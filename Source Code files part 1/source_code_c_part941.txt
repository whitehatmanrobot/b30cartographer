 0xffffffff

#define TRACE0(szMsg)   dspDebugOut((DEB_ERROR, szMsg));

/////////////////////////////////////////////////////////////////////
//  DllScheduleDialog()
//
//  Wrapper to call the function LogonScheduleDialog() &
//  ConnectionScheduleDialog ().
//  The wrapper will load the library loghours.dll, export
//  the function LogonScheduleDialog() or
//  ConnectionScheduleDialog () and free the library.
//
//  INTERFACE NOTES
//  This routine has EXACTLY the same interface notes
//  as LogonScheduleDialog() & ConnectionScheduleDialog ().
//
//  The function launches either ConnectionScheduleDialog () or LogonScheduleDialog ()
//  depending on the ID of the title passed in.
//
//  HISTORY
//  21-Jul-97   t-danm      Creation.
//  3-4-98		bryanwal	Modification to launch different dialogs.
//
HRESULT
DllScheduleDialog(
    HWND hwndParent,
    BYTE ** pprgbData,
    int idsTitle,
    LPCTSTR pszName,
    LPCTSTR pszObjClass,
    DWORD dwFlags,
    ScheduleDialogType dlgtype );

/////////////////////////////////////////////////////////////////////
//  FIsValidUncPath()
//
//  Return TRUE if a UNC path is valid, otherwise return FALSE.
//
//  HISTORY
//  18-Aug-97   t-danm      Creation.
//
BOOL
FIsValidUncPath(
    LPCTSTR pszPath,    // IN: Path to validate
    UINT uFlags);        // IN: Validation flags


/////////////////////////////////////////////////////////////////////
//  DSPROP_IsValidUNCPath()
//
//  Exported (UNICODE ONLY) entry point to call FIsValidUncPath()
//  for use in DS Admin
//
BOOL DSPROP_IsValidUNCPath(LPCWSTR lpszPath);


//+----------------------------------------------------------------------------
//
//  User Profile Page
//
//-----------------------------------------------------------------------------

#define COMBO_Z_DRIVE   22

static const PWSTR wzProfilePath  = L"profilePath";      // ADSTYPE_CASE_IGNORE_STRING

static const PWSTR wzScriptPath   = L"scriptPath";       // ADSTYPE_CASE_IGNORE_STRING

static const PWSTR wzHomeDir      = L"homeDirectory";    // ADSTYPE_CASE_IGNORE_STRING

static const PWSTR wzHomeDrive    = L"homeDrive";        // ADSTYPE_CASE_IGNORE_STRING


DWORD 
AddFullControlForUser(IN PSID pUserSid, IN LPCWSTR lpszPathName);

#endif // DSADMIN


#endif // __UACCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\user.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       user.cxx
//
//  Contents:   
//
//  History:    05-May-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"
#include "user.h"
#include "group.h"
#include "qrybase.h"
#ifndef UNICODE
#   include <stdio.h>
#endif

//+----------------------------------------------------------------------------
//
//  Function:   CountryCode
//
//  Synopsis:   Handles the Country combo box to get/set the Country-Code
//              (LDAP display name: countryCode) numeric ISO-3166 code.
//
//  Notes:      This attr function MUST be called after CountryName. It
//              relies on CountryName populating the combobox and setting its
//              item data values.
//
//-----------------------------------------------------------------------------
HRESULT
CountryCode(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    switch(DlgOp)
    {
    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        DBG_OUT("CountryCode: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        int iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                           CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            INT_PTR pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                              CB_GETITEMDATA, iSel, 0);
            if (pCur == LB_ERR)
            {
                DWORD dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }

            PDsCountryCode pCountryCode = (PDsCountryCode)pCur;

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->Integer = pCountryCode->wCode;
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CountryName
//
//  Synopsis:   Handles the Country combo box/static control to get/set the
//              Country-Name (LDAP display name: c) 2 character ISO-3166 code.
//
//  Notes:      If the control is read-only, then assume it is a static text
//              control (or a read-only edit control) rather than a combobox.
//              Also, if read-only, then only the fInit should be called.
//
//-----------------------------------------------------------------------------
HRESULT
CountryName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    PWSTR pwsz = NULL;
    DWORD dwErr = 0;
    INT_PTR pCur = NULL;
    PDsCountryCode pCountryCode = NULL;
    int iSel = 0, iCur = -1, cxExtent = 0;
#ifdef UNICODE
    CStrW strFirstCode, strLastCode, strCodeLine, strCurName;
#else
    CStr strFirstCode, strLastCode, strCodeLine, strCurName;
#endif
    CStrW str2CharAbrev;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (!pAttrMap->fIsReadOnly && !PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID),
                         FALSE);
        }
		// fall through...
    case fObjChanged:
      {
        DBG_OUT("CountryName: fInit");
        PTSTR ptzFullName = NULL;
        WORD wCode = 0;
        HDC hDC = NULL;
        unsigned long ulFirstCode, ulLastCode, i;

        strFirstCode.LoadString(g_hInstance, IDS_FIRST_COUNTRY_CODE);
        strLastCode.LoadString(g_hInstance, IDS_LAST_COUNTRY_CODE);

        if (strFirstCode.IsEmpty() || strLastCode.IsEmpty())
        {
            ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        ulFirstCode = _tcstoul(strFirstCode, NULL, 10);
        ulLastCode = _tcstoul(strLastCode, NULL, 10);

        if (!pAttrMap->fIsReadOnly)
        {
            hDC = GetDC(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
        }

        PWSTR pwzCurCode;

        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            pwzCurCode = pAttrInfo->pADsValues->CaseIgnoreString;
        }
        else
        {
            pwzCurCode = NULL;
        }

        for (i = ulFirstCode; i <= ulLastCode; i++)
        {
            strCodeLine.LoadString(g_hInstance, i);

            if (strCodeLine.IsEmpty())
            {
                ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if (!GetALineOfCodes(strCodeLine.GetBuffer(1), &ptzFullName, str2CharAbrev, &wCode))
            {
                ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if (!pAttrMap->fIsReadOnly)
            {
                // If not in read-only mode, then we use a combobox from which
                // the user selects the country.
                // Insert the full name into the combobox list.
                //
                SIZE s;
                if (hDC != NULL)
                {
                  GetTextExtentPoint32(hDC, ptzFullName, static_cast<int>(_tcslen(ptzFullName)), &s);

                  if (s.cx > cxExtent)
                  {
                      cxExtent = s.cx;
                  }

                  iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                                 CB_ADDSTRING, 0, (LPARAM)ptzFullName);

                  if (iSel < 0)
                  {
                      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
                  }

                  //
                  // Add the name codes as item data.
                  //
                  pCountryCode = new DsCountryCode;

                  CHECK_NULL_REPORT(pCountryCode, pPage->GetHWnd(), return E_OUTOFMEMORY);

                  wcscpy(pCountryCode->pwz2CharAbrev, str2CharAbrev);

                  pCountryCode->wCode = wCode;

                  if (SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                         CB_SETITEMDATA, iSel,
                                         (LPARAM)pCountryCode) == CB_ERR)
                  {
                      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
                  }
                }
            }
            //
            // See if the current country matches that saved on the DS object
            // (if one has been saved).
            //
            if (pwzCurCode)
            {
                if (_wcsicmp(pwzCurCode, str2CharAbrev) == 0)
                {
                    iCur = iSel;
                    strCurName = ptzFullName;
                }
            }

            if ((iCur == iSel) && pAttrMap->fIsReadOnly)
            {
                // Read-only mode means that we are using a static text
                // control. Insert the full name into the control.
                //
                SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptzFullName);
                break;
            }

            if (pAttrMap->fIsReadOnly)
            {
                iSel++;
            }
        }

        if (!pAttrMap->fIsReadOnly)
        {
          if (hDC != NULL)
          {
            ReleaseDC(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), hDC);
          }
          SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                             CB_SETHORIZONTALEXTENT, (WPARAM)cxExtent, 0);
          if (iCur >= 0)
          {
            iCur = (int) SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_FINDSTRINGEXACT, 0,
                                      (WPARAM)(LPCTSTR)strCurName);
            dspAssert(iCur != CB_ERR);
            SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                               CB_SETCURSEL, iCur, 0);
          }
        }
        else
        {
          if (iCur < 0)
          {
            // If iCur is still -1, then country code hasn't been set.
            //
            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, TEXT(""));
          }
        }
        break;
      }
    case fApply:
        DBG_OUT("CountryName: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                       CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_GETITEMDATA, iSel, 0);
            if (pCur == LB_ERR)
            {
                dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }

            pCountryCode = (PDsCountryCode)pCur;

            if (!AllocWStr(pCountryCode->pwz2CharAbrev, &pwsz))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
            }

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->CaseIgnoreString = pwsz;
        }
        break;

    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fOnDestroy:
        DBG_OUT("CountryName: fOnDestroy");
        iSel = 0;
        do
        {
            pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_GETITEMDATA, iSel, 0);
            if (pCur != CB_ERR)
            {
                // Delete the itemdata string.
                //
                delete (PDsCountryCode)pCur;

                iSel++;
            }
        } while (pCur != CB_ERR);
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TextCountry
//
//  Synopsis:   Handles the Country combo box to get/set the Text-Country
//              (LDAP display name: co) 
//
//  Notes:      This attr function MUST be called after CountryName. It
//              relies on CountryName populating the combobox
//
//-----------------------------------------------------------------------------
HRESULT
TextCountry(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    switch(DlgOp)
    {
    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        DBG_OUT("TextCountry: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        int iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                           CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {   
            LPTSTR ptz = new TCHAR[pAttrMap->nSizeLimit + 1];
            CHECK_NULL_REPORT(ptz, pPage->GetHWnd(), return E_OUTOFMEMORY);

            INT_PTR pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                              CB_GETLBTEXT, iSel, (LPARAM) (LPCSTR) ptz );
            if (pCur == LB_ERR)
            {
                delete ptz;
                DWORD dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }
            
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            if( pADsValue == NULL )
            {
              ReportError(E_OUTOFMEMORY,0, pPage->GetHWnd()); 
              delete ptz;
              return E_OUTOFMEMORY;
            }

            
            if (!TcharToUnicode(ptz, &pADsValue->CaseIgnoreString))
            {
              delete[] ptz;
              delete pADsValue;
              REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
              return E_OUTOFMEMORY;
            }

            delete[] ptz;
    
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            
        }
        break;
    }

    return S_OK;
}

// CountryName helpers:

//+----------------------------------------------------------------------------
//
//  Function:   GetALineOfCodes
//
//  Synopsis:   Parse a line of country codes.
//
//-----------------------------------------------------------------------------
BOOL GetALineOfCodes(PTSTR ptzLine, PTSTR * pptzFullName,
                     CStrW & str2CharAbrev, LPWORD pwCode)
{
    //
    // The line is parsed from end to beginning. That way we don't need to
    // dependend on the column widths being fixed.
    //
    // The last token is the numeric code. Read it.
    //
    RemoveTrailingWhitespace(ptzLine);

    PTSTR ptzCode = _tcsrchr(ptzLine, TEXT(' '));

    if (!ptzCode)
    {
        // try tab char.
        //
        ptzCode = _tcsrchr(ptzLine, TEXT('\t'));
    }

    if (!ptzCode || (ptzCode <= ptzLine) || (_tcslen(ptzCode) < 2))
    {
        return FALSE;
    }

    *ptzCode = TEXT('\0');

    ptzCode++;

    int iScanned = _stscanf(ptzCode, TEXT("%u"), pwCode);
    dspAssert(iScanned == 1);

    //
    // The next to last token is the 3 character code. Skip it.
    //
    RemoveTrailingWhitespace(ptzLine);

    size_t nLen = _tcslen(ptzLine);

    if (3 >= nLen)
    {
        return FALSE;
    }

    ptzLine[nLen - 3] = TEXT('\0');

    //
    // The next token (moving toward the front) is the 2 character code.
    //
    RemoveTrailingWhitespace(ptzLine);

    PTSTR ptz2CharAbrev = _tcsrchr(ptzLine, TEXT(' '));

    if (!ptz2CharAbrev)
    {
        // try tab char.
        //
        ptz2CharAbrev = _tcsrchr(ptzLine, TEXT('\t'));
    }

    if (!ptz2CharAbrev || (ptz2CharAbrev <= ptzLine))
    {
        return FALSE;
    }

    *ptz2CharAbrev = TEXT('\0');

    ptz2CharAbrev++;

    if (_tcslen(ptz2CharAbrev) != 2)
    {
        return FALSE;
    }

    str2CharAbrev = ptz2CharAbrev;

    //
    // The first token is the full country name.
    //
    RemoveTrailingWhitespace(ptzLine);

    if (!_tcslen(ptzLine))
    {
        return FALSE;
    }

    *pptzFullName = ptzLine;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTrailingWhitespace
//
//  Synopsis:   Trailing white space is replaced by NULLs.
//
//-----------------------------------------------------------------------------
void RemoveTrailingWhitespace(PTSTR ptz)
{
    size_t nLen = _tcslen(ptz);

    while (nLen)
    {
        if (!iswspace(ptz[nLen - 1]))
        {
            return;
        }
        ptz[nLen - 1] = L'\0';
        nLen--;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   ManagerEdit
//
//  Synopsis:   Handles the manager edit control.
//
//  Notes:      The page member m_pData stores the pAttrData value whose pVoid
//              element is set to the DN of the manager. The other manager
//              attr functions can then access the manager value and can also
//              read the fWritable element.
//
//-----------------------------------------------------------------------------
HRESULT
ManagerEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    PWSTR pwz = NULL;
    PWSTR canonical = NULL;
    HRESULT hr = S_OK;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (pAttrInfo && pAttrInfo->dwNumValues > 0)
        {
            if (!AllocWStr(pAttrInfo->pADsValues[0].DNString, &pwz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }
            hr = CrackName (pwz, &canonical, GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());
            if (FAILED(hr))
            {
                delete pwz;
                return S_FALSE;
            }
            PTSTR ptz, ptzName;
            if (!UnicodeToTchar(canonical, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                delete pwz;
                return E_OUTOFMEMORY;
            }
            LocalFreeStringW(&canonical);
            ptzName = _tcschr(ptz, TEXT('\n'));
            dspAssert(ptzName);
            ptzName++;
            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptzName);
            delete ptz;
        }
        pAttrData->pVoid = reinterpret_cast<LPARAM>(pwz);
        ((CDsTableDrivenPage *)pPage)->m_pData = reinterpret_cast<LPARAM>(pAttrData);
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        pwz = (PWSTR)reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData)->pVoid;

        if (pwz)
        {
            // make a copy cause CDsTableDrivenPage::OnApply deletes it.
            PWSTR pwzTmp;
            if (!AllocWStr(pwz, &pwzTmp))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
      
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->CaseIgnoreString = pwzTmp;
        }
        else
        {
            pAttrInfo->pADsValues = NULL;
            pAttrInfo->dwNumValues = 0;
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        break;

    case fOnDestroy:
        if (reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData)
        {
            PATTR_DATA pData = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
            PVOID pVoid = reinterpret_cast<PVOID>(pData->pVoid);
            DO_DEL(pVoid);
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   DirectReportsList
//
//  Synopsis:   Handles the User Organisation Direct Reports list.
//
//-----------------------------------------------------------------------------
HRESULT
DirectReportsList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA,
                  DLG_OP DlgOp)
{
  //
  // Multi-select will result in a return at this point
  //
  if (pPage->GetObjPathName() == NULL)
  {
    return S_OK;
  }

  switch (DlgOp)
  {
    case fInit:
      {
        HRESULT hr;
        Smart_PADS_ATTR_INFO spAttrs;
        DWORD cAttrs = 0;
        PWSTR rgpwzAttrNames[] = {pAttrMap->AttrInfo.pszAttrName};
        CComPtr <IDirectoryObject> spGcObj;

        hr = BindToGCcopyOfObj(pPage, pPage->GetObjPathName(), &spGcObj);

        if (SUCCEEDED(hr))
        {
          hr = spGcObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

          if (SUCCEEDED(hr))
          {
            //
            // If the bind to the GC was successful, use those results.
            // Otherwise, use the results of the local object read.
            //
            if (!cAttrs)
            {
              return S_OK;
            }
            pAttrInfo = spAttrs;
          }
        }

        if (!pAttrInfo)
        {
          return S_OK;
        }

        for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
        {
          PWSTR pwzDns;
          hr = CrackName(pAttrInfo->pADsValues[i].DNString, &pwzDns,
                         GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());

          CHECK_HRESULT(hr, return hr);

          PTSTR ptz, ptzName;
          if (!UnicodeToTchar(pwzDns, &ptz))
          {
            LocalFreeStringW(&pwzDns);
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
          }
          LocalFreeStringW(&pwzDns);
          ptzName = _tcschr(ptz, TEXT('\n'));
          dspAssert(ptzName);
          ptzName++;
          LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST, LB_ADDSTRING,
                                               0, (LPARAM)ptzName);
          if (lresult != LB_ERR)
          {
            PWSTR pwzDN = new WCHAR[wcslen(pAttrInfo->pADsValues[i].DNString) + 1];
            if (pwzDN != NULL)
            {
              wcscpy(pwzDN, pAttrInfo->pADsValues[i].DNString);
              SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                 LB_SETITEMDATA, lresult, (LPARAM)pwzDN);
            }
          }
          delete ptz;
        }
      }
      break;
    
    case fOnCommand:
      {
        if (lParam == LBN_DBLCLK)
        {
          //
          // Retrieve the current selection
          //
          PWSTR pwzDN = NULL;
          LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                               LB_GETCURSEL, 0, 0);

          if (lresult != LB_ERR)
          {
            //
            // Get the DN associated with the item
            //
            lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                         LB_GETITEMDATA, lresult, 0);
            if (lresult != LB_ERR)
            {
              pwzDN = (PWSTR)lresult;
              if (pwzDN != NULL)
              {
                //
                // Launch the secondary proppages
                //
                PostPropSheet(pwzDN, pPage);
              }
            }
          }
        }
      }
      break;
    
    case fOnDestroy:
      {
        //
        // Must free the memory associated with the list box
        //
        LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                             LB_GETCOUNT, 0, 0);
        if (lresult != LB_ERR)
        {
          for (LRESULT idx = lresult - 1 ; idx >= 0; idx--)
          {
            lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                         LB_GETITEMDATA, idx, 0);
            if (lresult != LB_ERR)
            {
              PWSTR pwzDN = (PWSTR)lresult;
              if (pwzDN != NULL)
              {
                delete[] pwzDN;
              }
            }
          }
        }
      }
      break;

    default:
      break;
  }

  return S_OK;
}

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Function:   ExpandUsername
//
//  Synopsis:   Substitutes the SAM account name for the %username%
//
//  Notes:      
//
//-----------------------------------------------------------------------------
BOOL ExpandUsername(PWSTR& pwzValue, PWSTR pwzSamName, BOOL& fExpanded)
{
  dspAssert(pwzValue);

  CStrW strUserToken;

  strUserToken.LoadString(g_hInstance, IDS_PROFILE_USER_TOKEN);

  unsigned int TokenLength = strUserToken.GetLength();

  if (!TokenLength)
  {
    return FALSE;
  }

  if (!pwzSamName)
  {
    return FALSE;
  }

  PWSTR pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

  if (pwzTokenStart)
  {
    if ((wcslen(pwzTokenStart) >= TokenLength) &&
        (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0))
    {
      fExpanded = TRUE;
    }
    else
    {
      fExpanded = FALSE;
      return TRUE;
    }
  }
  else
  {
    fExpanded = FALSE;
    return TRUE;
  }

  CStrW strValue, strAfterToken;

  while (pwzTokenStart)
  {
    *pwzTokenStart = L'\0';

    strValue = pwzValue;

    if ((L'\0' != *pwzValue) && !strValue.GetLength())
    {
      return FALSE;
    }

    PWSTR pwzAfterToken = pwzTokenStart + TokenLength;

    strAfterToken = pwzAfterToken;

    if ((L'\0' != *pwzAfterToken) && !strAfterToken.GetLength())
    {
      return FALSE;
    }

    delete pwzValue;

    strValue += pwzSamName;

    if (!strValue.GetLength())
    {
      return FALSE;
    }

    strValue += strAfterToken;

    if (!strValue.GetLength())
    {
      return FALSE;
    }

    if (!AllocWStr((PWSTR)(LPCWSTR)strValue, &pwzValue))
    {
      return FALSE;
    }

    pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

    if (!(pwzTokenStart &&
          (wcslen(pwzTokenStart) >= TokenLength) &&
          (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0)))
    {
      return TRUE;
    }
  }

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   MailAttr
//
//  Synopsis:   Handles the mail edit control.
//
//  Notes:      Manages inter-page communications/attribute syncronization of
//              the mail attribute.
//
//-----------------------------------------------------------------------------
HRESULT
MailAttr(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
         LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
  PWSTR pwz = NULL;
  dspAssert(pAttrData);
  int cch;

  switch (DlgOp)
  {
    case fInit:
      if (pAttrInfo && pAttrInfo->pADsValues && pAttrInfo->pADsValues->CaseIgnoreString)
      {
        SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID,
                       pAttrInfo->pADsValues->CaseIgnoreString);
      }
      if (!PATTR_DATA_IS_WRITABLE(pAttrData))
      {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
      }
      break;

    case fOnCommand:
      if (EN_CHANGE == lParam)
      {
        pPage->SetDirty();
        PATTR_DATA_SET_DIRTY(pAttrData);
      }
      break;

    case fApply:
      if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
      {
        return ADM_S_SKIP;
      }

      SendMessage(GetParent(pPage->GetHWnd()), PSM_QUERYSIBLINGS,
                  (WPARAM)pAttrMap->AttrInfo.pszAttrName,
                  (LPARAM)pPage->GetHWnd());

      cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                    WM_GETTEXTLENGTH, 0, 0);
      if (cch)
      {
        cch++;
        pwz = new WCHAR[cch];
        CHECK_NULL_REPORT(pwz, pPage->GetHWnd(), return E_OUTOFMEMORY);

        GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwz, cch);
      }
      if (pwz)
      {
        BOOL fExpanded = FALSE;
        PWSTR pwzSamName = reinterpret_cast<PWSTR>(lParam);
        ExpandUsername(pwz, pwzSamName, fExpanded);

        if (!FValidSMTPAddress(pwz))
        {
          ErrMsg(IDS_INVALID_MAIL_ADDR, pPage->GetHWnd());
          delete [] pwz;
          return E_FAIL;
        }
        PADSVALUE pADsValue;
        pADsValue = new ADSVALUE;
        CHECK_NULL(pADsValue, return E_OUTOFMEMORY);

        pAttrInfo->pADsValues = pADsValue;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        pADsValue->dwType = pAttrInfo->dwADsType;
        pADsValue->CaseIgnoreString = pwz;
      }
      else
      {
        pAttrInfo->pADsValues = NULL;
        pAttrInfo->dwNumValues = 0;
        pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
      }
      break;

    case fOnSetActive:
      dspDebugOut((DEB_ITRACE,
                  "(HWND: %08x) got PSN_SETACTIVE, sending PSM_QUERYSIBLINGS.\n",
                  pPage->GetHWnd()));
      SendMessage(GetParent(pPage->GetHWnd()), PSM_QUERYSIBLINGS,
                  (WPARAM)pAttrMap->AttrInfo.pszAttrName,
                  (LPARAM)pPage->GetHWnd());
      break;

    case fOnKillActive:
      //
      // Validate the entry if the focus is lost.
      //
      if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
      {
        return ADM_S_SKIP;
      }

      cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                    WM_GETTEXTLENGTH, 0, 0);
      if (cch)
      {
        cch++;
        pwz = new WCHAR[cch];
        CHECK_NULL_REPORT(pwz, pPage->GetHWnd(), return E_OUTOFMEMORY);

        GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwz, cch);
      }
      if (pwz)
      {
        if (!FValidSMTPAddress(pwz))
        {
          ErrMsg(IDS_INVALID_MAIL_ADDR, pPage->GetHWnd());
          delete [] pwz;
          SetFocus(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
          return PSNRET_INVALID_NOCHANGEPAGE;
        }
        else
        {
          delete [] pwz;
        }
      }
      break;

    case fQuerySibling:
      //
      // lParam == the HWND of the sending window.
      // pAttrInfo == the name of the attribute whose status is sought.
      //
  #if DBG == 1
      char szBuf[100];
      strcpy(szBuf, "(HWND: %08x) got PSM_QUERYSIBLINGS for '%ws'");
  #endif
      if ((HWND)lParam != pPage->GetHWnd())
      {
        if (PATTR_DATA_IS_DIRTY(pAttrData) && pAttrInfo &&
            _wcsicmp((PWSTR)pAttrInfo, pAttrMap->AttrInfo.pszAttrName) == 0)
        {
  #if DBG == 1
          strcat(szBuf, " sending DSPROP_ATTRCHANGED_MSG");
  #endif
          ADS_ATTR_INFO Attr;
          ADSVALUE ADsValue;

          cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                        WM_GETTEXTLENGTH, 0, 0);
          pwz = new WCHAR[++cch];
          CHECK_NULL_REPORT(pwz, pPage->GetHWnd(), return E_OUTOFMEMORY);

          Attr.dwNumValues = 1;
          Attr.pszAttrName = pAttrMap->AttrInfo.pszAttrName;
          Attr.pADsValues = &ADsValue;
          Attr.pADsValues->dwType = pAttrMap->AttrInfo.dwADsType;
          Attr.pADsValues->CaseIgnoreString = pwz;

          GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID,
                         Attr.pADsValues->CaseIgnoreString, cch);

          SendMessage((HWND)lParam, g_uChangeMsg, (WPARAM)&Attr, 0);

          delete[] pwz;
        }
      }
  #if DBG == 1
      else
      {
        strcat(szBuf, " (it was sent by this page!)");
      }
      strcat(szBuf, "\n");
      dspDebugOut((DEB_ITRACE, szBuf, pPage->GetHWnd(), pAttrInfo));
  #endif
        break;

    case fAttrChange:
      //
      // pAttrInfo == the PADS_ATTR_INFO struct for the changed attribute.
      //
      dspAssert(pAttrInfo && pAttrInfo->pszAttrName && pAttrInfo->pADsValues &&
                pAttrInfo->pADsValues->CaseIgnoreString);
      dspDebugOut((DEB_ITRACE,
                   "(HWND: %08x) got DSPROP_ATTRCHANGED_MSG for '%ws'.\n",
                   pPage->GetHWnd(), pAttrInfo->pszAttrName));
      if (_wcsicmp(pAttrInfo->pszAttrName, pAttrMap->AttrInfo.pszAttrName) == 0)
      {
        SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID,
                       pAttrInfo->pADsValues->CaseIgnoreString);
      }
      break;

    case fOnDestroy:
      break;
  }

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ManagerChangeBtn
//
//  Synopsis:   Handles the User Organization page change manager button.
//
//-----------------------------------------------------------------------------
HRESULT
ManagerChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                 PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
                 DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        PATTR_DATA pad = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
        dspAssert(pad);
        if (!PATTR_DATA_IS_WRITABLE(pad))
        {
          EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
        return S_OK;
    }
    if (!(DlgOp == fOnCommand && lParam == BN_CLICKED))
    {
        return S_OK;
    }
    HRESULT hr = S_OK;
    PWSTR cleanstr, canonical;
    CWaitCursor WaitCursor;
    IDsObjectPicker * pObjSel;
    BOOL fIsObjSelInited;

    hr = pPage->GetObjSel(&pObjSel, &fIsObjSelInited);

    CHECK_HRESULT(hr, return hr);

    if (!fIsObjSelInited)
    {
        CStrW cstrDC;
        CComPtr<IDirectoryObject> spDsObj;
        if (pPage->m_pDsObj == NULL)
        {
          //
          // For the retrieval of the DS Object names
          //
          FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM objMedium;
          hr = pPage->m_pWPTDataObj->GetData(&fmte, &objMedium);
          CHECK_HRESULT(hr, return hr);

          LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

          //
          // Get the objects path 
          //
          LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                                   pDsObjectNames->aObjects[0].offsetName);

          //
          // Bind to the object
          //
          hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, 
                             IID_IDirectoryObject, (PVOID*)&spDsObj);
          CHECK_HRESULT(hr, return hr);
        }
        else
        {
          spDsObj = pPage->m_pDsObj;
        }
        hr = GetLdapServerName(spDsObj, cstrDC);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        DSOP_SCOPE_INIT_INFO rgScopes[3];
        DSOP_INIT_INFO InitInfo;

        ZeroMemory(rgScopes, sizeof(rgScopes));
        ZeroMemory(&InitInfo, sizeof(InitInfo));

        rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
        rgScopes[0].pwzDcName = cstrDC;
        rgScopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        rgScopes[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        rgScopes[2].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
        InitInfo.cDsScopeInfos = 3;
        InitInfo.aDsScopeInfos = rgScopes;
        InitInfo.pwzTargetComputer = cstrDC;

        hr = pObjSel->Initialize(&InitInfo);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        pPage->ObjSelInited();
    }

    IDataObject * pdoSelections = NULL;

    hr = pObjSel->InvokeDialog(pPage->GetHWnd(), &pdoSelections);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    if (hr == S_FALSE || !pdoSelections)
    {
        return S_OK;
    }

    FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

    hr = pdoSelections->GetData(&fmte, &medium);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

    if (!pSelList || !pSelList->cItems || !pSelList->aDsSelection->pwzADsPath)
    {
        return S_OK;
    }

    WaitCursor.SetWait();

    hr = pPage->SkipPrefix(pSelList->aDsSelection->pwzADsPath, &cleanstr);

    GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    pdoSelections->Release();

    if (FAILED(hr))
    {
        return hr;
    }

    PATTR_DATA pData = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
    if (pData != NULL)
    {
      PVOID pVoid = reinterpret_cast<PVOID>(pData->pVoid);
      if (pVoid != NULL)
      {
        DO_DEL(pVoid);
      }
      pData->pVoid = reinterpret_cast<LPARAM>(cleanstr);
    }

    hr = CrackName(cleanstr, &canonical, GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());

    if (FAILED(hr))
    {
        return hr;
    }
    PTSTR ptz, ptzName;
    if (!UnicodeToTchar(canonical, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        LocalFreeStringW(&canonical);
        return E_OUTOFMEMORY;
    }
    LocalFreeStringW(&canonical);
    ptzName = _tcschr(ptz, TEXT('\n'));
    dspAssert(ptzName);
    ptzName++;

    SetDlgItemText(pPage->GetHWnd(), IDC_MANAGER_EDIT, ptzName);

    delete ptz;

    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_PROPPAGE_BTN), TRUE);
    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_MGR_CLEAR_BTN), TRUE);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   MgrPropBtn
//
//  Synopsis:   Handles the User Organisation page Manager Properties button.
//
//-----------------------------------------------------------------------------
HRESULT
MgrPropBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
           DLG_OP DlgOp)
{
    PATTR_DATA pad = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
    PWSTR pwzManager = NULL;
    if (pad)
    {
        pwzManager = (PWSTR)pad->pVoid;
    }

    if (DlgOp == fInit)
    {
        dspAssert(pad);
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID),
                     pwzManager != NULL);
        return S_OK;
    }
    if (!(DlgOp == fOnCommand && lParam == BN_CLICKED))
    {
        return S_OK;
    }

    dspAssert(pwzManager);

    return PostPropSheet(pwzManager, pPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   ClearMgrBtn
//
//  Synopsis:   Handles the User Organisation page Clear Manager button.
//
//-----------------------------------------------------------------------------
HRESULT
ClearMgrBtn(CDsPropPageBase * pPage, PATTR_MAP,
            PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
            DLG_OP DlgOp)
{
    PATTR_DATA pad = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
    PWSTR pwzManager = NULL;
    if (pad)
    {
        pwzManager = (PWSTR)pad->pVoid;
    }

    if (DlgOp == fInit)
    {
        dspAssert(pad);
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_MGR_CLEAR_BTN),
                     (pwzManager != NULL) && PATTR_DATA_IS_WRITABLE(pad));
        return S_OK;
    }
    if (!(DlgOp == fOnCommand && lParam == BN_CLICKED))
    {
        return S_OK;
    }

    dspAssert(pwzManager);

    SetDlgItemText(pPage->GetHWnd(), IDC_MANAGER_EDIT, TEXT(""));

    if (pad)
    {
        PVOID pVoid = reinterpret_cast<PVOID>(pad->pVoid);
        if (pVoid != NULL)
        {
            DO_DEL(pVoid);
        }
        pad->pVoid = NULL;
    }

    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_PROPPAGE_BTN), FALSE);
    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_MGR_CLEAR_BTN), FALSE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   AddReportsBtn
//
//  Synopsis:   Handles the User Organisation page Add Direct Reports button.
//
//-----------------------------------------------------------------------------
HRESULT
AddReportsBtn(CDsPropPageBase * pPage, PATTR_MAP,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_ADD_BTN), FALSE);
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   RmReportsBtn
//
//  Synopsis:   Handles the User Organisation page Remove Direct Reports button.
//
//-----------------------------------------------------------------------------
HRESULT
RmReportsBtn(CDsPropPageBase * pPage, PATTR_MAP,
             PADS_ATTR_INFO, LPARAM, PATTR_DATA,
             DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_REMOVE_BTN), FALSE);
    }
    return S_OK;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\usercert.h ===
//+----------------------------------------------------------------------------
//
//  Class:      CDsUserCertPage
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       UserCert.h
//
//  Contents:   DS user object property pages header
//
//  Classes:    CDsUserCertPage
//
//  History:    12-November-97 BryanWal created
//
//-----------------------------------------------------------------------------

#ifndef _USERCERT_H_
#define _USERCERT_H_
#include "proppage.h"
#include <wincrypt.h>
#include <cryptui.h>
#include "certifct.h"

enum {
	CERTCOL_ISSUED_TO = 0,
	CERTCOL_ISSUED_BY,
	CERTCOL_PURPOSES,
	CERTCOL_EXP_DATE
};

HRESULT CreateUserCertPage(PDSPAGE, LPDATAOBJECT, PWSTR,
                           PWSTR, HWND, DWORD, 
                           CDSBasePathsInfo* pBasePathsInfo,
                           HPROPSHEETPAGE *);
//
//  Purpose:    property page object class for the User Certificates page.
//
//-----------------------------------------------------------------------------
class CDsUserCertPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsUserCertPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                    DWORD dwFlags);
    virtual ~CDsUserCertPage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
	CRYPTUI_SELECTCERTIFICATE_STRUCT m_selCertStruct;
	HBITMAP		m_hbmCert;
	HIMAGELIST	m_hImageList;
	int			m_nCertImageIndex;
	HRESULT AddListViewColumns ();
	HCERTSTORE m_hCertStore;
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnDestroy(void);

protected:
	int MessageBox (int caption, int text, UINT flags);
	HRESULT AddCertToStore (PCCERT_CONTEXT pCertContext);
	void OnNotifyItemChanged (LPNMLISTVIEW pnmv);
	void OnNotifyStateChanged (LPNMLVODSTATECHANGE pStateChange);
	void EnableControls ();
	void DisplaySystemError (DWORD dwErr, int iCaptionText);
	HRESULT InsertCertInList (CCertificate* pCert, int nItem);
	void RefreshItemInList (CCertificate * pCert, int nItem);
	CCertificate* GetSelectedCertificate (int& nSelItem);
	HRESULT PopulateListView ();
	virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
	HRESULT	OnDeleteItemCertList (LPNMLISTVIEW pNMListView);
	HRESULT OnColumnClickCertList (LPNMLISTVIEW pNMListView);
	HRESULT OnDblClkCertList (LPNMHDR pNMHdr);
	HRESULT OnClickedCopyToFile ();
	HRESULT OnClickedRemove();
	HRESULT OnClickedAddFromFile();
	HRESULT OnClickedAddFromStore ();
	HRESULT OnClickedViewCert ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\usercert.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       UserCert.cxx
//
//  Contents:   
//
//  History:    12-November-97 BryanWal created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "commdlg.h"
#include "UserCert.h"
#include "pages.h"
#include "proppage.h"
#include "crtdbg.h"
#include "certifct.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserCertPage::CDsUserCertPage
//
//-----------------------------------------------------------------------------
CDsUserCertPage::CDsUserCertPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                 HWND hNotifyObj, DWORD dwFlags) 
	: CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags),
	m_hCertStore (0),
	m_hImageList (0),
	m_hbmCert (0),
	m_nCertImageIndex (0)
{
    TRACE(CDsUserCertPage,CDsUserCertPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsUserCertPage");
#endif

	::ZeroMemory (&m_selCertStruct, sizeof (m_selCertStruct));
}


//+----------------------------------------------------------------------------
//
//  Member:     CDsUserCertPage::~CDsUserCertPage
//
//-----------------------------------------------------------------------------
CDsUserCertPage::~CDsUserCertPage()
{
    TRACE(CDsUserCertPage,~CDsUserCertPage);

	// Clean up enumerated store list
	for (DWORD dwIndex = 0; dwIndex < m_selCertStruct.cDisplayStores; dwIndex++)
	{
		dspAssert (m_selCertStruct.rghDisplayStores);
		::CertCloseStore (m_selCertStruct.rghDisplayStores[dwIndex], CERT_CLOSE_STORE_FORCE_FLAG);
	}
	if ( m_selCertStruct.rghDisplayStores )
		delete [] m_selCertStruct.rghDisplayStores;


	if ( m_hbmCert )
		DeleteObject (m_hbmCert);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUserCertPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT CreateUserCertPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                             PWSTR pwzADsPath, PWSTR pwzClass,
                             HWND hNotifyObj, DWORD dwFlags,
                             CDSBasePathsInfo* pBasePathsInfo,
                             HPROPSHEETPAGE *phPage)
{
    TRACE_FUNCTION(CreateUserCertPage);

    CDsUserCertPage * pPageObj = new CDsUserCertPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::DlgProc(HWND /*hDlg*/, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}


typedef struct _ENUM_ARG {
    DWORD				dwFlags;
    DWORD*              pcDisplayStores;          
    HCERTSTORE **       prghDisplayStores;        
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumStoresSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD /*dwFlags*/,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void * /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
	void*		pvPara = (void*)pwszSystemStore;



	HCERTSTORE	hNewStore  = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
				CERT_SYSTEM_STORE_CURRENT_USER, pvPara);
	if ( !hNewStore )
	{
		hNewStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
				CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG, pvPara);
	}
	if ( hNewStore )
	{
		DWORD		dwCnt = *(pEnumArg->pcDisplayStores);
		HCERTSTORE*	phStores = 0;

		phStores = new HCERTSTORE[dwCnt+1];
		if ( phStores )
		{
			DWORD	dwIndex = 0;
			if ( *(pEnumArg->prghDisplayStores) )
			{
				for (; dwIndex < dwCnt; dwIndex++)
				{
					phStores[dwIndex] = (*(pEnumArg->prghDisplayStores))[dwIndex];
				}
				delete [] (*(pEnumArg->prghDisplayStores));
			}
			(*(pEnumArg->pcDisplayStores))++;
			(*(pEnumArg->prghDisplayStores)) = phStores;
			(*(pEnumArg->prghDisplayStores))[dwIndex] = hNewStore;
		}
		else
		{
			SetLastError (ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}
	}

    return TRUE;
}



//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsUserCertPage::OnInitDialog(LPARAM /*lParam*/)
{
    TRACE(CDsUserCertPage,OnInitDialog);
    HRESULT hResult = S_OK;
    CWaitCursor WaitCursor;
	const	LPWSTR	CERT_PROPERTY_NAME = L"UserCertificate";

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

	// Get the object name and open its Published Certificate store
	LPCWSTR	pszObjName = GetObjPathName ();
	dspAssert (pszObjName);
	if ( pszObjName )
	{
		LPWSTR	pszHeader = L"LDAP://";
		size_t	ldapLen = wcslen (pszHeader);
		LPCWSTR	pszDN = pszObjName + ldapLen; 
		LPWSTR	pvPara = new WCHAR[ldapLen+1 + wcslen (pszDN) + 1 + 
					wcslen (CERT_PROPERTY_NAME) + 1];
		if ( pvPara )
		{
			wcscpy (pvPara, pszHeader);
			wcscat (pvPara, pszDN);
			wcscat (pvPara, _T("?"));
			wcscat (pvPara, CERT_PROPERTY_NAME);

			m_hCertStore = ::CertOpenStore ("LDAP",
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
				0,
				(void*) pvPara);
			if ( !m_hCertStore )
			{
                DWORD dwErr = GetLastError ();
				hResult = HRESULT_FROM_WIN32 (dwErr);
                if ( ERROR_ACCESS_DENIED == dwErr )
                {
       				MessageBox (IDS_USER_TITLE_PUBLISHED_CERTS, IDS_CANT_OPEN_STORE_OPEN_READ_ONLY,
    						MB_ICONINFORMATION | MB_OK);
                    
			        m_hCertStore = ::CertOpenStore ("LDAP",
				        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
				        CERT_STORE_READONLY_FLAG,
				        (void*) pvPara);
			        if ( m_hCertStore )
                    {
                        dwErr = 0;
                        hResult = S_OK;
				        ::EnableWindow (GetDlgItem (GetHWnd (), IDC_ADD_FROM_STORE), FALSE);
				        ::EnableWindow (GetDlgItem (GetHWnd (), IDC_ADD_FROM_FILE), FALSE);
                    }
                    else
			        {
                        dwErr = GetLastError ();
        				hResult = HRESULT_FROM_WIN32 (dwErr);
                    }
                }

                if ( FAILED (hResult) )
                {
                    DisplaySystemError (dwErr, IDS_CANT_OPEN_STORE);
				    ::EnableWindow (GetDlgItem (GetHWnd (), IDC_ADD_FROM_STORE), FALSE);
				    ::EnableWindow (GetDlgItem (GetHWnd (), IDC_ADD_FROM_FILE), FALSE);
                }
			}
		}
	}


	// Set up result list view
	COLORREF	crMask = RGB (255, 0, 255);
	m_hImageList = ImageList_Create (16, 16, ILC_MASK, 10, 10);
	dspAssert (m_hImageList);
	if ( m_hImageList )
	{
		m_hbmCert = ::LoadBitmap (g_hInstance, MAKEINTRESOURCE (IDB_CERTIFICATE));
		dspAssert (m_hbmCert);
		if ( m_hbmCert )
		{
			m_nCertImageIndex = ImageList_AddMasked (m_hImageList, m_hbmCert,
					crMask);
			dspAssert (m_nCertImageIndex != -1);
			if ( m_nCertImageIndex != -1 )
			{
				ListView_SetImageList (::GetDlgItem (GetHWnd (), IDC_CERT_LIST),
						m_hImageList, LVSIL_SMALL);		
			}
		}
	}


	hResult = AddListViewColumns ();
	if ( SUCCEEDED  (hResult) && m_hCertStore )
		hResult = PopulateListView ();

	EnableControls ();

	// Enumerate User's certificate stores for use in selecting certificates
	// from stores.
	ENUM_ARG	EnumArg;

	m_selCertStruct.dwSize = sizeof (CRYPTUI_SELECTCERTIFICATE_STRUCT);
	m_selCertStruct.hwndParent = GetHWnd ();
	EnumArg.pcDisplayStores = &m_selCertStruct.cDisplayStores;
	EnumArg.prghDisplayStores = &m_selCertStruct.rghDisplayStores;

	::CertEnumSystemStore (CERT_SYSTEM_STORE_CURRENT_USER, 0, &EnumArg, 
			EnumStoresSysCallback);

    return hResult;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::OnApply(void)
{
    TRACE(CDsUserCertPage,OnApply);
    HRESULT hResult = S_OK;
    CWaitCursor WaitCursor;

	if ( m_hCertStore )
	{
		BOOL	bResult = ::CertControlStore (m_hCertStore, 0, 
				CERT_STORE_CTRL_COMMIT, NULL);
		if ( !bResult )
		{

			DWORD	dwErr = GetLastError ();
			dspAssert (dwErr == ERROR_NOT_SUPPORTED);
			if ( dwErr != ERROR_NOT_SUPPORTED )
			{
				MessageBox (IDS_USER_TITLE_PUBLISHED_CERTS, IDS_CANT_SAVE_STORE,
						MB_ICONINFORMATION | MB_OK);
				hResult = E_FAIL;
			}
		}
	}

    return (SUCCEEDED(hResult)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    switch (codeNotify)
    {
	case BN_CLICKED:
		switch (id)
		{
		case IDC_VIEW_CERT:
			return OnClickedViewCert ();
			break;

		case IDC_ADD_FROM_STORE:
			return OnClickedAddFromStore ();
			break;

		case IDC_ADD_FROM_FILE:
			return OnClickedAddFromFile ();
			break;

		case IDC_REMOVE:
			return OnClickedRemove ();
			break;

		case IDC_COPY_TO_FILE:
			return OnClickedCopyToFile ();
			break;

		default:
			_ASSERT (0);
			return E_UNEXPECTED;
			break;
		}
		break;

	default:
        break;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnNotify
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
	LPNMHDR	pNMHdr = (LPNMHDR) lParam;
	_ASSERT (pNMHdr);
	if ( !pNMHdr )
		return E_POINTER;

	switch (pNMHdr->code)
	{
	case NM_DBLCLK:
        if (m_fInInit)
            return TRUE;
		else if ( wParam == IDC_CERT_LIST )
			return OnDblClkCertList (pNMHdr);
		break;

	case LVN_COLUMNCLICK:
        if (m_fInInit)
            return TRUE;
		else if ( wParam == IDC_CERT_LIST )
			return OnColumnClickCertList ((LPNMLISTVIEW) lParam);
		break;

	case LVN_DELETEALLITEMS:
        if (m_fInInit)
            return TRUE;
		else if ( wParam == IDC_CERT_LIST )
			return FALSE;	// Do not suppress LVN_DELETEITEM messages
		break;

	case LVN_DELETEITEM:
        if (m_fInInit)
            return TRUE;
		else if ( wParam == IDC_CERT_LIST )
			return OnDeleteItemCertList ((LPNMLISTVIEW) lParam);
		break;

	case LVN_ODSTATECHANGED:
		OnNotifyStateChanged ((LPNMLVODSTATECHANGE) lParam);
		return 0;

	case LVN_ITEMCHANGED:
		OnNotifyItemChanged ((LPNMLISTVIEW) lParam); 
		return 0;
 
    default:
        break;
	}

    return CDsPropPageBase::OnNotify(wParam, lParam);
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::OnDestroy(void)
{
	ListView_DeleteAllItems (::GetDlgItem (GetHWnd (), IDC_CERT_LIST));
    CDsPropPageBase::OnDestroy();

	if ( m_hCertStore )
	{
		// Back out of uncommitted changes before closing the store.
		BOOL	bResult = ::CertControlStore (m_hCertStore, 
			CERT_STORE_CTRL_COMMIT_CLEAR_FLAG, 
			CERT_STORE_CTRL_COMMIT, NULL);
		if ( !bResult )
		{
			DWORD	dwErr = GetLastError ();
			dspAssert (dwErr != ERROR_NOT_SUPPORTED && dwErr != ERROR_CALL_NOT_IMPLEMENTED);
		}
		::CertCloseStore (m_hCertStore, 0);
		m_hCertStore = 0;
	}

    // If an application processes this message, it should return zero.
    return 0;
}




HRESULT CDsUserCertPage::AddListViewColumns()
{
	// Add list view columns
	LVCOLUMN	lvCol;
	::ZeroMemory (&lvCol, sizeof (lvCol));
    PTSTR		ptsz = 0;

    if ( !LoadStringToTchar (IDS_CERTCOL_ISSUED_TO, &ptsz) )
    {
        ReportError(GetLastError(), 0, GetHWnd());
        return E_OUTOFMEMORY;
    }
	
	lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
    lvCol.fmt = LVCFMT_LEFT;
	lvCol.cx = 90;
    lvCol.pszText = ptsz;     
	lvCol.iSubItem = CERTCOL_ISSUED_TO; 
	HWND	hWndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
	int	nIndex = ListView_InsertColumn (hWndList, CERTCOL_ISSUED_TO, &lvCol);
	_ASSERT (nIndex != -1);
	delete [] ptsz;
	if ( nIndex == -1 )
		return E_UNEXPECTED;

    if ( !LoadStringToTchar (IDS_CERTCOL_ISSUED_BY, &ptsz) )
    {
        ReportError (GetLastError (), 0, GetHWnd ());
        return E_OUTOFMEMORY;
    }
	lvCol.cx = 90;
    lvCol.pszText = ptsz;     
	lvCol.iSubItem = CERTCOL_ISSUED_BY; 
	nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_ISSUED_BY, &lvCol);
	_ASSERT (nIndex != -1);
	delete [] ptsz;
	if ( nIndex == -1 )
		return E_UNEXPECTED;


    if ( !LoadStringToTchar (IDS_CERTCOL_PURPOSES, &ptsz) )
    {
        ReportError (GetLastError (), 0, GetHWnd ());
        return E_OUTOFMEMORY;
    }
	lvCol.cx = 125;
    lvCol.pszText = ptsz;     
	lvCol.iSubItem = CERTCOL_PURPOSES; 
	nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_PURPOSES, &lvCol);
	_ASSERT (nIndex != -1);
	delete [] ptsz;
	if ( nIndex == -1 )
		return E_UNEXPECTED;

    if ( !LoadStringToTchar (IDS_CERTCOL_EXP_DATE, &ptsz) )
    {
        ReportError (GetLastError (), 0, GetHWnd ());
        return E_OUTOFMEMORY;
    }
	lvCol.cx = 125;
    lvCol.pszText = ptsz;     
	lvCol.iSubItem = CERTCOL_EXP_DATE; 
	nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_EXP_DATE, &lvCol);
	_ASSERT (nIndex != -1);
	delete [] ptsz;
	if ( nIndex == -1 )
		return E_UNEXPECTED;

	return S_OK;
}

HRESULT CDsUserCertPage::OnClickedViewCert()
{
	HRESULT	hResult = S_OK;
	int				nSelItem = -1;
	CCertificate*	pCert = GetSelectedCertificate (nSelItem);
	if ( pCert )
	{
		CRYPTUI_VIEWCERTIFICATE_STRUCT	vcs;
		HCERTSTORE						hCertStore = ::CertDuplicateStore (pCert->GetCertStore ());


		::ZeroMemory (&vcs, sizeof (vcs));
		vcs.dwSize = sizeof (vcs);
		vcs.hwndParent = GetHWnd ();
		vcs.dwFlags = 0;
		vcs.cStores = 1;
		vcs.rghStores = &hCertStore;
		vcs.pCertContext = pCert->GetCertContext ();

		BOOL fPropertiesChanged = FALSE;
		BOOL bResult = ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);
		if ( bResult )
		{
			if ( fPropertiesChanged )
			{
				pCert->Refresh ();
				RefreshItemInList (pCert, nSelItem);
			}
		}
		::CertCloseStore (hCertStore, 0);
	}
	
	::SetFocus (::GetDlgItem (GetHWnd (), IDC_CERT_LIST));
	return hResult;
}

HRESULT CDsUserCertPage::OnClickedAddFromStore()
{
	HRESULT								hResult = S_OK;

	PCCERT_CONTEXT	pCertContext = ::CryptUIDlgSelectCertificate (&m_selCertStruct);
	if ( pCertContext )
	{
		hResult = AddCertToStore (pCertContext);
		SetDirty();
	}
	

	::SetFocus (::GetDlgItem (GetHWnd (), IDC_CERT_LIST));
	return hResult;
}

HRESULT CDsUserCertPage::OnClickedAddFromFile()
{
	HRESULT			hResult = S_OK;
	HWND			hwndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);


	PWSTR	pszFilter = 0;
	PWSTR	pszDlgTitle = 0;
	if ( LoadStringToTchar (IDS_CERT_SAVE_FILTER, &pszFilter) &&
			LoadStringToTchar (IDS_OPEN_FILE_DLG_TITLE, &pszDlgTitle) )
	{
		LPWSTR			pszDefExt = _T("cer");
		OPENFILENAME	ofn;
		WCHAR			szFile[MAX_PATH];
		WCHAR			chReplace = pszFilter[wcslen (pszFilter)-1]; // retrieve wild character
	    for (int i = 0; pszFilter[i]; i++)
		{
			if ( pszFilter[i] == chReplace )
				pszFilter[i] = 0;
		}


		::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
		::ZeroMemory (&ofn, sizeof (ofn));
		ofn.lStructSize = sizeof (OPENFILENAME);     
		ofn.hwndOwner = GetHWnd ();
		ofn.lpstrFilter = pszFilter;
		ofn.lpstrFile = szFile;
		ofn.nMaxFile = MAX_PATH;     
		ofn.lpstrTitle = pszDlgTitle;
		ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST; 
		ofn.lpstrDefExt = pszDefExt;     


		BOOL bResult = GetOpenFileName (&ofn);
		if ( bResult )
		{
			DWORD			dwMsgAndCertEncodingType = 0;
			DWORD			dwContentType = 0;
			DWORD			dwFormatType = 0;
			PCERT_CONTEXT	pCertContext = 0;

			bResult = ::CryptQueryObject (
					CERT_QUERY_OBJECT_FILE,
					(void *) ofn.lpstrFile,
					CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
						CERT_QUERY_CONTENT_FLAG_CERT |
						CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED | 
						CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED |  
						CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
					CERT_QUERY_FORMAT_FLAG_ALL,
					0,
					&dwMsgAndCertEncodingType,
					&dwContentType,
					&dwFormatType,
					NULL,
					NULL,
					(const void **) &pCertContext);
			if ( bResult && pCertContext )
			{		
				hResult = AddCertToStore (pCertContext);
//				::CertFreeCertificateContext (pCertContext);
				SetDirty();
			}
			else
			{
				LPWSTR	pszCaption = 0;
				LPWSTR	pszMsg = 0;

				if ( LoadStringToTchar (IDS_OPEN_FILE_DLG_TITLE, &pszCaption) &&
						LoadStringToTchar (IDS_UNKNOWN_CERT_FILE_TYPE, &pszMsg) )
				{
					::MessageBox (GetHWnd (), pszMsg, pszCaption, MB_ICONWARNING | MB_OK);
				}
				else
					hResult = E_OUTOFMEMORY;

				if ( pszCaption )
					delete [] pszCaption;

				if ( pszMsg )
					delete [] pszMsg;
			}
		}
	}

	if ( pszFilter )
		delete [] pszFilter;
	if ( pszDlgTitle )
		delete [] pszDlgTitle;

	::SetFocus (hwndList);
	return hResult;
}

HRESULT CDsUserCertPage::OnClickedRemove()
{
	HRESULT			hResult = S_OK;
	int				nSelItem = -1;
	HWND			hwndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
	bool			bConfirmationRequested = false;
	int				iResult = 0;
	int				nSelCnt = ListView_GetSelectedCount (hwndList);

	if ( nSelCnt < 1 )
		return E_FAIL;

	while (1)
	{
		CCertificate*	pCert = GetSelectedCertificate (nSelItem);
		if ( pCert )
		{
			if ( !bConfirmationRequested )
			{
				LPWSTR	pszCaption = 0;
				LPWSTR	pszText = 0;
				int		textId = 0;

				if ( 1 == nSelCnt )
					textId = IDS_CONFIRM_DELETE_CERT;
				else
					textId = IDS_CONFIRM_DELETE_CERTS;

				if ( LoadStringToTchar (textId, &pszText) &&
						LoadStringToTchar (IDS_REMOVE_CERT, &pszCaption) )
				{
					iResult = ::MessageBox (GetHWnd (), pszText, pszCaption,
							MB_YESNO);
				}
				if ( pszCaption )
					delete [] pszCaption;
				if ( pszText )
					delete [] pszText;
				bConfirmationRequested = true;
				if ( IDYES != iResult )
					break;
			}

			BOOL bResult = pCert->DeleteFromStore ();
			dspAssert (bResult);
			if ( bResult )
			{
				bResult = ListView_DeleteItem (
						hwndList, 
						nSelItem);
				dspAssert (bResult);
				if ( bResult )
					SetDirty ();
				else
					hResult = E_FAIL;
			}
			else
			{
				DWORD dwErr = GetLastError ();
				DisplaySystemError (dwErr, IDS_REMOVE_CERT);
				hResult = HRESULT_FROM_WIN32 (dwErr);
				break;
			}
		}
		else
			break;
	}

	::SetFocus (hwndList);
	EnableControls ();

	return hResult;
}

HRESULT CDsUserCertPage::OnClickedCopyToFile()
{
	HRESULT			hResult = S_OK;

	PWSTR	pszFilter = 0;
	PWSTR	pszDlgTitle = 0;
	if ( LoadStringToTchar (IDS_CERT_SAVE_FILTER, &pszFilter) &&
			LoadStringToTchar (IDS_SAVE_FILE_DLG_TITLE, &pszDlgTitle) )
	{
		LPWSTR			pszDefExt = _T("cer");
		OPENFILENAME	ofn;
		WCHAR			szFile[MAX_PATH];
		WCHAR			chReplace = pszFilter[wcslen (pszFilter)-1]; // retrieve wild character
	    for (int i = 0; pszFilter[i]; i++)
		{
			if ( pszFilter[i] == chReplace )
				pszFilter[i] = 0;
		}


		::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
		::ZeroMemory (&ofn, sizeof (ofn));
		ofn.lStructSize = sizeof (OPENFILENAME);     
		ofn.hwndOwner = GetHWnd ();
		ofn.lpstrFilter = pszFilter;
		ofn.lpstrFile = szFile;
		ofn.nMaxFile = MAX_PATH;     
		ofn.lpstrTitle = pszDlgTitle;
		ofn.Flags = OFN_PATHMUSTEXIST | OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY; 
		ofn.lpstrDefExt = pszDefExt;     

		BOOL bResult = ::GetSaveFileName (&ofn);
		if ( bResult )
		{
			if ( wcsstr (_wcsupr (ofn.lpstrFile), _T(".CER")) )
			{
				HANDLE hFile = ::CreateFile (ofn.lpstrFile, // pointer to name of the file
					  GENERIC_READ | GENERIC_WRITE,         // access (read-write) mode
					  0,									// share mode
					  NULL,									// pointer to security attributes
					  CREATE_ALWAYS,						// how to create
					  FILE_ATTRIBUTE_NORMAL,				// file attributes
					  NULL);								// handle to file with attributes to copy
				dspAssert (hFile != INVALID_HANDLE_VALUE);
				if ( hFile != INVALID_HANDLE_VALUE )
				{
					int	iSelItem = -1;

					CCertificate* pCert = GetSelectedCertificate (iSelItem);
					dspAssert (pCert);
					if ( pCert )
					{
						// To cer file -> put out encoded blob
						// pbEncodedCert
						hResult = pCert->WriteToFile (hFile);
						if ( !SUCCEEDED (hResult) )
							DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
					}

					if ( !CloseHandle (hFile) )
					{
						dspAssert (0);
						DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
					}
				}
				else
					DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
			}
			else
			{
				void* pvSaveToPara = (void*) ofn.lpstrFile;

				HCERTSTORE hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY, 
						X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
						CERT_FILE_STORE_COMMIT_ENABLE_FLAG, 0);
				if ( hCertStore )
				{
					int	iSelItem = -1;

					CCertificate* pCert = GetSelectedCertificate (iSelItem);
					dspAssert (pCert);
					if ( pCert )
					{
						bResult = ::CertAddCertificateContextToStore (
								hCertStore,
								::CertDuplicateCertificateContext (pCert->GetCertContext ()),
								CERT_STORE_ADD_ALWAYS,
								NULL);
						dspAssert (bResult);
						if ( bResult )
						{
							bResult = ::CertSaveStore (
									hCertStore,
									X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
									CERT_STORE_SAVE_AS_PKCS7,
									CERT_STORE_SAVE_TO_FILENAME,
									pvSaveToPara,
									0);
							dspAssert (bResult);
							if ( !bResult )
								DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
						}
						else
							DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
					}
					::CertCloseStore (hCertStore, 0);
				}
			}
		}
	}
	else
		hResult = E_OUTOFMEMORY;

	if ( pszFilter )
		delete [] pszFilter;
	if ( pszDlgTitle )
		delete [] pszDlgTitle;
	
	::SetFocus (::GetDlgItem (GetHWnd (), IDC_CERT_LIST));
	return hResult;
}

HRESULT CDsUserCertPage::OnDblClkCertList(LPNMHDR /*pNMHdr*/)
{
	HRESULT	hResult = S_OK;
	
	hResult = OnClickedViewCert ();
	return hResult;
}

HRESULT CDsUserCertPage::OnColumnClickCertList(LPNMLISTVIEW /*pNMListView*/)
{
	HRESULT	hResult = S_OK;
	
	return hResult;
}

HRESULT	CDsUserCertPage::OnDeleteItemCertList (LPNMLISTVIEW pNMListView)
{
	HRESULT	hResult = S_OK;

	dspAssert (pNMListView);
	if ( pNMListView )
	{
		LVITEM	lvItem;

		::ZeroMemory (&lvItem, sizeof (lvItem));

		lvItem.mask = LVIF_PARAM;
		lvItem.iItem = pNMListView->iItem;

		if ( ListView_GetItem (::GetDlgItem (GetHWnd (), IDC_CERT_LIST), &lvItem) )
		{
			CCertificate* pCert = (CCertificate*) lvItem.lParam;
			dspAssert (pCert);
			if ( pCert )
			{
				delete pCert;
			}
			else
				hResult = E_UNEXPECTED;
		}
		else
			hResult = E_UNEXPECTED;
	}
	else
		hResult = E_POINTER;

	return hResult;
}

HRESULT CDsUserCertPage::PopulateListView()
{
	CWaitCursor			cursor;
    PCCERT_CONTEXT		pCertContext = 0;
	HRESULT				hResult = S_OK;
	CCertificate*		pCert = 0;

	//	Iterate through the list of certificates in the system store,
	//	allocate new certificates with the CERT_CONTEXT returned,
	//	and store them in the certificate list.
	int	nItem = -1;
	while ( SUCCEEDED (hResult) )
	{
		pCertContext = ::CertEnumCertificatesInStore (m_hCertStore, pCertContext);
		if ( !pCertContext )
			break;

		pCert = new CCertificate (pCertContext,	m_hCertStore);
		if ( pCert )
		{
			nItem++;

			hResult = InsertCertInList (pCert, nItem);
			if ( !SUCCEEDED (hResult) )
				delete pCert;
		}
		else
		{
			hResult = E_OUTOFMEMORY;
		}
	}


	return hResult;
}

// Get the first selected certificate, starting at the end of the list
// and previous to the passed in nSelItem.  Pass in a -1 to search
// the entire list
CCertificate* CDsUserCertPage::GetSelectedCertificate (int& nSelItem)
{
	HWND			hWndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
	int				nCnt = ListView_GetItemCount (hWndList);
	CCertificate*	pCert = 0;
	int				nSelCnt = ListView_GetSelectedCount (hWndList);
	LVITEM			lvItem;

	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_PARAM;


	if ( nSelCnt >= 1 )
	{
		if ( -1 != nSelItem )
			nCnt = nSelItem;

		while (--nCnt >= 0)
		{
			UINT	flag = ListView_GetItemState (hWndList, 
				nCnt, LVIS_SELECTED);
			if ( flag & LVNI_SELECTED )
			{
				lvItem.iItem = nCnt;

				if ( ListView_GetItem (::GetDlgItem (GetHWnd (), 
						IDC_CERT_LIST),
						&lvItem) )
				{
					pCert = (CCertificate*) lvItem.lParam;
					dspAssert (pCert);
					if ( pCert )
					{
						nSelItem = nCnt;
					}
				}
				else
				{
					dspAssert (0);
				}
				break; 
			}
		}
	}

	return pCert;
}

void CDsUserCertPage::RefreshItemInList (CCertificate * /*pCert*/, int nItem)
{
	HWND			hWndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
	BOOL bResult = ListView_Update (hWndList, nItem);
	dspAssert (bResult);
}


HRESULT CDsUserCertPage::InsertCertInList(CCertificate * pCert, int nItem)
{
	HRESULT			hResult = S_OK;
	HWND			hWndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
	LVITEM			lvItem;
	PWSTR			pszText = 0;
	int				nIndex = 0;


	// Insert icon and subject name
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
	lvItem.iItem = nItem;
	lvItem.iSubItem = CERTCOL_ISSUED_TO;
	lvItem.iImage = m_nCertImageIndex;
	lvItem.lParam = (LPARAM) pCert;
	hResult = pCert->GetSubjectName (&pszText);
	if ( SUCCEEDED (hResult) )
		lvItem.pszText = pszText;
	else
	{
		hResult = pCert->GetAlternateSubjectName (&pszText);
		if ( SUCCEEDED (hResult) )
			lvItem.pszText = pszText;
	}
	if ( SUCCEEDED (hResult) )
	{
		nIndex = ListView_InsertItem (hWndList, &lvItem);		
		_ASSERT (nIndex != -1);
		if ( nIndex == -1 )
		{
			delete pCert;
			hResult = E_UNEXPECTED;
		}
	}
	else
	{
		delete pCert;
		hResult = E_UNEXPECTED;
	}


	if ( SUCCEEDED (hResult) )
	{
		// Insert issuer name
		::ZeroMemory (&lvItem, sizeof (lvItem));
		HRESULT	hResultToo = pCert->GetIssuerName (&pszText);
		if ( !SUCCEEDED (hResultToo) )
		{
			hResult = pCert->GetAlternateIssuerName (&pszText);
		}
		if ( SUCCEEDED (hResultToo) )
		{
			ListView_SetItemText (hWndList, nIndex, CERTCOL_ISSUED_BY, pszText);
		}
	}

	// Insert intended purpose
	if ( SUCCEEDED (hResult) )
	{
		HRESULT	hResultToo = pCert->GetEnhancedKeyUsage (&pszText);
		if ( SUCCEEDED (hResultToo) && pszText )
		{
			ListView_SetItemText (hWndList, nIndex, CERTCOL_PURPOSES, pszText);
		}
	}

	// Insert expiration date
	if ( SUCCEEDED (hResult) )
	{
		HRESULT	hResultToo = pCert->GetValidNotAfter (&pszText);
		if ( SUCCEEDED (hResultToo) )
		{
			ListView_SetItemText (hWndList, nIndex, CERTCOL_EXP_DATE, pszText);
		}
	}

	if ( pszText )
		delete [] pszText;

	return hResult;
}

void CDsUserCertPage::DisplaySystemError(DWORD dwErr, int iCaptionText)
{
	LPVOID lpMsgBuf = 0;
		
	FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
			NULL,
			dwErr,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf, 0, NULL);
		
	// Display the string.
	PWSTR	pszCaption = 0;
	if ( LoadStringToTchar (iCaptionText, & pszCaption) )
	{
		::MessageBox (GetHWnd (), (LPWSTR) lpMsgBuf, pszCaption, 
				MB_ICONWARNING | MB_OK);
		delete [] pszCaption;
	}

	// Free the buffer.
	LocalFree (lpMsgBuf);
}

void CDsUserCertPage::EnableControls()
{
	HWND	hWndDlg = GetHWnd ();
	HWND	hWndList = ::GetDlgItem (hWndDlg, IDC_CERT_LIST);
	int		nSelCnt = ListView_GetSelectedCount (hWndList);
	int		nSelItem = -1;
	bool	bCanDelete = true;

	while (bCanDelete)
	{
		CCertificate*	pCert = GetSelectedCertificate (nSelItem);
		if ( pCert )
			bCanDelete = pCert->CanDelete ();
		else
			break;
	}

	::EnableWindow (::GetDlgItem (hWndDlg, IDC_REMOVE), bCanDelete && nSelCnt > 0);
	::EnableWindow (::GetDlgItem (hWndDlg, IDC_COPY_TO_FILE), nSelCnt == 1);
	::EnableWindow (::GetDlgItem (hWndDlg, IDC_VIEW_CERT), nSelCnt == 1);
}

void CDsUserCertPage::OnNotifyStateChanged(LPNMLVODSTATECHANGE /*pStateChange*/)
{
	EnableControls ();
}

void CDsUserCertPage::OnNotifyItemChanged (LPNMLISTVIEW /*pnmv*/)
{
	EnableControls ();
}

HRESULT CDsUserCertPage::AddCertToStore(PCCERT_CONTEXT pCertContext)
{
	HRESULT	hResult = S_OK;

	BOOL bResult = ::CertAddCertificateContextToStore (
				m_hCertStore,
				pCertContext,
				CERT_STORE_ADD_NEW,
				0);
	if ( bResult )
	{
		CCertificate* pCert = new CCertificate (pCertContext, m_hCertStore); 
		if ( pCert )
		{
			hResult = InsertCertInList (pCert, 
					ListView_GetItemCount (
					::GetDlgItem (GetHWnd (), IDC_CERT_LIST)));
			if ( !SUCCEEDED (hResult) )
				delete pCert;
		}
		else
		{
			hResult = E_OUTOFMEMORY;
		}
	}
	else
	{
		DWORD	dwErr = GetLastError ();
		if ( dwErr == CRYPT_E_EXISTS )
		{
			LPWSTR	pszMsg = 0;
			LPWSTR	pszCaption = 0;

			if ( LoadStringToTchar (IDS_DUPLICATE_CERT, &pszMsg) &&
					LoadStringToTchar (IDS_ADD_FROM_STORE, &pszCaption) )
			{
				::MessageBox (GetHWnd (), pszMsg, pszCaption, 
						MB_ICONINFORMATION | MB_OK);
				hResult = E_FAIL;
			}
			else
				hResult = E_OUTOFMEMORY;

			if ( pszMsg )
				delete [] pszMsg;
			if ( pszCaption )
				delete [] pszCaption;
		}
		else
		{
			DisplaySystemError (dwErr, IDS_ADD_FROM_STORE);
			hResult = HRESULT_FROM_WIN32 (dwErr);
		}
	}

	return hResult;
}

int CDsUserCertPage::MessageBox(int caption, int text, UINT flags)
{
	int	iReturn = -1;

	LPWSTR	pszMsg = 0;
	LPWSTR	pszCaption = 0;

	if ( LoadStringToTchar (text, &pszMsg) && 
			LoadStringToTchar (caption, &pszCaption) )
	{
		iReturn = ::MessageBox (GetHWnd (), pszMsg, pszCaption, flags);
	}

	if ( pszMsg )
		delete [] pszMsg;
	if ( pszCaption )
		delete [] pszCaption;

	return iReturn;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\user.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       user.h
//
//  Contents:   DS user object property pages header
//
//  Classes:    CDsUserAcctPage, CDsUsrProfilePage, CDsMembershipPage
//
//  History:    05-May-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _USER_H_
#define _USER_H_

#include "objlist.h"
#include "loghrapi.h"

BOOL ExpandUsername(PWSTR& pwzValue, PWSTR pwzSamName, BOOL& fExpanded);

HRESULT CountryName(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT CountryCode(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT TextCountry(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ManagerEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ManagerChangeBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                         LPARAM, PATTR_DATA, DLG_OP);

HRESULT MgrPropBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                   LPARAM, PATTR_DATA, DLG_OP);

HRESULT ClearMgrBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT DirectReportsList(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                          LPARAM, PATTR_DATA, DLG_OP);

HRESULT AddReportsBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

HRESULT RmReportsBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                     LPARAM, PATTR_DATA, DLG_OP);

HRESULT MailAttr(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                 LPARAM, PATTR_DATA, DLG_OP);

HRESULT ShBusAddrBtn(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                     LPARAM, PATTR_DATA, DLG_OP);

#ifdef DSADMIN

typedef enum _ScheduleDialogType {
  SchedDlg_Connection,
  SchedDlg_Replication,
  SchedDlg_Logon
} ScheduleDialogType;

HRESULT
DllScheduleDialog(HWND hwndParent, BYTE ** pprgbData, int idsTitle,
                  LPCTSTR pszName = NULL,
                  LPCTSTR pszObjClass = NULL,
                  DWORD dwFlags = 0,
                  ScheduleDialogType dlgtype = SchedDlg_Logon );

//+----------------------------------------------------------------------------
//
//  Class:      CLogonWkstaDlg
//
//  Purpose:    Update the logon workstations attribute. This is a dialog
//              that hosts the CMultiStringAttr class.
//
//-----------------------------------------------------------------------------
class CLogonWkstaDlg
{
public:
    CLogonWkstaDlg(CDsPropPageBase * pPage);
    ~CLogonWkstaDlg() {};
    //
    //  Static WndProc for multi-valued edit dialog.
    //
    static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                      WPARAM wParam, LPARAM lParam);
    HRESULT Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                 BOOL fWritable = TRUE, int nLimit = 0,
                 BOOL fCommaList = FALSE);
    int     Edit(void);
    HRESULT Write(PADS_ATTR_INFO pAttr);
    BOOL    IsDirty(void);
    void    ClearDirty(void);

private:
    //
    // Dialog proc.
    //
    BOOL CALLBACK MultiValDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam);

    void                ClearAttrInfo(void);

    CMultiStringAttr    m_MSA;
    CDsPropPageBase   * m_pPage;
    BOOL                m_fAllWkstas;
    BOOL                m_fOrigAllWkstas;
    BOOL                m_fFirstUp;
};

HRESULT CreateUserAcctPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                           DWORD, CDSBasePathsInfo*, HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsUserAcctPage
//
//  Purpose:    property page object class for the user object account page.
//
//-----------------------------------------------------------------------------
class CDsUserAcctPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                    DWORD dwFlags);
    ~CDsUserAcctPage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);

    BOOL FillSuffixCombo(LPWSTR pwzUPNdomain);

    //
    //  Data members
    //
    DWORD           m_dwUsrAcctCtrl;
    BOOL            m_fOrigCantChangePW;
    BOOL            m_fOrigSelfAllowChangePW;
    BOOL            m_fOrigWorldAllowChangePW;
    LARGE_INTEGER   m_PwdLastSet;
    BYTE *          m_pargbLogonHours;  // Pointer to allocated array of bytes for the logon hours (array length=21 bytes)
    PWSTR           m_pwzUPN;
    PWSTR           m_pwzSAMname;
    PSID            m_pSelfSid;
    PSID            m_pWorldSid;
    size_t          m_cchSAMnameCtrl;
    LARGE_INTEGER   m_LockoutTime;
    BOOL            m_fUACWritable;
    BOOL            m_fUPNWritable;
    BOOL            m_fSAMNameWritable;
    BOOL            m_fPwdLastSetWritable;
    BOOL            m_fAcctExpiresWritable;
    BOOL            m_fLoginHoursWritable;
    BOOL            m_fUserWkstaWritable;
    BOOL            m_fLockoutTimeWritable;
    BOOL            m_fNTSDWritable;
    BOOL            m_fSAMNameChanged;
    BOOL            m_fAcctCtrlChanged;
    BOOL            m_fAcctExpiresChanged;
    BOOL            m_fLogonHoursChanged;
    BOOL            m_fIsAdmin;
    CLogonWkstaDlg        * m_pWkstaDlg;
};

HRESULT CreateUsrProfilePage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND, DWORD,
                             CDSBasePathsInfo*, HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsUsrProfilePage
//
//  Purpose:    property page object class for the user object profile page.
//
//-----------------------------------------------------------------------------
class CDsUsrProfilePage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
    ~CDsUsrProfilePage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);
    BOOL    ExpandUsername(PWSTR & pwzValue, BOOL & fExpanded);

    //
    //  Data members
    //
    PTSTR       m_ptszLocalHomeDir;
    PTSTR       m_ptszRemoteHomeDir;
    PWSTR       m_pwzSamName;
    int         m_nDrive;
    int         m_idHomeDirRadio;
    BOOL        m_fProfilePathWritable;
    BOOL        m_fScriptPathWritable;
    BOOL        m_fHomeDirWritable;
    BOOL        m_fHomeDriveWritable;
    BOOL        m_fProfilePathChanged;
    BOOL        m_fLogonScriptChanged;
    BOOL        m_fHomeDirChanged;
    BOOL        m_fHomeDriveChanged;
    BOOL        m_fSharedDirChanged;
    PSID        m_pObjSID;
};

HRESULT CreateMembershipPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR,
                             HWND, DWORD, 
                             CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE *);

HRESULT CreateNonSecMembershipPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR,
                                   HWND, DWORD, 
                                   CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsMembershipPage
//
//  Purpose:    property page object class for the membership page.
//
//-----------------------------------------------------------------------------
class CDsMembershipPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsMembershipPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags, BOOL fSecPrinciple = TRUE);
    ~CDsMembershipPage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);
    HRESULT FillMembershipList(void);
    void    InvokeGroupQuery(void);
    void    RemoveMember(void);
    BOOL    SelectionCanBePrimaryGroup(void);
    HRESULT SetPrimaryGroup(void);
    HRESULT ConvertRIDtoName(DWORD RID, PTSTR * pptzName, PWSTR * ppwzDN);
    HRESULT BindToGroup(CMemberListItem * pItem, BOOL fAdd,
                        IUnknown ** ppUnk,
                        PBOOL pfBindFailed);

    //
    //  Data members
    //
    CDsMembershipList * m_pList;
    CMemberLinkList     m_DelList;
    CMemberListItem   * m_pPriGrpLI;
    PWSTR               m_pwzObjDomain;
    BSTR                m_bstrDomPath;
    PSID                m_pObjSID;
    DWORD               m_dwOriginalPriGroup;
    BOOL                m_fSecPrinciple;
    BOOL                m_fMixed; // Domain is in mixed mode
    DWORD               m_dwGrpType;
    BOOL                m_fPriGrpWritable;
};

#endif // DSADMIN

// CountryCode helpers:

typedef struct _DsCountryCode {
    WORD  wCode;
    WCHAR pwz2CharAbrev[3];
} DsCountryCode, *PDsCountryCode;

BOOL GetALineOfCodes(PTSTR pwzLine, PTSTR * pptzFullName,
                     CStrW & str2CharAbrev, LPWORD pwCode);

void RemoveTrailingWhitespace(PTSTR pwz);

#endif // _USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\sample\dll.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dll.h
//
//  Contents:   DLL refcounting classes.
//
//  Classes:    CDll, CDllRef
//
//  History:    6/09/1997 Eric Brown
//
//-----------------------------------------------------------------------------

#ifndef _DLL_H_
#define _DLL_H_

class CDll
{
public:

    static ULONG AddRef() { return InterlockedIncrement((LONG*)&s_cObjs); }
    static ULONG Release() { return InterlockedDecrement((LONG*)&s_cObjs); }

    static void LockServer(BOOL fLock)
    {
        (fLock == TRUE) ? InterlockedIncrement((LONG*)&s_cLocks)
                        : InterlockedDecrement((LONG*)&s_cLocks);
    }

    static HRESULT CanUnloadNow(void)
    {
        return (0L == s_cObjs && 0L == s_cLocks) ? S_OK : S_FALSE;
    }

    static ULONG s_cObjs;
    static ULONG s_cLocks;

};

class CDllRef
{
public:
    CDllRef(void) { CDll::AddRef(); }
    ~CDllRef(void) { CDll::Release(); }
};

#endif // _DLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\sample\host.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       host.cxx
//
//  Contents:   CDsPropPageHost, the class that exposes IShellExtInit and
//              IShellPropSheetExt
//              Also, the ClassFactory and IUnknown code.
//
//  History:    8-Sep-97 Eric Brown created
//
//-----------------------------------------------------------------------------

#include "page.h"

CLIPFORMAT g_cfDsObjectNames = 0;
const CLSID CLSID_SamplePage = { /* cca62184-294f-11d1-bcfe-00c04fd8d5b6 */
    0xcca62184,
    0x294f,
    0x11d1,
    {0xbc, 0xfe, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xb6}
};

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::CDsPropPageHost
//
//-----------------------------------------------------------------------------
CDsPropPageHost::CDsPropPageHost() :
    m_pDataObj(NULL),
    m_uRefs(1)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::~CDsPropPageHost
//
//-----------------------------------------------------------------------------
CDsPropPageHost::~CDsPropPageHost()
{
    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IShellExtInit::Initialize
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHost::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                            HKEY hKeyID)
{
    if (IsBadReadPtr(pDataObj, sizeof(LPDATAOBJECT)))
    {
        return E_INVALIDARG;
    }

    if (m_pDataObj)
    {
        m_pDataObj->Release();
        m_pDataObj = NULL;
    }

    // Hang onto the IDataObject we are being passed.

    m_pDataObj = pDataObj;
    if (m_pDataObj)
    {
        m_pDataObj->AddRef();
    }
    else
    {
        return E_INVALIDARG;
    }

    // Check to see if we have our clipboard format registered, if not then
    // lets do it.

    if (!g_cfDsObjectNames)
    {
        g_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    }
    if (!g_cfDsObjectNames)
    {
        return E_FAIL;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IShellExtInit::AddPages
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHost::AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    HRESULT hr = S_OK;
    HPROPSHEETPAGE hPage;
    STGMEDIUM ObjMedium = {TYMED_NULL};
    FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    LPDSOBJECTNAMES pDsObjectNames;
    PWSTR pwzObjName;
    PWSTR pwzClass;
    CDsPropPage * PropPage;

    //
    // Get the path to the DS object from the data object.
    // Note: This call runs on the caller's main thread. The pages' window
    // procs run on a different thread, so don't reference the data object
    // from a winproc unless it is first marshalled on this thread.
    //
    hr = m_pDataObj->GetData(&fmte, &ObjMedium);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    pDsObjectNames = (LPDSOBJECTNAMES)ObjMedium.hGlobal;

    if (pDsObjectNames->cItems < 1)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pwzObjName = (PWSTR)ByteOffset(pDsObjectNames,
                                   pDsObjectNames->aObjects[0].offsetName);
    pwzClass = (PWSTR)ByteOffset(pDsObjectNames,
                                 pDsObjectNames->aObjects[0].offsetClass);

    //
    // NOTIFY_OBJ
    // Create/contact the notification object.
    //
    HWND hNotifyObj;

    hr = ADsPropCreateNotifyObj(m_pDataObj, pwzObjName, &hNotifyObj);

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Create the page.
    //
    PropPage = new CDsPropPage(hNotifyObj);

    hr = PropPage->Init(pwzObjName, pwzClass);

    if (!SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    hr = PropPage->CreatePage(&hPage);

    if (!SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    //
    // Invoke the callback function, which will add the page to the list of
    // pages that will be used to create the property sheet.
    //
    (*pAddPageProc)(hPage, lParam);

Cleanup:
    ReleaseStgMedium(&ObjMedium);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member: CDsPropPageHost::IShellExtInit::ReplacePage
//
//  Notes:  Not used.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHost::ReplacePage(UINT uPageID,
                             LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                             LPARAM lParam)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHost::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(LPSHELLEXTINIT)this;
    }
    else if (IID_IShellExtInit == riid)
    {
        *ppvObject = (LPSHELLEXTINIT)this;
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppvObject = (LPSHELLPROPSHEETEXT)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageHost::AddRef(void)
{
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageHost::Release(void)
{
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//      CDsPropPageHostCF - class factory for the CDsPropPageHost object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::Create
//
//  Synopsis:   creates a new class factory object
//
//-----------------------------------------------------------------------------
IClassFactory *
CDsPropPageHostCF::Create(void)
{
    return new CDsPropPageHostCF();
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::CDsPropPageHostCF
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CDsPropPageHostCF::CDsPropPageHostCF() :
    m_uRefs(1)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::~CDsPropPageHostCF
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CDsPropPageHostCF::~CDsPropPageHostCF(void)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHostCF::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObject = (IClassFactory *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageHostCF::AddRef(void)
{
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IUnknown::Release
//
//  Synopsis:   decrement the refcount
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageHostCF::Release(void)
{
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IClassFactory::CreateInstance
//
//  Synopsis:   create an incore instance of the proppage host class object
//
//  Arguments:  [pUnkOuter] - aggregator
//              [riid]      - requested interface
//              [ppvObject] - receptor for itf ptr
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHostCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid,
                                   void **ppvObject)
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    CDsPropPageHost * pPropPage = new CDsPropPageHost();
    if (pPropPage == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pPropPage->QueryInterface(riid, ppvObject);
    if (FAILED(hr))
    {
        pPropPage->Release();
        return hr;
    }

    //
    // We got a refcount of one when launched, and the above QI increments it
    // to 2, so call release to take it back to 1.
    //
    pPropPage->Release();
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IClassFactory::LockServer
//
//  Synopsis:   Called with fLock set to TRUE to indicate that the server
//              should continue to run even if none of its objects are active
//
//  Arguments:  [fLock] - increment/decrement the instance count
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHostCF::LockServer(BOOL fLock)
{
    CDll::LockServer(fLock);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\sample\page.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       page.cxx
//
//  Contents:   CDsPropPage, the class that implements the sample property
//              page.
//
//  History:    8-Sep-97 Eric Brown created
//              24-Sep-98  "    "   revised to include notification object.
//
//-----------------------------------------------------------------------------

#include "page.h"

WCHAR wzSpendingLimit[] = L"spendingLimit";

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPage::CDsPropPage
//
//-----------------------------------------------------------------------------
CDsPropPage::CDsPropPage(HWND hNotifyObj) :
    m_hPage(NULL),
    m_pDsObj(NULL),
    m_fInInit(FALSE),
    m_fPageDirty(FALSE),
    m_pwzObjPathName(NULL),
    m_pwzObjClass(NULL),
    m_pwzRDName(NULL),
    m_hNotifyObj(hNotifyObj),
    m_pWritableAttrs(NULL),
    m_hrInit(S_OK)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPage::~CDsPropPage
//
//  Notes:      m_pWritableAttrs does not need to be freed. It refers to
//              memory held by the notify object and freed when the notify
//              object is destroyed.
//
//-----------------------------------------------------------------------------
CDsPropPage::~CDsPropPage()
{
    if (m_pDsObj)
    {
        m_pDsObj->Release();
    }
    if (m_pwzObjPathName)
    {
        delete m_pwzObjPathName;
    }
    if (m_pwzObjClass)
    {
        delete m_pwzObjClass;
    }
    if (m_pwzRDName)
    {
        delete m_pwzRDName;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::CreatePage
//
//  Sysnopsis:  Create the prop page
//
//  Notes:      if m_hrInit contains a failure code at this point, then an
//              error page template could be substituted for the regular one.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPage::CreatePage(HPROPSHEETPAGE * phPage)
{
    TCHAR szTitle[MAX_PATH];
    
    if (!LoadString(g_hInstance, IDS_PAGE_TITLE, szTitle, MAX_PATH - 1))
    { 
        DWORD dwErr = GetLastError();
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    PROPSHEETPAGE   psp;

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK | PSP_USETITLE;
    psp.pszTemplate = (LPCTSTR)IDD_SAMPLE_PAGE;
    psp.pfnDlgProc  = (DLGPROC)StaticDlgProc;
    psp.pfnCallback = PageCallback;
    psp.pcRefParent = NULL; // do not set PSP_USEREFPARENT
    psp.lParam      = (LPARAM) this;
    psp.hInstance   = g_hInstance;
    psp.pszTitle    = L"Spending Limit";

    *phPage = CreatePropertySheetPage(&psp);

    if (*phPage == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::Init
//
//  Sysnopsis:  Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPage::Init(PWSTR pwzObjName, PWSTR pwzClass)
{
    m_pwzObjPathName = new WCHAR[wcslen(pwzObjName) + 1];
    if (m_pwzObjPathName == NULL )
    {
        return E_OUTOFMEMORY;
    }

    m_pwzObjClass = new WCHAR[wcslen(pwzClass) + 1];
    if (m_pwzObjClass == NULL)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(m_pwzObjPathName, pwzObjName);
    wcscpy(m_pwzObjClass, pwzClass);

    //
    // NOTIFY_OBJ
    // Contact the notification object for the initialization info.
    //
    ADSPROPINITPARAMS InitParams = {0};

    InitParams.dwSize = sizeof (ADSPROPINITPARAMS);
    
    if (!ADsPropGetInitInfo(m_hNotifyObj, &InitParams))
    {
        m_hrInit = E_FAIL;
        return E_FAIL;
    }

    if (FAILED(InitParams.hr))
    {
        m_hrInit = InitParams.hr;
        return m_hrInit;
    }

    m_pwzRDName = new WCHAR[wcslen(InitParams.pwzCN) + 1];

    if (m_pwzRDName == NULL)
    {
        m_hrInit = E_OUTOFMEMORY;
        return E_OUTOFMEMORY;
    }

    m_pDsObj = InitParams.pDsObj;
    m_pDsObj->AddRef();

    m_pWritableAttrs = InitParams.pWritableAttrs;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     StaticDlgProc
//
//  Sysnopsis:  static dialog proc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDsPropPage * pPage = (CDsPropPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

        pPage = (CDsPropPage *) ppsp->lParam;
        pPage->m_hPage = hDlg;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPage);
    }

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pPage->m_fInInit = TRUE;
        pPage->OnInitDialog(lParam);
        pPage->m_fInInit = FALSE;
        return TRUE;

    case WM_COMMAND:
        return pPage->OnCommand(LOWORD(wParam),(HWND)lParam, HIWORD(wParam));

    case WM_NOTIFY:
        return pPage->OnNotify(uMsg, wParam, lParam);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnInitDialog
//
//  Sysnopsis:  Handles dialog initialization messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnInitDialog(LPARAM lParam)
{
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;
    HRESULT hr = S_OK;

    //
    // NOTIFY_OBJ
    // Send the notification object the page's window handle.
    //
    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage, NULL))
    {
        m_pWritableAttrs = NULL;
    }

    //
    // Disable the edit control if the user does not have write permission on
    // the attribute.
    //
    if (!ADsPropCheckIfWritable(wzSpendingLimit, m_pWritableAttrs))
    {
        EnableWindow(GetDlgItem (m_hPage, IDC_SPENDING_EDIT), FALSE);
    }

    //
    // Get the attribute value.
    //
    PWSTR rgpwzAttrNames[] = {wzSpendingLimit};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    if (FAILED(hr))
    {
        // Display an error.
        return TRUE;
    }

    if (cAttrs == 1 && pAttrs->dwNumValues > 0)
    {
        // Display the value.
        //
        SetWindowText(GetDlgItem (m_hPage, IDC_SPENDING_EDIT), 
                      pAttrs->pADsValues->CaseIgnoreString);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnNotify
//
//  Sysnopsis:  Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnNotify(UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_APPLY:

        if (!m_fPageDirty)
        {
            return PSNRET_NOERROR;
        }
		{
	    	LRESULT lResult = OnApply();
		    // Store the result into the dialog
    		SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, lResult);
		}
		return TRUE;

    case PSN_RESET:
        return FALSE; // allow the property sheet to be destroyed.

    case PSN_SETACTIVE:
        return OnPSNSetActive(lParam);

    case PSN_KILLACTIVE:
        return OnPSNKillActive(lParam);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnCommand
//
//  Sysnopsis:  Handles the WM_COMMAND message
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if ((codeNotify == EN_CHANGE) && !m_fInInit)
    {
        SetDirty();
    }
    if ((codeNotify == BN_CLICKED) && (id == IDCANCEL))
    {
        //
        // Pressing ESC in a multi-line edit control results in this
        // WM_COMMAND being sent. Pass it on to the parent (the sheet proc) to
        // close the sheet.
        //
        PostMessage(GetParent(m_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                    (LPARAM)hwndCtl);
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnApply
//
//  Sysnopsis:  Handles the  PSN_APPLY notification message
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnApply()
{
    HRESULT hr = S_OK;
    DWORD cModified;
    ADS_ATTR_INFO aAttrs[1];
    PADS_ATTR_INFO pAttrs = aAttrs;
    WCHAR wzEdit[MAX_PATH];
    UINT cch;
    ADSVALUE Value;
    PWSTR rgpwzAttrNames[] = {wzSpendingLimit};

    cch = GetDlgItemText(m_hPage, IDC_SPENDING_EDIT, wzEdit, MAX_PATH);

    pAttrs[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    pAttrs[0].pszAttrName = rgpwzAttrNames[0];

    if (cch > 0)
    {
        Value.dwType = ADSTYPE_CASE_IGNORE_STRING;
        Value.CaseIgnoreString = wzEdit;
        pAttrs[0].pADsValues = &Value;
        pAttrs[0].dwNumValues = 1;
        pAttrs[0].dwControlCode = ADS_ATTR_UPDATE;
    }
    else
    {
        pAttrs[0].pADsValues = NULL;
        pAttrs[0].dwNumValues = 0;
        pAttrs[0].dwControlCode = ADS_ATTR_CLEAR;
    }

    //
    // Write the changes.
    //
    hr = m_pDsObj->SetObjectAttributes(pAttrs, 1, &cModified);

    //
    // NOTIFY_OBJ
    // Signal the change notification. Note that the notify-apply
    // message must be sent even if the page is not dirty so that the
    // notify ref-counting will properly decrement.
    //
    SendMessage(m_hNotifyObj, WM_ADSPROP_NOTIFY_APPLY, TRUE, 0);

    m_fPageDirty = FALSE;

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnPSNSetActive
//
//  Sysnopsis:  Page activation event.
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnPSNSetActive(LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnPSNKillActive
//
//  Sysnopsis:  Page deactivation event (when other pages cover this one).
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnPSNKillActive(LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::PageCallback
//
//  Sysnopsis:  Callback used to free the CDsPropPage object when the
//              property sheet has been destroyed.
//
//-----------------------------------------------------------------------------
UINT CALLBACK
CDsPropPage::PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp)
{

    if (uMsg == PSPCB_RELEASE)
    {
        //
        // Determine instance that invoked this static function
        //
        CDsPropPage * pPage = (CDsPropPage *) ppsp->lParam;

        if (IsWindow(pPage->m_hNotifyObj))
        {
            //
            // NOTIFY_OBJ
            // Tell the notification object to shut down.
            //
            SendMessage(pPage->m_hNotifyObj, WM_ADSPROP_NOTIFY_EXIT, 0, 0);
        }

        delete pPage;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\sample\page.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       page.h
//
//  Contents:   Active Directory object property page sample class header
//
//  Classes:    CDsPropPageHost, CDsPropPageHostCF, CDsPropPage
//
//  History:    8-Sep-97 Eric Brown created
//
//  This code produces a dynlink library called proppage.dll. It adds a new
//  property page to an Active Directory object class for a new attribute
//  called Spending-Limit (LDAP display name: spendingLimit). To use this DLL,
//  you need to modify the Display Specifier for the class of interest by
//  adding the following value:
//  10,{cca62184-294f-11d1-bcfe-00c04fd8d5b6}
//  to the adminPropertyPages attribute. Then run regsvr32 proppage.dll. You
//  also need to modify the schema by creating the string attribute
//  Spending-Limit and adding it to the May-Contain list for the class. Now
//  start Active Directory Manager and open properties on an object of the
//  applicable class and you should see the new property page.
//
//-----------------------------------------------------------------------------

#ifndef _PAGE_H_
#define _PAGE_H_

#include <windows.h>
#include <ole2.h>
#include <activeds.h>
#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>
#include <adsprop.h>
#include "resource.h"


extern HINSTANCE g_hInstance;
extern CLIPFORMAT g_cfDsObjectNames;
extern const CLSID CLSID_SamplePage;

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

//
// a couple of helper classes for dll ref. counting.
//
class CDll
{
public:

    static ULONG AddRef() { return InterlockedIncrement((LONG*)&s_cObjs); }
    static ULONG Release() { return InterlockedDecrement((LONG*)&s_cObjs); }

    static void LockServer(BOOL fLock) {
        (fLock == TRUE) ? InterlockedIncrement((LONG*)&s_cLocks)
                        : InterlockedDecrement((LONG*)&s_cLocks);
    }

    static HRESULT CanUnloadNow(void) {
        return (0L == s_cObjs && 0L == s_cLocks) ? S_OK : S_FALSE;
    }

    static ULONG s_cObjs;
    static ULONG s_cLocks;

};  // class CDll


class CDllRef
{
public:

    CDllRef(void) { CDll::AddRef(); }
    ~CDllRef(void) { CDll::Release(); }

}; // class CDllRef


//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPageHost
//
//  Purpose:    Property pages host object class. This is the COM object that
//              creates the property page(s).
//
//-----------------------------------------------------------------------------
class CDsPropPageHost : public IShellExtInit, IShellPropSheetExt
{
public:
   CDsPropPageHost();
    ~CDsPropPageHost();

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // IShellExtInit methods
    //
    STDMETHOD(Initialize)(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                          HKEY hKeyID );

    //
    // IShellPropSheetExt methods
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc,
                           LPARAM lParam);

private:

    LPDATAOBJECT        m_pDataObj;
    unsigned long       m_uRefs;
    CDllRef             m_DllRef;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPageHostCF
//
//  Purpose:    object class factory
//
//-----------------------------------------------------------------------------
class CDsPropPageHostCF : public IClassFactory
{
public:
    CDsPropPageHostCF();
    ~CDsPropPageHostCF();

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid,
                              void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

    static IClassFactory * Create(void);

private:

    unsigned long   m_uRefs;
    CDllRef         m_DllRef;
};

//
//  static wind proc
//
static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam,
                            LPARAM lParam);

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPage
//
//  Purpose:    property page object class
//
//-----------------------------------------------------------------------------
class CDsPropPage
{
public:

    CDsPropPage(HWND hNotifyObj);
    ~CDsPropPage(void);

    HRESULT Init(PWSTR pwzObjName, PWSTR pwzClass);
    HRESULT CreatePage(HPROPSHEETPAGE * phPage);
    void    SetDirty(void) {
                PropSheet_Changed(GetParent(m_hPage), m_hPage);
                m_fPageDirty = TRUE;
            };

    static  UINT CALLBACK PageCallback(HWND hwnd, UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);

    //
    //  Member functions, called by WndProc
    //
    LRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(UINT uMessage, WPARAM wParam, LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    LRESULT OnPSNSetActive(LPARAM lParam);
    LRESULT OnPSNKillActive(LPARAM lParam);

    //
    //  Data members
    //
    HWND                m_hPage;
    IDirectoryObject *  m_pDsObj;
    BOOL                m_fInInit;
    BOOL                m_fPageDirty;
    PWSTR               m_pwzObjPathName;
    PWSTR               m_pwzObjClass;
    PWSTR               m_pwzRDName;
    HWND                m_hNotifyObj;
    PADS_ATTR_INFO      m_pWritableAttrs;
    CDllRef             m_DllRef;
    HRESULT             m_hrInit;
};

#endif // _PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\sample\dllmisc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dllmisc.cxx
//
//  Contents:   AD property page sample class object handler DLL fcns.
//
//  History:    21-Mar-97 Eric Brown created
//
//-----------------------------------------------------------------------------

#include "page.h"

HINSTANCE g_hInstance = NULL;
ULONG CDll::s_cObjs  = 0;
ULONG CDll::s_cLocks = 0;

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//  History:    24-May-95 EricB created.
//
//-----------------------------------------------------------------------------
extern "C" INT APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, PVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Get instance handle
            //
            g_hInstance = hInstance;
            break;

        case DLL_PROCESS_DETACH:
            break;
    }
    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Creates a class factory for the requested object.
//
//  Arguments:  [cid]    - the requested class object
//              [iid]    - the requested interface
//              [ppvObj] - returned pointer to class object
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDAPI
DllGetClassObject(REFCLSID cid, REFIID iid, void **ppvObj)
{
    IUnknown *pUnk = NULL;
    HRESULT hr = S_OK;

    if (cid != CLSID_SamplePage)
    {
        return E_NOINTERFACE;
    }

    pUnk = CDsPropPageHostCF::Create();
    if (pUnk != NULL)
    {
        hr = pUnk->QueryInterface(iid, ppvObj);
        pUnk->Release();
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Indicates whether the DLL can be removed if there are no
//              objects in existence.
//
//  Returns:    S_OK or S_FALSE
//
//-----------------------------------------------------------------------------
STDAPI
DllCanUnloadNow(void)
{
    return CDll::CanUnloadNow();
}

TCHAR const c_szDsProppagesProgID[] = TEXT("ADsSamplePropertyPage");
TCHAR const c_szServerType[] = TEXT("InProcServer32");
TCHAR const c_szDsProppagesDllName[] = TEXT("proppage.dll");
TCHAR const c_szThreadModel[] = TEXT("ThreadingModel");
TCHAR const c_szThreadModelValue[] = TEXT("Apartment");

//+----------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Adds entries to the system registry.
//
//  Returns:    S_OK or S_FALSE
//
//  Notes:      The keys look like this:
//
//      HKC\CLSID\clsid <No Name> REG_SZ name.progid
//                     \InPropServer32 <No Name> : REG_SZ : proppage.dll
//                                     ThreadingModel : REG_SZ : Apartment
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    HKEY hKeyCLSID, hKeyDsPPClass, hKeySvr;
    
    long lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0,
                             KEY_WRITE, &hKeyCLSID);
    if (lRet != ERROR_SUCCESS)
    {
        return (HRESULT_FROM_WIN32(lRet));
    }

    LPOLESTR pszCLSID;
    DWORD dwDisposition;

    hr = StringFromCLSID(CLSID_SamplePage, &pszCLSID);
    
    lRet = RegCreateKeyEx(hKeyCLSID, pszCLSID, 0, NULL,
                          REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeyDsPPClass, &dwDisposition);

    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }

    lRet = RegSetValueEx(hKeyDsPPClass, NULL, 0, REG_SZ,
                         (CONST BYTE *)c_szDsProppagesProgID,
                         sizeof(TCHAR) * (wcslen(c_szDsProppagesProgID) + 1));
    if (lRet != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyDsPPClass);
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }

    lRet = RegCreateKeyEx(hKeyDsPPClass, c_szServerType, 0, NULL,
                          REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeySvr, &dwDisposition);

    RegCloseKey(hKeyDsPPClass);
    
    if (lRet != ERROR_SUCCESS)
    {
         hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }
    
    lRet = RegSetValueEx(hKeySvr, NULL, 0, REG_SZ,
        (CONST BYTE *)c_szDsProppagesDllName,
        sizeof(TCHAR) * (wcslen(c_szDsProppagesDllName) + 1));
    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
    }
    
    lRet = RegSetValueEx(hKeySvr, c_szThreadModel, 0, REG_SZ,
        (CONST BYTE *)c_szThreadModelValue,
        sizeof(TCHAR) * (wcslen(c_szThreadModelValue) + 1));
    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
    }
    
    RegCloseKey(hKeySvr);

    RegCloseKey(hKeyCLSID);

    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT, c_szDsProppagesProgID, 0, NULL,
                          REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeyDsPPClass, &dwDisposition);

    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }
    lRet = RegCreateKeyEx(hKeyDsPPClass, L"CLSID", 0, NULL,
                          REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeyCLSID, &dwDisposition);

    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }
    lRet = RegSetValueEx(hKeyCLSID, NULL, 0, REG_SZ,
                         (CONST BYTE *)pszCLSID,
                         sizeof(TCHAR) * (wcslen(pszCLSID) + 1));
    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }
    CoTaskMemFree(pszCLSID);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\sample\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by page.rc
//
#define IDS_PAGE_TITLE                  1
#define IDD_SAMPLE_PAGE                 101
#define IDC_SPENDING_EDIT               1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\shell\computer.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       computer.h
//
//  Contents:   DS computer object property pages header
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _COMPUTER_H_
#define _COMPUTER_H_

HRESULT
ShComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

#endif // _COMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\shell\dllmisc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dllmisc.cxx
//
//  Contents:   DS property pages class objects handler DLL fcn strings.
//
//  History:    21-Mar-97 EricB created
//              25-Mar-01 EricB split out shell version for dsprop.dll.
//
//-----------------------------------------------------------------------------

#include "pch.h"

TCHAR const c_szDsProppagesProgID[] = TEXT("DsPropertyPages.");
TCHAR const c_szDsProppagesDllName[] = TEXT("dsprop.dll");

#include "misc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\shell\computer.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       computer.cxx
//
//  Contents:   Computer object functionality.
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "computer.h"

//+----------------------------------------------------------------------------
//
//  Function:   ShComputerRole
//
//  Synopsis:   Handles the computer Role value for the shell computer general
//              page.
//
//-----------------------------------------------------------------------------
HRESULT
ShComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
             DLG_OP DlgOp)
{
    TRACE_FUNCTION(ComputerRole);

    if (DlgOp != fInit)
    {
        return S_OK;
    }
    //
    // Set the computer role value.
    //
    PTSTR ptz;

    int id = IDS_ROLE_WKS;  // UF_WORKSTATION_TRUST_ACCOUNT

    if (pAttrInfo && pAttrInfo->dwNumValues && pAttrInfo->pADsValues &&
        (pAttrInfo->pADsValues->Integer & UF_SERVER_TRUST_ACCOUNT))
    {
        id = IDS_ROLE_SVR;
    }

    if (!LoadStringToTchar(id, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptz);

    delete ptz;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\shell\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in propuuid.h
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

#include <shluuid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\shell\user.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       user.h
//
//  Contents:   AD user object shell property pages header
//
//  Classes:    CDsUserAcctPage, CDsUsrProfilePage, CDsMembershipPage
//
//  History:    05-May-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _USER_H_
#define _USER_H_

#include "objlist.h"

BOOL ExpandUsername(PWSTR& pwzValue, PWSTR pwzSamName, BOOL& fExpanded);

HRESULT CountryName(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT CountryCode(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT TextCountry(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ManagerEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ManagerChangeBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                         LPARAM, PATTR_DATA, DLG_OP);

HRESULT MgrPropBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                   LPARAM, PATTR_DATA, DLG_OP);

HRESULT ClearMgrBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT DirectReportsList(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                          LPARAM, PATTR_DATA, DLG_OP);

HRESULT AddReportsBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

HRESULT RmReportsBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                     LPARAM, PATTR_DATA, DLG_OP);

HRESULT MailAttr(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                 LPARAM, PATTR_DATA, DLG_OP);

HRESULT ShBusAddrBtn(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                     LPARAM, PATTR_DATA, DLG_OP);

// CountryCode helpers:

typedef struct _DsCountryCode {
    WORD  wCode;
    WCHAR pwz2CharAbrev[3];
} DsCountryCode, *PDsCountryCode;

BOOL GetALineOfCodes(PTSTR pwzLine, PTSTR * pptzFullName,
                     CStrW & str2CharAbrev, LPWORD pwCode);

void RemoveTrailingWhitespace(PTSTR pwz);

#endif // _USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\shell\shlprop.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       shlprop.cxx
//
//  Contents:   Tables for table-driven Shell DS property pages
//
//  History:    14-July-97 Jimharr created from dsprop.cxx by ericb
//
//  Note:       Attribute LDAP display names, types, upper ranges, and so
//              forth, have been manually copied from schema.ini. Thus,
//              consistency is going to be difficult to maintain. If you know
//              of schema.ini changes that affect any of the attributes in
//              this file, then please make any necessary corrections here.
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "user.h"
#include "group.h"
#include "computer.h"
#include "pages.hm" // HIDC_*
#include <ntdsadef.h>

#include "dsprop.cxx"

HRESULT
ROList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
       LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);

#define NT_GROUP_PAGE

#ifdef NT_GROUP_PAGE
HRESULT
BmpPictureCtrl(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

INT_PTR CALLBACK
PictureDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//+----------------------------------------------------------------------------
//
//  Class:      CBmpPicCtrl
//
//  Purpose:    Picture control sub-class window proc for displaying bitmaps.
//
//-----------------------------------------------------------------------------
class CBmpPicCtrl
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CBmpPicCtrl(HWND hCtrl, PBYTE pb);
    ~CBmpPicCtrl(void);

    //
    //  Static WndProc to be passed as subclass address.
    //
    static LRESULT CALLBACK StaticCtrlProc(HWND hWnd, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam);
    //
    //  Member functions, called by WndProc
    //
    LRESULT OnPaint(void);

    HRESULT CreateBmpPalette(void);
    //
    //  Data members
    //

protected:
    HWND                m_hCtrl;
    HWND                m_hDlg;
    WNDPROC             m_pOldProc;
    PBYTE               m_pbBmp;
    HPALETTE            m_hPal;
};

#endif // NT_GROUP_PAGE

//+----------------------------------------------------------------------------
// User Object.
//-----------------------------------------------------------------------------

//
// General page, first name
//
ATTR_MAP USGFirstName = {IDC_SH_FIRST_NAME_EDIT, FALSE, FALSE, 64,
                         {L"givenName", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, last name
//
ATTR_MAP USGLastName = {IDC_SH_LAST_NAME_EDIT, FALSE, FALSE, 64,
                       {L"sn", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, NULL, NULL};
//
// General page, friendly name
//
ATTR_MAP USGFriendlyName = {IDC_SH_DISPLAY_NAME_EDIT, FALSE, FALSE,
                            ATTR_LEN_UNLIMITED, {L"displayName",
                            ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                            NULL, 0}, NULL, NULL};
//
// General page, phone number
//
ATTR_MAP USGPhone = {IDC_PHONE_EDIT, FALSE, FALSE, 32,
                    {L"telephoneNumber", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, email
//
ATTR_MAP USGEMail = {IDC_EMAIL_EDIT, FALSE, FALSE, 256,
                    {L"mail", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                     NULL, 0}, NULL, NULL};
//
// General page, URL
//
ATTR_MAP USGURL = {IDC_URL_EDIT, FALSE, FALSE, 2048,
                  {L"wWWHomePage", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, NULL,
                   0}, NULL, NULL};
//
// The list of attributes on the User General page.
//
PATTR_MAP rgpUSGAttrMap[] = {{&GenIcon}, {&AttrName}, {&USGFirstName},
                             {&USGLastName}, {&USGFriendlyName},
                             {&USGPhone}, {&USGEMail}, {&USGURL}};
//--------------------------------------------------------
// Business page, title
//
ATTR_MAP USBTitle = {IDC_TITLE, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                     {L"title", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                      NULL, 0}, NULL, NULL};
//
// Business page, Company
//
ATTR_MAP USBCo = {IDC_COMPANY, FALSE, FALSE, 64,
                  {L"company", ADS_ATTR_UPDATE,
                   ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Business page, Department
//
ATTR_MAP USBDept = {IDC_DEPARTMENT, FALSE, FALSE, 64,
                    {L"department", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Business page, office
//
ATTR_MAP USBOffice = {IDC_OFFICE, FALSE, FALSE, 128,
                     {L"physicalDeliveryOfficeName", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Business page, Manager
//
ATTR_MAP USBMgr = {IDC_MANAGER, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                   {L"manager", ADS_ATTR_UPDATE,
                    ADSTYPE_DN_STRING, NULL, 0}, ManagerEdit, NULL};
//
// Business page, direct reports
//
ATTR_MAP USBReports = {IDC_REPORTS_LIST, TRUE, TRUE, 0,
                       {L"directReports", ADS_ATTR_UPDATE,
                        ADSTYPE_DN_STRING, NULL, 0}, DirectReportsList, NULL};
//
// The list of attributes on the User Business page.
//
PATTR_MAP rgpUSBAttrMap[] = {{&USBTitle}, {&USBCo}, {&USBDept}, {&USBOffice},
                             {&USBMgr}, {&USBReports}};

//
// The User General page description.
//
DSPAGE ShellUserGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_USER_GEN, 0, 0, NULL,
                           CreateTableDrivenPage,
                           sizeof(rgpUSGAttrMap)/sizeof(PATTR_MAP), rgpUSGAttrMap};

//
// The User Business page description.
//
DSPAGE ShellUserBusiness = {IDS_TITLE_BUSINESS, IDD_SHELL_BUSINESS, 0, 0, NULL,
                            CreateTableDrivenPage,
                            sizeof(rgpUSBAttrMap)/sizeof(PATTR_MAP), rgpUSBAttrMap};

#ifdef NT_GROUP_PAGE
//----------------------------------------------
// Special User page, Home phone primary/other
//
ATTR_MAP USpecHomePhone = {IDC_HOMEPHONE_EDIT, FALSE, FALSE, 64,
                           {L"homePhone", ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

ATTR_MAP USpecHomeOther = {IDC_OTHER_HOME_BTN, FALSE, TRUE, 64,
                         {L"otherHomePhone", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Special page, Pager
//
ATTR_MAP USpecPager = {IDC_PAGER_EDIT, FALSE, FALSE, 64,
                     {L"pager", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                      NULL, 0}, NULL, NULL};

ATTR_MAP USpecOtherPager = {IDC_OTHER_PAGER_BTN, FALSE, TRUE, 64,
                          {L"otherPager", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Special page, Mobile
//
ATTR_MAP USpecMobile = {IDC_MOBILE_EDIT, FALSE, FALSE, 64,
                      {L"mobile", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                       NULL, 0}, NULL, NULL};

ATTR_MAP USpecOtherMobile = {IDC_OTHER_MOBLE_BTN, FALSE, TRUE, 64,
                          {L"otherMobile", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Special page, user's home page
//
ATTR_MAP USpecURL = {IDC_HOME_PAGE_EDIT, FALSE, FALSE, 2048,
                  {L"wWWHomePage", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                   NULL, 0}, NULL, NULL};
//
// Special page, other home pages
//
ATTR_MAP USpecOtherURL = {IDC_OTHER_URL_BTN, FALSE, TRUE, 2048,
                       {L"url", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Special page, Address
//
ATTR_MAP USpecAddress = {IDC_ADDRESS_EDIT, FALSE, FALSE, 1024,
                         {L"homePostalAddress", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Special page, Picture
//
ATTR_MAP USpecPicture = {IDC_PICTURE_BMP, TRUE, FALSE, 0,
                         {L"thumbnailPhoto", ADS_ATTR_UPDATE,
                          ADSTYPE_OCTET_STRING, NULL, 0}, BmpPictureCtrl, NULL};

//
// The list of attributes on the User Special page.
//
PATTR_MAP rgpUSpecAttrMap[] = {{&USpecHomePhone}, {&USpecHomeOther}, {&USpecPager},
                               {&USpecOtherPager}, {&USpecMobile}, {&USpecOtherMobile},
                               {&USpecURL}, {&USpecOtherURL}, {&USpecAddress},
                               {&USpecPicture}};
//
// The Special page description.
//
DSPAGE NTGroup = {IDS_NT_GRP_TITLE, IDD_NT_GROUP, 0, 0, NULL,
                  CreateTableDrivenPage,
                  sizeof(rgpUSpecAttrMap)/sizeof(PATTR_MAP),
                  rgpUSpecAttrMap};

//----------------------------------------------
// The list of Special pages.
//
PDSPAGE rgShellUSpecPages[] = {{&NTGroup}};

//
// The User Special class description.
//
DSCLASSPAGES ShellUSpecCls = {&CLSID_SpecialUserInfo, TEXT("User Special Info"),
                              sizeof(rgShellUSpecPages)/sizeof(PDSPAGE),
                              rgShellUSpecPages};
#endif // NT_GROUP_PAGE

//----------------------------------------------
// The list of User pages.
//
PDSPAGE rgShellUserPages[] = {{&ShellUserGeneral}, {&UserAddress}, {&ShellUserBusiness}};

//
// The User class description.
//
DSCLASSPAGES ShellUserCls = {&CLSID_DsShellUserPropPages, TEXT("User"),
                             sizeof(rgShellUserPages)/sizeof(PDSPAGE),
                             rgShellUserPages};


//-------------------------------------------------------
// Contact object
//-------------------------------------------------------
//
// The list of Contact pages.
//
PDSPAGE rgShellContactPages[] = {{&ShellUserGeneral}, {&ShellUserBusiness}};
//
// The Contact class description.
//
DSCLASSPAGES ShellContactCls = {&CLSID_DsShellContactPropPages, TEXT("Contact"),
                                sizeof(rgShellContactPages)/sizeof(PDSPAGE),
                                rgShellContactPages};

//-------------------------------------------------------
// Volume object
//-------------------------------------------------------

//
// Volume page, path
//
ATTR_MAP VSPath = {IDC_PATH, FALSE, FALSE,
                   ATTR_LEN_UNLIMITED, {L"uNCName",
                   ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                   NULL, 0}, NULL, NULL};
ATTR_MAP VolKey = {IDC_KEYWORDS_LIST, TRUE, TRUE, 0,
                   {L"keywords", ADS_ATTR_UPDATE,
                    ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ROList, NULL};

//
// The list of attributes on the Volume General page.
//
PATTR_MAP rgpVSAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}, {&VSPath}, {&VolKey}};

//
// The Volume  General page description.
//
DSPAGE ShellVolumeGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_VOLUME_GEN, 0, 0, NULL,
                             CreateTableDrivenPage,
                             sizeof(rgpVSAttrMap)/sizeof(PATTR_MAP),
                             rgpVSAttrMap};

//----------------------------------------------
// The list of Volume pages.
//
PDSPAGE rgShellVolumePages[] = {{&ShellVolumeGeneral}};

//
// The Volume class description.
//
DSCLASSPAGES ShellVolumeCls = {&CLSID_DsShellVolumePropPages, TEXT("Volume"),
                               sizeof(rgShellVolumePages)/sizeof(PDSPAGE),
                               rgShellVolumePages};

//
//-----------------------------------------------
// computer object
//----------------------------------------------
//
// Computer General page, Network Address.
//
//ATTR_MAP CSComputerNetAddr = {IDC_NET_ADDR_EDIT, FALSE, FALSE, 256,
//                              {L"networkAddress", ADS_ATTR_UPDATE,
//                              ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL};
//
// Computer General page, Role.
//
ATTR_MAP CSComputerRoleAttr = {IDC_ROLE, TRUE, FALSE, 260,
                               {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                               ADSTYPE_INTEGER, NULL, 0}, ShComputerRole, NULL};

//
// The list of attributes on the Computer General page.
//
PATTR_MAP rgpCSAttrMap[] = {{&GenIcon}, {&AttrName},
                            {&Description}, // {&CSComputerNetAddr},
                            {&CSComputerRoleAttr}};
//
// The Computer General page description.
//
DSPAGE ShellComputerGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_COMPUTER_GEN, 0, 0, NULL,
                               CreateTableDrivenPage,
                               sizeof(rgpCSAttrMap)/sizeof(PATTR_MAP),
                               rgpCSAttrMap};
//----------------------------------------------
// The list of Computer pages.
//
PDSPAGE rgShellComputerPages[] = {{&ShellComputerGeneral}};

//
// The Computer class description.
//
DSCLASSPAGES ShellComputerCls = {&CLSID_DsShellComputerPropPages, TEXT("Computer"),
                                 sizeof(rgShellComputerPages)/sizeof(PDSPAGE),
                                 rgShellComputerPages};

//----------------------------------------------
// Domain object
//----------------------------------------------

//
// The list of attributes on the General page.
//
PATTR_MAP rgpDSAttrMap[] = {{&GenIcon}, {&AttrName},
                            {&Description}};
//
// The Computer General page description.
//
DSPAGE ShellDomainGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_DOMAIN_GEN, 0, 0, NULL,
                             CreateTableDrivenPage,
                             sizeof(rgpDSAttrMap)/sizeof(PATTR_MAP),
                             rgpDSAttrMap};
//----------------------------------------------
// The list of Domain pages.
//
PDSPAGE rgShellDomainPages[] = {{&ShellDomainGeneral}};

//
// The Domain class description.
//
DSCLASSPAGES ShellDomainCls = {&CLSID_DsShellDomainPropPages, TEXT("Domain"),
                             sizeof(rgShellDomainPages)/sizeof(PDSPAGE),
                             rgShellDomainPages};

//----------------------------------------------
// OU object
//----------------------------------------------

//
// The list of attributes on the OU General page.
//
PATTR_MAP rgpOSAttrMap[] = {{&GenIcon}, {&AttrName},
                            {&Description}};
//
// The OU General page description.
//
DSPAGE ShellOUGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_DOMAIN_GEN, 0, 0, NULL,
                             CreateTableDrivenPage,
                             sizeof(rgpOSAttrMap)/sizeof(PATTR_MAP),
                             rgpOSAttrMap};
//----------------------------------------------
// The list of OU pages.
//
PDSPAGE rgShellOUPages[] = {{&ShellOUGeneral}};

//
// The OU class description.
//
DSCLASSPAGES ShellOUCls = {&CLSID_DsShellOUPropPages, TEXT("OU"),
                             sizeof(rgShellOUPages)/sizeof(PDSPAGE),
                             rgShellOUPages};

//----------------------------------------------
// Group object
//----------------------------------------------

//
// The Group General page description.
//
DSPAGE ShellGroupGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_GROUP_GEN, 0, 0, NULL,
                            CreateGrpShlGenPage, 0, NULL};

//----------------------------------------------
// The list of Group pages.
//
PDSPAGE rgShellGroupPages[] = {{&ShellGroupGeneral}};

//
// The Group class description.
//
DSCLASSPAGES ShellGroupCls = {&CLSID_DsShellGroupPropPages, TEXT("Group"),
                              sizeof(rgShellGroupPages)/sizeof(PDSPAGE),
                              rgShellGroupPages};

#ifdef NT_GROUP_PAGE

//+----------------------------------------------------------------------------
//
//  Function:   BmpPictureCtrl
//
//  Synopsis:   Fetches the bitmap from the user object Picture attribute
//              and draws it on the page.
//
//-----------------------------------------------------------------------------
HRESULT
BmpPictureCtrl(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA pAttrData,
               DLG_OP DlgOp)
{
    HWND hPicCtrl;
    PBYTE pb;
    CBmpPicCtrl * pPicCtrlObj;

    switch (DlgOp)
    {
    case fInit:
        pAttrData->pVoid = NULL;

        if (pAttrInfo == NULL)
        {
            return S_OK;
        }
        hPicCtrl = GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID);

        dspAssert(pAttrInfo->pADsValues != NULL);
        dspAssert(pAttrInfo->dwADsType == ADSTYPE_OCTET_STRING);
        dspAssert(pAttrInfo->dwNumValues == 1);
        dspAssert(pAttrInfo->pADsValues->dwType == ADSTYPE_OCTET_STRING);

        dspAssert(pAttrInfo->pADsValues->OctetString.dwLength > 0);
        dspAssert(pAttrInfo->pADsValues->OctetString.lpValue != NULL);

        //
        // Enforce the maximum size.
        //
        pb = pAttrInfo->pADsValues->OctetString.lpValue;

        PBITMAPINFO pBmpInfo;

        pBmpInfo = (PBITMAPINFO)((PBYTE)pb + sizeof(BITMAPFILEHEADER));

        dspDebugOut((DEB_ITRACE, "Bitmap size: (%d, %d)\n",
                     pBmpInfo->bmiHeader.biWidth, pBmpInfo->bmiHeader.biHeight));
#define MAX_PIC_SIZE 100
        if ((pBmpInfo->bmiHeader.biWidth > MAX_PIC_SIZE) ||
            (pBmpInfo->bmiHeader.biHeight > MAX_PIC_SIZE))
        {
            LONG_PTR lStyle = GetWindowLongPtr(hPicCtrl, GWL_STYLE);
            lStyle &= ~(SS_BITMAP);
            lStyle |= SS_LEFT;
            SetWindowLongPtr(hPicCtrl, GWL_STYLE, lStyle);
            TCHAR szMsg[200];
            wsprintf(szMsg, TEXT("Bitmap is too large (%d, %d)!"),
                     pBmpInfo->bmiHeader.biWidth, pBmpInfo->bmiHeader.biHeight);
            SetWindowText(hPicCtrl, szMsg);
            dspDebugOut((DEB_ITRACE, "Bitmap too large! (%d, %d) max allowed.\n",
                         MAX_PIC_SIZE, MAX_PIC_SIZE));
            return S_OK;
        }

        //
        // Save the bitmap.
        //
        pb = (PBYTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                pAttrInfo->pADsValues->OctetString.dwLength);

        CHECK_NULL_REPORT(pb, pPage->GetHWnd(), return E_OUTOFMEMORY);

        memcpy(pb, pAttrInfo->pADsValues->OctetString.lpValue,
               pAttrInfo->pADsValues->OctetString.dwLength);
        //
        // Subclass the picture "static" control.
        //
        pPicCtrlObj = new CBmpPicCtrl(hPicCtrl, pb);

        CHECK_NULL_REPORT(pPicCtrlObj, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrData->pVoid = reinterpret_cast<LPARAM>(pPicCtrlObj);

        break;

    case fOnDestroy:
        pPicCtrlObj = reinterpret_cast<CBmpPicCtrl*>(pAttrData->pVoid);
        DO_DEL(pPicCtrlObj);
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Class:      CBmpPicCtrl
//
//  Synopsis:   Icon control window subclass object, so we can paint a class-
//              specific icon.
//
//-----------------------------------------------------------------------------
CBmpPicCtrl::CBmpPicCtrl(HWND hCtrl, PBYTE pb) :
    m_hCtrl(hCtrl),
    m_pbBmp(pb),
    m_pOldProc(NULL),
    m_hPal(NULL)
{
#ifdef _DEBUG
    strcpy(szClass, "CBmpPicCtrl");
#endif
    SetWindowLongPtr(hCtrl, GWLP_USERDATA, (LONG_PTR)this);
    m_pOldProc = (WNDPROC)SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LONG_PTR)StaticCtrlProc);
    m_hDlg = GetParent(hCtrl);
}

CBmpPicCtrl::~CBmpPicCtrl(void)
{
    SetWindowLongPtr(m_hCtrl, GWLP_WNDPROC, (LONG_PTR)m_pOldProc);
    if (m_pbBmp)
    {
        GlobalFree(m_pbBmp);
    }
    if (m_hPal)
    {
        DeleteObject(m_hPal);
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CBmpPicCtrl::StaticCtrlProc
//
//  Synopsis:   control sub-proc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CBmpPicCtrl::StaticCtrlProc(HWND hCtrl, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    HDC hDC;
    HPALETTE hOldPal;
    UINT iChanged = 0;
    CBmpPicCtrl * pCCtrl = (CBmpPicCtrl*)GetWindowLongPtr(hCtrl, GWLP_USERDATA);

    dspAssert(pCCtrl != NULL);

    switch (uMsg)
    {
    case WM_PALETTECHANGED:
        if ((HWND)wParam == hCtrl)
        {
            break;
        }
        // Fall through:
    case WM_QUERYNEWPALETTE:
        dspDebugOut((DEB_ITRACE, "Got palette message.\n"));
        if (pCCtrl->m_hPal == NULL)
        {
            hr = pCCtrl->CreateBmpPalette();

            CHECK_HRESULT(hr, return FALSE);
        }
        hDC = GetDC(hCtrl);
        if (hDC != NULL)
        {
          hOldPal = SelectPalette(hDC, pCCtrl->m_hPal, FALSE);
          iChanged = RealizePalette(hDC);
          SelectPalette(hDC, hOldPal, TRUE);
          RealizePalette(hDC);
          ReleaseDC(hCtrl, hDC);
          if (iChanged > 0 && iChanged != GDI_ERROR)
          {
              InvalidateRect(hCtrl, NULL, TRUE);
          }
        }
        return(iChanged);        

    case WM_PAINT:
        if (!pCCtrl->OnPaint())
        {
            return FALSE;
        }
        break;

    default:
        break;
    }

    return CallWindowProc(pCCtrl->m_pOldProc, hCtrl, uMsg, wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CBmpPicCtrl::OnPaint
//
//  Synopsis:   Paint the DS specified icon.
//
//-----------------------------------------------------------------------------
LRESULT
CBmpPicCtrl::OnPaint(void)
{
    TRACE(CBmpPicCtrl,OnPaint);
    HRESULT hr = S_OK;
    HDC hDC = NULL;
    PAINTSTRUCT ps;
    HPALETTE hOldPal = NULL;

    if (m_hPal == NULL)
    {
        hr = CreateBmpPalette();
        CHECK_HRESULT(hr, return FALSE);
    }

    hDC = BeginPaint(m_hCtrl, &ps);

    CHECK_NULL_REPORT(hDC, m_hDlg, return FALSE);

    if (m_hPal)
    {
        hOldPal = SelectPalette(hDC, m_hPal, FALSE);
        RealizePalette(hDC);
    }

    dspAssert(m_pbBmp != NULL);

    PBITMAPFILEHEADER pBmpFileHdr = (PBITMAPFILEHEADER)m_pbBmp;

    // Advance past the BITMAPFILEHEADER struct.
    //
    PBITMAPINFO pBmpInfo = (PBITMAPINFO)(m_pbBmp + sizeof(BITMAPFILEHEADER));

    if (SetDIBitsToDevice(hDC,
                          0, 0,
                          pBmpInfo->bmiHeader.biWidth,
                          pBmpInfo->bmiHeader.biHeight,
                          0, 0, 0,
                          pBmpInfo->bmiHeader.biHeight,
                          m_pbBmp + pBmpFileHdr->bfOffBits,
                          pBmpInfo,
                          DIB_RGB_COLORS) == 0)
    {
        REPORT_ERROR(GetLastError(), m_hDlg);
    }

    if (m_hPal)
    {
        SelectPalette(hDC, hOldPal, TRUE);
    }
    EndPaint(m_hCtrl, &ps);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateBmpPalette
//
//  Synopsis:   Creates the palette for the bitmap.
//
//-----------------------------------------------------------------------------
HRESULT
CBmpPicCtrl::CreateBmpPalette(void)
{
    TRACE(CBmpPicCtrl,CreateBmpPalette);
    PBITMAPINFO pBmpInfo;

    pBmpInfo = (PBITMAPINFO)(m_pbBmp + sizeof(BITMAPFILEHEADER));

    WORD nColors, cClrBits = pBmpInfo->bmiHeader.biBitCount;

    if (cClrBits == 1)
        cClrBits = 1;
    else if (cClrBits <= 4) 
        cClrBits = 4;
    else if (cClrBits <= 8)
        cClrBits = 8; 
    else if (cClrBits <= 16)
        cClrBits = 16; 
    else if (cClrBits <= 24)
        cClrBits = 24;
    else 
        cClrBits = 32; 

    if (cClrBits >= 24)
    {
        // True color BMPs don't need explicit palettes.
        //
        return S_OK;
    }

    nColors = static_cast<WORD>(1 << cClrBits);

    dspDebugOut((DEB_ITRACE, "Bitmap has %d colors.\n", nColors));

    PLOGPALETTE plp = (PLOGPALETTE)LocalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                              sizeof(LOGPALETTE) +
                                              sizeof (PALETTEENTRY) * nColors);
    
    CHECK_NULL_REPORT(plp, m_hDlg, return E_OUTOFMEMORY);

    plp->palVersion = 0x300;
    plp->palNumEntries = nColors;

    for (WORD i = 0; i < nColors; i++)
    {
        plp->palPalEntry[i].peBlue = pBmpInfo->bmiColors[i].rgbBlue;
        plp->palPalEntry[i].peGreen = pBmpInfo->bmiColors[i].rgbGreen;
        plp->palPalEntry[i].peRed = pBmpInfo->bmiColors[i].rgbRed;
        plp->palPalEntry[i].peFlags = 0; //PC_NOCOLLAPSE;
    }

    m_hPal = CreatePalette(plp);

    if (m_hPal == NULL)
    {
        REPORT_ERROR(GetLastError(), m_hDlg);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LocalFree(plp);

    return S_OK;
}

#endif // NT_GROUP_PAGE

HRESULT
ROList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
       LPARAM, PATTR_DATA, DLG_OP DlgOp)
{

    if (DlgOp != fInit)
    {
        return S_OK;
    }
    if (pAttrInfo == NULL)
    {
        return S_OK;
    }
    dspAssert(pAttrInfo->pADsValues != NULL);

    for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
    {
        SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID, LB_ADDSTRING, 0,
                           (LPARAM)pAttrInfo->pADsValues[i].CaseIgnoreString);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
// The list of classes.
//-----------------------------------------------------------------------------

PDSCLASSPAGES rgClsPages[] = {
    &ShellComputerCls,
    &ShellVolumeCls,
    &ShellUserCls,
    &ShellContactCls,
    &ShellDomainCls,
    &ShellGroupCls,
    &ShellOUCls,
    &ShellUSpecCls
};


//+----------------------------------------------------------------------------
// The global struct containing the list of classes.
//-----------------------------------------------------------------------------
RGDSPPCLASSES g_DsPPClasses = {sizeof(rgClsPages)/sizeof(PDSCLASSPAGES),
                               rgClsPages};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\shell\notify.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       notify.cxx
//
//  Contents:   Change notification ref-counting object.
//
//  Classes:    CNotifyObj
//
//  History:    20-Jan-98 EricB
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"  // g_ClassIconCache

#define NOTIFYOUT(x) dspDebugOut((DEB_ITRACE, "Notify Obj (this: 0x%p) " #x "\n", this));
#define DSPROP_WAITTIME 600000 // wait 600 seconds, 10 minutes.

//+----------------------------------------------------------------------------
//
//  Function:   ADsPropCreateNotifyObj
//
//  Synopsis:   Checks to see if the notification window/object exists for this
//              sheet instance and if not creates it.
//
//  Arguments:  [pAppThdDataObj] - the unmarshalled data object pointer.
//              [pwzADsObjName]  - object path name.
//              [phNotifyObj]    - to return the notificion window handle.
//
//  Returns:    HRESULTs.
//
//-----------------------------------------------------------------------------
STDAPI
ADsPropCreateNotifyObj(LPDATAOBJECT pAppThdDataObj, PWSTR pwzADsObjName,
                       HWND * phNotifyObj)
{
    return CNotifyObj::Create(pAppThdDataObj, pwzADsObjName, phNotifyObj);
}

//+----------------------------------------------------------------------------
//
//  Function:   ADsPropGetInitInfo
//
//  Synopsis:   Pages call this at their init time to retreive DS object info.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [pInitParams] - struct filled in with DS object info.
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//  Note that pInitParams->pWritableAttrs can be NULL if there are no writable
//  attributes.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropGetInitInfo(HWND hNotifyObj, PADSPROPINITPARAMS pInitParams)
{
    return CNotifyObj::GetInitInfo(hNotifyObj, pInitParams);
}

//+----------------------------------------------------------------------------
//
//  Function:   ADsPropSetHwndWithTitle
//
//  Synopsis:   Pages call this at their dialog init time to send their hwnd
//              to the Notify object. Use this function instead of 
//              ADsPropSetHwnd for multi-select property pages.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [hPage]       - the page's window handle.
//              [ptzTitle]    - the page's title
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropSetHwndWithTitle(HWND hNotifyObj, HWND hPage, PTSTR ptzTitle)
{
    return CNotifyObj::SetHwnd(hNotifyObj, hPage, ptzTitle);
}

//+----------------------------------------------------------------------------
//
//  Function:   ADsPropSetHwnd
//
//  Synopsis:   Pages call this at their dialog init time to send their hwnd
//              to the Notify object.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [hPage]       - the page's window handle.
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropSetHwnd(HWND hNotifyObj, HWND hPage)
{
   return ADsPropSetHwndWithTitle(hNotifyObj, hPage, 0);
}

//+----------------------------------------------------------------------------
//
//  function:   ADsPropCheckIfWritable
//
//  Synopsis:   See if the attribute is writable by checking if it is in
//              the allowedAttributesEffective array.
//
//  Arguments:  [pwzAttr]        - the attribute name.
//              [pWritableAttrs] - the array of writable attributes.
//
//  Returns:    FALSE if the attribute name is not found in the writable-attrs
//              array or if the array pointer is NULL.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropCheckIfWritable(const PWSTR pwzAttr, const PADS_ATTR_INFO pWritableAttrs)
{
    BOOL fWritable = FALSE;

    if (!pWritableAttrs || IsBadReadPtr(pWritableAttrs, sizeof(ADS_ATTR_INFO)))
    {
        return FALSE;
    }

    for (DWORD i = 0; i < pWritableAttrs->dwNumValues; i++)
    {
        if (_wcsicmp(pWritableAttrs->pADsValues[i].CaseIgnoreString,
                     pwzAttr) == 0)
        {
            fWritable = TRUE;
            break;
        }
    }
    return fWritable;
}

//+----------------------------------------------------------------------------
//
//  function:   ADsPropSendErrorMessage
//
//  Synopsis:   Adds an error message to a list which is presented when
//              ADsPropShowErrorDialog is called
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [pError]      - the error structure
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropSendErrorMessage(HWND hNotifyObj, PADSPROPERROR pError)
{
   return SendMessage(hNotifyObj, WM_ADSPROP_NOTIFY_ERROR, 0, (LPARAM)pError) != 0;
}

//+----------------------------------------------------------------------------
//
//  function:   ADsPropShowErrorDialog
//
//  Synopsis:   Presents an error dialog with the error messages accumulated
//              through calls to ADsPropSendErrorMessage
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [hPage]       - the property page window handle.
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropShowErrorDialog(HWND hNotifyObj, HWND hPage)
{
#ifdef DSADMIN
  CNotifyObj* pNotifyObj = NULL;

  dspAssert(hNotifyObj);
  if (!IsWindow(hNotifyObj))
  {
    return FALSE;
  }
  LRESULT lResult = SendMessage(hNotifyObj, WM_ADSPROP_NOTIFY_GET_NOTIFY_OBJ, 0,
                                (LPARAM)&pNotifyObj);

  if (lResult && pNotifyObj)
  {
    CMultiSelectErrorDialog dlg(hNotifyObj, hPage);
    
    CPageInfo* pPageInfoArray = pNotifyObj->m_pPageInfoArray;
    UINT cPages = pNotifyObj->m_cPages;
    IDataObject* pDataObject = pNotifyObj->m_pAppThdDataObj;

    dspAssert(pPageInfoArray);
    dspAssert(cPages > 0);
    dspAssert(pDataObject);

    HRESULT hr = dlg.Init(pPageInfoArray, 
                          cPages, 
                          pDataObject);
    if (SUCCEEDED(hr))
    {
      dlg.DoModal();
      SetForegroundWindow(dlg.m_hWnd);

      for (UINT pageIdx = 0; pageIdx < cPages; pageIdx++)
      {
        pPageInfoArray[pageIdx].m_ApplyErrors.Clear();
        pPageInfoArray[pageIdx].m_ApplyStatus = CPageInfo::notAttempted;
      }
    }
  }
#endif
  return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::Create
//
//  Synopsis:   Creation procedure: creates instances of the object.
//
//  Arguments:  [pAppThdDataObj] - the unmarshalled data object pointer.
//              [pwzADsObjName]  - object path name.
//              [phNotifyObj]    - to return the notificion window handle.
//
//  Returns:    HRESULTs.
//
//-----------------------------------------------------------------------------
HRESULT
CNotifyObj::Create(LPDATAOBJECT pAppThdDataObj, PWSTR pwzADsObjName,
                   HWND * phNotifyObj)
{
    HWND hNotify;
    HRESULT hr = S_OK;

    // Only one caller at a time.
    //
    CNotifyCreateCriticalSection NotifyCS;

    //
    // See if the object/window already exist for this property sheet and
    // get the object DN.
    //
    hNotify = FindSheetNoSetFocus(pwzADsObjName);

    if (hNotify != NULL)
    {
        // The window already exists, return the window handle.
        //
        *phNotifyObj = hNotify;
        dspDebugOut((DEB_ITRACE, "CNotifyObj::Create returning existing notify obj HWND.\n"));
        return S_OK;
    }
    dspDebugOut((DEB_ITRACE, "CNotifyObj::Create, creating notify obj.\n"));

    long lNotifyHandle;
    PPROPSHEETCFG pSheetCfg;
    PROPSHEETCFG sheetCfg;
    ZeroMemory(&sheetCfg, sizeof(PROPSHEETCFG));
    STGMEDIUM sm = {TYMED_NULL, NULL, NULL};
    FORMATETC fmte = {g_cfDsPropCfg, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    hr = pAppThdDataObj->GetData(&fmte, &sm);

    if (FAILED(hr))
    {
        if (hr != DV_E_FORMATETC)
        {
            REPORT_ERROR_FORMAT(hr, IDS_NOTIFYFAILURE, GetDesktopWindow());
            return hr;
        }
        lNotifyHandle = 0;
    }
    else
    {
        pSheetCfg = (PPROPSHEETCFG)sm.hGlobal;

        dspAssert(pSheetCfg);
        memcpy(&sheetCfg, pSheetCfg, sizeof(PROPSHEETCFG));

        GlobalFree(sm.hGlobal);
    }

    //
    // Create the notification object.
    //
    CNotifyObj * pNotifyObj = new CNotifyObj(pAppThdDataObj, &sheetCfg);

    CHECK_NULL_REPORT(pNotifyObj, GetDesktopWindow(), return ERROR_OUTOFMEMORY);

    if (pNotifyObj->m_hr != S_OK)
    {
        REPORT_ERROR_FORMAT(pNotifyObj->m_hr, IDS_NOTIFYFAILURE, GetDesktopWindow());
        return pNotifyObj->m_hr;
    }

    dspDebugOut((DEB_ITRACE, "Notify Obj (this: 0x%p) object allocated, pAppThdDataObj = 0x%08p\n",
                 pNotifyObj, pAppThdDataObj));

    if (!AllocWStr(pwzADsObjName, &pNotifyObj->m_pwzObjDN))
    {
        return E_OUTOFMEMORY;
    }

    uintptr_t hThread;

    hThread = _beginthread(NotifyThreadFcn, 0, (PVOID)pNotifyObj);

    if (hThread == -1)
    {
        dspDebugOut((DEB_ERROR, "_beginthread failed with error %s\n",
                     strerror(errno)));
        REPORT_ERROR_FORMAT(ERROR_NOT_ENOUGH_MEMORY, IDS_NOTIFYFAILURE, GetDesktopWindow());
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Wait for initialization to complete and return the results.
    //
    if (WaitForSingleObject(pNotifyObj->m_hInitEvent, DSPROP_WAITTIME) == WAIT_TIMEOUT)
    {
        CloseHandle(pNotifyObj->m_hInitEvent);
        REPORT_ERROR_FORMAT(0, IDS_NOTIFYTIMEOUT, GetDesktopWindow());
        return HRESULT_FROM_WIN32(WAIT_TIMEOUT);
    }

    CloseHandle(pNotifyObj->m_hInitEvent);

    if (pNotifyObj->m_hWnd != NULL)
    {
        *phNotifyObj = pNotifyObj->m_hWnd;
    }
    else
    {
        REPORT_ERROR_FORMAT(pNotifyObj->m_hr, IDS_NOTIFYFAILURE, GetDesktopWindow());
        hr = pNotifyObj->m_hr;
        delete pNotifyObj;
        return hr;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::GetInitInfo
//
//  Synopsis:   Pages call this at their init time to retreive DS object info.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [pInitParams] - struct filled in with DS object info.
//
//  Note that pInitParams->pWritableAttrs can be NULL if there are no writable
//  attributes.
//
//-----------------------------------------------------------------------------
BOOL
CNotifyObj::GetInitInfo(HWND hNotifyObj, PADSPROPINITPARAMS pInitParams)
{
    dspDebugOut((DEB_ITRACE, "CNotifyObj::GetInitInfo\n"));
    if (IsBadWritePtr(pInitParams, sizeof(ADSPROPINITPARAMS)))
    {
        return FALSE;
    }
    dspAssert(hNotifyObj && pInitParams);
    if (!IsWindow(hNotifyObj))
    {
        pInitParams->hr = E_FAIL;
        return FALSE;
    }
    if (pInitParams->dwSize != sizeof (ADSPROPINITPARAMS))
    {
        return FALSE;
    }
    SendMessage(hNotifyObj, WM_ADSPROP_NOTIFY_PAGEINIT, 0,
                (LPARAM)pInitParams);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::SetHwnd
//
//  Synopsis:   Pages call this at their dialog init time to send their hwnd.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [hPage]       - the page's window handle.
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
BOOL
CNotifyObj::SetHwnd(HWND hNotifyObj, HWND hPage, PTSTR ptzTitle)
{
    dspDebugOut((DEB_ITRACE, "CNotifyObj::SetHwnd\n"));
    dspAssert(hNotifyObj && hPage);
    if (!IsWindow(hNotifyObj))
    {
        return FALSE;
    }
    SendMessage(hNotifyObj, WM_ADSPROP_NOTIFY_PAGEHWND, (WPARAM)hPage, (LPARAM)ptzTitle);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     NotifyThreadFcn
//
//  Synopsis:   Object window creation and message loop thread.
//
//-----------------------------------------------------------------------------
VOID __cdecl
NotifyThreadFcn(PVOID pParam)
{
  // All of the function except the _endthread() call is enclosed in braces
  // so that the dtors of the auto classes would run. Otherwise the thread is
  // ended before the function scope is left and the auto class object dtors
  // never run.
  {
    CNotifyObj * pNotifyObj = (CNotifyObj *)pParam;
    dspAssert(pNotifyObj);

    MSG msg;

    CSmartPtr <TCHAR> ptzTitle;
    if (!UnicodeToTchar(pNotifyObj->m_pwzObjDN, &ptzTitle))
    {
        pNotifyObj->m_hr = E_OUTOFMEMORY;
        SetEvent(pNotifyObj->m_hInitEvent);
        return;
    }

    CStr cstrTitle(ptzTitle);

    WCHAR szIH[10];
    _itow(g_iInstance, szIH, 16);

    cstrTitle += szIH;

    //
    // The window title is set to the DN of the object plus the instance
    // identifier converted to a string. This enables FindWindow to locate a
    // pre-existing instance of the notify window for a specific object for
    // a specific instance of DS Admin.
    //
    pNotifyObj->m_hWnd = CreateWindow(tzNotifyWndClass, cstrTitle, WS_POPUP,
                                      0, 0, 1, 1, NULL, NULL, g_hInstance,
                                      pNotifyObj);
    if (pNotifyObj->m_hWnd == NULL)
    {
        DWORD dwErr = GetLastError();
        dspDebugOut((DEB_ERROR,
                     "Notify Obj window creation failed with error %d!\n",
                     dwErr));
        pNotifyObj->m_hr = HRESULT_FROM_WIN32(dwErr);
        SetEvent(pNotifyObj->m_hInitEvent);
        return;
    }
    dspDebugOut((DEB_ITRACE, "Notify Obj (this: 0x%p) window creation complete.\n",
                 pNotifyObj));

    SetEvent(pNotifyObj->m_hInitEvent);

    while (GetMessage(&msg, NULL, 0, 0))
    {
        DispatchMessage(&msg);
    }

    delete pNotifyObj;
  }
  _endthread();
}

//+----------------------------------------------------------------------------
//
//  Method:     _FindDSAHiddenWindowFromDSFind
//
//  Synopsis:   Looks for hidden DSA window of the snapin instance calling DS Find
//
//  Returns:    HWND of DSA hidden window if called from DS Find.
//
//-----------------------------------------------------------------------------

BOOL CALLBACK EnumDSAHiddenWindowProc(HWND hwnd,	LPARAM lParam)
{
    HWND* phWnd = (HWND*)lParam;
    *phWnd = NULL;

    // get the window class
    TCHAR szClass[64];
    if (0 == GetClassName(hwnd, szClass, 64))
    {
        return TRUE;
    }
    
    if (_tcscmp(szClass, TEXT("DSAHiddenWindow")) != 0)
    {
        return TRUE; // no match, continue
    }


    // got a DSA hidden window
    // get the window title, to make sure it is 
    // the one originating DS Find

	  TCHAR szTitle[256];
	  ::GetWindowText(hwnd, szTitle, 256);
	  if (_tcscmp(szTitle, TEXT("DS Find")) != 0)
	  {
        return TRUE; // no match continue
    }

    // we go the right class and title, but
    // we still have to verify it is from the 
    // same process (assuming DS Find modal)

    DWORD dwProcessId = 0x0;
    GetWindowThreadProcessId(hwnd, &dwProcessId);

    if (GetCurrentProcessId() != dwProcessId)
    {
        return TRUE; // from wrong process, continue
    }

    // finally, we got it!!

		*phWnd = hwnd;
		return FALSE;
}


HWND _FindDSAHiddenWindowFromDSFind()
{
    HWND hwndHidden = NULL;
    EnumWindows(EnumDSAHiddenWindowProc, (LPARAM)&hwndHidden);  
    return hwndHidden;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::CNotifyObj
//
//-----------------------------------------------------------------------------
CNotifyObj::CNotifyObj(LPDATAOBJECT pDataObj, PPROPSHEETCFG pSheetCfg) :
    m_hWnd(NULL),
    m_hPropSheet(NULL),
    m_cPages(0),
    m_cApplies(0),
    m_pAppThdDataObj(pDataObj),
    m_pStrmMarshalledDO(NULL),
    m_hInitEvent(NULL),
    m_fBeingDestroyed(FALSE),
    m_fSheetDirty(FALSE),
    m_hr(S_OK),
    m_pwzObjDN(NULL),
    m_pDsObj(NULL),
    m_pwzCN(NULL),
    m_pWritableAttrs(NULL),
    m_pAttrs(NULL),
    m_pPageInfoArray(NULL)
{
#ifdef _DEBUG
  strcpy(szClass, "CNotifyObj");
#endif

  memcpy(&m_sheetCfg, pSheetCfg, sizeof(PROPSHEETCFG));


  if (m_sheetCfg.hwndHidden == NULL)
  {
    // we might be called from DS Find, so we want to find
    // the DSA hidden window, needed for creating
    // secondary property sheets
    m_sheetCfg.hwndHidden = _FindDSAHiddenWindowFromDSFind();
  }


  //
  // We need to addref the data object but can't release it on this thread,
  // so we marshall it (which implicitly addrefs it) and then then unmarshall
  // and release on the notify object thread.
  //
  CoMarshalInterThreadInterfaceInStream(IID_IDataObject,
                                        pDataObj,
                                        &m_pStrmMarshalledDO);

  m_hInitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  if (m_hInitEvent == NULL)
  {
    m_hr = HRESULT_FROM_WIN32(GetLastError());
  }

  //
  // Arbitrary default size.  This will expand as more pages are added
  //
  m_nPageInfoArraySize = 5;
  m_pPageInfoArray = new CPageInfo[m_nPageInfoArraySize];
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::~CNotifyObj
//
//-----------------------------------------------------------------------------
CNotifyObj::~CNotifyObj(void)
{
  NOTIFYOUT(destructor);

  LPDATAOBJECT pNotifyThdDataObj = NULL;

  if (m_pStrmMarshalledDO)
  {
    CoGetInterfaceAndReleaseStream(m_pStrmMarshalledDO,
                                   IID_IDataObject,
                                   reinterpret_cast<void**>(&pNotifyThdDataObj));
    m_pStrmMarshalledDO = NULL;
  }
  DO_RELEASE(pNotifyThdDataObj);
  //DBG_OUT("-----------------------releasing object in notify obj dtor");
  DO_RELEASE(m_pDsObj);

  if (m_sheetCfg.lNotifyHandle)
  {
    MMCFreeNotifyHandle(m_sheetCfg.lNotifyHandle);
  }
  if (m_sheetCfg.hwndHidden && m_sheetCfg.wParamSheetClose)
  {
   ::PostMessage(m_sheetCfg.hwndHidden, 
                 WM_DSA_SHEET_CLOSE_NOTIFY, 
                 (WPARAM)m_sheetCfg.wParamSheetClose, 
                 (LPARAM)0);
  }
  DO_DEL(m_pwzObjDN);
  if (m_pAttrs)
  {
    FreeADsMem(m_pAttrs);
  }

  if (m_pPageInfoArray != NULL)
  {
    delete[] m_pPageInfoArray;
    m_pPageInfoArray = NULL;
  }

}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::StaticNotifyProc
//
//  Synopsis:   window procedure
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CNotifyObj::StaticNotifyProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNotifyObj * pNotifyObj = (CNotifyObj*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (uMsg == WM_CREATE)
    {
        pNotifyObj = (CNotifyObj *)((CREATESTRUCT *)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pNotifyObj);
    }

    if (pNotifyObj)
    {
        return pNotifyObj->NotifyProc(hWnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::NotifyProc
//
//  Synopsis:   Instance window procedure
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CNotifyObj::NotifyProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uMsg)
  {
  case WM_CREATE:
    return OnCreate();

  case WM_ADSPROP_NOTIFY_PAGEINIT:
    dspDebugOut((DEB_ITRACE,
                 "Notify Obj 0x%p: WM_ADSPROP_NOTIFY_PAGEINIT\n",
                 this));
    PADSPROPINITPARAMS pInitParams;
    pInitParams = (PADSPROPINITPARAMS)lParam;
    pInitParams->hr = m_hr;
    pInitParams->pDsObj = m_pDsObj;
    pInitParams->pwzCN = m_pwzCN;
    pInitParams->pWritableAttrs = m_pWritableAttrs;
    return 0;

  case WM_ADSPROP_NOTIFY_PAGEHWND:
    {
      m_cApplies = ++m_cPages;
      dspDebugOut((DEB_ITRACE,
                   "Notify Obj 0x%p: WM_ADSPROP_NOTIFY_PAGEHWND count now %d\n",
                   this, m_cPages));
      HWND hWndPage = (HWND)wParam;
      if (!m_hPropSheet)
      {
        m_hPropSheet = GetParent(hWndPage);
      }

      if (m_cPages > m_nPageInfoArraySize)
      {
        //
        // REVIEW_JEFFJON : after going beyond the initial size, should the size increase
        //                  incrementally or in chunks?
        //
        CPageInfo* pNewPageInfoArray = new CPageInfo[m_cPages];
        if (pNewPageInfoArray != NULL)
        {
          memset(pNewPageInfoArray, 0, sizeof(CPageInfo) * m_cPages);
          memcpy(pNewPageInfoArray, m_pPageInfoArray, sizeof(CPageInfo) * m_nPageInfoArraySize);
          delete[] m_pPageInfoArray;
          m_pPageInfoArray = pNewPageInfoArray;
          m_nPageInfoArraySize = m_cPages;
        }
      }

      m_pPageInfoArray[m_cPages - 1].m_hWnd = hWndPage;

      //
      // Copy the title if one was sent
      //
      PTSTR ptzPageTitle = reinterpret_cast<PTSTR>(lParam);
      if (ptzPageTitle != NULL)
      {
        size_t iTitleSize = _tcslen(ptzPageTitle);
        m_pPageInfoArray[m_cPages - 1].m_ptzTitle = new TCHAR[iTitleSize + 1];
        if (m_pPageInfoArray[m_cPages - 1].m_ptzTitle != NULL)
        {
          _tcscpy(m_pPageInfoArray[m_cPages - 1].m_ptzTitle, ptzPageTitle);
        }
      }
    }
    return 0;

  case WM_ADSPROP_NOTIFY_APPLY:
    {
      NOTIFYOUT(WM_ADSPROP_NOTIFY_APPLY);
      if ((BOOL)wParam)
      {
        // The security page and extension pages don't inherit from our
        // page framework and thus don't participate in the notify object
        // refcounting or the page-dirty flagging. So, don't fire a change
        // notification unless one of our pages was dirty.
        //
        m_fSheetDirty = TRUE;
      }

      // NTRAID#NTBUG9-462165-2001/10/17-JeffJon
      // Need to set the apply status to success.

      HWND hPage = reinterpret_cast<HWND>(lParam);
      if (hPage)
      {
        for (UINT idx = 0; idx < m_cPages; idx++)
        {
          if (m_pPageInfoArray[idx].m_hWnd == hPage)
          {
             m_pPageInfoArray[idx].m_ApplyStatus = CPageInfo::success;
             break;
          }
        }
      }

      if (--m_cApplies == 0 && m_fSheetDirty)
      {
        NOTIFYOUT(Sending change notification);
        if (m_sheetCfg.lNotifyHandle)
        {
          // The change notify call results in a PostMessage back to the
          // MMC main thread. Therefore, we need to pass the data object
          // pointer that came from the main thread.
          //
          MMCPropertyChangeNotify(m_sheetCfg.lNotifyHandle, (LPARAM)m_pAppThdDataObj);
        }
        if (m_sheetCfg.hwndParentSheet)
        {
          PostMessage(m_sheetCfg.hwndParentSheet, WM_ADSPROP_NOTIFY_CHANGE, 0, 0);
        }
        m_cApplies = m_cPages;
        m_fSheetDirty = FALSE;

        //
        // Change the status of all the pages back to notAttempted
        //
        for (UINT idx = 0; idx < m_cPages; idx++)
        {
          m_pPageInfoArray[idx].m_ApplyStatus = CPageInfo::notAttempted;
        }

      }
      return 0;
    }

  case WM_ADSPROP_NOTIFY_ERROR:
    {
      NOTIFYOUT(WM_ADSPROP_NOTIFY_ERROR);
      PADSPROPERROR pApplyErrors = reinterpret_cast<PADSPROPERROR>(lParam);
      if (pApplyErrors != NULL)
      {
        for (UINT idx = 0; idx < m_cPages; idx++)
        {
          if (m_pPageInfoArray[idx].m_hWnd == pApplyErrors->hwndPage)
          {
            m_pPageInfoArray[idx].m_ApplyErrors.SetError(pApplyErrors);
            if (m_pPageInfoArray[idx].m_ApplyErrors.GetErrorCount() > 0)
            {
              m_pPageInfoArray[idx].m_ApplyStatus = CPageInfo::failed;
            }
            else
            {
              m_pPageInfoArray[idx].m_ApplyStatus = CPageInfo::success;
            }
            break;
          }
        }
      }
      return 0;
    }

  case WM_ADSPROP_NOTIFY_GET_NOTIFY_OBJ:
    {
      NOTIFYOUT(WM_ADSPROP_NOTIFY_GET_NOTIFY_OBJ);
      BOOL retVal = FALSE;
      if (lParam != NULL)
      {
        CNotifyObj** ppNotifyObj = reinterpret_cast<CNotifyObj**>(lParam);
        if (ppNotifyObj)
        {
          *ppNotifyObj = this;
          retVal = TRUE;
        }
      }
      return retVal;
    }

  case WM_ADSPROP_NOTIFY_SETFOCUS:
    NOTIFYOUT(WM_ADSPROP_NOTIFY_SETFOCUS);
    SetForegroundWindow(m_hPropSheet);
    return 0;

  case WM_ADSPROP_NOTIFY_FOREGROUND:
    NOTIFYOUT(WM_ADSPROP_NOTIFY_FOREGROUND);
    if (wParam) //  bActivate flag
    {
      SetForegroundWindow(m_hPropSheet);
    }
    else
    {
      SetWindowPos(m_hPropSheet, HWND_TOP, 
                   0,0,0,0,
                    SWP_NOMOVE | SWP_NOSIZE);
    }
    return 0;

  case WM_ADSPROP_SHEET_CREATE:
    NOTIFYOUT(WM_ADSPROP_SHEET_CREATE);

    if (m_sheetCfg.hwndHidden)
    {
      ::PostMessage(m_sheetCfg.hwndHidden, 
                   WM_DSA_SHEET_CREATE_NOTIFY, 
                   wParam, 
                   lParam);
    }
    return 0;

  case WM_ADSPROP_NOTIFY_EXIT:
    {
      NOTIFYOUT(WM_ADSPROP_NOTIFY_EXIT);
      if (m_fBeingDestroyed)
      {
        return 0;
      }
      m_fBeingDestroyed = TRUE;

      DestroyWindow(hWnd);
      return 0;
    }

  case WM_DESTROY:
    NOTIFYOUT(WM_DESTROY);
    CoUninitialize();
    PostQuitMessage(0);
    return 0;

  default:
    break;
  }

  return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::OnCreate
//
//  Synopsis:   Window creation/initialization processing. Bind to the DS
//              object and read its CN and Allowed-Attributes-Effective
//              properties.
//
//-----------------------------------------------------------------------------
LRESULT
CNotifyObj::OnCreate(void)
{
    NOTIFYOUT(WM_CREATE);
    HRESULT hr;
    DWORD cAttrs;

    CoInitialize(NULL);

    //
    // we need to check to see if we can
    // convert the string to a CLSID.  If
    // we can then this is a multi-select
    // property page and we shouldn't try
    // to bind.
    //
    CLSID clsid;
    if (SUCCEEDED(::CLSIDFromString(m_pwzObjDN, &clsid)))
    {
      m_hr = S_OK;
      return S_OK;
    }

    //DBG_OUT("+++++++++++++++++++++++++++addrefing (opening) object");
    hr = ADsOpenObject(m_pwzObjDN, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                       IID_IDirectoryObject, (PVOID *)&m_pDsObj);

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        // ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS);
        m_hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    if (hr == 0x80070051)
    {
        // On subsequent network failures, ADSI returns this error code which
        // is not documented anywhere. I'll turn it into a documented error
        // code which happens to be the code returned on the first failure.
        //
        hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP);
    }
    if (hr == HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP))
    {
        // ErrMsg(IDS_ERRMSG_NO_DC_RESPONSE);
        m_hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP);
        return 0;
    }
    CHECK_HRESULT(hr, m_hr = hr; return hr);

    PWSTR rgszNames[2] = {g_wzName, g_wzAllowed};

    hr = m_pDsObj->GetObjectAttributes(rgszNames, 2, &m_pAttrs, &cAttrs);

    CHECK_HRESULT(hr, m_hr = hr; return hr);

    dspAssert(cAttrs >= 1); // expect to always get name.

    for (DWORD i = 0; i < cAttrs; i++)
    {
        if (_wcsicmp(m_pAttrs[i].pszAttrName, g_wzName) == 0)
        {
            m_pwzCN = m_pAttrs[i].pADsValues->CaseIgnoreString;
            continue;
        }

        if (_wcsicmp(m_pAttrs[i].pszAttrName, g_wzAllowed) == 0)
        {
            m_pWritableAttrs = &m_pAttrs[i];

#if DBG == 1
            for (DWORD j = 0; j < m_pAttrs[i].dwNumValues; j++)
            {
                dspDebugOut((DEB_USER4, "Allowed attribute (effective): %ws\n",
                             m_pAttrs[i].pADsValues[j].CaseIgnoreString));
            }
#endif
        }
    }
    
    NOTIFYOUT(WM_CREATE done);
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   RegisterNotifyClass
//
//  Synopsis:   Register the window class for the notification window.
//
//-----------------------------------------------------------------------------
VOID
RegisterNotifyClass(void)
{
    WNDCLASS wcls;
    wcls.style = 0;
    wcls.lpfnWndProc = CNotifyObj::StaticNotifyProc;
    wcls.cbClsExtra = 0;
    wcls.cbWndExtra = 0;
    wcls.hInstance = g_hInstance;
    wcls.hIcon = NULL;
    wcls.hCursor = NULL;
    wcls.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcls.lpszMenuName = NULL;
    wcls.lpszClassName = tzNotifyWndClass;

    RegisterClass(&wcls);
}

//+----------------------------------------------------------------------------
//
//  Function:   FindSheetNoSetFocus
//
//  Synopsis:   Locate the property sheet for the DS object.
//
//-----------------------------------------------------------------------------
HWND
FindSheetNoSetFocus(PWSTR pwzObjADsPath)
{
    HWND hNotify = NULL;
    //
    // See if the object/window already exists for this property sheet.
    // Note that the window title is the DN of the object plus the instance id.
    //
#ifdef UNICODE
    CStr cstrTitle(pwzObjADsPath);

    WCHAR szIH[10];
    _itow(g_iInstance, szIH, 16);

    cstrTitle += szIH;

    hNotify = FindWindow(tzNotifyWndClass, cstrTitle);
#else
    LPSTR pszTitle;
    if (UnicodeToTchar(pwzObjADsPath, &pszTitle))
    {
        CStr cstrTitle(pszTitle);

        char szIH[10];
        _itoa(g_iInstance, szIH, 16);

        cstrTitle += szIH;

        hNotify = FindWindow(tzNotifyWndClass, cstrTitle);
        delete [] pszTitle;
    }
#endif

    dspDebugOut((DEB_ITRACE, "FindSheet: returned hNotify = 0x%08x\n", hNotify));

    return hNotify;
}

//+----------------------------------------------------------------------------
//
//  Function:   BringSheetToForeground
//
//  Synopsis:   Locate the property sheet for the DS object identified by the
//              data object and bring it to the top of the Z order
//
//-----------------------------------------------------------------------------
extern "C" BOOL 
BringSheetToForeground(PWSTR pwzObjADsPath, BOOL bActivate)
{
    HWND hNotify = FindSheetNoSetFocus(pwzObjADsPath);

    if (!hNotify)
    {
        return FALSE;
    }

    PostMessage(hNotify, WM_ADSPROP_NOTIFY_FOREGROUND, (WPARAM)bActivate, 0);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   FindSheet
//
//  Synopsis:   Locate the property sheet for the DS object identified by the
//              data object. For use in the dsprop DLL. If found, bring the
//              sheet to the foregroung and set the focus to the sheet.
//
//-----------------------------------------------------------------------------
BOOL
FindSheet(PWSTR pwzObjADsPath)
{
    HWND hNotify = FindSheetNoSetFocus(pwzObjADsPath);

    if (!hNotify)
    {
        return FALSE;
    }

    SendMessage(hNotify, WM_ADSPROP_NOTIFY_SETFOCUS, 0, 0);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   IsSheetAlreadyUp
//
//  Synopsis:   Public, exported function to locate a prop sheet for the DS
//              object identified by the data object. If found, sends a message
//              to the sheet to bring it to the foreground.
//
//-----------------------------------------------------------------------------
extern "C" BOOL
IsSheetAlreadyUp(LPDATAOBJECT pDataObj)
{
    // Get the object's DN from the data object.
    //
    HRESULT hr = S_OK;
    STGMEDIUM sm = {TYMED_NULL, NULL, NULL};
    FORMATETC fmte = {g_cfDsMultiSelectProppages, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    PWSTR pszUniqueID;

    BOOL fFound = FALSE;
    hr = pDataObj->GetData(&fmte, &sm);

    if (FAILED(hr))
    {
      STGMEDIUM smDS = {TYMED_NULL, NULL, NULL};
      FORMATETC fmteDS = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
      LPDSOBJECTNAMES pDsObjectNames;

      hr = pDataObj->GetData(&fmteDS, &smDS);

      if (FAILED(hr))
      {
        return FALSE;
      }

      pDsObjectNames = (LPDSOBJECTNAMES)smDS.hGlobal;

      dspAssert(pDsObjectNames->cItems > 0);

      pszUniqueID = (LPWSTR)ByteOffset(pDsObjectNames,
                                       pDsObjectNames->aObjects[0].offsetName);

      fFound = FindSheet(pszUniqueID);

      GlobalFree(smDS.hGlobal);
    }
    else
    {
      pszUniqueID = (PWSTR)sm.hGlobal;
      dspAssert(pszUniqueID != NULL);

      fFound = FindSheet(pszUniqueID);

      ReleaseStgMedium(&sm);

    }

    return fFound;
}

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Method:     CMultiSelectErrorDialog::CMultiSelectErrorDialog
//
//  Synopsis:   Multi-select error message dialog constructor
//
//-----------------------------------------------------------------------------
CMultiSelectErrorDialog::CMultiSelectErrorDialog(HWND hNotifyObj, HWND hParent)
  : m_hWnd(NULL),
    m_hNotifyObj(hNotifyObj),
    m_hParent(hParent),
    m_bModal(FALSE),
    m_bInit(FALSE),
    m_pPageInfoArray(NULL),
    m_nPageCount(0),
    m_pDataObj(NULL)
{

}
    
//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::StaticDlgProc
//
//  Synopsis:   The static dialog proc for displaying errors for multi-select pages
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK CMultiSelectErrorDialog::StaticDlgProc(HWND hDlg, 
                                                        UINT uMsg, 
                                                        WPARAM wParam,
                                                        LPARAM lParam)
{
  CMultiSelectErrorDialog* dlg = NULL;

  UINT code;
  UINT id;
  switch (uMsg)
  {
    case WM_INITDIALOG:
      dlg = reinterpret_cast<CMultiSelectErrorDialog*>(lParam);
      dspAssert(dlg != NULL);
      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)dlg);
      SetForegroundWindow(hDlg);
      return dlg->OnInitDialog(hDlg);

    case WM_COMMAND:
      code = GET_WM_COMMAND_CMD(wParam, lParam);
      id   = GET_WM_COMMAND_ID(wParam, lParam);
      if (dlg == NULL)
      {
        dlg = reinterpret_cast<CMultiSelectErrorDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));
      }
      switch (id)
      {
        case IDOK:
        case IDCANCEL:
          if (code == BN_CLICKED)
          {
            dlg->OnClose();
          }
          break;
        case IDC_COPY_BUTTON:
          if (code == BN_CLICKED)
          {
            dlg->OnCopyButton();
          }
          break;
        case IDC_PROPERTIES_BUTTON:
          if (code == BN_CLICKED)
          {
            dlg->ShowListViewItemProperties();
          }
          break;
      }
      break;

    case WM_NOTIFY:
      {
        if (dlg == NULL)
        {
          dlg = reinterpret_cast<CMultiSelectErrorDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));
        }
        int idCtrl = (int)wParam;
        LPNMHDR pnmh = reinterpret_cast<LPNMHDR>(lParam);
        if (idCtrl == IDC_ERROR_LIST)
        {
          switch (pnmh->code)
          {
            case NM_DBLCLK:
              {
                dlg->ListItemActivate(pnmh);
              }
              break;

            case LVN_ITEMCHANGED:
            case NM_CLICK:
              {
                dlg->ListItemClick(pnmh);
              }
              break;
            default:
              break;
          }
        }
        break;
      }

    case WM_HELP:
      {
        LPHELPINFO pHelpInfo = reinterpret_cast<LPHELPINFO>(lParam);
        if (!pHelpInfo || pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
        {
          return 0;
        }
        WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
        break;
      }
  }
  return 0;
}

BOOL LoadStringToTcharFromDsPrpRes(int ids, PTSTR * pptstr)
{
    static const int MAX_STRING = 1024;

    TCHAR szBuf[MAX_STRING];

    HMODULE hDsPropRes = ::LoadLibraryEx(L"dsprpres.dll", 0, LOAD_LIBRARY_AS_DATAFILE);
    BOOL result = FALSE;

    do
    {
        if (!LoadString(hDsPropRes, ids, szBuf, MAX_STRING - 1))
        {
            break;
        }

        *pptstr = new TCHAR[_tcslen(szBuf) + 1];

        CHECK_NULL(*pptstr, return FALSE);

        _tcscpy(*pptstr, szBuf);

        result = TRUE;
    }
    while (0);

    ::FreeLibrary(hDsPropRes);

    return result;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::Init
//
//  Synopsis:   Initializes the member variables
//
//-----------------------------------------------------------------------------
BOOL CMultiSelectErrorDialog::OnInitDialog(HWND hDlg)
{
  dspAssert(m_bInit);
  if (!m_bInit)
  {
    return TRUE;
  }

  m_hWnd = hDlg;

  //
  // Disable the properties button until there is a selection
  //
  EnableWindow(GetDlgItem(m_hWnd, IDC_PROPERTIES_BUTTON), FALSE);

  HRESULT hr = S_OK;
  hr = InitializeListBox(hDlg);
  CHECK_HRESULT(hr, return TRUE;);

  CComPtr<IADsPathname> spPathCracker;

  hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                        IID_IADsPathname, (PVOID *)&spPathCracker);

  CHECK_HRESULT_REPORT(hr, hDlg, return TRUE);

  dspAssert(m_pPageInfoArray != NULL);
  if (m_pPageInfoArray == NULL)
  {
    return TRUE;
  }

  INT iMaxLen = 0;
  SIZE size = {0,0};

  //
  // Load the appropriate list box
  //
  for (UINT pageIdx = 0; pageIdx < m_nPageCount; pageIdx++)
  {
    if (m_pPageInfoArray[pageIdx].m_ApplyStatus == CPageInfo::failed)
    {
      PTSTR ptzCaptionFormat = NULL;

      LoadStringToTcharFromDsPrpRes(IDS_MULTI_FAILURE_CAPTION, &ptzCaptionFormat);

      if (ptzCaptionFormat != NULL)
      {
        PWSTR pszCaption = new WCHAR[wcslen(ptzCaptionFormat) + wcslen(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetPageTitle()) + 1];
        if (pszCaption != NULL)
        {
          wsprintf(pszCaption, ptzCaptionFormat, m_pPageInfoArray[pageIdx].m_ApplyErrors.GetPageTitle());
          SetWindowText(GetDlgItem(m_hWnd, IDC_ERROR_STATIC), pszCaption);
          delete[] pszCaption;
          pszCaption = NULL;
        }
      }

      for (UINT objectIdx = 0; objectIdx < m_pPageInfoArray[pageIdx].m_ApplyErrors.GetCount(); objectIdx++)
      {
        //
        // Get the objects path and class name
        //
        PWSTR pszObjPath = m_pPageInfoArray[pageIdx].m_ApplyErrors.GetName(objectIdx);
        PWSTR pszObjClass = m_pPageInfoArray[pageIdx].m_ApplyErrors.GetClass(objectIdx);

        //
        // Get the class icon for the object
        //
        int iIcon = g_ClassIconCache.GetClassIconIndex(pszObjClass);
        dspAssert(iIcon != -1);

        //
        // Get the object name from the path
        //
        PWSTR pszLabel = NULL;
        CComBSTR bstr;
        hr = spPathCracker->Set(pszObjPath,
                                ADS_SETTYPE_FULL);
        CHECK_HRESULT(hr, pszLabel = pszObjPath;);

        if (SUCCEEDED(hr))
        {
          hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
          CHECK_HRESULT(hr, pszLabel = pszObjPath;);
        }

        // CODEWORK 122531 Should we be turning off escaped mode here?

        if (SUCCEEDED(hr))
        {
          hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstr);
          CHECK_HRESULT(hr, pszLabel = pszObjPath;);
        }

        if (SUCCEEDED(hr))
        {
          pszLabel = bstr;
        }
        dspAssert(pszLabel != NULL);

        //
        // Create the list view item
        //
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iSubItem = IDX_NAME_COL;

        lvi.lParam = (LPARAM)pszObjPath;
        lvi.pszText = pszLabel;
        lvi.iItem = objectIdx;

        if (-1 != iIcon)
        {
          lvi.mask |= LVIF_IMAGE;
          lvi.iImage = iIcon;
        }

        //
        // Insert the new item
        //
        int NewIndex = ListView_InsertItem(m_hList, &lvi);
        dspAssert(NewIndex != -1);
        if (NewIndex == -1)
        {
          continue;
        }

        //
        // Format the error message and insert it
        //
        PWSTR ptzMsg = NULL;
        if (FAILED(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetError(objectIdx)))
        {
          LoadErrorMessage(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetError(objectIdx), 0, &ptzMsg);
          if (!ptzMsg)
          {
             ptzMsg = L""; // make prefix happy.
          }
          //
          // REVIEW_JEFFJON : this is hack to get rid of two extra characters
          //                  at the end of the string
          //
          size_t iLen = wcslen(ptzMsg);
          ptzMsg[iLen - 2] = L'\0';
        }
        else
        {
          ptzMsg = new WCHAR[wcslen(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetStringError(objectIdx)) + 1];
          if (ptzMsg != NULL)
          {
            wcscpy(ptzMsg, m_pPageInfoArray[pageIdx].m_ApplyErrors.GetStringError(objectIdx));
          }
        }

        if (NULL != ptzMsg)
        {
          ListView_SetItemText(m_hList, NewIndex, IDX_ERROR_COL,
                               ptzMsg);

          INT len = lstrlen(ptzMsg);
          if( len > iMaxLen )
          {
              HDC hdc = GetDC(hDlg);         
              GetTextExtentPoint32(hdc,ptzMsg,lstrlen(ptzMsg),&size);   
              ReleaseDC(hDlg, hdc);
              iMaxLen = len;
          }
          delete[] ptzMsg;
        }
      }
    }
    else if (m_pPageInfoArray[pageIdx].m_ApplyStatus == CPageInfo::success)
    {
      //
      // Insert the page title into the success list box
      //
      SendDlgItemMessage(m_hWnd, IDC_SUCCESS_LISTBOX, LB_ADDSTRING, 0, (LPARAM)m_pPageInfoArray[pageIdx].m_ptzTitle);
    }
    else // apply not tried yet
    {
      //
      // Insert the page title into the not attempted list box
      //
      SendDlgItemMessage(m_hWnd, IDC_NOT_ATTEMPTED_LISTBOX, LB_ADDSTRING, 0, (LPARAM)m_pPageInfoArray[pageIdx].m_ptzTitle);
    }
  }

  //
  // Select the first item in the error list
  //
  LVCOLUMN col;
  col.mask = LVCF_WIDTH;
  col.cx = size.cx;
  ListView_SetColumn(m_hList,1, &col);
  ListView_SetExtendedListViewStyle(m_hList, LVS_EX_FULLROWSELECT);
  ListView_SetItemState(m_hList, 0, LVIS_SELECTED, LVIS_SELECTED);
  return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::InitializeListBox
//
//  Synopsis:   Initializes the member variables
//
//-----------------------------------------------------------------------------
HRESULT CMultiSelectErrorDialog::InitializeListBox(HWND hDlg)
{

  m_hList = GetDlgItem(hDlg, IDC_ERROR_LIST);

  if (m_hList == NULL)
  {
    return HRESULT_FROM_WIN32(GetLastError());
  }

  ListView_SetExtendedListViewStyle(m_hList, LVS_EX_FULLROWSELECT);

  //
  // Set the column headings.
  //
  PTSTR ptsz;
  RECT rect;
  GetClientRect(m_hList, &rect);

  if (!LoadStringToTchar(IDS_COL_TITLE_OBJNAME, &ptsz))
  {
    ReportError(GetLastError(), 0, hDlg);
    return HRESULT_FROM_WIN32(GetLastError());
  }

  LV_COLUMN lvc = {0};
  lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
  lvc.fmt = LVCFMT_LEFT;
  lvc.cx = OBJ_LIST_NAME_COL_WIDTH;
  lvc.pszText = ptsz;
  lvc.iSubItem = IDX_NAME_COL;

  ListView_InsertColumn(m_hList, IDX_NAME_COL, &lvc);

  delete[] ptsz;

  if (!LoadStringToTchar(IDS_COL_TITLE_ERRORMSG, &ptsz))
  {
    ReportError(GetLastError(), 0, hDlg);
    return HRESULT_FROM_WIN32(GetLastError());
  }

  lvc.cx = rect.right - OBJ_LIST_NAME_COL_WIDTH;
  lvc.pszText = ptsz;
  lvc.iSubItem = IDX_ERROR_COL;

  ListView_InsertColumn(m_hList, IDX_ERROR_COL, &lvc);

  delete[] ptsz;

  //
  // Assign the imagelist to the listview
  //
  ListView_SetImageList(m_hList, g_ClassIconCache.GetImageList(), LVSIL_SMALL);
  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::Init
//
//  Synopsis:   Initializes the member variables
//
//-----------------------------------------------------------------------------
HRESULT CMultiSelectErrorDialog::Init(CPageInfo* pPageInfoArray, 
                                      UINT nPageCount,
                                      IDataObject* pDataObj)
{
  m_nPageCount = nPageCount;
  m_pPageInfoArray = pPageInfoArray;
  m_bInit = TRUE;
  m_pDataObj = pDataObj;
  m_pDataObj->AddRef();

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::OnCopyButton
//
//  Synopsis:   Called when the user presses the Retry button
//
//-----------------------------------------------------------------------------
void CMultiSelectErrorDialog::OnCopyButton()
{
  dspAssert(m_bInit);
  if (!m_bInit)
  {
    return;
  }

  dspAssert(m_pPageInfoArray != NULL);
  if (m_pPageInfoArray == NULL)
  {
    return;
  }

  CComPtr<IADsPathname> spPathCracker;
  HRESULT hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                        IID_IADsPathname, (PVOID *)&spPathCracker);
  CHECK_HRESULT_REPORT(hr, m_hWnd, return);


  if (OpenClipboard(m_hWnd) == 0)
  {
    return;
  }

  if (EmptyClipboard() == 0)
  {
    CloseClipboard();
    return;
  }

  CStrW szClipboardData;
  szClipboardData.Empty();

  for (UINT pageIdx = 0; pageIdx < m_nPageCount; pageIdx++)
  {
    for (UINT objectIdx = 0; objectIdx < m_pPageInfoArray[pageIdx].m_ApplyErrors.GetCount(); objectIdx++)
    {
      //
      // Get the objects path and class name
      //
      PWSTR pszObjPath = m_pPageInfoArray[pageIdx].m_ApplyErrors.GetName(objectIdx);

      //
      // Get the object name from the path
      //
      PWSTR pszLabel = NULL;
      CComBSTR bstr;
      hr = spPathCracker->Set(pszObjPath,
                              ADS_SETTYPE_FULL);
      CHECK_HRESULT(hr, pszLabel = pszObjPath;);

      if (SUCCEEDED(hr))
      {
        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        CHECK_HRESULT(hr, pszLabel = pszObjPath;);
      }

      // CODEWORK 122531 Should we be turning off escaped mode here?

      if (SUCCEEDED(hr))
      {
        hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstr);
        CHECK_HRESULT(hr, pszLabel = pszObjPath;);
      }

      if (SUCCEEDED(hr))
      {
        pszLabel = bstr;
      }
      dspAssert(pszLabel != NULL);

      //
      // Format the error message and insert it
      //
      PWSTR ptzMsg = NULL;
      if (FAILED(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetError(objectIdx)))
      {
        LoadErrorMessage(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetError(objectIdx), 0, &ptzMsg);
      }
      else
      {
        ptzMsg = new WCHAR[wcslen(m_pPageInfoArray[pageIdx].m_ApplyErrors.GetStringError(objectIdx)) + 1];
        if (ptzMsg != NULL)
        {
          wcscpy(ptzMsg, m_pPageInfoArray[pageIdx].m_ApplyErrors.GetStringError(objectIdx));
        }
      }

      if (NULL != ptzMsg)
      {
        szClipboardData += pszLabel;
        szClipboardData += L",";
        szClipboardData += ptzMsg;
        szClipboardData += g_wzCRLF;
        delete ptzMsg;
      }
    }
  }

  HGLOBAL hBuffer = NULL;
  DWORD   dwBufferSize;
  HANDLE  hMemClipboard;


  LPTSTR  pszGlobalBuffer = NULL;
  dwBufferSize = (szClipboardData.GetLength() + 1) * sizeof(TCHAR);
      
  hBuffer = GlobalAlloc (GMEM_MOVEABLE, dwBufferSize);
  pszGlobalBuffer = (LPTSTR)GlobalLock (hBuffer);
  if ( NULL == pszGlobalBuffer ) 
  {
    // allocation or lock failed so bail out
    GlobalFree (hBuffer);
    return;
  }

  _tcscpy ( pszGlobalBuffer, szClipboardData );
  GlobalUnlock (hBuffer);

  if ( NULL != hBuffer ) 
  {
    hMemClipboard = SetClipboardData (
#if UNICODE
                  CF_UNICODETEXT,     // UNICODE text in the clipboard
#else
                  CF_TEXT,            // ANSI text in the clipboard
#endif
                  hBuffer);
    if (hMemClipboard == NULL) 
    {
      //free memory since it didn't make it to the clipboard
      GlobalFree (hBuffer);
      return;
    }
  } 
  else 
  {
    //free memory since it didn't make it to the clipboard
    GlobalFree (hBuffer);
    return;
  }

  CloseClipboard();
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::ListItemClick
//
//  Synopsis:   Invokes a property page for the item that was activated
//
//-----------------------------------------------------------------------------
void CMultiSelectErrorDialog::ListItemClick(LPNMHDR)
{
  UINT nSelectedCount = ListView_GetSelectedCount(m_hList);
  if (nSelectedCount == 1)
  {
    EnableWindow(GetDlgItem(m_hWnd, IDC_PROPERTIES_BUTTON), TRUE);
  }
  else
  {
    EnableWindow(GetDlgItem(m_hWnd, IDC_PROPERTIES_BUTTON), FALSE);
  }
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::ListItemActivate
//
//  Synopsis:   Invokes a property page for the item that was activated
//
//-----------------------------------------------------------------------------
void CMultiSelectErrorDialog::ListItemActivate(LPNMHDR pnmh)
{
  LPNMITEMACTIVATE pActivateHeader = reinterpret_cast<LPNMITEMACTIVATE>(pnmh);
  dspAssert(pActivateHeader != NULL);
  if (pActivateHeader != NULL)
  {
    ShowListViewItemProperties();
  }
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::ShowListViewItemProperties()
//
//  Synopsis:   Invokes a secondary sheet for the selected list view item
//
//-----------------------------------------------------------------------------
BOOL CMultiSelectErrorDialog::ShowListViewItemProperties()
{
  BOOL bSuccess = TRUE;

  UINT nSelectCount = ListView_GetSelectedCount(m_hList);
  if (nSelectCount == 1)
  {
    //
    // Get the selected item
    //
    int nSelectedItem = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
    if (nSelectedItem != -1)
    {
      //
      // Retrieve the item's path
      //
      LVITEM lvi = {0};
      lvi.iItem = nSelectedItem;
      lvi.mask = LVIF_PARAM;

      if (ListView_GetItem(m_hList, &lvi))
      {
        PWSTR pwzPath = reinterpret_cast<PWSTR>(lvi.lParam);
        if (pwzPath != NULL)
        {
          //
          // Get the DN
          //
          CComPtr<IADsPathname> spPathCracker;
          HRESULT hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IADsPathname, (PVOID *)&spPathCracker);

          CHECK_HRESULT_REPORT(hr, m_hWnd, return FALSE;);

          hr = spPathCracker->Set(pwzPath, ADS_SETTYPE_FULL);
          CHECK_HRESULT_REPORT(hr, m_hWnd, return FALSE;);

          hr = spPathCracker->put_EscapedMode(ADS_ESCAPEDMODE_ON);
          dspAssert(SUCCEEDED(hr));

          hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
          CHECK_HRESULT_REPORT(hr, m_hWnd, return FALSE;);

          CComBSTR bstrDN;
          hr = spPathCracker->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
          CHECK_HRESULT_REPORT(hr, m_hWnd, return FALSE;);

          //
          // Invoke the page
          //
          hr = PostADsPropSheet(bstrDN, m_pDataObj, m_hParent, m_hNotifyObj, FALSE);
          if (FAILED(hr))
          {
            bSuccess = FALSE;
          }
        }
        else
        {
          bSuccess = FALSE;
        }
      }
      else
      {
        bSuccess = FALSE;
      }
    }
    else
    {
      bSuccess = FALSE;
    }
  }

  return bSuccess;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::OnClose
//
//  Synopsis:   Closes the modal dialog
//
//-----------------------------------------------------------------------------
void CMultiSelectErrorDialog::OnClose()
{
  EndDialog(m_hWnd, 0);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::DoModal
//
//  Synopsis:   Displays the modal dialog
//
//-----------------------------------------------------------------------------
int CMultiSelectErrorDialog::DoModal()
{
  m_bModal = TRUE;
  dspAssert(IsWindow(m_hParent));

  HMODULE hDsPropRes = ::LoadLibraryEx(L"dsprpres.dll", 0, LOAD_LIBRARY_AS_DATAFILE);

  int result = (int)DialogBoxParam(hDsPropRes, MAKEINTRESOURCE(IDD_MULTISELECT_ERROR_DIALOG),
                             m_hParent, (DLGPROC)StaticDlgProc, (LPARAM)this);

  ::FreeLibrary(hDsPropRes);

  return result;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiSelectErrorDialog::ShowWindow
//
//  Synopsis:   Displays the modeless dialog
//
//-----------------------------------------------------------------------------
BOOL CMultiSelectErrorDialog::ShowWindow()
{
  m_bModal = FALSE;

  HMODULE hDsPropRes = ::LoadLibraryEx(L"dsprpres.dll", 0, LOAD_LIBRARY_AS_DATAFILE);

  m_hWnd = CreateDialogParam(hDsPropRes, MAKEINTRESOURCE(IDD_MULTISELECT_ERROR_DIALOG),
                             m_hParent, (DLGPROC)StaticDlgProc, (LPARAM)this);

  BOOL result = ::ShowWindow(m_hWnd, SW_SHOWNORMAL);

  ::FreeLibrary(hDsPropRes);

  return result;
}
#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\inc\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE)
  #if defined(TRACE)
    #undef TRACE
    void  DSATrace(LPCWSTR, ...);
    #define TRACE DSATrace
  #endif // defined(TRACE)
#endif // defined(_USE_DSA_TRACE)


#if defined(_USE_DSA_ASSERT)
#undef ASSERT
#undef VERIFY
#undef THIS_FILE
#define THIS_FILE          __FILE__
BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
#define ASSERT(f) \
	do \
	{ \
    BOOL bLame = (f && L"some lame hack so that prefast doesn't bark"); \
  	if (!(bLame) && DSAAssertFailedLine(THIS_FILE, __LINE__)) \
	  	::DebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)
#endif // _USE_DSA_ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\shell\user.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       user.cxx
//
//  Contents:   AD user shell property pages
//
//  History:    05-May-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"
#include "user.h"
//#include "group.h"
#ifndef UNICODE
#   include <stdio.h>
#endif

//+----------------------------------------------------------------------------
//
//  Function:   CountryCode
//
//  Synopsis:   Handles the Country combo box to get/set the Country-Code
//              (LDAP display name: countryCode) numeric ISO-3166 code.
//
//  Notes:      This attr function MUST be called after CountryName. It
//              relies on CountryName populating the combobox and setting its
//              item data values.
//
//-----------------------------------------------------------------------------
HRESULT
CountryCode(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    switch(DlgOp)
    {
    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        DBG_OUT("CountryCode: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        int iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                           CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            INT_PTR pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                              CB_GETITEMDATA, iSel, 0);
            if (pCur == LB_ERR)
            {
                DWORD dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }

            PDsCountryCode pCountryCode = (PDsCountryCode)pCur;

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->Integer = pCountryCode->wCode;
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CountryName
//
//  Synopsis:   Handles the Country combo box/static control to get/set the
//              Country-Name (LDAP display name: c) 2 character ISO-3166 code.
//
//  Notes:      If the control is read-only, then assume it is a static text
//              control (or a read-only edit control) rather than a combobox.
//              Also, if read-only, then only the fInit should be called.
//
//-----------------------------------------------------------------------------
HRESULT
CountryName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    PWSTR pwsz = NULL;
    DWORD dwErr = 0;
    INT_PTR pCur = NULL;
    PDsCountryCode pCountryCode = NULL;
    int iSel = 0, iCur = -1, cxExtent = 0;
#ifdef UNICODE
    CStrW strFirstCode, strLastCode, strCodeLine, strCurName;
#else
    CStr strFirstCode, strLastCode, strCodeLine, strCurName;
#endif
    CStrW str2CharAbrev;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (!pAttrMap->fIsReadOnly && !PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID),
                         FALSE);
            //
            // Remove the accelerator from the label since a disabled control
            // is not reachable.
            //
            CStr strLabel;
            strLabel.LoadString(g_hInstance, IDS_COUNTRY_LABEL_NO_ACCEL);
            SetDlgItemText(pPage->GetHWnd(), IDC_COUNTRY_LABEL, strLabel.GetBuffer(0));
        }
		// fall through...
    case fObjChanged:
      {
        DBG_OUT("CountryName: fInit");
        PTSTR ptzFullName = NULL;
        WORD wCode = 0;
        HDC hDC = NULL;
        unsigned long ulFirstCode, ulLastCode, i;

        strFirstCode.LoadString(g_hInstance, IDS_FIRST_COUNTRY_CODE);
        strLastCode.LoadString(g_hInstance, IDS_LAST_COUNTRY_CODE);

        if (strFirstCode.IsEmpty() || strLastCode.IsEmpty())
        {
            ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        ulFirstCode = _tcstoul(strFirstCode, NULL, 10);
        ulLastCode = _tcstoul(strLastCode, NULL, 10);

        if (!pAttrMap->fIsReadOnly)
        {
            hDC = GetDC(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
        }

        PWSTR pwzCurCode;

        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            pwzCurCode = pAttrInfo->pADsValues->CaseIgnoreString;
        }
        else
        {
            pwzCurCode = NULL;
        }

        for (i = ulFirstCode; i <= ulLastCode; i++)
        {
            strCodeLine.LoadString(g_hInstance, i);

            if (strCodeLine.IsEmpty())
            {
                ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if (!GetALineOfCodes(strCodeLine.GetBuffer(1), &ptzFullName, str2CharAbrev, &wCode))
            {
                ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if (!pAttrMap->fIsReadOnly)
            {
                // If not in read-only mode, then we use a combobox from which
                // the user selects the country.
                // Insert the full name into the combobox list.
                //
                SIZE s;
                if (hDC != NULL)
                {
                  GetTextExtentPoint32(hDC, ptzFullName, static_cast<int>(_tcslen(ptzFullName)), &s);

                  if (s.cx > cxExtent)
                  {
                      cxExtent = s.cx;
                  }

                  iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                                 CB_ADDSTRING, 0, (LPARAM)ptzFullName);

                  if (iSel < 0)
                  {
                      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
                  }

                  //
                  // Add the name codes as item data.
                  //
                  pCountryCode = new DsCountryCode;

                  CHECK_NULL_REPORT(pCountryCode, pPage->GetHWnd(), return E_OUTOFMEMORY);

                  wcscpy(pCountryCode->pwz2CharAbrev, str2CharAbrev);

                  pCountryCode->wCode = wCode;

                  if (SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                         CB_SETITEMDATA, iSel,
                                         (LPARAM)pCountryCode) == CB_ERR)
                  {
                      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
                  }
                }
            }
            //
            // See if the current country matches that saved on the DS object
            // (if one has been saved).
            //
            if (pwzCurCode)
            {
                if (_wcsicmp(pwzCurCode, str2CharAbrev) == 0)
                {
                    iCur = iSel;
                    strCurName = ptzFullName;
                }
            }

            if ((iCur == iSel) && pAttrMap->fIsReadOnly)
            {
                // Read-only mode means that we are using a static text
                // control. Insert the full name into the control.
                //
                SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptzFullName);
                break;
            }

            if (pAttrMap->fIsReadOnly)
            {
                iSel++;
            }
        }

        if (!pAttrMap->fIsReadOnly)
        {
          if (hDC != NULL)
          {
            ReleaseDC(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), hDC);
          }
          SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                             CB_SETHORIZONTALEXTENT, (WPARAM)cxExtent, 0);
          if (iCur >= 0)
          {
            iCur = (int) SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_FINDSTRINGEXACT, 0,
                                      (WPARAM)(LPCTSTR)strCurName);
            dspAssert(iCur != CB_ERR);
            SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                               CB_SETCURSEL, iCur, 0);
          }
        }
        else
        {
          if (iCur < 0)
          {
            // If iCur is still -1, then country code hasn't been set.
            //
            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, TEXT(""));
          }
        }
        break;
      }
    case fApply:
        DBG_OUT("CountryName: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                       CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_GETITEMDATA, iSel, 0);
            if (pCur == LB_ERR)
            {
                dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }

            pCountryCode = (PDsCountryCode)pCur;

            if (!AllocWStr(pCountryCode->pwz2CharAbrev, &pwsz))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
            }

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->CaseIgnoreString = pwsz;
        }
        break;

    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fOnDestroy:
        DBG_OUT("CountryName: fOnDestroy");
        iSel = 0;
        do
        {
            pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_GETITEMDATA, iSel, 0);
            if (pCur != CB_ERR)
            {
                // Delete the itemdata string.
                //
                delete (PDsCountryCode)pCur;

                iSel++;
            }
        } while (pCur != CB_ERR);
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TextCountry
//
//  Synopsis:   Handles the Country combo box to get/set the Text-Country
//              (LDAP display name: co) 
//
//  Notes:      This attr function MUST be called after CountryName. It
//              relies on CountryName populating the combobox
//
//-----------------------------------------------------------------------------
HRESULT
TextCountry(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    switch(DlgOp)
    {
    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        DBG_OUT("TextCountry: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        int iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                           CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {   
            LPTSTR ptz = new TCHAR[pAttrMap->nSizeLimit + 1];
            CHECK_NULL_REPORT(ptz, pPage->GetHWnd(), return E_OUTOFMEMORY);

            INT_PTR pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                              CB_GETLBTEXT, iSel, (LPARAM) (LPCSTR) ptz );
            if (pCur == LB_ERR)
            {
                delete ptz;
                DWORD dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }
            
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            if( pADsValue == NULL )
            {
              ReportError(E_OUTOFMEMORY,0, pPage->GetHWnd()); 
              delete ptz;
              return E_OUTOFMEMORY;
            }

            
            if (!TcharToUnicode(ptz, &pADsValue->CaseIgnoreString))
            {
              delete ptz;
              delete pADsValue;
              REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
              return E_OUTOFMEMORY;
            }

            delete ptz;
    
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            
        }
        break;
    }

    return S_OK;
}

// CountryName helpers:

//+----------------------------------------------------------------------------
//
//  Function:   GetALineOfCodes
//
//  Synopsis:   Parse a line of country codes.
//
//-----------------------------------------------------------------------------
BOOL GetALineOfCodes(PTSTR ptzLine, PTSTR * pptzFullName,
                     CStrW & str2CharAbrev, LPWORD pwCode)
{
    //
    // The line is parsed from end to beginning. That way we don't need to
    // dependend on the column widths being fixed.
    //
    // The last token is the numeric code. Read it.
    //
    RemoveTrailingWhitespace(ptzLine);

    PTSTR ptzCode = _tcsrchr(ptzLine, TEXT(' '));

    if (!ptzCode)
    {
        // try tab char.
        //
        ptzCode = _tcsrchr(ptzLine, TEXT('\t'));
    }

    if (!ptzCode || (ptzCode <= ptzLine) || (_tcslen(ptzCode) < 2))
    {
        return FALSE;
    }

    *ptzCode = TEXT('\0');

    ptzCode++;

    int iScanned = _stscanf(ptzCode, TEXT("%u"), pwCode);
    dspAssert(iScanned == 1);

    //
    // The next to last token is the 3 character code. Skip it.
    //
    RemoveTrailingWhitespace(ptzLine);

    size_t nLen = _tcslen(ptzLine);

    if (3 >= nLen)
    {
        return FALSE;
    }

    ptzLine[nLen - 3] = TEXT('\0');

    //
    // The next token (moving toward the front) is the 2 character code.
    //
    RemoveTrailingWhitespace(ptzLine);

    PTSTR ptz2CharAbrev = _tcsrchr(ptzLine, TEXT(' '));

    if (!ptz2CharAbrev)
    {
        // try tab char.
        //
        ptz2CharAbrev = _tcsrchr(ptzLine, TEXT('\t'));
    }

    if (!ptz2CharAbrev || (ptz2CharAbrev <= ptzLine))
    {
        return FALSE;
    }

    *ptz2CharAbrev = TEXT('\0');

    ptz2CharAbrev++;

    if (_tcslen(ptz2CharAbrev) != 2)
    {
        return FALSE;
    }

    str2CharAbrev = ptz2CharAbrev;

    //
    // The first token is the full country name.
    //
    RemoveTrailingWhitespace(ptzLine);

    if (!_tcslen(ptzLine))
    {
        return FALSE;
    }

    *pptzFullName = ptzLine;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTrailingWhitespace
//
//  Synopsis:   Trailing white space is replaced by NULLs.
//
//-----------------------------------------------------------------------------
void RemoveTrailingWhitespace(PTSTR ptz)
{
    size_t nLen = _tcslen(ptz);

    while (nLen)
    {
        if (!iswspace(ptz[nLen - 1]))
        {
            return;
        }
        ptz[nLen - 1] = L'\0';
        nLen--;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   ManagerEdit
//
//  Synopsis:   Handles the manager edit control.
//
//  Notes:      The page member m_pData stores the pAttrData value whose pVoid
//              element is set to the DN of the manager. The other manager
//              attr functions can then access the manager value and can also
//              read the fWritable element.
//
//-----------------------------------------------------------------------------
HRESULT
ManagerEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    PWSTR pwz = NULL;
    PWSTR canonical = NULL;
    HRESULT hr = S_OK;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (pAttrInfo && pAttrInfo->dwNumValues > 0)
        {
            if (!AllocWStr(pAttrInfo->pADsValues[0].DNString, &pwz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }
            hr = CrackName (pwz, &canonical, GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());
            if (FAILED(hr))
            {
                delete pwz;
                return S_FALSE;
            }
            PTSTR ptz, ptzName;
            if (!UnicodeToTchar(canonical, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                delete pwz;
                return E_OUTOFMEMORY;
            }
            LocalFreeStringW(&canonical);
            ptzName = _tcschr(ptz, TEXT('\n'));
            dspAssert(ptzName);
            ptzName++;
            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptzName);
            delete ptz;
        }
        pAttrData->pVoid = reinterpret_cast<LPARAM>(pwz);
        ((CDsTableDrivenPage *)pPage)->m_pData = reinterpret_cast<LPARAM>(pAttrData);
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        pwz = (PWSTR)reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData)->pVoid;

        if (pwz)
        {
            // make a copy cause CDsTableDrivenPage::OnApply deletes it.
            PWSTR pwzTmp;
            if (!AllocWStr(pwz, &pwzTmp))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
      
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->CaseIgnoreString = pwzTmp;
        }
        else
        {
            pAttrInfo->pADsValues = NULL;
            pAttrInfo->dwNumValues = 0;
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        break;

    case fOnDestroy:
        if (reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData)
        {
            PATTR_DATA pData = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
            PVOID pVoid = reinterpret_cast<PVOID>(pData->pVoid);
            DO_DEL(pVoid);
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   DirectReportsList
//
//  Synopsis:   Handles the User Organisation Direct Reports list.
//
//-----------------------------------------------------------------------------
HRESULT
DirectReportsList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA,
                  DLG_OP DlgOp)
{
  //
  // Multi-select will result in a return at this point
  //
  if (pPage->GetObjPathName() == NULL)
  {
    return S_OK;
  }

  switch (DlgOp)
  {
    case fInit:
      {
        HRESULT hr;
        Smart_PADS_ATTR_INFO spAttrs;
        DWORD cAttrs = 0;
        PWSTR rgpwzAttrNames[] = {pAttrMap->AttrInfo.pszAttrName};
        CComPtr <IDirectoryObject> spGcObj;

        hr = BindToGCcopyOfObj(pPage, pPage->GetObjPathName(), &spGcObj);

        if (SUCCEEDED(hr))
        {
          hr = spGcObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

          if (SUCCEEDED(hr))
          {
            //
            // If the bind to the GC was successful, use those results.
            // Otherwise, use the results of the local object read.
            //
            if (!cAttrs)
            {
              return S_OK;
            }
            pAttrInfo = spAttrs;
          }
        }

        if (!pAttrInfo)
        {
          return S_OK;
        }

        for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
        {
          PWSTR pwzDns;
          hr = CrackName(pAttrInfo->pADsValues[i].DNString, &pwzDns,
                         GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());

          CHECK_HRESULT(hr, return hr);

          PTSTR ptz, ptzName;
          if (!UnicodeToTchar(pwzDns, &ptz))
          {
            LocalFreeStringW(&pwzDns);
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
          }
          LocalFreeStringW(&pwzDns);
          ptzName = _tcschr(ptz, TEXT('\n'));
          dspAssert(ptzName);
          ptzName++;
          LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST, LB_ADDSTRING,
                                               0, (LPARAM)ptzName);
          if (lresult != LB_ERR)
          {
            PWSTR pwzDN = new WCHAR[wcslen(pAttrInfo->pADsValues[i].DNString) + 1];
            if (pwzDN != NULL)
            {
              wcscpy(pwzDN, pAttrInfo->pADsValues[i].DNString);
              SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                 LB_SETITEMDATA, lresult, (LPARAM)pwzDN);
            }
          }
          delete ptz;
        }
      }
      break;
    
    case fOnCommand:
      {
        if (lParam == LBN_DBLCLK)
        {
          //
          // Retrieve the current selection
          //
          PWSTR pwzDN = NULL;
          LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                               LB_GETCURSEL, 0, 0);

          if (lresult != LB_ERR)
          {
            //
            // Get the DN associated with the item
            //
            lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                         LB_GETITEMDATA, lresult, 0);
            if (lresult != LB_ERR)
            {
              pwzDN = (PWSTR)lresult;
              if (pwzDN != NULL)
              {
                //
                // Launch the secondary proppages
                //
                PostPropSheet(pwzDN, pPage);
              }
            }
          }
        }
      }
      break;
    
    case fOnDestroy:
      {
        //
        // Must free the memory associated with the list box
        //
        LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                             LB_GETCOUNT, 0, 0);
        if (lresult != LB_ERR)
        {
          for (LRESULT idx = lresult - 1 ; idx >= 0; idx--)
          {
            lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                         LB_GETITEMDATA, idx, 0);
            if (lresult != LB_ERR)
            {
              PWSTR pwzDN = (PWSTR)lresult;
              if (pwzDN != NULL)
              {
                delete[] pwzDN;
              }
            }
          }
        }
      }
      break;

    default:
      break;
  }

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\inc\dsadminp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsadminp.h
//
//--------------------------------------------------------------------------







//
// CoClass for the choose DC dialog object
//

// {8F2AC965-04A2-11d3-82BD-00C04F68928B}
DEFINE_GUID(CLSID_DsAdminChooseDCObj, 
0x8f2ac965, 0x4a2, 0x11d3, 0x82, 0xbd, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


//
// Interface to access the choose DC dialog object
//

// {A5F06B5F-04A2-11d3-82BD-00C04F68928B}
DEFINE_GUID(IID_IDsAdminChooseDC, 
0xa5f06b5f, 0x4a2, 0x11d3, 0x82, 0xbd, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);



#ifndef _DSADMINP_H
#define _DSADMINP_H



// ----------------------------------------------------------------------------
// 
// Interface: IDsAdminChooseDC
//  
// Implemented by the object CLSID_DsAdminChooseDCObj
//
// Used by: any client needing to invoke the DC selection UI
//

  
#undef  INTERFACE
#define INTERFACE   IDsAdminChooseDC

DECLARE_INTERFACE_(IDsAdminChooseDC, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAdminChooseDC methods ***
  STDMETHOD(InvokeDialog)(THIS_ /*IN*/  HWND hwndParent,
                                /*IN*/  LPCWSTR lpszTargetDomain,
                                /*IN*/  LPCWSTR lpszTargetDomainController,
                                /*IN*/  ULONG uFlags,
                                /*OUT*/ BSTR* bstrSelectedDC) PURE;
};











/////////////////////////////////////////////////////////////////////
// macros

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)



/////////////////////////////////////////////////////////////////////
// Helper global API's

HRESULT GetAttr(       IN IADs* pIADs, IN WCHAR* wzAttr, OUT PADS_ATTR_INFO* ppAttrs );
HRESULT GetStringAttr( IN IADs* pIADs, IN WCHAR* wzAttr, OUT BSTR* pbstr );
HRESULT GetObjectGUID( IN IADs* pIADs, OUT UUID* pUUID );
HRESULT GetObjectGUID( IN IADs* pIADs, OUT BSTR* pbstrObjectGUID );

HRESULT GetADSIServerName(OUT PWSTR* szServer, IN IUnknown* pUnk);


int cchLoadHrMsg( IN HRESULT hr, OUT PTSTR* pptzSysMsg, IN BOOL TryADsIErrors );
void StringErrorFromHr(HRESULT hr, OUT PWSTR* pszError, BOOL TryADsIErrors = TRUE);


/////////////////////////////////////////////////////////////////////
// FSMO Mainipulation API's

class CDSBasePathsInfo; // fwd decl.

enum FSMO_TYPE
{
  SCHEMA_FSMO,
  RID_POOL_FSMO,
  PDC_FSMO,
  INFRASTUCTURE_FSMO,
  DOMAIN_NAMING_FSMO,
};

HRESULT FindFsmoOwner(IN CDSBasePathsInfo* pCurrentPath,
                      IN FSMO_TYPE fsmoType,
                      OUT CDSBasePathsInfo* pFsmoOwnerPath,
                      OUT PWSTR* pszFsmoOwnerServerName);

HRESULT CheckpointFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo);
HRESULT GracefulFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo, IN FSMO_TYPE fsmoType);
HRESULT ForcedFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo,
                                IN FSMO_TYPE fsmoType);




/////////////////////////////////////////////////////////////////////
// CDSBasePathsInfo

class CDSBasePathsInfo
{
public:
  CDSBasePathsInfo();
  ~CDSBasePathsInfo();

  // initialization functions  
  HRESULT InitFromName(LPCWSTR lpszServerOrDomainName);
  HRESULT InitFromContainer(IADsContainer* pADsContainerObj);
  HRESULT InitFromInfo(CDSBasePathsInfo* pBasePathsInfo);

  // accessor functions
  IADs* GetRootDSE() { return m_spRootDSE;}

  LPCWSTR GetProvider()               { return L"LDAP://";}
  LPCWSTR GetProviderAndServerName()  { return m_szProviderAndServerName;}
  LPCWSTR GetServerName()             { return m_szServerName;}
  LPCWSTR GetDomainName()             { return m_szDomainName;}

  LPCWSTR GetSchemaNamingContext()      { return m_szSchemaNamingContext;}
  LPCWSTR GetConfigNamingContext()      { return m_szConfigNamingContext;}
  LPCWSTR GetDefaultRootNamingContext() {return m_szDefaultNamingContext;}
  LPCWSTR GetRootDomainNamingContext()  {return m_szRootDomainNamingContext;}

  UINT    GetDomainBehaviorVersion()  { return m_nDomainBehaviorVersion; }
  UINT    GetForestBehaviorVersion()  { return m_nForestBehaviorVersion; }


  // helper functions to compose LDAP paths out of naming contexts
  // NOTE: the caller needs to free the memory allocated for the returned
  //       string by using the operator delete[]
  //
  int ComposeADsIPath(OUT PWSTR* pszPath, IN LPCWSTR lpszNamingContext);

  int GetSchemaPath(OUT PWSTR* s);
  int GetConfigPath(OUT PWSTR* s);
  int GetDefaultRootPath(OUT PWSTR* s);
  int GetRootDomainPath(OUT PWSTR* s);
  int GetRootDSEPath(OUT PWSTR* s);
  int GetAbstractSchemaPath(OUT PWSTR* s);
  int GetPartitionsPath(OUT PWSTR* s);
  int GetSchemaObjectPath(IN LPCWSTR lpszObjClass, OUT PWSTR* s);
  int GetInfrastructureObjectPath(OUT PWSTR* s);

  // display specifiers cache API's
  HRESULT GetDisplaySpecifier(LPCWSTR lpszObjectClass, REFIID riid, void** ppv);
  HICON GetIcon(LPCWSTR lpszObjectClass, DWORD dwFlags, INT cxIcon, INT cyIcon);
  HRESULT GetFriendlyClassName(LPCWSTR lpszObjectClass, 
                               LPWSTR lpszBuffer, int cchBuffer);
  HRESULT GetFriendlyAttributeName(LPCWSTR lpszObjectClass, 
                                   LPCWSTR lpszAttributeName,
                                   LPWSTR lpszBuffer, int cchBuffer);
  BOOL IsClassContainer(LPCWSTR lpszObjectClass, LPCWSTR lpszADsPath, DWORD dwFlags);
  HRESULT GetClassCreationInfo(LPCWSTR lpszObjectClass, LPDSCLASSCREATIONINFO* ppdscci);

  bool IsInitialized() { return m_bIsInitialized; }

  UINT AddRef() { return ++m_nRefs; }
  UINT Release();

private:
  PWSTR m_szServerName;             // DNS server (DC) name (e.g. "mydc.mycomp.com.")
  PWSTR m_szDomainName;             // DNS domain name (e.g. "mydom.mycomp.com.")
  PWSTR m_szProviderAndServerName;  // LDAP://<server>/

  PWSTR m_szSchemaNamingContext;
  PWSTR m_szConfigNamingContext;
  PWSTR m_szDefaultNamingContext;
  PWSTR m_szRootDomainNamingContext;

  UINT  m_nDomainBehaviorVersion;
  UINT  m_nForestBehaviorVersion;

  UINT  m_nRefs;

  CComPtr<IADs>                     m_spRootDSE;  // cached connection
  CComPtr<IDsDisplaySpecifier>      m_spIDsDisplaySpecifier;  // pointer to Display Specifier Cache

  bool  m_bIsInitialized;

  HRESULT _InitHelper();
  void _Reset();
  void _BuildProviderAndServerName();
};

///////////////////////////////////////////////////////////////////////////////
// CDsDisplaySpecOptionsCFHolder
//
// Helper class to cache a DSDISPLAYSPECOPTIONS struct for the 
// corresponding clipboard format

class CDsDisplaySpecOptionsCFHolder
{
public:
  CDsDisplaySpecOptionsCFHolder()
  {
    m_pDsDisplaySpecOptions = NULL;
  }
  ~CDsDisplaySpecOptionsCFHolder()
  {
    if (m_pDsDisplaySpecOptions != NULL)
      GlobalFree(m_pDsDisplaySpecOptions);
  }
  HRESULT Init(CDSBasePathsInfo* pBasePathInfo);
  PDSDISPLAYSPECOPTIONS Get();
private:
  PDSDISPLAYSPECOPTIONS m_pDsDisplaySpecOptions;
};

//////////////////////////////////////////////////////////////////////////
// CToggleTextControlHelper

class CToggleTextControlHelper
{
public:
	CToggleTextControlHelper();
  ~CToggleTextControlHelper();
  BOOL Init(HWND hWnd);
	void SetToggleState(BOOL bFirst);

private:
	HWND m_hWnd;
  WCHAR* m_pTxt1;
  WCHAR* m_pTxt2;
};


#endif //_DSADMINP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\inc\propcfg.h ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       propcfg.cpp
//
//  Contents:   Data object clipboard format for property sheet configuration
//              information.
//
//  History:    30-May-97 EricB - Created
//-----------------------------------------------------------------------------

#ifndef __PROPCFG_H__
#define __PROPCFG_H__


// private message for secondary sheet creation sent to the notify object
#define WM_ADSPROP_SHEET_CREATE       (WM_USER + 1108) 
// private message for retrieving a pointer to an instance of the notify object
// associated with a particular HWND
#define WM_ADSPROP_NOTIFY_GET_NOTIFY_OBJ (WM_USER + 1111)

// struct used as WPARAM argument for the secondary sheet creation message
typedef struct _DSA_SEC_PAGE_INFO
{
    HWND    hwndParentSheet;
    DWORD   offsetTitle;                // offset to the sheet title
    DSOBJECTNAMES dsObjectNames;        // single selection DSOBJECTNAMES struct
} DSA_SEC_PAGE_INFO, * PDSA_SEC_PAGE_INFO;


///////////////////////////////////////////////////////////////////////////


// private messages to be sent to DSA 

// message to be posted to DSA hidden window to notify a sheet has closed
// the wParam of the message is a cookie provided in the PROPSHEETCFG struct/CF
#define WM_DSA_SHEET_CLOSE_NOTIFY     (WM_USER + 5) 


// message to be posted to DSA hidden window to create secondary sheet
// the wParam of the message is a PDSA_SEC_PAGE_INFO 
#define WM_DSA_SHEET_CREATE_NOTIFY    (WM_USER + 6) 


#define CFSTR_DS_PROPSHEETCONFIG L"DsPropSheetCfgClipFormat"

#define CFSTR_DS_PARENTHWND L"DsAdminParentHwndClipFormat"

#define CFSTR_DS_SCHEMA_PATH L"DsAdminSchemaPathClipFormat"

#define CFSTR_DS_MULTISELECTPROPPAGE L"DsAdminMultiSelectClipFormat"

#endif // __PROPCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\inc\secondaryproppages.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       secondaryProppages.h
//
//--------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
// CSecondaryPagesManager

template <class TCOOKIE> class CSecondaryPagesManager
{
public:
  ~CSecondaryPagesManager()
  {
    ASSERT(m_secondaryPagesCookies.IsEmpty());
  }

  HRESULT CreateSheet(HWND hWndParent, 
                      LPCONSOLE pIConsole, 
                      IUnknown* pUnkComponentData,
                      TCOOKIE* pCookie,
                      IDataObject* pDataObject,
                      LPCWSTR lpszTitle)
  {
    ASSERT(pIConsole != NULL);
    ASSERT(pDataObject != NULL);
    ASSERT(pUnkComponentData != NULL);

	  // get an interface to a sheet provider
	  CComPtr<IPropertySheetProvider> spSheetProvider;
	  HRESULT hr = pIConsole->QueryInterface(IID_IPropertySheetProvider,(void**)&spSheetProvider);
	  ASSERT(SUCCEEDED(hr));
	  ASSERT(spSheetProvider != NULL);

	  // get an interface to a sheet callback
	  CComPtr<IPropertySheetCallback> spSheetCallback;
	  hr = pIConsole->QueryInterface(IID_IPropertySheetCallback,(void**)&spSheetCallback);
	  ASSERT(SUCCEEDED(hr));
	  ASSERT(spSheetCallback != NULL);

	  ASSERT(pDataObject != NULL);

	  // get a sheet
    MMC_COOKIE cookie = reinterpret_cast<MMC_COOKIE>(pCookie);
	  hr = spSheetProvider->CreatePropertySheet(lpszTitle, TRUE, cookie, 
                                              pDataObject, 0x0 /*dwOptions*/);
	  ASSERT(SUCCEEDED(hr));

	  hr = spSheetProvider->AddPrimaryPages(pUnkComponentData,
											  FALSE /*bCreateHandle*/,
											  hWndParent,
											  FALSE /* bScopePane*/);

    hr = spSheetProvider->AddExtensionPages();

	  ASSERT(SUCCEEDED(hr));

	  hr = spSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWndParent), 0);
	  ASSERT(SUCCEEDED(hr));

    if (pCookie->IsSheetLocked())
    {
      // we created the sheet correctly,
      // add it to the list of cookies
      m_secondaryPagesCookies.AddTail(pCookie);
    }

	  return hr;
  }

  BOOL IsCookiePresent(TCOOKIE* pCookie)
  {
    return (m_secondaryPagesCookies.Find(pCookie) != NULL);
  }

  template <class CMP> TCOOKIE* FindCookie(CMP compare)
  {
    for (POSITION pos = m_secondaryPagesCookies.GetHeadPosition(); pos != NULL; )
    {
      TCOOKIE* pCookie = m_secondaryPagesCookies.GetNext(pos);
      if (compare(pCookie))
      {
        // found
        return pCookie;
      }
    }
    return NULL;
  }
  void OnSheetClose(TCOOKIE* pCookie)
  {
    // remove from the list of cookies and delete memory
    POSITION pos = m_secondaryPagesCookies.Find(pCookie);
    if (pos != NULL) 
    {
      ASSERT(!pCookie->IsSheetLocked());
      m_secondaryPagesCookies.RemoveAt(pos);
      delete pCookie;
    }
  }

private:
  CList <TCOOKIE *, TCOOKIE*> m_secondaryPagesCookies;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\inc\pcrack.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pcrack.h
//
//  requires iads.h (IADsPathname) and atlbase.h (CComPtr)
//
//--------------------------------------------------------------------------

// pcrack.h : include file for CPathCracker

#ifndef __PCRACK_H__
#define __PCRACK_H__

class CPathCracker
{
public:
  CPathCracker()
  {
    m_hrCreate = Init();
  }
private:

  HRESULT Init()
  {
    HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(m_spIADsPathname));
    return hr;
  }
  
public:
  
  // IADsPathname methods
  virtual /* [id] */ HRESULT STDMETHODCALLTYPE Set( 
      /* [in] */ const BSTR bstrADsPath,
      /* [in] */ long lnSetType) 
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->Set(bstrADsPath, lnSetType); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDisplayType( 
      /* [in] */ long lnDisplayType) 
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->SetDisplayType(lnDisplayType); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE Retrieve( 
      /* [in] */ long lnFormatType,
      /* [retval][out] */ BSTR __RPC_FAR *pbstrADsPath) 
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->Retrieve(lnFormatType, pbstrADsPath); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNumElements( 
      /* [retval][out] */ long __RPC_FAR *plnNumPathElements)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetNumElements(plnNumPathElements); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetElement( 
      /* [in] */ long lnElementIndex,
      /* [retval][out] */ BSTR __RPC_FAR *pbstrElement)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetElement(lnElementIndex, pbstrElement); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddLeafElement( 
      /* [in] */ BSTR bstrLeafElement)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->AddLeafElement(bstrLeafElement); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE RemoveLeafElement( void)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->RemoveLeafElement(); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopyPath( 
      /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppAdsPath)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->CopyPath(ppAdsPath); }

  virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEscapedElement( 
      /* [in] */ long lnReserved,
      /* [in] */ const BSTR bstrInStr,
      /* [retval][out] */ BSTR __RPC_FAR *pbstrOutStr)
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetEscapedElement(lnReserved, bstrInStr, pbstrOutStr); }

  virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EscapedMode( 
      /* [retval][out] */ long __RPC_FAR *retval)  
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->get_EscapedMode(retval); }

  virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EscapedMode( 
      /* [in] */ long lnEscapedMode) 
    { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->put_EscapedMode(lnEscapedMode); }


private:
  CComPtr<IADsPathname> m_spIADsPathname;
  HRESULT m_hrCreate;
};

#endif _PCRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\src\basepathsinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       basePathsInfo.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"


/////////////////////////////////////////////////////////////////////
// CDSBasePathsInfo

CDSBasePathsInfo::CDSBasePathsInfo() : 
  m_nDomainBehaviorVersion(0), 
  m_nForestBehaviorVersion(0),
  m_nRefs(0),
  m_szServerName(0),
  m_szDomainName(0),
  m_szProviderAndServerName(0),
  m_szSchemaNamingContext(0),
  m_szConfigNamingContext(0),
  m_szDefaultNamingContext(0),
  m_szRootDomainNamingContext(0),
  m_bIsInitialized(false)
{
}

CDSBasePathsInfo::~CDSBasePathsInfo()
{
  _Reset();
}

UINT CDSBasePathsInfo::Release()
{
   if (--m_nRefs == 0)
   {
      delete this;
      return 0;
   }

   return m_nRefs;
}

HRESULT CDSBasePathsInfo::InitFromContainer(IADsContainer* pADsContainerObj)
{
  _Reset();
  PWSTR szServer = 0;
  HRESULT hr = GetADSIServerName(OUT &szServer, IN pADsContainerObj);
  if (SUCCEEDED(hr) && szServer)
  {
    hr = InitFromName(szServer);
  }

  if (szServer)
  {
     delete[] szServer;
     szServer = 0;
  }
  m_bIsInitialized = true;
  return hr;
}

HRESULT CDSBasePathsInfo::InitFromInfo(CDSBasePathsInfo* pBasePathsInfo)
{
  if (pBasePathsInfo->m_szServerName)
  {
     if (m_szServerName)
     {
        delete[] m_szServerName;
     }

     m_szServerName = new WCHAR[wcslen(pBasePathsInfo->m_szServerName) + 1];
     ASSERT(m_szServerName);
     if (m_szServerName)
     {
       wcsncpy(m_szServerName, pBasePathsInfo->m_szServerName, wcslen(pBasePathsInfo->m_szServerName) + 1);
     }
  }

  if (pBasePathsInfo->m_szDomainName)
  {
     if (m_szDomainName)
     {
       delete[] m_szDomainName;
     }
     m_szDomainName = new WCHAR[wcslen(pBasePathsInfo->m_szDomainName) + 1];
     ASSERT(m_szDomainName);
     if (m_szDomainName)
     {
       wcsncpy(m_szDomainName ,pBasePathsInfo->m_szDomainName, wcslen(pBasePathsInfo->m_szDomainName) + 1);
     }
  }


  if (pBasePathsInfo->m_szProviderAndServerName)
  {
     if (m_szProviderAndServerName)
     {
       delete[] m_szProviderAndServerName;
     }
     m_szProviderAndServerName = new WCHAR[wcslen(pBasePathsInfo->m_szProviderAndServerName) + 1];
     ASSERT(m_szProviderAndServerName);
     if (m_szProviderAndServerName)
     {
       wcsncpy(m_szProviderAndServerName ,pBasePathsInfo->m_szProviderAndServerName,
               wcslen(pBasePathsInfo->m_szProviderAndServerName) + 1);
     }
  }

  if (pBasePathsInfo->m_szSchemaNamingContext)
  {
     if (m_szSchemaNamingContext)
     {
       delete[] m_szSchemaNamingContext;
     }
     m_szSchemaNamingContext = new WCHAR[wcslen(pBasePathsInfo->m_szSchemaNamingContext) + 1];
     ASSERT(m_szSchemaNamingContext);
     if (m_szSchemaNamingContext)
     {
       wcsncpy(m_szSchemaNamingContext, pBasePathsInfo->m_szSchemaNamingContext,
               wcslen(pBasePathsInfo->m_szSchemaNamingContext) + 1);
     }
  }

  if (pBasePathsInfo->m_szConfigNamingContext)
  {
     if (m_szConfigNamingContext)
     {
       delete[] m_szConfigNamingContext;
     }
     m_szConfigNamingContext = new WCHAR[wcslen(pBasePathsInfo->m_szConfigNamingContext) + 1];
     ASSERT(m_szConfigNamingContext);
     if (m_szConfigNamingContext)
     {
       wcsncpy(m_szConfigNamingContext, pBasePathsInfo->m_szConfigNamingContext,
               wcslen(pBasePathsInfo->m_szConfigNamingContext) + 1);
     }
  }

  if (pBasePathsInfo->m_szDefaultNamingContext)
  {
     if (m_szDefaultNamingContext)
     {
       delete[] m_szDefaultNamingContext;
     }
     m_szDefaultNamingContext = new WCHAR[wcslen(pBasePathsInfo->m_szDefaultNamingContext) + 1];
     ASSERT(m_szDefaultNamingContext);
     if (m_szDefaultNamingContext)
     {
       wcsncpy(m_szDefaultNamingContext, pBasePathsInfo->m_szDefaultNamingContext,
               wcslen(pBasePathsInfo->m_szDefaultNamingContext) + 1);
     }
  }


  if (pBasePathsInfo->m_szRootDomainNamingContext)
  {
    if (m_szRootDomainNamingContext)
    {
      delete[] m_szRootDomainNamingContext;
    }
    m_szRootDomainNamingContext = new WCHAR[wcslen(pBasePathsInfo->m_szRootDomainNamingContext) + 1];
    ASSERT(m_szRootDomainNamingContext);
    if (m_szRootDomainNamingContext)
    {
      wcsncpy(m_szRootDomainNamingContext, pBasePathsInfo->m_szRootDomainNamingContext,
              wcslen(pBasePathsInfo->m_szRootDomainNamingContext) + 1);
    }
  }

  m_spRootDSE = pBasePathsInfo->m_spRootDSE;
  m_spIDsDisplaySpecifier = pBasePathsInfo->m_spIDsDisplaySpecifier;

  _BuildProviderAndServerName();
  m_bIsInitialized = true;
  return S_OK;
}

int CDSBasePathsInfo::ComposeADsIPath(OUT PWSTR* pszPath, IN LPCWSTR lpszNamingContext)
{
  if (!pszPath || !IsInitialized())
  {
     return 0;
  }

  *pszPath = 0;

  PCWSTR pszServer = GetProviderAndServerName();

  if (!lpszNamingContext ||
      !pszServer)
  {
     return 0;
  }

  size_t length = wcslen(pszServer);
  length += wcslen(lpszNamingContext);

  int ret = 0;

  if (length)
  {
    *pszPath = new WCHAR[length + 1];
    ASSERT(*pszPath);

    if (*pszPath)
    {
      wcsncpy(*pszPath, pszServer, length + 1);
      wcsncat(*pszPath, lpszNamingContext, wcslen(lpszNamingContext));

      ret = static_cast<UINT>(wcslen(*pszPath) + 1);
    }
  }
  return ret;
}


HRESULT CDSBasePathsInfo::InitFromName(LPCWSTR lpszServerOrDomainName)
{
  TRACE(L"CDSBasePathsInfo::InitFromName(%s)\n", lpszServerOrDomainName);
  _Reset();

  // try to bind with the info we got
  PWSTR szProviderAndServerOrDomainName = 0;
  if ( (lpszServerOrDomainName == NULL) || (lpszServerOrDomainName[0] == NULL) )
  {
    szProviderAndServerOrDomainName = new WCHAR[wcslen(GetProvider()) + 1];
    if (szProviderAndServerOrDomainName)
    {
      wcsncpy(szProviderAndServerOrDomainName, GetProvider(), wcslen(GetProvider()) + 1);
    }
  }
  else
  {
    //
    // Add one more for the \0 and another for the /
    //
    size_t newStringLength = wcslen(GetProvider()) + wcslen(lpszServerOrDomainName) + 2;
    szProviderAndServerOrDomainName = new WCHAR[newStringLength];
    if (szProviderAndServerOrDomainName)
    {
      wcsncpy(szProviderAndServerOrDomainName, GetProvider(), newStringLength);
      wcsncat(szProviderAndServerOrDomainName, lpszServerOrDomainName, wcslen(lpszServerOrDomainName) + 1);
      wcsncat(szProviderAndServerOrDomainName, L"/", 2);
    }
  }

  if (!szProviderAndServerOrDomainName)
  {
     return E_OUTOFMEMORY;
  }

  HRESULT hr = S_OK;
  VARIANT Schema, Config, Root, Default;

  ::VariantInit(&Schema);
  ::VariantInit(&Config);
  ::VariantInit(&Default);
  ::VariantInit(&Root);

  // get the RootDSE 
  TRACE(L"// get the RootDSE\n");
  PCWSTR pszRootDSE = L"RootDSE";

  size_t newStringLength = wcslen(szProviderAndServerOrDomainName) + wcslen(pszRootDSE) + 1;
  PWSTR szRootDSEPath = new WCHAR[newStringLength];
  if (!szRootDSEPath)
  {
    delete[] szProviderAndServerOrDomainName;
    szProviderAndServerOrDomainName = 0;
    
    hr = E_OUTOFMEMORY;
    goto error;
  }

  ZeroMemory(szRootDSEPath, newStringLength);
  wcsncpy(szRootDSEPath, szProviderAndServerOrDomainName, newStringLength);
  wcsncat(szRootDSEPath, pszRootDSE, wcslen(pszRootDSE) + 1);

  hr = ::ADsOpenObject ((LPWSTR)(LPCWSTR)szRootDSEPath, NULL, NULL,
                      ADS_SECURE_AUTHENTICATION,
                      IID_IADs, (void **)&m_spRootDSE);
  if (FAILED(hr))
  {
    TRACE(L"Failed to bind to RootDSE: AdsOpenObject(%s, ...) returned hr = 0x%x\n", 
            (LPCWSTR)szRootDSEPath, hr);
    goto error;
  }

  // get the schema naming context
  TRACE(L"get the schema naming context\n");
  hr = m_spRootDSE->Get(L"schemaNamingContext", &Schema);
  if (FAILED(hr))
  {
    TRACE(L"Failed m_spRootDSE->Get(schemaNamingContext, &Schema), returned hr = 0x%x\n", hr);
    goto error;
  }


  m_szSchemaNamingContext = new WCHAR[wcslen(Schema.bstrVal) + 1];
  ASSERT(m_szSchemaNamingContext);
  if (m_szSchemaNamingContext)
  {
     wcsncpy(m_szSchemaNamingContext, Schema.bstrVal, wcslen(Schema.bstrVal) + 1);
  }
  else
  {
     hr = E_OUTOFMEMORY;
     goto error;
  }

  // get the configuration naming context
  TRACE(L"// get the configuration naming context\n");
  hr = m_spRootDSE->Get(L"configurationNamingContext",&Config);
  if (FAILED(hr))
  {
    TRACE(L"Failed m_spRootDSE->Get(configurationNamingContext,&Config), returned hr = 0x%x\n", hr);
    goto error;
  }
  m_szConfigNamingContext = new WCHAR[wcslen(Config.bstrVal) + 1];
  ASSERT(m_szConfigNamingContext);
  if (m_szConfigNamingContext)
  {
     wcsncpy(m_szConfigNamingContext, Config.bstrVal, wcslen(Config.bstrVal) + 1);
  }
  else
  {
     hr = E_OUTOFMEMORY;
     goto error;
  }

  // get the default naming context
  TRACE(L"// get the default naming context\n");
  hr = m_spRootDSE->Get (L"defaultNamingContext", &Default);
  if (FAILED(hr))
  {
    TRACE(L"Failed m_spRootDSE->Get (defaultNamingContext, &Default), returned hr = 0x%x\n", hr);
    goto error;
  }
  m_szDefaultNamingContext = new WCHAR[wcslen(Default.bstrVal) + 1];
  ASSERT(m_szDefaultNamingContext);
  if (m_szDefaultNamingContext)
  {
     wcsncpy(m_szDefaultNamingContext, Default.bstrVal, wcslen(Default.bstrVal) + 1);
  }
  else
  {
     hr = E_OUTOFMEMORY;
     goto error;
  }
  TRACE(L"//defaultNamingContext = %s\n", m_szDefaultNamingContext);

  // get the enterprise root domain name
  TRACE(L"// get the root domain naming context\n");
  hr = m_spRootDSE->Get (L"rootDomainNamingContext", &Root);
  if (FAILED(hr))
  {
    TRACE(L"Failed m_spRootDSE->Get (rootDomainNamingContext, &Root), returned hr = 0x%x\n", hr);
    goto error;
  }
  m_szRootDomainNamingContext = new WCHAR[wcslen(Root.bstrVal) + 1];
  ASSERT(m_szRootDomainNamingContext);
  if (m_szRootDomainNamingContext)
  {
     wcsncpy(m_szRootDomainNamingContext, Root.bstrVal, wcslen(Root.bstrVal) + 1);
  }
  TRACE(L"//rootDomainNamingContext = %s\n", m_szRootDomainNamingContext);

  do
  {
    //
    // retrieve the Domain Version from the domainDNS node
    //
    size_t newStringLength = wcslen(szProviderAndServerOrDomainName) +
                             wcslen(GetDefaultRootNamingContext()) + 1;

    PWSTR szDomainPath = new WCHAR[newStringLength];
    if (!szDomainPath)
    {
      hr = E_OUTOFMEMORY;
      break;
    }

    ZeroMemory(szDomainPath, newStringLength);
    wcsncpy(szDomainPath, szProviderAndServerOrDomainName, newStringLength);
    wcsncat(szDomainPath, GetDefaultRootNamingContext(), wcslen(GetDefaultRootNamingContext()) + 1);

    CComPtr<IADs> spDomain;
    hr = ::ADsOpenObject(szDomainPath, NULL, NULL,
                         ADS_SECURE_AUTHENTICATION,
                         IID_IADs, (PVOID*)&spDomain);

    delete[] szDomainPath;
    szDomainPath = 0;

    if (FAILED(hr))
    {
      m_nDomainBehaviorVersion = 0;
      break;
    }

    VARIANT varVer;
    ::VariantInit(&varVer);

    hr = spDomain->GetInfo();

    CComBSTR bstrVer = L"msDS-Behavior-Version";
    hr = spDomain->Get(bstrVer, &varVer);
    if (FAILED(hr))
    {
      m_nDomainBehaviorVersion = 0;
      break;
    }

    ASSERT(varVer.vt == VT_I4);
    m_nDomainBehaviorVersion = static_cast<UINT>(varVer.lVal);

    ::VariantClear(&varVer);
  } while (FALSE);

  do
  {
    //
    // retrieve the Forest Version from the partitions node
    //
    size_t newStringLength = wcslen(szProviderAndServerOrDomainName) +
                             wcslen(GetConfigNamingContext()) + 1;

    PWSTR strPath = new WCHAR[newStringLength];
    if (!strPath)
    {
      hr = E_OUTOFMEMORY;
      break;
    }

    ZeroMemory(strPath, newStringLength);
    wcsncpy(strPath, szProviderAndServerOrDomainName, newStringLength);
    wcsncat(strPath, GetConfigNamingContext(), wcslen(GetConfigNamingContext()) + 1);

    CComPtr<IADsPathname> spADsPath;

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&spADsPath);
    if (FAILED(hr))
    {
       break;
    }

    hr = spADsPath->Set(strPath, ADS_SETTYPE_FULL);

    delete[] strPath;
    strPath = 0;

    if (FAILED(hr))
    {
       break;
    }

    hr = spADsPath->SetDisplayType(ADS_DISPLAY_FULL);
    if (FAILED(hr))
    {
       break;
    }

    hr = spADsPath->AddLeafElement(L"CN=Partitions,");
    if (FAILED(hr))
    {
       break;
    }

    CComBSTR bstrPartitions;

    hr = spADsPath->Retrieve(ADS_FORMAT_X500, &bstrPartitions);
    if (FAILED(hr))
    {
       break;
    }

    CComPtr<IADs> spPartitions;

    hr = ADsOpenObject((PWSTR)(PCWSTR)bstrPartitions, NULL, NULL, 0, IID_IADs, (PVOID *)&spPartitions);
    if (FAILED(hr))
    {
       break;
    }

    VARIANT var;
    ::VariantInit(&var);

    hr = spPartitions->Get(L"msDS-Behavior-Version", &var);

    if (E_ADS_PROPERTY_NOT_FOUND == hr)
    {
       break;
    }
    else
    {
       ASSERT(var.vt == VT_I4);
       m_nForestBehaviorVersion = static_cast<UINT>(var.iVal);
    }

    ::VariantClear(&var);
  } while (FALSE);

  {
    // retrieve the DNS DC name we are bound to
    TRACE(L"// retrieve the DNS DC name we are bound to\n");
    size_t newStringLength = wcslen(szProviderAndServerOrDomainName) +
                             wcslen(GetConfigNamingContext()) + 1;

    PWSTR szConfigPath = new WCHAR[newStringLength];
    if (!szConfigPath)
    {
      hr = E_OUTOFMEMORY;
      goto error;
    }

    ZeroMemory(szConfigPath, newStringLength);
    wcsncpy(szConfigPath, szProviderAndServerOrDomainName, newStringLength);
    wcsncat(szConfigPath, GetConfigNamingContext(), wcslen(GetConfigNamingContext()) + 1);

   
    CComPtr<IADs> spConfig;
    hr = ::ADsOpenObject (szConfigPath, NULL, NULL,
                        ADS_SECURE_AUTHENTICATION,
                        IID_IADs, (void **)&spConfig);
    TRACE(L"ADsOpenObject(%s, ...) returned hr = 0x%x\n", (LPCWSTR)szConfigPath, hr);
    
    delete[] szConfigPath;
    szConfigPath = 0;

    if (FAILED(hr))
    {
      goto error;
    }

    PWSTR szServerName = 0;
    hr = GetADSIServerName(&szServerName, spConfig);
    TRACE(L"GetADSIServerName(%s) returned hr = 0x%x\n", szServerName, hr);

    if (FAILED(hr))
    {
      goto error;
    }

    if (!szServerName)
    {
       hr = E_OUTOFMEMORY;
       goto error;
    }

    // The member now owns the memory
    m_szServerName = szServerName;

    // retrieve the DNS domain name
    TRACE(L"// retrieve the DNS domain name\n");

    PCWSTR pszLDAP = L"LDAP://";
    size_t newLDAPStringLength = wcslen(pszLDAP) +
                                 wcslen(m_szServerName) +
                                 1;

    PWSTR sz = new WCHAR[newLDAPStringLength];
    if (sz)
    {
      ZeroMemory(sz, newLDAPStringLength);
      wcsncpy(sz, pszLDAP, newLDAPStringLength);
      wcsncat(sz, m_szServerName, wcslen(m_szServerName) + 1);

    }
    else
    {
       hr = E_OUTOFMEMORY;
       goto error;
    }

    CComPtr<IADs> spX;
    hr = ::ADsOpenObject(sz, NULL, NULL,
                        ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
                        IID_IADs, (void **)&spX);

    TRACE(L"ADsOpenObject(%s) DNS domain name, returned hr = 0x%x\n", (LPCWSTR)sz, hr);

    if (FAILED(hr))
    {
      goto error;
    }

    CComBSTR sbstrCanonicalName;
    hr = GetStringAttr( spX, L"canonicalName", &sbstrCanonicalName);
    if (FAILED(hr))
    {
      TRACE(L"Failed GetStringAttr( spX, canonicalName, &sbstrCanonicalName)");
      goto error;
    }
    UINT nLen = ::SysStringLen(sbstrCanonicalName);
    ASSERT(nLen > 1);
    sbstrCanonicalName[nLen-1] = NULL; // remove the "/" at the end

    ASSERT(!m_szDomainName);
    m_szDomainName = new WCHAR[wcslen(sbstrCanonicalName) + 1];
    ASSERT(m_szDomainName);
    if (m_szDomainName)
    {
       wcsncpy(m_szDomainName, sbstrCanonicalName, wcslen(sbstrCanonicalName) + 1);
    }
    else
    {
       hr = E_OUTOFMEMORY;
       goto error;
    }
  }

  // load and set the display specifier cache
  TRACE(L"// load and set the display specifier cache\n");
  if (m_spIDsDisplaySpecifier == NULL)
  {
    hr = ::CoCreateInstance(CLSID_DsDisplaySpecifier,
                            NULL,
						                CLSCTX_INPROC_SERVER,
                            IID_IDsDisplaySpecifier,
                            (void**)&m_spIDsDisplaySpecifier);
    if (FAILED(hr))
    {
      TRACE(_T("Trying to get the display specifier cache failed: %lx.\n"), hr);
      goto error;
    }
  }

  hr = m_spIDsDisplaySpecifier->SetServer(GetServerName(), NULL, NULL, 0x0);
  if (FAILED(hr))
  {
    TRACE(_T("m_spIDsDisplaySpecifier->SetServer(%s) failed, returned hr = 0x%x\n"), GetServerName(), hr);
    goto error;
  }

  ::VariantClear(&Schema);
  ::VariantClear(&Config);
  ::VariantClear(&Default);
  ::VariantClear(&Root);

  TRACE(L"CDSBasePathsInfo::InitFromName() returning on success\n");
  ASSERT(SUCCEEDED(hr)); // if we got here, all is fine
  _BuildProviderAndServerName();
  m_bIsInitialized = true;
  return hr; 

error:

  if (szProviderAndServerOrDomainName)
  {
    delete[] szProviderAndServerOrDomainName;
    szProviderAndServerOrDomainName = 0;
  }

  if (szRootDSEPath)
  {
    delete[] szRootDSEPath;
    szRootDSEPath = 0;
  }

  ::VariantClear(&Schema);
  ::VariantClear(&Config);
  ::VariantClear(&Default);
  ::VariantClear(&Root);

  // failed, we need to reset the object state
  _Reset();
  TRACE(L"CDSBasePathsInfo::InitFromName returning on failure\n");
  return hr;
}

void CDSBasePathsInfo::_Reset()
{

  if (m_szServerName)
  {
    delete[] m_szServerName;
    m_szServerName = 0;
  }

  if (m_szDomainName)
  {
    delete[] m_szDomainName;
    m_szDomainName = 0;
  }

  if (m_szProviderAndServerName)
  {
    delete[] m_szProviderAndServerName;
    m_szProviderAndServerName = 0;
  }

  if (m_szSchemaNamingContext)
  {
    delete[] m_szSchemaNamingContext;
    m_szSchemaNamingContext = 0;
  }

  if (m_szConfigNamingContext)
  {
    delete[] m_szConfigNamingContext;
    m_szConfigNamingContext = 0;
  }

  if (m_szDefaultNamingContext)
  {
    delete[] m_szDefaultNamingContext;
    m_szDefaultNamingContext = 0;
  }

  if (m_szRootDomainNamingContext)
  {
    delete[] m_szRootDomainNamingContext;
    m_szRootDomainNamingContext = 0;
  }

  m_spRootDSE = NULL;
}

void CDSBasePathsInfo::_BuildProviderAndServerName()
{
  if (m_szProviderAndServerName)
  {
    delete[] m_szProviderAndServerName;
    m_szProviderAndServerName = 0;
  }

  if (m_szServerName && wcslen(m_szServerName) > 0)
  {
    size_t newStringLength = wcslen(GetProvider()) + wcslen(m_szServerName) + 2;
    m_szProviderAndServerName = new WCHAR[newStringLength];
    ASSERT(m_szProviderAndServerName);
    if (m_szProviderAndServerName)
    {
      wcsncpy(m_szProviderAndServerName, GetProvider(), newStringLength);
      wcsncat(m_szProviderAndServerName, m_szServerName, wcslen(m_szServerName) + 1);
      wcsncat(m_szProviderAndServerName, L"/", 2);
    }
  }
  else
  {
    PCWSTR pszProvider = GetProvider();
    if (pszProvider)
    {
      m_szProviderAndServerName = new WCHAR[wcslen(pszProvider) + 1];
      ASSERT(m_szProviderAndServerName);
      if (m_szProviderAndServerName)
      {
        wcsncpy(m_szProviderAndServerName, pszProvider, wcslen(pszProvider) + 1);
      }
    }
  }
}
int CDSBasePathsInfo::GetSchemaPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, GetSchemaNamingContext());
}

int CDSBasePathsInfo::GetConfigPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, GetConfigNamingContext());
}

int CDSBasePathsInfo::GetDefaultRootPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, GetDefaultRootNamingContext());
}

int CDSBasePathsInfo::GetRootDomainPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, GetRootDomainNamingContext());
}

int CDSBasePathsInfo::GetRootDSEPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, L"RootDSE");
}

int CDSBasePathsInfo::GetAbstractSchemaPath(OUT PWSTR* s)
{
  return ComposeADsIPath(s, L"Schema");
}

int CDSBasePathsInfo::GetPartitionsPath(OUT PWSTR* s)
{
  int result = 0;

  if (!s || !IsInitialized())
  {
     ASSERT(IsInitialized());
     ASSERT(s);
     return result;
  }

  *s = 0;
  if (!GetConfigNamingContext())
  {
     return result;
  }

  PCWSTR pszPartitionsBase = L"CN=Partitions,";
  size_t newStringSize = wcslen(pszPartitionsBase) + wcslen(GetConfigNamingContext()) + 1;
  PWSTR pszPartitionsPath = new WCHAR[newStringSize];
  if (pszPartitionsPath)
  {
    ZeroMemory(pszPartitionsPath, newStringSize);
    wcsncpy(pszPartitionsPath, pszPartitionsBase, newStringSize);
    wcsncat(pszPartitionsPath, GetConfigNamingContext(), wcslen(GetConfigNamingContext()) + 1);
    
    result = ComposeADsIPath(s, pszPartitionsPath);

    delete[] pszPartitionsPath;
    pszPartitionsPath = 0;
  }

  return result;
}

int CDSBasePathsInfo::GetSchemaObjectPath(IN LPCWSTR lpszObjClass, OUT PWSTR* s)
{
  if (!s || !IsInitialized())
  {
     ASSERT(IsInitialized());
     ASSERT(s);
     return 0;
  }

  if (!GetProviderAndServerName() ||
      !GetSchemaNamingContext())
  {
     return 0;
  }

  size_t newStringLength = wcslen(GetProviderAndServerName()) +
                           wcslen(lpszObjClass) +
                           wcslen(GetSchemaNamingContext()) +
                           5; // for CN= and extra comma

  int result = 0;
  *s = new WCHAR[newStringLength];

  if (*s)
  {
    ZeroMemory(*s, newStringLength);
    wcsncpy(*s, GetProviderAndServerName(), newStringLength);
    wcsncat(*s, L"CN=", 4);
    wcsncat(*s, lpszObjClass, wcslen(lpszObjClass) + 1);
    wcsncat(*s, L",", 2);
    wcsncat(*s, GetSchemaNamingContext(), wcslen(GetSchemaNamingContext()) + 1);

    result = static_cast<int>(wcslen(*s));
  }
  return result;
}

//----------------------------------------------------
// BUGBUG BUG BUG BUGBUG BUG
// this should actually look in the domain object for
// the list of known, but rename-able objects in the domain
//---------------------------------------------------------
int CDSBasePathsInfo::GetInfrastructureObjectPath(OUT PWSTR* s)
{
  if (!s || !IsInitialized())
  {
    ASSERT(IsInitialized());
    ASSERT(s);
    return 0;
  }

  *s = 0;

  if (!GetProviderAndServerName() ||
      !GetDefaultRootNamingContext())
  {
     return 0;
  }

  PCWSTR pszInfraBase = L"CN=Infrastructure,";
  size_t newStringLength = wcslen(GetProviderAndServerName()) +
                           wcslen(GetDefaultRootNamingContext()) +
                           wcslen(pszInfraBase) +
                           1; // for \0

  int result = 0;
  *s = new WCHAR[newStringLength];

  if (*s)
  {
    ZeroMemory(*s, newStringLength);

    wcsncpy(*s, GetProviderAndServerName(), newStringLength);
    wcsncat(*s, pszInfraBase, wcslen(pszInfraBase) + 1);
    wcsncat(*s, GetDefaultRootNamingContext(), wcslen(GetDefaultRootNamingContext()) + 1);
    
    result = static_cast<int>(wcslen(*s));
  }

  return result;
}

// display specifiers cache API's
HRESULT CDSBasePathsInfo::GetDisplaySpecifier(LPCWSTR lpszObjectClass, REFIID riid, void** ppv)
{
  if (!m_spIDsDisplaySpecifier)
  {
    ASSERT(m_spIDsDisplaySpecifier != NULL);
    return E_FAIL;
  }
  return m_spIDsDisplaySpecifier->GetDisplaySpecifier(lpszObjectClass, riid, ppv);
}

HICON CDSBasePathsInfo::GetIcon(LPCWSTR lpszObjectClass, DWORD dwFlags, INT cxIcon, INT cyIcon)
{
 if (!m_spIDsDisplaySpecifier)
 {
   ASSERT(m_spIDsDisplaySpecifier != NULL);
   return NULL;
 }
 return m_spIDsDisplaySpecifier->GetIcon(lpszObjectClass, dwFlags, cxIcon, cyIcon);
}

HRESULT CDSBasePathsInfo::GetFriendlyClassName(LPCWSTR lpszObjectClass, 
                                               LPWSTR lpszBuffer, int cchBuffer)
{
 if (!m_spIDsDisplaySpecifier)
 {
   ASSERT(m_spIDsDisplaySpecifier != NULL);
   return E_FAIL;
 }
 return m_spIDsDisplaySpecifier->GetFriendlyClassName(lpszObjectClass, 
                            lpszBuffer, cchBuffer);
}

HRESULT CDSBasePathsInfo::GetFriendlyAttributeName(LPCWSTR lpszObjectClass, 
                                                   LPCWSTR lpszAttributeName,
                                                   LPWSTR lpszBuffer, int cchBuffer)
{
  if (!m_spIDsDisplaySpecifier)
  {
    ASSERT(m_spIDsDisplaySpecifier != NULL);
    return E_FAIL;
  }
  return m_spIDsDisplaySpecifier->GetFriendlyAttributeName(lpszObjectClass, 
                                                           lpszAttributeName,
                                                           lpszBuffer, cchBuffer);
}

BOOL CDSBasePathsInfo::IsClassContainer(LPCWSTR lpszObjectClass, LPCWSTR lpszADsPath, DWORD dwFlags)
{
  if (!m_spIDsDisplaySpecifier)
  {
    ASSERT(m_spIDsDisplaySpecifier != NULL);
    return FALSE;
  }
  return m_spIDsDisplaySpecifier->IsClassContainer(lpszObjectClass, lpszADsPath, dwFlags);
}

HRESULT CDSBasePathsInfo::GetClassCreationInfo(LPCWSTR lpszObjectClass, LPDSCLASSCREATIONINFO* ppdscci)
{
  if (!m_spIDsDisplaySpecifier)
  {
    ASSERT(m_spIDsDisplaySpecifier != NULL);
    return E_FAIL;
  }
  return m_spIDsDisplaySpecifier->GetClassCreationInfo(lpszObjectClass, ppdscci);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\inc\dscmn.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dscmn.h
//
//  Contents:   Methods exported from DSPROP.DLL for use in DSADMIN.DLL
//
//  History:    19-February-98 JonN created
//
//-----------------------------------------------------------------------------

#ifndef _DSCMN_H_
#define _DSCMN_H_

//
// Illegal characters that cannot be used in the UPN or SAM Account name
//
#define INVALID_ACCOUNT_NAME_CHARS         L"\"/\\[]:|<>+=;,?,*"
#define INVALID_ACCOUNT_NAME_CHARS_WITH_AT L"\"/\\[]:|<>+=;,?,*@"

// This GUID is copied from ds\setup\schema.ini
#define SZ_GUID_CONTROL_UserChangePassword L"ab721a53-1e2f-11d0-9819-00aa0040529b"
extern const GUID GUID_CONTROL_UserChangePassword;
/* add this to your source:
const GUID GUID_CONTROL_UserChangePassword =
    { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};
*/

HRESULT DSPROP_PickComputer(
	IN HWND hwndParent,
	IN LPCWSTR lpcwszRootPath, // only the server name is used
	OUT BSTR* pbstrADsPath );
HRESULT DSPROP_PickNTDSDSA(
    IN HWND hwndParent,
    IN LPCWSTR lpcwszRootPath,
    OUT BSTR* pbstrADsPath );
HRESULT DSPROP_DSQuery(
    IN HWND hwndParent,
    IN LPCWSTR lpcwszRootPath,
    IN CLSID* pclsidDefaultForm,
    OUT BSTR* pbstrADsPath );
HRESULT DSPROP_IsFrsObject( IN LPWSTR pszClassName, OUT bool* pfIsFrsObject );
HRESULT DSPROP_RemoveX500LeafElements(
    IN unsigned int nElements,
    IN OUT BSTR* pbstrADsPath );
HRESULT DSPROP_TweakADsPath(
    IN     LPCWSTR       lpcwszInitialADsPath,
    IN     int           iTargetLevelsUp,
    IN     PWCHAR*       ppwszTargetLevelsBack,
    OUT    BSTR*         pbstrResultDN
    );
HRESULT DSPROP_RetrieveRDN(
    IN     LPCWSTR       lpwszDN,
    OUT    BSTR*         pbstrRDN
    );
//HRESULT DSPROP_GetGCSearch(
//    IN  REFIID iid,
//    OUT void** ppvObject
//    );
HRESULT DSPROP_GetGCSearchOnDomain(
    PWSTR pwzDomainDnsName,
    IN  REFIID iid,
    OUT void** ppvObject
    );

typedef enum {
    GET_OBJ_CAN_NAME,
    GET_OBJ_CAN_NAME_EX,
    GET_OBJ_1779_DN,
    GET_OBJ_NT4_NAME,
    GET_DNS_DOMAIN_NAME,
    GET_NT4_DOMAIN_NAME,
    GET_FQDN_DOMAIN_NAME,
    GET_OBJ_UPN
} CRACK_NAME_OPR;

HRESULT CrackName(PWSTR pwzNameIn, PWSTR * ppwzDnsName,
                  CRACK_NAME_OPR Opr, HWND hWnd = NULL);

void MsgBox(UINT MsgID, HWND hWnd);
void MsgBox2(UINT MsgID, UINT InsertID, HWND hWnd);
//
// Error reporting. Note, use MsgBoxX (see above) for non-error messages.
//
void ErrMsg(UINT MsgID, HWND hWnd = NULL);
void ErrMsgParam(UINT MsgID, LPARAM param, HWND hWnd = NULL);

BOOL CheckADsError(HRESULT * phr, BOOL fIgnoreAttrNotFound, PSTR file,
                   int line, HWND hwnd = NULL);
#define CHECK_ADS_HR(phr, hwnd) CheckADsError(phr, FALSE, __FILE__, __LINE__, hwnd)
#define CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(phr, hwnd) \
            CheckADsError(phr, TRUE, __FILE__, __LINE__, hwnd)
void ReportError(HRESULT hr, int nStr, HWND hWnd = NULL);
#if defined(DSADMIN)
//+----------------------------------------------------------------------------
//
//  Function:   SuperMsgBox
//
//  Synopsis:   Displays a message obtained from a string resource with
//              the parameters expanded. The error param, dwErr, if
//              non-zero, is converted to a string and becomes the first
//              replaceable param.
//
//              This function includes the functionality of ReportErrorEx in
//              dsadmin\util.cpp *except* it does not have SpecialMessageBox.
//              It also can replace ReportMessageEx by setting dwErr to zero.
//
//  Note: this function is UNICODE-only.
//
//-----------------------------------------------------------------------------
int SuperMsgBox(
    HWND hWnd,          // owning window.
    int nMessageId,     // string resource ID of message. Must have replacable params to match nArguments.
    int nTitleId,       // string resource ID of the title. If zero, uses IDS_MSG_TITLE.
    UINT ufStyle,       // MessageBox flags.
    DWORD dwErr,        // Error code, or zero if not needed.
    PVOID * rgpvArgs,   // array of pointers/values for substitution in the nMessageId string.
    int nArguments,     // count of pointers in string array.
    BOOL fTryADSiErrors,// If the failure is the result of an ADSI call, see if an ADSI extended error.
    PSTR szFile,        // use the __FILE__ macro. ignored in retail build.
    int nLine           // use the __LINE__ macro. ignored in retail build.
    );
#endif //defined(DSADMIN)

HRESULT
ModifyNetWareUserPassword(
    IN IADsUser*          pADsUser,
    IN PCWSTR             pwzADsPath,
    IN PCWSTR             pwzNewPassword
);

BOOL CheckGroupUpdate(HRESULT hr, HWND hPage = NULL, BOOL fAdd = TRUE, PWSTR pwzDN = NULL);

#ifndef dspAssert
#define dspAssert ASSERT
#endif

// smartpointer for PADS_ATTR_INFO
void Smart_PADS_ATTR_INFO__Empty( PADS_ATTR_INFO* ppAttrs );
class Smart_PADS_ATTR_INFO
{
private:
  PADS_ATTR_INFO m_pAttrs;
public:
  Smart_PADS_ATTR_INFO::Smart_PADS_ATTR_INFO() : m_pAttrs(NULL) {}
  Smart_PADS_ATTR_INFO::~Smart_PADS_ATTR_INFO() { Empty(); }
  operator PADS_ATTR_INFO() const { return m_pAttrs; }
  PADS_ATTR_INFO* operator&() { return &m_pAttrs; }
  PADS_ATTR_INFO operator->() {dspAssert(m_pAttrs); return m_pAttrs;}
  void Empty() { Smart_PADS_ATTR_INFO__Empty( &m_pAttrs ); }
};

// smartpointer for DsBind handle
void Smart_DsHandle__Empty( HANDLE* phDs );
class Smart_DsHandle
{
private:
  HANDLE m_hDs;
public:
  Smart_DsHandle::Smart_DsHandle() : m_hDs(NULL) {}
  Smart_DsHandle::~Smart_DsHandle() { Empty(); }
  operator HANDLE() const { return m_hDs; }
  HANDLE* operator&() { return &m_hDs; }
  void Empty() { Smart_DsHandle__Empty( &m_hDs ); }
};

class DSPROP_BSTR_BLOCK;
bool  DSPROP_BSTR_BLOCK__SetCount(  DSPROP_BSTR_BLOCK& block, int cItems );
BSTR& DSPROP_BSTR_BLOCK__Reference( DSPROP_BSTR_BLOCK& block, int iItem  );

class DSPROP_BSTR_BLOCK
{
public:
    DSPROP_BSTR_BLOCK()
        : m_cItems( 0 )
        , m_abstrItems( NULL ) {}
    ~DSPROP_BSTR_BLOCK() { Empty(); }

    int QueryCount() const { return m_cItems; }
    const BSTR operator[](int iItem) const
        { return DSPROP_BSTR_BLOCK__Reference(
                const_cast<DSPROP_BSTR_BLOCK&>(*this), iItem ); }
    operator const BSTR*() const { return m_abstrItems; }
    operator LPWSTR*() const { return (LPWSTR*)m_abstrItems; }

    bool SetCount( int cItems )
        { return DSPROP_BSTR_BLOCK__SetCount(  *this, cItems ); }
    bool Set( BSTR cbstrItem, int iItem )
        {
            return (NULL != (
                DSPROP_BSTR_BLOCK__Reference( *this, iItem ) =
                    ::SysAllocString(cbstrItem) ) );
        }

    void Empty() { (void) SetCount(0); }

private:
    int   m_cItems;
    BSTR* m_abstrItems;

friend bool  DSPROP_BSTR_BLOCK__SetCount(  DSPROP_BSTR_BLOCK& block, int cItems );
friend BSTR& DSPROP_BSTR_BLOCK__Reference( DSPROP_BSTR_BLOCK& block, int iItem  );
};

HRESULT DSPROP_ShallowSearch(
    IN OUT DSPROP_BSTR_BLOCK* pbstrBlock,
    IN LPCTSTR lpcwszADsPathDirectory,
    IN LPCTSTR lpcwszTargetDesiredClass,
    IN PADS_ATTR_INFO pAttrInfoExclusions = NULL
    );

// The following functions support duelling listbox capability
HRESULT DSPROP_Duelling_Populate(
    IN HWND hwndListbox,
    IN const DSPROP_BSTR_BLOCK& bstrblock
    );
void DSPROP_Duelling_UpdateButtons(
    HWND hwndDlg,
    int nAnyCtrlid
    );
void DSPROP_Duelling_ButtonClick(
    HWND hwndDlg,
    int nButtonCtrlid
    );
void DSPROP_Duelling_ClearListbox(
    HWND hwndListbox
    );

// JonN 4/8/99: add code to enable horizontal scrolling where appropriate
HRESULT DSPROP_HScrollStringListbox(
    HWND hwndListbox
    );


DWORD DSPROP_CreateHomeDirectory(IN PSID pUserSid, IN LPCWSTR lpszPathName);
BOOL DSPROP_IsValidUNCPath(LPCWSTR lpszPath);

void DSPROP_DomainVersionDlg(PCWSTR pwzDomainPath, PCWSTR pwzDomainDnsName,
                             HWND hWndParent);
void DSPROP_ForestVersionDlg(PCWSTR pwzConfigPath, PCWSTR pwzPartitionsPath,
                             PCWSTR pwzSchemaPath, PCWSTR pwzRootDnsName,
                             HWND hWndParent);

#endif // _DSCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\src\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef  __PCH_H
#define  __PCH_H

// MFC
#include <afxwin.h>
#include <afxtempl.h>		// MFC Template classes

// ATL
#include <atlbase.h>

#include <shlobj.h>

// ADSI
#include <activeds.h>
#include <iadsp.h>

// Display Specifier stuff
#include <dsclient.h>

// MMC
#include <mmc.h>

#include "dbg.h"
#include "dsadminp.h"
#include "dscmn.h"

#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\inc\shluuid.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       propuuid.h
//
//  Contents:   guid definitions.
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

DEFINE_GUID(CLSID_SpecialUserInfo,0x717ef4fe,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
//DEFINE_GUID(CLSID_Unused,0x717ef4ff,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsShellUserPropPages,0xf5d121ed,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellContactPropPages,0xf5d121f0,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellGroupPropPages,0xf5d121ee,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellDomainPropPages,0xf5d121ef,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellOUPropPages,0xf2c3faae,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellVolumePropPages,0xf5d121f3,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsShellComputerPropPages,0xf5d121f4,0xc8ac,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\inc\propuuid.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       propuuid.h
//
//  Contents:   guid definitions.
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

DEFINE_GUID(CLSID_DsUserPropPages,0x6dfe6485,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsFSPOPropPages,0x6dfe6486,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
//DEFINE_GUID(CLSID_DsMailPropPages,0x6dfe6487,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsTopPropPages,0x6dfe6488,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsGroupPropPages,0x6dfe6489,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsMemberOfPropPages,0x6dfe648a,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsManageableObjPropPages,0x6dfe648b,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsDomainPropPages,0x6dfe648c,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsOuGenPropPage,0x9da6fd63,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsDomainPolicyPropPages,0x6dfe648e,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsLocalPolicyPropPages,0x6dfe648f,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsVolumePropPages,0x6dfe6490,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsIntersitePropPages,0x6dfe6491,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsComputerPropPages,0x6dfe6492,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsPrinterPropPages,0x6dfe6493,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsReplServerPropPages,0x6dfe6494,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsReplSitePropPages,0x717ef4fa,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSettingsPropPages,0x717ef4fb,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplDSAPropPages,0x717ef4fc,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplConnectionPropPages,0x717ef4fd,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSiteLicenseSettingsPropPages,0x717ef500,0xac8d,0x11d0,0xb9,0x45,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSiteSettingsPropPages,0x2f280288,0xbb6d,0x11d0,0xb9,0x48,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSubnetPropPages,0x9da6fd62,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);

DEFINE_GUID(CLSID_DsServiceAdminPage,0xc5f1645d,0xc8c9,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsContactPropPages,0xc5f1645c,0xc8c9,0x11d0,0xbc,0xdb,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsDomainOuPropPages,0x6dfe648d,0xa212,0x11d0,0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);
DEFINE_GUID(CLSID_DsKeywordsPropPage,0x9da6fd64,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsPhonePropPage,0x9da6fd65,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsAddressPhoneNotesPropPages,0x9da6fd66,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsTrustedDomainPropPages,0x9da6fd67,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);

DEFINE_GUID(CLSID_DsFrsSettings,0x9da6fd68,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsFrsReplicaSet,0x9da6fd69,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsFrsMember,0x9da6fd6a,0xc63b,0x11d0,0xb9,0x4d,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);

DEFINE_GUID(CLSID_DsContainerGeneralPage,0x5a96f2d8,0x736e,0x11d1,0xbd,0x0d,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);

DEFINE_GUID(CLSID_DsDefaultGeneralPage,0x6384e23e,0x736d,0x11d1,0xbd,0x0d,0x00,0xc0,0x4f,0xd8,0xd5,0xb6);

DEFINE_GUID(CLSID_DsFrsSubscriber,0x50d3055f,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsFrsSubscriptions,0x50d30560,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSiteLink,0x50d30561,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsReplSiteLinkBridge,0x50d30562,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsRpcContainer,0x50d30572,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsDefaultMultiGeneralPage,0x50d30563,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
DEFINE_GUID(CLSID_DsUserMultiPropPages,0x50d30564,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30565,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30566,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30567,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30568,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30569,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056a,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056b,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056c,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056d,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056e,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d3056f,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30570,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
// DEFINE_GUID(CLSID_Unused,0x50d30571,0x9911,0x11d1,0xb9,0xaf,0x00,0xc0,0x4f,0xd8,0xd5,0xb0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsadminlib\src\_dsadmin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       _dsadmin.cpp
//
//--------------------------------------------------------------------------


// FILE: _dsadmin.cpp

#include "pch.h"

//
// Common code for reading attributes using IDirectoryObject
// JonN 4/7/98
//

#define BREAK_ON_FAIL if (FAILED(hr)) { break; }
#define BREAK_AND_ASSERT_ON_FAIL if (FAILED(hr)) { ASSERT(FALSE); break; }
#define RETURN_ON_FAIL if (FAILED(hr)) { return hr; }
#define RETURN_AND_ASSERT_ON_FAIL if (FAILED(hr)) { ASSERT(FALSE); return hr; }

// returns E_FAIL if the attribute is not set
HRESULT GetAttr( IN IADs* pIADs, IN WCHAR* wzAttr, OUT PADS_ATTR_INFO* ppAttrs )
{
  ASSERT( NULL != pIADs && NULL != wzAttr && NULL != ppAttrs && NULL == *ppAttrs );

  CComQIPtr<IDirectoryObject,&IID_IDirectoryObject> spIDirectoryObject( pIADs );
  if (!spIDirectoryObject)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  DWORD cAttrs = 0;
  HRESULT hr = spIDirectoryObject->GetObjectAttributes(&wzAttr, 1, ppAttrs, &cAttrs);
  RETURN_ON_FAIL;
  if (   1 != cAttrs
      || NULL == *ppAttrs
      )
  {
    // the attribute is not set
    ASSERT( NULL == *ppAttrs );
    *ppAttrs = NULL; // might leak, but this shouldn't happen
    return E_FAIL;
  }

  return hr;
}

// returns E_FAIL if the attribute is not set
HRESULT GetStringAttr( IN IADs* pIADs, IN WCHAR* wzAttr, OUT BSTR* pbstr )
{
  ASSERT( NULL != pbstr && NULL == *pbstr );

  Smart_PADS_ATTR_INFO spAttrs;
  HRESULT hr = GetAttr( pIADs, wzAttr, &spAttrs );
  RETURN_ON_FAIL; // the attribute might just not exist

  LPWSTR pwz = NULL;
  switch (spAttrs[0].pADsValues[0].dwType)
  {
  case ADSTYPE_DN_STRING:
    pwz = spAttrs[0].pADsValues[0].DNString;
    break;
  case ADSTYPE_CASE_EXACT_STRING:
    pwz = spAttrs[0].pADsValues[0].CaseExactString;
    break;
  case ADSTYPE_CASE_IGNORE_STRING:
    pwz = spAttrs[0].pADsValues[0].CaseIgnoreString;
    break;
  default:
    ASSERT(FALSE);
    return E_FAIL;
  }
  ASSERT( NULL != pwz );

  *pbstr = ::SysAllocString( pwz );
  if (NULL == *pbstr)
  {
    ASSERT(FALSE);
    return E_OUTOFMEMORY;
  }

  return hr;
}

// returns E_FAIL if the attribute is not set
HRESULT GetObjectGUID( IN IADs* pIADs, OUT UUID* pUUID )
{
  ASSERT( NULL != pUUID );

  Smart_PADS_ATTR_INFO spAttrs;
  HRESULT hr = GetAttr( pIADs, L"objectGUID", &spAttrs );
  RETURN_ON_FAIL; // This is an optional parameter according to the schema
  if (   NULL == (PADS_ATTR_INFO)spAttrs
      || NULL == spAttrs[0].pADsValues
      || ADSTYPE_OCTET_STRING != spAttrs[0].pADsValues[0].dwType
      || sizeof(UUID) != spAttrs[0].pADsValues[0].OctetString.dwLength
      || NULL == spAttrs[0].pADsValues[0].OctetString.lpValue
      )
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  CopyMemory( pUUID, spAttrs[0].pADsValues[0].OctetString.lpValue, sizeof(UUID) );

  return hr;
}

// returns E_FAIL if the attribute is not set
HRESULT GetObjectGUID( IN IADs* pIADs, OUT BSTR* pbstrObjectGUID )
{
  ASSERT( NULL != pbstrObjectGUID && NULL == *pbstrObjectGUID );

  UUID uuid;
  ::ZeroMemory( &uuid, sizeof(uuid) );
  HRESULT hr = GetObjectGUID( pIADs, &uuid );
  RETURN_ON_FAIL; // This is an optional parameter according to the schema

  WCHAR awch[MAX_PATH];
  ::ZeroMemory( awch, sizeof(awch) );
  hr = ::StringFromGUID2(uuid, awch, MAX_PATH);
  RETURN_AND_ASSERT_ON_FAIL;

  *pbstrObjectGUID = ::SysAllocString( awch );
  if (NULL == *pbstrObjectGUID)
  {
    ASSERT(FALSE);
    return E_OUTOFMEMORY;
  }

  return hr;
}





///////////////////////////////////////////////////////////////////
// Function: GetADSIServerName
//
// Given an Unknown* that supports IADsObjectOptions, it
// returns the server name ADSI is bound to. 

HRESULT GetADSIServerName(OUT PWSTR* szServer, IN IUnknown* pUnk)
{
  CComPtr<IADsObjectOptions> spIADsObjectOptions;
  HRESULT hr = pUnk->QueryInterface(IID_IADsObjectOptions, (void**)&spIADsObjectOptions);
  if (FAILED(hr))
    return hr;

  VARIANT var;
  ::VariantInit(&var);

  hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);
  if (FAILED(hr))
    return hr;

  ASSERT(var.vt == VT_BSTR);
  BSTR value = V_BSTR(&var);

  if (value)
  {
     *szServer = new WCHAR[wcslen(value) + 1];
     ASSERT(*szServer);
     if (*szServer)
     {
        wcsncpy(*szServer, value, wcslen(value) + 1);
     }
     else
     {
        hr = E_OUTOFMEMORY;
     }
  }

  ::VariantClear(&var);
  return hr;

}



void StringErrorFromHr(HRESULT hr, PWSTR* szError, BOOL bTryADsIErrors)
{
  PWSTR lpsz = NULL;
  int cch = cchLoadHrMsg(hr, &lpsz, bTryADsIErrors);
  if (cch)
  {
    *szError = new WCHAR[wcslen(lpsz) + 1];
    if (*szError)
    {
      wcsncpy(*szError, lpsz, wcslen(lpsz) + 1);
    }
  }
  else
  {
    UINT maxError = 40;
    *szError = new WCHAR[maxError];
    if (*szError)
    {
      ZeroMemory(*szError, sizeof(WCHAR) * maxError);
      wsprintf(*szError, L"Error 0x%x", hr);
    }
  }
  if (lpsz != NULL)
    ::LocalFree(lpsz);
}


///////////////////////////////////////////////////////////////////
// Function: cchLoadHrMsg
//
// Given an HRESULT error code and a flag TryADsIErrors,
// it loads the string for the error. It returns the # of characters returned
// NOTICE: free the returned string using LocalFree.
int cchLoadHrMsg( IN HRESULT hr, OUT PTSTR* pptzSysMsg, IN BOOL TryADsIErrors )
{

  HRESULT Localhr = S_OK;
  DWORD status;

  // first check if we have extended ADs errors
  if ((hr != S_OK) && TryADsIErrors) {
    WCHAR Buf1[256], Buf2[256];
    Localhr = ADsGetLastError (&status,
                               Buf1, 256, Buf2, 256);
    TRACE(_T("ADsGetLastError returned status of %lx, error: %s, name %s\n"),
          status, Buf1, Buf2);

    if ((status != ERROR_INVALID_DATA) &&
        (status != 0)) {
      hr = status;
    }
  }

  int cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)pptzSysMsg, 0, NULL);

  if (!cch) { //try ads errors
    static HMODULE g_adsMod = 0;
    if (0 == g_adsMod)
      g_adsMod = GetModuleHandle (L"activeds.dll");
    cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE, g_adsMod, hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)pptzSysMsg, 0, NULL);
  }
  return cch;
}


/////////////////////////////////////////////////////////////////////
// FSMO Mainipulation API's



HRESULT _BindToFsmoHolder(IN CDSBasePathsInfo* pPathInfo,
                          IN FSMO_TYPE fsmoType,
                             OUT IADs** ppIADs)
{
  // determine the LDAP path of the object
  PWSTR szPath = 0;
  switch (fsmoType)
  {
  case SCHEMA_FSMO:
    TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = SCHEMA_FSMO\n");
    pPathInfo->GetSchemaPath(&szPath);
    break;
  case RID_POOL_FSMO:
    {
      TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = RID_POOL_FSMO\n");
      pPathInfo->GetDefaultRootPath(&szPath);
      CComPtr<IADs> spDefaultContainer;
      HRESULT hr = ::ADsOpenObject(szPath,
                       NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs,
                        (void **)&spDefaultContainer);

      TRACE(L"_BindToFsmoHolder(): ADsOpenObject(%s) returned hr = 0x0%x\n", 
            szPath, hr);

      if (FAILED(hr))
      {
        if (szPath)
        {
          delete[] szPath;
          szPath = 0;
        }
        return hr;
      }

      VARIANT ridManagerRefVariant;
      ::VariantInit(&ridManagerRefVariant);

      hr = spDefaultContainer->Get(L"rIDManagerReference", &ridManagerRefVariant);
      
      TRACE(L"_BindToFsmoHolder(): spDefaultContainer->Get(rIDManagerReference,...) returned hr = 0x0%x\n", 
                 hr);
      
      if (FAILED(hr))
      {
        if (szPath)
        {
          delete[] szPath;
          szPath = 0;
        }
        return hr;
      }

      TRACE(L"ridManagerRefVariant.bstrVal = <%s>\n", ridManagerRefVariant.bstrVal);

      if (szPath)
      {
        delete[] szPath;
        szPath = 0;
      }
      pPathInfo->ComposeADsIPath(&szPath, ridManagerRefVariant.bstrVal);
      ::VariantClear(&ridManagerRefVariant);
    }
    break;
  case PDC_FSMO:
    TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = PDC_FSMO\n");
    pPathInfo->GetDefaultRootPath(&szPath);
    break;
  case INFRASTUCTURE_FSMO:
    TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = INFRASTUCTURE_FSMO\n");
    pPathInfo->GetInfrastructureObjectPath(&szPath);
    break;
  case DOMAIN_NAMING_FSMO:
    TRACE(L"_BindToFsmoHolder(), FSMO_TYPE = DOMAIN_NAMING_FSMO\n");
    pPathInfo->GetPartitionsPath(&szPath);
    break;
  default:
      ASSERT(FALSE);
      return E_INVALIDARG;
  };

  // bind to it
  TRACE(L"_BindToFsmoHolder(): final bind szPath is = <%s>\n", (LPCWSTR)szPath);

  HRESULT hr = E_OUTOFMEMORY;
  if (szPath)
  {
    hr = ::ADsOpenObject(szPath,
                 NULL, NULL, ADS_SECURE_AUTHENTICATION,
                 IID_IADs,
                (void **)ppIADs);
    TRACE(L"_BindToFsmoHolder(): final ADsOpenObject(%s) returned hr = 0x0%x\n", 
          szPath, hr);
  }

  if (szPath)
  {
    delete[] szPath;
    szPath = 0;
  }


  return hr;
}

LPCWSTR _GetDummyProperty(IN FSMO_TYPE fsmoType)
{
  switch (fsmoType)
  {
  case SCHEMA_FSMO:
    return L"becomeSchemaMaster";
    break;
  case RID_POOL_FSMO:
    return L"becomeRIDMaster";
  case PDC_FSMO:
    return L"becomePDC";
    break;
  case INFRASTUCTURE_FSMO:
    return L"becomeInfrastructureMaster";
  case DOMAIN_NAMING_FSMO:
    return L"becomeDomainMaster";
    break;
  };
  return NULL;
}



class CX500LeafElementRemover
{
public:

  HRESULT Bind()
  {
    HRESULT hr = S_OK;
    if (m_spIADsPathname == NULL)
    {
      hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IADsPathname, (PVOID *)&(m_spIADsPathname));
      ASSERT((S_OK == hr) && (m_spIADsPathname != NULL));
    }
    return hr;
  }

  HRESULT RemoveLeafElement(IN LPCWSTR lpszX500DN, OUT CComBSTR& bsX500DN)
  {
    TRACE(L"RemoveLeafElement(%s)\n", lpszX500DN);
    bsX500DN.Empty();
    if (m_spIADsPathname == NULL)
      return E_FAIL;

    HRESULT hr = m_spIADsPathname->Set((LPWSTR)lpszX500DN, ADS_SETTYPE_DN);
    if (FAILED(hr))
    {
      return hr;
    }
    hr = m_spIADsPathname->RemoveLeafElement();
    if (FAILED(hr))
    {
      return hr;
    }
    hr = m_spIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bsX500DN);

    TRACE(L"m_spIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bsX500DN) returned hr = 0x%x, bsX500DN = <%s>\n",
                    hr, bsX500DN);
    return hr;
  }

private:
  CComPtr<IADsPathname> m_spIADsPathname;
};






HRESULT FindFsmoOwner(IN CDSBasePathsInfo* pCurrentPath,
                      IN FSMO_TYPE fsmoType,
                      OUT CDSBasePathsInfo* pFsmoOwnerPath,
                      OUT PWSTR* szFsmoOwnerServerName)
{
  TRACE(L"FindFsmoOwner()\n");

  if (!szFsmoOwnerServerName)
  {
    ASSERT(szFsmoOwnerServerName);
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;
  // start with the current path
  pFsmoOwnerPath->InitFromInfo(pCurrentPath);
  
  static const int nMaxReferrals = 10;
  int nIteration = 0;


  // create an instance of the path cracker to remove leaf elements
  CX500LeafElementRemover leafRemover;
  hr = leafRemover.Bind();
  if (FAILED(hr)) 
  {
    return hr;
  }


  // loop searching for referrals
  TRACE(L"loop searching for referrals\n");
  do
  {
    TRACE(L"BEGIN LOOP\n");

    // bind to the object holding the FSMO attribute
    CComPtr<IADs> spIADsFsmo;
    hr = _BindToFsmoHolder(pFsmoOwnerPath, fsmoType, &spIADsFsmo);
    if (FAILED(hr))
      return hr;

    // get the FSMO Role Owner property
    VARIANT fsmoRoleOwnerProperty;
    ::VariantInit(&fsmoRoleOwnerProperty);

    hr = spIADsFsmo->Get(L"fSMORoleOwner", &fsmoRoleOwnerProperty);
    
    TRACE(L"spIADsFsmo->Get(fSMORoleOwner) returned hr = 0x%x\n", hr);
    
    if (FAILED(hr))
      return hr;

    // The result here is in the form, "CN=NTDS Settings,CN=Machine,CN=..."
    // we need to just have "CN=Machine,CN=..."

    CComBSTR bsTemp;
    hr = leafRemover.RemoveLeafElement(IN fsmoRoleOwnerProperty.bstrVal, OUT bsTemp);
    
    TRACE(L"leafRemover.RemoveLeafElement(%s) returned hr = 0x%x\n",  fsmoRoleOwnerProperty.bstrVal, hr);

    ::VariantClear(&fsmoRoleOwnerProperty);

    if (FAILED(hr))
    {
      return hr;
    }

    // bind to the path
    PWSTR szfsmoRoleOwnerPath;
    pFsmoOwnerPath->ComposeADsIPath(&szfsmoRoleOwnerPath, bsTemp);
    CComPtr<IADs> spFsmoRoleOwner;
    hr = ::ADsOpenObject(szfsmoRoleOwnerPath,
                    NULL, NULL, ADS_SECURE_AUTHENTICATION,
                    IID_IADs,
                   (void **)&spFsmoRoleOwner);

    TRACE(L"ADsOpenObject(%s) on szfsmoRoleOwnerPath returned hr = 0x%x \n", szfsmoRoleOwnerPath, hr);
    
    if (szfsmoRoleOwnerPath)
    {
       delete[] szfsmoRoleOwnerPath;
       szfsmoRoleOwnerPath = 0;
    }

    if (FAILED(hr))
      return hr;

    // get the DNS host name of the FSMO owner
    VARIANT dNSHostNameProperty;
    ::VariantInit(&dNSHostNameProperty);

    hr = spFsmoRoleOwner->Get(L"dNSHostName", &dNSHostNameProperty);
    TRACE(L"spFsmoRoleOwner->Get(dNSHostName, ...) returned hr = 0x%x\n",  hr);

    if (FAILED(hr))
      return hr;

    if (dNSHostNameProperty.bstrVal)
    {
       *szFsmoOwnerServerName = new WCHAR[wcslen(dNSHostNameProperty.bstrVal) + 1];
       if (!(*szFsmoOwnerServerName))
       {
         ASSERT(*szFsmoOwnerServerName);
         ::VariantClear(&dNSHostNameProperty);
         return E_OUTOFMEMORY;
       }

       wcsncpy(*szFsmoOwnerServerName, dNSHostNameProperty.bstrVal, 
               wcslen(dNSHostNameProperty.bstrVal) + 1);
    }

    // compare with the current server
    TRACE(L"compare szFsmoOwnerServerName = <%s> with pFsmoOwnerPath->GetServerName() = <%s>\n",
                           *szFsmoOwnerServerName, pFsmoOwnerPath->GetServerName());

    if (_wcsicmp(dNSHostNameProperty.bstrVal, pFsmoOwnerPath->GetServerName()) == 0)
    {
      // we are done, found the owner
      TRACE(L"we are done, found the owner\n");

      ::VariantClear(&dNSHostNameProperty);
      break;
    }

    // too many iterations, we have to break out
    if (nIteration >= nMaxReferrals)
    {
      TRACE(L"too many iterations, we have to break out\n");
      hr = E_FAIL;
      ::VariantClear(&dNSHostNameProperty);
      break;
    }

    // we got a referral, try another round
    // by binding to that server to chase the referral
    TRACE(L" we got a referral, try another round\n");
    hr = pFsmoOwnerPath->InitFromName(dNSHostNameProperty.bstrVal);

    ::VariantClear(&dNSHostNameProperty);
    if (FAILED(hr))
      return hr;

    nIteration++;
    TRACE(L"END LOOP\n");
  }
  while (TRUE);

  return hr;
}

HRESULT CheckpointFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo)
{
  // assume we are already bound to the RootDSE
  IADs* pIADsRoot = pPathInfo->GetRootDSE();
  ASSERT(pIADsRoot != NULL);
  if (pIADsRoot == NULL)
    return E_INVALIDARG;

  // try to write the dummy property to cause the transfer

  VARIANT argVar;
  ::VariantInit(&argVar);
  
// need to get the domain SID to pass as an argument
  PWSTR szDomainPath = 0;
  pPathInfo->GetDefaultRootPath(&szDomainPath);
  
  CComPtr<IADs> spDomainObject;
  HRESULT hr = ::ADsOpenObject(szDomainPath,
                               NULL, NULL, ADS_SECURE_AUTHENTICATION,
                               IID_IADs,
                               (void **)&spDomainObject);

  if (szDomainPath)
  {
     delete[] szDomainPath;
     szDomainPath = 0;
  }

  if (FAILED(hr))
    return hr;
  
  hr = spDomainObject->Get(L"objectSid", &argVar);
  if (FAILED(hr))
    return hr;
  
  pIADsRoot->GetInfo();
  hr = pIADsRoot->Put(L"becomePdcWithCheckPoint", argVar);

  ::VariantClear(&argVar);
  if (FAILED(hr))
      return hr;
  return pIADsRoot->SetInfo();
}


// tell the target server to assume the FSMO
HRESULT GracefulFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo, IN FSMO_TYPE fsmoType)
{
  // assume we are already bound to the RootDSE
  IADs* pIADsRoot = pPathInfo->GetRootDSE();
  ASSERT(pIADsRoot != NULL);
  if (pIADsRoot == NULL)
    return E_INVALIDARG;

  // try to write the dummy property to cause the transfer

  VARIANT argVar;
  ::VariantInit(&argVar);

  if (fsmoType == PDC_FSMO) 
  {
    // need to get the domain SID to pass as an argument
    PWSTR szDomainPath = 0;
    pPathInfo->GetDefaultRootPath(&szDomainPath);

    CComPtr<IADs> spDomainObject;
    HRESULT hr = ::ADsOpenObject(szDomainPath,
                   NULL, NULL, ADS_SECURE_AUTHENTICATION,
                   IID_IADs,
                  (void **)&spDomainObject);

    if (szDomainPath)
    {
       delete[] szDomainPath;
       szDomainPath = 0;
    }

    if (FAILED(hr))
      return hr;

    hr = spDomainObject->Get(L"objectSid", &argVar);
    if (FAILED(hr))
      return hr;
  }
  else
  {
    // dummy value, anything would do
    argVar.vt = VT_I4;
    argVar.lVal = (long)1;
  }
  pIADsRoot->GetInfo();
  HRESULT hr = pIADsRoot->Put((LPWSTR)_GetDummyProperty(fsmoType), argVar);

  ::VariantClear(&argVar);

  if (FAILED(hr))
      return hr;
  return pIADsRoot->SetInfo();
}

HRESULT ForcedFsmoOwnerTransfer(IN CDSBasePathsInfo* pPathInfo,
                                IN FSMO_TYPE fsmoType)
{
  // assume we are already bound to the RootDSE
  IADs* pIADsRoot = pPathInfo->GetRootDSE();
  ASSERT(pIADsRoot != NULL);
  if (pIADsRoot == NULL)
    return E_INVALIDARG;

  VARIANT serverName;
  ::VariantInit(&serverName);

  // this attribute is in the form "CN=Machine,CN=..."
  HRESULT hr = pIADsRoot->Get(L"serverName", &serverName);
  if (FAILED(hr))
    return hr;

  // bind to the object holding the FSMO attribute
  CComPtr<IADs> spIADsFsmo;
  hr = _BindToFsmoHolder(pPathInfo, fsmoType, &spIADsFsmo);
  if (FAILED(hr))
  {
    ::VariantClear(&serverName);
    return hr;
  }

  // rebuild the attribute
  PCWSTR pszBaseSettings = L"CN=NTDS Settings,";
  size_t newStringLength = wcslen(serverName.bstrVal) + wcslen(pszBaseSettings) + 1;
  PWSTR szNewAttr = new WCHAR[newStringLength];
  if (!szNewAttr)
  {
    ::VariantClear(&serverName);
    return E_OUTOFMEMORY;
  }

  ZeroMemory(szNewAttr, wcslen(serverName.bstrVal) + wcslen(pszBaseSettings) + 1);
  wcsncpy(szNewAttr, pszBaseSettings, newStringLength);
  wcsncat(szNewAttr, serverName.bstrVal, wcslen(serverName.bstrVal));

  ::VariantClear(&serverName);

  // set the FSMO Role Owner property
  // this completes the transfer
  VARIANT fsmoRoleOwnerProperty;
  ::VariantInit(&fsmoRoleOwnerProperty);
  fsmoRoleOwnerProperty.bstrVal = szNewAttr;
  fsmoRoleOwnerProperty.vt = VT_BSTR;

  hr = spIADsFsmo->Put(L"fSMORoleOwner", fsmoRoleOwnerProperty);
  if (FAILED(hr))
      return hr;
  return spIADsFsmo->SetInfo();
}









///////////////////////////////////////////////////////////////////////////////
// CDsDisplaySpecOptionsCFHolder

HRESULT CDsDisplaySpecOptionsCFHolder::Init(CDSBasePathsInfo* pBasePathInfo)
{
  ASSERT(pBasePathInfo != NULL);
  // get full path in the form "LDAP://<server>/<config>" 
  PWSTR szConfigPath = 0;
  pBasePathInfo->GetConfigPath(&szConfigPath);
  if (!szConfigPath)
  {
     return E_OUTOFMEMORY;
  }

  DWORD nConfigPathLen = static_cast<DWORD>(wcslen(szConfigPath));

  // get the offset of the config path
  UINT nServerNameLen = static_cast<UINT>(wcslen(pBasePathInfo->GetServerName()));
  UINT nAttribPrefixLen = static_cast<UINT>(wcslen(DS_PROP_ADMIN_PREFIX));

  // allocate memory
  UINT cbStruct = sizeof (DSDISPLAYSPECOPTIONS);
  DWORD dwSize = cbStruct + 
    ((nAttribPrefixLen+1) + (nServerNameLen+1) + (nConfigPathLen+1))*sizeof(WCHAR);
  PDSDISPLAYSPECOPTIONS pNewDsDisplaySpecOptions = (PDSDISPLAYSPECOPTIONS)
                  GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, dwSize);

  if (pNewDsDisplaySpecOptions == NULL) 
  {
    delete[] szConfigPath;
    szConfigPath = 0;

    return E_OUTOFMEMORY;
  }

  // set data
  pNewDsDisplaySpecOptions->dwSize = sizeof (DSDISPLAYSPECOPTIONS);
  pNewDsDisplaySpecOptions->dwFlags = DSDSOF_HASUSERANDSERVERINFO | DSDSOF_DSAVAILABLE;
//  pNewDsDisplaySpecOptions->dwFlags = DSDSOF_HASUSERANDSERVERINFO;

  // set offsets and copy strings
  pNewDsDisplaySpecOptions->offsetUserName = 0; // not passed
  pNewDsDisplaySpecOptions->offsetPassword = 0; // not passed

  pNewDsDisplaySpecOptions->offsetAttribPrefix = cbStruct;
  wcscpy ((LPWSTR)((BYTE *)pNewDsDisplaySpecOptions + pNewDsDisplaySpecOptions->offsetAttribPrefix), 
                        (LPCWSTR)DS_PROP_ADMIN_PREFIX);

  pNewDsDisplaySpecOptions->offsetServer = 
      pNewDsDisplaySpecOptions->offsetAttribPrefix + (nAttribPrefixLen+1)*sizeof(WCHAR);
  wcscpy ((LPWSTR)((BYTE *)pNewDsDisplaySpecOptions + pNewDsDisplaySpecOptions->offsetServer), 
                        pBasePathInfo->GetServerName());
  

  pNewDsDisplaySpecOptions->offsetServerConfigPath = 
     pNewDsDisplaySpecOptions->offsetServer + (nServerNameLen+1)*sizeof(WCHAR);
  wcscpy ((LPWSTR)((BYTE *)pNewDsDisplaySpecOptions + pNewDsDisplaySpecOptions->offsetServerConfigPath),
          szConfigPath);

  if (szConfigPath)
  {
     delete[] szConfigPath;
     szConfigPath = 0;
  }

  if (m_pDsDisplaySpecOptions != NULL) 
  {
    GlobalFree(m_pDsDisplaySpecOptions);
  }
  m_pDsDisplaySpecOptions = pNewDsDisplaySpecOptions;
  return S_OK;
}

PDSDISPLAYSPECOPTIONS CDsDisplaySpecOptionsCFHolder::Get()
{
  ASSERT(m_pDsDisplaySpecOptions != NULL);
  if (m_pDsDisplaySpecOptions == NULL)
    return NULL;

  PDSDISPLAYSPECOPTIONS pDsDisplaySpecOptions;
  pDsDisplaySpecOptions = (PDSDISPLAYSPECOPTIONS)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                     GlobalSize(m_pDsDisplaySpecOptions));
  if (pDsDisplaySpecOptions == NULL)
  {
    return NULL;
  }
  memcpy(pDsDisplaySpecOptions, m_pDsDisplaySpecOptions, (size_t)GlobalSize(m_pDsDisplaySpecOptions));
  return pDsDisplaySpecOptions;
}

//////////////////////////////////////////////////////////////////////////
// CToggleTextControlHelper


CToggleTextControlHelper::CToggleTextControlHelper()
{
	m_hWnd = 0;
  m_pTxt1 = m_pTxt2 = NULL;
}

CToggleTextControlHelper::~CToggleTextControlHelper()
{
	if (m_pTxt1 != NULL)
		free(m_pTxt1);
}


BOOL CToggleTextControlHelper::Init(HWND hWnd)
{
	ASSERT(m_hWnd == NULL);
	ASSERT(::IsWindow(hWnd));
	m_hWnd = hWnd;

	// get the text out of the window
	int nLen = ::GetWindowTextLength(m_hWnd);
	ASSERT(m_pTxt1 == NULL);
	m_pTxt1 = (WCHAR*)malloc(sizeof(WCHAR)*(nLen+1));
  if (m_pTxt1 == NULL)
    return FALSE;

  ::GetWindowText(m_hWnd, m_pTxt1, nLen+1);
	ASSERT(m_pTxt1 != NULL);

	// look for '\n', change it into '\0'and get a pointer to it
	m_pTxt2 = m_pTxt1;
	while (*m_pTxt2)
	{
		if (*m_pTxt2 == TEXT('\n'))
		{
			*m_pTxt2 = TEXT('\0');
			m_pTxt2++;
      ::SetWindowText(m_hWnd, NULL);
			return TRUE;
		}
		else
			m_pTxt2++;
	}
  m_pTxt2 = m_pTxt1; // failed to find separator
	return FALSE;
}

void CToggleTextControlHelper::SetToggleState(BOOL bFirst)
{
  ASSERT(::IsWindow(m_hWnd));
	::SetWindowText(m_hWnd, bFirst ? m_pTxt1 : m_pTxt2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\dscsetup\doinst.h ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		doinst.h
//
//  History:	Aug. 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------


#define		STR_DSCLIENT_INF		        TEXT("dsclient.inf")

#define   STR_INSTALL_SECTIONNT4      TEXT("DSClientNT4")

#define		STR_DSCLIENTINF_REGISTEROCX	TEXT("DsClient.inf,RegisterOCXsection,1,N")
#define   STR_INSTSEC_DLL             TEXT("instsec.dll")
#define   STR_SECUR32_DLL             TEXT("secur32.dll")
#define   STR_GETENCSCHANNEL          "GetEncSChannel"

// define for the custom registry action after dscleint.inf by Chandana Surlu 
#define		SECURITY_PROVIDERS_KEY		  TEXT("System\\CurrentControlSet\\Control\\SecurityProviders")
#define		SECURITY_PROVIDERS_VALUE	  TEXT("SecurityProviders")
#define		COMMA_BLANK					        TEXT(", ")
#define		NEGOTIAT					          TEXT("negotiat.dll")

#define   RUNONCE_KEY                 TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define   REG_DSUI_VALUE              TEXT("RegisterDSUI")
#define   REG_WABINST_VALUE           TEXT("RunWABINST")
#define   REG_DSPROP_VALUE            TEXT("RegisterDSPROP")

#define   STR_REGISTER_REGSVR32_SI_EXE   TEXT("\\regsvr32.exe /s /i ")
#define   STR_REGISTER_REGSVR32_S_EXE TEXT("\\regsvr32.exe /s ")
#define   STR_RUN_WABINST_EXE         TEXT("\\wabinst.exe /q /r:n")
#define   STR_REGISTER_DSFOLDER_DLL   TEXT("\\dsfolder.dll")
#define   STR_REGISTER_DSQUERY_DLL    TEXT("\\dsquery.dll")
#define   STR_REGISTER_DSUIEXT_DLL    TEXT("\\dsuiext.dll")
#define   STR_REGISTER_CMNQUERY_DLL   TEXT("\\cmnquery.dll")
#define   STR_REGISTER_DSPROP_DLL     TEXT("\\dsprop.dll")



INT  LaunchINFInstall( HWND hWnd );

VOID CALLBACK Timer1Proc(HWND hwnd,  
                         UINT uMsg,  
                         UINT idEvent, 
                         DWORD dwTime);

UINT CALLBACK QueueCallbackProc(PVOID	    pDefaultContext,
								UINT	    Notification,
								UINT_PTR	Param1,
								UINT_PTR	Param2);

VOID InstallFinish(BOOL nShow);
BOOL LaunchProcess(LPTSTR lpCommandLine);
BOOL RegisterOCX();
VOID DoDsclientReg();
BOOL DoEncSChannel();


// encrypted schannel installer
typedef BOOL (__cdecl *FPGETENCSCHANNEL)(BYTE**, DWORD*);
//BOOL __cdecl GetEncSChannel(BYTE **pData, DWORD *dwDecSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\dscsetup\dscsetup.cpp ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		dscsetup.cpp
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------


#include <windows.h>
#include <prsht.h>
#include <setupapi.h>
#include <tchar.h>
#include <stdlib.h>
#include "resource.h"
#include "dscsetup.h"
#include "wizard.h"

#include "doinst.h"


SInstallVariables	g_sInstVar;


// DllMain Entry 
BOOL APIENTRY DllMain( HINSTANCE hInstance, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


// This is an exported function.
DWORD WINAPI DoDscSetup(LPCSTR lpCmdLine)
{
	// initialize the variables of installation
	InitVariables();

	ParseCmdline(const_cast<PSTR>(lpCmdLine));

  //
  // Go through setup if we are installing with anything but
  // the /a flag
  //
  if (g_sInstVar.m_bSysDlls || g_sInstVar.m_bWabInst)
  {
	  // create objects
	  if(!CreateObjects())
          return SETUP_ERROR;

	  // Launch setup wizard
	  if(!DSCSetupWizard()) 
	  {
		  TCHAR		szMessage[MAX_MESSAGE + 1]; 
		  TCHAR		szTitle[MAX_TITLE + 1]; 

		  LoadString(g_sInstVar.m_hInstance, 
                     IDS_ERROR_WIZARD,
                     szMessage, 
                     MAX_MESSAGE);
		  LoadString(g_sInstVar.m_hInstance, 
                     IDS_ERROR_TITLE, 
                     szTitle, 
                     MAX_TITLE);

		  // display a error message - Failure to load Setup Wizard
		  MessageBox(NULL,	
					  szMessage,	// address of text in message box
					  szTitle,	// address of title of message box  
					  MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box

		  g_sInstVar.m_nSetupResult = SETUP_ERROR;
	  }

	  // destroy objects
	  DestroyObjects();

	  if(g_sInstVar.m_nSetupResult == SETUP_SUCCESS &&
             !g_sInstVar.m_bQuietMode
#ifdef MERRILL_LYNCH
             && !g_sInstVar.m_bNoReboot
#endif
             )
	  {
		  // prompt reboot
		  SetupPromptReboot(NULL,		// optional, handle to a file queue
						  NULL,          // parent window of this dialog box
						  FALSE);        // optional, do not prompt user);
	  }
     else if(g_sInstVar.m_nSetupResult == SETUP_SUCCESS &&
             g_sInstVar.m_bQuietMode 
#ifdef MERRILL_LYNCH
             && !g_sInstVar.m_bNoReboot
#endif
             )
     {
         HANDLE htoken = INVALID_HANDLE_VALUE;

         do
         {
            // twiddle our process privileges to enable SE_SHUTDOWN_NAME
            HRESULT hr = OpenProcessToken(GetCurrentProcess(),
                                          TOKEN_ADJUST_PRIVILEGES,
                                          &htoken);
            if (FAILED(hr))
            {
               break;
            }

            LUID luid;
            memset(&luid, 0, sizeof(luid));
            hr = LookupPrivilegeValue(0, SE_SHUTDOWN_NAME, &luid);
            if (FAILED(hr))
            {
               break;
            }

            TOKEN_PRIVILEGES privs;
            memset(&privs, 0, sizeof(privs));
            privs.PrivilegeCount = 1;
            privs.Privileges[0].Luid = luid;
            privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            hr = AdjustTokenPrivileges(htoken, 0, &privs, 0, 0, 0);
            if (FAILED(hr))
            {
               break;
            }

            hr = ExitWindowsEx(EWX_REBOOT, 0);
            if (FAILED(hr))
            {
               break;
            }
         }
         while (0);

         if (htoken != INVALID_HANDLE_VALUE)
         {
            CloseHandle(htoken);
         }

     }
  }
  else
  {
    //
    // Setup was run with the /a flag.  This means we
    // don't want to show the UI and let the adsix86.inf
    // handle the install for us
    //
    if (!LaunchProcess(STR_INSTALL_ADSIWREMOVE))
    {
      g_sInstVar.m_nSetupResult = SETUP_ERROR;
    }
  }
	return g_sInstVar.m_nSetupResult;
}


VOID ParseCmdline(LPSTR lpCmdLine)
{
  PCTSTR ptszTok = _tcstok(lpCmdLine, _T(" "));
  do
  {
    if (ptszTok != NULL)
    {
      if (_tcsicmp(ptszTok, _T("/q")) == 0)
      {
        g_sInstVar.m_bQuietMode = TRUE;
      }

      if (_tcsicmp(ptszTok, _T("/a")) == 0)
      {
        g_sInstVar.m_bWabInst = FALSE;
        g_sInstVar.m_bSysDlls = FALSE;
      }

      if (_tcsicmp(ptszTok, _T("/d")) == 0)
      {
        g_sInstVar.m_bWabInst = FALSE;
      }
#ifdef MERRILL_LYNCH
      if (_tcsicmp(ptszTok, _T("/n")) == 0)
      {
        g_sInstVar.m_bNoReboot = TRUE;
      }
#endif
    }
    ptszTok = _tcstok(NULL, _T(" "));
  } while (ptszTok != NULL);
}


// initialize the variables of installation
VOID InitVariables()
{
	g_sInstVar.m_hInstance = GetModuleHandle(STR_DLL_NAME);
  g_sInstVar.m_hInstallThread = NULL;
	g_sInstVar.m_uTimerID = 0;
  g_sInstVar.m_hBigBoldFont = NULL;
	g_sInstVar.m_hProgress = NULL;
	g_sInstVar.m_hFileNameItem = NULL;

  g_sInstVar.m_bDCOMInstalled = FALSE;

	g_sInstVar.m_bQuietMode = FALSE;
  g_sInstVar.m_bWabInst = TRUE;
  g_sInstVar.m_bSysDlls = TRUE;
#ifdef MERRILL_LYNCH
  g_sInstVar.m_bNoReboot = FALSE;
#endif
	g_sInstVar.m_nSetupResult = SETUP_SUCCESS;

  // get source path
  GetModuleFileName(g_sInstVar.m_hInstance,
                    g_sInstVar.m_szSourcePath, 
                    MAX_PATH);
  *(_tcsrchr(g_sInstVar.m_szSourcePath, CHAR_BACKSLASH) + 1) = TEXT('\0');       // Strip setup.exe off path
}

// start setup wizard
BOOL DSCSetupWizard()
{
	PROPSHEETHEADER psh;
	PROPSHEETPAGE	psPage[SIZE_WIZARD_PAGE];
	int  i = 0;

	//
	// Setup the Welcome page
	//
    i=0;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | PSP_HIDEHEADER;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_WELCOME);
	psPage[i].pfnDlgProc = (DLGPROC) WelcomeDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);

/* ntbug#337931: remove license page
    //
	// Setup the License Page
	//
    i++;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | 
                        PSP_USEHEADERTITLE | 
                        PSP_USEHEADERSUBTITLE;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_LICENSE);
	psPage[i].pfnDlgProc = (DLGPROC) LicenseDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);
	psPage[i].pszHeaderTitle = MAKEINTRESOURCE(IDS_HEADERTITLE_LICENSE);
	psPage[i].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_HEADERSUBTITLE_LICENSE);
*/
	//
	// Setup the Select Page
	//
    i++;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | 
                        PSP_USEHEADERTITLE |
                        PSP_USEHEADERSUBTITLE;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_CONFIRM);
	psPage[i].pfnDlgProc = (DLGPROC) ConfirmDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);
	psPage[i].pszHeaderTitle = MAKEINTRESOURCE(IDS_HEADERTITLE_CONFIRM);
	psPage[i].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_HEADERSUBTITLE_CONFIRM);

	//
	// Setup the Confirm Page
	//
    i++;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | 
                        PSP_USEHEADERTITLE | 
                        PSP_USEHEADERSUBTITLE;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_INSTALL);
	psPage[i].pfnDlgProc = (DLGPROC) InstallDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);
	psPage[i].pszHeaderTitle = MAKEINTRESOURCE(IDS_HEADERTITLE_INSTALL);
	psPage[i].pszHeaderSubTitle = MAKEINTRESOURCE(IDS_HEADERSUBTITLE_INSTALL);

	//
	// Setup the Completion page
	//
    i++;
	ZeroMemory(&psPage[i],sizeof(PROPSHEETPAGE));
	psPage[i].dwSize = sizeof(PROPSHEETPAGE);
	psPage[i].dwFlags = PSP_USETITLE | PSP_HIDEHEADER;
	psPage[i].hInstance = g_sInstVar.m_hInstance;
	psPage[i].pszTemplate = MAKEINTRESOURCE(IDD_COMPLETION);
	psPage[i].pfnDlgProc = (DLGPROC) CompletionDialogProc;
	psPage[i].lParam = (LPARAM) 0;
	psPage[i].pszTitle = MAKEINTRESOURCE(IDS_WIZARD_TITLE);

	//
	// Setup the wizard
	//
	ZeroMemory(&psh,sizeof(PROPSHEETHEADER));
	psh.dwSize = sizeof(PROPSHEETHEADER);
	// Windows 98 with 16 color display mode crashes when PSH_STRETCHWATERMARK flag is on.
	psh.dwFlags = PSH_USEICONID | 
                  PSH_PROPSHEETPAGE | 
                  PSH_WIZARD97 |
                  PSH_WATERMARK |
                  PSH_HEADER; // | PSH_STRETCHWATERMARK;
	psh.pszIcon = MAKEINTRESOURCE(IDI_ICON_APP);
	psh.hInstance = g_sInstVar.m_hInstance;
	psh.pszCaption = MAKEINTRESOURCE(IDS_WIZARD_TITLE);;
	psh.nStartPage = 0;
	psh.nPages = SIZE_WIZARD_PAGE;
	psh.ppsp = (LPCPROPSHEETPAGE) &psPage;

	//
	// Run the wizard
	//
	if(g_sInstVar.m_bQuietMode)
    {
        if(!CheckDiskSpace())
            return FALSE;

        psh.nStartPage = 2;
    }
	else
		psh.nStartPage = 0;

	if( PropertySheet(&psh) < 0 )	// failure to load wizard
	{
		return FALSE;
	}

	//
	// Because SetWindowLongPtr(hWnd, DWL_MSGRESULT, IDD_COMPLETION) 
    // doesn't work on Win95 (when users click Cancel, the wizard can't
    // be routed to the Completion page), I added the following code to
    // open the Completion page
	//
	if(!g_sInstVar.m_bQuietMode)
	{
		psh.nStartPage = 3;
		if( PropertySheet(&psh) < 0 )	// failure to load wizard
		{
			return FALSE;
		}
	}
	
	return TRUE;
}


// check for DCOM installed
void CheckDCOMInstalled()
{
	HKEY		hSubKey;

	// check if IE 4.0 has been installed
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, 
									  STR_DCOM_REGKEY, 
									  0, 
									  KEY_READ, 
									  &hSubKey)	)
	{
        g_sInstVar.m_bDCOMInstalled = TRUE;
		RegCloseKey(hSubKey);
	}
}

//  gets Disk Free space
DWORD64 SetupGetDiskFreeSpace()
{
    DWORD		dwSectorsPerCluster;
    DWORD		dwBytesPerSector;
    DWORD		dwNumberOfFreeClusters;
    DWORD		dwTotalNumberOfClusters;
    DWORD64  	d64FreeSpace = 0;
    TCHAR		szPathName[MAX_PATH + 1];	        // address of root path 

	if(GetSystemDirectory(szPathName,  // address of buffer for system directory
						  MAX_PATH))       // size of directory buffer);
	{
		if ( szPathName[1] == TEXT(':'))
		{
			// this is a drive letter
			// assume it is of for d:backslash
			szPathName[3] = TEXT('\0');		

			//get free space, GetDiskFreeSpaceEx() don't support in older Win95
			if (GetDiskFreeSpace(szPathName,	        // address of root path 
								 &dwSectorsPerCluster,	    // address of sectors per cluster 
								 &dwBytesPerSector,	        // address of bytes per sector 
								 &dwNumberOfFreeClusters,	// address of number of free clusters  
								 &dwTotalNumberOfClusters)) // address of total number of clusters  
			{
				// calc total  size
				d64FreeSpace = DWORD64(dwSectorsPerCluster)
							  * dwBytesPerSector
							  * dwNumberOfFreeClusters;
			}
		}
	}

	return d64FreeSpace;
}

// check if DSClient has been installed
BOOL CheckDSClientInstalled()
{
	HKEY	hSubKey;
	BOOL	bResult = FALSE;

	// open reg key of DS Client
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
									  STR_DSCLIENT_REGKEY,
									  0, 
									  KEY_ALL_ACCESS, 
									  &hSubKey)	) 
	{
		bResult = TRUE;		
		RegCloseKey(hSubKey);
	}

	return bResult;
}

/* ntbug#337931: remove license page
//  load "License Agreement" text from license file 
BOOL LoadLicenseFile(HWND hDlg)
{
	BOOL    bReturn = FALSE;
	TCHAR	szTitle[MAX_TITLE + 1];
	TCHAR	szTempBuffer[MAX_MESSAGE + 1];
	TCHAR	szLicenseFile[MAX_PATH + 1];
	TCHAR	szReturnTextBuffer[MAX_MESSAGE + 1]; 
    LPTSTR	lpszLicenseText = NULL;
    HANDLE	hFile;
    DWORD	dwNumberOfBytesRead, dwFileSize;

    //
    // Determine where we are installing from
    // and specific the license file there
    //
	lstrcpy(szLicenseFile, g_sInstVar.m_szSourcePath);
	lstrcat(szLicenseFile, STR_LICENSEFILE);	
	
    // Open License file
    hFile = CreateFile(szLicenseFile,       // pointer to name of the file 
                       GENERIC_READ,          // access (read-write) mode 
                       FILE_SHARE_READ,       // share mode 
                       NULL,                  // pointer to security descriptor 
                       OPEN_EXISTING,         // how to create 
                       FILE_ATTRIBUTE_NORMAL, // file attributes 
                       NULL);                 // handle to file with attributes to copy  

    if(INVALID_HANDLE_VALUE != hFile)
    {                
	
		// Read License file into string
		// setup memory, get file size in bytes
		dwFileSize = GetFileSize (hFile, NULL) ;

		if (dwFileSize != 0xFFFFFFFF) 
		{ 		
            // this program is for Win98/95, it will work in MBCS not UNICODE
            // this code is for ANSI US version, license.txt file uses the single byte character set(ANSI)
            // if doing locolization, license.txt file should use the double byte character set(DBCS/MBCS)
			lpszLicenseText = (LPTSTR) calloc (dwFileSize + sizeof(TCHAR), 
                                               sizeof(BYTE));
		}

		if(lpszLicenseText)
		{
			//read file
			if (ReadFile(hFile,    	// handle of file to read 
						  lpszLicenseText,    // address of buffer that receives data  
						  dwFileSize,    	// number of bytes to read 
						  &dwNumberOfBytesRead,    // address of number of bytes read 
						  NULL))                // address of structure for data 
			{
				// display license on dialog
				SetDlgItemText(hDlg, IDC_LICENSE_TEXT, lpszLicenseText);

				bReturn = TRUE;
			}

			// so free the memory
			free(lpszLicenseText);
		}

		//close file handle
		CloseHandle(hFile);
 	}
	
	if(!bReturn)
	{
		// load string
		LoadString(g_sInstVar.m_hInstance, 
                   IDS_ERROR_TITLE,
                   szTitle, 
                   MAX_TITLE);
		LoadString(g_sInstVar.m_hInstance, 
                   IDS_ERROR_LICENSEFILE, 
                   szTempBuffer, 
                   MAX_MESSAGE);
		wsprintf(szReturnTextBuffer, 
                 TEXT("%s %s"), 
                 szTempBuffer,
                 szLicenseFile);

		MessageBox(hDlg, 
			szReturnTextBuffer,
			szTitle, 
			MB_OK | MB_TOPMOST | MB_ICONERROR);
	}
      
    return bReturn;
}
*/

// check disk space
BOOL CheckDiskSpace()
{
	BOOL  bResult = TRUE;
	TCHAR  szString[MAX_MESSAGE + MAX_TITLE + 1];
	TCHAR  szTitle[MAX_TITLE + 1];
	TCHAR  szMessage[MAX_MESSAGE + 1];

	if(SIZE_TOTAL*MB_TO_BYTE > SetupGetDiskFreeSpace())
	{
		// load string
		LoadString(g_sInstVar.m_hInstance, 
                   IDS_ERROR_NODISKSPACE, 
                   szMessage, 
                   MAX_MESSAGE);
		LoadString(g_sInstVar.m_hInstance, 
                   IDS_ERROR_TITLE, 
                   szTitle, 
                   MAX_TITLE);
		wsprintf(szString,
                 TEXT("%s %d MB."), 
                 szMessage, 
                 SIZE_TOTAL); 
            
		MessageBox(NULL,
				szString,
				szTitle, 
				MB_OK | MB_TOPMOST | MB_ICONERROR);

		bResult = FALSE;
	}

	return bResult;
}

// create objects
BOOL CreateObjects()
{
    try
    {
        // initialize the synchronizing object
        InitializeCriticalSection(&g_sInstVar.m_oCriticalSection);
    }
    catch(...)
    {
        return FALSE;
    }

    // create a 12 pt big font
    CreateBigFont();

    return TRUE;
}

// destroy objects
VOID DestroyObjects()
{
    // wait to finish the runing setup process
    if(g_sInstVar.m_hInstallThread)
    {
        // wait the installation thread to finish
	    WaitForSingleObject(g_sInstVar.m_hInstallThread,INFINITE);
   		CloseHandle(g_sInstVar.m_hInstallThread);
    }

   	// delete the synchronizing object
	DeleteCriticalSection(&g_sInstVar.m_oCriticalSection);

    //Frees up the space used by loading the fonts
    if( g_sInstVar.m_hBigBoldFont ) 
	{
        DeleteObject( g_sInstVar.m_hBigBoldFont );
    }

}

//create a big font for dialog title
VOID CreateBigFont()
{
    NONCLIENTMETRICS ncm;
    LOGFONT BigBoldLogFont;
    HDC hdc;

    // Create the fonts we need based on the dialog font
	ZeroMemory(&ncm,sizeof(NONCLIENTMETRICS));
    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	BigBoldLogFont = ncm.lfMessageFont;
    BigBoldLogFont.lfWeight = FW_BOLD;

	hdc = GetDC(NULL);
    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - 
                                  (GetDeviceCaps(hdc,LOGPIXELSY) * 
                                   SIZE_TITLE_FONT / 
                                   72);

        g_sInstVar.m_hBigBoldFont = CreateFontIndirect(&BigBoldLogFont);

        ReleaseDC(NULL,hdc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\dscsetup\doinst.cpp ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		doinst.cpp
//
//  History:	Aug. 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------


#include <windows.h>
#include <setupapi.h>
#include <advpub.h>
#include "resource.h"
#include "dscsetup.h"	
#include "wizard.h"
#include "doinst.h"    


extern	SInstallVariables	g_sInstVar;


// do installation
DWORD DoInstallation(HWND hWnd)
{
  if(g_sInstVar.m_nSetupResult == SETUP_SUCCESS)
  {
    // set the fake progressbar for DCOM and WAB nstall
    g_sInstVar.m_uTimerID = SetTimer(hWnd,
                                     1,
                                     1000,  // 1 seconds
                                     Timer1Proc);

    // do the custom action of NTLMv2
    if(!DoEncSChannel())
    	    g_sInstVar.m_nSetupResult = SETUP_ERROR;

    // stop the fake progressbar
    if(g_sInstVar.m_uTimerID)
        KillTimer(hWnd, g_sInstVar.m_uTimerID);

    // install adsi
    if (!LaunchProcess(STR_INSTALL_ADSI))
    {
      g_sInstVar.m_nSetupResult = SETUP_ERROR;
    }

   	// install dsclient
    if(g_sInstVar.m_nSetupResult == SETUP_SUCCESS)
	    g_sInstVar.m_nSetupResult = LaunchINFInstall(hWnd);

  }

	return g_sInstVar.m_nSetupResult;
}


VOID CALLBACK Timer1Proc(HWND hwnd,     // handle of window for timer messages
                         UINT uMsg,     // WM_TIMER message
                         UINT idEvent,  // timer identifier
                         DWORD dwTime)   // current system time
{
    static int nCount = 0;

    if(nCount > 100)
        nCount = 100;

    // set the fake progressbar 
	SendMessage (g_sInstVar.m_hProgress, PBM_SETPOS, (WPARAM) nCount, 0); 
    
    nCount ++;
}
 

// This routine will do an installation based on those settings 
// using the setupapi.dll
INT LaunchINFInstall( HWND hWnd )
{
  TCHAR	szInfFileName[MAX_PATH + 1];
	TCHAR	szInstallSection[MAX_TITLE];
  BOOL	bResult = FALSE;

  // Context for my call back routine
  HSPFILEQ		hFileQueue;
  HINF			hInf;
	PVOID			pDefaultContext;
 
	//
  // Get inf handle
  // must know where the inf is located 
  // SetupOpenInfFile will only look in windows\inf by default
  //
	lstrcpy(szInfFileName, g_sInstVar.m_szSourcePath);
  lstrcat(szInfFileName, STR_DSCLIENT_INF);

  hInf = SetupOpenInfFile(szInfFileName,   // If path,needs full path, else looks in %windir%\inf
						NULL,            // Inf Type, matches Class in [Version] section SetupClass=SAMPLE
						INF_STYLE_WIN4,  // or INF_STYLE_OLDNT
						NULL);           // Line where error occurs if inf is has a problem
						
  if (hInf == INVALID_HANDLE_VALUE) 
	  return SETUP_ERROR;
		
  //
  // Create a Setup file queue and initialize the default Setup
  // queue callback routine.
  //
  hFileQueue = SetupOpenFileQueue();

  if(hFileQueue == INVALID_HANDLE_VALUE) 
	{
		SetupCloseInfFile(hInf);
    return SETUP_ERROR;
	}
    
    // using SetupInitDefaultQueueCallback.    
	SendMessage (g_sInstVar.m_hProgress, PBM_SETPOS, (WPARAM) 0, 0);	
	pDefaultContext = SetupInitDefaultQueueCallbackEx(hWnd,  // HWND of owner window
													NULL,  // HWND of alternate progress dialog which receives 
													0,     // Message sent to above window indicating a progress message
													0,     // DWORD Reserved
													NULL);   // PVOID Reserved
																	
  if(!pDefaultContext)
  {
      // Close the queue and the inf file and return
      SetupCloseFileQueue(hFileQueue);
      SetupCloseInfFile(hInf);
      return SETUP_ERROR;
  }

  lstrcpy (szInstallSection, STR_INSTALL_SECTIONNT4);
	//
  // Queue file operations and commit the queue.
  //
	bResult = SetupInstallFilesFromInfSection(hInf,			// HINF that has the directory ids set above
											  NULL,          // layout.inf if you have one, this a convient
											  hFileQueue,     // Queue to add files to
											  szInstallSection,   // SectionName,
											  g_sInstVar.m_szSourcePath,    // Path where the source files are located
											  SP_COPY_NEWER );
	//
  // All the files for each component are now in one queue
  // now we commit it to start the copy ui, this way the
  // user has one long copy progress dialog--and for a big install
  // can go get the cup of coffee 
	if(bResult)
		bResult = SetupCommitFileQueue(hWnd,                    // Owner
										hFileQueue,             // Queue with the file list
										QueueCallbackProc,		// This is our handler, it calls the default for us
										pDefaultContext);       // Pointer to resources allocated with SetupInitDefaultQueueCallback/Ex                 
		
	if (!bResult || (g_sInstVar.m_nSetupResult == SETUP_CANCEL))
	{
		SetupTermDefaultQueueCallback(pDefaultContext);
    SetupCloseFileQueue(hFileQueue);
    SetupCloseInfFile(hInf);

		if(g_sInstVar.m_nSetupResult == SETUP_CANCEL)
			return SETUP_CANCEL;
		else
			return SETUP_ERROR;
	}

  //
  // NOTE: you can do the entire install
  // for a section with this api but in this case
  // we build the file list conditionally and
  // do only out ProductInstall section for registy stuff
  // Also using SPINST_FILES will do the files
  // as above but only one section at a time
  // so the progress bar would keep completing and starting over
  // SPINST_ALL does files, registry and inis
  // 
	bResult = SetupInstallFromInfSection(hWnd,
										hInf,
										szInstallSection,
										SPINST_INIFILES | SPINST_REGISTRY,
										HKEY_LOCAL_MACHINE,
										NULL,	//m_szSourcePath,    // Path where the source files are located
										0,		//SP_COPY_NEWER,
										NULL,	//(PSP_FILE_CALLBACK) QueueCallbackProc, 
										NULL,	//&MyInstallData,
										NULL, 
										NULL);

	//
  // We're done so free the context, close the queue,
  // and release the inf handle
  //
	SetupTermDefaultQueueCallback(pDefaultContext);
  SetupCloseFileQueue(hFileQueue);
  SetupCloseInfFile(hInf);
    	    
  if (g_sInstVar.m_bSysDlls)
  {
    //
 	  // register OCX file
    //
    if(!RegisterOCX())
    {
		  return SETUP_ERROR;
    }
  }

  //
	// The custom registry action after dsclient.inf by Chandana Surlu 
  //
	DoDsclientReg();

	SendMessage (g_sInstVar.m_hProgress, PBM_SETPOS, (WPARAM) 100, 0);
  InstallFinish(FALSE);

  return SETUP_SUCCESS;
}

/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
UINT CALLBACK QueueCallbackProc(PVOID   	pDefaultContext,
								UINT	    Notification,
								UINT_PTR	Param1,
								UINT_PTR	Param2)
{
	static INT	snFilesCopied;

	// synchronizing user cancel
	EnterCriticalSection(&g_sInstVar.m_oCriticalSection);
	LeaveCriticalSection(&g_sInstVar.m_oCriticalSection);

	//instaniate dialog first time
    if (g_sInstVar.m_nSetupResult == SETUP_CANCEL)
	{
		SetLastError (ERROR_CANCELLED);
		return FILEOP_ABORT;
	}

    switch (Notification)
    {
	case SPFILENOTIFY_STARTQUEUE:
	case SPFILENOTIFY_ENDQUEUE:
		
		return FILEOP_DOIT;

    case SPFILENOTIFY_STARTCOPY:
	
		// update file name item  
		SetWindowText(g_sInstVar.m_hFileNameItem, 
                      ((PFILEPATHS) Param1)->Target);
		break;

	case SPFILENOTIFY_ENDCOPY:
		
		snFilesCopied++;

		// update dialog file progress with message
		if ((snFilesCopied + 1)>= NUM_FILES_TOTAL)
		{
			SendMessage (g_sInstVar.m_hProgress, 
                         PBM_SETPOS, 
                         (WPARAM) 100,
                         0); 	
		}
		else
		{
			SendMessage (g_sInstVar.m_hProgress, 
                         PBM_SETPOS, 
                         (WPARAM) ((float)snFilesCopied / 
                                (float)NUM_FILES_TOTAL * 100), 
                         0); 
		}

		break;		

 	default:
		break;
	}

	return SetupDefaultQueueCallback(pDefaultContext, 
                                     Notification, 
									 Param1, 
									 Param2);
}

VOID InstallFinish(BOOL nShow)
{
	if(nShow)
		WinExec("grpconv -o", SW_SHOWNORMAL);
	else
		WinExec("grpconv -o", SW_HIDE);	  
}


// launch Inf file to install this component
BOOL LaunchProcess(LPTSTR lpCommandLine)
{
	BOOL bResult = FALSE;

	STARTUPINFO				si;
	PROCESS_INFORMATION		pi;

	// its console window will be invisible to the user.
	ZeroMemory(&pi,sizeof(PROCESS_INFORMATION));
	ZeroMemory(&si,sizeof(STARTUPINFO));
	si.cb			= sizeof (STARTUPINFO);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;            // HideWindow

  if(CreateProcess(	NULL,					
						lpCommandLine,			
						NULL,					
						NULL,					
						FALSE,				
						0,					
						NULL,				
						NULL,				
						&si,                
						&pi ) )             
	{
		// wait to finish the runing setup process
		WaitForSingleObject(pi.hProcess,INFINITE);
	
		// close process handle
		if (pi.hProcess && pi.hProcess != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hProcess) ;
		}
		if (pi.hThread && pi.hThread != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hThread) ;
		}

		bResult = TRUE;
	}

	return bResult;
}

// register OCX file
BOOL RegisterOCX()
{
  TCHAR  szSystem[MAX_PATH + 1];
  TCHAR  szTemp[MAX_PATH + 1];
  TCHAR  szCmdline[MAX_PATH + 1];
  BOOL  bSuccess = TRUE;

  if(!GetSystemDirectory(szSystem, MAX_PATH))
      return FALSE;

  wsprintf(szTemp, 
          TEXT("%s%s%s"),
          szSystem,
          STR_REGISTER_REGSVR32_S_EXE,
          szSystem);

  //
  // REVIEW_JEFFJON : we are not going to register it here
  //                  Instead we are going to set the RunOnce regkey
  //                  to register the dlls on reboot
  //

  if (g_sInstVar.m_bWabInst)
  {
    // register dsfolder.dll
    wsprintf(szCmdline, 
            TEXT("%s%s %s%s %s%s %s%s %s%s"),
            szTemp,
            STR_REGISTER_DSFOLDER_DLL,
            szSystem,
            STR_REGISTER_DSUIEXT_DLL,
            szSystem,
            STR_REGISTER_DSQUERY_DLL,
            szSystem,
            STR_REGISTER_CMNQUERY_DLL,
            szSystem,
            STR_REGISTER_DSPROP_DLL);

    ULONG WinError = 0;
    HKEY RunOnceKey = NULL;
    ULONG Size = 0;
	  ULONG Type = REG_SZ;
    DWORD dwDisp = 0;

	  // open reg key
    WinError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
							                RUNONCE_KEY,
							                0,
							                NULL,
							                REG_OPTION_NON_VOLATILE,
							                KEY_ALL_ACCESS,
							                NULL,
							                &RunOnceKey,
							                &dwDisp);

    if (WinError == ERROR_SUCCESS)
    {
  	  UINT BufferSize = strlen(szCmdline);
  	  BufferSize++;
		  WinError = RegSetValueEx( RunOnceKey,
								                REG_DSUI_VALUE,
								                0,
								                Type,
								                (PUCHAR)szCmdline,
								                BufferSize);
      if (WinError != ERROR_SUCCESS && bSuccess)
      {
        bSuccess = FALSE;
      }

      //
      // Run wabinst.exe
      //
      wsprintf(szCmdline,
               TEXT("%s%s"),
               szSystem,
               STR_RUN_WABINST_EXE);
      if (!LaunchProcess(szCmdline))
      {
        bSuccess = FALSE;
      }
    }
    else
    {
      bSuccess = FALSE;
    }

    if (RunOnceKey)
    {
        RegCloseKey(RunOnceKey);
    }
  }

  return bSuccess;
}        



// The custom registry action after dsclient.inf by Chandana Surlu 
VOID DoDsclientReg()
{
  ULONG WinError = 0;
  HKEY ProvidersKey = NULL;
  ULONG Size = 0;
	ULONG Type;
	ULONG BufferSize = 0;
  LPSTR StringToBeWritten = NULL;
  DWORD dwDisp;
	BOOL  bSuccess = FALSE;

	// open reg key
  WinError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
						SECURITY_PROVIDERS_KEY,
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&ProvidersKey,
						&dwDisp);

  if (WinError != ERROR_SUCCESS)
  {
    if (WinError == ERROR_FILE_NOT_FOUND)
    {
      BufferSize = sizeof(NEGOTIAT);
      StringToBeWritten= (LPSTR) LocalAlloc(0,BufferSize);
      if (StringToBeWritten)
			{
				strcpy (StringToBeWritten, NEGOTIAT);

				bSuccess = TRUE;
			}
		}
  }
  else
  {
    WinError = RegQueryValueEx(ProvidersKey,
								 SECURITY_PROVIDERS_VALUE,
								 0,
								 &Type,
								 NULL,
								 &Size);

    if ( WinError == ERROR_SUCCESS) 
    {
      BufferSize = Size + sizeof(COMMA_BLANK) + sizeof(NEGOTIAT);
      StringToBeWritten= (LPSTR) LocalAlloc(0,BufferSize);
      
	    if (StringToBeWritten) 
	    {
	      WinError = RegQueryValueEx(ProvidersKey,
								SECURITY_PROVIDERS_VALUE,
								0,
								&Type,
								(PUCHAR) StringToBeWritten,
								&Size);

				if ( WinError == ERROR_SUCCESS) 
				{
          if (NULL == strstr(StringToBeWritten, NEGOTIAT))
          {
					  strcat (StringToBeWritten, COMMA_BLANK);
					  strcat (StringToBeWritten, NEGOTIAT);

					  bSuccess = TRUE;
          }
				}
			}
    }
    else if (WinError == ERROR_FILE_NOT_FOUND)
    {
      BufferSize = sizeof(NEGOTIAT) + sizeof(CHAR);
      StringToBeWritten= (LPSTR) LocalAlloc(0,BufferSize);
      if (StringToBeWritten) 
			{
				strcpy (StringToBeWritten, NEGOTIAT);
				Type = REG_SZ;

				bSuccess = TRUE;
			}
    }
  }

	if(bSuccess)
	{
		BufferSize = strlen(StringToBeWritten);
		BufferSize++;
		WinError = RegSetValueEx( ProvidersKey,
								  SECURITY_PROVIDERS_VALUE,
								  0,
								  Type,
								  (PUCHAR)StringToBeWritten,
								  BufferSize);
	}

  if (ProvidersKey)
  {
    RegCloseKey(ProvidersKey);
  }
  if (StringToBeWritten)
  {
    LocalFree(StringToBeWritten);
  }
}

// The NTLMv2 custom action before dsclient.inf installation.
// Calling encrypted schannel installer to create dynamically a 128 bit secur32.dll
// to replace the old 56 bit secur32.dll. 
BOOL DoEncSChannel()
{
    FPGETENCSCHANNEL fpEncSChannel;
    HINSTANCE  hInst;
    BYTE*  pFileData;
    DWORD  dwSize = 0;
    HANDLE hFile;
    DWORD  dwWritten;
    BOOL   bRet;

    // load "instsec.dll" 
    hInst = LoadLibrary(STR_INSTSEC_DLL); 
    if(!hInst) 
        return TRUE;

    // get the pointer of function "GetEncSChannel"
    fpEncSChannel = (FPGETENCSCHANNEL) GetProcAddress(hInst, STR_GETENCSCHANNEL);

    // calling GetEncSChannel to get the file data
    if( !fpEncSChannel ||
        fpEncSChannel(&pFileData, &dwSize) == FALSE ||
        dwSize == 0)
    {
        FreeLibrary( hInst );
        return TRUE;
    }

    // create file - "secur32.dll"
    hFile = CreateFile(
        STR_SECUR32_DLL,        // pointer to name of the file "secur32.dll"
        GENERIC_WRITE,          // access (read-write) mode
        0,                      // share mode
        NULL,                   // pointer to security attributes
        CREATE_ALWAYS,          // how to create
        FILE_ATTRIBUTE_NORMAL,  // file attributes
        NULL                    // handle to file with attributes to copy
        );

    if(hFile == INVALID_HANDLE_VALUE)
    {
        VirtualFree(pFileData, 0, MEM_RELEASE);
        FreeLibrary( hInst );
        return FALSE;
    }

    // write the file data to file "secur32.dll"
    bRet = WriteFile(
        hFile,              // handle to file to write to
        pFileData,          // pointer to data to write to file
        dwSize,             // number of bytes to write
        &dwWritten,         // pointer to number of bytes written
        NULL                // pointer to structure for overlapped I/O
        );

    if(bRet && dwSize != dwWritten)
        bRet = FALSE;

    // clean memory
    VirtualFree(pFileData, 0, MEM_RELEASE);
    CloseHandle( hFile );
    FreeLibrary( hInst );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\dscsetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_SETUP_SUCCESS_TITLE         1
#define IDS_SETUP_SUCCESS               2
#define IDS_SETUP_CANCEL_TITLE          3
#define IDS_SETUP_CANCEL                4
#define IDS_SETUP_ERROR_TITLE           5
#define IDS_SETUP_ERROR                 6
#define IDS_CANCEL_TITLE                7
#define IDS_CANCEL_MSG                  8
#define IDS_ERROR_TITLE                 9
#define IDS_ERROR_WIN98SP1_MESSAGE      12
#define IDS_ERROR_REGISTEROCX_MESSAGE   13
#define IDS_ERROR_NODISKSPACE           14
#define IDS_ERROR_LICENSEFILE           15
#define IDS_ERROR_WIZARD                16
#define IDS_WIZARD_TITLE                17
#define IDS_HEADERTITLE_LICENSE         18
#define IDS_HEADERSUBTITLE_LICENSE      19
#define IDS_HEADERTITLE_INSTALL         20
#define IDS_HEADERSUBTITLE_INSTALL      21
#define IDS_HEADERTITLE_CONFIRM         22
#define IDS_HEADERSUBTITLE_CONFIRM      23
#define IDS_REINSTALL_MSG               25
#define IDS_WARNING_TITLE               27
#define IDD_LICENSE                     104
#define IDD_WELCOME                     107
#define IDB_HEADER                      127
#define IDD_CONFIRM                     128
#define IDB_MAIN                        132
#define IDD_COMPLETION                  133
#define IDD_INSTALL                     134
#define IDI_ICON_APP                    139
#define IDB_MAINBACKCOLOR               142
#define IDC_LICENSE_TEXT                1010
#define IDC_STATIC			1011
#define IDC_STATIC1                     1012
#define IDC_STATIC2                     1013
#define IDC_STATIC3                     1014
#define IDC_STATIC_WELCOME_TITLE        1035
#define IDC_RADIO_ACCEPTED              1040
#define IDC_RADIO_REJECTED              1041
#define IDC_STATIC_COMPLETION_TITLE     1042
#define IDC_STATIC_COMPLETION           1043
#define IDC_STATIC_CONFIRM_INSTALL      1044
#define IDC_INSTALL_PROGRESS            1045
#define IDC_STATIC_FILENAME             1046

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        143
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1047
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_ERROR_TITLE                 1
#define IDS_ERROR_IE_MESSAGE            2
#define IDS_ERROR_OS_MESSAGE            3
#define IDS_ERROR_DSCSETUP_MESSAGE      4
#define IDS_ERROR_LOAD_DSCSETUPDLL      4
#define IDS_ERROR_DLLENTRY              5
#define IDS_ERROR_WIN98SP1_MESSAGE      6
#define IDS_ERROR_ADMINISTRATOR_MESSAGE 7
#define IDS_WARNING_TITLE               9
#define IDI_ICON_APP                    114

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1045
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\setup\dfssetup.c ===
//+-------------------------------------------------------------------------
//
//	File:		DfsSetup.c  
//
// 	Purppose:	This a 16 bits program to install DFS.INF (net driver) 
//
// 	History:	June-1998	Zeyong Xu 	Created.
//
//--------------------------------------------------------------------------                

 
#include <windows.h>
#include <setupx.h>   

   
//
// Install Dfs driver instance on Windows95/98
//
int main( int argc, char *argv[])
{ 
	// initialize buffer
	char szDriverDescription[] = "DFS Services for Microsoft Network Client";  
	char szDriverName[] = "vredir.vxd"; 
	char szDriverPnPID[] = "DFSVREDIR"; 
	char szDriverInfFile[] = "dfs.inf"; 
	char szDriverDeviceSection[] = "DFSVREDIR.ndi";    
	char szNetClass[] = "netclient";
    LPDEVICE_INFO   lpdi = NULL;
    LPDRIVER_NODE   lpdn = NULL;
    int  nRet = 1;

	// if no dfs.inf file is found in commandline, return
	if( argc != 2 || lstrcmp(argv[1],szDriverInfFile) )
		return 0;

    //
    // Create a device info
    //
    if (DiCreateDeviceInfo(&lpdi, NULL, NULL, NULL, NULL, szNetClass, NULL) == OK)
    {
		//
        // Create a driver node
        //
        if (DiCreateDriverNode(&lpdn, 0, INFTYPE_TEXT, 0, szDriverDescription,
                szDriverDescription, NULL, NULL, szDriverInfFile,
                szDriverDeviceSection, NULL) == OK) 
        { 
            LPSTR   szTmp1, szTmp2; 

            //
            // Call the net class installer to install the driver
            //                      
            lpdi->lpSelectedDriver = lpdn;
            lpdi->hwndParent = NULL;
            lstrcpy(lpdi->szDescription, szDriverDescription);
            szTmp1 = lpdn->lpszHardwareID;
            szTmp2 = lpdn->lpszCompatIDs;
            lpdn->lpszHardwareID = szDriverPnPID;
            lpdn->lpszCompatIDs  = szDriverPnPID;

	        // Calling NDI Class Installer...  
            if(DiCallClassInstaller(DIF_INSTALLDEVICE, lpdi) == OK) 
            {
                //
                // Are we supposed to reboot?
                //     
/*               if (lpdi->Flags & DI_NEEDREBOOT) 
                {
                    gNeedsReboot = TRUE;
                } 
*/                 
                nRet = 0;        // install successful
            }
             
             // change back settings
            lpdn->lpszCompatIDs  = szTmp2;
            lpdn->lpszHardwareID = szTmp1;
            lpdi->lpSelectedDriver = NULL;

            //
            // Destroy the driver node
            //    
            DiDestroyDriverNodeList(lpdn);

        } 
     
        //
        // Destroy the device info
        //
        DiDestroyDeviceInfoList(lpdi);
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\dscsetup\wizard.cpp ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		wizard.cpp
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------

#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include "resource.h"
#include "dscsetup.h"
#include "doinst.h"
#include "wizard.h"


extern	SInstallVariables	g_sInstVar;


// welcome page DlgProc of wizard
BOOL CALLBACK WelcomeDialogProc(HWND hWnd, 
                                UINT nMessage, 
                                WPARAM wParam, 
                                LPARAM lParam)
{
	BOOL		bReturn = FALSE;
	LPNMHDR		lpNotifyMsg;

	switch (nMessage) 
	{
	case WM_INITDIALOG:
	{
		RECT	rc;

		// set font of title text
		SetWindowFont(GetDlgItem(hWnd, IDC_STATIC_WELCOME_TITLE),
					  g_sInstVar.m_hBigBoldFont,
					  TRUE);

		// Position the dialog
		if (GetWindowRect(GetParent(hWnd), &rc)) 
		{
			SetWindowPos(GetParent(hWnd),
						HWND_TOP,
						(GetSystemMetrics(SM_CXSCREEN) / 2) - 
                            ((rc.right - rc.left) / 2),
						(GetSystemMetrics(SM_CYSCREEN) / 2) - 
                            ((rc.bottom - rc.top) / 2),
						rc.right - rc.left,
						rc.bottom - rc.top,
						SWP_NOOWNERZORDER);
		}

		break;
	}
	case WM_NOTIFY:

		lpNotifyMsg = (NMHDR FAR*) lParam;
		switch (lpNotifyMsg->code) 
		{	
		// user click cancel
		case PSN_QUERYCANCEL:
			
			// cancel confirm?
			if(!ConfirmCancelWizard(hWnd))
			{
				SetWindowLongPtr(hWnd, DWL_MSGRESULT, TRUE);
				bReturn = TRUE;			
			}
			break;

		case PSN_WIZNEXT:
			break;

		case PSN_SETACTIVE:

			PropSheet_SetWizButtons(GetParent(hWnd), PSWIZB_NEXT);
			break;
		
		default:
			break;
		}
		break;

	default:
		break;
	}

	return bReturn;
}

/* ntbug#337931: remove license page
// License page DlgProc of wizard
BOOL CALLBACK LicenseDialogProc(HWND hWnd,
                                UINT nMessage, 
                                WPARAM wParam, 
                                LPARAM lParam)
{
	BOOL		bReturn = FALSE;
	LPNMHDR		lpNotifyMsg;
    HFONT       hLicenseTextFont;

	switch (nMessage) 
	{
	case WM_INITDIALOG:

		if(!CheckDiskSpace() ||			// check disk space
			!LoadLicenseFile(hWnd))		// Load license file
		{
			g_sInstVar.m_nSetupResult = SETUP_ERROR;
			PropSheet_PressButton(GetParent(hWnd), PSBTN_FINISH);  // close wizard
		}

        // use a ANSI_FIXED_FONT (Couirer) font for EULA to replace the default
		// font - MS Shell Dlg in order to fix the bug in Hebrew Win95
		if(g_sInstVar.m_bWin95)
        {
            hLicenseTextFont = (HFONT) GetStockObject(ANSI_FIXED_FONT);
            if(hLicenseTextFont)
            {
		        SetWindowFont(GetDlgItem(hWnd, IDC_LICENSE_TEXT),
					          hLicenseTextFont,
					          TRUE);
            }
        }

		bReturn = TRUE;
		break;

	case WM_NOTIFY:

		lpNotifyMsg = (NMHDR FAR*) lParam;
		switch (lpNotifyMsg->code) 
		{	
		// user click cancel
		case PSN_QUERYCANCEL:

			// cancel confirm?
			if(!ConfirmCancelWizard(hWnd))
			{
				SetWindowLongPtr(hWnd, DWL_MSGRESULT, TRUE);
				bReturn = TRUE;			
			}
			break;

		case PSN_WIZNEXT:
			break;

		case PSN_SETACTIVE:
		{
			HWND hButton;
			hButton = GetDlgItem(hWnd, IDC_RADIO_ACCEPTED);
			// get radio button check status
			if( hButton && 
                BST_CHECKED == SendMessage(hButton, BM_GETCHECK, 0, 0L) )
				PropSheet_SetWizButtons(GetParent(hWnd), 
                                        PSWIZB_BACK | PSWIZB_NEXT);
			else
				PropSheet_SetWizButtons(GetParent(hWnd),
                                        PSWIZB_BACK);
			
			break;
		}		
		default:
			break;
		}
		break;

	case WM_COMMAND:	// button click
		{
			HWND hButton;
			hButton = GetDlgItem(hWnd, IDC_RADIO_ACCEPTED);
			// get radio button check status
			if( hButton && BST_CHECKED == 
                SendMessage(hButton, BM_GETCHECK, 0, 0L) )
				PropSheet_SetWizButtons(GetParent(hWnd), 
                                        PSWIZB_BACK | PSWIZB_NEXT);
			else
				PropSheet_SetWizButtons(GetParent(hWnd), 
                                        PSWIZB_BACK);
		}

	default:
		break;
	}
	return bReturn;
}
*/

// Confirm page DlgProc of wizard
BOOL CALLBACK ConfirmDialogProc(HWND hWnd, 
                                UINT nMessage, 
                                WPARAM wParam, 
                                LPARAM lParam)
{
	BOOL		bReturn = FALSE;
	LPNMHDR		lpNotifyMsg;

	switch (nMessage) 
	{
	case WM_INITDIALOG:
		
		if(!CheckDiskSpace())			// check disk space
		{
			g_sInstVar.m_nSetupResult = SETUP_ERROR;
			PropSheet_PressButton(GetParent(hWnd), PSBTN_FINISH);  // close wizard
		}

        // check if DSClient has been installed
		if(CheckDSClientInstalled())
		{
			// load string and dispaly it in textitem
			TCHAR  szMessage[MAX_MESSAGE + 1];
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_REINSTALL_MSG,
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd,
                           IDC_STATIC_CONFIRM_INSTALL,
                           szMessage);
		}
		break;
		
	case WM_NOTIFY:

		lpNotifyMsg = (NMHDR FAR*) lParam;
		switch (lpNotifyMsg->code) 
		{	
		// user click cancel
		case PSN_QUERYCANCEL:

			// cancel confirm?
			if(!ConfirmCancelWizard(hWnd))
			{
				SetWindowLongPtr(hWnd, DWL_MSGRESULT, TRUE);
				bReturn = TRUE;			
			}
			break;

		case PSN_WIZNEXT:
			break;

		case PSN_SETACTIVE:
			PropSheet_SetWizButtons(GetParent(hWnd), 
                                    PSWIZB_BACK | PSWIZB_NEXT);
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	return bReturn;
}


// wizard dialog callback function
BOOL CALLBACK InstallDialogProc(HWND hWnd,
                                UINT nMessage, 
                                WPARAM wParam, 
                                LPARAM lParam) 
{
	BOOL			bReturn = FALSE;
	LPNMHDR			lpMsg;

	switch (nMessage) 
	{
	case WM_INITDIALOG:
	{
		DWORD	dwThreadId;

        // get the handle of install progress bar and file name item
		g_sInstVar.m_hProgress = GetDlgItem(hWnd, IDC_INSTALL_PROGRESS);
		g_sInstVar.m_hFileNameItem = GetDlgItem(hWnd, IDC_STATIC_FILENAME);

		// start to do installation
		g_sInstVar.m_hInstallThread = CreateThread(NULL,	
								                    0,		
								                    DoInstallationProc,
								                    hWnd,	
								                    0,		
								                    &dwThreadId); 

    // if CreateThread() failed
    if(!g_sInstVar.m_hInstallThread)
    {
   		g_sInstVar.m_nSetupResult = SETUP_ERROR;
			PropSheet_PressButton(GetParent(hWnd), PSBTN_FINISH);  // close wizard
    }

		bReturn = TRUE;
		break;		
	}
	case WM_NOTIFY:
	{
		lpMsg = (NMHDR FAR*) lParam;
		switch(lpMsg->code)
		{
		// cancel to do nothing
		case PSN_QUERYCANCEL:
	
			// block
			EnterCriticalSection(&g_sInstVar.m_oCriticalSection);
			
			// cancel confirm?
			if(!ConfirmCancelWizard(hWnd))
			{
				SetWindowLongPtr(hWnd, DWL_MSGRESULT, TRUE);
				bReturn = TRUE;			
			}
		
			// unblock
			LeaveCriticalSection(&g_sInstVar.m_oCriticalSection);
			
			break;

		case PSN_WIZFINISH:
			break;

		case PSN_WIZBACK:
			break;

		case PSN_SETACTIVE:

			PropSheet_SetWizButtons(GetParent(hWnd), 0);
			break;
			
		default:
			break;
		}
	}
	default:
		break;
	}
	
	return bReturn;
}

// Completion page DlgProc of wizard
BOOL CALLBACK CompletionDialogProc(HWND hWnd, 
                                   UINT nMessage,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
	BOOL		bReturn = FALSE;
	LPNMHDR		lpNotifyMsg;

	switch (nMessage) 
	{
	case WM_INITDIALOG:
	{
		TCHAR		szMessage[MAX_MESSAGE + 1];
		RECT		rc;

		// load string and dispaly it in textitem
		switch (g_sInstVar.m_nSetupResult)
		{
		case SETUP_SUCCESS:
		
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_SUCCESS_TITLE, 
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION_TITLE, szMessage);
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_SUCCESS, 
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION, szMessage);
			break;

		case SETUP_CANCEL:
	
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_CANCEL_TITLE,
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION_TITLE, szMessage);
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_CANCEL, 
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION, szMessage);
			break;
			
		case SETUP_ERROR:
	
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_ERROR_TITLE,
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION_TITLE, szMessage);
			LoadString(g_sInstVar.m_hInstance, 
                       IDS_SETUP_ERROR, 
                       szMessage, 
                       MAX_MESSAGE);
			SetDlgItemText(hWnd, IDC_STATIC_COMPLETION, szMessage);
			break;

		default:
			break;
		}
	
		// set font of title text
		SetWindowFont(GetDlgItem(hWnd, IDC_STATIC_COMPLETION_TITLE),
					  g_sInstVar.m_hBigBoldFont,
					  TRUE);
		
		// Position the dialog
		if (GetWindowRect(GetParent(hWnd), &rc)) 
		{
			SetWindowPos(GetParent(hWnd),
						HWND_TOP,
						(GetSystemMetrics(SM_CXSCREEN) / 2) - 
                            ((rc.right - rc.left) / 2),
						(GetSystemMetrics(SM_CYSCREEN) / 2) - 
                            ((rc.bottom - rc.top) / 2),
						rc.right - rc.left,
						rc.bottom - rc.top,
						SWP_NOOWNERZORDER);
		}
		
		break;
	}
	case WM_NOTIFY:

		lpNotifyMsg = (NMHDR FAR*) lParam;
		switch (lpNotifyMsg->code) 
		{	
		case PSN_QUERYCANCEL:
			break;

		case PSN_WIZFINISH:
			break;

		case PSN_SETACTIVE:

			// set wizard button
			PropSheet_SetWizButtons(GetParent(hWnd), PSWIZB_FINISH);
			PropSheet_CancelToClose(GetParent(hWnd));
			break;
		
		default:
			break;
		}

		break;

	default:
		break;
	}

	return bReturn;
}

// ask if you want to cancel the wizard
BOOL ConfirmCancelWizard(HWND hWnd)
{
	TCHAR			szMsg[MAX_MESSAGE + 1];
	TCHAR			szTitle[MAX_TITLE + 1];

	LoadString(g_sInstVar.m_hInstance, IDS_CANCEL_TITLE, szTitle, MAX_TITLE);
	LoadString(g_sInstVar.m_hInstance, IDS_CANCEL_MSG, szMsg, MAX_MESSAGE);

	if (IDYES == MessageBox(hWnd, 
                            szMsg, 
                            szTitle, 
                            MB_YESNO | MB_TOPMOST | MB_ICONQUESTION))
	{
    // kill timer
    if(g_sInstVar.m_uTimerID)
        KillTimer(hWnd, g_sInstVar.m_uTimerID);

    // set m_nSetupResult to SETUP_CANCEL, in order to stop the inatllation
    g_sInstVar.m_nSetupResult = SETUP_CANCEL;
		return TRUE;
	}

	return FALSE;
}

// do installation proc
DWORD WINAPI DoInstallationProc(LPVOID lpVoid)
{
	HWND hWnd = (HWND)lpVoid;

	// do installation
	g_sInstVar.m_nSetupResult = DoInstallation(hWnd);

	// Close install page of the setup wizard
	PropSheet_PressButton(GetParent(hWnd), PSBTN_FINISH);		

	return g_sInstVar.m_nSetupResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\dscsetup\dscsetup.h ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		dscsetup.h
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------


#define		MAX_MESSAGE			1024
#define		MAX_TITLE			  64

#define		SETUP_SUCCESS		0
#define		SETUP_ERROR			1
#define		SETUP_CANCEL		2

#define		NUM_FILES_TOTAL	14
#define		SIZE_TOTAL			10
#define   MB_TO_BYTE			1000000
#define		SIZE_TITLE_FONT		12
#define		SIZE_WIZARD_PAGE	4

#define		STR_DSCLIENT_REGKEY		  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\DsClient")
#define		STR_IE_REGKEY			      TEXT("Software\\Microsoft\\Internet Explorer")
#define		STR_VERSION				      TEXT("Version")
#define		STR_IE_VERSION_4  		  TEXT("4")
#define		STR_DCOM_REGKEY			    TEXT("CLSID\\{BDC67890-4FC0-11D0-A805-00AA006D2EA4}\\InstalledVersion")
#define		STR_DLL_NAME			      TEXT("dscsetup.dll")
#define		STR_INSTALL_DCOM95		  TEXT("dcom95.exe /q /r:n")
#define		STR_INSTALL_WAB 		    TEXT("wabinst.exe /q /r:n")
#define   STR_INSTALL_ADSI        TEXT("adsix86.exe /C:\"rundll32 advpack.dll,LaunchINFSection adsix86.inf,RegADSIWithDsclient,,N\"")
#define   STR_INSTALL_ADSIWREMOVE TEXT("adsix86.exe")
#define		CHAR_BACKSLASH			    TEXT('\\')


// define a installation structure
typedef struct _SINSTALLVARIBLES
{
	HINSTANCE	m_hInstance;
  HANDLE    m_hInstallThread;
  UINT      m_uTimerID;
	HWND		  m_hProgress;
	HWND		  m_hFileNameItem;
	HFONT		  m_hBigBoldFont;

  BOOL      m_bDCOMInstalled;
	BOOL      m_bQuietMode;
  BOOL      m_bWabInst;
  BOOL      m_bSysDlls;
#ifdef MERRILL_LYNCH
  BOOL  m_bNoReboot;
#endif
	UINT		  m_nSetupResult;

	TCHAR		  m_szSourcePath[MAX_PATH + 1];

	CRITICAL_SECTION  m_oCriticalSection;

} SInstallVariables;


VOID InitVariables();
VOID ParseCmdline(LPSTR lpCmdLine);
DWORD DoInstallation(HWND hWnd);
VOID CentreWindow(HWND hwnd);
DWORD64 SetupGetDiskFreeSpace();
BOOL CheckDSClientInstalled();
BOOL DSCSetupWizard();
void CheckDCOMInstalled();
BOOL LoadLicenseFile(HWND hDlg);
BOOL CheckDiskSpace();
BOOL CreateObjects();
VOID DestroyObjects();
VOID CreateBigFont();                   

// export function
DWORD WINAPI DoDscSetup(LPCSTR lpCmdLine);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\setup\setup.h ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		setup.h
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to do an NT4 setup
//																	
//------------------------------------------------------------------


#define		MAX_MESSAGE			512
#define		MAX_TITLE			64

#define		SETUP_SUCCESS		0
#define		SETUP_ERROR			1
#define		SETUP_CANCEL		2

#define		STR_DSCLIENT_REGKEY		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\DsClient")
#define		STR_IE_REGKEY			    TEXT("Software\\Microsoft\\Internet Explorer")
#define		STR_VERSION				    TEXT("Version")
#define		STR_IE_VERSION			  TEXT("4")
#define		STR_DSCSETUP_DLL		  TEXT("dscsetup.dll")
#define		STR_DODSCSETUP        "DoDscSetup"
#define   STR_INSTALL_ADSI      TEXT("adsix86.exe /C:\"rundll32 advpack.dll,LaunchINFSection adsix86.inf,RegADSIWithDsclient,,N\"")


typedef DWORD (WINAPI *FPDODSCSETUP)(LPCSTR);

typedef enum
{
  FullInstall,
  FullInstallQuiet,
  ADSIOnly,
  ADSIOnlyQuiet,
  Wabless,
  WablessQuiet
} DSCCOMMANDLINEPARAMS;

typedef enum
{
  NonNT4,
#ifdef MERRILL_LYNCH
  NT4SP1toSP3,
  NT4SP4toSP5,
#else
  NT4preSP6,
#endif
  NT4SP6
} RETOSVERSION;

typedef enum
{
  PreIE4,
  IE4
} RETIEVERSION;

DSCCOMMANDLINEPARAMS ParseCmdline(LPSTR lpCmdLine);
RETIEVERSION CheckIEVersion();
RETOSVERSION CheckOSVersion();
BOOL CheckAdministrator(HINSTANCE);
BOOL RunADSIOnlySetup(HINSTANCE);

INT  LaunchDscsetup(HINSTANCE hInstance, LPCSTR lpCmdLine);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\dscsetup\wizard.h ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup Wizard				
//
//  Purpose:	Installs the Windows NT4 DS Client Files			
//
//  File:		wizard.h
//
//  History:	March 1998	Zeyong Xu	Created
//            Jan   2000  Jeff Jones (JeffJon) Modified
//                        - changed to be an NT setup
//																	
//------------------------------------------------------------------



BOOL CALLBACK WelcomeDialogProc(HWND hWnd, 
								UINT nMessage, 
								WPARAM wParam, 
								LPARAM lParam);
/* ntbug#337931: remove license page

BOOL CALLBACK LicenseDialogProc(HWND hWnd, 
								UINT nMessage, 
								WPARAM wParam, 
								LPARAM lParam);
*/
BOOL CALLBACK ConfirmDialogProc(HWND hWnd, 
							   UINT nMessage, 
							   WPARAM wParam, 
							   LPARAM lParam);

BOOL CALLBACK InstallDialogProc(HWND hWnd, 
								UINT nMessage, 
								WPARAM wParam, 
								LPARAM lParam);

BOOL CALLBACK CompletionDialogProc(HWND hWnd, 
								   UINT nMessage, 
								   WPARAM wParam, 
								   LPARAM lParam);

BOOL ConfirmCancelWizard(HWND hWnd);
DWORD WINAPI DoInstallationProc(LPVOID lpVoid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsclientnt4\setup\setup\setup.c ===
//+------------------------------------------------------------------
//																	
//  Project:	Windows NT4 DS Client Setup				
//
//  Purpose:	Check OS and IE version, and launch dscsetup 
//				to installs the Windows NT 4.0 DS Client Files			
//
//  File:		Setup.c
//
//  History:	Aug 1998	Zeyong Xu	Created
//            Jan 2000  Jeff Jones (JeffJon) Modified
//                      - Changes made to make it into an NT4 setup
//																	
//------------------------------------------------------------------


#include <windows.h>
#include <tchar.h>
#include "resource.h"
#include "setup.h"

DSCCOMMANDLINEPARAMS ParseCmdline(LPSTR lpCmdLine)
{
  DSCCOMMANDLINEPARAMS retCommandParams = FullInstall;
  BOOL bQuietMode = FALSE;
  BOOL bWabinst   = TRUE;
  BOOL bSystem    = TRUE;

  PCTSTR ptszTok = _tcstok(lpCmdLine, _T(" "));
  do
  {
    if (ptszTok != NULL)
    {
      if (_tcsicmp(ptszTok, _T("/q")) == 0)
      {
        bQuietMode = TRUE;
      }

      if (_tcsicmp(ptszTok, _T("/a")) == 0)
      {
        bWabinst = FALSE;
        bSystem  = FALSE;
      }

      if (_tcsicmp(ptszTok, _T("/d")) == 0)
      {
        bWabinst = FALSE;
      }
    }
    ptszTok = _tcstok(NULL, _T("  "));
  } while (ptszTok != NULL);

  if (bQuietMode)
  {
    if (bWabinst && bSystem)
    {
      retCommandParams = FullInstallQuiet;
    }
    else if (bSystem && !bWabinst)
    {
      retCommandParams = WablessQuiet;
    }
    else
    {
      retCommandParams = ADSIOnlyQuiet;
    }
  }
  else
  {
    if (bWabinst && bSystem)
    {
      retCommandParams = FullInstall;
    }
    else if (bSystem && !bWabinst)
    {
      retCommandParams = Wabless;
    }
    else
    {
      retCommandParams = ADSIOnly;
    }
  }
  return retCommandParams;
}

// winmain
INT WINAPI WinMain(HINSTANCE hInstance, 
				   HINSTANCE hPrevInstance, 
				   LPSTR lpCmdLine, 
				   INT nCmdShow)
{
  //
  // Parse the commandline for later use
  //
  DSCCOMMANDLINEPARAMS commandParams = ParseCmdline(lpCmdLine);

  // check OS version
  RETOSVERSION retOSVersion = CheckOSVersion();

  TCHAR  szMessage[MAX_MESSAGE + 1];
	TCHAR  szTitle[MAX_TITLE + 1];

  LoadString(hInstance, 
           IDS_ERROR_TITLE, 
           szTitle, 
           MAX_TITLE);

  //
  // Here is the matrix we are shooting for.
  //  A   = ADSI only
  //  D   = System files only
  //  ALL = Wabinst, ADSI, and system files
  //
  //--------------------------------------------
  //                | < IE4      | >= IE4      |
  //----------------+------------+--------------
  //        Other   |    X     	 |    X        |
  //----------------+------------+--------------
  //      < SP6a    |    A       |    A        |
  //----------------+------------+--------------
  //       >=SP6a   |    A       |   A,D, ALL  |
  //--------------------------------------------

  //
  // if we are building the Merrill Lynch version
  // (MERRILL_LYNCH will be defined) we have to 
  // add the following line to the matrix above
  //
  //--------------------------------------------
  //  NO SP to SP3  |    A       |    A        |
  //----------------+------------+--------------
  //  SP4 to > SP6a |   special installed bits |
  //--------------------------------------------
  //

  if (retOSVersion == NonNT4)
  {
		// if not NT4, display error message
		LoadString(hInstance,
               IDS_ERROR_OS_MESSAGE,
               szMessage, 
               MAX_MESSAGE);

    MessageBox(NULL,	// handle of owner window
				szMessage,	// address of text in message box
				szTitle,	// address of title of message box  
				MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box

    return SETUP_ERROR;
  }
#ifdef MERRILL_LYNCH
  else if (retOSVersion == NT4SP1toSP3)
#else
  else if (retOSVersion == NT4preSP6)
#endif
  {
    if (commandParams == ADSIOnly ||
        commandParams == ADSIOnlyQuiet)
    {
      //
      // Check to be sure the user in the Administrators group
      // We have to be able to copy over system files
      //
      if (!CheckAdministrator(hInstance))
      {
        return SETUP_CANCEL;
      }

      return RunADSIOnlySetup(hInstance);
    }
    else
    {
		  LoadString(hInstance,
                 IDS_ERROR_OS_MESSAGE,
                 szMessage, 
                 MAX_MESSAGE);

      MessageBox(NULL,	// handle of owner window
				  szMessage,	// address of text in message box
				  szTitle,	// address of title of message box  
				  MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box
      return SETUP_ERROR;
    }
  }
  else  // NT4 SP6a or greater
  {
    RETIEVERSION retIEVersion = CheckIEVersion();
    if (retIEVersion == PreIE4)
    {
      if (commandParams == ADSIOnly ||
          commandParams == ADSIOnlyQuiet)
      {
        //
        // Check to be sure the user in the Administrators group
        // We have to be able to copy over system files
        //
        if (!CheckAdministrator(hInstance))
        {
          return SETUP_CANCEL;
        }

        return RunADSIOnlySetup(hInstance);
      }
      else
      {
		    LoadString(hInstance,
                   IDS_ERROR_IE_MESSAGE,
                   szMessage, 
                   MAX_MESSAGE);

        MessageBox(NULL,	// handle of owner window
				    szMessage,	// address of text in message box
				    szTitle,	// address of title of message box  
				    MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box
        return SETUP_ERROR;
      }
    }
  }
  //
  // Check to be sure the user in the Administrators group
  // We have to be able to copy over system files
  //
  if (!CheckAdministrator(hInstance))
  {
    return SETUP_CANCEL;
  }


	return LaunchDscsetup(hInstance,lpCmdLine);
}


// check for IE 4.0 or later version
RETIEVERSION CheckIEVersion()
{
	HKEY		hSubKey;
	DWORD		dwType;
	ULONG		nLen;
	TCHAR		szValue[MAX_TITLE];
  RETIEVERSION retIEVersion = PreIE4;

	// check if IE 4.0 has been installed
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
									  STR_IE_REGKEY, 
									  0, 
									  KEY_READ, 
									  &hSubKey)		)
	{
		nLen = MAX_PATH;
		if (ERROR_SUCCESS == RegQueryValueEx(hSubKey, 
											 STR_VERSION, 
											 NULL, 
											 &dwType, 
											 (LPBYTE) szValue, &nLen)	)
		{
			if((nLen > 0) && (dwType == REG_SZ))
				retIEVersion = (_tcscmp(szValue,STR_IE_VERSION) >= 0) ? IE4 : PreIE4;  // IE 4.0 or later was installed
		}
		RegCloseKey(hSubKey);
	}
	
	return retIEVersion;
}

// check for NT4 Version
RETOSVERSION CheckOSVersion()
{
  RETOSVERSION retOSVersion = NT4SP6;
  BOOL   bGetInfoSucceeded = TRUE;
  OSVERSIONINFOEX  osvi;
  ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

  // get os verion info
  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

  if (!GetVersionEx((OSVERSIONINFO*)&osvi))
  {
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bGetInfoSucceeded = GetVersionEx((OSVERSIONINFO*)&osvi);
  }
  else
  {
    bGetInfoSucceeded = TRUE;
  }

  if(bGetInfoSucceeded &&
     osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
     osvi.dwMajorVersion == 4 &&
     osvi.dwOSVersionInfoSize >= sizeof(OSVERSIONINFOEX) &&
     osvi.wServicePackMajor >= 6)  // NT4 SP6
  {
    retOSVersion = NT4SP6;
  }
  else if (bGetInfoSucceeded &&
           osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
           osvi.dwMajorVersion == 4 &&
#ifdef MERRILL_LYNCH
           (osvi.wServicePackMajor >= 4 && osvi.wServicePackMajor < 6))
  {
    retOSVersion = NT4SP4toSP5;
  }
  else if (bGetInfoSucceeded &&
           osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
           osvi.dwMajorVersion == 4 &&
           osvi.wServicePackMajor < 4)
  {
    retOSVersion = NT4SP1toSP3;
#else           
           osvi.dwOSVersionInfoSize == sizeof(OSVERSIONINFO))
  {
    retOSVersion = NT4preSP6;
#endif
  }
  else
  {
    retOSVersion = NonNT4;
  }


  return retOSVersion;
}

//
// check for Administrators group
//
BOOL CheckAdministrator(HINSTANCE hInstance)
{
	BOOL   bReturn = TRUE;
	TCHAR  szMessage[MAX_MESSAGE + 1];
	TCHAR  szTitle[MAX_TITLE + 1];

  do   // false loop
  {
    HANDLE                    hToken=INVALID_HANDLE_VALUE; // process token
    BYTE                      bufTokenGroups[10000]; // token group information
    DWORD                     lenTokenGroups;        // returned length of token group information
    SID_IDENTIFIER_AUTHORITY  siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID                      psidAdministrators;
    PTOKEN_GROUPS             ptgGroups = (PTOKEN_GROUPS) bufTokenGroups;
    DWORD                     iGroup;       // group number index

    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_READ, &hToken ) )
    {
      bReturn = FALSE;
      break;
    }

    if (!GetTokenInformation( hToken, TokenGroups, bufTokenGroups, sizeof bufTokenGroups, &lenTokenGroups ) )
    {
      bReturn = FALSE;
      break;
    }

    if ( AllocateAndInitializeSid(
        &siaNtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &psidAdministrators ) )
    {
      bReturn = FALSE;

      for ( iGroup = 0; iGroup < ptgGroups->GroupCount; iGroup++ )
      {
         if ( EqualSid( psidAdministrators, ptgGroups->Groups[iGroup].Sid ) )
         {
            bReturn = TRUE;
            break;
         }
      }

      FreeSid( psidAdministrators );
    }
    else
    {
      bReturn = FALSE;
      break;
    }

    if ( hToken != INVALID_HANDLE_VALUE )
    {
      CloseHandle( hToken );
      hToken = INVALID_HANDLE_VALUE;
    }

  } while (FALSE);

  if(!bReturn)
  {
	  LoadString(hInstance, IDS_ERROR_ADMINISTRATOR_MESSAGE, szMessage, MAX_MESSAGE);
   	LoadString(hInstance, IDS_ERROR_TITLE, szTitle, MAX_TITLE);

      MessageBox(NULL,	// handle of owner window
				szMessage,	// address of text in message box
				szTitle,	// address of title of message box  
				MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box
	}
		
	return bReturn;
}

//
// Launches a process with the given commandline and
// waits for it to finish.
//
BOOL LaunchProcess(LPTSTR lpCommandLine)
{
	BOOL bResult = FALSE;

	STARTUPINFO				si;
	PROCESS_INFORMATION		pi;

	// its console window will be invisible to the user.
	ZeroMemory(&pi,sizeof(PROCESS_INFORMATION));
	ZeroMemory(&si,sizeof(STARTUPINFO));
	si.cb			= sizeof (STARTUPINFO);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;            // HideWindow

  if(CreateProcess(	NULL,					
						lpCommandLine,			
						NULL,					
						NULL,					
						FALSE,				
						0,					
						NULL,				
						NULL,				
						&si,                
						&pi ) )             
	{
		// wait to finish the runing setup process
		WaitForSingleObject(pi.hProcess,INFINITE);
	
		// close process handle
		if (pi.hProcess && pi.hProcess != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hProcess) ;
		}
		if (pi.hThread && pi.hThread != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hThread) ;
		}

		bResult = TRUE;
	}

	return bResult;
}

//
// Run the setup for ADSI only
//
int RunADSIOnlySetup(HINSTANCE hInstance)
{
  int iReturn = SETUP_SUCCESS;
  if (!LaunchProcess(STR_INSTALL_ADSI))
  {
    iReturn = SETUP_ERROR;
  }
  return iReturn;
}

// launch Inf file to install this component
INT LaunchDscsetup(HINSTANCE hInstance, LPCSTR lpCmdLine)
{
	INT     nResult = SETUP_ERROR;
	TCHAR	szMessage[MAX_MESSAGE + 1]; 
	TCHAR	szTitle[MAX_TITLE + 1]; 

	FPDODSCSETUP fpDoDscSetup;
	HINSTANCE  hInst = LoadLibrary(STR_DSCSETUP_DLL);

	if(hInst) 
	{
		fpDoDscSetup = (FPDODSCSETUP) GetProcAddress(hInst, STR_DODSCSETUP);

		if(fpDoDscSetup)
		{
			// Do dscsetup
			nResult = fpDoDscSetup(lpCmdLine);
		}
    else
    {
      LoadString(hInstance, IDS_ERROR_DLLENTRY, szMessage, MAX_MESSAGE);
      LoadString(hInstance, IDS_ERROR_TITLE, szTitle, MAX_TITLE);

        // display a error message - can't find dscsetup.exe
      MessageBox(NULL,	// handle of owner window
		      szMessage,	// address of text in message box
	        szTitle,	// address of title of message box  
		      MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box

    }

 		FreeLibrary( hInst );
	}
  else
	{
		LoadString(hInstance, IDS_ERROR_LOAD_DSCSETUPDLL, szMessage, MAX_MESSAGE);
		LoadString(hInstance, IDS_ERROR_TITLE, szTitle, MAX_TITLE);

        // display a error message - can't find dscsetup.exe
		MessageBox(NULL,	// handle of owner window
					szMessage,	// address of text in message box
					szTitle,	// address of title of message box  
					MB_OK | MB_TOPMOST | MB_ICONERROR);  // style of message box
	}

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsutil2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dsUtil2.h
//
//  Contents:  Utility functions callable by the parser
//
//  History:   28-Apr-2001 JonN     Created
//             
//
//--------------------------------------------------------------------------

#ifndef _DSUTIL2_H_
#define _DSUTIL2_H_

//+--------------------------------------------------------------------------
//
//  Class:      GetEscapedElement
//
//  Purpose:    Calls IADsPathname::GetEscapedElement.  Uses LocalAlloc.
//
//  History:    28-Apr-2001 JonN     Created
//
//---------------------------------------------------------------------------

HRESULT GetEscapedElement( OUT PWSTR* ppszOut, IN PCWSTR pszIn );

#endif //_DSUTIL2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsutilrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsutil.rc
//
#define IDS_SUCCESS                     200
#define IDS_FAILED                      201
#define IDS_FAILED_SET_PASSWORD         202
#define IDS_FAILED_SET_NW_PASSWORD      203
#define IDS_FAILED_RESET_COMPUTER       204
#define IDS_YES                         205
#define IDS_NO                          206
#define IDS_ADMIN_PASSWORD_PROMPT       207
#define IDS_USER_PASSWORD_PROMPT        208
#define IDS_FAILED_CHANGE_GROUP_DOMAIN_VERSION 209
#define IDS_MUSTCHPWD_CANCHPWD_CONFLICT 210
#define IDS_ERRMSG_REMOVE_FROM_GROUP    211
#define IDS_ERRMSG_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER 212

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dsUtil.h
//
//  Contents:  Utility functions for working with Active Directory
//
//  History:   05-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _DSUTIL_H_
#define _DSUTIL_H_

//+--------------------------------------------------------------------------
//
//  Class:      CDSCmdCredentialObject
//
//  Purpose:    Object for maintaining username and an encrypted password
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CDSCmdCredentialObject
{
public :
   //
   // Constructor
   //
	CDSCmdCredentialObject();

   //
   // Destructor
   //
	~CDSCmdCredentialObject();

   //
   // Public accessor methods
   //
	PCWSTR   GetUsername() const { return m_sbstrUsername; }
	HRESULT  SetUsername(PCWSTR pszUsername);

	HRESULT  GetPassword(PWSTR pszPassword, UINT* pnWCharCount) const;
	HRESULT  SetPassword(PCWSTR pszPassword);

	bool     UsingCredentials() const { return m_bUsingCredentials; }
	void     SetUsingCredentials(const bool bUseCred) { m_bUsingCredentials = bUseCred; }

private :
   //
   // Private data members
   //
	CComBSTR m_sbstrUsername;
	PWSTR    m_pszPassword;
	bool     m_bUsingCredentials;
};

typedef enum
{
   DSCMD_LDAP_PROVIDER = 0,
   DSCMD_GC_PROVIDER
}  DSCMD_PROVIDER_TYPE;

//+--------------------------------------------------------------------------
//
//  Class:      CDSCmdBasePathsInfo
//
//  Purpose:    Object for storing and retrieving the paths for the well
//              known naming contexts
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CDSCmdBasePathsInfo
{
public:
   //
   // Constructor
   //
   CDSCmdBasePathsInfo();

   //
   // Destructor
   //
   ~CDSCmdBasePathsInfo();

   //
   // Public accessor methods
   //
   HRESULT     InitializeFromName(const CDSCmdCredentialObject& refCredentialObject,
                                 PCWSTR pszServerOrDomain,
                                 bool bServerName = false);
   bool        IsInitialized() const             { return m_bInitialized; }
   CComBSTR    GetProviderAndServerName() const  { return m_sbstrProviderAndServerName; }
   CComBSTR    GetGCProvider() const             { return m_sbstrGCProvider; }
   CComBSTR    GetServerName() const             { return m_sbstrServerName; }
   IADs*       GetRootDSE() const                { return m_spRootDSE; }
   CComBSTR    GetConfigurationNamingContext() const;
   CComBSTR    GetSchemaNamingContext() const;
   CComBSTR    GetDefaultNamingContext() const;

   //
   // Other helpful methods
   //
   void        ComposePathFromDN(PCWSTR pszDN, 
                                 CComBSTR& refsbstrPath, 
                                 DSCMD_PROVIDER_TYPE nProviderType = DSCMD_LDAP_PROVIDER) const;

   HRESULT     GetDomainMode(const CDSCmdCredentialObject& refCredObject,
                             bool& bMixedMode) const;

private:
   //
   // Private data members
   //
   bool        m_bInitialized;


   CComBSTR    m_sbstrProviderAndServerName;
   CComBSTR    m_sbstrGCProvider;
   CComBSTR    m_sbstrServerName;

   mutable bool        m_bModeInitialized;
   mutable bool        m_bDomainMode;
   mutable CComBSTR    m_sbstrConfigNamingContext;
   mutable CComBSTR    m_sbstrSchemaNamingContext;
   mutable CComBSTR    m_sbstrDefaultNamingContext;

   CComPtr<IADs> m_spRootDSE;
};

//////////////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Function:   DSCmdOpenObject
//
//  Synopsis:   A wrapper around ADsOpenObject
//
//  Arguments:  [refCredentialObject - IN] : a reference to a credential management object
//              [pszPath - IN]           : a pointer to a NULL terminated wide character
//                                         string that contains the ADSI path of the
//                                         object to connect to
//              [refIID - IN]            : the interface ID of the interface to return
//              [ppObject - OUT]         : a pointer which is to receive the interface pointer
//              [bBindToServer - IN]     : true if the path contains a server name,
//                                         false otherwise
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Anything else is a failure code from an ADSI call
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DSCmdOpenObject(const CDSCmdCredentialObject& refCredentialObject,
                        PCWSTR pszPath,
                        REFIID refIID,
                        void** ppObject,
                        bool bBindToServer);

//+--------------------------------------------------------------------------
//
//  Function:   GetErrorMessage
//
//  Synopsis:   Retrieves the error message associated with the HRESULT by 
//              using FormatMessage
//
//  Arguments:  [hr - IN]                 : HRESULT for which the error 
//                                          message is to be retrieved
//              [sbstrErrorMessage - OUT] : Receives the error message
//
//  Returns:    bool : true if the message was formatted properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool GetErrorMessage(HRESULT hr, CComBSTR& sbstrErrorMessage);

//+--------------------------------------------------------------------------
//
//  Function:   DisplayErrorMessage
//
//  Synopsis:   Displays the error message retrieved from GetErrorMessage 
//              to stderr. If GetErrorMessage fails, it displays the error
//              code of the HRESULT
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//              [hr - IN]        : HRESULT for which the error 
//                                 message is to be retrieved
//              [pszMessage - IN]: string of an additional message to be displayed
//                                 at the end
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool DisplayErrorMessage(PCWSTR pszCommand,
                         PCWSTR pszName,
                         HRESULT hr, 
                         PCWSTR pszMessage = NULL);

//+--------------------------------------------------------------------------
//
//  Function:   DisplayErrorMessage
//
//  Synopsis:   Displays the error message retrieved from GetErrorMessage 
//              to stderr. If GetErrorMessage fails, it displays the error
//              code of the HRESULT
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//              [hr - IN]        : HRESULT for which the error 
//                                 message is to be retrieved
//              [nStringID - IN] : Resource ID an additional message to be displayed
//                                 at the end
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool DisplayErrorMessage(PCWSTR pszCommand,
                         PCWSTR pszName,
                         HRESULT hr, 
                         UINT nStringID);

//+--------------------------------------------------------------------------
//
//  Function:   DisplaySuccessMessage
//
//  Synopsis:   Displays a success message for the command
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool DisplaySuccessMessage(PCWSTR pszCommand,
                           PCWSTR pszName);



//+--------------------------------------------------------------------------
//
//  Function:   WriteStringIDToStandardOut
//
//  Synopsis:   Loads the String Resource and displays on Standardout
//
//  Arguments:  nStringID :	Resource ID	
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   hiteshr Created
//
//---------------------------------------------------------------------------
bool WriteStringIDToStandardOut(UINT nStringID);

/////////////////////////////////////////////////////////////////////////////////////////

//
// Forward declarations
//
struct _DSAttributeTableEntry;

//+--------------------------------------------------------------------------
//
//  Struct:     _DSObjectTableEntry
//
//  Purpose:    Definition of a table entry that describes what attributes
//              are exposed on an specific object class
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
typedef struct _DSObjectTableEntry
{
   //
   // The objectClass of the object to be created or modified
   //
   PCWSTR pszObjectClass;

   //
   // The command line string used to determine the object class
   // This is not always identical to pszObjectClass
   //
   PCWSTR pszCommandLineObjectType;

   //
   // The table to merge with the common switches for the parser
   //
   ARG_RECORD* pParserTable;

   //
   // The ID of the Usage help text for this 
   //
   UINT nUsageID;

   //
   // A count of the number of attributes in the table above
   //
   DWORD dwAttributeCount;

   //
   // A pointer to a table of attributes that can be modified or set on this class
   //
   _DSAttributeTableEntry** pAttributeTable; 

   // Some sort of creation function
} DSOBJECTTABLEENTRY, *PDSOBJECTTABLEENTRY;

//+-------------------------------------------------------------------------
// 
//  Type:      PATTRIBUTEEVALFUNC
//
//  Synopsis:  The definition of a function that prepares the command line
//             string value to be set in the DS.
//
//  Note:      *ppAttr should be set to NULL if this function does not need
//             to create a new unique ADS_ATTR_INFO structure in the array
//             to be set on the object.  For instance, there are many bits
//             in the user account control that are represented by different
//             command line flags but we really only need one entry for the
//             userAccountControl attribute.
//
//  Returns:   S_OK if the pAttr members were successfully set.
//             S_FALSE if the function failed but displayed its own error message. 
//             If the return value is S_FALSE then the function should call
//             SetLastError() with the error code.
//             Otherwise the pAttr info will not be used when making 
//             the modifications to the object and an error will be reported
//
//  History:   08-Sep-2000    JeffJon     Created
//
//---------------------------------------------------------------------------
typedef HRESULT (*PATTRIBUTEEVALFUNC)(PCWSTR pszPath,
                                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                                      const CDSCmdCredentialObject& refCredentialObject,
                                      const PDSOBJECTTABLEENTRY pObjectEntry, 
                                      const ARG_RECORD& argRecord,
                                      DWORD dwAttributeIdx,
                                      PADS_ATTR_INFO* ppAttr);

//+--------------------------------------------------------------------------
//
// Flags for the _DSAttributeDescription and _DSAttributeTableEntry 
// struct dwFlags field
//
//---------------------------------------------------------------------------
#define  DS_ATTRIBUTE_DIRTY         0x00000001
#define  DS_ATTRIBUTE_READ          0x00000002
#define  DS_ATTRIBUTE_ONCREATE      0x00000004
#define  DS_ATTRIBUTE_POSTCREATE    0x00000008
#define  DS_ATTRIBUTE_REQUIRED      0x00000010
#define  DS_ATTRIBUTE_NOT_REUSABLE  0x00000020

//+--------------------------------------------------------------------------
//
//  Struct:     _DSAttributeDescription
//
//  Purpose:    Definition of a table entry that describes an attribute
//              This was split out from _DSAttributeTableEntry so that 
//              more than one entry could point to the same attribute.
//              For instance, the userAccountControl bits are separate
//              command line flags but all use the same attribute.  This
//              way we only need to read the attribute once and set it once.
//
//  History:    13-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
typedef struct _DSAttributeDescription
{
   //
   // The ADS_ATTR_INFO struct that defines how this attribute will be set
   //
   ADS_ATTR_INFO  adsAttrInfo;

   //
   // Flags that are used to determine how and when the attribute can be set,
   // if the adsAttrInfo has been retrieved and/or set.
   // For instance, group membership can only be set after the user object is
   // created
   //
   DWORD          dwFlags;      
} DSATTRIBUTEDESCRIPTION, *PDSATTRIBUTEDESCRIPTION;

//+--------------------------------------------------------------------------
//
//  Struct:     _DSAttributeTableEntry
//
//  Purpose:    Definition of a table entry that describes an attribute
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
typedef struct _DSAttributeTableEntry
{
   //
   // The name of the attribute
   //
   PWSTR          pszName;

   //
   // The unique identifier for this attribute that cooresponds to
   // the command line switch
   //
   UINT           nAttributeID;

   //
   // Flags that represent when this attribute can be set in relation to
   // the objects creation
   //
   DWORD          dwFlags;

   //
   // Pointer to the description of the attribute
   //
   PDSATTRIBUTEDESCRIPTION pAttrDesc;

   //
   // A function that can evaluate the value string passed in and make
   // it ready for setting on the object
   //
   PATTRIBUTEEVALFUNC pEvalFunc;

   //
   // Undefined data that is static and specific for the entry
   //
   void* pVoid;

} DSATTRIBUTETABLEENTRY, *PDSATTRIBUTETABLEENTRY;


//+--------------------------------------------------------------------------
//
//  Function:   ReadGroupType
//
//  Synopsis:   Reads the group type from the group specified by the given DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [plType - OUT]        : returns the currect group type
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ReadGroupType(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      long* plType);

//+--------------------------------------------------------------------------
// Function to be used in the attribute table for evaluating the command line
// strings
//---------------------------------------------------------------------------

HRESULT FillAttrInfoFromObjectEntry(PCWSTR pszDN,
                                    const CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    const PDSOBJECTTABLEENTRY pObjectEntry,
                                    const ARG_RECORD& argRecord,
                                    DWORD dwAttributeIdx,
                                    PADS_ATTR_INFO* ppAttr);

HRESULT ResetUserPassword(PCWSTR pszDN,
                          const CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          const PDSOBJECTTABLEENTRY pObjectEntry,
                          const ARG_RECORD& argRecord,
                          DWORD dwAttributeIdx,
                          PADS_ATTR_INFO* ppAttr);

HRESULT ResetComputerAccount(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD dwAttributeIdx,
                             PADS_ATTR_INFO* ppAttr);

HRESULT DisableAccount(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredentialObject,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr);

HRESULT SetMustChangePwd(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr);

HRESULT ChangeMustChangePwd(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr);

HRESULT PwdNeverExpires(PCWSTR pszDN,
                        const CDSCmdBasePathsInfo& refBasePathsInfo,
                        const CDSCmdCredentialObject& refCredentialObject,
                        const PDSOBJECTTABLEENTRY pObjectEntry,
                        const ARG_RECORD& argRecord,
                        DWORD dwAttributeIdx,
                        PADS_ATTR_INFO* ppAttr);

HRESULT ReversiblePwd(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      const PDSOBJECTTABLEENTRY pObjectEntry,
                      const ARG_RECORD& argRecord,
                      DWORD dwAttributeIdx,
                      PADS_ATTR_INFO* ppAttr);

HRESULT AccountExpires(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredentialObject,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr);

HRESULT SetCanChangePassword(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD dwAttributeIdx,
                             PADS_ATTR_INFO* ppAttr);

HRESULT ChangeCanChangePassword(PCWSTR pszDN,
                                const CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                const PDSOBJECTTABLEENTRY pObjectEntry,
                                const ARG_RECORD& argRecord,
                                DWORD dwAttributeIdx,
                                PADS_ATTR_INFO* ppAttr);

HRESULT SetGroupScope(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      const PDSOBJECTTABLEENTRY pObjectEntry,
                      const ARG_RECORD& argRecord,
                      DWORD dwAttributeIdx,
                      PADS_ATTR_INFO* ppAttr);

HRESULT ChangeGroupScope(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr);

HRESULT SetGroupSecurity(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr);

HRESULT ChangeGroupSecurity(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr);

HRESULT ModifyGroupMembers(PCWSTR pszDN,
                           const CDSCmdBasePathsInfo& refBasePathsInfo,
                           const CDSCmdCredentialObject& refCredentialObject,
                           const PDSOBJECTTABLEENTRY pObjectEntry,
                           const ARG_RECORD& argRecord,
                           DWORD dwAttributeIdx,
                           PADS_ATTR_INFO* ppAttr);

HRESULT RemoveGroupMembers(PCWSTR pszDN,
                           const CDSCmdBasePathsInfo& refBasePathsInfo,
                           const CDSCmdCredentialObject& refCredentialObject,
                           const PDSOBJECTTABLEENTRY pObjectEntry,
                           const ARG_RECORD& argRecord,
                           DWORD dwAttributeIdx,
                           PADS_ATTR_INFO* ppAttr);

HRESULT MakeMemberOf(PCWSTR pszDN,
                     const CDSCmdBasePathsInfo& refBasePathsInfo,
                     const CDSCmdCredentialObject& refCredentialObject,
                     const PDSOBJECTTABLEENTRY pObjectEntry,
                     const ARG_RECORD& argRecord,
                     DWORD dwAttributeIdx,
                     PADS_ATTR_INFO* ppAttr);

HRESULT BuildComputerSAMName(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD dwAttributeIdx,
                             PADS_ATTR_INFO* ppAttr);

HRESULT BuildGroupSAMName(PCWSTR pszDN,
                          const CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          const PDSOBJECTTABLEENTRY pObjectEntry,
                          const ARG_RECORD& argRecord,
                          DWORD dwAttributeIdx,
                          PADS_ATTR_INFO* ppAttr);

HRESULT FillAttrInfoFromObjectEntryExpandUsername(PCWSTR pszDN,
                                                  const CDSCmdBasePathsInfo& refBasePathsInfo,
                                                  const CDSCmdCredentialObject& refCredentialObject,
                                                  const PDSOBJECTTABLEENTRY pObjectEntry,
                                                  const ARG_RECORD& argRecord,
                                                  DWORD dwAttributeIdx,
                                                  PADS_ATTR_INFO* ppAttr);

HRESULT SetComputerAccountType(PCWSTR pszDN,
                               const CDSCmdBasePathsInfo& refBasePathsInfo,
                               const CDSCmdCredentialObject& refCredentialObject,
                               const PDSOBJECTTABLEENTRY pObjectEntry,
                               const ARG_RECORD& argRecord,
                               DWORD dwAttributeIdx,
                               PADS_ATTR_INFO* ppAttr);

HRESULT SetIsGC(PCWSTR pszDN,
                const CDSCmdBasePathsInfo& refBasePathsInfo,
                const CDSCmdCredentialObject& refCredentialObject,
                const PDSOBJECTTABLEENTRY pObjectEntry,
                const ARG_RECORD& argRecord,
                DWORD dwAttributeIdx,
                PADS_ATTR_INFO* ppAttr);

//+--------------------------------------------------------------------------
//
//  Function:   EvaluateMustChangePassword
//
//  Synopsis:   
//
//  Arguments:  [pszDN - IN] : DN of the object to check
//              [refBasePathsInfo - IN] : reference to the base paths info
//              [refCredentialObject - IN] : reference to the credential manangement object
//              [bMustChangePassword - OUT] : true if the user must change their
//                                            password at next logon, false otherwise
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT EvaluateMustChangePassword(PCWSTR pszDN,
                                   const CDSCmdBasePathsInfo& refBasePathsInfo,
                                   const CDSCmdCredentialObject& refCredentialObject,
                                   bool& bMustChangePassword);


//+--------------------------------------------------------------------------
//
//  Function:   EvaluateCanChangePasswordAces
//
//  Synopsis:   Looks for explicit entries in the ACL to see if the user can
//              change their password
//
//  Arguments:  [pszDN - IN] : DN of the object to check
//              [refBasePathsInfo - IN] : reference to the base paths info
//              [refCredentialObject - IN] : reference to the credential manangement object
//              [bCanChangePassword - OUT] : false if there are explicit entries
//                                           that keep the user from changing their
//                                           password.  true otherwise.
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT EvaluateCanChangePasswordAces(PCWSTR pszDN,
                                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                                      const CDSCmdCredentialObject& refCredentialObject,
                                      bool& bCanChangePassword);

//+--------------------------------------------------------------------------
//
//  Enumeration:  FSMO_TYPE
//
//  Synopsis:     The types of FSMO owners
//
//---------------------------------------------------------------------------
enum FSMO_TYPE
{
  SCHEMA_FSMO,
  RID_POOL_FSMO,
  PDC_FSMO,
  INFRASTUCTURE_FSMO,
  DOMAIN_NAMING_FSMO,
};

//+--------------------------------------------------------------------------
//
//  Function:   BindToFSMOHolder
//
//  Synopsis:   Binds to the appropriate object which can be used to find a
//              particular FSMO owner
//
//  Arguments:  [refBasePathsInfo - IN] : reference to the base paths info object
//              [refCredObject - IN]    : reference to the credential management object
//              [fsmoType - IN]         : type of the FSMO we are searching for
//              [refspIADs - OUT]       : interface to the object that will be
//                                        used to start a search for the FSMO owner
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    13-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BindToFSMOHolder(IN  const CDSCmdBasePathsInfo&       refBasePathsInfo,
                         IN  const CDSCmdCredentialObject& refCredObject,
                         IN  FSMO_TYPE                  fsmoType,
                         OUT CComPtr<IADs>&             refspIADs);

//+--------------------------------------------------------------------------
//
//  Function:   FindFSMOOwner
//
//  Synopsis:   
//
//  Arguments:  [refBasePathsInfo - IN] : reference to the base paths info object
//              [refCredObject - IN]    : reference to the credential management object
//              [fsmoType - IN]         : type of the FSMO we are searching for
//              [refspIADs - OUT]       : interface to the object that will be
//                                        used to start a search for the FSMO owner
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    13-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT FindFSMOOwner(IN  const CDSCmdBasePathsInfo&       refBasePathsInfo,
                      IN  const CDSCmdCredentialObject& refCredObject,
                      IN  FSMO_TYPE                  fsmoType,
                      OUT CComBSTR&                  refsbstrServer);


//+--------------------------------------------------------------------------
//
//  Function:   ValidateAndModifySAMName
//
//  Synopsis:   Looks for any illegal characters in the SamAccountName and
//              converts them to the replacementChar
//
//  Arguments:  [pszSAMName - IN/OUT]  : pointer to a string that contains the SamAccountName
//                                       illegal characters will be replaced
//              [pszInvalidChars - IN] : string containing the illegal characters
//
//  Returns:    HRESULT : S_OK if the name was valid and no characters had to be replaced
//                        S_FALSE if the name contained invalid characters that were replaced
//                        E_INVALIDARG
//
//  History:    21-Feb-2001   JeffJon   Created
//
//---------------------------------------------------------------------------

#define INVALID_NETBIOS_AND_ACCOUNT_NAME_CHARS_WITH_AT ILLEGAL_FAT_CHARS L".@"

HRESULT ValidateAndModifySAMName(PWSTR pszSAMName, 
                                 PCWSTR pszInvalidChars);

//+--------------------------------------------------------------------------
//
//  Class:      GetOutputDN
//
//  Purpose:    Converts an ADSI-escaped DN to one with DSCMD input escaping.
//              This way, the output DN can be piped as input to another
//              DSCMD command.
//
//  History:    08-May-2001 JonN     Created
//
//---------------------------------------------------------------------------
HRESULT GetOutputDN( OUT BSTR* pbstrOut, IN PCWSTR pszIn );

#endif //_DSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsUtil.cpp
//
//  Contents:  Utility functions for working with Active Directory
//
//  History:   06-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "dsutil.h"
#include "dsutil2.h" // GetEscapedElement
#include "dsutilrc.h"
#include "cstrings.h"
#include "secutil.h"

#include <accctrl.h>  // OBJECTS_AND_SID
#include <aclapi.h>   // GetNamedSecurityInfo etc.
#include <lmaccess.h> // UF_*  userAccountControl bits
#include <ntsam.h>    // GROUP_TYPE_*


//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::CDSCmdCredentialObject
//
//  Synopsis:   Constructor for the credential management class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CDSCmdCredentialObject::CDSCmdCredentialObject()
   : m_pszPassword(0),
     m_bUsingCredentials(false)
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::~CDSCmdCredentialObject
//
//  Synopsis:   Destructor for the credential management class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CDSCmdCredentialObject::~CDSCmdCredentialObject()
{
   if (m_pszPassword)
   {
      free(m_pszPassword);
      m_pszPassword = 0;
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::SetUsername
//
//  Synopsis:   Encodes the passed in string and sets the m_pszPassword
//              member data.
//
//  Arguments:  [pszPassword] : unencoded password
//
//  Returns:    HRESULT : E_OUTOFMEMORY if we failed to allocate space
//                                      for the new password
//                        E_POINTER if the string passed in is not valid
//                        S_OK if we succeeded in setting the password
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSCmdCredentialObject::SetUsername(PCWSTR pszUsername)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CDSCmdCredentialObject::SetUsername, hr);

   do // false loop
   {
      //
      // Verify the input parameters
      //
      if (!pszUsername)
      {
         hr = E_POINTER;
         break;
      }

      //
      // Copy the new username
      //
      m_sbstrUsername = pszUsername;
      DEBUG_OUTPUT(FULL_LOGGING, L"Username = %s", pszUsername);
   } while (false);

   return hr;
}

//
// A prime number used to seed the encoding and decoding
//
#define NW_ENCODE_SEED3  0x83


//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::SetPassword
//
//  Synopsis:   Encodes the passed in string and sets the m_pszPassword
//              member data.
//
//  Arguments:  [pszPassword] : unencoded password
//
//  Returns:    HRESULT : E_OUTOFMEMORY if we failed to allocate space
//                                      for the new password
//                        S_OK if we succeeded in setting the password
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSCmdCredentialObject::SetPassword(PCWSTR pszPassword)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CDSCmdCredentialObject::SetPassword, hr);

   do // false loop
   {
	   UNICODE_STRING Password;

      //
      // Free the previously allocated password if there was one
      //
	   if (m_pszPassword) 
	   {
		   free(m_pszPassword);
		   m_pszPassword = 0;
	   }

	   UCHAR Seed = NW_ENCODE_SEED3;
	   Password.Length = 0;

      //
      // Allocate space for the new encoded password
      //
	   m_pszPassword = (PWSTR)malloc(sizeof(WCHAR) * (MAX_PASSWORD_LENGTH + 1));
	   if(!m_pszPassword) 
	   {
         DEBUG_OUTPUT(FULL_LOGGING, L"Failed to allocate memory for the new password");
		   hr = E_OUTOFMEMORY;
         break;
	   }

      //
      // Copy the unencoded password
      //
	   wcscpy(m_pszPassword, pszPassword);

      DEBUG_OUTPUT(FULL_LOGGING, L"Password = %s", pszPassword);

      //
      // Encode the password in-place
      //
	   RtlInitUnicodeString(&Password, m_pszPassword);
	   RtlRunEncodeUnicodeString(&Seed, &Password);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdCredentialObject::GetPassword
//
//  Synopsis:   Unencodes the password member and returns a string in the
//              provided buffer with the clear text password.
//
//  Arguments:  [pszBuffer - IN]   : buffer to receive the clear text password
//              [pnWCharCount - IN/OUT] : count of the number of wide characters 
//                                   the buffer can take including the NULL 
//                                   terminator. If the buffer is too small,
//                                   the amount needed is returned.
//
//  Returns:    HRESULT : E_INVALIDARG if the buffer is not valid
//                        E_OUTOFMEMORY if the buffer is too small
//                        E_FAIL if the password has not been set
//                        S_OK if we succeeded in getting the password
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT CDSCmdCredentialObject::GetPassword(PWSTR pszBuffer, UINT* pnWCharCount) const
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CDSCmdCredentialObject::GetPassword, hr);

   do // false loop
   {
	    UNICODE_STRING Password;
	    UCHAR Seed = NW_ENCODE_SEED3;

	    Password.Length = 0;

      //
      // Verify input parameters
      //
	    if (!pszBuffer ||
          !pnWCharCount) 
	    {
         ASSERT(pszBuffer);
         ASSERT(pnWCharCount);

         hr = E_INVALIDARG;
         break;
	    }

      //
      // Verify there is a password to retrieve
      //
      if (!m_pszPassword) 
      {
         DEBUG_OUTPUT(FULL_LOGGING, L"No password has been set");
         hr = E_FAIL;
         break;
      }

      //
      // Check to see if the buffer is large enough
      //
      UINT uLen = static_cast<UINT>(wcslen(m_pszPassword));
      if (uLen + 1 > *pnWCharCount)
      {
         *pnWCharCount = uLen + 1;

         DEBUG_OUTPUT(FULL_LOGGING, L"Failed to allocate enough memory for the password");
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Copy the encoded password into the buffer
      //
	    wcscpy(pszBuffer, m_pszPassword);

      //
      // Decode the buffer in place
      //
      RtlInitUnicodeString(&Password, pszBuffer);
      RtlRunDecodeUnicodeString(Seed, &Password);
   } while (false);

   return hr;
}

////////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::CDSCmdBasePathsInfo
//
//  Synopsis:   Constructor for the base paths management class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CDSCmdBasePathsInfo::CDSCmdBasePathsInfo()
   : m_bInitialized(false),
     m_bModeInitialized(false),
     m_bDomainMode(true)
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::~CDSCmdBasePathsInfo
//
//  Synopsis:   Destructor for the base paths management class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CDSCmdBasePathsInfo::~CDSCmdBasePathsInfo()
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::InitializeFromName
//
//  Synopsis:   Initializes all the member strings for the well known
//              naming contexts by connecting to the RootDSE of the server or
//              domain that is passed in.
//
//  Arguments:  [refCredentialObject - IN] : a reference to the credential manager
//              [pszServerOrDomain - IN] : a NULL terminated wide character string
//                                         that contains the name of the domain or
//                                         server to connect to
//              [bServerName - IN]       : Specifies whether the name given by 
//                                         pszServerOrDomain is a server name (true)
//                                         or a domain name (false)
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_OUTOFMEMORY if an allocation for one of the strings
//                                      failed
//                        Anything else is a failure code from an ADSI call
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSCmdBasePathsInfo::InitializeFromName(const CDSCmdCredentialObject& refCredentialObject,
                                                PCWSTR pszServerOrDomain,
                                                bool bServerName)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, CDSCmdBasePathsInfo::InitializeFromName, hr);

   do // false loop
   {
      //
      // Check to see if we are already initialized
      //
      if (IsInitialized())
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Base paths info already initialized");
         break;
      }
   
      //
      // Create the path to the RootDSE
      //
      CComBSTR sbstrRootDSE;
      sbstrRootDSE = g_bstrLDAPProvider;
   
      if (pszServerOrDomain)
      {
         sbstrRootDSE += pszServerOrDomain;
         sbstrRootDSE += L"/";
      }
      sbstrRootDSE += g_bstrRootDSE;

      //
      // Now sbstrRootDSE should either be in the form "LDAP://<serverOrDomain>/RootDSE"
      // or "LDAP://RootDSE"
      //

      //
      // Bind to the RootDSE
      //
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrRootDSE,
                           IID_IADs,
                           (void**)&m_spRootDSE,
                           false);
      if (FAILED(hr))
      {
         break;
      }

      if (bServerName)
      {
         m_sbstrServerName = pszServerOrDomain;
      }
      else
      {
         //
         // Get the configuration naming context
         //
         CComVariant var;
         hr = m_spRootDSE->Get(g_bstrConfigNCProperty, &var);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to get the Configuration Naming Context: hr = 0x%x", hr);
            break;
         }
         if (var.vt != VT_BSTR)
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"The variant returned from Get(Config) isn't a VT_BSTR!");
            hr = E_FAIL;
            break;
         }
         m_sbstrConfigNamingContext = var.bstrVal;
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"ConfigNC = %s", m_sbstrConfigNamingContext);

         //
         // Get the server name that we are connected to
         //

         //
         // Create the path to the config naming context
         //
         CComBSTR sbstrConfigPath;
         sbstrConfigPath = g_bstrLDAPProvider;
         if (pszServerOrDomain)
         {
            sbstrConfigPath += pszServerOrDomain;
            sbstrConfigPath += L"/";
         }
         sbstrConfigPath += m_sbstrConfigNamingContext;

         //
         // Bind to the configuration container
         //
         CComPtr<IADsObjectOptions> spIADsObjectOptions;
         hr = DSCmdOpenObject(refCredentialObject,
                              sbstrConfigPath,
                              IID_IADsObjectOptions, 
                              (void**)&spIADsObjectOptions,
                              false);
         if (FAILED(hr))
         {
            break;
         }

         //
         // Retrieve the server name
         //
         var.Clear();
         hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to get the server name: hr = 0x%x", hr);
            break;
         }

         if (var.vt != VT_BSTR)
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"The variant returned from GetOption isn't a VT_BSTR!");
            hr = E_FAIL;
            break;
         }

         //
         // Store the server name
         //
         m_sbstrServerName = V_BSTR(&var);
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Server name = %s", m_sbstrServerName);
      }

      //
      // Create the provider plus server name string
      //
      m_sbstrProviderAndServerName = g_bstrLDAPProvider;
      m_sbstrProviderAndServerName += m_sbstrServerName;

      m_sbstrGCProvider = g_bstrGCProvider;

      m_bInitialized = true;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::GetConfigurationNamingContext
//
//  Synopsis:   Returns the the DN of the Configuration container
//
//  Arguments:  
//
//  Returns:    CComBSTR : A copy of the CComBSTR containing the string
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CComBSTR  CDSCmdBasePathsInfo::GetConfigurationNamingContext() const
{ 
   ENTER_FUNCTION(LEVEL5_LOGGING, CDSCmdBasePathsInfo::GetConfigurationNamingContext);
   if (IsInitialized() &&
       !m_sbstrConfigNamingContext.Length())
   {
      //
      // Get the configuration naming context
      //
      CComVariant var;
      HRESULT hr = m_spRootDSE->Get(g_bstrConfigNCProperty, &var);
      if (SUCCEEDED(hr) &&
          var.vt == VT_BSTR)
      {
         m_sbstrConfigNamingContext = var.bstrVal;
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"ConfigNC = %s", m_sbstrConfigNamingContext);
      }
      else
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to retrieve the ConfigNC: hr = 0x%x", hr);
      }
   }
   return m_sbstrConfigNamingContext; 
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::GetSchemaNamingContext
//
//  Synopsis:   Returns the the DN of the Schema container
//
//  Arguments:  
//
//  Returns:    CComBSTR : A copy of the CComBSTR containing the string
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CComBSTR  CDSCmdBasePathsInfo::GetSchemaNamingContext() const    
{ 
   ENTER_FUNCTION(LEVEL5_LOGGING, CDSCmdBasePathsInfo::GetSchemaNamingContext);
   if (IsInitialized() &&
       !m_sbstrSchemaNamingContext.Length())
   {
      //
      // Get the schema naming context
      //
      CComVariant var;
      HRESULT hr = m_spRootDSE->Get(g_bstrSchemaNCProperty, &var);
      if (SUCCEEDED(hr) &&
          var.vt == VT_BSTR)
      {
         m_sbstrSchemaNamingContext = var.bstrVal;
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"SchemaNC = %s", m_sbstrConfigNamingContext);
      }
      else
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to retrieve the SchemaNC: hr = 0x%x", hr);
      }
   }
   return m_sbstrSchemaNamingContext; 
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::GetDefaultNamingContext
//
//  Synopsis:   Returns the the DN of the Domain
//
//  Arguments:  
//
//  Returns:    CComBSTR : A copy of the CComBSTR containing the string
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CComBSTR  CDSCmdBasePathsInfo::GetDefaultNamingContext() const    
{ 
   ENTER_FUNCTION(LEVEL5_LOGGING, CDSCmdBasePathsInfo::GetDefaultNamingContext);
   if (IsInitialized() &&
       !m_sbstrDefaultNamingContext.Length())
   {
      //
      // Get the schema naming context
      //
      CComVariant var;
      HRESULT hr = m_spRootDSE->Get(g_bstrDefaultNCProperty, &var);
      if (SUCCEEDED(hr) &&
          var.vt == VT_BSTR)
      {
         m_sbstrDefaultNamingContext = var.bstrVal;
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"DefaultNC = %s", m_sbstrDefaultNamingContext);
      }
      else
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Failed to retrieve the DefaultNC: hr = 0x%x", hr);
      }
   }
   return m_sbstrDefaultNamingContext; 
}

//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::GetDomainMode
//
//  Synopsis:   Figures out if the domain is in mixed or native mode
//
//  Arguments:  [refCredObject - IN] : reference to the credential manager
//              [bMixedMode - OUT]   : Is the domain in mixed mode?
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI error
//
//  History:    24-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSCmdBasePathsInfo::GetDomainMode(const CDSCmdCredentialObject& refCredObject,
                                           bool& bMixedMode) const    
{ 
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, CDSCmdBasePathsInfo::GetDomainMode, hr);

   hr = S_OK;

   do // false loop
   {
      if (!m_bModeInitialized)
      {
         //
         // Get the path to the domainDNS node
         //
         CComBSTR sbstrDomainDN;
         sbstrDomainDN = GetDefaultNamingContext();

         CComBSTR sbstrDomainPath;
         ComposePathFromDN(sbstrDomainDN, sbstrDomainPath);

         //
         // Open the domainDNS node
         //
         CComPtr<IADs> spADs;
         hr = DSCmdOpenObject(refCredObject,
                              sbstrDomainPath,
                              IID_IADs,
                              (void**)&spADs,
                              true);
         if (FAILED(hr))
         {
            break;
         }

         CComVariant var;
         hr = spADs->Get(L"nTMixedDomain", &var);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"Failed to retrieve the domain mode: hr = 0x%x",
                         hr);
            break;
         }

         if (var.vt == VT_I4)
         {
            m_bDomainMode = (var.lVal != 0);
            m_bModeInitialized = true;
         }
         else
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"Variant not an VT_I4!");
            m_bDomainMode = true;
            m_bModeInitialized = true;
         }
      }

      bMixedMode = m_bDomainMode;
   } while (false);

   return hr; 
}


//+--------------------------------------------------------------------------
//
//  Member:     CDSCmdBasePathsInfo::ComposePathFromDN
//
//  Synopsis:   Appends the DN to the provider and server name
//
//  Arguments:  [pszDN - IN]    : pointer to a NULL terminated wide character string
//                                that contains the DN of the object to make the ADSI
//                                path to
//              [refsbstrPath - OUT] : reference to a CComBSTR that will take
//                                     the full ADSI path 
//              [nProviderType - OPTIONAL IN] : Option to specify which provider
//                                              to compose the path with
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDSCmdBasePathsInfo::ComposePathFromDN(PCWSTR pszDN, 
                                            CComBSTR& refsbstrPath,
                                            DSCMD_PROVIDER_TYPE nProviderType) const
{
   refsbstrPath.Empty();

   switch (nProviderType)
   {
   case DSCMD_LDAP_PROVIDER :
      refsbstrPath = GetProviderAndServerName();
      break;

   case DSCMD_GC_PROVIDER :
      refsbstrPath = GetGCProvider();
      break;

   default :
      ASSERT(FALSE);
      break;
   }

   refsbstrPath += L"/";
   refsbstrPath += pszDN;
}


//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::CPathCracker
//
//  Synopsis:   Constructor for the path cracker IADsPathname wrapper
//
//  Arguments:  
//
//  Returns:    
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CPathCracker::CPathCracker()
{
   m_hrCreate = Init();
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::Init
//
//  Synopsis:   Called by the constructor to create the IADsPathname object
//              and store it in the m_spIADsPathname member
//
//  Arguments:  
//
//  Returns:    HRESULT : the value returned from the CoCreateInstance
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::Init()
{
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, 
                                   NULL, 
                                   CLSCTX_INPROC_SERVER,
                                   IID_IADsPathname, 
                                   (void**)&(m_spIADsPathname));
   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::GetParentDN
//
//  Synopsis:   Simply removes the leaf part of the DN
//
//  Arguments:  [pszDN - IN] : pointer to a NULL terminated wide string that
//                             contains the DN of the child
//              [refsbstrDN - OUT] : reference to a CComBSTR that is to 
//                                   receive the parent DN.
//
//  Returns:    HRESULT : S_OK if successful, otherwise the value returned 
//                        from the IADsPathname methods
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::GetParentDN(PCWSTR pszDN,
                                  CComBSTR& refsbstrDN)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CPathCracker::GetParentDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      refsbstrDN.Empty();

      CPathCracker pathCracker;
      hr = pathCracker.Set((BSTR)pszDN, ADS_SETTYPE_DN);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.RemoveLeafElement();
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &refsbstrDN);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::GetObjectRDNFromDN
//
//  Synopsis:   Returns the leaf part of the DN
//
//  Arguments:  [pszDN - IN] : pointer to a NULL terminated wide string that
//                             contains the DN of the child
//              [refsbstrRDN - OUT] : reference to a CComBSTR that is to 
//                             receive the leaf RDN.
//
//  Returns:    HRESULT : S_OK if successful, otherwise the value returned 
//                        from the IADsPathname methods
//
//  History:    25-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::GetObjectRDNFromDN(PCWSTR pszDN,
                                         CComBSTR& refsbstrRDN)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CPathCracker::GetObjectRDNFromDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      refsbstrRDN.Empty();

      CPathCracker pathCracker;
      hr = pathCracker.Set((BSTR)pszDN, ADS_SETTYPE_DN);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.Retrieve(ADS_FORMAT_LEAF, &refsbstrRDN);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::GetObjectNameFromDN
//
//  Synopsis:   Returns the value of the leaf part of the DN
//
//  Arguments:  [pszDN - IN] : pointer to a NULL terminated wide string that
//                             contains the DN of the child
//              [refsbstrRDN - OUT] : reference to a CComBSTR that is to 
//                             receive the leaf Name.
//
//  Returns:    HRESULT : S_OK if successful, otherwise the value returned 
//                        from the IADsPathname methods
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::GetObjectNameFromDN(PCWSTR pszDN,
                                          CComBSTR& refsbstrRDN)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CPathCracker::GetObjectNameFromDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      refsbstrRDN.Empty();

      CPathCracker pathCracker;
      hr = pathCracker.Set((BSTR)pszDN, ADS_SETTYPE_DN);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.Retrieve(ADS_FORMAT_LEAF, &refsbstrRDN);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathCracker::GetDNFromPath
//
//  Synopsis:   Returns the DN when given and ADSI path
//
//  Arguments:  [pszPath - IN] : pointer to a NULL terminated wide string that
//                               contains the ADSI path of the object
//              [refsbstrDN - OUT] : reference to a CComBSTR that is to 
//                             receive the DN.
//
//  Returns:    HRESULT : S_OK if successful, otherwise the value returned 
//                        from the IADsPathname methods
//
//  History:    24-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CPathCracker::GetDNFromPath(PCWSTR pszPath,
                                    CComBSTR& refsbstrDN)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, CPathCracker::GetDNFromPath, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszPath)
      {
         ASSERT(pszPath);
         hr = E_INVALIDARG;
         break;
      }

      refsbstrDN.Empty();

      CPathCracker pathCracker;
      hr = pathCracker.Set((BSTR)pszPath, ADS_SETTYPE_FULL);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      if (FAILED(hr))
      {
         break;
      }

      hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &refsbstrDN);
   } while (false);

   return hr;
}

///////////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Function:   DSCmdOpenObject
//
//  Synopsis:   A wrapper around ADsOpenObject
//
//  Arguments:  [refCredentialObject - IN] : a reference to a credential management object
//              [pszPath - IN]           : a pointer to a NULL terminated wide character
//                                         string that contains the ADSI path of the
//                                         object to connect to
//              [refIID - IN]            : the interface ID of the interface to return
//              [ppObject - OUT]         : a pointer which is to receive the interface pointer
//              [bBindToServer - IN]     : true if the path contains a server name,
//                                         false otherwise
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Anything else is a failure code from an ADSI call
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DSCmdOpenObject(const CDSCmdCredentialObject& refCredentialObject,
                        PCWSTR pszPath,
                        REFIID refIID,
                        void** ppObject,
                        bool   bBindToServer)
{
   ENTER_FUNCTION_HR(FULL_LOGGING, DSCmdOpenObject, hr);

   do // false loop
   {
      DWORD dwFlags = ADS_SECURE_AUTHENTICATION;

      if (!pszPath ||
          !ppObject)
      {
         ASSERT(pszPath);
         ASSERT(ppObject);

         hr = E_INVALIDARG;
         break;
      }

      if (bBindToServer)
      {
         //
         // If we know we are connecting to a specific server and not domain in general
         // then pass the ADS_SERVER_BIND flag to save ADSI the trouble of figuring it out
         //
         dwFlags |= ADS_SERVER_BIND;
         DEBUG_OUTPUT(FULL_LOGGING, L"Using ADS_SERVER_BIND flag");
      }

      if (refCredentialObject.UsingCredentials())
      {
         DEBUG_OUTPUT(FULL_LOGGING, L"Using credentials");

         WCHAR szPasswordBuffer[MAX_PASSWORD_LENGTH];
         UINT sBufferSize = static_cast<UINT>(sizeof(szPasswordBuffer));
         hr = refCredentialObject.GetPassword(szPasswordBuffer, 
                                              &sBufferSize);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(FULL_LOGGING, L"GetPassword failed: hr = 0x%x", hr);
            DEBUG_OUTPUT(FULL_LOGGING, L"Using NULL password.");
            ZeroMemory(&szPasswordBuffer, sizeof(szPasswordBuffer));
         }

         DEBUG_OUTPUT(FULL_LOGGING, L"Calling ADsOpenObject()");
         DEBUG_OUTPUT(FULL_LOGGING, L"  path = %s", pszPath);

         hr = ADsOpenObject((LPWSTR)pszPath,
                            refCredentialObject.GetUsername(),
                            szPasswordBuffer,
                            dwFlags,
                            refIID,
                            ppObject);

         //
         // If we failed with E_INVALIDARG and we were using ADS_SERVER_BIND
         // try calling again without the ADS_SERVER_BIND flag.  W2K did not have
         // this flag available until SP1.
         //
         if (hr == E_INVALIDARG &&
             (dwFlags & ADS_SERVER_BIND))
         {
            DEBUG_OUTPUT(FULL_LOGGING, L"ADsOpenObject failed with E_INVALIDARG, trying again without ADS_SERVER_BIND");
            dwFlags &= ~ADS_SERVER_BIND;

            hr = ADsOpenObject((LPWSTR)pszPath,
                               refCredentialObject.GetUsername(),
                               szPasswordBuffer,
                               dwFlags,
                               refIID,
                               ppObject);
         }

         //
         // Make sure to zero out the password after it is used
         //
         ZeroMemory(szPasswordBuffer, sizeof(szPasswordBuffer)); 
      }
      else
      {
         DEBUG_OUTPUT(FULL_LOGGING, L"Calling ADsOpenObject()");
         DEBUG_OUTPUT(FULL_LOGGING, L"  path = %s", pszPath);

         hr = ADsOpenObject((LPWSTR)pszPath, 
                            NULL, 
                            NULL, 
                            dwFlags, 
                            refIID, 
                            ppObject);
         //
         // If we failed with E_INVALIDARG and we were using ADS_SERVER_BIND
         // try calling again without the ADS_SERVER_BIND flag.  W2K did not have
         // this flag available until SP1.
         //
         if (hr == E_INVALIDARG &&
             (dwFlags & ADS_SERVER_BIND))
         {
            DEBUG_OUTPUT(FULL_LOGGING, L"ADsOpenObject failed with E_INVALIDARG, trying again without ADS_SERVER_BIND");
            dwFlags &= ~ADS_SERVER_BIND;

            hr = ADsOpenObject((LPWSTR)pszPath,
                               NULL,
                               NULL,
                               dwFlags,
                               refIID,
                               ppObject);
         }
      }
      DEBUG_OUTPUT(FULL_LOGGING, L"ADsOpenObject() return hr = 0x%x", hr);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
// Function to be used in the attribute table for evaluating the command line
// strings
//---------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Function:   FillAttrInfoFromObjectEntry
//
//  Synopsis:   Fills the ADS_ATTR_INFO from the attribute table associated
//              with the object entry
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]     : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_OUTOFMEMORY if we failed to allocate space for the value
//                        E_FAIL if we failed to format the value properly
//
//  History:    06-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT FillAttrInfoFromObjectEntry(PCWSTR /*pszDN*/,
                                    const CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    const PDSOBJECTTABLEENTRY pObjectEntry,
                                    const ARG_RECORD& argRecord,
                                    DWORD dwAttributeIdx,
                                    PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, FillAttrInfoFromObjectEntry, hr);

   do // false loop
   {
      //
      // Verify Parameters
      //
      if (!pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);

         hr = E_INVALIDARG;
         break;
      }

      switch (argRecord.fType)
      {
      case ARG_TYPE_STR :
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"argRecord.fType = ARG_TYPE_STR");

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

         if (argRecord.strValue && argRecord.strValue[0] != L'\0')
         {
            //
            // REVIEW_JEFFJON : this is being leaked!
            //
            (*ppAttr)->pADsValues = new ADSVALUE[1];
            if ((*ppAttr)->pADsValues)
            {
               (*ppAttr)->dwNumValues = 1;
               (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
               switch ((*ppAttr)->dwADsType)
               {
               case ADSTYPE_DN_STRING :
                  {
                     //
                     // Lets bind to be sure the object exists
                     //
                     CComBSTR sbstrObjPath;
                     refBasePathsInfo.ComposePathFromDN(argRecord.strValue, sbstrObjPath);

                     CComPtr<IADs> spIADs;
                     hr = DSCmdOpenObject(refCredentialObject,
                                          sbstrObjPath,
                                          IID_IADs,
                                          (void**)&spIADs,
                                          true);

                     if (FAILED(hr))
                     {
                        DEBUG_OUTPUT(LEVEL3_LOGGING, L"DN object doesn't exist. %s", argRecord.strValue);
                        break;
                     }

                     (*ppAttr)->pADsValues->DNString = argRecord.strValue;
                     DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_DN_STRING = %s", argRecord.strValue);
                  }
                  break;

               case ADSTYPE_CASE_EXACT_STRING :
                  (*ppAttr)->pADsValues->CaseExactString = argRecord.strValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_CASE_EXACT_STRING = %s", argRecord.strValue);
                  break;

               case ADSTYPE_CASE_IGNORE_STRING :
                  (*ppAttr)->pADsValues->CaseIgnoreString = argRecord.strValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_CASE_IGNORE_STRING = %s", argRecord.strValue);
                  break;

               case ADSTYPE_PRINTABLE_STRING :
                  (*ppAttr)->pADsValues->PrintableString = argRecord.strValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_PRINTABLE_STRING = %s", argRecord.strValue);
                  break;

               default :
                  hr = E_INVALIDARG;
                  break;
               }
               //
               // Set the attribute dirty
               //
               pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
         
            }
            break;
         }
         else
         {
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"No value present, changing control code to ADS_ATTR_CLEAR");
            //
            // Clear the attribute
            //
            (*ppAttr)->dwControlCode = ADS_ATTR_CLEAR;
            (*ppAttr)->dwNumValues = 0;

            //
            // Set the attribute dirty
            //
            pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
         }
         break;

      default:
         hr = E_INVALIDARG;
         break;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ResetObjectPassword
//
//  Synopsis:   Resets the password on any object that supports the IADsUser interface
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pszNewPassword - IN] : pointer to the new password to set
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise its an ADSI failure code
//
//  History:    12-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ResetObjectPassword(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            PCWSTR pszNewPassword)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ResetObjectPassword, hr);

   do // false loop
   {
      if (!pszDN ||
          !pszNewPassword)
      {
         ASSERT(pszDN);
         ASSERT(pszNewPassword);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADsUser interface to the user object
      //
      CComPtr<IADsUser> spUser;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADsUser,
                           (void**)&spUser,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      hr = spUser->SetPassword((BSTR)pszNewPassword);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ResetUserPassword
//
//  Synopsis:   Resets the user's password
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_FAIL if we failed to format the value properly
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ResetUserPassword(PCWSTR pszDN,
                          const CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          const PDSOBJECTTABLEENTRY pObjectEntry,
                          const ARG_RECORD& argRecord,
                          DWORD /*dwAttributeIdx*/,
                          PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ResetUserPassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Don't create a new index in the array of ADS_ATTR_INFO
      //
      *ppAttr = NULL;
      ASSERT(argRecord.bDefined && argRecord.strValue);
   
      hr = ResetObjectPassword(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               argRecord.strValue);
      if (FAILED(hr))
      {
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             hr,
                             IDS_FAILED_SET_PASSWORD);
         hr = S_FALSE;
         break;
      }
   } while (false);

   return hr;
}
/*
//+--------------------------------------------------------------------------
//
//  Function:   ModifyNetWareUserPassword
//
//  Synopsis:   Resets the NetWare user's password
//
//  Arguments:  [pADsUser - IN]       : pointer to IADsUser interface for user object
//              [pwzADsPath - IN]     : path to the user object
//              [pwzNewPassword - IN] : the new password 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise it is the return code from an ADSI call
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ModifyNetWareUserPassword(IADsUser* pADsUser,
                                  PCWSTR pwzADsPath,
                                  PCWSTR pwzNewPassword)
{
   CComPtr<IDirectoryObject> spDsObj;
   HRESULT hr = pADsUser->QueryInterface(IID_IDirectoryObject, reinterpret_cast<void **>(&spDsObj));
   if (FAILED(hr))
   {
      return hr;
   }


   //
   // Check to see if NWPassword exists on the object
   //
   PWSTR pszAttrs[] = { L"NWPassword" };
   PADS_ATTR_INFO pAttrs = NULL;
   DWORD dwAttrsReturned = 0;
   hr = spDsObj->GetObjectAttributes(pszAttrs,
                                     1,
                                     &pAttrs,
                                     dwAttrsReturned);

   if (S_OK == hr && dwAttrsReturned == 1 && pAttrs != NULL)
   {
      //
      // This is a NetWare enabled user
      //

      //
      // load fpnwclnt.dll
      //
      HINSTANCE           hFPNWClntDll = NULL;
      PMapRidToObjectId   pfnMapRidToObjectId = NULL;
      PSwapObjectId       pfnSwapObjectId = NULL;
      PReturnNetwareForm  pfnReturnNetwareForm = NULL;

      hFPNWClntDll = LoadLibrary(SZ_FPNWCLNT_DLL);
      pfnMapRidToObjectId = reinterpret_cast<PMapRidToObjectId>(GetProcAddress(hFPNWClntDll, SZ_MAPRIDTOOBJECTID));
      pfnSwapObjectId = reinterpret_cast<PSwapObjectId>(GetProcAddress(hFPNWClntDll, SZ_SWAPOBJECTID));
      pfnReturnNetwareForm = reinterpret_cast<PReturnNetwareForm>(GetProcAddress(hFPNWClntDll, SZ_RETURNNETWAREFORM));

      if (!hFPNWClntDll || !pfnMapRidToObjectId || !pfnSwapObjectId || !pfnReturnNetwareForm)
      {
         hr = HRESULT_FROM_WIN32( GetLastError() );
      } 
      else 
      {

         // get secret key
         PWSTR pwzPath = NULL;
         hr = SkipLDAPPrefix(pwzADsPath, pwzPath);
         if (SUCCEEDED(hr))
         {
            PWSTR pwzPDCName = NULL, pwzSecretKey = NULL;
            hr = GetPDCInfo(pwzPath, pwzPDCName, pwzSecretKey);

            if (SUCCEEDED(hr))
            {
               // get object id
               CStr cstrUserName;
               DWORD dwObjectID = 0, dwSwappedObjectID = 0;
               hr = GetNWUserInfo(spDsObj,
                                  cstrUserName,       // OUT
                                  dwObjectID,         // OUT
                                  dwSwappedObjectID,  // OUT
                                  pfnMapRidToObjectId,
                                  pfnSwapObjectId);

               if (SUCCEEDED(hr))
               {
                  // change password in the userParms
                  LONG err = SetNetWareUserPassword(cstrUserParms,
                                                    pwzSecretKey,
                                                    dwObjectID,
                                                    pwzNewPassword,
                                                    pfnReturnNetwareForm);

                  if (NERR_Success == err)
                  {
                     err = ResetNetWareUserPasswordTime(cstrUserParms, false); // clear the expire flag
                  }

                  hr = HRESULT_FROM_WIN32(err);

                  // write userParms back to DS
                  if (SUCCEEDED(hr))
                  {
                     hr = WriteUserParms(spDsObj, cstrUserParms);
                  }
               }
            }
            if (pwzPath)
               delete pwzPath;
         }
      }

      if (hFPNWClntDll)
      {
         FreeLibrary(hFPNWClntDll);
      }
   }

   return hr;
}
*/

//+--------------------------------------------------------------------------
//
//  Function:   ResetComputerAccount
//
//  Synopsis:   Resets the computer account
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]     : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    12-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ResetComputerAccount(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD /*dwAttributeIdx*/,
                             PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ResetComputerAccount, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Don't create a new entry in the ADS_ATTR_INFO array
      //
      *ppAttr = NULL;

      ASSERT(argRecord.bDefined && argRecord.strValue);
   
      //
      // Retrieve the samAccountName from the computer object
      //
      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADsUser interface to the user object
      //
      CComPtr<IADs> spADs;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADs,
                           (void**)&spADs,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      CComVariant var;
      hr = spADs->Get(L"samAccountName", &var);
      if (FAILED(hr))
      {
         break;
      }

      ASSERT(var.vt == VT_BSTR);

      //
      // The new password for the computer account is the first
      // 14 characters of the samAccountName minus the '$'.
      //
      WCHAR pszNewPassword[15];
      memset(pszNewPassword, 0, sizeof(WCHAR) * 15);

      wcsncpy(pszNewPassword, var.bstrVal, 14);
      PWSTR pszDollar = wcschr(pszNewPassword, L'$');
      if (pszDollar)
      {
         *pszDollar = L'\0';
      }

      hr = ResetObjectPassword(pszDN,
                               refBasePathsInfo,
                               refCredentialObject,
                               pszNewPassword);
      if (FAILED(hr))
      {
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             hr,
                             IDS_FAILED_RESET_COMPUTER);
         hr = S_FALSE;
         break;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReadUserAccountControl
//
//  Synopsis:   Reads the userAccountControl attribute from the object specified
//              by the DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [plBits - OUT]         : returns the currect userAccountControl bits
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    12-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ReadUserAccountControl(PCWSTR pszDN,
                               const CDSCmdBasePathsInfo& refBasePathsInfo,
                               const CDSCmdCredentialObject& refCredentialObject,
                               long* plBits)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ReadUserAccountControl, hr);

   do // false loop
   {
      if (!pszDN ||
          !plBits)
      {
         ASSERT(pszDN);
         ASSERT(plBits);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADsUser interface to the user object
      //
      CComPtr<IADs> spADs;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADs,
                           (void**)&spADs,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      CComVariant var;
      hr = spADs->Get(L"userAccountControl", &var);
      if (FAILED(hr))
      {
         break;
      }

      ASSERT(var.vt == VT_I4);

      *plBits = var.lVal;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DisableAccount
//
//  Synopsis:   Disables/Enables the account using the UF_ACCOUNTDISABLE bit in the 
//              userAccountControl attribute
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    12-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT DisableAccount(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredentialObject,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, DisableAccount, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Reading user account control from object");
         hr = ReadUserAccountControl(pszDN,
                                     refBasePathsInfo,
                                     refCredentialObject,
                                     &lUserAccountControl);
         if (FAILED(hr))
         {
            break;
         }
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Using existing userAccountControl from table.");
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      if (pObjectEntry->pAttributeTable[dwAttributeIdx]->nAttributeID != NULL &&
		  argRecord.bDefined && argRecord.bValue)
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding UF_ACCOUNTDISABLE to the userAccountControl");
         lUserAccountControl |= UF_ACCOUNTDISABLE;
      }
      else
      {
		 DEBUG_OUTPUT(LEVEL3_LOGGING, L"Removing UF_ACCOUNTDISABLE from the userAccountControl");
         lUserAccountControl &= ~UF_ACCOUNTDISABLE;
      }

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetMustChangePwd
//
//  Synopsis:   Sets the pwdLastSet attribute 
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT SetMustChangePwd(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                         const CDSCmdCredentialObject& /*refCredentialObject*/,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetMustChangePwd, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      //
      // REVIEW_JEFFJON : this is being leaked!
      //
      (*ppAttr)->pADsValues = new ADSVALUE;
      if ((*ppAttr)->pADsValues)
      {
         (*ppAttr)->dwNumValues = 1;
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

         if (argRecord.bValue)
         {
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0;
         }
         else
         {
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0xffffffff;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0xffffffff;
         }
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   ChangeMustChangePwd
//
//  Synopsis:   Sets the pwdLastSet attribute 
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ChangeMustChangePwd(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ChangeMustChangePwd, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      //
      // We will assume they can change their password unless we discover otherwise
      //
      bool bCanChangePassword = true;
      hr = EvaluateCanChangePasswordAces(pszDN,
                                         refBasePathsInfo,
                                         refCredentialObject,
                                         bCanChangePassword);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"EvaluateCanChangePasswordAces failed: hr = 0x%x",
                      hr);
         ASSERT(false);
      }

      if (!bCanChangePassword && argRecord.bValue)
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"Cannot have must change password and cannot change password");
         DisplayErrorMessage(g_pszDSCommandName, pszDN, S_OK, IDS_MUSTCHPWD_CANCHPWD_CONFLICT);
         *ppAttr = NULL;
         hr = S_FALSE;
         break;
      }
      else
      {
         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
      }

      //
      // REVIEW_JEFFJON : this is being leaked!
      //
      (*ppAttr)->pADsValues = new ADSVALUE;
      if ((*ppAttr)->pADsValues)
      {
         (*ppAttr)->dwNumValues = 1;
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

         if (argRecord.bValue)
         {
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0;
         }
         else
         {
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0xffffffff;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0xffffffff;
         }
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   PwdNeverExpires
//
//  Synopsis:   Sets the UF_DONT_EXPIRE_PASSWD bit in the 
//              userAccountControl attribute
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT PwdNeverExpires(PCWSTR pszDN,
                        const CDSCmdBasePathsInfo& refBasePathsInfo,
                        const CDSCmdCredentialObject& refCredentialObject,
                        const PDSOBJECTTABLEENTRY pObjectEntry,
                        const ARG_RECORD& argRecord,
                        DWORD dwAttributeIdx,
                        PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, PwdNeverExpires, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
         hr = ReadUserAccountControl(pszDN,
                                     refBasePathsInfo,
                                     refCredentialObject,
                                     &lUserAccountControl);
         if (FAILED(hr))
         {
            break;
         }
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      if (argRecord.bValue)
      {
         lUserAccountControl |= UF_DONT_EXPIRE_PASSWD;
      }
      else
      {
         lUserAccountControl &= ~UF_DONT_EXPIRE_PASSWD;
      }

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReversiblePwd
//
//  Synopsis:   Sets the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in the 
//              userAccountControl attribute
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT ReversiblePwd(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      const PDSOBJECTTABLEENTRY pObjectEntry,
                      const ARG_RECORD& argRecord,
                      DWORD dwAttributeIdx,
                      PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ReversiblePwd, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
         hr = ReadUserAccountControl(pszDN,
                                     refBasePathsInfo,
                                     refCredentialObject,
                                     &lUserAccountControl);
         if (FAILED(hr))
         {
            break;
         }
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      if (argRecord.bValue)
      {
         lUserAccountControl |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
      }
      else
      {
         lUserAccountControl &= ~UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
      }

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   AccountExpires
//
//  Synopsis:   Sets in how many days the account will expire
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
const unsigned long DSCMD_FILETIMES_PER_MILLISECOND = 10000;
const DWORD DSCMD_FILETIMES_PER_SECOND = 1000 * DSCMD_FILETIMES_PER_MILLISECOND;
const DWORD DSCMD_FILETIMES_PER_MINUTE = 60 * DSCMD_FILETIMES_PER_SECOND;
const __int64 DSCMD_FILETIMES_PER_HOUR = 60 * (__int64)DSCMD_FILETIMES_PER_MINUTE;
const __int64 DSCMD_FILETIMES_PER_DAY  = 24 * DSCMD_FILETIMES_PER_HOUR;
const __int64 DSCMD_FILETIMES_PER_MONTH= 30 * DSCMD_FILETIMES_PER_DAY;

HRESULT AccountExpires(PCWSTR pszDN,
                       const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                       const CDSCmdCredentialObject& /*refCredentialObject*/,
                       const PDSOBJECTTABLEENTRY pObjectEntry,
                       const ARG_RECORD& argRecord,
                       DWORD dwAttributeIdx,
                       PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, AccountExpires, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      //
      // REVIEW_JEFFJON : this is being leaked
      //
      (*ppAttr)->pADsValues = new ADSVALUE;
      if (!(*ppAttr)->pADsValues)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
      (*ppAttr)->dwNumValues = 1;

      //
      // Note: the table entry for this attribute is ARG_TYPE_INTSTR but the parser
      // will change it to ARG_TYPE_INT if the value starts with digits.  If not then
      // the parser will change the type to ARG_TYPE_STR
      //
      if (argRecord.fType == ARG_TYPE_INT)
      {
         //
         // Get the system time and then add the number of days until the account expires
         //
         FILETIME currentFT = {0};
         ::GetSystemTimeAsFileTime(&currentFT);

         LARGE_INTEGER liExpires;
         liExpires.LowPart = currentFT.dwLowDateTime;
         liExpires.HighPart = currentFT.dwHighDateTime;

         //
         // Add one to the day because it is really the start of the next day that the account gets
         // disabled
         //
         __int64 days = argRecord.nValue + 1;
         __int64 nanosecs = days * DSCMD_FILETIMES_PER_DAY;
         (*ppAttr)->pADsValues->LargeInteger.QuadPart = liExpires.QuadPart + nanosecs;
      }
      else if (argRecord.fType == ARG_TYPE_STR)
      {
         CComBSTR sbstrStrValue = argRecord.strValue;
         sbstrStrValue.ToLower();

         if (0 == _wcsicmp(sbstrStrValue, g_bstrNever))
         {
            //
            // Zero signifies that the account never expires
            //
            (*ppAttr)->pADsValues->LargeInteger.HighPart = 0;
            (*ppAttr)->pADsValues->LargeInteger.LowPart = 0;
         }
         else
         {
            hr = E_INVALIDARG;
            break;
         }
      }

      //
      // Mark the attribute as dirty
      //
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   EvaluateMustChangePassword
//
//  Synopsis:   Determines whether the user must change their password at next logon
//
//  Arguments:  [pszDN - IN] : DN of the object to check
//              [refBasePathsInfo - IN] : reference to the base paths info
//              [refCredentialObject - IN] : reference to the credential manangement object
//              [bMustChangePassword - OUT] : true if the user must change their
//                                            password at next logon, false otherwise
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT EvaluateMustChangePassword(PCWSTR pszDN,
                                   const CDSCmdBasePathsInfo& refBasePathsInfo,
                                   const CDSCmdCredentialObject& refCredentialObject,
                                   bool& bMustChangePassword)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, EvaluateMustChangePassword, hr);

   do // false loop
   {
      //
      // Validate parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      bMustChangePassword = false;

      //
      // Compose the path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Open the object
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spDirObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      static const DWORD dwAttrCount = 1;
      PWSTR pszAttrs[] = { L"pwdLastSet" };
      PADS_ATTR_INFO pAttrInfo = NULL;
      DWORD dwAttrsReturned = 0;

      hr = spDirObject->GetObjectAttributes(pszAttrs,
                                            dwAttrCount,
                                            &pAttrInfo,
                                            &dwAttrsReturned);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"GetObjectAttributes for pwdLastSet failed: hr = 0x%x",
                      hr);
         break;
      }

      if (pAttrInfo && dwAttrsReturned && pAttrInfo->dwNumValues)
      {
         if (pAttrInfo->pADsValues->LargeInteger.HighPart == 0 &&
             pAttrInfo->pADsValues->LargeInteger.LowPart == 0)
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"User must change password at next logon");
            bMustChangePassword = true;
         }
      }

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   EvaluateCanChangePasswordAces
//
//  Synopsis:   Looks for explicit entries in the ACL to see if the user can
//              change their password
//
//  Arguments:  [pszDN - IN] : DN of the object to check
//              [refBasePathsInfo - IN] : reference to the base paths info
//              [refCredentialObject - IN] : reference to the credential manangement object
//              [bCanChangePassword - OUT] : false if there are explicit entries
//                                           that keep the user from changing their
//                                           password.  true otherwise.
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT EvaluateCanChangePasswordAces(PCWSTR pszDN,
                                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                                      const CDSCmdCredentialObject& refCredentialObject,
                                      bool& bCanChangePassword)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, EvaluateCanChangePasswordAces, hr);

   do // false loop
   {
      //
      // Validate parameters
      //
      if (!pszDN)
      {
         ASSERT(pszDN);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Compose the path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Open the object
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spDirObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
      CSimpleAclHolder Dacl;
      hr = DSReadObjectSecurity(spDirObject,
                                &sdControl,
                                &(Dacl.m_pAcl));
      if (FAILED(hr))
      {
         break;
      }

      //
      // Create and Initialize the Self and World SIDs
      //
      CSidHolder selfSid;
      CSidHolder worldSid;

      PSID pSid = NULL;

      SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                               WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
      if (!AllocateAndInitializeSid(&NtAuth,
                                    1,
                                    SECURITY_PRINCIPAL_SELF_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate self SID: hr = 0x%x", hr);
         break;
      }

      selfSid.Attach(pSid, false);
      pSid = NULL;

      if (!AllocateAndInitializeSid(&WorldAuth,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate world SID: hr = 0x%x", hr);
         break;
      }

      worldSid.Attach(pSid, false);
      pSid = NULL;

      ULONG ulCount = 0, j = 0;
      PEXPLICIT_ACCESS rgEntries = NULL;

      DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);

      if (ERROR_SUCCESS != dwErr)
      {
         hr = HRESULT_FROM_WIN32(dwErr);
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"GetExplicitEntriesFromAcl failed: hr = 0x%x", hr);
         break;
      }

      //
      // Are these ACEs already present?
      //
      bool bSelfAllowPresent = false;
      bool bWorldAllowPresent = false;
      bool bSelfDenyPresent = false;
      bool bWorldDenyPresent = false;

      //
      // Loop through looking for the can change password ACE for self and world
      //
      for (j = 0; j < ulCount; j++)
      {
         //
         // Look for deny ACEs
         //
         if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
             (rgEntries[j].grfAccessMode == DENY_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get())) 
               {
                  //
                  // Deny self found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Deny self found at rgEntries[%d]", j);
                  bSelfDenyPresent = true;
               }
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Deny world found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Deny world found at rgEntries[%d]", j);
                  bWorldDenyPresent = true;
               }
            }
         }
         //
         // Look for allow ACEs
         //
         else if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                  (rgEntries[j].grfAccessMode == GRANT_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get()))
               {
                  //
                  // Allow self found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Allow self found at rgEntries[%d]", j);
                  bSelfAllowPresent = true;
               }
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Allow world found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Allow world found at rgEntries[%d]", j);
                  bWorldAllowPresent = true;
               }
            }
         }
      }

      if (bSelfDenyPresent || bWorldDenyPresent)
      {
         //
         // There is an explicit deny so we know that the user cannot change password
         //
         bCanChangePassword = false;
      }
      else if ((!bSelfDenyPresent && !bWorldDenyPresent) &&
               (bSelfAllowPresent || bWorldAllowPresent))
      {
         //
         // There is no explicit deny but there are explicit allows so we know that
         // the user can change password
         //
         bCanChangePassword = true;
      }
      else
      {
         //
         // We are not sure because the explicit entries are not telling us for
         // certain so it all depends on inheritence.  Most likely they will
         // be able to change their password unless the admin has changed something
         // higher up or through group membership
         //
         bCanChangePassword = true;
      }
   } while(false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ChangeCanChangePassword
//
//  Synopsis:   Sets or removes the Deny Ace on the can change password ACL
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ChangeCanChangePassword(PCWSTR pszDN,
                                const CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                const PDSOBJECTTABLEENTRY pObjectEntry,
                                const ARG_RECORD& argRecord,
                                DWORD dwAttributeIdx,
                                PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ChangeCanChangePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = NULL;

      //
      // Read the userAccountControl to make sure we don't have
      // the user must change password bit set
      //
      bool bMustChangePassword = false;
      hr = EvaluateMustChangePassword(pszDN,
                                      refBasePathsInfo,
                                      refCredentialObject,
                                      bMustChangePassword);
      if (FAILED(hr))
      {
         //
         // Lets log it but continue on as if everything was OK
         //
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"EvaluateMustChangePassword failed: hr = 0x%x",
                      hr);
      }

      if (bMustChangePassword && !argRecord.bValue)
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"Cannot have must change password and cannot change password");
         DisplayErrorMessage(g_pszDSCommandName, pszDN, S_OK, IDS_MUSTCHPWD_CANCHPWD_CONFLICT);
         *ppAttr = NULL;
         hr = S_FALSE;
         break;
      }

      hr = SetCanChangePassword(pszDN,
                                refBasePathsInfo,
                                refCredentialObject,
                                pObjectEntry,
                                argRecord,
                                dwAttributeIdx,
                                ppAttr);
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetCanChangePassword
//
//  Synopsis:   Sets or removes the Deny Ace on the can change password ACL
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetCanChangePassword(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD /*dwAttributeIdx*/,
                             PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetCanChangePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = NULL;

      //
      // Compose the path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Open the object
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spDirObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
      CSimpleAclHolder Dacl;
      hr = DSReadObjectSecurity(spDirObject,
                                &sdControl,
                                &(Dacl.m_pAcl));
      if (FAILED(hr))
      {
         break;
      }

      //
      // Create and Initialize the Self and World SIDs
      //
      CSidHolder selfSid;
      CSidHolder worldSid;

      PSID pSid = NULL;

      SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                               WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
      if (!AllocateAndInitializeSid(&NtAuth,
                                    1,
                                    SECURITY_PRINCIPAL_SELF_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate self SID: hr = 0x%x", hr);
         break;
      }

      selfSid.Attach(pSid, false);
      pSid = NULL;

      if (!AllocateAndInitializeSid(&WorldAuth,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate world SID: hr = 0x%x", hr);
         break;
      }

      worldSid.Attach(pSid, false);
      pSid = NULL;

      ULONG ulCount = 0, j = 0;
      PEXPLICIT_ACCESS rgEntries = NULL;

      DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);

      if (ERROR_SUCCESS != dwErr)
      {
         hr = HRESULT_FROM_WIN32(dwErr);
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"GetExplicitEntriesFromAcl failed: hr = 0x%x", hr);
         break;
      }

      //
      // At most we will be adding two ACEs hence the +2
      //
      PEXPLICIT_ACCESS rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, sizeof(EXPLICIT_ACCESS)*(ulCount + 2));
      if (!rgNewEntries)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      DEBUG_OUTPUT(FULL_LOGGING, L"GetExplicitEntriesFromAcl return %d entries", ulCount); 

      //
      // Are these ACEs already present?
      //
      bool bSelfAllowPresent = false;
      bool bWorldAllowPresent = false;
      bool bSelfDenyPresent = false;
      bool bWorldDenyPresent = false;

      ULONG ulCurrentEntry = 0;
      //
      // If we are not granting them permission, then put the deny ACE at the top
      //
      if (!argRecord.bValue)
      {
         //
         // initialize the new entries (DENY ACE's)
         //
         OBJECTS_AND_SID rgObjectsAndSid[2];
         memset(rgObjectsAndSid, 0, sizeof(rgObjectsAndSid));

         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding the deny self ACE at rgNewEntries[%d]", ulCurrentEntry);
         rgNewEntries[ulCurrentEntry].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
         rgNewEntries[ulCurrentEntry].grfAccessMode = DENY_ACCESS;
         rgNewEntries[ulCurrentEntry].grfInheritance = NO_INHERITANCE;

         //
         // build the trustee structs for change password
         //
         BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulCurrentEntry].Trustee),
                                       &(rgObjectsAndSid[0]),
                                       const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                       NULL, // inherit guid
                                       selfSid.Get());
         ulCurrentEntry++;

         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding the deny world ACE at rgNewEntries[%d]", ulCurrentEntry);
         rgNewEntries[ulCurrentEntry].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
         rgNewEntries[ulCurrentEntry].grfAccessMode = DENY_ACCESS;
         rgNewEntries[ulCurrentEntry].grfInheritance = NO_INHERITANCE;

         //
         // build the trustee structs for change password
         //
         BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulCurrentEntry].Trustee),
                                       &(rgObjectsAndSid[1]),
                                       const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                       NULL, // inherit guid
                                       worldSid.Get());
         ulCurrentEntry++;
      }

      //
      // Loop through all the ACEs and copy them over to the rgNewEntries unless it is
      // an ACE that we want to remove
      //
      for (j = 0; j < ulCount; j++)
      {
         bool bCopyACE = true;

         //
         // Look for deny ACEs
         //
         if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
             (rgEntries[j].grfAccessMode == DENY_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get())) 
               {
                  //
                  // Deny self found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Deny self found at rgEntries[%d]", j);
                  bSelfDenyPresent = true;

                  //
                  // Never copy the deny ACE because we added it above for !argRecord.bValue
                  //
                  bCopyACE = false;
               }
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Deny world found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Deny world found at rgEntries[%d]", j);
                  bWorldDenyPresent = true;

                  //
                  // Never copy the deny ACE because we added it above for !argRecord.bValue
                  //
                  bCopyACE = false;
               }
            }
         }
         //
         // Look for allow ACEs
         //
         else if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                  (rgEntries[j].grfAccessMode == GRANT_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get()))
               {
                  //
                  // Allow self found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Allow self found at rgEntries[%d]", j);
                  bSelfAllowPresent = true;
                  if (!argRecord.bValue)
                  {
                     bCopyACE = false;
                  }
               }
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Allow world found
                  //
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Allow world found at rgEntries[%d]", j);
                  bWorldAllowPresent = TRUE;
                  if (!argRecord.bValue)
                  {
                     bCopyACE = false;
                  }
               }
            }
         }

         if (bCopyACE)
         {
            DEBUG_OUTPUT(FULL_LOGGING, 
                          L"Copying entry from rgEntries[%d] to rgNewEntries[%d]",
                          j,
                          ulCurrentEntry);
            rgNewEntries[ulCurrentEntry] = rgEntries[j];
            ulCurrentEntry++;
         }
      }

      //
      // Now add the allow ACEs if they were not present and we are granting user can change pwd
      //
      if (argRecord.bValue)
      {
         if (!bSelfAllowPresent)
         {
            //
            // Need to add the grant self ACE
            //
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding the grant self ACE at rgNewEntries[%d]", ulCurrentEntry);
            OBJECTS_AND_SID rgObjectsAndSid = {0};
            rgNewEntries[ulCurrentEntry].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
            rgNewEntries[ulCurrentEntry].grfAccessMode = GRANT_ACCESS;
            rgNewEntries[ulCurrentEntry].grfInheritance = NO_INHERITANCE;

            BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulCurrentEntry].Trustee),
                                          &(rgObjectsAndSid),
                                          const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                          NULL, // inherit guid
                                          selfSid.Get());
            ulCurrentEntry++;
         }

         if (!bWorldAllowPresent)
         {
            //
            // Need to add the grant world ACE
            //
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"Adding the grant world ACE at rgNewEntries[%d]", ulCurrentEntry);

            OBJECTS_AND_SID rgObjectsAndSid = {0};
            rgNewEntries[ulCurrentEntry].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
            rgNewEntries[ulCurrentEntry].grfAccessMode = GRANT_ACCESS;
            rgNewEntries[ulCurrentEntry].grfInheritance = NO_INHERITANCE;

            BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulCurrentEntry].Trustee),
                                          &(rgObjectsAndSid),
                                          const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                          NULL, // inherit guid
                                          worldSid.Get());
            ulCurrentEntry++;
         }
      }

      //
      // We should only have added two ACEs at most
      //
      ASSERT(ulCurrentEntry <= ulCount + 2);
      if (ulCurrentEntry > ulCount)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, 
                      L"We probably ran off the end of the array because ulCurrentEntry(%d) is > ulCount(%d)", 
                      ulCurrentEntry, 
                      ulCount);
      }


      //
      // Now set the entries in the new ACL
      //
      CSimpleAclHolder NewDacl;

      DEBUG_OUTPUT(LEVEL3_LOGGING, L"Calling SetEntriesInAcl for %d entries", ulCurrentEntry);
      dwErr = SetEntriesInAcl(ulCurrentEntry, rgNewEntries, NULL, &(NewDacl.m_pAcl));
      if (ERROR_SUCCESS != dwErr)
      {
         hr = HRESULT_FROM_WIN32(dwErr);
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"SetEntriesInAcl failed: hr = 0x%x", hr);
         break;
      }

      ASSERT(IsValidAcl(NewDacl.m_pAcl));

      //
      // Free the entries
      //
      if (rgNewEntries)
      {
         LocalFree(rgNewEntries);
      }

      if (ulCount && rgEntries)
      {
         LocalFree(rgEntries);
      }

      //
      // Write the new ACL back as a SecurityDescriptor
      //
      hr = DSWriteObjectSecurity(spDirObject,
                                 sdControl,
                                 NewDacl.m_pAcl);
      if (FAILED(hr))
      {
         break;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReadGroupType
//
//  Synopsis:   Reads the group type from the group specified by the given DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                        CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [plType - OUT]        : returns the currect group type
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ReadGroupType(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      long* plType)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ReadGroupType, hr);

   do // false loop
   {
      if (!pszDN ||
          !plType)
      {
         ASSERT(pszDN);
         ASSERT(plType);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADs interface to the user object
      //
      CComPtr<IADs> spADs;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADs,
                           (void**)&spADs,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      CComVariant var;
      hr = spADs->Get(L"groupType", &var);
      if (FAILED(hr))
      {
         break;
      }

      ASSERT(var.vt == VT_I4);

      *plType = var.lVal;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetGroupScope
//
//  Synopsis:   Sets the groupType attribute to local/universal/global
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetGroupScope(PCWSTR pszDN,
                      const CDSCmdBasePathsInfo& refBasePathsInfo,
                      const CDSCmdCredentialObject& refCredentialObject,
                      const PDSOBJECTTABLEENTRY pObjectEntry,
                      const ARG_RECORD& argRecord,
                      DWORD dwAttributeIdx,
                      PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetGroupScope, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      //
      // Read the current group type
      //
      bool bUseExistingAttrInfo = false;
      long lGroupType = 0;
      if (!(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ))
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Group type has not been read, try reading it now");
         hr = ReadGroupType(pszDN,
                            refBasePathsInfo,
                            refCredentialObject,
                            &lGroupType);
         if (FAILED(hr))
         {
            //
            // Just continue on without knowing since we are trying to set it anyway
            //
            hr = S_OK;
            lGroupType = 0;
         }

         //
         // Mark the attribute as read and allocate space for the new value
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         (*ppAttr)->dwNumValues = 1;
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
      }
      else
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Group type has been read, just use that one");

         //
         // If the attribute hasn't been set yet create a new value for it
         //
         if (!(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_DIRTY))
         {
            (*ppAttr)->pADsValues = new ADSVALUE;
            if (!(*ppAttr)->pADsValues)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

            (*ppAttr)->dwNumValues = 1;
            (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         }

         lGroupType = (*ppAttr)->pADsValues->Integer;
         bUseExistingAttrInfo = true;
      }
      DEBUG_OUTPUT(LEVEL3_LOGGING, L"old grouptype = 0x%x", lGroupType);

      //
      // Remember the security bit
      //
      bool bIsSecurityEnabled = (lGroupType & GROUP_TYPE_SECURITY_ENABLED) != 0;

      //
      // Clear out the old value
      //
      lGroupType = 0;

      //
      // The parser should have already verified that the strValue contains 
      // either 'l', 'g', or 'u'
      //
      CComBSTR sbstrInput;
      sbstrInput = argRecord.strValue;
      sbstrInput.ToLower();

      if (sbstrInput == g_bstrGroupScopeLocal)
      {
         //
         // Local group
         //
         lGroupType = GROUP_TYPE_RESOURCE_GROUP;
      }
      else if (sbstrInput == g_bstrGroupScopeGlobal)
      {
         //
         // Global group
         //
         lGroupType = GROUP_TYPE_ACCOUNT_GROUP;
      }
      else if (sbstrInput == g_bstrGroupScopeUniversal)
      {
         //
         // Universal group
         //
         lGroupType = GROUP_TYPE_UNIVERSAL_GROUP;
      }
      else
      {
         *ppAttr = NULL;
         hr = E_INVALIDARG;
         break;
      }

      //
      // Reset the security bit
      //
      if (bIsSecurityEnabled)
      {
         lGroupType |= GROUP_TYPE_SECURITY_ENABLED;
      }

      //
      // Set the new value in the ADS_ATTR_INFO
      //
      (*ppAttr)->pADsValues->Integer = lGroupType;

      DEBUG_OUTPUT(LEVEL3_LOGGING, L"new grouptype = 0x%x", lGroupType);

      //
      // Mark the attribute as dirty
      //
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;

      //
      // if the attribute was previously read then we don't need to add another ADS_ATTR_INFO
      // 
      if (bUseExistingAttrInfo)
      {
        *ppAttr = NULL;
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   ChangeGroupScope
//
//  Synopsis:   Sets the groupType attribute to local/universal/global
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ChangeGroupScope(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetGroupScope, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      //
      // Check the domain mode
      //
      bool bMixedMode = false;
      hr = refBasePathsInfo.GetDomainMode(refCredentialObject,
                                          bMixedMode);
      if (FAILED(hr))
      {
         *ppAttr = NULL;
         break;
      }

      if (bMixedMode)
      {
         //
         // We don't allow group type to be changed in Mixed Mode
         //
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             E_FAIL,
                             IDS_FAILED_CHANGE_GROUP_DOMAIN_VERSION);
         hr = S_FALSE;
         break;
      }

      hr = SetGroupScope(pszDN,
                         refBasePathsInfo,
                         refCredentialObject,
                         pObjectEntry,
                         argRecord,
                         dwAttributeIdx,
                         ppAttr);

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetGroupSecurity
//
//  Synopsis:   Sets the groupType to be security enabled or disabled
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetGroupSecurity(PCWSTR pszDN,
                         const CDSCmdBasePathsInfo& refBasePathsInfo,
                         const CDSCmdCredentialObject& refCredentialObject,
                         const PDSOBJECTTABLEENTRY pObjectEntry,
                         const ARG_RECORD& argRecord,
                         DWORD dwAttributeIdx,
                         PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetGroupSecurity, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      //
      // Read the current group type
      //
      bool bUseExistingAttrInfo = false;
      long lGroupType = 0;
      if (!(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ))
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Group type has not been read, try reading it now");
         hr = ReadGroupType(pszDN,
                            refBasePathsInfo,
                            refCredentialObject,
                            &lGroupType);
         if (FAILED(hr))
         {
            //
            // Continue on anyway since we are trying to set this attribute
            //
            hr = S_OK;
            lGroupType = 0;
         }

         //
         // Mark the attribute as read and allocate space for the new value
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         (*ppAttr)->dwNumValues = 1;
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
      }
      else
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Group type has been read, just use that one");

         //
         // if the attribute hasn't been marked dirty allocate space for the value
         //
         if (!(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ))
         {
            (*ppAttr)->pADsValues = new ADSVALUE;
            if (!(*ppAttr)->pADsValues)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

            (*ppAttr)->dwNumValues = 1;
            (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         }
         lGroupType = (*ppAttr)->pADsValues->Integer;
         bUseExistingAttrInfo = true;
      }
      DEBUG_OUTPUT(LEVEL3_LOGGING, L"old grouptype = 0x%x", lGroupType);

      if (argRecord.bValue)
      {
         lGroupType |= GROUP_TYPE_SECURITY_ENABLED;
      }
      else
      {
         lGroupType &= ~(GROUP_TYPE_SECURITY_ENABLED);
      }

      //
      // Set the new value in the ADS_ATTR_INFO
      //
      (*ppAttr)->pADsValues->Integer = lGroupType;

      DEBUG_OUTPUT(LEVEL3_LOGGING, L"new grouptype = 0x%x", lGroupType);

      //
      // Mark the attribute as dirty
      //
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;

      //
      // if we are just using the existing ADS_ATTR_INFO don't return a new one
      //
      if (bUseExistingAttrInfo)
      {
        *ppAttr = NULL;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ChangeGroupSecurity
//
//  Synopsis:   Sets the groupType to be security enabled or disabled but
//              checks if we are in native mode first
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ChangeGroupSecurity(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            const PDSOBJECTTABLEENTRY pObjectEntry,
                            const ARG_RECORD& argRecord,
                            DWORD dwAttributeIdx,
                            PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetGroupSecurity, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      //
      // Check the domain mode
      //
      bool bMixedMode = false;
      hr = refBasePathsInfo.GetDomainMode(refCredentialObject,
                                          bMixedMode);
      if (FAILED(hr))
      {
         *ppAttr = NULL;
         break;
      }

      if (bMixedMode)
      {
         //
         // We don't allow group type to be changed in Mixed Mode
         //
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             E_FAIL,
                             IDS_FAILED_CHANGE_GROUP_DOMAIN_VERSION);
         hr = S_FALSE;
         break;
      }

      hr = SetGroupSecurity(pszDN,
                            refBasePathsInfo,
                            refCredentialObject,
                            pObjectEntry,
                            argRecord,
                            dwAttributeIdx,
                            ppAttr);

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ModifyGroupMembers
//
//  Synopsis:   Sets the groupType to be security enabled or disabled
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ModifyGroupMembers(PCWSTR pszDN,
                           const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                           const CDSCmdCredentialObject& /*refCredentialObject*/,
                           const PDSOBJECTTABLEENTRY pObjectEntry,
                           const ARG_RECORD& argRecord,
                           DWORD dwAttributeIdx,
                           PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ModifyGroupMembers, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(argRecord.strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         *ppAttr = NULL;
         hr = E_OUTOFMEMORY;
         break;
      }

      (*ppAttr)->pADsValues = new ADSVALUE[nStrings];
      if (!(*ppAttr)->pADsValues)
      {
         *ppAttr = NULL;
         LocalFree(ppszArray);
         hr = E_OUTOFMEMORY;
         break;
      }
      (*ppAttr)->dwNumValues = nStrings;

      for (UINT nIdx = 0; nIdx < nStrings; nIdx++)
      {
         (*ppAttr)->pADsValues[nIdx].dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->pADsValues[nIdx].DNString = ppszArray[nIdx];
      }

      //
      // Mark the attribute as dirty
      //
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;

      if (ppszArray)
      {
         LocalFree(ppszArray);
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReadGroupMembership
//
//  Synopsis:   Reads the group members list
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [ppMembersAttr - OUT] : returns the currect group membership
//                                      this value must be freed using FreeADsMem
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ReadGroupMembership(PCWSTR pszDN,
                            const CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            PADS_ATTR_INFO* ppMembersAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ReadGroupMembership, hr);

   do // false loop
   {
      if (!pszDN ||
          !ppMembersAttr)
      {
         ASSERT(pszDN);
         ASSERT(ppMembersAttr);

         hr = E_INVALIDARG;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADs interface to the user object
      //
      CComPtr<IDirectoryObject> spObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IDirectoryObject,
                           (void**)&spObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      DWORD dwNumReturned = 0;
      PWSTR ppszAttrs[] = { L"member" };
      hr = spObject->GetObjectAttributes(ppszAttrs,
                                         sizeof(ppszAttrs)/sizeof(PWSTR),
                                         ppMembersAttr,
                                         &dwNumReturned);
      if (FAILED(hr))
      {
         break;
      }
   } while (false);
   
   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ShowRemoveFromGroupFailure
//
//  Synopsis:   Displays an error message as a result of failure to remove
//              an object from a group
//
//  Arguments:  [hr - IN]        : failure code
//              [pszDN - IN]     : DN of the group object
//              [pszMember - IN] : DN of the member being removed
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    06-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ShowRemoveFromGroupFailure(HRESULT hrResult,
                                   PCWSTR pszDN,
                                   PCWSTR pszMember)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, ShowRemoveFromGroupFailure, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pszMember)
      {
         ASSERT(pszDN);
         ASSERT(pszMember);

         hr = E_INVALIDARG;
         break;
      }

      bool bShowGenericMessage = true;
      CComBSTR sbstrFormatter;
      bool bLoadFormatString = sbstrFormatter.LoadString(::GetModuleHandle(NULL), 
                                                         IDS_ERRMSG_REMOVE_FROM_GROUP);
      if (bLoadFormatString)
      {
         size_t messageLength = wcslen(sbstrFormatter) + wcslen(pszMember);
         PWSTR pszMessage = new WCHAR[messageLength + 1];
         if (pszMessage)
         {
            wsprintf(pszMessage, sbstrFormatter, pszMember);
            DisplayErrorMessage(g_pszDSCommandName,
                                pszDN,
                                hrResult,
                                pszMessage);
            bShowGenericMessage = false;
            delete[] pszMessage;
            pszMessage = 0;
         }
      }
      
      if (bShowGenericMessage)
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to load the string IDS_ERRMSG_REMOVE_FROM_GROUP from the resource file");
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Using the default message instead");
         DisplayErrorMessage(g_pszDSCommandName,
                             pszDN,
                             hrResult);
      }
   } while (false);

   return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   RemoveGroupMembers
//
//  Synopsis:   Removes the specified members from the group
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT RemoveGroupMembers(PCWSTR pszDN,
                           const CDSCmdBasePathsInfo& refBasePathsInfo,
                           const CDSCmdCredentialObject& refCredentialObject,
                           const PDSOBJECTTABLEENTRY pObjectEntry,
                           const ARG_RECORD& argRecord,
                           DWORD /*dwAttributeIdx*/,
                           PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, RemoveGroupMembers, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      //
      // We won't be returning an attribute
      //
      *ppAttr = 0;

      //
      // Parse the members to be removed
      //
      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(argRecord.strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         *ppAttr = NULL;
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Convert the DN to a path
      //
      CComBSTR sbstrPath;
      refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

      //
      // Bind and obtain the IADs interface to the user object
      //
      CComPtr<IADsGroup> spGroup;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrPath,
                           IID_IADsGroup,
                           (void**)&spGroup,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      //
      // Remove each of the objects from the group
      //
      for (UINT nStringIdx = 0; nStringIdx < nStrings; nStringIdx++)
      {
         //
         // Convert the member DN into a ADSI path
         //
         CComBSTR sbstrMemberPath;
         refBasePathsInfo.ComposePathFromDN(ppszArray[nStringIdx], sbstrMemberPath);

         //
         // Remove the member
         //
         hr = spGroup->Remove(sbstrMemberPath);
         if (FAILED(hr))
         {
            ShowRemoveFromGroupFailure(hr, pszDN, ppszArray[nStringIdx]);
            hr = S_FALSE;
            break;
         }
      }
      
      if (ppszArray)
      {
         LocalFree(ppszArray);
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   MakeMemberOf
//
//  Synopsis:   Makes the object specified by pszDN a member of the group
//              specified in the argRecord.strValue
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    25-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT MakeMemberOf(PCWSTR pszDN,
                     const CDSCmdBasePathsInfo& refBasePathsInfo,
                     const CDSCmdCredentialObject& refCredentialObject,
                     const PDSOBJECTTABLEENTRY pObjectEntry,
                     const ARG_RECORD& argRecord,
                     DWORD dwAttributeIdx,
                     PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, MakeMemberOf, hr);
   
   PWSTR* ppszArray = NULL;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      //
      // We are going to do all the work here so don't pass back the ADS_ATTR_INFO
      //
      *ppAttr = NULL;

      ADS_ATTR_INFO* pMemberAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      UINT nStrings = 0;
      ParseNullSeparatedString(argRecord.strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to parse null separated string list of groups");
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Create the value
      //
      ADSVALUE MemberValue = { ADSTYPE_DN_STRING, NULL };
      pMemberAttr->pADsValues = &MemberValue;
      pMemberAttr->dwNumValues = 1;
      pMemberAttr->dwControlCode = ADS_ATTR_APPEND;
      pMemberAttr->pADsValues->DNString = (PWSTR)pszDN;

      //
      // For each group in the list add the object to the group
      //
      for (UINT nIdx = 0; nIdx < nStrings; nIdx++)
      {
         PWSTR pszGroupDN = ppszArray[nIdx];
         ASSERT(pszGroupDN);

         CComBSTR sbstrGroupPath;
         refBasePathsInfo.ComposePathFromDN(pszGroupDN, sbstrGroupPath);

         CComPtr<IDirectoryObject> spDirObject;
         hr  = DSCmdOpenObject(refCredentialObject,
                               sbstrGroupPath,
                               IID_IDirectoryObject,
                               (void**)&spDirObject,
                               true);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to open group object: %s", sbstrGroupPath);
            break;
         }

         DWORD dwNumAttrs = 0;
         hr = spDirObject->SetObjectAttributes(pMemberAttr,
                                               1,
                                               &dwNumAttrs);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to set object attributes on group object: %s", sbstrGroupPath);
            break;
         }
      }

   } while (false);

   if (ppszArray)
   {
      LocalFree(ppszArray);
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetIsGC
//
//  Synopsis:   Makes the server object specified by pszDN into a GC or not
//              by modifying the NTDS Settings object contained within
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    14-Apr-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetIsGC(PCWSTR pszDN,
                const CDSCmdBasePathsInfo& refBasePathsInfo,
                const CDSCmdCredentialObject& refCredentialObject,
                const PDSOBJECTTABLEENTRY pObjectEntry,
                const ARG_RECORD& argRecord,
                DWORD /*dwAttributeIdx*/,
                PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetIsGC, hr);
   
   PADS_ATTR_INFO pAttrInfo = 0;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      //
      // We are going to do all the work here so don't pass back the ADS_ATTR_INFO
      //
      *ppAttr = NULL;

      //
      // Get the NTDS Settings object that is contained within the server of the specified DN
      //
      CComBSTR sbstrSettingsDN = L"CN=NTDS Settings,";
      sbstrSettingsDN += pszDN;

      CComBSTR sbstrSettingsPath;
      refBasePathsInfo.ComposePathFromDN(sbstrSettingsDN, sbstrSettingsPath);

      DEBUG_OUTPUT(LEVEL3_LOGGING,
                   L"NTDS Settings path = %s",
                   sbstrSettingsPath);

      CComPtr<IDirectoryObject> spDirectoryObject;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrSettingsPath,
                           IID_IDirectoryObject,
                           (void**)&spDirectoryObject,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      PWSTR pszAttrs[] = { L"options" };
      DWORD dwReturned = 0;
      hr = spDirectoryObject->GetObjectAttributes(pszAttrs, 1, &pAttrInfo, &dwReturned);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, 
                      L"Failed to get old options: hr = 0x%x",
                      hr);
         break;
      }
      
      if (dwReturned < 1 ||
          !pAttrInfo)
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING,
                      L"Get options succeeded but no values were returned.");
         hr = E_FAIL;
         break;
      }

      if (argRecord.bDefined && 
          argRecord.bValue)
      {
         pAttrInfo->pADsValues->Integer |= 0x1;
      }
      else
      {
         pAttrInfo->pADsValues->Integer &= ~(0x1);
      }

      dwReturned = 0;
      hr = spDirectoryObject->SetObjectAttributes(pAttrInfo, 1, &dwReturned);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING,
                      L"Failed to set the new options: hr = 0x%x",
                      hr);
         break;
      }

      ASSERT(dwReturned == 1);
      
   } while (false);

   if (pAttrInfo)
   {
      FreeADsMem(pAttrInfo);
   }
   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildComputerSAMName
//
//  Synopsis:   If the -samname argument was defined use that, else compute
//              the same name from the DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    09-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BuildComputerSAMName(PCWSTR pszDN,
                             const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                             const CDSCmdCredentialObject& /*refCredentialObject*/,
                             const PDSOBJECTTABLEENTRY pObjectEntry,
                             const ARG_RECORD& argRecord,
                             DWORD dwAttributeIdx,
                             PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, BuildComputerSAMName, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      (*ppAttr)->pADsValues = new ADSVALUE[1];
      if (!(*ppAttr)->pADsValues)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      (*ppAttr)->dwNumValues = 1;
      (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

      if (!argRecord.bDefined ||
          !argRecord.strValue)
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Constructing sAMAccountName for computer");

         //
         // If the object type is group and the sAMAccountName
         // was not specified, construct it from the DN or name
         //
         CONST DWORD computerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
         DWORD Len = computerNameLen;
         WCHAR szDownLevel[computerNameLen];
         ZeroMemory(szDownLevel, computerNameLen * sizeof(WCHAR));

         CComBSTR sbstrName;
         hr = CPathCracker::GetObjectNameFromDN(pszDN,
                                                sbstrName);
         if (SUCCEEDED(hr))
         {
            //
            // run through the OEM conversion, just to
            // behave the same way as typing in the OEM
            // edit box
            //
            CComBSTR sbstrOemUnicode;
            _UnicodeToOemConvert(sbstrName, sbstrOemUnicode);

            // run through the DNS validation
            if (!DnsHostnameToComputerName(sbstrOemUnicode, szDownLevel, &Len))
            {
               DEBUG_OUTPUT(LEVEL3_LOGGING, 
                            L"Failed in DnsHostnameToComputerName: GLE = 0x%x",
                            GetLastError());
               Len = 0;
            }

            if (Len > 0)
            {
               //
               // Validate the SAM name
               //
               HRESULT hrValidate = ValidateAndModifySAMName(szDownLevel, 
                                                             INVALID_NETBIOS_AND_ACCOUNT_NAME_CHARS_WITH_AT);

               if (FAILED(hrValidate))
               {
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Unable to validate the SamAccountName");
                  ASSERT(SUCCEEDED(hrValidate));
                  break;
               }

               //
               // Change the last character to a $
               //
               if (Len == MAX_COMPUTERNAME_LENGTH)
               {
                  szDownLevel[Len - 1] = L'$';
               }
               else
               {
                  szDownLevel[Len] = L'$';
                  szDownLevel[Len+1] = L'\0';
               }

               //
               // Allocate enough memory for the string in the command args structure
               // REVIEW_JEFFJON : this is being leaked
               //
               (*ppAttr)->pADsValues->CaseIgnoreString = (LPTSTR)LocalAlloc(LPTR, (wcslen(szDownLevel) + 1) * sizeof(WCHAR) );
               if (!(*ppAttr)->pADsValues->CaseIgnoreString)
               {
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"Failed to allocate space for (*ppAttr)->pADsValues->CaseIgnoreString");
                  hr = E_OUTOFMEMORY;
                  break;
               }

               //
               // Truncate the name if necessary but copy it to the command args structure
               //
               _tcsncpy((*ppAttr)->pADsValues->CaseIgnoreString, 
                        szDownLevel, 
                        wcslen(szDownLevel));
            }
         }
      }
      else
      {
         (*ppAttr)->pADsValues->CaseIgnoreString = argRecord.strValue;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildGroupSAMName
//
//  Synopsis:   If the -samname argument was defined use that, else compute
//              the same name from the DN
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    09-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BuildGroupSAMName(PCWSTR pszDN,
                          const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                          const CDSCmdCredentialObject& /*refCredentialObject*/,
                          const PDSOBJECTTABLEENTRY pObjectEntry,
                          const ARG_RECORD& argRecord,
                          DWORD dwAttributeIdx,
                          PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, BuildGroupSAMName, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"Invalid args");
         hr = E_INVALIDARG;
         break;
      }

      *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

      (*ppAttr)->pADsValues = new ADSVALUE[1];
      if (!(*ppAttr)->pADsValues)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      (*ppAttr)->dwNumValues = 1;
      (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;

      if (!argRecord.bDefined ||
          !argRecord.strValue)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, L"Constructing sAMAccountName for group");
         static const UINT nSamLength = 256;

         //
         // If the object type is group and the sAMAccountName
         // was not specified, construct it from the DN or name
         //
         CComBSTR sbstrName;
         hr = CPathCracker::GetObjectNameFromDN(pszDN,
                                                sbstrName);
         if (SUCCEEDED(hr))
         {
            UINT nNameLen = sbstrName.Length();

            //
            // Allocate enough memory for the string in the command args structure
            // REVIEW_JEFFJON : this is being leaked
            //
            (*ppAttr)->pADsValues->CaseIgnoreString = (LPTSTR)LocalAlloc(LPTR, (nNameLen+2) * sizeof(TCHAR) );
            if (!(*ppAttr)->pADsValues->CaseIgnoreString)
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Failed to allocate space for (*ppAttr)->pADsValues->CaseIgnoreString");
               hr = E_OUTOFMEMORY;
               break;
            }

            //
            // Truncate the name if necessary but copy it to the command args structure
            //
            _tcsncpy((*ppAttr)->pADsValues->CaseIgnoreString, 
                     sbstrName, 
                     (nNameLen > nSamLength) ? nSamLength : nNameLen);

         }
      }
      else
      {
         (*ppAttr)->pADsValues->CaseIgnoreString = argRecord.strValue;
      }
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetComputerAccountType
//
//  Synopsis:   Sets the userAccountControl to make the object a workstation
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]      : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    05-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT SetComputerAccountType(PCWSTR pszDN,
                               const CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                               const CDSCmdCredentialObject& /*refCredentialObject*/,
                               const PDSOBJECTTABLEENTRY pObjectEntry,
                               const ARG_RECORD& /*argRecord*/,
                               DWORD dwAttributeIdx,
                               PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, SetComputerAccountType, hr);
   
   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pObjectEntry ||
          !ppAttr)
      {
         ASSERT(pszDN);
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
      
         hr = E_INVALIDARG;
         break;
      }

      long lUserAccountControl = 0;

      //
      // If the userAccountControl hasn't already been read, do so now
      //
      if (0 == (DS_ATTRIBUTE_READ & pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags))
      {
         //
         // Mark the table entry as read
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_READ;

         *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);
         (*ppAttr)->pADsValues = new ADSVALUE;
         if (!(*ppAttr)->pADsValues)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
         (*ppAttr)->dwNumValues = 1;
      }
      else
      {
         if (!pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues)
         {
            ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);
            hr = E_INVALIDARG;
            break;
         }
         lUserAccountControl = pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer;

         //
         // Don't create a new entry in the ADS_ATTR_INFO array
         //
         *ppAttr = NULL;
      }

      ASSERT(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues);

      //
      // Add in the required workstation flags
      //
      lUserAccountControl |= UF_WORKSTATION_TRUST_ACCOUNT | UF_ACCOUNTDISABLE | UF_PASSWD_NOTREQD;

      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo.pADsValues->Integer = lUserAccountControl;
      pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetErrorMessage
//
//  Synopsis:   Retrieves the error message associated with the HRESULT by 
//              using FormatMessage
//
//  Arguments:  [hr - IN]                 : HRESULT for which the error 
//                                          message is to be retrieved
//              [sbstrErrorMessage - OUT] : Receives the error message
//
//  Returns:    bool : true if the message was formatted properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool GetErrorMessage(HRESULT hr, CComBSTR& sbstrErrorMessage)
{
   ENTER_FUNCTION(MINIMAL_LOGGING, GetErrorMessage);

   HRESULT hrGetLast = S_OK;
   DWORD status = 0;
   PTSTR ptzSysMsg = NULL;

   //
   // first check if we have extended ADs errors
   //
   if (hr != S_OK) 
   {
      WCHAR Buf1[256], Buf2[256];
      hrGetLast = ::ADsGetLastError(&status, Buf1, 256, Buf2, 256);
      if ((status != ERROR_INVALID_DATA) && (status != 0)) 
      {
         hr = status;
         DEBUG_OUTPUT(MINIMAL_LOGGING, 
                      L"ADsGetLastError returned hr = 0x%x",
                      hr);

         if (HRESULT_CODE(hr) == ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER)
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"Displaying special error message for ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER");
            bool bLoadedMessage = sbstrErrorMessage.LoadString(::GetModuleHandle(NULL),
                                                               IDS_ERRMSG_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER);
            if (bLoadedMessage)
            {
               return true;
            }
         }
      }
   }

   //
   // try the system first
   //
   int nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                  | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, 
                                hr,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (PTSTR)&ptzSysMsg, 
                                0, 
                                NULL);

   if (nChars == 0) 
   { 
      //
      //try ads errors
      //
      static HMODULE g_adsMod = 0;
      if (0 == g_adsMod)
      {
         g_adsMod = GetModuleHandle (L"activeds.dll");
      }
      nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                 | FORMAT_MESSAGE_FROM_HMODULE, 
                               g_adsMod, 
                               hr,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                               (PTSTR)&ptzSysMsg, 
                               0, 
                               NULL);
   }

   if (nChars > 0)
   {
      //
      // Strip off the newline if there is one
      //
      PTSTR ptzTemp = ptzSysMsg;
      while (ptzTemp && *ptzTemp != _T('\0'))
      {
         if (*ptzTemp == _T('\n') || *ptzTemp == _T('\r'))
         {
            *ptzTemp = _T('\0');
         }
         ptzTemp++;
      }
      sbstrErrorMessage = ptzSysMsg;
      ::LocalFree(ptzSysMsg);
   }

   return (nChars > 0);
}

//+--------------------------------------------------------------------------
//
//  Function:   DisplayErrorMessage
//
//  Synopsis:   Displays the error message retrieved from GetErrorMessage 
//              to stderr. If GetErrorMessage fails, it displays the error
//              code of the HRESULT
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//              [hr - IN]        : HRESULT for which the error 
//                                 message is to be retrieved
//              [pszMessage - IN]: string of an additional message to be displayed
//                                 at the end
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//              10-May-2001   JonN      256583 output DSCMD-escaped DN
//
//---------------------------------------------------------------------------

bool DisplayErrorMessage(PCWSTR pszCommand,
                         PCWSTR pszName,
                         HRESULT hr, 
                         PCWSTR pszMessage)
{
   bool bRet = true;
   CComBSTR sbstrError;
   CComBSTR sbstrFailed;

   bool bGetError = false;
   if (FAILED(hr))
   {
      bGetError = GetErrorMessage(hr, sbstrError);
   }
   bool bLoadFailed = sbstrFailed.LoadString(::GetModuleHandle(NULL), IDS_FAILED);

   // JonN 5/10/01 256583 output DSCMD-escaped DN
   CComBSTR sbstrOutputDN;
   if (pszName && *pszName)
   {
      HRESULT hr = GetOutputDN( &sbstrOutputDN, pszName );
      if (FAILED(hr))
      {
          ASSERT(FALSE);
      }
      else
      {
         pszName = sbstrOutputDN;
      }
   }

   if (bGetError && bLoadFailed && pszName && pszMessage)
   {
      WriteStandardError(L"%s %s:%s:%s:%s\n", 
                         pszCommand, 
                         sbstrFailed, 
                         pszName, 
                         sbstrError, 
                         pszMessage);
   }
   else if (bGetError && bLoadFailed && pszName && !pszMessage)
   {
      WriteStandardError(L"%s %s:%s:%s\n",
                         pszCommand,
                         sbstrFailed,
                         pszName,
                         sbstrError);
   }
   else if (bGetError && bLoadFailed && !pszName && pszMessage)
   {
      WriteStandardError(L"%s %s:%s:%s\n",
                         pszCommand,
                         sbstrFailed,
                         sbstrError,
                         pszMessage);
   }
   else if (bGetError && bLoadFailed && !pszName && !pszMessage)
   {
      WriteStandardError(L"%s %s:%s\n",
                         pszCommand,
                         sbstrFailed,
                         sbstrError);
   }
   else if (!bGetError && bLoadFailed && !pszName && pszMessage)
   {
      WriteStandardError(L"%s %s:%s\n",
                         pszCommand,
                         sbstrFailed,
                         pszMessage);
   }
   else if (!bGetError && bLoadFailed && pszName && pszMessage)
   {
      WriteStandardError(L"%s %s:%s:%s\n",
                         pszCommand,
                         sbstrFailed,
                         pszName,
                         pszMessage);
   }
   else
   {
      WriteStandardError(L"Error code = 0x%x\n", hr);
      bRet = FALSE;
   }

   return bRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   DisplayErrorMessage
//
//  Synopsis:   Displays the error message retrieved from GetErrorMessage 
//              to stderr. If GetErrorMessage fails, it displays the error
//              code of the HRESULT
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//              [hr - IN]        : HRESULT for which the error 
//                                 message is to be retrieved
//              [nStringID - IN] : Resource ID an additional message to be displayed
//                                 at the end
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

bool DisplayErrorMessage(PCWSTR pszCommand,
                         PCWSTR pszName,
                         HRESULT hr, 
                         UINT nStringID)
{
   CComBSTR sbstrMessage;

   bool bLoadString = sbstrMessage.LoadString(::GetModuleHandle(NULL), nStringID);
   if (bLoadString)
   {
      return DisplayErrorMessage(pszCommand, pszName, hr, sbstrMessage);
   }
   return DisplayErrorMessage(pszCommand, pszName, hr);
}

//+--------------------------------------------------------------------------
//
//  Function:   DisplaySuccessMessage
//
//  Synopsis:   Displays a success message for the command
//
//  Arguments:  [pszCommand - IN]: the name of the command line executable
//              [pszName - IN]   : the name passed in as the target of the operation
//
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   JeffJon   Created
//              10-May-2001   JonN      256583 output DSCMD-escaped DN
//
//---------------------------------------------------------------------------

bool DisplaySuccessMessage(PCWSTR pszCommand,
                           PCWSTR pszName)
{
   //
   // Verify parameters
   //
   if (!pszCommand)
   {
      ASSERT(pszCommand);
      return false;
   }

   CComBSTR sbstrSuccess;
   if (!sbstrSuccess.LoadString(::GetModuleHandle(NULL), IDS_SUCCESS))
   {
      return false;
   }

   CComBSTR sbstrOutputDN;
   if (!pszName)
   {
      WriteStandardOut(L"%s %s\n", pszCommand, sbstrSuccess);
   }
   else
   {
      // JonN 5/10/01 256583 output DSCMD-escaped DN
      if (*pszName)
      {
         HRESULT hr = GetOutputDN( &sbstrOutputDN, pszName );
         if (FAILED(hr))
         {
             ASSERT(FALSE);
         }
         else
         {
            pszName = sbstrOutputDN;
         }
      }

      WriteStandardOut(L"%s %s:%s\n", pszCommand, sbstrSuccess, pszName);
   }

   return true;
}

//+--------------------------------------------------------------------------
//
//  Function:   WriteStringIDToStandardOut
//
//  Synopsis:   Loads the String Resource and displays on Standardout
//
//  Arguments:  nStringID :	Resource ID	
//  Returns:    bool : true if the message was formatted and displayed properly
//                     false otherwise
//
//  History:    11-Sep-2000   hiteshr Created
//
//---------------------------------------------------------------------------
bool WriteStringIDToStandardOut(UINT nStringID)
{

   CComBSTR sbstrSuccess;
   if (!sbstrSuccess.LoadString(::GetModuleHandle(NULL), nStringID))
   {
      return false;
   }

   WriteStandardOut(sbstrSuccess);
   return true;
}


//+---------------------------------------------------------------------------
//
//  Function:   ExpandUsername
//
//  Synopsis:   If the value in pwzValue contains %username% it gets expanded
//              to be the sAMAccountName
//
//  Arguments:  [pwzValue IN/OUT] : string that may contain %username%
//              [pwzSamName IN]   : the SAM name to substitute
//              [fExpanded OUT]   : whether the value needed to be expanded or not
//
//  Return:     bool : true if the function succeeded, false otherwise
//
//  History     27-Oct-2000   JeffJon  Created
//----------------------------------------------------------------------------
bool ExpandUsername(PWSTR& pwzValue, PWSTR pwzSamName, bool& fExpanded)
{
  ENTER_FUNCTION(LEVEL5_LOGGING, ExpandUsername);

  PCWSTR pszUserToken = L"$username$";
  unsigned int TokenLength = static_cast<unsigned int>(wcslen(pszUserToken));

  bool bRet = false;

  do // false loop
  {
     if (!pwzValue)
     {
        ASSERT(pwzValue);
        break;
     }

     //
     // This determines if expansion is needed
     //
     PWSTR pwzTokenStart = wcschr(pwzValue, pszUserToken[0]);
     if (pwzTokenStart)
     {
       if ((wcslen(pwzTokenStart) >= TokenLength) &&
           (_wcsnicmp(pwzTokenStart, pszUserToken, TokenLength) == 0))
       {
         fExpanded = true;
       }
       else
       {
         fExpanded = false;
         bRet = true;
         break;
       }
     }
     else
     {
       fExpanded = false;
       bRet = true;
       break;
     }

     //
     // If the samName isn't given return without doing anything
     // This is useful to just determine if expansion is needed or not
     //
     if (!pwzSamName)
     {
       bRet = false;
       break;
     }

     CComBSTR sbstrValue;
     CComBSTR sbstrAfterToken;

     while (pwzTokenStart)
     {
       *pwzTokenStart = L'\0';

       sbstrValue = pwzValue;

       if ((L'\0' != *pwzValue) && !sbstrValue.Length())
       {
         bRet = false;
         break;
       }

       PWSTR pwzAfterToken = pwzTokenStart + TokenLength;

       sbstrAfterToken = pwzAfterToken;

       if ((L'\0' != *pwzAfterToken) && !sbstrAfterToken.Length())
       {
         bRet = false;
         break;
       }

       delete pwzValue;

       sbstrValue += pwzSamName;

       if (!sbstrValue.Length())
       {
         bRet = false;
         break;
       }

       sbstrValue += sbstrAfterToken;

       if (!sbstrValue.Length())
       {
         bRet = false;
         break;
       }

       pwzValue = new WCHAR[sbstrValue.Length() + 1];
       if (!pwzValue)
       {
         bRet = false;
         break;
       }
       wcscpy(pwzValue, sbstrValue);

       pwzTokenStart = wcschr(pwzValue, pszUserToken[0]);
       if (!(pwzTokenStart &&
             (wcslen(pwzTokenStart) >= TokenLength) &&
             (_wcsnicmp(pwzTokenStart, pszUserToken, TokenLength) == 0)))
       {
         bRet = true;
         break;
       }
     } // while
  } while (false);

  return bRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   FillAttrInfoFromObjectEntryExpandUsername
//
//  Synopsis:   Fills the ADS_ATTR_INFO from the attribute table associated
//              with the object entry and expands values containing %username%
//
//  Arguments:  [pszDN - IN]          : pointer to a string containing the DN
//                                      to the object being modified
//              [refBasePathsInfo - IN] : reference to an instance of the 
//                                      CDSCmdBasePathsInfo class
//              [refCredentialObject - IN] : reference to an instance of the 
//                                      CDSCmdCredentialObject class
//              [pObjectEntry - IN]   : pointer to an entry in the object table
//                                      that defines the object we are modifying
//              [argRecord - IN]      : the argument record structure from the
//                                      parser table that corresponds to this
//                                      attribute
//              [dwAttributeIdx - IN] : index into the attribute table for the
//                                      object in which we are setting
//              [ppAttr - IN/OUT]     : pointer to the ADS_ATTR_INFO structure
//                                      which this function will fill in
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_OUTOFMEMORY if we failed to allocate space for the value
//                        E_FAIL if we failed to format the value properly
//
//  History:    27-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT FillAttrInfoFromObjectEntryExpandUsername(PCWSTR pszDN,
                                                  const CDSCmdBasePathsInfo& refBasePathsInfo,
                                                  const CDSCmdCredentialObject& refCredentialObject,
                                                  const PDSOBJECTTABLEENTRY pObjectEntry,
                                                  const ARG_RECORD& argRecord,
                                                  DWORD dwAttributeIdx,
                                                  PADS_ATTR_INFO* ppAttr)
{
   ENTER_FUNCTION_HR(LEVEL3_LOGGING, FillAttrInfoFromObjectEntryExpandUsername, hr);

   do // false loop
   {
      //
      // Verify Parameters
      //
      if (!pObjectEntry ||
          !ppAttr ||
          !pszDN)
      {
         ASSERT(pObjectEntry);
         ASSERT(ppAttr);
         ASSERT(pszDN);

         hr = E_INVALIDARG;
         break;
      }

      if (argRecord.strValue && argRecord.strValue[0] != L'\0')
      {
         //
         // REVIEW_JEFFJON : this is being leaked!!!
         //
         PWSTR pszValue = new WCHAR[wcslen(argRecord.strValue) + 1];
         if (!pszValue)
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         wcscpy(pszValue, argRecord.strValue);

         //
         // First check to see if we need to expand %username%
         //
         CComBSTR sbstrSamName;
         bool bExpandNeeded = false;
         ExpandUsername(pszValue, NULL, bExpandNeeded);
         if (bExpandNeeded)
         {
            DEBUG_OUTPUT(LEVEL5_LOGGING, L"%username% expansion required.  Retrieving sAMAccountName...");

            //
            // Retrieve the sAMAccountName of the object and then expand the %username%
            //
            CComBSTR sbstrPath;
            refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

            CComPtr<IADs> spADs;
            hr = DSCmdOpenObject(refCredentialObject,
                                 sbstrPath,
                                 IID_IADs,
                                 (void**)&spADs,
                                 true);
            if (FAILED(hr))
            {
               break;
            }

            CComVariant var;
            hr = spADs->Get(L"sAMAccountName", &var);
            if (FAILED(hr))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, 
                            L"Failed to get sAMAccountName: hr = 0x%x",
                            hr);
               break;
            }

            ASSERT(var.vt == VT_BSTR);
            sbstrSamName = var.bstrVal;

            DEBUG_OUTPUT(LEVEL5_LOGGING,
                         L"sAMAccountName = %w",
                         sbstrSamName);

            //
            // Now expand the username to the sAMAccountName
            //
            if (!ExpandUsername(pszValue, sbstrSamName, bExpandNeeded))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Failed to expand %username%");
               hr = E_OUTOFMEMORY;
               break;
            }
         }

         switch (argRecord.fType)
         {
         case ARG_TYPE_STR :
            DEBUG_OUTPUT(LEVEL3_LOGGING, L"argRecord.fType = ARG_TYPE_STR");

            *ppAttr = &(pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->adsAttrInfo);

            //
            // REVIEW_JEFFJON : this is being leaked!
            //
            (*ppAttr)->pADsValues = new ADSVALUE[1];
            if ((*ppAttr)->pADsValues)
            {
               (*ppAttr)->dwNumValues = 1;
               (*ppAttr)->pADsValues->dwType = (*ppAttr)->dwADsType;
               switch ((*ppAttr)->dwADsType)
               {
               case ADSTYPE_DN_STRING :
                  {
                     //
                     // Lets bind to be sure the object exists
                     //
                     CComBSTR sbstrObjPath;
                     refBasePathsInfo.ComposePathFromDN(pszValue, sbstrObjPath);

                     CComPtr<IADs> spIADs;
                     hr = DSCmdOpenObject(refCredentialObject,
                                          sbstrObjPath,
                                          IID_IADs,
                                          (void**)&spIADs,
                                          true);

                     if (FAILED(hr))
                     {
                        DEBUG_OUTPUT(LEVEL3_LOGGING, L"DN object doesn't exist. %s", pszValue);
                        break;
                     }

                     (*ppAttr)->pADsValues->DNString = pszValue;
                     DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_DN_STRING = %s", pszValue);
                  }
                  break;

               case ADSTYPE_CASE_EXACT_STRING :
                  (*ppAttr)->pADsValues->CaseExactString = pszValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_CASE_EXACT_STRING = %s", pszValue);
                  break;

               case ADSTYPE_CASE_IGNORE_STRING :
                  (*ppAttr)->pADsValues->CaseIgnoreString = pszValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_CASE_IGNORE_STRING = %s", pszValue);
                  break;

               case ADSTYPE_PRINTABLE_STRING :
                  (*ppAttr)->pADsValues->PrintableString = pszValue;
                  DEBUG_OUTPUT(LEVEL3_LOGGING, L"ADSTYPE_PRINTABLE_STRING = %s", pszValue);
                  break;

               default :
                  hr = E_INVALIDARG;
                  break;
               }
               //
               // Set the attribute dirty
               //
               pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
      
            }
            break;

         default:
            hr = E_INVALIDARG;
            break;
         }
      }
      else
      {
         DEBUG_OUTPUT(LEVEL3_LOGGING, L"No value present, changing control code to ADS_ATTR_CLEAR");
         //
         // Clear the attribute
         //
         (*ppAttr)->dwControlCode = ADS_ATTR_CLEAR;
         (*ppAttr)->dwNumValues = 0;

         //
         // Set the attribute dirty
         //
         pObjectEntry->pAttributeTable[dwAttributeIdx]->pAttrDesc->dwFlags |= DS_ATTRIBUTE_DIRTY;
      }

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BindToFSMOHolder
//
//  Synopsis:   Binds to the appropriate object which can be used to find a
//              particular FSMO owner
//
//  Arguments:  [refBasePathsInfo - IN] : reference to the base paths info object
//              [refCredObject - IN]    : reference to the credential management object
//              [fsmoType - IN]         : type of the FSMO we are searching for
//              [refspIADs - OUT]       : interface to the object that will be
//                                        used to start a search for the FSMO owner
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if an invalid FSMO type was passed
//                        Otherwise an ADSI failure code
//
//  History:    13-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT BindToFSMOHolder(IN  const CDSCmdBasePathsInfo&       refBasePathsInfo,
                         IN  const CDSCmdCredentialObject& refCredObject,
                         IN  FSMO_TYPE                  fsmoType,
                         OUT CComPtr<IADs>&             refspIADs)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, BindToFSMOHolder, hr);

    refspIADs = 0;
    CComBSTR sbstrDN;

    switch (fsmoType)
    {
        case SCHEMA_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = SCHEMA_FSMO");
            sbstrDN = refBasePathsInfo.GetSchemaNamingContext();
            break;
          }

        case RID_POOL_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = RID_POOL_FSMO");

            sbstrDN = refBasePathsInfo.GetDefaultNamingContext();

            CComBSTR sbstrPath;
            refBasePathsInfo.ComposePathFromDN(sbstrDN, sbstrPath);

            CComPtr<IADs> spIADsDefault;
            hr = DSCmdOpenObject(refCredObject,
                                 sbstrPath,
                                 IID_IADs,
                                 (void**)&spIADsDefault,
                                 true);
            if (FAILED(hr))
            {
                break;
            }

            CComVariant var;
            hr = spIADsDefault->Get(g_bstrIDManagerReference, &var);
            if (FAILED(hr))
            {
                break;
            }

            ASSERT(var.vt == VT_BSTR);
            sbstrDN = var.bstrVal;
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"rIDManagerReference = %s",
                         sbstrDN);

            break;
          }
            
        case PDC_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = PDC_FSMO");

            sbstrDN = refBasePathsInfo.GetDefaultNamingContext();
            break;
          }

        case INFRASTUCTURE_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = INFRASTUCTURE_FSMO");

            sbstrDN = refBasePathsInfo.GetDefaultNamingContext();
            break;
          }

        case DOMAIN_NAMING_FSMO:
          {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"FSMO_TYPE = DOMAIN_NAMING_FSMO");

            sbstrDN = L"CN=Partitions,";
            sbstrDN += refBasePathsInfo.GetConfigurationNamingContext();
            break;
          }
            
        default:
            ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    if (SUCCEEDED(hr))
    {
        CComBSTR sbstrPath;
        refBasePathsInfo.ComposePathFromDN(sbstrDN, sbstrPath);

        hr = DSCmdOpenObject(refCredObject,
                             sbstrPath,
                             IID_IADs,
                             (void**)&refspIADs,
                             true);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   FindFSMOOwner
//
//  Synopsis:   
//
//  Arguments:  [refBasePathsInfo - IN] : reference to the base paths info object
//              [refCredObject - IN]    : reference to the credential management object
//              [fsmoType - IN]         : type of the FSMO we are searching for
//              [refspIADs - OUT]       : interface to the object that will be
//                                        used to start a search for the FSMO owner
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        Otherwise an ADSI failure code
//
//  History:    13-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT FindFSMOOwner(IN  const CDSCmdBasePathsInfo&       refBasePathsInfo,
                      IN  const CDSCmdCredentialObject& refCredObject,
                      IN  FSMO_TYPE                  fsmoType,
                      OUT CComBSTR&                  refsbstrServerDN)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, FindFSMOOwner, hr);

    refsbstrServerDN.Empty();

    static const int nMaxReferrals = 10;
    int nIterations = 0;

    //
    // We will start the search with the current server
    //
    CComBSTR sbstrNextServer;
    sbstrNextServer = refBasePathsInfo.GetServerName();

    do
    {
        //
        // Initialize a new base paths info object on each iteration
        //
        CDSCmdBasePathsInfo nextPathsInfo;
        hr = nextPathsInfo.InitializeFromName(refCredObject,
                                              sbstrNextServer,
                                              true);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to initialize the base paths info for %s: hr = 0x%x",
                         sbstrNextServer,
                         hr);
            break;
        }

        //
        // Now bind to the fsmo holder for that server
        //
        CComPtr<IADs> spIADs;
        hr = BindToFSMOHolder(nextPathsInfo,
                              refCredObject,
                              fsmoType,
                              spIADs);
        if (FAILED(hr))
        {
            break;
        }

        //
        // Get the fSMORoleOwner property
        //
        CComVariant fsmoRoleOwnerProperty;
        hr = spIADs->Get(g_bstrFSMORoleOwner, &fsmoRoleOwnerProperty);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to get the fSMORoleOwner: hr = 0x%x",
                         hr);
            break;
        }

        //
        // The result here is in the form, "CN=NTDS Settings,CN=Machine,CN=..."
        // we need to just have "CN=Machine,CN=..."
        //
        CComBSTR sbstrMachineOwner;
        hr = CPathCracker::GetParentDN(fsmoRoleOwnerProperty.bstrVal, sbstrMachineOwner);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to get the parent DN of the FSMORoleOwner: hr = 0x%x",
                         hr);
            break;
        }

        CComBSTR sbstrMachinePath;
        nextPathsInfo.ComposePathFromDN(sbstrMachineOwner, sbstrMachinePath);

        //
        // Bind to the server object so we can get the dnsHostName to compare to the server name
        //
        CComPtr<IADs> spIADsServer;
        hr = DSCmdOpenObject(refCredObject,
                             sbstrMachinePath,
                             IID_IADs,
                             (void**)&spIADsServer,
                             true);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to bind to server object: hr = 0x%x",
                         hr);
            break;
        }

        //
        // Get the DNS host name
        //
        CComVariant varServerName;
        hr = spIADsServer->Get(g_bstrDNSHostName, &varServerName);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to get the dNSHostName: hr = 0x%x",
                         hr);
            break;
        }

        ASSERT(varServerName.vt == VT_BSTR);
        sbstrNextServer = varServerName.bstrVal;

        //
        // If the server name in the dNSHostName attribute matches the current
        // base paths info, then we found the owner
        //
        if (0 == _wcsicmp(sbstrNextServer, nextPathsInfo.GetServerName()))
        {
            //
            // We found it
            //
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"The role owner is %s",
                         sbstrNextServer);
            refsbstrServerDN = sbstrMachineOwner;
            break;
        }

        ++nIterations;
    } while (nIterations < nMaxReferrals);

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   ValidateAndModifySAMName
//
//  Synopsis:   Looks for any illegal characters in the SamAccountName and
//              converts them to the replacementChar
//
//  Arguments:  [pszSAMName - IN/OUT]  : pointer to a string that contains the SamAccountName
//                                       illegal characters will be replaced
//              [pszInvalidChars - IN] : string containing the illegal characters
//
//  Returns:    HRESULT : S_OK if the name was valid and no characters had to be replaced
//                        S_FALSE if the name contained invalid characters that were replaced
//                        E_INVALIDARG
//
//  History:    21-Feb-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ValidateAndModifySAMName(PWSTR pszSAMName, 
                                 PCWSTR pszInvalidChars)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, ValidateAndModifySAMName, hr);

    static const WCHAR replacementChar = L'_';

    do
    {
        if (!pszSAMName ||
            !pszInvalidChars)
        {
            ASSERT(pszSAMName);
            ASSERT(pszInvalidChars);

            hr = E_INVALIDARG;
            break;
        }

        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"SAM name before: %s",
                     pszSAMName);

        for (size_t idx = 0; idx < wcslen(pszInvalidChars); ++idx)
        {
            WCHAR* illegalChar = 0;
            do
            {
                illegalChar = wcschr(pszSAMName, pszInvalidChars[idx]);
                if (illegalChar)
                {
                    *illegalChar = replacementChar;
                    hr = S_FALSE;
                }
            } while (illegalChar);
        }
    } while (false);

    DEBUG_OUTPUT(LEVEL3_LOGGING,
                 L"SAM name after: %s",
                 pszSAMName);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Class:      GetEscapedElement
//
//  Purpose:    Calls IADsPathname::GetEscapedElement.  Uses LocalAlloc.
//
//  History:    28-Apr-2001 JonN     Created
//
//---------------------------------------------------------------------------
HRESULT GetEscapedElement( OUT PWSTR* ppszOut, IN PCWSTR pszIn )
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, GetEscapedElement, hr);

    CPathCracker pathCracker;
    CComBSTR sbstrIn = pszIn;
    CComBSTR sbstrEscaped;
    if (sbstrIn.Length() > 0) // handle empty path component
    {
        hr = pathCracker.GetEscapedElement(0,
                                           sbstrIn,
                                           &sbstrEscaped);
        if (FAILED(hr))
            return hr;
        else if (!sbstrEscaped)
            return E_FAIL;
    }
    *ppszOut = (LPWSTR)LocalAlloc(LPTR, (sbstrEscaped.Length()+1) * sizeof(WCHAR) );
    if (NULL == *ppszOut)
        return E_OUTOFMEMORY;
    if (sbstrIn.Length() > 0) // handle empty path component
        wcscpy( *ppszOut, sbstrEscaped );

    return hr;

} // GetEscapedElement

//+--------------------------------------------------------------------------
//
//  Class:      GetOutputDN
//
//  Purpose:    Converts an ADSI-escaped DN to one with DSCMD input escaping.
//              This way, the output DN can be piped as input to another
//              DSCMD command.
//
//  History:    08-May-2001 JonN     Created
//
//---------------------------------------------------------------------------
HRESULT GetOutputDN( OUT BSTR* pbstrOut, IN PCWSTR pszIn )
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, GetOutputDN, hr);

    if (NULL == pszIn || L'\0' == *pszIn)
    {
        *pbstrOut = SysAllocString(L"");
        return (NULL == *pbstrOut) ? E_OUTOFMEMORY : S_OK;
    }

    CPathCracker pathCracker;
    CComBSTR sbstrIn = pszIn;
    hr = pathCracker.Set(sbstrIn, ADS_SETTYPE_DN);
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        return hr;
    }

    long lnNumPathElements = 0;
    hr = pathCracker.GetNumElements( &lnNumPathElements );
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        return hr;
    }
    else if (0 >= lnNumPathElements)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    hr = pathCracker.put_EscapedMode( ADS_ESCAPEDMODE_OFF_EX );
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        return hr;
    }

    CComBSTR sbstrOut;
    CComBSTR sbstrComma( L"," );
    for (long lnPathElement = 0;
         lnPathElement < lnNumPathElements;
         lnPathElement++)
    {
        CComBSTR sbstrElement;
        hr = pathCracker.GetElement( lnPathElement, &sbstrElement );
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            return hr;
        }

        // re-escape sbstrElement
        CComBSTR sbstrEscapedElement( (sbstrElement.Length()+1) * 2 );
        ::ZeroMemory( (BSTR)sbstrEscapedElement,
                      (sbstrElement.Length()+1) * 2 * sizeof(WCHAR) );
        LPWSTR pszEscapedElement = sbstrEscapedElement;
        for (LPWSTR pszElement = sbstrElement;
             L'\0' != *pszElement;
             pszElement++)
        {
            switch (*pszElement)
            {
            case ',':
            case '\\':
                *(pszEscapedElement++) = L'\\';
                // fall through
            default:
                *(pszEscapedElement++) = *pszElement;
                break;
            }
        }

        if (!!sbstrOut)
            sbstrOut += sbstrComma;
        // cast to avoid CComBSTR::operator+= "bug"
        sbstrOut += (BSTR)sbstrEscapedElement;
    }

    *pbstrOut = sbstrOut.Detach();

    return hr;

} // GetOutputDN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parserutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      parserutil.cpp
//
//  Contents:  Helpful functions for manipulating and validating 
//             generic command line arguments
//
//  History:   07-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------


#include "pch.h"
#include "iostream.h"

//+--------------------------------------------------------------------------
//
//  Function:   GetPasswdStr
//
//  Synopsis:   Reads a password string from stdin without echoing the keystrokes
//
//  Arguments:  [buf - OUT]    : buffer to put string in
//              [buflen - IN]  : size of the buffer
//              [&len - OUT]   : length of the string placed into the buffer
//
//  Returns:    DWORD : 0 or ERROR_INSUFFICIENT_BUFFER if user typed too much.
//                      Buffer contents are only valid on 0 return.
//
//  History:    07-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
#define CR              0xD
#define BACKSPACE       0x8

DWORD GetPasswdStr(LPTSTR  buf,
                   DWORD   buflen,
                   PDWORD  len)
{
    TCHAR	ch;
    TCHAR	*bufPtr = buf;
    DWORD	c;
    int		err;
    DWORD   mode;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;               /* GP fault probe (a la API's) */
    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) 
    {
	    err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
	    if (!err || c != 1)
	        ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) 
        {  /* back up one or two */
           /*
           * IF bufPtr == buf then the next two lines are
           * a no op.
           */
           if (bufPtr != buf) 
           {
                    bufPtr--;
                    (*len)--;
           }
        }
        else 
        {
                *bufPtr = ch;

                if (*len < buflen) 
                    bufPtr++ ;                   /* don't overflow buf */
                (*len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = TEXT('\0');         /* null terminate the string */
    putwchar(TEXT('\n'));

    return ((*len <= buflen) ? 0 : ERROR_INSUFFICIENT_BUFFER);
}


//+--------------------------------------------------------------------------
//
//  Function:   ValidatePassword
//
//  Synopsis:   Password validation function called by parser
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : ERROR_INVALID_PARAMETER if the argument record or
//                          the value it contains is not valid
//                      ERROR_NOT_ENOUGH_MEMORY
//                      ERROR_SUCCESS if everything succeeded and it is a
//                          valid password
//                      Otherwise it is an error condition returned from
//                          GetPasswdStr
//
//  History:    07-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
DWORD ValidatePassword(PVOID pArg, UINT IdStr)
{
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec || !pRec->strValue)
        return ERROR_INVALID_PARAMETER;
    
    if(wcscmp(pRec->strValue, L"*") != 0 )
        return ERROR_SUCCESS;

    CComBSTR sbstrPrompt;
    if(sbstrPrompt.LoadString(::GetModuleHandle(NULL),IdStr))
    {
        DisplayOutput(sbstrPrompt);
    }
    else
        DisplayOutput(L"Enter Password\n");    
        
    WCHAR buffer[MAX_PASSWORD_LENGTH];
    DWORD len = 0;
    DWORD dwErr = GetPasswdStr(buffer,MAX_PASSWORD_LENGTH,&len);
    if(dwErr != ERROR_SUCCESS)
        return dwErr;
            
    LocalFree(pRec->strValue);
    pRec->strValue = (LPWSTR)LocalAlloc(LPTR,sizeof(WCHAR)*(len+1));
    if(!pRec->strValue)
        return ERROR_NOT_ENOUGH_MEMORY;
    else
    {
        wcscpy(pRec->strValue,buffer);
        return ERROR_SUCCESS;                                                                
    }                
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateAdminPassword
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : ERROR_INVALID_PARAMETER if the argument record or
//                          the value it contains is not valid
//                      ERROR_SUCCESS if everything succeeded and it is a
//                          valid password
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------
DWORD ValidateAdminPassword(PVOID pArg)
{
    return ValidatePassword(pArg,IDS_ADMIN_PASSWORD_PROMPT);
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateUserPassword
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------
DWORD ValidateUserPassword(PVOID pArg)
{
    return ValidatePassword(pArg, IDS_USER_PASSWORD_PROMPT);
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateYesNo
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------

DWORD ValidateYesNo(PVOID pArg)
{
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec || !pRec->strValue)
        return ERROR_INVALID_PARAMETER;

    CComBSTR sbstrYes;
    CComBSTR sbstrNo;
    CComBSTR sbstrInput;

    if(!sbstrYes.LoadString(::GetModuleHandle(NULL),IDS_YES))
    {
        return ERROR_RESOURCE_DATA_NOT_FOUND;
    }
    if(!sbstrNo.LoadString(::GetModuleHandle(NULL), IDS_NO))
    {
        return ERROR_RESOURCE_DATA_NOT_FOUND;
    }
    sbstrYes.ToLower();
    sbstrNo.ToLower();
    sbstrInput = pRec->strValue;
    sbstrInput.ToLower();
    if( sbstrInput == sbstrYes )
    {
        LocalFree(pRec->strValue);
        pRec->bValue = TRUE;
    }
    else if( sbstrInput == sbstrNo )
    {
        LocalFree(pRec->strValue);
        pRec->bValue = FALSE;
    }
    else
        return ERROR_INVALID_PARAMETER;

    //
    // Have to set this to bool or else
    // FreeCmd will try to free the string
    // which AVs when the bool is true
    //
    pRec->fType = ARG_TYPE_BOOL;
    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateNever
//
//  Synopsis:   Password validation function called by parser for Admin
//              Verifies the value contains digits or "NEVER"
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   JeffJon Created
//
//---------------------------------------------------------------------------

DWORD ValidateNever(PVOID pArg)
{
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec)
        return ERROR_INVALID_PARAMETER;

    if (pRec->fType == ARG_TYPE_STR)
    {
       CComBSTR sbstrInput;
       sbstrInput = pRec->strValue;
       if( _wcsicmp(sbstrInput, g_bstrNever) )
       {
          return ERROR_INVALID_PARAMETER;
       }
    }
    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateGroupScope
//
//  Synopsis:   Makes sure that the value following the -scope switch is one
//              of (l/g/u)
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    18-Sep-2000   JeffJon Created
//
//---------------------------------------------------------------------------

DWORD ValidateGroupScope(PVOID pArg)
{
    DWORD dwReturn = ERROR_SUCCESS;
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec || !pRec->strValue)
        return ERROR_INVALID_PARAMETER;

    CComBSTR sbstrInput;
    sbstrInput = pRec->strValue;
    sbstrInput.ToLower();
    if(sbstrInput == _T("l") ||
       sbstrInput == _T("g") ||
       sbstrInput == _T("u"))
    {
        dwReturn = ERROR_SUCCESS;
    }
    else
    {
        dwReturn = ERROR_INVALID_PARAMETER;
    }

    return dwReturn;
}

//+--------------------------------------------------------------------------
//
//  Function:   MergeArgCommand
//
//  Synopsis:   Combines two ARG_RECORD arrays into a single
//
//  Arguments:  [pCommand1 - IN]     : first ARG_RECORD array to merge
//              [pCommand2 - IN]     : second ARG_RECORD array to merge
//              [ppOutCommand - OUT] : the array that results from the merge
//
//  Returns:    HRESULT : S_OK on success
//                        E_OUTOFMEMORY if failed to allocate memory for new array
//
//  History:    08-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT MergeArgCommand(PARG_RECORD pCommand1, 
                        PARG_RECORD pCommand2, 
                        PARG_RECORD *ppOutCommand)
{
   HRESULT hr = S_OK;

   //
   // Verify parameters
   //
   if (!pCommand1 && pCommand2)
   {
      *ppOutCommand = pCommand2;
      return hr;
   }
   else if (pCommand1 && !pCommand2)
   {
      *ppOutCommand = pCommand1;
      return hr;
   }
   else if (!pCommand1 && !pCommand2)
   {
      return E_INVALIDARG;
   }

   LONG nSize1 = 0;
   LONG nSize2 = 0;

   UINT i = 0;

   for(i=0; pCommand1[i].fType != ARG_TYPE_LAST ;i++)
   {
      ++nSize1;
   }
   for(i=0; pCommand2[i].fType != ARG_TYPE_LAST ;i++)
   {
      ++nSize2;
   }

   *ppOutCommand = (PARG_RECORD)LocalAlloc(LPTR, sizeof(ARG_RECORD)*(nSize1+nSize2+1));
   if(!*ppOutCommand)
   {
      return E_OUTOFMEMORY;
   }

   memcpy(*ppOutCommand,pCommand1,sizeof(ARG_RECORD)*nSize1);        
   memcpy((*ppOutCommand+nSize1),pCommand2,sizeof(ARG_RECORD)*(nSize2+1));        

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ParseStringByChar
//
//  Synopsis:   Parses a string into elements separated by the given character
//
//  Arguments:  [psz - IN]     : string to be parsed
//              [tchar - IN]   : character that is to be used as the separator
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    18-Sep-2000   JeffJon   Created
//              14-Apr-2001   JeffJon   Modified to separate on a generic character
//
//---------------------------------------------------------------------------

void ParseStringByChar(PTSTR psz,
                       TCHAR tchar,
							  PTSTR** ppszArr,
							  UINT* pnArrEntries)
{
   //
   // Verify parameters
   //
   if (!psz ||
       !ppszArr ||
       !pnArrEntries)
   {
      ASSERT(psz);
      ASSERT(ppszArr);
      ASSERT(pnArrEntries);

      return;
   }

   //
   // Count the number of strings
   //
   UINT nCount = 0;
   PTSTR pszTemp = psz;
   while (true)
   {
      if (pszTemp[0] == tchar && 
          pszTemp[1] == tchar)
      {
         nCount++;
         break;
      }
      else if (pszTemp[0] == tchar &&
               pszTemp[1] != tchar)
      {
         nCount++;
         pszTemp++;
      }
      else
      {
         pszTemp++;
      }
   }

   *pnArrEntries = nCount;

   //
   // Allocate the array
   //
   *ppszArr = (PTSTR*)LocalAlloc(LPTR, nCount * sizeof(PTSTR));
   if (*ppszArr)
   {
      //
      // Copy the string pointers into the array
      //
      UINT nIdx = 0;
      pszTemp = psz;
      (*ppszArr)[nIdx] = pszTemp;
      nIdx++;

      while (true)
      {
         if (pszTemp[0] == tchar && 
             pszTemp[1] == tchar)
         {
            break;
         }
         else if (pszTemp[0] == tchar &&
                  pszTemp[1] != tchar)
         {
            (*ppszArr)[nIdx] = &(pszTemp[1]);
            nIdx++;
            pszTemp++;
         }
         else
         {
            pszTemp++;
         }
      }
   }
}

//+--------------------------------------------------------------------------
//
//  Function:   ParseNullSeparatedString
//
//  Synopsis:   Parses a '\0' separated list that ends in "\0\0" into a string
//              array
//
//  Arguments:  [psz - IN]     : '\0' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    14-Apr-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseNullSeparatedString(PTSTR psz,
                              PTSTR** ppszArr,
                              UINT* pnArrEntries)
{
   ParseStringByChar(psz,
                     L'\0',
                     ppszArr,
                     pnArrEntries);
}

//+--------------------------------------------------------------------------
//
//  Function:   ParseSemicolonSeparatedString
//
//  Synopsis:   Parses a ';' separated list 
//
//  Arguments:  [psz - IN]     : ';' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    14-Apr-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseSemicolonSeparatedString(PTSTR psz,
                                   PTSTR** ppszArr,
                                   UINT* pnArrEntries)
{
   ParseStringByChar(psz,
                     L';',
                     ppszArr,
                     pnArrEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      pch.h
//
//  Contents:  Precompiled header for this project
//
//  History:   06-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

//
// System includes
//
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windows.h>
#include <stdio.h>

#include <atlbase.h>

//
// ILLEGAL_FAT_CHARS
//
#include <validc.h>


//
// ADSI headers
//
#include <iads.h>
#include <activeds.h>

//
// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.
//
#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG

//
// Parser header file
//
#include "varg.h"

#include "strings.h"
#include "parserutil.h"
#include "pcrack.h"
#include "util.h"

#include "dsutil.h"
#include "dsutilrc.h"


//
// Some global defines
//
#define MAX_PASSWORD_LENGTH 128  // including the NULL terminator
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\query.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSQuery.h
//
//  Contents:  Query object for DS snapin
//
//  History:   04-dec-96 jimharr    Created
//
//--------------------------------------------------------------------------


#ifndef __QUERY_H__
#define __QUERY_H__

#define QUERY_PAGESIZE 50

//
// CDSSearch
//
class CDSSearch
{
public:
  CDSSearch();
  ~CDSSearch();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT Init(PCWSTR pszPath, const CDSCmdCredentialObject& refCredObject);
  HRESULT DoQuery(BOOL bAttrOnly = FALSE);
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) 
  {
    return m_pObj->FreeColumn(pColumnData);
  };
  HRESULT SetAttributeList (LPTSTR *pszAttribs, INT cAttrs);  
  HRESULT SetSearchScope (ADS_SCOPEENUM scope);
  HRESULT SetFilterString (LPWSTR pszFilter) 
  {
    if (!pszFilter)
    {
       return E_INVALIDARG;
    }

    if (m_pwszFilter)
    {
       delete[] m_pwszFilter;
       m_pwszFilter = NULL;
    }
    m_pwszFilter = new WCHAR[wcslen(pszFilter) + 1];
    if (!m_pwszFilter)
    {
       return E_OUTOFMEMORY;
    }

    wcscpy(m_pwszFilter, pszFilter);
    return S_OK;
  };
  HRESULT GetNextColumnName(LPWSTR *ppszColumnName);
  VOID FreeColumnName(LPWSTR pszColumnName)
  {
    FreeADsMem(pszColumnName);

  }    

  //Attributes
public:
  IDirectorySearch   * m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR             m_pwszFilter;
  LPWSTR *           m_ppszAttr;
  DWORD              m_CountAttr;
  ADS_SCOPEENUM      m_scope;

private:
  void _Reset();
  BOOL m_bInitialized;  
};
        


#endif //__DSQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parserutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      parserutil.h
//
//  Contents:  Helpful functions for manipulating and validating 
//             generic command line arguments
//
//  History:   07-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _PARSEUTIL_H_
#define _PARSEUTIL_H_

HRESULT MergeArgCommand(PARG_RECORD pCommand1, 
                        PARG_RECORD pCommand2, 
                        PARG_RECORD *ppOutCommand);

DWORD GetPasswdStr(LPTSTR  buf,
                   DWORD   buflen,
                   PDWORD  len);
DWORD ValidateAdminPassword(PVOID pArg);
DWORD ValidateUserPassword(PVOID pArg);
DWORD ValidateYesNo(PVOID pArg);
DWORD ValidateGroupScope(PVOID pArg);
DWORD ValidateNever(PVOID pArg);

//+--------------------------------------------------------------------------
//
//  Function:   ParseNullSeparatedString
//
//  Synopsis:   Parses a '\0' separated list that ends in "\0\0" into a string
//              array
//
//  Arguments:  [psz - IN]     : '\0' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseNullSeparatedString(PTSTR psz,
								      PTSTR** ppszArr,
								      UINT* pnArrEntries);

//+--------------------------------------------------------------------------
//
//  Function:   ParseSemicolonSeparatedString
//
//  Synopsis:   Parses a ';' separated list 
//
//  Arguments:  [psz - IN]     : ';' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    14-Apr-2001   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseSemicolonSeparatedString(PTSTR psz,
                                   PTSTR** ppszArr,
                                   UINT* pnArrEntries);

#endif // _PARSEUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\secutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:      SecUtil.h
//
//  Contents:  Utility functions for working with the security APIs
//
//  History:   15-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _SECUTIL_H_
#define _SECUTIL_H_

extern const GUID GUID_CONTROL_UserChangePassword;

//+--------------------------------------------------------------------------
//
//  Class:      CSimpleSecurityDescriptorHolder
//
//  Purpose:    Smart wrapper for a SecurityDescriptor
//
//  History:    15-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CSimpleSecurityDescriptorHolder
{
public:
   //
   // Constructor and Destructor
   //
   CSimpleSecurityDescriptorHolder();
   ~CSimpleSecurityDescriptorHolder();

   //
   // Public member data
   //
   PSECURITY_DESCRIPTOR m_pSD;
private:
   CSimpleSecurityDescriptorHolder(const CSimpleSecurityDescriptorHolder&) {}
   CSimpleSecurityDescriptorHolder& operator=(const CSimpleSecurityDescriptorHolder&) {}
};


//+--------------------------------------------------------------------------
//
//  Class:      CSimpleAclHolder
//
//  Purpose:    Smart wrapper for a ACL
//
//  History:    15-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CSimpleAclHolder
{
public:
  CSimpleAclHolder()
  {
    m_pAcl = NULL;
  }
  ~CSimpleAclHolder()
  {
    if (m_pAcl != NULL)
      ::LocalFree(m_pAcl);
  }

  PACL m_pAcl;
};

//+--------------------------------------------------------------------------
//
//  Class:      CSidHolder
//
//  Purpose:    Smart wrapper for a SID
//
//  History:    15-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CSidHolder
{
public:
   //
   // Constructor and Destructor
   //
   CSidHolder();
   ~CSidHolder();

   //
   // Public methods
   //
   PSID Get();
   bool Copy(PSID p);
   void Attach(PSID p, bool bLocalAlloc);
   void Clear();

private:
   //
   // Private methods
   //
   void _Init();
   void _Free();
   bool _Copy(PSID p);

   //
   // Private member data
   //
   PSID m_pSID;
   bool m_bLocalAlloc;
};

//
//Function for reading and writing acl
//
HRESULT
DSReadObjectSecurity(IN IDirectoryObject *pDsObject,
                     OUT SECURITY_DESCRIPTOR_CONTROL * psdControl,
                     OUT PACL *ppDacl);

HRESULT 
DSWriteObjectSecurity(IN IDirectoryObject *pDsObject,
                      IN SECURITY_DESCRIPTOR_CONTROL sdControl,
                      PACL pDacl);


#endif //_SECUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\query.cpp ===
#include "pch.h"
#include "query.h"


CDSSearch::CDSSearch()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_ppszAttr = NULL;
  m_CountAttr = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
}


void CDSSearch::_Reset()
{
  if (m_pObj != NULL) 
  {
    if (m_SearchHandle) 
    {
      m_pObj->CloseSearchHandle (m_SearchHandle);
      m_SearchHandle = NULL;
    }
    m_pObj->Release();
    m_pObj = NULL;
  }

  if (m_pwszFilter)
  {
     delete[] m_pwszFilter;
     m_pwszFilter = NULL;
  }
}

CDSSearch::~CDSSearch()
{
  _Reset();
}


HRESULT CDSSearch::Init(IDirectorySearch * pObj)
{
  HRESULT            hr = S_OK;
  _Reset();
  m_pObj = pObj;
  pObj->AddRef();
  m_bInitialized = TRUE;
  m_scope = ADS_SCOPE_ONELEVEL;  
  return hr;
}

HRESULT CDSSearch::Init(PCWSTR pszPath,
                        const CDSCmdCredentialObject& refCredObject)
{
  ENTER_FUNCTION_HR(FULL_LOGGING, CDSSearch::Init, hr);

  do // false loop
  {
    //
    // Verify parameters
    //
    if (!pszPath)
    {
      ASSERT(pszPath);
      hr = E_INVALIDARG;
      break;
    }

    CComPtr<IDirectorySearch> spDirSearch;
    hr = DSCmdOpenObject(refCredObject,
                         pszPath,
                         IID_IDirectorySearch,
                         (void**)&spDirSearch,
                         true);
    if (FAILED(hr))
    {
      break;
    }

    hr = Init(spDirSearch);
  } while (false);
  
  return hr;
}


HRESULT CDSSearch::SetAttributeList (LPTSTR *ppszAttribs, INT cAttrs)
{
  m_ppszAttr = ppszAttribs;
  m_CountAttr = cAttrs;
  return S_OK;
}

HRESULT CDSSearch::SetSearchScope (ADS_SCOPEENUM scope)
{
  if (m_bInitialized) {
    m_scope = scope;
  }
  return S_OK;
}

const int NUM_PREFS = 5;
HRESULT _SetSearchPreference(IDirectorySearch* piSearch, ADS_SCOPEENUM scope, BOOL bAttrOnly)
{
  if (NULL == piSearch)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  int cPref = 4;

  ADS_SEARCHPREF_INFO aSearchPref[5];
  aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
  aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
  aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
  aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
  aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
  aSearchPref[2].vValue.Integer = FALSE;
  aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
  aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[3].vValue.Integer = scope;
  if(bAttrOnly)
  {	
    aSearchPref[4].dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
	aSearchPref[4].vValue.dwType = ADSTYPE_BOOLEAN;
	aSearchPref[4].vValue.Integer = TRUE;
	++cPref;
  }

  return piSearch->SetSearchPreference (aSearchPref, cPref);
}


HRESULT CDSSearch::DoQuery(BOOL bAttrOnly)
{
  if (!m_bInitialized)
    return E_ADS_BAD_PATHNAME;

  HRESULT hr = _SetSearchPreference(m_pObj, m_scope, bAttrOnly);

  if (SUCCEEDED(hr)) {
    hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                m_ppszAttr,
                                m_CountAttr,
                                &m_SearchHandle);
  }

  return hr;
}

HRESULT
CDSSearch::GetNextRow()
{
  DWORD status = ERROR_MORE_DATA;
  HRESULT hr = S_OK;
  HRESULT hr2 = S_OK;
  WCHAR Buffer1[512], Buffer2[512];
  if (!m_bInitialized) {
    return E_ADS_BAD_PATHNAME;
  }
  while (status == ERROR_MORE_DATA ) {
    hr = m_pObj->GetNextRow (m_SearchHandle);
    if (hr == S_ADS_NOMORE_ROWS) {
      hr2 = ADsGetLastError(&status, Buffer1, 512,
                      Buffer2, 512);
      ASSERT(SUCCEEDED(hr2));
    } else {
      status = 0;
    }
  }
  return hr;
}

HRESULT
CDSSearch::GetColumn(LPWSTR Attribute,
                     PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) {
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT 
CDSSearch::GetNextColumnName(LPWSTR *ppszColumnName)
{  
  if (m_bInitialized) {
    return m_pObj->GetNextColumnName(m_SearchHandle,
                                     ppszColumnName);
  }
  return E_ADS_BAD_PATHNAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\pcrack.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       pcrack.h
//
//  requires iads.h (IADsPathname) and atlbase.h (CComPtr)
//
//--------------------------------------------------------------------------

// pcrack.h : include file for CPathCracker

#ifndef __PCRACK_H__
#define __PCRACK_H__

//+--------------------------------------------------------------------------
//
//  Class:      CPathCracker
//
//  Purpose:    A wrapper around the IADsPathname interface with additional
//              methods for manipulating paths.
//              The constructor creates the object and the destructor releases it.
//              This object is meant to be created on the stack and then it
//              is cleaned up when it goes out of scope
//
//  History:    6-Sep-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CPathCracker
{
public:
   //
   // Constructor
   //
   CPathCracker();

   //
   // IADsPathname methods
   //
   virtual /* [id] */ HRESULT STDMETHODCALLTYPE Set( 
                        /* [in] */ const BSTR bstrADsPath,
                        /* [in] */ long lnSetType) 
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->Set(bstrADsPath, lnSetType); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDisplayType( 
                        /* [in] */ long lnDisplayType) 
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->SetDisplayType(lnDisplayType); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE Retrieve( 
                        /* [in] */ long lnFormatType,
                        /* [retval][out] */ BSTR __RPC_FAR *pbstrADsPath) 
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->Retrieve(lnFormatType, pbstrADsPath); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNumElements( 
                        /* [retval][out] */ long __RPC_FAR *plnNumPathElements)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetNumElements(plnNumPathElements); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetElement( 
                        /* [in] */ long lnElementIndex,
                        /* [retval][out] */ BSTR __RPC_FAR *pbstrElement)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetElement(lnElementIndex, pbstrElement); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddLeafElement( 
                        /* [in] */ BSTR bstrLeafElement)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->AddLeafElement(bstrLeafElement); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE RemoveLeafElement( void)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->RemoveLeafElement(); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopyPath( 
                        /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppAdsPath)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->CopyPath(ppAdsPath); }

   virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEscapedElement( 
                        /* [in] */ long lnReserved,
                        /* [in] */ const BSTR bstrInStr,
                        /* [retval][out] */ BSTR __RPC_FAR *pbstrOutStr)
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->GetEscapedElement(lnReserved, bstrInStr, pbstrOutStr); }

   virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EscapedMode( 
                        /* [retval][out] */ long __RPC_FAR *retval)  
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->get_EscapedMode(retval); }

   virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EscapedMode( 
                           /* [in] */ long lnEscapedMode) 
   { return (m_spIADsPathname == NULL) ? m_hrCreate : m_spIADsPathname->put_EscapedMode(lnEscapedMode); }

   //
   // Other helpful path manglers
   //
   static HRESULT GetParentDN(PCWSTR pszDN,
                              CComBSTR& refsbstrDN);
   static HRESULT GetObjectRDNFromDN(PCWSTR pszDN,
                                     CComBSTR& refsbstrRDN);
   static HRESULT GetObjectNameFromDN(PCWSTR pszDN,
                                      CComBSTR& refsbstrName);
   static HRESULT GetDNFromPath(PCWSTR pszPath,
                                CComBSTR& refsbstrDN);

private:
   //
   // Private member function
   //
   HRESULT Init();

   //
   // Private member data
   //
   CComPtr<IADsPathname> m_spIADsPathname;
   HRESULT m_hrCreate;
};

#endif _PCRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\secutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      SecUtil.cpp
//
//  Contents:  Utility functions for working with security APIs
//
//  History:   15-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "secutil.h"

extern const GUID GUID_CONTROL_UserChangePassword =
    { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};

//+--------------------------------------------------------------------------
//
//  Member:     CSimpleSecurityDescriptorHolder::CSimpleSecurityDescriptorHolder
//
//  Synopsis:   Constructor for the smart security descriptor
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CSimpleSecurityDescriptorHolder::CSimpleSecurityDescriptorHolder()
{
   m_pSD = NULL;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSimpleSecurityDescriptorHolder::~CSimpleSecurityDescriptorHolder
//
//  Synopsis:   Destructor for the smart security descriptor
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CSimpleSecurityDescriptorHolder::~CSimpleSecurityDescriptorHolder()
{
   if (m_pSD != NULL)
   {
      ::LocalFree(m_pSD);
      m_pSD = NULL;
   }
}


////////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::CSidHolder
//
//  Synopsis:   Constructor : initializes the member data
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CSidHolder::CSidHolder()
{
   _Init();
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::~CSidHolder
//
//  Synopsis:   Destructor : Frees all data associated with the wrapped SID
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CSidHolder::~CSidHolder()
{
   _Free();
}
  
//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::Get
//
//  Synopsis:   Public accessor to the SID being wrapped
//
//  Arguments:  
//
//  Returns:    PSID : pointer to the SID being wrapped.  NULL if the class
//                     is not currently wrapping a SID
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
PSID CSidHolder::Get()
{
   return m_pSID;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::Copy
//
//  Synopsis:   Frees the memory associated with the currently wrapped SID
//              and then copies the new SID
//
//  Arguments:  [p - IN] : SID to be copied
//
//  Returns:    bool : true if the copy was successful, false otherwise
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
bool CSidHolder::Copy(PSID p)
{
   _Free();
   return _Copy(p);
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::Attach
//
//  Synopsis:   Attaches the SID to the wrapper
//
//  Arguments:  [p - IN] : SID to be wrapped by this class
//              [bLocalAlloc - OUT] : tells whether the SID should be freed
//                                    with LocalFree
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CSidHolder::Attach(PSID p, bool bLocalAlloc)
{
   _Free();
   m_pSID = p;
   m_bLocalAlloc = bLocalAlloc;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::Clear
//
//  Synopsis:   Frees the memory associated with the SID being wrapped
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CSidHolder::Clear()
{
   _Free();
}


//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::_Init
//
//  Synopsis:   Initializes the member data to default values
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CSidHolder::_Init()
{
   m_pSID = NULL;
   m_bLocalAlloc = TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::_Free
//
//  Synopsis:   Frees the memory associated with the SID being wrapped
//
//  Arguments:  
//
//  Returns:    
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CSidHolder::_Free()
{
   if (m_pSID != NULL)
   {
      if (m_bLocalAlloc)
      {
         ::LocalFree(m_pSID);
      }
      else
      {
         ::FreeSid(m_pSID);
         _Init();
      }
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CSidHolder::_Copy
//
//  Synopsis:   Makes a copy of the SID being wrapped
//
//  Arguments:  [p - OUT] : destination of the SID being copied
//
//  Returns:    bool : true if SID was copied successfully
//                     false if there was a failure
//
//  History:    15-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
bool CSidHolder::_Copy(PSID p)
{
   if ( (p == NULL) || !::IsValidSid(p) )
   {
      return false;
   }

   DWORD dwLen = ::GetLengthSid(p);
   PSID pNew = ::LocalAlloc(LPTR, dwLen);
   if (pNew == NULL)
   {
      return false;
      }

   if (!::CopySid(dwLen, pNew, p))
   {
      ::LocalFree(pNew);
      return false;
   }
   m_bLocalAlloc = TRUE;
   m_pSID = pNew;
   ASSERT(dwLen == ::GetLengthSid(m_pSID));
   ASSERT(memcmp(p, m_pSID, dwLen) == 0);
   return true;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfoMask
//
//  Synopsis:   Reads the security descriptor from the specied DS object
//
//  Arguments:  [IN  punk]          --  IUnknown from IDirectoryObject
//              [IN  si]            --  SecurityInformation
////  History:  25-Dec-2000         --  Hiteshr Created
//----------------------------------------------------------------------------
HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}

WCHAR const c_szSDProperty[]        = L"nTSecurityDescriptor";


//+---------------------------------------------------------------------------
//
//  Function:   DSReadObjectSecurity
//
//  Synopsis:   Reads the Dacl from the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [psdControl]        -- Control Setting for SD
//                                     They can be returned when calling
//                                      DSWriteObjectSecurity                 
//              [OUT ppDacl]        --  DACL returned here
//              
//
//  History     25-Oct-2000         -- hiteshr created
//
//  Notes:  If Object Doesn't have DACL, function will succeed but *ppDacl will
//          be NULL. 
//          Caller must free *ppDacl, if not NULL, by calling LocalFree
//
//----------------------------------------------------------------------------
HRESULT 
DSReadObjectSecurity(IN IDirectoryObject *pDsObject,
                     OUT SECURITY_DESCRIPTOR_CONTROL * psdControl,
                     OUT PACL *ppDacl)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DSReadObjectSecurity, hr);

   PADS_ATTR_INFO pSDAttributeInfo = NULL;

   do // false loop
   {
      LPWSTR pszSDProperty = (LPWSTR)c_szSDProperty;
      DWORD dwAttributesReturned;
      PSECURITY_DESCRIPTOR pSD = NULL;
      PACL pAcl = NULL;

      if(!pDsObject || !ppDacl)
      {
         ASSERT(FALSE);
         hr = E_INVALIDARG;
         break;
      }

      *ppDacl = NULL;

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         break;
      }

      //
      // Read the security descriptor
      //
      hr = pDsObject->GetObjectAttributes(&pszSDProperty,
                                         1,
                                         &pSDAttributeInfo,
                                         &dwAttributesReturned);
      if (SUCCEEDED(hr) && !pSDAttributeInfo)    
         hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege

      if(FAILED(hr))
      {
         break;
      }                

      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType);
      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType);

      pSD = (PSECURITY_DESCRIPTOR)pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue;

      ASSERT(IsValidSecurityDescriptor(pSD));


      //
      //Get the security descriptor control
      //
      if(psdControl)
      {
         DWORD dwRevision;
         if(!GetSecurityDescriptorControl(pSD, psdControl, &dwRevision))
         {
             hr = HRESULT_FROM_WIN32(GetLastError());
             break;
         }
      }

      //
      //Get pointer to DACL
      //
      BOOL bDaclPresent, bDaclDefaulted;
      if(!GetSecurityDescriptorDacl(pSD, 
                                   &bDaclPresent,
                                   &pAcl,
                                   &bDaclDefaulted))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }

      if(!bDaclPresent ||
         !pAcl)
      {
         break;
      }

      ASSERT(IsValidAcl(pAcl));

      //
      //Make a copy of the DACL
      //
      *ppDacl = (PACL)LocalAlloc(LPTR,pAcl->AclSize);
      if(!*ppDacl)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      CopyMemory(*ppDacl,pAcl,pAcl->AclSize);

    }while(0);


    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DSWriteObjectSecurity
//
//  Synopsis:   Writes the Dacl to the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [sdControl]         -- control for security descriptor
//              [IN  pDacl]         --  The DACL to be written
//
//  History     25-Oct-2000         -- hiteshr created
//----------------------------------------------------------------------------
HRESULT 
DSWriteObjectSecurity(IN IDirectoryObject *pDsObject,
                      IN SECURITY_DESCRIPTOR_CONTROL sdControl,
                      PACL pDacl)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DSWriteObjectSecurity, hr);

   PISECURITY_DESCRIPTOR pSD = NULL;
   PSECURITY_DESCRIPTOR psd = NULL;

   do // false loop
   {
      ADSVALUE attributeValue;
      ADS_ATTR_INFO attributeInfo;
      DWORD dwAttributesModified;
      DWORD dwSDLength;

      if(!pDsObject || !pDacl)
      {
         ASSERT(FALSE);
         hr = E_INVALIDARG;
         break;
      }

      ASSERT(IsValidAcl(pDacl));

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"SetSecurityInfoMask failed: hr = 0x%x",
                      hr);
         break;
      }


      //
      //Build the Security Descriptor
      //
      pSD = (PISECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
      if (pSD == NULL)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to allocate memory for Security Descriptor");
         hr = E_OUTOFMEMORY;
         break;
      }
        
      InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

      //
      // Finally, build the security descriptor
      //
      pSD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ
                     | (sdControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

      if(pDacl->AclSize)
      {
         pSD->Dacl = pDacl;
      }

      //
      // Need the total size
      //
      dwSDLength = GetSecurityDescriptorLength(pSD);

      //
      // If necessary, make a self-relative copy of the security descriptor
      //
      psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

      if (psd == NULL ||
          !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"MakeSelfRelativeSD failed: hr = 0x%x",
                      hr);
         break;
      }


      attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeValue.SecurityDescriptor.dwLength = dwSDLength;
      attributeValue.SecurityDescriptor.lpValue = (LPBYTE)psd;

      attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
      attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
      attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeInfo.pADsValues = &attributeValue;
      attributeInfo.dwNumValues = 1;

      // Write the security descriptor
      hr = pDsObject->SetObjectAttributes(&attributeInfo,
                                         1,
                                         &dwAttributesModified);
   } while (false);
    
   if (psd != NULL)
   {
      LocalFree(psd);
   }

   if(pSD != NULL)
   {
      LocalFree(pSD);
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sources.inc

!ENDIF

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE=..\pch.h

!IF !defined(DISPLAY_BASEDIR)
DISPLAY_BASEDIR = $(PROJECT_ROOT)\display
!ENDIF

INCLUDES= $(O);                        \
          ..;                          \
          ..\parser;                   \
          $(BASE_INC_PATH);            \
          $(DISPLAY_BASEDIR)\inc;      \
          $(DISPLAY_BASEDIR)\proppage; \
          $(PROJECT_ROOT)\dsadminlib\inc; 

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

# so will be built unicode
C_DEFINES=-DUNICODE -D_UNICODE 

MSC_WARNING_LEVEL= /W4

USE_ATL=1
ATL_VER=30

LINKLIBS=\
    ..\parser\$(O)\parser.lib

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\ntdll.lib       \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\oleaut32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\activeds.lib    \
    $(SDK_LIB_PATH)\adsiid.lib      \
    $(SDK_LIB_PATH)\dsprop.lib      \
    $(SDK_LIB_PATH)\secur32.lib     \
    $(SHELL_LIB_PATH)\comctlp.lib   \
    $(PROJECT_ROOT)\dsadminlib\src\$(O)\dsadminp.lib

SOURCES= \
    ..\parserutil.cpp \
    ..\secutil.cpp    \
    ..\util.cpp       \
    ..\query.cpp      \
    ..\dsutil.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsadd\addtable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      addtable.h
//
//  Contents:  Declares a table which contains the classes which can be
//             created through dsadd.exe
//
//  History:   22-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _ADDTABLE_H_
#define _ADDTABLE_H_

typedef enum COMMON_COMMAND
{
   //
   // Common switches
   //
#ifdef DBG
   eCommDebug,
#endif
   eCommHelp,
   eCommServer,
   eCommDomain,
   eCommUserName,
   eCommPassword,
   eCommQuiet,
   eCommContinue,
   eCommObjectType,
   eCommObjectDNorName,
   eCommDescription,
   eTerminator,

   //
   // User and Contact switches
   //
   eUserSam = eTerminator,
   eUserUpn,
   eUserFn,
   eUserMi,
   eUserLn,
   eUserDisplay,
   eUserEmpID,
   eUserPwd,
   eUserMemberOf,
   eUserOffice,
   eUserTel,
   eUserEmail,
   eUserHometel,
   eUserPager,
   eUserMobile,
   eUserFax,
   eUserIPPhone,
   eUserWebPage,
   eUserTitle,
   eUserDept,
   eUserCompany,
   eUserManager,
   eUserHomeDir,
   eUserHomeDrive,
   eUserProfilePath,
   eUserScriptPath,
   eUserMustchpwd,
   eUserCanchpwd,
   eUserReversiblePwd,
   eUserPwdneverexpires,
   eUserAcctexpires,
   eUserDisabled,

   //
   // Contact switches
   //
   eContactFn = eTerminator,
   eContactMi,
   eContactLn,
   eContactDisplay,
   eContactOffice,
   eContactTel,
   eContactEmail,
   eContactHometel,
   eContactPager,
   eContactMobile,
   eContactFax,
   eContactTitle,
   eContactDept,
   eContactCompany,

   //
   // Computer switches
   //
   eComputerSamname = eTerminator,
   eComputerLocation,
   eComputerMemberOf,

   //
   // Group switches
   //
   eGroupSamname = eTerminator,
   eGroupSecgrp,
   eGroupScope,
   eGroupMemberOf,
   eGroupMembers,

   //
   // OU doesn't have any additional switches
   //

   //
   // Subnet switches
   //
   eSubnetSite = eTerminator,

   //
   // Site switches
   // 
   eSiteAutotopology = eTerminator,

   //
   // Site Link switches
   //
   eSLinkIp = eTerminator,
   eSLinkSmtp,
   eSLinkAddsite,
   eSLinkRmsite,
   eSLinkCost,
   eSLinkRepint,
   eSLinkAutobacksync,
   eSLinkNotify,

   //
   // Site Link Bridge switches
   //
   eSLinkBrIp = eTerminator,
   eSLinkBrSmtp,
   eSLinkBrAddslink,
   eSLinkBrRmslink,

   //
   // Replication Connection switches
   // 
   eConnTransport = eTerminator,
   eConnEnabled,
   eConnManual,
   eConnAutobacksync,
   eConnNotify,

   //
   // Server switches
   //
   eServerAutotopology = eTerminator,
};

//
// The parser table
//
extern ARG_RECORD DSADD_COMMON_COMMANDS[];

//
// The table of supported objects
//
extern PDSOBJECTTABLEENTRY g_DSObjectTable[];

#endif //_ADDTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsadd\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   22-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

//
// The command line executable name
//
PCWSTR g_pszDSCommandName           = L"dsadd";

//
// Object types as are typed on the command line
//
PCWSTR g_pszOU                      = L"ou";
PCWSTR g_pszUser                    = L"user";
PCWSTR g_pszContact                 = L"contact";
PCWSTR g_pszComputer                = L"computer";
PCWSTR g_pszGroup                   = L"group";

//
// Common switches
//
PCWSTR c_sz_arg1_com_debug          = L"debug";
PCWSTR c_sz_arg1_com_help           = L"h";
PCWSTR c_sz_arg2_com_help           = L"?";
PCWSTR c_sz_arg1_com_server         = L"s";
PCWSTR c_sz_arg2_com_server         = L"server";
PCWSTR c_sz_arg1_com_domain         = L"d";
PCWSTR c_sz_arg2_com_domain         = L"domain";
PCWSTR c_sz_arg1_com_username       = L"u";
PCWSTR c_sz_arg2_com_username       = L"username";
PCWSTR c_sz_arg1_com_password       = L"p";
PCWSTR c_sz_arg2_com_password       = L"password";
PCWSTR c_sz_arg1_com_quiet          = L"q";
PCWSTR c_sz_arg1_com_continue       = L"C";
PCWSTR c_sz_arg1_com_description    = L"desc";
PCWSTR c_sz_arg1_com_objecttype     = L"objecttype";
PCWSTR c_sz_arg1_com_objectDN       = L"Target object for this command";

//
// User and Contact switches
//
PCWSTR g_pszArg1UserSAM             = L"samid";
PCWSTR g_pszArg1UserUPN             = L"upn"; 
PCWSTR g_pszArg1UserFirstName       = L"fn";
PCWSTR g_pszArg1UserMiddleInitial   = L"mi";
PCWSTR g_pszArg1UserLastName        = L"ln";
PCWSTR g_pszArg1UserDisplayName     = L"display";
PCWSTR g_pszArg1UserEmpID           = L"empid";
PCWSTR g_pszArg1UserPassword        = L"pwd";
PCWSTR g_pszArg1UserMemberOf        = L"memberof";
PCWSTR g_pszArg1UserOffice          = L"office";
PCWSTR g_pszArg1UserTelephone       = L"tel"; 
PCWSTR g_pszArg1UserEmail           = L"email";
PCWSTR g_pszArg1UserHomeTelephone   = L"hometel";
PCWSTR g_pszArg1UserPagerNumber     = L"pager"; 
PCWSTR g_pszArg1UserMobileNumber    = L"mobile"; 
PCWSTR g_pszArg1UserFaxNumber       = L"fax";
PCWSTR g_pszArg1UserIPTel           = L"iptel";
PCWSTR g_pszArg1UserWebPage         = L"webpg";
PCWSTR g_pszArg1UserTitle           = L"title";
PCWSTR g_pszArg1UserDepartment      = L"dept"; 
PCWSTR g_pszArg1UserCompany         = L"company";
PCWSTR g_pszArg1UserManager         = L"mgr";
PCWSTR g_pszArg1UserHomeDirectory   = L"hmdir";
PCWSTR g_pszArg1UserHomeDrive       = L"hmdrv";
PCWSTR g_pszArg1UserProfilePath     = L"profile";
PCWSTR g_pszArg1UserScriptPath      = L"loscr";
PCWSTR g_pszArg1UserMustChangePwd   = L"mustchpwd";
PCWSTR g_pszArg1UserCanChangePwd    = L"canchpwd";
PCWSTR g_pszArg1UserReversiblePwd   = L"reversiblepwd";
PCWSTR g_pszArg1UserPwdNeverExpires = L"pwdneverexpires";
PCWSTR g_pszArg1UserAccountExpires  = L"acctexpires";
PCWSTR g_pszArg1UserDisableAccount  = L"disabled";

//
// Computer switches
//
PCWSTR g_pszArg1ComputerSAMName     = L"samid";
PCWSTR g_pszArg1ComputerLocation    = L"loc";
PCWSTR g_pszArg1ComputerMemberOf    = L"memberof";

//
// Group switches
//
PCWSTR g_pszArg1GroupSAMName        = L"samid";
PCWSTR g_pszArg1GroupSec            = L"secgrp";
PCWSTR g_pszArg1GroupScope          = L"scope";
PCWSTR g_pszArg1GroupMemberOf       = L"memberof";
PCWSTR g_pszArg1GroupMembers        = L"members";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsadd\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   22-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

//
// The command line executable name
//
extern PCWSTR g_pszDSCommandName;

//
// Object types as are typed on the command line
//
extern PCWSTR g_pszOU;
extern PCWSTR g_pszUser;
extern PCWSTR g_pszContact;
extern PCWSTR g_pszComputer;
extern PCWSTR g_pszGroup;

//
// Common switches
//
extern PCWSTR c_sz_arg1_com_debug;
extern PCWSTR c_sz_arg1_com_help;
extern PCWSTR c_sz_arg2_com_help;
extern PCWSTR c_sz_arg1_com_server;
extern PCWSTR c_sz_arg2_com_server;
extern PCWSTR c_sz_arg1_com_domain;
extern PCWSTR c_sz_arg2_com_domain;
extern PCWSTR c_sz_arg1_com_username;
extern PCWSTR c_sz_arg2_com_username;
extern PCWSTR c_sz_arg1_com_password;
extern PCWSTR c_sz_arg2_com_password;
extern PCWSTR c_sz_arg1_com_quiet;
extern PCWSTR c_sz_arg1_com_continue;
extern PCWSTR c_sz_arg1_com_description;
extern PCWSTR c_sz_arg1_com_objecttype;
extern PCWSTR c_sz_arg1_com_objectDN;

//
// User and contact switches
//
extern PCWSTR g_pszArg1UserSAM;
extern PCWSTR g_pszArg1UserUPN; 
extern PCWSTR g_pszArg1UserFirstName;
extern PCWSTR g_pszArg1UserMiddleInitial;
extern PCWSTR g_pszArg1UserLastName;
extern PCWSTR g_pszArg1UserDisplayName;
extern PCWSTR g_pszArg1UserEmpID;
extern PCWSTR g_pszArg1UserPassword;
extern PCWSTR g_pszArg1UserMemberOf;
extern PCWSTR g_pszArg1UserOffice;
extern PCWSTR g_pszArg1UserTelephone;
extern PCWSTR g_pszArg1UserEmail;
extern PCWSTR g_pszArg1UserHomeTelephone;
extern PCWSTR g_pszArg1UserPagerNumber;
extern PCWSTR g_pszArg1UserMobileNumber;
extern PCWSTR g_pszArg1UserFaxNumber;
extern PCWSTR g_pszArg1UserIPTel;
extern PCWSTR g_pszArg1UserWebPage;
extern PCWSTR g_pszArg1UserTitle;
extern PCWSTR g_pszArg1UserDepartment;
extern PCWSTR g_pszArg1UserCompany;
extern PCWSTR g_pszArg1UserManager;
extern PCWSTR g_pszArg1UserHomeDirectory;
extern PCWSTR g_pszArg1UserHomeDrive;
extern PCWSTR g_pszArg1UserProfilePath;
extern PCWSTR g_pszArg1UserScriptPath;
extern PCWSTR g_pszArg1UserMustChangePwd;
extern PCWSTR g_pszArg1UserCanChangePwd;
extern PCWSTR g_pszArg1UserReversiblePwd;
extern PCWSTR g_pszArg1UserPwdNeverExpires;
extern PCWSTR g_pszArg1UserDisableAccount;
extern PCWSTR g_pszArg1UserAccountExpires;

//
// Computer switches
//
extern PCWSTR g_pszArg1ComputerSAMName;
extern PCWSTR g_pszArg1ComputerLocation;
extern PCWSTR g_pszArg1ComputerMemberOf;

//
// Group switches
//
extern PCWSTR g_pszArg1GroupSAMName;
extern PCWSTR g_pszArg1GroupSec;
extern PCWSTR g_pszArg1GroupScope;
extern PCWSTR g_pszArg1GroupMemberOf;
extern PCWSTR g_pszArg1GroupMembers;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      strings.h
//
//  Contents:  Global strings that will be needed throughout this project
//
//  History:   06-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _STRINGS_H_
#define _STRINGS_H_

static const BSTR g_bstrLDAPProvider         = L"LDAP://";
static const BSTR g_bstrGCProvider           = L"GC://";
static const BSTR g_bstrRootDSE              = L"RootDSE";
static const BSTR g_bstrDefaultNCProperty    = L"defaultNamingContext";
static const BSTR g_bstrSchemaNCProperty     = L"schemaNamingContext";
static const BSTR g_bstrConfigNCProperty     = L"configurationNamingContext";

static const BSTR g_bstrGroupScopeLocal      = L"l";
static const BSTR g_bstrGroupScopeUniversal  = L"u";
static const BSTR g_bstrGroupScopeGlobal     = L"g";

static const BSTR g_bstrNever                = L"NEVER";

// Other attributes
static const BSTR g_bstrIDManagerReference   = L"rIDManagerReference";
static const BSTR g_bstrFSMORoleOwner        = L"fSMORoleOwner";
static const BSTR g_bstrDNSHostName          = L"dNSHostName";


#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      Util.h
//
//  Contents:  Generic utility functions and classes for dscmd
//
//  History:   01-Oct-2000 JeffJon  Created
//             
//--------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

#ifdef DBG

//+--------------------------------------------------------------------------
//
//  Class:      CDebugSpew
//
//  Purpose:    Signifies whether to spew debug output on checked builds or not
//
//  History:    01-Oct-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CDebugSpew
{
public:
   //
   // Constructor/Destructor
   //
   CDebugSpew()
      : m_nDebugLevel(0),
        m_nIndent(0)
   {}

   ~CDebugSpew() {}

   //
   // Public data accessors
   //
   void SetDebugLevel(UINT nDebugLevel) { m_nDebugLevel = nDebugLevel; }
   UINT GetDebugLevel() { return m_nDebugLevel; }
   bool IsDebugEnabled() const { return (m_nDebugLevel > 0); }

   void SpewHeader();

   void EnterFunction(UINT nLevel, PCWSTR pszFunction);
   void LeaveFunction(UINT nLevel, PCWSTR pszFunction);
   void LeaveFunctionHr(UINT nLevel, PCWSTR pszFunction, HRESULT hr);
   void Output(UINT nLevel, PCWSTR pszOutput, ...);

private:
   //
   // Private data accessors
   //
   void Indent() { m_nIndent += TAB; }
   void Outdent() { (m_nIndent >= TAB) ? m_nIndent -= TAB : m_nIndent = 0; }
   UINT GetIndent() { return m_nIndent; }

   //
   // Private data
   //

   //
   // This should always be in the range of 0 - 10 where zero is no debug output
   // and 10 is complete output
   //
   UINT m_nDebugLevel;
   UINT m_nIndent;

   static const UINT TAB = 3;
};

//
// Globals
//
extern CDebugSpew  DebugSpew;


//+--------------------------------------------------------------------------
//
//  Class:      CFunctionSpew
//
//  Purpose:    Object which outputs the "Enter function" debug spew on creation
//              and outputs the "Leave function" debug spew on destruction
//
//  History:    07-Dec-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CFunctionSpew
{
public:
  //
  // Constructor/Destructor
  //
  CFunctionSpew(UINT   nDebugLevel,
               PCWSTR pszFunctionName)
     : m_nDebugLevel(nDebugLevel),
       m_pszFunctionName(pszFunctionName),
       m_bLeaveAlreadyWritten(false)
  {
    ASSERT(pszFunctionName);
    DebugSpew.EnterFunction(nDebugLevel, pszFunctionName);
  }

  virtual ~CFunctionSpew()
  {
     if (!IsLeaveAlreadyWritten())
     {
       DebugSpew.LeaveFunction(GetDebugLevel(), GetFunctionName());
     }
  }

protected:
  PCWSTR    GetFunctionName()       { return m_pszFunctionName; }
  UINT      GetDebugLevel()         { return m_nDebugLevel; }
  bool      IsLeaveAlreadyWritten() { return m_bLeaveAlreadyWritten; }
  void      SetLeaveAlreadyWritten(){ m_bLeaveAlreadyWritten = true; }

private:
  PCWSTR    m_pszFunctionName;
  UINT      m_nDebugLevel;
  bool      m_bLeaveAlreadyWritten;
};

//+--------------------------------------------------------------------------
//
//  Class:      CFunctionSpewHR
//
//  Purpose:    Object which outputs the "Enter function" debug spew on creation
//              and outputs the "Leave function" with the HRESULT return value
//              on destruction
//
//  History:    07-Dec-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CFunctionSpewHR : public CFunctionSpew
{
public:
  //
  // Constructor/Destructor
  //
  CFunctionSpewHR(UINT     nDebugLevel,
                 PCWSTR   pszFunctionName,
                 HRESULT& refHR)
     : m_refHR(refHR),
       CFunctionSpew(nDebugLevel, pszFunctionName)
  {
  }

  virtual ~CFunctionSpewHR()
  {
    DebugSpew.LeaveFunctionHr(GetDebugLevel(), GetFunctionName(), m_refHR);
    SetLeaveAlreadyWritten();
  }

private:
  HRESULT&  m_refHR;
};


//
// Helper macros for use with CDebugSpew
//
   #define ENABLE_DEBUG_OUTPUT(level)           DebugSpew.SetDebugLevel((level)); \
                                                DebugSpew.SpewHeader();
   #define DISABLE_DEBUG_OUTPUT()               DebugSpew.SetDebugLevel(0);
   #define ENTER_FUNCTION(level, func)          CFunctionSpew functionSpewObject((level), TEXT(#func));
   #define ENTER_FUNCTION_HR(level, func, hr)   HRESULT (hr) = S_OK; \
                                                CFunctionSpewHR functionSpewObject((level), TEXT(#func), (hr));
   #define LEAVE_FUNCTION(level, func)          DebugSpew.LeaveFunction((level), TEXT(#func));
   #define LEAVE_FUNCTION_HR(level, func, hr)   DebugSpew.LeaveFunctionHr((level), TEXT(#func), (hr));
   #define DEBUG_OUTPUT                         DebugSpew.Output
#else
   #define ENABLE_DEBUG_OUTPUT(level)
   #define DISABLE_DEBUG_OUTPUT()
   #define ENTER_FUNCTION(level, func)
   #define ENTER_FUNCTION_HR(level, func, hr)   HRESULT (hr) = S_OK;
   #define LEAVE_FUNCTION(level, func)
   #define LEAVE_FUNCTION_HR(level, func, hr)
   #define DEBUG_OUTPUT
#endif // DBG

//
// Debug log levels - NOTE these can be given more meaningful names as needed
//
enum
{
   NO_DEBUG_LOGGING = 0,
   MINIMAL_LOGGING,
   LEVEL2_LOGGING,
   LEVEL3_LOGGING,
   LEVEL4_LOGGING,
   LEVEL5_LOGGING,
   LEVEL6_LOGGING,
   LEVEL7_LOGGING,
   LEVEL8_LOGGING,
   LEVEL9_LOGGING,
   FULL_LOGGING
};

//+--------------------------------------------------------------------------
//
//  Function:   _UnicodeToOemConvert
//
//  Synopsis:   takes the passed in string (pszUnicode) and converts it to
//              the OEM code page
//
//  Arguments:  [pszUnicode - IN] : the string to be converted
//              [sbstrOemUnicode - OUT] : the converted string
//
//  Returns:    
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void _UnicodeToOemConvert(PCWSTR pszUnicode, CComBSTR& sbstrOemUnicode);

//+--------------------------------------------------------------------------
//
//  Function:   SpewAttrs(ADS_ATTR_INFO* pCreateAttrs, DWORD dwNumAttrs);
//
//  Synopsis:   Uses the DEBUG_OUTPUT macro to output the attributes and the
//              values specified
//
//  Arguments:  [pAttrs - IN] : The ADS_ATTR_INFO
//              [dwNumAttrs - IN] : The number of attributes in pAttrs
//
//  Returns:    
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
#ifdef DBG
void SpewAttrs(ADS_ATTR_INFO* pAttrs, DWORD dwNumAttrs);
#endif // DBG


//+--------------------------------------------------------------------------
//
//  Function:   litow
//
//  Synopsis:   
//
//  Arguments:  [li - IN] :  reference to large integer to be converted to string
//              [sResult - OUT] : Gets the output string
//  Returns:    void
//
//  History:    25-Sep-2000   hiteshr   Created
//              Copied from dsadmin code base, changed work with CComBSTR
//---------------------------------------------------------------------------

void litow(LARGE_INTEGER& li, CComBSTR& sResult);

//+--------------------------------------------------------------------------
//
//  Class:      CManagedStringEntry
//
//  Synopsis:   My own string list entry since we are not using MFC
//
//  History:    25-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
class CManagedStringEntry
{
public:
   //
   // Constructor
   //
   CManagedStringEntry(PCWSTR pszValue) : pNext(NULL), sbstrValue(pszValue) {}

   CComBSTR sbstrValue;
   CManagedStringEntry* pNext;
};

//+--------------------------------------------------------------------------
//
//  Class:      CManagedStringList
//
//  Synopsis:   My own string list since we are not using MFC
//
//  History:    25-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
class CManagedStringList
{
public:
   //
   // Constructor
   //
   CManagedStringList() : m_pHead(NULL), m_pTail(NULL), m_nCount(0) {}

   //
   // Destructor
   //
   ~CManagedStringList()
   {
      DeleteAll();
   }

   void DeleteAll()
   {
      CManagedStringEntry* pEntry = m_pHead;
      while (pEntry != NULL)
      {
         CManagedStringEntry* pTempEntry = pEntry;
         pEntry = pEntry->pNext;
         delete pTempEntry;
      }
      m_nCount = 0;
   }

   void Add(PCWSTR pszValue)
   {
      if (!m_pHead)
      {
         m_pHead = new CManagedStringEntry(pszValue);
         m_pTail = m_pHead;
         m_nCount++;
      }
      else
      {
         ASSERT(m_pTail);
         m_pTail->pNext = new CManagedStringEntry(pszValue);
         if (m_pTail->pNext)
         {
            m_pTail = m_pTail->pNext;
            m_nCount++;
         }
      }
   }

   bool Contains(PCWSTR pszValue)
   {
      bool bRet = false;
      for (CManagedStringEntry* pEntry = m_pHead; pEntry; pEntry = pEntry->pNext)
      {
         if (_wcsicmp(pEntry->sbstrValue, pszValue) == 0)
         {
            bRet = true;
            break;
         }
      }
      return bRet;
   }

private:
   CManagedStringEntry* m_pHead;
   CManagedStringEntry* m_pTail;

   UINT m_nCount;
};



#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsadd\addtable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      addtable.cpp
//
//  Contents:  Defines a table which contains the classes which can be
//             created through dsadd.exe
//
//  History:   22-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "addtable.h"
#include "usage.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------

ARG_RECORD DSADD_COMMON_COMMANDS[] = 
{
#ifdef DBG
   //
   // -debug, -debug
   //
   0,(LPWSTR)c_sz_arg1_com_debug, 
   ID_ARG2_NULL,NULL,
   ARG_TYPE_DEBUG, ARG_FLAG_OPTIONAL|ARG_FLAG_HIDDEN,  
   (CMD_TYPE)0,     
   0,  NULL,
#endif

   //
   // h, ?
   //
   0,(LPWSTR)c_sz_arg1_com_help, 
   0,(LPWSTR)c_sz_arg2_com_help, 
   ARG_TYPE_HELP, ARG_FLAG_OPTIONAL,  
   (CMD_TYPE)FALSE,     
   0,  NULL,

   //
   // s,server
   //
   0,(LPWSTR)c_sz_arg1_com_server, 
   0,(LPWSTR)c_sz_arg2_com_server, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // d,domain
   //
   0,(LPWSTR)c_sz_arg1_com_domain, 
   0,(LPWSTR)c_sz_arg2_com_domain, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // u, username    
   //
   0,(LPWSTR)c_sz_arg1_com_username, 
   0,(LPWSTR)c_sz_arg2_com_username, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // w, password
   //
   0,(LPWSTR)c_sz_arg1_com_password, 
   0,(LPWSTR)c_sz_arg2_com_password, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   (CMD_TYPE)_T(""),    
   0,  ValidateAdminPassword,

   //
   // q,q
   //
   0,(LPWSTR)c_sz_arg1_com_quiet, 
   ID_ARG2_NULL,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   (CMD_TYPE)_T(""),    
   0,  NULL,

   //
   // c  Continue
   //
   0,(PWSTR)c_sz_arg1_com_continue,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)_T(""),
   0, NULL,

   //
   // objecttype
   //
   0,(LPWSTR)c_sz_arg1_com_objecttype, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN,  
   0,    
   0,  NULL,

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_DN,
   0,    
   0,  NULL,

   //
   // description
   //
   0, (PWSTR)c_sz_arg1_com_description,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   ARG_TERMINATOR
};

ARG_RECORD DSADD_USER_COMMANDS[]=
{
   //
   // samid  sAMAccountName
   //
   0, (PWSTR)g_pszArg1UserSAM,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_REQUIRED,
   0,
   0, NULL,

   //
   // upn
   //
   0, (PWSTR)g_pszArg1UserUPN, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // empid  Employee ID
   //
   0, (PWSTR)g_pszArg1UserEmpID, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pwd Password
   //
   0, (PWSTR)g_pszArg1UserPassword, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateUserPassword,

   //
   // memberOf MemberOf
   //
   0, (PWSTR)g_pszArg1UserMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   0,
   0, NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // iptel IP Telephone
   //
   0, (PWSTR)g_pszArg1UserIPTel, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // webpg  Web Page
   //
   0, (PWSTR)g_pszArg1UserWebPage, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mgr Manager
   //
   0, (PWSTR)g_pszArg1UserManager, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,  
   0,    
   0,  NULL,

   //
   // hmdir  Home Directory
   //
   0, (PWSTR)g_pszArg1UserHomeDirectory, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hmdrv  Home Drive
   //
   0, (PWSTR)g_pszArg1UserHomeDrive, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // profile Profile path
   //
   0, (PWSTR)g_pszArg1UserProfilePath, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // loscr Script path
   //
   0, (PWSTR)g_pszArg1UserScriptPath, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mustchpwd Must Change Password at next logon
   //
   0, (PWSTR)g_pszArg1UserMustChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,

   //
   // canchpwd Can Change Password
   //
   0, (PWSTR)g_pszArg1UserCanChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,
   
   //
   // reversiblepwd  Password stored with reversible encryption
   //
   0, (PWSTR)g_pszArg1UserReversiblePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,

   //
   // pwdneverexpires Password never expires
   //
   0, (PWSTR)g_pszArg1UserPwdNeverExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,
 
   //
   // acctexpires Account Expires
   //
   0, (PWSTR)g_pszArg1UserAccountExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_INTSTR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateNever,
  
   //
   // disabled  Disable Account
   //
   0, (PWSTR)g_pszArg1UserDisableAccount, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  ValidateYesNo,

   ARG_TERMINATOR
};

ARG_RECORD DSADD_COMPUTER_COMMANDS[]=
{
   //
   // samname
   //
   0, (PWSTR)g_pszArg1ComputerSAMName,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // loc Location
   //
   0, (PWSTR)g_pszArg1ComputerLocation,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // disabled
   //
   0, (PWSTR)g_pszArg1ComputerMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   0,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSADD_GROUP_COMMANDS[]=
{
   //
   // samname
   //
   0, (PWSTR)g_pszArg1GroupSAMName,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // secgrp Security enabled
   //
   0, (PWSTR)g_pszArg1GroupSec,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  ValidateYesNo,

   //
   // scope Group scope (local/global/universal)
   //
   0, (PWSTR)g_pszArg1GroupScope,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  ValidateGroupScope,

   //
   // memberof  MemberOf
   //
   0, (PWSTR)g_pszArg1GroupMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   0,
   0,  NULL,

   //
   // members  Members of the group
   //
   0, (PWSTR)g_pszArg1GroupMembers,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   0,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSADD_CONTACT_COMMANDS[]=
{
   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,

};
/*
ARG_RECORD DSADD_SUBNET_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SUBNET_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SUBNET_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SUBNET_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //site
    IDS_ARG1_SUBNET_SITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSADD_SITE_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SITE_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
        ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SITE_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SITE_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autotopology
    IDS_ARG1_SITE_AUTOTOPOLOGY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSADD_SLINK_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SLINK_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //ip
    IDS_ARG1_SLINK_IP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //smtp
    IDS_ARG1_SLINK_SMTP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SLINK_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //addsite
    IDS_ARG1_SLINK_ADDSITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //rmsite
    IDS_ARG1_SLINK_RMSITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //cost
    IDS_ARG1_SLINK_COST, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //repint
    IDS_ARG1_SLINK_REPINT, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SLINK_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autobacksync
    IDS_ARG1_SLINK_AUTOBACKSYNC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //notify
    IDS_ARG1_SLINK_NOTIFY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSADD_SLINKBR_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SLINKBR_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //ip
    IDS_ARG1_SLINKBR_IP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //smtp
    IDS_ARG1_SLINKBR_SMTP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SLINKBR_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //addslink
    IDS_ARG1_SLINKBR_ADDSLINK, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //rmslink
    IDS_ARG1_SLINKBR_RMSLINK, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SLINKBR_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSADD_CONN_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_CONN_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //transport
    IDS_ARG1_CONN_TRANSPORT, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //enabled
    IDS_ARG1_CONN_ENABLED, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_CONN_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //manual
    IDS_ARG1_CONN_MANUAL, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autobacksync
    IDS_ARG1_CONN_AUTOBACKSYNC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //notify
    IDS_ARG1_CONN_NOTIFY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};

ARG_RECORD DSADD_SERVER_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SERVER_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SERVER_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SERVER_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autotopology
    IDS_ARG1_SERVER_AUTOTOPOLOGY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


*/

//+-------------------------------------------------------------------------
// Attributes
//--------------------------------------------------------------------------

//
// Description
//
DSATTRIBUTEDESCRIPTION description =
{
   {
      L"description",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY descriptionEntry =
{
   L"description",
   eCommDescription,
   DS_ATTRIBUTE_ONCREATE,
   &description,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// UPN
//
DSATTRIBUTEDESCRIPTION upn =
{
   {
      L"userPrincipalName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY upnUserEntry =
{
   L"userPrincipalName",
   eUserUpn,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &upn,
   FillAttrInfoFromObjectEntry,
   NULL
};


//
// First name
//
DSATTRIBUTEDESCRIPTION firstName =
{
   {
      L"givenName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY firstNameUserEntry =
{
   L"givenName",
   eUserFn,
   DS_ATTRIBUTE_ONCREATE,
   &firstName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY firstNameContactEntry =
{
   L"givenName",
   eContactFn,
   DS_ATTRIBUTE_ONCREATE,
   &firstName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Middle Initial
//
DSATTRIBUTEDESCRIPTION middleInitial =
{
   {
      L"initials",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY middleInitialUserEntry =
{
   L"initials",
   eUserMi,
   DS_ATTRIBUTE_ONCREATE,
   &middleInitial,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY middleInitialContactEntry =
{
   L"initials",
   eContactMi,
   DS_ATTRIBUTE_ONCREATE,
   &middleInitial,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Last name
//
DSATTRIBUTEDESCRIPTION lastName =
{
   {
      L"sn",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY lastNameUserEntry =
{
   L"sn",
   eUserLn,
   DS_ATTRIBUTE_ONCREATE,
   &lastName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY lastNameContactEntry =
{
   L"sn",
   eContactLn,
   DS_ATTRIBUTE_ONCREATE,
   &lastName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Display name
//
DSATTRIBUTEDESCRIPTION displayName =
{
   {
      L"displayName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY displayNameUserEntry =
{
   L"displayName",
   eUserDisplay,
   DS_ATTRIBUTE_ONCREATE,
   &displayName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY displayNameContactEntry =
{
   L"displayName",
   eContactDisplay,
   DS_ATTRIBUTE_ONCREATE,
   &displayName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Employee ID
//
DSATTRIBUTEDESCRIPTION employeeID =
{
   {
      L"employeeID",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY employeeIDUserEntry =
{
   L"employeeID",
   eUserEmpID,
   DS_ATTRIBUTE_ONCREATE,
   &employeeID,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Password
//
DSATTRIBUTEDESCRIPTION password =
{
   {
      NULL,
      ADS_ATTR_UPDATE,
      ADSTYPE_INVALID,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY passwordUserEntry =
{
   L"password",
   eUserPwd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &password,
   ResetUserPassword,
   NULL
};

//
// Office
//
DSATTRIBUTEDESCRIPTION office =
{
   {
      L"physicalDeliveryOfficeName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY officeUserEntry =
{
   L"physicalDeliveryOfficeName",
   eUserOffice,
   DS_ATTRIBUTE_ONCREATE,
   &office,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY officeContactEntry =
{
   L"physicalDeliveryOfficeName",
   eContactOffice,
   DS_ATTRIBUTE_ONCREATE,
   &office,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Telephone
//
DSATTRIBUTEDESCRIPTION telephone =
{
   {
      L"telephoneNumber",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY telephoneUserEntry =
{
   L"telephoneNumber",
   eUserTel,
   DS_ATTRIBUTE_ONCREATE,
   &telephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY telephoneContactEntry =
{
   L"telephoneNumber",
   eContactTel,
   DS_ATTRIBUTE_ONCREATE,
   &telephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Email
//
DSATTRIBUTEDESCRIPTION email =
{
   {
      L"mail",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY emailUserEntry =
{
   L"mail",
   eUserEmail,
   DS_ATTRIBUTE_ONCREATE,
   &email,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY emailContactEntry =
{
   L"mail",
   eContactEmail,
   DS_ATTRIBUTE_ONCREATE,
   &email,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Telephone
//
DSATTRIBUTEDESCRIPTION homeTelephone =
{
   {
      L"homePhone",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeTelephoneUserEntry =
{
   L"homePhone",
   eUserHometel,
   DS_ATTRIBUTE_ONCREATE,
   &homeTelephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY homeTelephoneContactEntry =
{
   L"homePhone",
   eContactHometel,
   DS_ATTRIBUTE_ONCREATE,
   &homeTelephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Pager
//
DSATTRIBUTEDESCRIPTION pager =
{
   {
      L"pager",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY pagerUserEntry =
{
   L"pager",
   eUserPager,
   DS_ATTRIBUTE_ONCREATE,
   &pager,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY pagerContactEntry =
{
   L"pager",
   eContactPager,
   DS_ATTRIBUTE_ONCREATE,
   &pager,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Mobile phone
//
DSATTRIBUTEDESCRIPTION mobile =
{
   {
      L"mobile",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY mobileUserEntry =
{
   L"mobile",
   eUserMobile,
   DS_ATTRIBUTE_ONCREATE,
   &mobile,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY mobileContactEntry =
{
   L"mobile",
   eContactMobile,
   DS_ATTRIBUTE_ONCREATE,
   &mobile,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Fax
//
DSATTRIBUTEDESCRIPTION fax =
{
   {
      L"facsimileTelephoneNumber",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY faxUserEntry =
{
   L"facsimileTelephoneNumber",
   eUserFax,
   DS_ATTRIBUTE_ONCREATE,
   &fax,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY faxContactEntry =
{
   L"facsimileTelephoneNumber",
   eContactFax,
   DS_ATTRIBUTE_ONCREATE,
   &fax,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Title
//
DSATTRIBUTEDESCRIPTION title =
{
   {
      L"title",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY titleUserEntry =
{
   L"title",
   eUserTitle,
   DS_ATTRIBUTE_ONCREATE,
   &title,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY titleContactEntry =
{
   L"title",
   eContactTitle,
   DS_ATTRIBUTE_ONCREATE,
   &title,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Department
//
DSATTRIBUTEDESCRIPTION department =
{
   {
      L"department",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY departmentUserEntry =
{
   L"department",
   eUserDept,
   DS_ATTRIBUTE_ONCREATE,
   &department,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY departmentContactEntry =
{
   L"department",
   eContactDept,
   DS_ATTRIBUTE_ONCREATE,
   &department,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Company
//
DSATTRIBUTEDESCRIPTION company =
{
   {
      L"company",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY companyUserEntry =
{
   L"company",
   eUserCompany,
   DS_ATTRIBUTE_ONCREATE,
   &company,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY companyContactEntry =
{
   L"company",
   eContactCompany,
   DS_ATTRIBUTE_ONCREATE,
   &company,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Web Page
//
DSATTRIBUTEDESCRIPTION webPage =
{
   {
      L"wwwHomePage",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY webPageUserEntry =
{
   L"wwwHomePage",
   eUserWebPage,
   DS_ATTRIBUTE_ONCREATE,
   &webPage,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// IP Phone
//
DSATTRIBUTEDESCRIPTION ipPhone =
{
   {
      L"ipPhone",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY ipPhoneUserEntry =
{
   L"ipPhone",
   eUserIPPhone,
   DS_ATTRIBUTE_ONCREATE,
   &ipPhone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Script Path
//
DSATTRIBUTEDESCRIPTION scriptPath =
{
   {
      L"scriptPath",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY scriptPathUserEntry =
{
   L"scriptPath",
   eUserScriptPath,
   DS_ATTRIBUTE_ONCREATE,
   &scriptPath,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Directory
//
DSATTRIBUTEDESCRIPTION homeDirectory =
{
   {
      L"homeDirectory",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeDirectoryUserEntry =
{
   L"homeDirectory",
   eUserHomeDir,
   DS_ATTRIBUTE_ONCREATE,
   &homeDirectory,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Drive
//
DSATTRIBUTEDESCRIPTION homeDrive =
{
   {
      L"homeDrive",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeDriveUserEntry =
{
   L"homeDrive",
   eUserHomeDrive,
   DS_ATTRIBUTE_ONCREATE,
   &homeDrive,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Profile Path
//
DSATTRIBUTEDESCRIPTION profilePath =
{
   {
      L"profilePath",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY profilePathUserEntry =
{
   L"profilePath",
   eUserProfilePath,
   DS_ATTRIBUTE_ONCREATE,
   &profilePath,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// pwdLastSet
//
DSATTRIBUTEDESCRIPTION pwdLastSet =
{
   {
      L"pwdLastSet",
      ADS_ATTR_UPDATE,
      ADSTYPE_LARGE_INTEGER,
      NULL,
      0
   },
   0
};
DSATTRIBUTETABLEENTRY mustChangePwdUserEntry =
{
   L"pwdLastSet",
   eUserMustchpwd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &pwdLastSet,
   SetMustChangePwd,
   NULL
};

//
// accountExpires
//
DSATTRIBUTEDESCRIPTION accountExpires =
{
   {
      L"accountExpires",
      ADS_ATTR_UPDATE,
      ADSTYPE_LARGE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY accountExpiresUserEntry =
{
   L"accountExpires",
   eUserAcctexpires,
   DS_ATTRIBUTE_ONCREATE,
   &accountExpires,
   AccountExpires,
   NULL
};

//
// user account control 
//
DSATTRIBUTEDESCRIPTION userAccountControl =
{
   {
      L"userAccountControl",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY disableUserEntry =
{
   L"userAccountControl",
   eUserDisabled,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &userAccountControl,
   DisableAccount,
   NULL
};

DSATTRIBUTETABLEENTRY pwdNeverExpiresUserEntry =
{
   L"userAccountControl",
   eUserPwdneverexpires,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   PwdNeverExpires,
   NULL
};

DSATTRIBUTETABLEENTRY reverisblePwdUserEntry =
{
   L"userAccountControl",
   eUserReversiblePwd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   ReversiblePwd,
   NULL
};

DSATTRIBUTETABLEENTRY accountTypeComputerEntry =
{
   L"userAccountControl",
   0,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_REQUIRED,
   &userAccountControl,
   SetComputerAccountType,
   0
};

DSATTRIBUTETABLEENTRY disableComputerEntry =
{
   L"userAccountControl",
   NULL,				// does not have a cooresponding command line switch
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &userAccountControl,
   DisableAccount,
   NULL
};

//
// SAM Account Name
//
DSATTRIBUTEDESCRIPTION samAccountName =
{
   {
      L"sAMAccountName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY samNameGroupEntry =
{
   L"sAMAccountName",
   eGroupSamname,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &samAccountName,
   BuildGroupSAMName,
   NULL
};

DSATTRIBUTETABLEENTRY samNameUserEntry =
{
   L"sAMAccountName",
   eUserSam,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &samAccountName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY samNameComputerEntry =
{
   L"sAMAccountName",
   eComputerSamname,
   DS_ATTRIBUTE_ONCREATE | DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_REQUIRED,
   &samAccountName,
   BuildComputerSAMName,
   NULL
};

//
// Manager
//
DSATTRIBUTEDESCRIPTION manager =
{
   {
      L"manager",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY managerUserEntry =
{
   L"manager",
   eUserManager,
   DS_ATTRIBUTE_ONCREATE,
   &manager,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Group Type
//
DSATTRIBUTEDESCRIPTION groupType =
{
   {
      L"groupType",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupScopeTypeEntry =
{
   L"groupType",
   eGroupScope,
   DS_ATTRIBUTE_ONCREATE,
   &groupType,
   SetGroupScope,
   NULL
};

DSATTRIBUTETABLEENTRY groupSecurityTypeEntry =
{
   L"groupType",
   eGroupSecgrp,
   DS_ATTRIBUTE_ONCREATE,
   &groupType,
   SetGroupSecurity,
   NULL
};

//
// Add Group Members
//
DSATTRIBUTEDESCRIPTION groupMembers =
{
   {
      L"member",
      ADS_ATTR_UPDATE,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY membersGroupEntry =
{
   L"member",
   eGroupMembers,
   DS_ATTRIBUTE_POSTCREATE,
   &groupMembers,
   ModifyGroupMembers,
   NULL
};

//
// Add object to another group
//
DSATTRIBUTETABLEENTRY memberOfUserEntry =
{
   L"member",
   eUserMemberOf,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &groupMembers,
   MakeMemberOf,
   NULL
};

DSATTRIBUTETABLEENTRY memberOfComputerEntry =
{
   L"member",
   eComputerMemberOf,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &groupMembers,
   MakeMemberOf,
   NULL
};

DSATTRIBUTETABLEENTRY memberOfGroupEntry =
{
   L"member",
   eGroupMemberOf,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   &groupMembers,
   MakeMemberOf,
   NULL
};

//
// User Can Change Password
//
DSATTRIBUTETABLEENTRY canChangePwdUserEntry =
{
   NULL,
   eUserCanchpwd,
   DS_ATTRIBUTE_POSTCREATE | DS_ATTRIBUTE_NOT_REUSABLE,
   NULL,
   SetCanChangePassword,
   NULL
};

//
// Location
//
DSATTRIBUTEDESCRIPTION location =
{
   {
      L"location",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY locationComputerEntry =
{
   L"location",
   eComputerLocation,
   DS_ATTRIBUTE_ONCREATE,
   &location,
   FillAttrInfoFromObjectEntry,
   NULL
};


//+-------------------------------------------------------------------------
// Objects
//--------------------------------------------------------------------------

//
// Organizational Unit
//

PDSATTRIBUTETABLEENTRY OUAttributeTable[] =
{
   &descriptionEntry
};

DSOBJECTTABLEENTRY g_OUObjectEntry = 
{
   L"organizationalUnit",
   g_pszOU,
   NULL,       // Uses just the common switches
   USAGE_DSADD_OU,
   sizeof(OUAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   OUAttributeTable
};


//
// User
//

PDSATTRIBUTETABLEENTRY UserAttributeTable[] =
{
   &descriptionEntry,
   &samNameUserEntry,
   &upnUserEntry,
   &firstNameUserEntry,
   &middleInitialUserEntry,
   &lastNameUserEntry,
   &displayNameUserEntry,
   &employeeIDUserEntry,
   &passwordUserEntry,
   &memberOfUserEntry,
   &officeUserEntry,
   &telephoneUserEntry,
   &emailUserEntry,
   &homeTelephoneUserEntry,
   &pagerUserEntry,
   &mobileUserEntry,
   &faxUserEntry,
   &ipPhoneUserEntry,
   &webPageUserEntry,
   &titleUserEntry,
   &departmentUserEntry,
   &companyUserEntry,
   &managerUserEntry,
   &homeDirectoryUserEntry,
   &homeDriveUserEntry,
   &profilePathUserEntry,
   &scriptPathUserEntry,
   &canChangePwdUserEntry,
   &mustChangePwdUserEntry,
   &reverisblePwdUserEntry,
   &pwdNeverExpiresUserEntry,
   &accountExpiresUserEntry,
   &disableUserEntry,
};

DSOBJECTTABLEENTRY g_UserObjectEntry = 
{
   L"user",
   g_pszUser,
   DSADD_USER_COMMANDS,
   USAGE_DSADD_USER,
   sizeof(UserAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   UserAttributeTable
};

//
// Contact
//

PDSATTRIBUTETABLEENTRY ContactAttributeTable[] =
{
   &descriptionEntry,
   &firstNameContactEntry,
   &middleInitialContactEntry,
   &lastNameContactEntry,
   &displayNameContactEntry,
   &officeContactEntry,
   &telephoneContactEntry,
   &emailContactEntry,
   &homeTelephoneContactEntry,
   &pagerContactEntry,
   &mobileContactEntry,
   &faxContactEntry,
   &titleContactEntry,
   &departmentContactEntry,
   &companyContactEntry
};

DSOBJECTTABLEENTRY g_ContactObjectEntry = 
{
   L"contact",
   g_pszContact,
   DSADD_CONTACT_COMMANDS,
   USAGE_DSADD_CONTACT,
   sizeof(ContactAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ContactAttributeTable
};

//
// Computer
//

PDSATTRIBUTETABLEENTRY ComputerAttributeTable[] =
{
   &descriptionEntry,
   &samNameComputerEntry,
   &locationComputerEntry,
   &memberOfComputerEntry,
   &accountTypeComputerEntry,
   &disableComputerEntry
};

DSOBJECTTABLEENTRY g_ComputerObjectEntry = 
{
   L"computer",
   g_pszComputer,
   DSADD_COMPUTER_COMMANDS,
   USAGE_DSADD_COMPUTER,
   sizeof(ComputerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ComputerAttributeTable
};

//
// Group
//
PDSATTRIBUTETABLEENTRY GroupAttributeTable[] =
{
   &descriptionEntry,
   &samNameGroupEntry,
   &groupScopeTypeEntry,
   &groupSecurityTypeEntry,
   &memberOfGroupEntry,
   &membersGroupEntry,
};

DSOBJECTTABLEENTRY g_GroupObjectEntry = 
{
   L"group",
   g_pszGroup,
   DSADD_GROUP_COMMANDS,
   USAGE_DSADD_GROUP,
   sizeof(GroupAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   GroupAttributeTable
};


//+-------------------------------------------------------------------------
// Object Table
//--------------------------------------------------------------------------
PDSOBJECTTABLEENTRY g_DSObjectTable[] =
{
   &g_OUObjectEntry,
   &g_UserObjectEntry,
   &g_ContactObjectEntry,
   &g_ComputerObjectEntry,
   &g_GroupObjectEntry,
   NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      Util.cpp
//
//  Contents:  Generic utility functions and classes for dscmd
//
//  History:   01-Oct-2000 JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "util.h"

#ifdef DBG

//
// Globals
//
CDebugSpew  DebugSpew;

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::EnterFunction
//
//  Synopsis:   Outputs "Enter " followed by the function name (or any passed
//              in string) and then calls Indent so that any output is indented
//
//  Arguments:  [nDebugLevel - IN] : the level at which this output should
//                                   be spewed
//              [pszFunction - IN] : a string to output to the console which
//                                   is proceeded by "Entering "
//
//  Returns:    
//
//  History:    01-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::EnterFunction(UINT nDebugLevel, PCWSTR pszFunction)
{
   //
   // Verify input parameter
   //
   if (!pszFunction)
   {
      ASSERT(pszFunction);
      return;
   }

   CComBSTR sbstrOutput(L"Entering ");
   sbstrOutput += pszFunction;

   //
   // Output the debug spew
   //
   Output(nDebugLevel, sbstrOutput);

   //
   // Indent
   //
   Indent();
}

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::LeaveFunction
//
//  Synopsis:   Outputs "Exit " followed by the function name (or any passed
//              in string) and then calls Outdent
//
//  Arguments:  [nDebugLevel - IN] : the level at which this output should
//                                   be spewed
//              [pszFunction - IN] : a string to output to the console which
//                                   is proceeded by "Leaving "
//
//  Returns:    
//
//  History:    01-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::LeaveFunction(UINT nDebugLevel, PCWSTR pszFunction)
{
   //
   // Verify input parameter
   //
   if (!pszFunction)
   {
      ASSERT(pszFunction);
      return;
   }

   //
   // Outdent
   //
   Outdent();

   CComBSTR sbstrOutput(L"Leaving ");
   sbstrOutput += pszFunction;

   //
   // Output the debug spew
   //
   Output(nDebugLevel, sbstrOutput);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::LeaveFunctionHr
//
//  Synopsis:   Outputs "Exit " followed by the function name (or any passed
//              in string), the HRESULT return value, and then calls Outdent
//
//  Arguments:  [nDebugLevel - IN] : the level at which this output should
//                                   be spewed
//              [pszFunction - IN] : a string to output to the console which
//                                   is proceeded by "Leaving "
//              [hr - IN]          : the HRESULT result value that is being
//                                   returned by the function
//
//  Returns:    
//
//  History:    01-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::LeaveFunctionHr(UINT nDebugLevel, PCWSTR pszFunction, HRESULT hr)
{
   //
   // Verify input parameter
   //
   if (!pszFunction)
   {
      ASSERT(pszFunction);
      return;
   }

   //
   // Outdent
   //
   Outdent();

   CComBSTR sbstrOutput(L"Leaving ");
   sbstrOutput += pszFunction;

   //
   // Append the return value
   //
   WCHAR pszReturn[30];
   wsprintf(pszReturn, L" returning 0x%x", hr);

   sbstrOutput += pszReturn;

   //
   // Output the debug spew
   //
   Output(nDebugLevel, sbstrOutput);
}

//+--------------------------------------------------------------------------
//
//  Member:     OsName
//
//  Synopsis:   Returns a readable string of the platform
//
//  Arguments:  [refInfo IN] : reference the OS version info structure
//                             retrieved from GetVersionEx()
//
//  Returns:    PWSTR : returns a pointer to static text describing the
//                      platform.  The returned string does not have to 
//                      be freed.
//
//  History:    20-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
PWSTR OsName(const OSVERSIONINFO& refInfo)
{
   switch (refInfo.dwPlatformId)
   {
      case VER_PLATFORM_WIN32s:
      {
         return L"Win32s on Windows 3.1";
      }
      case VER_PLATFORM_WIN32_WINDOWS:
      {
         switch (refInfo.dwMinorVersion)
         {
            case 0:
            {
               return L"Windows 95";
            }
            case 1:
            {
               return L"Windows 98";
            }
            default:
            {
               return L"Windows 9X";
            }
         }
      }
      case VER_PLATFORM_WIN32_NT:
      {
         return L"Windows NT";
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }
   return L"Some Unknown Windows Version";
}

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::SpewHeader
//
//  Synopsis:   Outputs debug information like command line and build info
//
//  Arguments:  
//
//  Returns:    
//
//  History:    20-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::SpewHeader()
{
   //
   // First output the command line
   //
   PWSTR pszCommandLine = GetCommandLine();
   if (pszCommandLine)
   {
      Output(MINIMAL_LOGGING,
             L"Command line: %s",
             GetCommandLine());
   }

   //
   // Output the module being used
   //
   do // false loop
   {
      //
      // Get the file path
      //
      WCHAR pszFileName[MAX_PATH + 1];
      ::ZeroMemory(pszFileName, sizeof(pszFileName));

      if (::GetModuleFileNameW(::GetModuleHandle(NULL), pszFileName, MAX_PATH) == 0)
      {
         break;
      }

      Output(MINIMAL_LOGGING,
             L"Module: %s",
             pszFileName);

      //
      // get the file attributes
      //
      WIN32_FILE_ATTRIBUTE_DATA attr;
      ::ZeroMemory(&attr, sizeof(attr));

      if (::GetFileAttributesEx(pszFileName, GetFileExInfoStandard, &attr) == 0)
      {
         break;
      }

      //
      // convert the filetime to a system time
      //
      FILETIME localtime;
      ::FileTimeToLocalFileTime(&attr.ftLastWriteTime, &localtime);
      SYSTEMTIME systime;
      ::FileTimeToSystemTime(&localtime, &systime);

      //
      // output the timestamp
      //
      Output(MINIMAL_LOGGING,
             L"Timestamp: %2d/%2d/%4d %2d:%2d:%d.%d",
             systime.wMonth,
             systime.wDay,
             systime.wYear,
             systime.wHour,
             systime.wMinute,
             systime.wSecond,
             systime.wMilliseconds);
   } while (false);

   //
   // Get the system info
   //
   OSVERSIONINFO info;
   info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

   BOOL success = ::GetVersionEx(&info);
   ASSERT(success);

   //
   // Get the Whistler build lab version
   //
   CComBSTR sbstrLabInfo;

   do // false loop
   { 
      HKEY key = 0;
      LONG err = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion",
                                0,
                                KEY_READ,
                                &key);
      if (err != ERROR_SUCCESS)
      {
         break;
      }

      WCHAR buf[MAX_PATH + 1];
      ::ZeroMemory(buf, sizeof(buf));

      DWORD type = 0;
      DWORD bufSize = MAX_PATH + 1;

      err = ::RegQueryValueEx(key,
                              L"BuildLab",
                              0,
                              &type,
                              reinterpret_cast<BYTE*>(buf),
                              &bufSize);
      if (err != ERROR_SUCCESS)
      {
         break;
      }
   
      sbstrLabInfo = buf;
   } while (false);

   Output(MINIMAL_LOGGING,
          L"Build: %s %d.%d build %d %s (BuildLab:%s)",
          OsName(info),
          info.dwMajorVersion,
          info.dwMinorVersion,
          info.dwBuildNumber,
          info.szCSDVersion,
          sbstrLabInfo);

   //
   // Output a blank line to separate the header from the rest of the output
   //
   Output(MINIMAL_LOGGING,
          L"\n");
}

//+--------------------------------------------------------------------------
//
//  Member:     CDebugSpew::Output
//
//  Synopsis:   Outputs the passed in string to stdout proceeded by the number
//              of spaces specified by GetIndent()
//
//  Arguments:  [nDebugLevel - IN] : the level at which this output should
//                                 be spewed
//              [pszOutput - IN] : a format string to output to the console
//              [... - IN]       : a variable argument list to be formatted
//                                 into pszOutput similar to wprintf
//
//  Returns:    
//
//  History:    01-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CDebugSpew::Output(UINT nDebugLevel, PCWSTR pszOutput, ...)
{
   if (nDebugLevel <= GetDebugLevel())
   {
      //
      // Verify parameters
      //
      if (!pszOutput)
      {
         ASSERT(pszOutput);
         return;
      }

	   va_list args;
	   va_start(args, pszOutput);

	   int nBuf;
	   WCHAR szBuffer[1024];

	   nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), pszOutput, args);

      CComBSTR sbstrOutput;

      //
      // Insert the spaces for the indent
      //
      for (UINT nCount = 0; nCount < GetIndent(); nCount++)
      {
         sbstrOutput += L" ";
      }

      //
      // Append the output string
      //
      sbstrOutput += szBuffer;

      //
      // Output the results
      //
      WriteStandardOut(L"%s\n", sbstrOutput);

      va_end(args);
   }
}

#endif // DBG

//+--------------------------------------------------------------------------
//
//  Macro:      MyA2WHelper
//
//  Synopsis:   Converts a string from Ansi to Unicode in the OEM codepage
//
//  Arguments:  [lpw - IN/OUT] : buffer to receive the Unicode string
//              [lpa - IN] : Ansi string to be converted
//              [nChars - IN] : maximum number of characters that can fit in the buffer
//              [acp - IN] : the codepage to use
//
//  Returns:    PWSTR : the Unicode string in the OEM codepage
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
inline PWSTR WINAPI MyA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	ATLASSERT(lpa != NULL);
	ATLASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	return lpw;
}

//+--------------------------------------------------------------------------
//
//  Macro:      A2W_OEM
//
//  Synopsis:   Converts a string from Ansi to Unicode in the OEM codepage
//
//  Arguments:  [lpa - IN] : the string to be converted
//
//  Returns:    PWSTR : the Unicode string in the OEM codepage
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
#define A2W_OEM(lpa) (\
	((_lpaMine = lpa) == NULL) ? NULL : (\
		_convert = (lstrlenA(_lpaMine)+1),\
		MyA2WHelper((LPWSTR) alloca(_convert*2), _lpaMine, _convert, CP_OEMCP)))


//+--------------------------------------------------------------------------
//
//  Function:   _UnicodeToOemConvert
//
//  Synopsis:   takes the passed in string (pszUnicode) and converts it to
//              the OEM code page
//
//  Arguments:  [pszUnicode - IN] : the string to be converted
//              [sbstrOemUnicode - OUT] : the converted string
//
//  Returns:    
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void _UnicodeToOemConvert(PCWSTR pszUnicode, CComBSTR& sbstrOemUnicode)
{
  USES_CONVERSION;

  //
  // add this for the macro to work
  //
  LPCSTR _lpaMine = NULL;

  //
  // convert to CHAR OEM
  //
  int nLen = lstrlen(pszUnicode);
  LPSTR pszOemAnsi = new CHAR[3*(nLen+1)]; // more, to be sure...
  if (pszOemAnsi)
  {
     CharToOem(pszUnicode, pszOemAnsi);

     //
     // convert it back to WCHAR on OEM CP
     //
     sbstrOemUnicode = A2W_OEM(pszOemAnsi);
     delete[] pszOemAnsi;
     pszOemAnsi = 0;
  }
}


//+--------------------------------------------------------------------------
//
//  Function:   SpewAttrs(ADS_ATTR_INFO* pCreateAttrs, DWORD dwNumAttrs);
//
//  Synopsis:   Uses the DEBUG_OUTPUT macro to output the attributes and the
//              values specified
//
//  Arguments:  [pAttrs - IN] : The ADS_ATTR_INFO
//              [dwNumAttrs - IN] : The number of attributes in pAttrs
//
//  Returns:    
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
#ifdef DBG
void SpewAttrs(ADS_ATTR_INFO* pAttrs, DWORD dwNumAttrs)
{
   for (DWORD dwAttrIdx = 0; dwAttrIdx < dwNumAttrs; dwAttrIdx++)
   {
      if (pAttrs[dwAttrIdx].dwADsType == ADSTYPE_DN_STRING           ||
          pAttrs[dwAttrIdx].dwADsType == ADSTYPE_CASE_EXACT_STRING   ||
          pAttrs[dwAttrIdx].dwADsType == ADSTYPE_CASE_IGNORE_STRING  ||
          pAttrs[dwAttrIdx].dwADsType == ADSTYPE_PRINTABLE_STRING)
      {
         for (DWORD dwValueIdx = 0; dwValueIdx < pAttrs[dwAttrIdx].dwNumValues; dwValueIdx++)
         {
            if (pAttrs[dwAttrIdx].pADsValues[dwValueIdx].CaseIgnoreString)
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"   %s = %s", 
                            pAttrs[dwAttrIdx].pszAttrName, 
                            pAttrs[dwAttrIdx].pADsValues[dwValueIdx].CaseIgnoreString);
            }
            else
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"   %s = value being cleared", 
                            pAttrs[dwAttrIdx].pszAttrName);
            }
         }
      }
   }
}

#endif // DBG

//+--------------------------------------------------------------------------
//
//  Function:   litow
//
//  Synopsis:   
//
//  Arguments:  [li - IN] :  reference to large integer to be converted to string
//              [sResult - OUT] : Gets the output string
//  Returns:    void
//
//  History:    25-Sep-2000   hiteshr   Created
//              Copied from dsadmin code base, changed work with CComBSTR
//---------------------------------------------------------------------------

void litow(LARGE_INTEGER& li, CComBSTR& sResult)
{
	LARGE_INTEGER n;
	n.QuadPart = li.QuadPart;

	if (n.QuadPart == 0)
	{
		sResult = L"0";
	}
	else
	{
		CComBSTR sNeg;
		sResult = L"";
		if (n.QuadPart < 0)
		{
			sNeg = CComBSTR(L'-');
			n.QuadPart *= -1;
		}
		while (n.QuadPart > 0)
		{
            WCHAR ch[2];
            ch[0] = static_cast<WCHAR>(L'0' + static_cast<WCHAR>(n.QuadPart % 10));
            ch[1] = L'\0';
			sResult += ch;
			n.QuadPart = n.QuadPart / 10;
		}
		sResult += sNeg;
	}

    //Reverse the string
    WCHAR szTemp[256];  
    wcscpy(szTemp,sResult);
    LPWSTR pStart,pEnd;
    pStart = szTemp;
    pEnd = pStart + wcslen(pStart) -1;
    while(pStart < pEnd)
    {
        WCHAR ch = *pStart;
        *pStart++ = *pEnd;
        *pEnd-- = ch;
    }

    sResult = szTemp;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsadd\dsadd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsAdd.cpp
//
//  Contents:  Defines the main function and parser tables for the DSAdd
//             command line utility
//
//  History:   22-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "addtable.h"
#include "resource.h"

//
// Function Declarations
//
HRESULT DoAddValidation(PARG_RECORD pCommandArgs);
HRESULT DoAdd(PARG_RECORD pCommandArgs, PDSOBJECTTABLEENTRY pObjectEntry);


int __cdecl _tmain( VOID )
{

   int argc;
   LPTOKEN pToken = NULL;
   HRESULT hr = S_OK;

   //
   // Initialize COM
   //
   hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
   if (FAILED(hr))
   {
      DisplayErrorMessage(g_pszDSCommandName, 
                          NULL,
                          hr);
      return hr;
   }

   if( !GetCommandInput(&argc,&pToken) )
   {
      PARG_RECORD pNewCommandArgs = 0;

      //
      // False loop
      //
      do
      {
         if(argc == 1)
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSADD);
            hr = E_INVALIDARG;
            break;
         }

         //
         // Find which object table entry to use from
         // the second command line argument
         //
         PDSOBJECTTABLEENTRY pObjectEntry = NULL;
         UINT idx = 0;
         while (true)
         {
            pObjectEntry = g_DSObjectTable[idx];
            if (!pObjectEntry)
            {
               break;
            }

            PWSTR pszObjectType = (pToken+1)->GetToken();
            if (0 == _wcsicmp(pObjectEntry->pszCommandLineObjectType, pszObjectType))
            {
               break;
            }
            idx++;
         }

         if (!pObjectEntry)
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSADD);
            hr = E_INVALIDARG;
            break;
         }

         //
         // Now that we have the correct table entry, merge the command line table
         // for this object with the common commands
         //
         hr = MergeArgCommand(DSADD_COMMON_COMMANDS, 
                              pObjectEntry->pParserTable, 
                              &pNewCommandArgs);
         if (FAILED(hr))
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayErrorMessage(g_pszDSCommandName, L"", hr);
            break;
         }

         if (!pNewCommandArgs)
         {
            //
            // Display the usage text and then break out of the false loop
            //
            DisplayMessage(pObjectEntry->nUsageID);
            hr = E_FAIL;
            break;
         }

         PARSE_ERROR Error;
         if(!ParseCmd(pNewCommandArgs,
                      argc-1, 
                      pToken+1,
                      pObjectEntry->nUsageID, 
                      &Error,
                      TRUE))
         {
            if (Error.Error != PARSE_ERROR_HELP_SWITCH &&
                Error.Error != ERROR_FROM_PARSER)
            {
               //
               // Display the usage text and then break out of the false loop
               //
               DisplayMessage(pObjectEntry->nUsageID);
            }
            hr = E_INVALIDARG;
            break;
         }
         else
         {
            //
            // Check to see if we are doing debug spew
            //
#ifdef DBG
            bool bDebugging = pNewCommandArgs[eCommDebug].bDefined && 
                              pNewCommandArgs[eCommDebug].nValue;
            if (bDebugging)
            {
               ENABLE_DEBUG_OUTPUT(pNewCommandArgs[eCommDebug].nValue);
            }
#else
            DISABLE_DEBUG_OUTPUT();
#endif
            //
            // Be sure that mutually exclusive and dependent switches are correct
            //
            hr = DoAddValidation(pNewCommandArgs);
            if (FAILED(hr))
            {
               DisplayErrorMessage(g_pszDSCommandName, 
                                   pNewCommandArgs[eCommObjectDNorName].strValue,
                                   hr);
               break;
            }

            //
            // Command line parsing succeeded
            //
            hr = DoAdd(pNewCommandArgs, pObjectEntry);
         }

      } while (false);

      //
      // Free the memory associated with the command values
      //
      if (pNewCommandArgs)
      {
         FreeCmd(pNewCommandArgs);
      }

      //
      // Free the tokens
      //
      if (pToken)
      {
         delete[] pToken;
         pToken = 0;
      }
   }

   //
   // Uninitialize COM
   //
   ::CoUninitialize();

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoGroupValidation
//
//  Synopsis:   Checks to be sure that command line switches for a group that 
//              are mutually exclusive are not both present and those that 
//              are dependent are both present
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    04-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoGroupValidation(PARG_RECORD pCommandArgs)
{
   HRESULT hr = S_OK;

   do // false loop
   {
      //
      // Set the group scope to default (global) if not given
      //
      if (!pCommandArgs[eGroupScope].bDefined ||
          !pCommandArgs[eGroupScope].strValue)
      {
         size_t nScopeLen = _tcslen(g_bstrGroupScopeGlobal);
         pCommandArgs[eGroupScope].strValue = (LPTSTR)LocalAlloc(LPTR, (nScopeLen+2) * sizeof(TCHAR) );
         if (!pCommandArgs[eGroupScope].strValue)
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Failed to allocate space for pCommandArgs[eGroupScope].strValue");
            hr = E_OUTOFMEMORY;
            break;
         }

         _tcscpy(pCommandArgs[eGroupScope].strValue, g_bstrGroupScopeGlobal);
         pCommandArgs[eGroupScope].bDefined = TRUE;
      }

      //
      // Set the group security to default (yes) if not given
      //
      if (!pCommandArgs[eGroupSecgrp].bDefined)
      {
         pCommandArgs[eGroupSecgrp].bValue = TRUE;
         pCommandArgs[eGroupSecgrp].bDefined = TRUE;

         //
         // Need to change the type to bool so that FreeCmd doesn't
         // try to free the string when the value is true
         //
         pCommandArgs[eGroupSecgrp].fType = ARG_TYPE_BOOL;
      }

   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoAddValidation
//
//  Synopsis:   Checks to be sure that command line switches that are mutually
//              exclusive are not both present and those that are dependent are
//              both presetn
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    22-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoAddValidation(PARG_RECORD pCommandArgs)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoAddValidation, hr);

   do // false loop
   {
      //
      // Check the user switches
      //
      PWSTR pszObjectType = NULL;
      if (!pCommandArgs[eCommObjectType].bDefined &&
          !pCommandArgs[eCommObjectType].strValue)
      {
         hr = E_INVALIDARG;
         break;
      }

      pszObjectType = pCommandArgs[eCommObjectType].strValue;
      if (0 == _wcsicmp(g_pszUser, pszObjectType))
      {
         //
         // Can't have user must change password if user can change password is no
         //
         if ((pCommandArgs[eUserMustchpwd].bDefined &&
              pCommandArgs[eUserMustchpwd].bValue) &&
             (pCommandArgs[eUserCanchpwd].bDefined &&
              !pCommandArgs[eUserCanchpwd].bValue))
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"User must change password and user can change password = false was supplied");
            hr = E_INVALIDARG;
            break;
         }
      }
      else if (0 == _wcsicmp(g_pszGroup, pszObjectType))
      {
         hr = DoGroupValidation(pCommandArgs);
         break;
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoAdd
//
//  Synopsis:   Finds the appropriate object in the object table and fills in
//              the attribute values and then creates the object
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    22-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoAdd(PARG_RECORD pCommandArgs, PDSOBJECTTABLEENTRY pObjectEntry)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoAdd, hr);
   
   PADS_ATTR_INFO pCreateAttrs = NULL;
   PADS_ATTR_INFO pPostCreateAttrs = NULL;

   do // false loop
   {
      if (!pCommandArgs || !pObjectEntry)
      {
         ASSERT(pCommandArgs && pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      CDSCmdCredentialObject credentialObject;
      if (pCommandArgs[eCommUserName].bDefined)
      {
         credentialObject.SetUsername(pCommandArgs[eCommUserName].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      if (pCommandArgs[eCommPassword].bDefined)
      {
         credentialObject.SetPassword(pCommandArgs[eCommPassword].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      //
      // Initialize the base paths info from the command line args
      // 
      CDSCmdBasePathsInfo basePathsInfo;
      if (pCommandArgs[eCommServer].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommServer].strValue,
                                               true);
      }
      else if (pCommandArgs[eCommDomain].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommDomain].strValue,
                                               false);
      }
      else
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
      }

      if (FAILED(hr))
      {
         //
         // Display error message and return
         //
         DisplayErrorMessage(g_pszDSCommandName, NULL, hr);
         break;
      }

      //
      // The DNs or Names should be given as a \0 separated list
      // So parse it and loop through each object
      //
      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(pCommandArgs[eCommObjectDNorName].strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         //
         // Display the usage text and then fail
         //
         DisplayMessage(pObjectEntry->nUsageID);
         hr = E_INVALIDARG;
         break;
      }

      DWORD dwCount = pObjectEntry->dwAttributeCount; 

      //
      // Allocate the creation ADS_ATTR_INFO
      // Add an extra attribute for the object class
      //
      pCreateAttrs = new ADS_ATTR_INFO[dwCount + 1];

      if (!pCreateAttrs)
      {
         //
         // Display error message and return
         //
         DisplayErrorMessage(g_pszDSCommandName, NULL, E_OUTOFMEMORY);
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Allocate the post create ADS_ATTR_INFO
      //
      pPostCreateAttrs = new ADS_ATTR_INFO[dwCount];
      if (!pPostCreateAttrs)
      {
         //
         // Display error message and return
         //
         DisplayErrorMessage(g_pszDSCommandName, NULL, E_OUTOFMEMORY);
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Loop through each of the objects
      //
      for (UINT nNameIdx = 0; nNameIdx < nStrings; nNameIdx++)
      {
         do // false loop
         {
            //
            // Get the objects DN
            //
            PWSTR pszObjectDN = ppszArray[nNameIdx];
            if (!pszObjectDN)
            {
               //
               // Display the usage text and then fail
               //
               DisplayMessage(pObjectEntry->nUsageID);
               hr = E_INVALIDARG;
               break; // this breaks out of the false loop
            }
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Object DN = %s", pszObjectDN);

            CComBSTR sbstrObjectPath;
            basePathsInfo.ComposePathFromDN(pszObjectDN, sbstrObjectPath);

            //
            // Now that we have the table entry loop through the other command line
            // args and see which ones can be applied
            //
            DWORD dwCreateAttributeCount = 0;

            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Starting processing DS_ATTRIBUTE_ONCREATE attributes");

            for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
            {
               ASSERT(pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc);

               UINT nAttributeIdx = pObjectEntry->pAttributeTable[dwIdx]->nAttributeID;

               if (pCommandArgs[nAttributeIdx].bDefined ||
                   pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_REQUIRED)
               {
                  //
                  // Call the evaluation function to get the appropriate ADS_ATTR_INFO set
                  // if this attribute entry has the DS_ATTRIBUTE_ONCREATE flag set
                  //
                  if ((pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_ONCREATE) &&
                      (!(pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_DIRTY) ||
                       pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE))
                  {
                     PADS_ATTR_INFO pNewAttr = NULL;
                     hr = pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc(pszObjectDN,
                                                                          basePathsInfo,
                                                                          credentialObject,
                                                                          pObjectEntry, 
                                                                          pCommandArgs[nAttributeIdx],
                                                                          dwIdx, 
                                                                          &pNewAttr);

                     DEBUG_OUTPUT(MINIMAL_LOGGING, L"pEvalFunc returned hr = 0x%x", hr);
                     if (SUCCEEDED(hr) && hr != S_FALSE)
                     {
                        if (pNewAttr)
                        {
                           pCreateAttrs[dwCreateAttributeCount] = *pNewAttr;
                           dwCreateAttributeCount++;
                        }
                     }
                     else
                     {
                        //
                        // Don't show an error if the eval function returned S_FALSE
                        //
                        if (hr != S_FALSE)
                        {
                           //
                           // Display an error
                           //
                           DisplayErrorMessage(g_pszDSCommandName,
                                               pszObjectDN,
                                               hr);
                        }
            
                        if (hr == S_FALSE)
                        {
                           //
                           // Return a generic error code so that we don't print the success message
                           //
                           hr = E_FAIL;
                        }
                        break; // this breaks out of the attribute loop   
                     }
                  }
               }
            } // Attribute for loop

            //
            // The IDispatch interface of the new object
            //
            CComPtr<IDispatch> spDispatch;

            if (SUCCEEDED(hr))
            {
               //
               // Now that we have the attributes ready, lets create the object
               //

               //
               // Get the parent path of the new object
               //
               CComBSTR sbstrParentDN;
               hr = CPathCracker::GetParentDN(pszObjectDN, sbstrParentDN);
               if (FAILED(hr))
               {
                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break; // this breaks out of the false loop
               }

               CComBSTR sbstrParentPath;
               basePathsInfo.ComposePathFromDN(sbstrParentDN, sbstrParentPath);

               //
               // Open the parent of the new object
               //
               CComPtr<IDirectoryObject> spDirObject;
               hr = DSCmdOpenObject(credentialObject,
                                    sbstrParentPath,
                                    IID_IDirectoryObject,
                                    (void**)&spDirObject,
                                    true);

               if (FAILED(hr))
               {
                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break; // this breaks out of the false loop
               }

               //
               // Get the name of the new object
               //
               CComBSTR sbstrObjectName;
               hr = CPathCracker::GetObjectRDNFromDN(pszObjectDN, sbstrObjectName);
               if (FAILED(hr))
               {
                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break; // this breaks out of the false loop
               }

               //
               // Add the object class to the attributes before creating the object
               //
               PADSVALUE pADsObjectClassValue = new ADSVALUE;
               if (!pADsObjectClassValue)
               {
                  hr = E_OUTOFMEMORY;
                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break; // this breaks out of the false loop
               }

               pADsObjectClassValue->dwType = ADSTYPE_CASE_IGNORE_STRING;
               pADsObjectClassValue->CaseIgnoreString = (PWSTR)pObjectEntry->pszObjectClass;

               DEBUG_OUTPUT(MINIMAL_LOGGING, L"New object name = %s", pObjectEntry->pszObjectClass);

               ADS_ATTR_INFO adsClassAttrInfo =
                  { 
                     L"objectClass",
                     ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING,
                     pADsObjectClassValue,
                     1
                  };

               pCreateAttrs[dwCreateAttributeCount] = adsClassAttrInfo;
               dwCreateAttributeCount++;

      #ifdef DBG
               DEBUG_OUTPUT(FULL_LOGGING, L"Creation Attributes:");
               SpewAttrs(pCreateAttrs, dwCreateAttributeCount);
      #endif
         
               hr = spDirObject->CreateDSObject(sbstrObjectName,
                                                pCreateAttrs, 
                                                dwCreateAttributeCount,
                                                &spDispatch);

               DEBUG_OUTPUT(MINIMAL_LOGGING, L"CreateDSObject returned hr = 0x%x", hr);

               if (FAILED(hr))
               {
                  CComBSTR sbstrDuplicateErrorMessage;

                  if (ERROR_OBJECT_ALREADY_EXISTS == HRESULT_CODE(hr))
                  {
                     sbstrDuplicateErrorMessage.LoadString(::GetModuleHandle(NULL), 
                                                           IDS_MSG_DUPLICATE_NAME_ERROR);
                  }

                  //
                  // Display error message and return
                  //
                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr,
                                      sbstrDuplicateErrorMessage);

                  if (pADsObjectClassValue)
                  {
                     delete pADsObjectClassValue;
                     pADsObjectClassValue = NULL;
                  }
                  break; // this breaks out of the false loop
               }

               if (pADsObjectClassValue)
               {
                  delete pADsObjectClassValue;
                  pADsObjectClassValue = NULL;
               }
            }

            if (SUCCEEDED(hr))
            {
               //
               // Now that we have created the object, set the attributes that are 
               // marked for Post Create
               //
               DWORD dwPostCreateAttributeCount = 0;
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Starting processing DS_ATTRIBUTE_POSTCREATE attributes");
               for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
               {
                  ASSERT(pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc);

                  UINT nAttributeIdx = pObjectEntry->pAttributeTable[dwIdx]->nAttributeID;

               if (pCommandArgs[nAttributeIdx].bDefined ||
                   pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_REQUIRED)
                  {
                     //
                     // Call the evaluation function to get the appropriate ADS_ATTR_INFO set
                     // if this attribute entry has the DS_ATTRIBUTE_POSTCREATE flag set
                     //
                     if ((pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_POSTCREATE) &&
                         (!(pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_DIRTY) ||
                          pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE))
                     {
                        PADS_ATTR_INFO pNewAttr = NULL;
                        hr = pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc(pszObjectDN,
                                                                             basePathsInfo,
                                                                             credentialObject,
                                                                             pObjectEntry, 
                                                                             pCommandArgs[nAttributeIdx],
                                                                             dwIdx, 
                                                                             &pNewAttr);

                        DEBUG_OUTPUT(MINIMAL_LOGGING, L"pEvalFunc returned hr = 0x%x", hr);
                        if (SUCCEEDED(hr) && hr != S_FALSE)
                        {
                           if (pNewAttr)
                           {
                              pPostCreateAttrs[dwPostCreateAttributeCount] = *pNewAttr;
                              dwPostCreateAttributeCount++;
                           }
                        }
                        else
                        {
                           //
                           // Don't show an error if the eval function returned S_FALSE
                           //
                           if (hr != S_FALSE)
                           {
                              //
                              // Load the post create message
                              //
                              CComBSTR sbstrPostCreateMessage;
                              sbstrPostCreateMessage.LoadString(::GetModuleHandle(NULL),
                                                                IDS_POST_CREATE_FAILURE);

                              //
                              // Display an error
                              //
                              DisplayErrorMessage(g_pszDSCommandName,
                                                  pszObjectDN,
                                                  hr,
                                                  sbstrPostCreateMessage);
                           }
         
                           if (hr == S_FALSE)
                           {
                              //
                              // Return a generic error code so that we don't print the success message
                              //
                              hr = E_FAIL;
                           }
                           break; // attribute table loop        
                        }
                     }
                  }
               } // Attribute table for loop

               //
               // Now set the attributes if necessary
               //
               if (SUCCEEDED(hr) && dwPostCreateAttributeCount > 0)
               {
                  //
                  // Now that we have the attributes ready, lets set them in the DS
                  //
                  CComPtr<IDirectoryObject> spNewDirObject;
                  hr = spDispatch->QueryInterface(IID_IDirectoryObject, (void**)&spNewDirObject);
                  if (FAILED(hr))
                  {
                     //
                     // Display error message and return
                     //
                     DEBUG_OUTPUT(MINIMAL_LOGGING, L"QI for IDirectoryObject failed: hr = 0x%x", hr);
                     DisplayErrorMessage(g_pszDSCommandName,
                                         pszObjectDN,
                                         hr);
                     break; // this breaks out of the false loop
                  }

                  DEBUG_OUTPUT(MINIMAL_LOGGING, L"Setting %d attributes", dwPostCreateAttributeCount);
      #ifdef DBG
                  DEBUG_OUTPUT(FULL_LOGGING, L"Post Creation Attributes:");
                  SpewAttrs(pPostCreateAttrs, dwPostCreateAttributeCount);
      #endif

                  DWORD dwAttrsModified = 0;
                  hr = spNewDirObject->SetObjectAttributes(pPostCreateAttrs, 
                                                           dwPostCreateAttributeCount,
                                                           &dwAttrsModified);

                  DEBUG_OUTPUT(MINIMAL_LOGGING, L"SetObjectAttributes returned hr = 0x%x", hr);
                  if (FAILED(hr))
                  {
                     //
                     // Display error message and return
                     //
                     DisplayErrorMessage(g_pszDSCommandName,
                                         pszObjectDN,
                                         hr);
                     break; // this breaks out of the false loop
                  }
               }
            }
         } while (false);

         //
         // Loop through the attributes again, clearing any values for 
         // attribute entries that are marked DS_ATTRIBUTE_NOT_REUSABLE
         //
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Cleaning up memory and flags for object %d", nNameIdx);
         for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
         {
            if (pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE)
            {
               if (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc &&
                   ((pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ) ||
                    (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_DIRTY)))
               {
                  //
                  // Cleanup the memory associated with the value
                  //
                  if (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues)
                  {
                     delete[] pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues;
                     pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues = NULL;
                  }

                  //
                  // Cleanup the flags so that the attribute will be read for the next object
                  //
                  pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags &= ~(DS_ATTRIBUTE_READ);
                  pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags &= ~(DS_ATTRIBUTE_DIRTY);

                  DEBUG_OUTPUT(LEVEL5_LOGGING, 
                               L"Flags for attribute %s = %d",
                               pObjectEntry->pAttributeTable[dwIdx]->pszName,
                               pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags);
               }
            }
         }

         //
         // Break if the continue flag is not specified
         //
         if (FAILED(hr) && !pCommandArgs[eCommContinue].bDefined)
         {
            break; // this breaks out of the name for loop
         }

         //
         // Display the success message
         //
         if (SUCCEEDED(hr) && !pCommandArgs[eCommQuiet].bDefined)
         {
            DisplaySuccessMessage(g_pszDSCommandName,
                                  pCommandArgs[eCommObjectDNorName].strValue);
         }
      } // Names for loop

   } while (false);

   //
   // Cleanup
   //
   if (pCreateAttrs)
   {
      delete[] pCreateAttrs;
      pCreateAttrs = NULL;
   }

   if (pPostCreateAttrs)
   {
      delete[] pPostCreateAttrs;
      pPostCreateAttrs = NULL;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsadd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsadd.rc
//
#define IDS_MSG_FAILED_INIT_PATH_INFO   100
#define IDS_POST_CREATE_FAILURE         101
#define IDS_MSG_DUPLICATE_NAME_ERROR    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\display.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      display.cpp
//
//  Contents:  Defines the functions used to convert values to strings
//             for display purposes
//
//  History:   17-Oct-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include <pch.h>

#include "cstrings.h"
#include "gettable.h"
#include "display.h"
#include "output.h"
#include "query.h"

#include <lmaccess.h>   // UF_* for userAccountControl flags
#include <ntsam.h>      // GROUP_TYPE_*
#include <ntdsapi.h>    // NTDSSETTINGS_OPT_*

//
// All these functions are of type PGETDISPLAYSTRINGFUNC as defined in
// gettable.h
//

HRESULT CommonDisplayStringFunc(PCWSTR /*pszDN*/,
                                CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                const CDSCmdCredentialObject& /*refCredentialObject*/,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& /*spDirObject*/,
                                PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, CommonDisplayStringFunc, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo && pAttrInfo->pADsValues)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);


         DWORD dwValuesAdded = 0;
         for (DWORD dwIdx = 0; dwIdx < pAttrInfo->dwNumValues; dwIdx++)
         {
            WCHAR* pBuffer = new WCHAR[MAXSTR];
            if (!pBuffer)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

            hr = GetStringFromADs(&(pAttrInfo->pADsValues[dwIdx]),
                                  pAttrInfo->dwADsType,
                                  pBuffer, 
                                  MAXSTR);
            if (SUCCEEDED(hr))
            {
               hr = pDisplayInfo->AddValue(pBuffer);
               if (FAILED(hr))
               {
                  delete[] pBuffer;
                  pBuffer = NULL;
                  break;
               }
               delete[] pBuffer;
               pBuffer = NULL;

               dwValuesAdded++;
            }
         }
      }

   } while (false);

   return hr;
}


HRESULT DisplayCanChangePassword(PCWSTR pszDN,
                                 CDSCmdBasePathsInfo& refBasePathsInfo,
                                 const CDSCmdCredentialObject& refCredentialObject,
                                 _DSGetObjectTableEntry* pEntry,
                                 ARG_RECORD* pRecord,
                                 PADS_ATTR_INFO /*pAttrInfo*/,
                                 CComPtr<IDirectoryObject>& /*spDirObject*/,
                                 PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayCanChangePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      bool bCanChangePassword = false;
      hr = EvaluateCanChangePasswordAces(pszDN,
                                         refBasePathsInfo,
                                         refCredentialObject,
                                         bCanChangePassword);
      if (FAILED(hr))
      {
         break;
      }

      DEBUG_OUTPUT(LEVEL8_LOGGING, 
                   L"Can change password: %s", 
                   bCanChangePassword ? g_pszYes : g_pszNo);

      hr = pDisplayInfo->AddValue(bCanChangePassword ? g_pszYes : g_pszNo);

   } while (false);

   return hr;
}

HRESULT DisplayMustChangePassword(PCWSTR /*pszDN*/,
                                  CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                  const CDSCmdCredentialObject& /*refCredentialObject*/,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& /*spDirObject*/,
                                  PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayMustChangePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_LARGE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         bool bMustChangePassword = false;

         if (pAttrInfo->pADsValues->LargeInteger.HighPart == 0 &&
             pAttrInfo->pADsValues->LargeInteger.LowPart  == 0)
         {
            bMustChangePassword = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Must change password: %s", 
                      bMustChangePassword ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bMustChangePassword ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}


HRESULT DisplayAccountDisabled(PCWSTR /*pszDN*/,
                               CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                               const CDSCmdCredentialObject& /*refCredentialObject*/,
                               _DSGetObjectTableEntry* pEntry,
                               ARG_RECORD* pRecord,
                               PADS_ATTR_INFO pAttrInfo,
                               CComPtr<IDirectoryObject>& /*spDirObject*/,
                               PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayAccountDisabled, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         bool bAccountDisabled = false;

         if (pAttrInfo->pADsValues->Integer & UF_ACCOUNTDISABLE)
         {
            bAccountDisabled = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Account disabled: %s", 
                      bAccountDisabled ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bAccountDisabled ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}

HRESULT DisplayPasswordNeverExpires(PCWSTR /*pszDN*/,
                                    CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                    const CDSCmdCredentialObject& /*refCredentialObject*/,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& /*spDirObject*/,
                                    PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayPasswordNeverExpires, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         bool bPwdNeverExpires = false;

         if (pAttrInfo->pADsValues->Integer & UF_DONT_EXPIRE_PASSWD)
         {
            bPwdNeverExpires = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Password never expires: %s", 
                      bPwdNeverExpires ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bPwdNeverExpires ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}


HRESULT DisplayReversiblePassword(PCWSTR /*pszDN*/,
                                  CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                  const CDSCmdCredentialObject& /*refCredentialObject*/,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& /*spDirObject*/,
                                  PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayReversiblePassword, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         bool bReversiblePwd = false;

         if (pAttrInfo->pADsValues->Integer & UF_DONT_EXPIRE_PASSWD)
         {
            bReversiblePwd = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Password store with reversible encryption: %s", 
                      bReversiblePwd ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bReversiblePwd ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}

// Constants

const unsigned long DSCMD_FILETIMES_PER_MILLISECOND = 10000;
const DWORD DSCMD_FILETIMES_PER_SECOND = 1000 * DSCMD_FILETIMES_PER_MILLISECOND;
const DWORD DSCMD_FILETIMES_PER_MINUTE = 60 * DSCMD_FILETIMES_PER_SECOND;
const __int64 DSCMD_FILETIMES_PER_HOUR = 60 * (__int64)DSCMD_FILETIMES_PER_MINUTE;
const __int64 DSCMD_FILETIMES_PER_DAY  = 24 * DSCMD_FILETIMES_PER_HOUR;
const __int64 DSCMD_FILETIMES_PER_MONTH= 30 * DSCMD_FILETIMES_PER_DAY;

HRESULT DisplayAccountExpires(PCWSTR /*pszDN*/,
                              CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                              const CDSCmdCredentialObject& /*refCredentialObject*/,
                              _DSGetObjectTableEntry* pEntry,
                              ARG_RECORD* pRecord,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& /*spDirObject*/,
                              PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayAccountExpires, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo && pAttrInfo->pADsValues)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);


         DWORD dwValuesAdded = 0;
         for (DWORD dwIdx = 0; dwIdx < pAttrInfo->dwNumValues; dwIdx++)
         {
            WCHAR* pBuffer = new WCHAR[MAXSTR];
            if (!pBuffer)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

            if (pAttrInfo->pADsValues[dwIdx].LargeInteger.QuadPart == 0 ||
                pAttrInfo->pADsValues[dwIdx].LargeInteger.QuadPart == -1 ||
                pAttrInfo->pADsValues[dwIdx].LargeInteger.QuadPart == 0x7FFFFFFFFFFFFFFF)
            {
               wcsncpy(pBuffer, g_pszNever, MAXSTR);
               hr = pDisplayInfo->AddValue(pBuffer);
               if (FAILED(hr))
               {
                  delete[] pBuffer;
                  pBuffer = NULL;
                  break;
               }
               dwValuesAdded++;
            }
            else
            {
               FILETIME ftGMT;     // GMT filetime
               FILETIME ftLocal;   // Local filetime
               SYSTEMTIME st;
               SYSTEMTIME stGMT;

               ZeroMemory(&ftGMT, sizeof(FILETIME));
               ZeroMemory(&ftLocal, sizeof(FILETIME));
               ZeroMemory(&st, sizeof(SYSTEMTIME));
               ZeroMemory(&stGMT, sizeof(SYSTEMTIME));

               //Get Local Time in SYSTEMTIME format
               ftGMT.dwLowDateTime = pAttrInfo->pADsValues[dwIdx].LargeInteger.LowPart;
               ftGMT.dwHighDateTime = pAttrInfo->pADsValues[dwIdx].LargeInteger.HighPart;
               FileTimeToSystemTime(&ftGMT, &stGMT);
               SystemTimeToTzSpecificLocalTime(NULL, &stGMT,&st);

               //For Display Purpose reduce one day
               SystemTimeToFileTime(&st, &ftLocal );
               pAttrInfo->pADsValues[dwIdx].LargeInteger.LowPart = ftLocal.dwLowDateTime;
               pAttrInfo->pADsValues[dwIdx].LargeInteger.HighPart = ftLocal.dwHighDateTime;
               pAttrInfo->pADsValues[dwIdx].LargeInteger.QuadPart -= DSCMD_FILETIMES_PER_DAY;
               ftLocal.dwLowDateTime = pAttrInfo->pADsValues[dwIdx].LargeInteger.LowPart;
               ftLocal.dwHighDateTime = pAttrInfo->pADsValues[dwIdx].LargeInteger.HighPart;
               FileTimeToSystemTime(&ftLocal, &st);

               // Format the string with respect to locale
               if (!GetDateFormat(LOCALE_USER_DEFAULT, 0 , 
                                  &st, NULL, 
                                  pBuffer, MAXSTR))
               {
                  hr = GetLastError();
                  DEBUG_OUTPUT(LEVEL5_LOGGING, 
                               L"Failed to locale string for date: hr = 0x%x",
                               hr);
               }
               else
               {
                  hr = pDisplayInfo->AddValue(pBuffer);
                  if (FAILED(hr))
                  {
                     delete[] pBuffer;
                     pBuffer = NULL;
                     break;
                  }
                  dwValuesAdded++;
               }
            }
            delete[] pBuffer;
            pBuffer = NULL;

         }
      }

   } while (false);

   return hr;
}

HRESULT DisplayGroupScope(PCWSTR /*pszDN*/,
                          CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                          const CDSCmdCredentialObject& /*refCredentialObject*/,
                          _DSGetObjectTableEntry* pEntry,
                          ARG_RECORD* pRecord,
                          PADS_ATTR_INFO pAttrInfo,
                          CComPtr<IDirectoryObject>& /*spDirObject*/,
                          PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGroupScope, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d values:",
                      pAttrInfo->dwNumValues);

         if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_RESOURCE_GROUP)
         {
            //
            // Display Domain Local
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Group scope: domain local");

            hr = pDisplayInfo->AddValue(L"domain local");
         }
         else if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_ACCOUNT_GROUP)
         {
            //
            // Display Global
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Group scope: global");

            hr = pDisplayInfo->AddValue(L"global");
         }
         else if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_UNIVERSAL_GROUP)
         {
            //
            // Display Universal
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Group scope: universal");

            hr = pDisplayInfo->AddValue(L"universal");
         }
         else
         {
            //
            // Unknown group type???
            //
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Group scope: unknown???");

            hr = pDisplayInfo->AddValue(L"unknown");
         }

      }

   } while (false);

   return hr;
}

HRESULT DisplayGroupSecurityEnabled(PCWSTR /*pszDN*/,
                                    CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                    const CDSCmdCredentialObject& /*refCredentialObject*/,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& /*spDirObject*/,
                                    PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGroupSecurityEnabled, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pRecord ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pRecord);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (pAttrInfo->pADsValues && pAttrInfo->dwADsType == ADSTYPE_INTEGER)
      {
         DEBUG_OUTPUT(FULL_LOGGING,
                      L"Adding %d value:",
                      1);

         bool bSecurityEnabled = false;

         if (pAttrInfo->pADsValues->Integer & GROUP_TYPE_SECURITY_ENABLED)
         {
            bSecurityEnabled = true;
         }
         DEBUG_OUTPUT(LEVEL8_LOGGING, 
                      L"Group security enabled: %s", 
                      bSecurityEnabled ? g_pszYes : g_pszNo);

         hr = pDisplayInfo->AddValue(bSecurityEnabled ? g_pszYes : g_pszNo);
      }

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ConvertRIDtoDN
//
//  Synopsis:   Finds the DN for the group associated with the primary group ID
//
//  Arguments:  [pObjSID IN]           : SID of the object in question
//              [priGroupRID IN]       : primary group ID of the group to be found
//              [refBasePathsInfo IN]  : reference to base paths info
//              [refCredObject IN]     : reference to the credential manager object
//              [refsbstrdN OUT]       : DN of the group
//
//  Returns:    S_OK if everthing succeeds and a group was found
//              S_FALSE if everthing succeeds but no group was found
//              E_INVALIDARG is an argument is incorrect
//              Anything else was a result of a failed ADSI call
//
//  History:    24-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT ConvertRIDtoDN(PSID pObjSID,
                       DWORD priGroupRID, 
                       CDSCmdBasePathsInfo& refBasePathsInfo,
                       const CDSCmdCredentialObject& refCredObject,
                       CComBSTR& refsbstrDN)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, ConvertRIDtoDN, hr);

   //
   // This needs to be cleaned up no matter how we exit the false loop
   //
   PWSTR pszSearchFilter = NULL;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pObjSID ||
          !priGroupRID)
      {
         ASSERT(pObjSID);
         ASSERT(priGroupRID);
         hr = E_INVALIDARG;
         break;
      }

      UCHAR * psaCount, i;
      PSID pSID = NULL;
      PSID_IDENTIFIER_AUTHORITY psia;
      DWORD rgRid[8];

      psaCount = GetSidSubAuthorityCount(pObjSID);

      if (psaCount == NULL)
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         DEBUG_OUTPUT(MINIMAL_LOGGING, 
                      L"GetSidSubAuthorityCount failed: hr = 0x%x",
                      hr);
         break;
      }

      if (*psaCount > 8)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"The count returned from GetSidSubAuthorityCount was too high: %d",
                      *psaCount);
         hr = E_FAIL;
         break;
      }

      for (i = 0; i < (*psaCount - 1); i++)
      {
         PDWORD pRid = GetSidSubAuthority(pObjSID, (DWORD)i);
         if (pRid == NULL)
         {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"GetSidSubAuthority for index %i failed: hr = 0x%x",
                         i,
                         hr);
            break;
         }
         rgRid[i] = *pRid;
      }

      if (FAILED(hr))
      {
         break;
      }

      rgRid[*psaCount - 1] = priGroupRID;
      for (i = *psaCount; i < 8; i++)
      {
         rgRid[i] = 0;
      }

      psia = GetSidIdentifierAuthority(pObjSID);
      if (psia == NULL)
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"GetSidIdentifierAuthority failed: hr = 0x%x",
                      hr);
         break; 
      }

      if (!AllocateAndInitializeSid(psia, *psaCount, rgRid[0], rgRid[1],
                               rgRid[2], rgRid[3], rgRid[4],
                               rgRid[5], rgRid[6], rgRid[7], &pSID))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"AllocateAndInitializeSid failed: hr = 0x%x",
                      hr);
         break;
      }

      PWSTR rgpwzAttrNames[] = { L"ADsPath" };
      const WCHAR wzSearchFormat[] = L"(&(objectCategory=group)(objectSid=%s))";
      PWSTR pwzSID;

      hr = ADsEncodeBinaryData((PBYTE)pSID, GetLengthSid(pSID), &pwzSID);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"ADsEncodeBinaryData failed: hr = 0x%x",
                      hr);
         break;
      }

      pszSearchFilter = new WCHAR[wcslen(pwzSID) + wcslen(wzSearchFormat) + 1];
      if (!pszSearchFilter)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      wsprintf(pszSearchFilter, wzSearchFormat, pwzSID);
      FreeADsMem(pwzSID);

      //
      // Get the domain path
      //
      CComBSTR sbstrDomainDN;
      sbstrDomainDN = refBasePathsInfo.GetDefaultNamingContext();

      CComBSTR sbstrDomainPath;
      refBasePathsInfo.ComposePathFromDN(sbstrDomainDN, sbstrDomainPath);

      //
      // Get an IDirectorySearch interface to the domain
      //
      CComPtr<IDirectorySearch> spDirSearch;
      hr = DSCmdOpenObject(refCredObject,
                           sbstrDomainPath,
                           IID_IDirectorySearch,
                           (void**)&spDirSearch,
                           true);
      if (FAILED(hr))
      {
         break;
      }

      CDSSearch Search;
      hr = Search.Init(spDirSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to initialize the search object: hr = 0x%x",
                      hr);
         break;
      }

      Search.SetFilterString(pszSearchFilter);

      Search.SetAttributeList(rgpwzAttrNames, 1);
      Search.SetSearchScope(ADS_SCOPE_SUBTREE);

      hr = Search.DoQuery();
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to run search: hr = 0x%x",
                      hr);
         break;
      }

      hr = Search.GetNextRow();
      if (hr == S_ADS_NOMORE_ROWS)
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"No group was found with primaryGroupID = %d",
                      priGroupRID);
         //
         // No object has a matching RID, the primary group must have been
         // deleted. Return S_FALSE to denote this condition.
         //
         hr = S_FALSE;
         break;
      }

      if (FAILED(hr))
      {
         break;
      }

      ADS_SEARCH_COLUMN Column;
      hr = Search.GetColumn(L"ADsPath", &Column);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to get the path column: hr = 0x%x",
                      hr);
         break;
      }

      if (!Column.pADsValues->CaseIgnoreString)
      {
         hr = E_FAIL;
         break;
      }

      refsbstrDN = Column.pADsValues->CaseIgnoreString;
      Search.FreeColumn(&Column);
   } while (false);

   //
   // Cleanup
   //
   if (pszSearchFilter)
   {
      delete[] pszSearchFilter;
      pszSearchFilter = NULL;
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   AddMemberOfValues
//
//  Synopsis:   Retrieves the DNs of the objects to which the current object
//              is a member
//
//  Arguments:  [pszDN IN]                : DN of object to retrieve member of
//              [pszClass IN]             : Class of object to retrieve member of
//              [refBasePathsInfo IN]     : reference to Base paths info object
//              [refCredentialObject IN]  : reference to Credential management object
//              [pDirObject IN]           : IDirectoryObject pointer to object
//              [pDisplayInfo IN/OUT]     : Pointer to display info for this attribute
//              [bRecurse IN]             : Should we find the memberOf for each memberOf
//
//  Returns:    S_OK if everthing succeeds
//              E_INVALIDARG is an argument is incorrect
//              Anything else was a result of a failed ADSI call
//
//  History:    24-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT AddMemberOfValues(PCWSTR pszDN,
                          PCWSTR pszClass,
                          CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          IDirectoryObject* pDirObject,
                          PDSGET_DISPLAY_INFO pDisplayInfo,
                          CManagedStringList& refGroupsDisplayed,
                          bool bRecurse = false)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, AddMemberOfValues, hr);

   //
   // These are declared here so that we can free them if we break out of the false loop
   //
   PADS_ATTR_INFO pAttrInfo = NULL;
   PADS_ATTR_INFO pGCAttrInfo = NULL;
   PSID pObjSID = NULL;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      CComPtr<IDirectoryObject> spDirObject;
      if (pDirObject)
      {
         //
         // Use the currently bound object
         // This should only happen on the first call.
         // All recursive calls should have this NULL
         //
         spDirObject = pDirObject;
      }
      else
      {
         //
         // We have to open the object
         //

         CComBSTR sbstrPath;
         refBasePathsInfo.ComposePathFromDN(pszDN, sbstrPath);

         hr = DSCmdOpenObject(refCredentialObject,
                              sbstrPath,
                              IID_IDirectoryObject,
                              (void**)&spDirObject,
                              true);
         if (FAILED(hr))
         {
            break;
         }
      }

      CComBSTR sbstrClass;
      if (!pszClass)
      {
         CComPtr<IADs> spIADs;
         hr = spDirObject->QueryInterface(IID_IADs, (void**)&spIADs);
         if (FAILED(hr))
         {
            break;
         }
         
         hr = spIADs->get_Class(&sbstrClass);
         if (FAILED(hr))
         {
            break;
         }
      }
      else
      {
         sbstrClass = pszClass;
      }

      //
      // Read the memberOf attribute and any attributes we need for that specific class
      //
      if (_wcsicmp(sbstrClass, g_pszUser) == 0 ||
          _wcsicmp(sbstrClass, g_pszComputer) == 0)
      {
         DEBUG_OUTPUT(FULL_LOGGING, L"Displaying membership for a group or computer");

         static const DWORD dwAttrCount = 3;
         PWSTR ppszAttrNames[] = { L"memberOf", L"primaryGroupID", L"objectSID" };
         DWORD dwAttrsReturned = 0;

         hr = spDirObject->GetObjectAttributes(ppszAttrNames,
                                               dwAttrCount,
                                               &pAttrInfo,
                                               &dwAttrsReturned);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"GetObjectAttributes failed for class %s: hr = 0x%x",
                         sbstrClass,
                         hr);
            break;
         }

         if (pAttrInfo && dwAttrsReturned)
         {
            DWORD priGroupRID = 0;

            //
            // For each attribute returned do the appropriate thing
            //
            for (DWORD dwIdx = 0; dwIdx < dwAttrsReturned; dwIdx++)
            {
               if (_wcsicmp(pAttrInfo[dwIdx].pszAttrName, L"memberOf") == 0)
               {
                  //
                  // Add each value and recurse if necessary
                  //
                  for (DWORD dwValueIdx = 0; dwValueIdx < pAttrInfo[dwIdx].dwNumValues; dwValueIdx++)
                  {
                     if (pAttrInfo[dwIdx].pADsValues &&
                         pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString)
                     {
                        if (!refGroupsDisplayed.Contains(pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString))
                        {
                           refGroupsDisplayed.Add(pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString);
                           hr = pDisplayInfo->AddValue(pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString);
                           if (FAILED(hr))
                           {
                              break; // value for loop
                           }
                        
                           if (bRecurse)
                           {
                              hr =  AddMemberOfValues(pAttrInfo[dwIdx].pADsValues[dwValueIdx].DNString,
                                                      NULL,
                                                      refBasePathsInfo,
                                                      refCredentialObject,
                                                      NULL,
                                                      pDisplayInfo,
                                                      refGroupsDisplayed,
                                                      bRecurse);
                              if (FAILED(hr))
                              {
                                 break; // value for loop
                              }
                           }
                        }
                     }
                  }

                  if (FAILED(hr))
                  {
                     break; // attrs for loop
                  }
               }
               else if (_wcsicmp(pAttrInfo[dwIdx].pszAttrName, L"primaryGroupID") == 0)
               {
                  if (pAttrInfo[dwIdx].pADsValues)
                  {
                     priGroupRID = pAttrInfo[dwIdx].pADsValues->Integer;
                  }
               }
               else if (_wcsicmp(pAttrInfo[dwIdx].pszAttrName, L"objectSID") == 0)
               {
                  pObjSID = new BYTE[pAttrInfo[dwIdx].pADsValues->OctetString.dwLength];
                  if (!pObjSID)
                  {
                     hr = E_OUTOFMEMORY;
                     break; // attrs for loop
                  }
                  memcpy(pObjSID, pAttrInfo[dwIdx].pADsValues->OctetString.lpValue,
                         pAttrInfo[dwIdx].pADsValues->OctetString.dwLength);
               }

            } // attrs for loop

            //
            // if we were able to retrieve the SID and the primaryGroupID,
            // then convert that into the DN of the group
            //
            if (pObjSID &&
                priGroupRID)
            {
               CComBSTR sbstrPath;
               hr = ConvertRIDtoDN(pObjSID,
                                   priGroupRID, 
                                   refBasePathsInfo,
                                   refCredentialObject,
                                   sbstrPath);
               if (SUCCEEDED(hr) &&
                   hr != S_FALSE)
               {
                  CComBSTR sbstrDN;

                  hr = CPathCracker::GetDNFromPath(sbstrPath, sbstrDN);
                  if (SUCCEEDED(hr))
                  {
                     if (!refGroupsDisplayed.Contains(sbstrDN))
                     {
                        refGroupsDisplayed.Add(sbstrDN);
                        hr = pDisplayInfo->AddValue(sbstrDN);
                        if (SUCCEEDED(hr) && bRecurse)
                        {
                           hr =  AddMemberOfValues(sbstrDN,
                                                   NULL,
                                                   refBasePathsInfo,
                                                   refCredentialObject,
                                                   NULL,
                                                   pDisplayInfo,
                                                   refGroupsDisplayed,
                                                   bRecurse);
                           if (FAILED(hr))
                           {
                              break; // false do loop
                           }
                        }
                     }
                  }
               }
            }

            if (FAILED(hr))
            {
               break; // false do loop
            }
         }
         if (pAttrInfo)
         {
            FreeADsMem(pAttrInfo);
            pAttrInfo = NULL;
         }
      }
      else if (_wcsicmp(sbstrClass, g_pszGroup) == 0)
      {
         long lGroupType = 0;
         hr = ReadGroupType(pszDN,
                            refBasePathsInfo,
                            refCredentialObject,
                            &lGroupType);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"Could not read group type: hr = 0x%x",
                         hr);
            break;
         }

         //
         // All we want to do is get the memberOf attribute
         //
         DWORD dwAttrCount = 1;
         PWSTR ppszAttrNames[] = { L"memberOf" };

         DWORD dwGCAttrsReturned = 0;
         if (!(lGroupType & GROUP_TYPE_RESOURCE_GROUP))
         {
            //
            // We also have to get its memberOf attribute from the GC if its not a local group
            //
            CComBSTR sbstrGCPath;
            refBasePathsInfo.ComposePathFromDN(pszDN,
                                               sbstrGCPath,
                                               DSCMD_GC_PROVIDER);
            
            //
            // Note: we will continue on as long as we succeed
            //
            CComPtr<IDirectoryObject> spGCDirObject;
            hr = DSCmdOpenObject(refCredentialObject,
                                 sbstrGCPath,
                                 IID_IDirectoryObject,
                                 (void**)&spGCDirObject,
                                 false);
            if (SUCCEEDED(hr))
            {
               //
               // Now get the memberOf attribute
               //
               hr = spGCDirObject->GetObjectAttributes(ppszAttrNames,
                                                       dwAttrCount,
                                                       &pGCAttrInfo,
                                                       &dwGCAttrsReturned);
               if (FAILED(hr))
               {
                  DEBUG_OUTPUT(LEVEL3_LOGGING,
                               L"Could not retrieve memberOf attribute from GC: hr = 0x%x",
                               hr);
                  hr = S_OK;
               }
            }
            else
            {
               DEBUG_OUTPUT(LEVEL3_LOGGING,
                            L"Could not bind to object in GC: hr = 0x%x",
                            hr);
               hr = S_OK;
            }
         }

         DWORD dwAttrsReturned = 0;

         hr = spDirObject->GetObjectAttributes(ppszAttrNames,
                                               dwAttrCount,
                                               &pAttrInfo,
                                               &dwAttrsReturned);
         if (FAILED(hr))
         {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"GetObjectAttributes failed for class %s: hr = 0x%x",
                         sbstrClass,
                         hr);
            break;
         }

         if (pAttrInfo && dwAttrsReturned)
         {
            bool bFirstPass = true;

            ASSERT(dwAttrsReturned == 1);
            ASSERT(_wcsicmp(pAttrInfo->pszAttrName, L"memberOf") == 0);

            //
            // Add each value and recurse if necessary
            //
            for (DWORD dwValueIdx = 0; dwValueIdx < pAttrInfo->dwNumValues; dwValueIdx++)
            {
               bool bExistsInGCList = false;

               if (pAttrInfo->pADsValues &&
                   pAttrInfo->pADsValues[dwValueIdx].DNString)
               {
                  if (pGCAttrInfo && dwGCAttrsReturned)
                  {
                     //
                     // Only add if it wasn't in the GC list
                     //
                     for (DWORD dwGCValueIdx = 0; dwGCValueIdx < pGCAttrInfo->dwNumValues; dwGCValueIdx++)
                     {
                        if (_wcsicmp(pAttrInfo->pADsValues[dwValueIdx].DNString,
                                     pGCAttrInfo->pADsValues[dwGCValueIdx].DNString) == 0)
                        {
                           bExistsInGCList = true;
                           if (!bFirstPass)
                           {
                              break; // gc value for
                           }
                        }

                        //
                        // Add all the GC values on the first pass and recurse if necessary
                        //
                        if (bFirstPass)
                        {
                           if (!refGroupsDisplayed.Contains(pGCAttrInfo->pADsValues[dwGCValueIdx].DNString))
                           {
                              refGroupsDisplayed.Add(pGCAttrInfo->pADsValues[dwGCValueIdx].DNString);
                              hr = pDisplayInfo->AddValue(pGCAttrInfo->pADsValues[dwGCValueIdx].DNString);
                           
                              //
                              // We will ignore failures with the GC list
                              //

                              if (bRecurse)
                              {
                                 hr =  AddMemberOfValues(pGCAttrInfo->pADsValues[dwGCValueIdx].DNString,
                                                         NULL,
                                                         refBasePathsInfo,
                                                         refCredentialObject,
                                                         NULL,
                                                         pDisplayInfo,
                                                         refGroupsDisplayed,
                                                         bRecurse);
                              }
                           }
                        }
                     }

                     bFirstPass = false;
                  }

                  //
                  // If it doesn't exist in the GC list then add it.
                  //
                  if (!bExistsInGCList)
                  {
                     if (!refGroupsDisplayed.Contains(pAttrInfo->pADsValues[dwValueIdx].DNString))
                     {
                        refGroupsDisplayed.Add(pAttrInfo->pADsValues[dwValueIdx].DNString);
                        hr = pDisplayInfo->AddValue(pAttrInfo->pADsValues[dwValueIdx].DNString);
                        if (FAILED(hr))
                        {
                           break; // value for loop
                        }
               
                        if (bRecurse)
                        {
                           hr =  AddMemberOfValues(pAttrInfo->pADsValues[dwValueIdx].DNString,
                                                   NULL,
                                                   refBasePathsInfo,
                                                   refCredentialObject,
                                                   NULL,
                                                   pDisplayInfo,
                                                   refGroupsDisplayed,
                                                   bRecurse);
                           if (FAILED(hr))
                           {
                              break; // value for loop
                           }
                        }
                     }
                  }
               }
            } // value for loop

            if (FAILED(hr))
            {
               break; // false do loop
            }
         }

      }
      else
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, L"Unknown class type: %s", sbstrClass);
         ASSERT(false);
         hr = E_INVALIDARG;
         break;
      }


   } while (false);

   //
   // Cleanup
   //
   if (pAttrInfo)
   {
      FreeADsMem(pAttrInfo);
      pAttrInfo = NULL;
   }

   if (pGCAttrInfo)
   {
      FreeADsMem(pGCAttrInfo);
      pGCAttrInfo = NULL;
   }

   if (pObjSID)
   {
      delete[] pObjSID;
      pObjSID = NULL;
   }

   return hr;
}

HRESULT DisplayUserMemberOf(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            _DSGetObjectTableEntry* pEntry,
                            ARG_RECORD* pCommandArgs,
                            PADS_ATTR_INFO pAttrInfo,
                            CComPtr<IDirectoryObject>& spDirObject,
                            PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayUserMemberOf, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pEntry ||
          !pCommandArgs ||
          !pAttrInfo ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // This list is used to keep from going into infinite recursion
      // if there is circular group membership
      //
      CManagedStringList groupsDisplayed;

      hr = AddMemberOfValues(pszDN,
                             g_pszUser,
                             refBasePathsInfo,
                             refCredentialObject,
                             spDirObject,
                             pDisplayInfo,
                             groupsDisplayed,
                             (pCommandArgs[eUserExpand].bDefined != 0));

   } while (false);

   return hr;
}

HRESULT DisplayComputerMemberOf(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pCommandArgs,
                                PADS_ATTR_INFO /*pAttrInfo*/,
                                CComPtr<IDirectoryObject>& spDirObject,
                                PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayComputerMemberOf, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // This list is used to keep from going into infinite recursion
      // if there is circular group membership
      //
      CManagedStringList groupsDisplayed;

      hr = AddMemberOfValues(pszDN,
                             g_pszComputer,
                             refBasePathsInfo,
                             refCredentialObject,
                             spDirObject,
                             pDisplayInfo,
                             groupsDisplayed,
                             (pCommandArgs[eComputerExpand].bDefined != 0));

   } while (false);

   return hr;
}

HRESULT DisplayGroupMemberOf(PCWSTR pszDN,
                             CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             _DSGetObjectTableEntry* pEntry,
                             ARG_RECORD* pCommandArgs,
                             PADS_ATTR_INFO /*pAttrInfo*/,
                             CComPtr<IDirectoryObject>& spDirObject,
                             PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGroupMemberOf, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // This list is used to keep from going into infinite recursion
      // if there is circular group membership
      //
      CManagedStringList groupsDisplayed;

      hr = AddMemberOfValues(pszDN,
                             g_pszGroup,
                             refBasePathsInfo,
                             refCredentialObject,
                             spDirObject,
                             pDisplayInfo,
                             groupsDisplayed,
                             (pCommandArgs[eGroupExpand].bDefined != 0));
   } while (false);

   return hr;
}

HRESULT DisplayGrandparentRDN(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                              const CDSCmdCredentialObject& /*refCredentialObject*/,
                              _DSGetObjectTableEntry* /*pEntry*/,
                              ARG_RECORD* /*pCommandArgs*/,
                              PADS_ATTR_INFO /*pAttrInfo*/,
                              CComPtr<IDirectoryObject>& /*spDirObject*/,
                              PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayGrandparentRDN, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      CComBSTR sbstrSiteName;

      CPathCracker pathCracker;
      hr = pathCracker.Set(const_cast<PWSTR>(pszDN), ADS_SETTYPE_DN);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"IADsPathname::Set failed: hr = 0x%x",
                      hr);
         break;
      }

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"IADsPathname::SetDisplayType failed: hr = 0x%x",
                      hr);
         break;
      }

      hr = pathCracker.GetElement(2, &sbstrSiteName);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"IADsPathname::GetElement failed: hr = 0x%x",
                      hr);
         break;
      }

      hr = pDisplayInfo->AddValue(sbstrSiteName);
   } while (false);

   return hr;
}

HRESULT IsServerGCDisplay(PCWSTR pszDN,
                          CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          _DSGetObjectTableEntry* /*pEntry*/,
                          ARG_RECORD* /*pCommandArgs*/,
                          PADS_ATTR_INFO /*pAttrInfo*/,
                          CComPtr<IDirectoryObject>& /*spDirObject*/,
                          PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, IsServerGCDisplay, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszDN ||
          !pDisplayInfo)
      {
         ASSERT(pszDN);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Compose the path to the NTDS settings object from the server DN
      //
      CComBSTR sbstrNTDSSettingsDN;
      sbstrNTDSSettingsDN = L"CN=NTDS Settings,";
      sbstrNTDSSettingsDN += pszDN;

      CComBSTR sbstrNTDSSettingsPath;
      refBasePathsInfo.ComposePathFromDN(sbstrNTDSSettingsDN, sbstrNTDSSettingsPath);

      CComPtr<IADs> spADs;
      hr = DSCmdOpenObject(refCredentialObject,
                           sbstrNTDSSettingsPath,
                           IID_IADs,
                           (void**)&spADs,
                           true);

      if (FAILED(hr))
      {
         break;
      }

      CComVariant var;
      hr = spADs->Get(L"options", &var);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(LEVEL5_LOGGING,
                      L"Failed to get the options: hr = 0x%x",
                      hr);
         break;
      }

      ASSERT(var.vt == VT_I4);

      bool bGC = false;
      if (var.lVal & 0x1)
      {
         bGC = true;
      }
      
      DEBUG_OUTPUT(LEVEL8_LOGGING,
                   L"Server is GC: %s",
                   bGC ? g_pszYes : g_pszNo);

      hr = pDisplayInfo->AddValue(bGC ? g_pszYes : g_pszNo);

   } while (false);

   return hr;
}

HRESULT FindSiteSettingsOptions(IDirectoryObject* pDirectoryObj,
                                DWORD& refOptions)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, FindSiteSettingsOptions, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pDirectoryObj)
      {
         ASSERT(pDirectoryObj);
         hr = E_INVALIDARG;
         break;
      }

      CComPtr<IDirectorySearch> spSearch;
      hr = pDirectoryObj->QueryInterface(IID_IDirectorySearch, (void**)&spSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"QI for IDirectorySearch failed: hr = 0x%x",
                      hr);
         break;
      }

      CDSSearch Search;
      hr = Search.Init(spSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"CDSSearch::Init failed: hr = 0x%x",
                      hr);
         break;
      }

      PWSTR pszSearchFilter = L"(objectClass=nTDSSiteSettings)";
      Search.SetFilterString(pszSearchFilter);

      PWSTR rgpwzAttrNames[] = { L"options" };
      Search.SetAttributeList(rgpwzAttrNames, 1);
      Search.SetSearchScope(ADS_SCOPE_ONELEVEL);

      hr = Search.DoQuery();
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to run search: hr = 0x%x",
                      hr);
         break;
      }

      hr = Search.GetNextRow();
      if (hr == S_ADS_NOMORE_ROWS)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"No rows found!");
         hr = E_FAIL;
         break;
      }

      ADS_SEARCH_COLUMN Column;
      hr = Search.GetColumn(L"options", &Column);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to get the options column: hr = 0x%x",
                      hr);
         break;
      }

      if (Column.dwADsType != ADSTYPE_INTEGER ||
          Column.dwNumValues == 0 ||
          !Column.pADsValues)
      {
         Search.FreeColumn(&Column);
         hr = E_FAIL;
         break;
      }

      refOptions = Column.pADsValues->Integer;

      Search.FreeColumn(&Column);
   } while (false);

   return hr;
}

HRESULT IsAutotopologyEnabledSite(PCWSTR /*pszDN*/,
                                  CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                  const CDSCmdCredentialObject& /*refCredentialObject*/,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pCommandArgs,
                                  PADS_ATTR_INFO /*pAttrInfo*/,
                                  CComPtr<IDirectoryObject>& spDirObject,
                                  PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, IsAutotopologyEnabledSite, hr);

   bool bAutoTopDisabled = false;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Get the options attribute from the nTDSSiteSettings object under the site object
      //
      DWORD dwOptions = 0;
      hr = FindSiteSettingsOptions(spDirObject,
                                   dwOptions);
      if (FAILED(hr))
      {
         break;
      }

      //
      // See if the intersite autotopology is disabled
      //
      if (dwOptions & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED)
      {
         bAutoTopDisabled = true;
      }

   } while (false);

   //
   // Add the value for display
   //
   DEBUG_OUTPUT(LEVEL8_LOGGING,
                L"Autotopology: %s",
                bAutoTopDisabled ? g_pszNo : g_pszYes);

   pDisplayInfo->AddValue(bAutoTopDisabled ? g_pszNo : g_pszYes);

   return hr;
}

HRESULT IsCacheGroupsEnabledSite(PCWSTR /*pszDN*/,
                                 CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                                 const CDSCmdCredentialObject& /*refCredentialObject*/,
                                 _DSGetObjectTableEntry* pEntry,
                                 ARG_RECORD* pCommandArgs,
                                 PADS_ATTR_INFO /*pAttrInfo*/,
                                 CComPtr<IDirectoryObject>& spDirObject,
                                 PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, IsCacheGroupsEnabledSite, hr);

   bool bCacheGroupsEnabled = false;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Get the options attribute from the nTDSSiteSettings object under the site object
      //
      DWORD dwOptions = 0;
      hr = FindSiteSettingsOptions(spDirObject,
                                   dwOptions);
      if (FAILED(hr))
      {
         break;
      }

      //
      // See if groups caching is enabled
      //
      if (dwOptions & NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED)
      {
         bCacheGroupsEnabled = true;
      }

   } while (false);

   //
   // Add the value for display
   //
   DEBUG_OUTPUT(LEVEL8_LOGGING,
                L"Cache groups enabled: %s",
                bCacheGroupsEnabled ? g_pszYes : g_pszNo);

   pDisplayInfo->AddValue(bCacheGroupsEnabled ? g_pszYes : g_pszNo);
  
   return hr;
}

HRESULT FindSiteSettingsPreferredGCSite(IDirectoryObject* pDirectoryObj,
                                        CComBSTR& refsbstrGC)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, FindSiteSettingsPreferredGCSite, hr);

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pDirectoryObj)
      {
         ASSERT(pDirectoryObj);
         hr = E_INVALIDARG;
         break;
      }

      CComPtr<IDirectorySearch> spSearch;
      hr = pDirectoryObj->QueryInterface(IID_IDirectorySearch, (void**)&spSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"QI for IDirectorySearch failed: hr = 0x%x",
                      hr);
         break;
      }

      CDSSearch Search;
      hr = Search.Init(spSearch);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"CDSSearch::Init failed: hr = 0x%x",
                      hr);
         break;
      }

      PWSTR pszSearchFilter = L"(objectClass=nTDSSiteSettings)";
      Search.SetFilterString(pszSearchFilter);

      PWSTR rgpwzAttrNames[] = { L"msDS-Preferred-GC-Site" };
      Search.SetAttributeList(rgpwzAttrNames, 1);
      Search.SetSearchScope(ADS_SCOPE_ONELEVEL);

      hr = Search.DoQuery();
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to run search: hr = 0x%x",
                      hr);
         break;
      }

      hr = Search.GetNextRow();
      if (hr == S_ADS_NOMORE_ROWS)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"No rows found!");
         hr = E_FAIL;
         break;
      }

      ADS_SEARCH_COLUMN Column;
      hr = Search.GetColumn(L"msDS-Preferred-GC-Site", &Column);
      if (FAILED(hr))
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING,
                      L"Failed to get the msDS-Preferred-GC-Site column: hr = 0x%x",
                      hr);
         break;
      }

      if (Column.dwADsType != ADSTYPE_DN_STRING ||
          Column.dwNumValues == 0 ||
          !Column.pADsValues)
      {
         Search.FreeColumn(&Column);
         hr = E_FAIL;
         break;
      }

      refsbstrGC = Column.pADsValues->DNString;

      Search.FreeColumn(&Column);
   } while (false);

   return hr;
}

HRESULT DisplayPreferredGC(PCWSTR /*pszDN*/,
                           CDSCmdBasePathsInfo& /*refBasePathsInfo*/,
                           const CDSCmdCredentialObject& /*refCredentialObject*/,
                           _DSGetObjectTableEntry* pEntry,
                           ARG_RECORD* pCommandArgs,
                           PADS_ATTR_INFO /*pAttrInfo*/,
                           CComPtr<IDirectoryObject>& spDirObject,
                           PDSGET_DISPLAY_INFO pDisplayInfo)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DisplayPreferredGC, hr);

   CComBSTR sbstrGC;

   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pEntry ||
          !pCommandArgs ||
          !pDisplayInfo)
      {
         ASSERT(pEntry);
         ASSERT(pCommandArgs);
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Get the msDS-Preferred-GC-Site attribute from the nTDSSiteSettings 
      // object under the site object
      //
      hr = FindSiteSettingsPreferredGCSite(spDirObject,
                                           sbstrGC);
      if (FAILED(hr))
      {
         break;
      }

   } while (false);

   //
   // Add the value for display
   //
   DEBUG_OUTPUT(LEVEL8_LOGGING,
                L"Preferred GC Site: %s",
                (!sbstrGC) ? g_pszNotConfigured : sbstrGC);

   pDisplayInfo->AddValue((!sbstrGC) ? g_pszNotConfigured : sbstrGC);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the dsget
//
//  History:   13-Oct-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

//
// The command line executable name
//
extern PCWSTR g_pszDSCommandName;

//
// Object types as are typed on the command line
//
extern PCWSTR g_pszOU;
extern PCWSTR g_pszUser;
extern PCWSTR g_pszContact;
extern PCWSTR g_pszComputer;
extern PCWSTR g_pszGroup;   
extern PCWSTR g_pszServer;
extern PCWSTR g_pszSite;
extern PCWSTR g_pszSubnet;

//
// Common switches
//
extern PCWSTR c_sz_arg1_com_debug;
extern PCWSTR c_sz_arg1_com_help;
extern PCWSTR c_sz_arg2_com_help;
extern PCWSTR c_sz_arg1_com_server;
extern PCWSTR c_sz_arg2_com_server;
extern PCWSTR c_sz_arg1_com_domain;
extern PCWSTR c_sz_arg2_com_domain;
extern PCWSTR c_sz_arg1_com_username;
extern PCWSTR c_sz_arg2_com_username;
extern PCWSTR c_sz_arg1_com_password;
extern PCWSTR c_sz_arg2_com_password;
extern PCWSTR c_sz_arg1_com_quiet;
extern PCWSTR c_sz_arg1_com_continue;
extern PCWSTR c_sz_arg1_com_objecttype;
extern PCWSTR c_sz_arg1_com_listformat;
extern PCWSTR c_sz_arg1_com_objectDN;
extern PCWSTR c_sz_arg1_com_description;

//
// User switches
//
extern PCWSTR g_pszArg1UserDN;
extern PCWSTR g_pszArg1UserSID;
extern PCWSTR g_pszArg1UserSAMID;
extern PCWSTR g_pszArg1UserUPN;
extern PCWSTR g_pszArg1UserFirstName;
extern PCWSTR g_pszArg1UserMiddleInitial;
extern PCWSTR g_pszArg1UserLastName;
extern PCWSTR g_pszArg1UserDisplayName;
extern PCWSTR g_pszArg1UserEmployeeID;
extern PCWSTR g_pszArg1UserOffice;
extern PCWSTR g_pszArg1UserTelephone;
extern PCWSTR g_pszArg1UserEmail;
extern PCWSTR g_pszArg1UserHomeTelephone;
extern PCWSTR g_pszArg1UserPagerNumber;
extern PCWSTR g_pszArg1UserMobileNumber;
extern PCWSTR g_pszArg1UserFaxNumber;
extern PCWSTR g_pszArg1UserIPTel;
extern PCWSTR g_pszArg1UserWebPage;
extern PCWSTR g_pszArg1UserTitle;
extern PCWSTR g_pszArg1UserDepartment;
extern PCWSTR g_pszArg1UserCompany;
extern PCWSTR g_pszArg1UserManager;
extern PCWSTR g_pszArg1UserHomeDirectory;
extern PCWSTR g_pszArg1UserHomeDrive;
extern PCWSTR g_pszArg1UserProfile;
extern PCWSTR g_pszArg1UserLogonScript;
extern PCWSTR g_pszArg1UserMustChangePwd;
extern PCWSTR g_pszArg1UserCanChangePwd;
extern PCWSTR g_pszArg1UserPwdNeverExpires;
extern PCWSTR g_pszArg1UserReversiblePwd;
extern PCWSTR g_pszArg1UserDisableAccount;
extern PCWSTR g_pszArg1UserAcctExpires;
extern PCWSTR g_pszArg1UserMemberOf;
extern PCWSTR g_pszArg1UserExpand;

//
// Computer switches
//
extern PCWSTR g_pszArg1ComputerDN;
extern PCWSTR g_pszArg1ComputerSID;
extern PCWSTR g_pszArg1ComputerSAMID;
extern PCWSTR g_pszArg1ComputerLoc;
extern PCWSTR g_pszArg1ComputerDisableAccount;
extern PCWSTR g_pszArg1ComputerMemberOf;
extern PCWSTR g_pszArg1ComputerExpand;

//
// Group switches
//
extern PCWSTR g_pszArg1GroupDN;
extern PCWSTR g_pszArg1GroupSID;
extern PCWSTR g_pszArg1GroupSamid;
extern PCWSTR g_pszArg1GroupSecGrp;
extern PCWSTR g_pszArg1GroupScope;
extern PCWSTR g_pszArg1GroupMemberOf;
extern PCWSTR g_pszArg1GroupMembers;
extern PCWSTR g_pszArg1GroupExpand;
 
//
// Ou switches
//
extern PCWSTR g_pszArg1OUDN;

//
// Server switches
//
extern PCWSTR g_pszArg1ServerDN;
extern PCWSTR g_pszArg1ServerDnsName;
extern PCWSTR g_pszArg1ServerSite;
extern PCWSTR g_pszArg1ServerIsGC;

//
// Site switches
//
extern PCWSTR g_pszArg1SiteDN;
extern PCWSTR g_pszArg1SiteAutotopology;
extern PCWSTR g_pszArg1SiteCacheGroups;
extern PCWSTR g_pszArg1SitePrefGCSite;

//
// Subnet switches
//
extern PCWSTR g_pszArg1SubnetDN;
extern PCWSTR g_pszArg1SubnetLocation;
extern PCWSTR g_pszArg1SubnetSite;


//
// Values
//
extern PCWSTR g_pszYes;
extern PCWSTR g_pszNo;
extern PCWSTR g_pszNotConfigured;
extern PCWSTR g_pszNever;


#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\dsget.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsget.cpp
//
//  Contents:  Defines the main function    DSGET
//             command line utility
//
//  History:   13-Oct-2000 JeffJon Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "gettable.h"
#include "query.h"
#include "resource.h"
#include "output.h"


//
// Forward Function Declarations
//
HRESULT DoGetValidation(PARG_RECORD pCommandArgs,
                        PDSGetObjectTableEntry pObjectEntry);

HRESULT DoGet(PARG_RECORD pCommandArgs, 
              PDSGetObjectTableEntry pObjectEntry);

HRESULT GetAttributesToFetch(IN PARG_RECORD pCommandArgs,
                             IN PDSGetObjectTableEntry pObjectEntry,
                             OUT LPWSTR **ppszAttributes,
                             OUT DWORD * pCount);
VOID FreeAttributesToFetch( IN LPWSTR *ppszAttributes,
                            IN DWORD  dwCount);


//
//Main Function
//
int __cdecl _tmain( VOID )
{

    int argc = 0;
    LPTOKEN pToken = NULL;
    HRESULT hr = S_OK;
    PARG_RECORD pNewCommandArgs = 0;

    //
    // False loop
    //
    do
    {
        //
        // Initialize COM
        //
        hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
        if (FAILED(hr))
            break;

        //Get CommandLine Input
        hr = HRESULT_FROM_WIN32(GetCommandInput(&argc,&pToken));
        if(FAILED(hr))
            break;


    
        if(argc == 1)
        {
            //
            //  Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSGET);
            hr = E_INVALIDARG;
            break;
        }
    
        //
        // Find which object table entry to use from
        // the second command line argument
        //
        PDSGetObjectTableEntry pObjectEntry = NULL;
        UINT idx = 0;
        PWSTR pszObjectType = (pToken+1)->GetToken();
        while (true)
        {
            pObjectEntry = g_DSObjectTable[idx++];
            if (!pObjectEntry)
            {
                break;
            }
            if (0 == _wcsicmp(pObjectEntry->pszCommandLineObjectType, pszObjectType))
            {
                break;
            }
        }

        if (!pObjectEntry)
        {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSGET);
            hr = E_INVALIDARG;
            break;
        }

        //
        // Now that we have the correct table entry, merge the command line table
        // for this object with the common commands
        //
        hr = MergeArgCommand(DSGET_COMMON_COMMANDS, 
                             pObjectEntry->pParserTable, 
                             &pNewCommandArgs);
        if (FAILED(hr))
            break;
        

        //
        //Parse the Input
        //
        PARSE_ERROR Error;
        if(!ParseCmd(pNewCommandArgs,
                     argc-1, 
                     pToken+1,
                     pObjectEntry->nUsageID, 
                     &Error,
                     TRUE))
        {
            if (Error.Error != PARSE_ERROR_HELP_SWITCH &&
                Error.Error != ERROR_FROM_PARSER)
            {
               //
               // Display the usage text and then break out of the false loop
               //
               DisplayMessage(pObjectEntry->nUsageID);
            }

            hr = E_INVALIDARG;
            break;
        }

         //
         // Check to see if we are doing debug spew
         //
#ifdef DBG
         bool bDebugging = pNewCommandArgs[eCommDebug].bDefined && 
                           pNewCommandArgs[eCommDebug].nValue;
         if (bDebugging)
         {
            ENABLE_DEBUG_OUTPUT(pNewCommandArgs[eCommDebug].nValue);
         }
#else
         DISABLE_DEBUG_OUTPUT();
#endif
        //
        // Do extra validation like switch dependency check etc.
        //
        hr = DoGetValidation(pNewCommandArgs,
                             pObjectEntry);
        if (FAILED(hr))
            break;

        //
        // Command line parsing succeeded
        //
        hr = DoGet(pNewCommandArgs, 
                   pObjectEntry);
        if(FAILED(hr))
            break;
         

    } while (false);    //False Loop

    //
    //Do the CleanUp
    //

    //
    // Free the memory associated with the command values
    //
    if (pNewCommandArgs)
    {
      FreeCmd(pNewCommandArgs);
    }

    //
    // Free the tokens
    //
    if (pToken)
    {
        delete[] pToken;
        pToken = 0;
    }
   

    //
    //Display Failure or Success Message
    //
    if(FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
    }
    else
    {
        DisplaySuccessMessage(g_pszDSCommandName,
                              NULL);
    }

    //
    // Uninitialize COM
    //
    CoUninitialize();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoGetValidation
//
//  Synopsis:   Checks to be sure that command line switches that are mutually
//              exclusive are not both present and those that are dependent are
//              both present, and other validations which cannot be done by parser.
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be queryied
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    13-Oct-2000   JeffJon  Created
//
//---------------------------------------------------------------------------
HRESULT DoGetValidation(IN PARG_RECORD pCommandArgs,
                        IN PDSGetObjectTableEntry pObjectEntry)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoGetValidation, hr);

   do // false loop
   {
      if (!pCommandArgs || 
          !pObjectEntry)
      {
         ASSERT(pCommandArgs);
         ASSERT(pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Check the object type specific switches
      //
      PWSTR pszObjectType = NULL;
      if (!pCommandArgs[eCommObjectType].bDefined &&
          !pCommandArgs[eCommObjectType].strValue)
      {
         hr = E_INVALIDARG;
         break;
      }

      pszObjectType = pCommandArgs[eCommObjectType].strValue;

      UINT nMemberOfIdx = 0;
      UINT nExpandIdx = 0;
      UINT nIdxLast = 0;
      UINT nMembersIdx = 0;
      bool bMembersDefined = false;
      bool bMemberOfDefined = false;
      if (0 == _wcsicmp(g_pszUser, pszObjectType) )
      {
         nMemberOfIdx = eUserMemberOf;
         nExpandIdx = eUserExpand;
         nIdxLast = eUserLast;

         if (pCommandArgs[eUserMemberOf].bDefined)
         {
            bMemberOfDefined = true;
         }
         //
         // If nothing is defined, then define DN, SAMAccountName, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eUserLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eUserSamID].bDefined = TRUE;
            pCommandArgs[eUserSamID].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }
      }
      else if (0 == _wcsicmp(g_pszComputer, pszObjectType) )
      {
         nMemberOfIdx = eComputerMemberOf;
         nExpandIdx = eComputerExpand;
         nIdxLast = eComputerLast;

         if (pCommandArgs[eComputerMemberOf].bDefined)
         {
            bMemberOfDefined = true;
         }

      }
      else if (0 == _wcsicmp(g_pszGroup, pszObjectType) )
      {
         nMemberOfIdx = eGroupMemberOf;
         nExpandIdx = eGroupExpand;
         nIdxLast = eGroupLast;
         nMembersIdx = eGroupMembers;

         if (pCommandArgs[eGroupMemberOf].bDefined)
         {
            bMemberOfDefined = true;
         }

         if (pCommandArgs[eGroupMembers].bDefined)
         {
            bMembersDefined = true;
         }
         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eUserLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }
      }
      else if (0 == _wcsicmp(g_pszOU, pszObjectType) ||
               0 == _wcsicmp(g_pszContact, pszObjectType))
      {
         //
         // If nothing is defined, then define DN, and Description
         //
         bool bSomethingDefined = false;
         for (UINT nIdx = eCommDN; nIdx <= eUserLast; nIdx++)
         {
            if (pCommandArgs[nIdx].bDefined)
            {
               bSomethingDefined = true;
               break;
            }
         }
         if (!bSomethingDefined)
         {
            pCommandArgs[eCommDN].bDefined = TRUE;
            pCommandArgs[eCommDN].bValue = TRUE;
            pCommandArgs[eCommDescription].bDefined = TRUE;
            pCommandArgs[eCommDescription].bValue = TRUE;
         }
      }

      //
      // if the members or the memberof switch is defined
      //
      if (bMemberOfDefined ||
          bMembersDefined)
      {
         //
         // If the members switch is defined, undefine everything else
         // If the members switch isn't defined but the memberof switch is
         // undefine everything else
         //
         for (UINT nIdx = eCommDN; nIdx < nIdxLast; nIdx++)
         {
            if ((!bMembersDefined && 
                  bMemberOfDefined &&
                  nIdx != nMemberOfIdx &&
                  nIdx != nExpandIdx) ||
                (bMembersDefined &&
                  nIdx != nMembersIdx &&
                  nIdx != nExpandIdx))
            {
               pCommandArgs[nIdx].bDefined = FALSE;
            }
         }

         //
         // MemberOf should always be seen in list view
         //
         pCommandArgs[eCommList].bDefined = TRUE;
         pCommandArgs[eCommList].bValue = TRUE;
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoGet
//
//  Synopsis:   Does the get
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    13-Oct-2000   JeffJon  Created
//
//---------------------------------------------------------------------------
HRESULT DoGet(PARG_RECORD pCommandArgs, 
              PDSGetObjectTableEntry pObjectEntry)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoGet, hr);

   do // false loop
   {
      if (!pCommandArgs || 
          !pObjectEntry)
      {
         ASSERT(pCommandArgs);
         ASSERT(pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      CDSCmdCredentialObject credentialObject;
      if (pCommandArgs[eCommUserName].bDefined)
      {
         credentialObject.SetUsername(pCommandArgs[eCommUserName].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      if (pCommandArgs[eCommPassword].bDefined)
      {
         credentialObject.SetPassword(pCommandArgs[eCommPassword].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      //
      // Initialize the base paths info from the command line args
      // 
      CDSCmdBasePathsInfo basePathsInfo;
      if (pCommandArgs[eCommServer].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommServer].strValue,
                                               true);
      }
      else if (pCommandArgs[eCommDomain].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommDomain].strValue,
                                               false);
      }
      else
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
      }

      if (FAILED(hr))
      {
         break;
      }

      //
      // The DNs or Names should be given as a \0 separated list
      // So parse it and loop through each object
      //
      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(pCommandArgs[eCommObjectDNorName].strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         //
         // Display the usage text and then fail
         //
         DisplayMessage(pObjectEntry->nUsageID);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Create the formatting object and initialize it
      //
      CFormatInfo formatInfo;
      hr = formatInfo.Initialize(nStrings, 
                                 pCommandArgs[eCommList].bDefined != 0,
                                 pCommandArgs[eCommQuiet].bDefined != 0);
      if (FAILED(hr))
      {
         break;
      }

      //
      // Loop through each of the objects
      //
      for (UINT nNameIdx = 0; nNameIdx < nStrings; nNameIdx++)
      {
         //
         // Use a false do loop here so that we can break on an
         // error but still have the chance to determine if we
         // should continue the for loop if the -c option was provided
         //
         do // false loop
         {

            PWSTR pszObjectDN = ppszArray[nNameIdx];
            if (!pszObjectDN)
            {
               //
               // Display the usage text and then fail
               //
               DisplayMessage(pObjectEntry->nUsageID);
               hr = E_INVALIDARG;
               break;
            }
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Object DN = %s", pszObjectDN);

            CComBSTR sbstrObjectPath;
            basePathsInfo.ComposePathFromDN(pszObjectDN, sbstrObjectPath);

            CComPtr<IDirectoryObject> spObject;
            hr = DSCmdOpenObject(credentialObject,
                                 sbstrObjectPath,
                                 IID_IDirectoryObject,
                                 (void**)&spObject,
                                 true);
            if(FAILED(hr))
            {
               break;
            }
 
            //
            //Get the arributes to fetch
            //
            LPWSTR *ppszAttributes = NULL;
            DWORD dwCountAttr = 0;
            hr = GetAttributesToFetch(pCommandArgs,
                                      pObjectEntry,
                                      &ppszAttributes,
                                      &dwCountAttr);
            if (FAILED(hr))
            {
               break;
            }

            DEBUG_OUTPUT(MINIMAL_LOGGING, 
                         L"Calling GetObjectAttributes for %d attributes.",
                         dwCountAttr);

            DWORD dwAttrsReturned = 0;
            PADS_ATTR_INFO pAttrInfo = NULL;
            hr = spObject->GetObjectAttributes(ppszAttributes, 
                                               dwCountAttr, 
                                               &pAttrInfo, 
                                               &dwAttrsReturned);
            if(FAILED(hr))
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING,
                            L"GetObjectAttributes failed: hr = 0x%x",
                            hr);
               FreeAttributesToFetch(ppszAttributes,dwCountAttr);
               break;
            }        
            DEBUG_OUTPUT(LEVEL5_LOGGING,
                         L"GetObjectAttributes succeeded: dwAttrsReturned = %d",
                         dwAttrsReturned);

            //
            // NOTE: there may be other items to display that are not
            //       part of the attributes fetched
            //
            /*
            if (dwAttrsReturned == 0 || !pAttrInfo)
            {
               break;
            }
            */
            //
            // Output the result of search   
            //
            hr = DsGetOutputValuesList(pszObjectDN,
                                       basePathsInfo,
                                       credentialObject,
                                       pCommandArgs,
                                       pObjectEntry,
                                       dwAttrsReturned,
                                       pAttrInfo,
                                       spObject,
                                       formatInfo); 
         } while (false);

         //
         // If there was a failure and the -c (continue) flag wasn't given
         // then stop processing names
         //
         if (FAILED(hr) && 
             !pCommandArgs[eCommContinue].bDefined)
         {
            break;
         }
      } // Names for loop

      //
      // Now display the results
      //
      formatInfo.Display();

   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetAttributesToFetch
//
//  Synopsis:   Make an array of attributes to fetch.
//  Arguments:  [ppszAttributes - OUT] : array of attributes to fetch
//              [pCount - OUT] : count of attributes in array 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetAttributesToFetch(IN PARG_RECORD pCommandArgs,
                             IN PDSGetObjectTableEntry pObjectEntry,
                             OUT LPWSTR **ppszAttributes,
                             OUT DWORD * pCount)
{
   ENTER_FUNCTION_HR(LEVEL8_LOGGING, GetAttributesToFetch, hr);

   do // false loop
   {

      if(!pCommandArgs || 
         !pObjectEntry)
      {   
         ASSERT(pCommandArgs);
         ASSERT(pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      LPWSTR *ppszAttr = (LPWSTR *)LocalAlloc(LPTR, pObjectEntry->dwAttributeCount *sizeof(LPCTSTR));
      if(!ppszAttr)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // Loop through the attributes that are needed and copy
      // them into the array.
      //
      // REVIEW_JEFFON : what if there are duplicates?
      //
      DEBUG_OUTPUT(FULL_LOGGING, L"Adding attributes to list:");

      DWORD dwAttrCount = 0;
      for(DWORD i = 0; i < pObjectEntry->dwAttributeCount; i++)
      {
         if (pObjectEntry->pAttributeTable[i])
         {
            UINT nCommandEntry = pObjectEntry->pAttributeTable[i]->nAttributeID;
            if (pCommandArgs[nCommandEntry].bDefined)
            {
               LPWSTR pszAttr = pObjectEntry->pAttributeTable[i]->pszName;
               if (pszAttr)
               {
                  hr = LocalCopyString(ppszAttr+dwAttrCount, pszAttr);
                  if (FAILED(hr))
                  {
                     LocalFree(ppszAttr);
                     hr = E_OUTOFMEMORY;
                     break;
                  }
                  DEBUG_OUTPUT(FULL_LOGGING, L"\t%s", pszAttr);
                  dwAttrCount++;
               }
            }
         }
      }

      if (SUCCEEDED(hr))
      {
         DEBUG_OUTPUT(FULL_LOGGING, L"Done adding %d attributes to list.", dwAttrCount);
      }

      *ppszAttributes = ppszAttr;
      *pCount = dwAttrCount;
   } while (false);

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   FreeAttributesToFetch
//
//  Synopsis:   Function to free memory allocated by GetAttributesToFetch
//  Arguments:  [dwszAttributes - in] : array of attributes to fetch
//              [dwCount - in] : count of attributes in array 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
VOID FreeAttributesToFetch( IN LPWSTR *ppszAttributes,
                            IN DWORD  dwCount)
{
    while(dwCount)
    {
        LocalFree(ppszAttributes[--dwCount]);
    }
    LocalFree(ppszAttributes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in dsget
//
//  History:   13-Oct-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

//
// The command line executable name
//
PCWSTR g_pszDSCommandName           = L"dsget";

//
// Object types as are typed on the command line
//
PCWSTR g_pszOU                      = L"ou";
PCWSTR g_pszUser                    = L"user";
PCWSTR g_pszContact                 = L"contact";
PCWSTR g_pszComputer                = L"computer";
PCWSTR g_pszGroup                   = L"group";
PCWSTR g_pszServer                  = L"server";
PCWSTR g_pszSite                    = L"site";
PCWSTR g_pszSubnet                  = L"subnet";

//
// Common switches
//
PCWSTR c_sz_arg1_com_debug          = L"debug";
PCWSTR c_sz_arg1_com_help           = L"h";
PCWSTR c_sz_arg2_com_help           = L"?";
PCWSTR c_sz_arg1_com_server         = L"s";
PCWSTR c_sz_arg2_com_server         = L"server";
PCWSTR c_sz_arg1_com_domain         = L"d";
PCWSTR c_sz_arg2_com_domain         = L"domain";
PCWSTR c_sz_arg1_com_username       = L"u";
PCWSTR c_sz_arg2_com_username       = L"username";
PCWSTR c_sz_arg1_com_password       = L"p";
PCWSTR c_sz_arg2_com_password       = L"password";
PCWSTR c_sz_arg1_com_quiet          = L"q";
PCWSTR c_sz_arg1_com_continue       = L"c";
PCWSTR c_sz_arg1_com_objecttype     = L"objecttype";
PCWSTR c_sz_arg1_com_objectDN       = L"Target object for this command";
PCWSTR c_sz_arg1_com_listformat     = L"l";
PCWSTR c_sz_arg1_com_description    = L"desc";

//
// User switches
//
PCWSTR g_pszArg1UserDN              = L"dn";
PCWSTR g_pszArg1UserSID             = L"sid";
PCWSTR g_pszArg1UserSAMID           = L"samid";
PCWSTR g_pszArg1UserUPN             = L"upn"; 
PCWSTR g_pszArg1UserFirstName       = L"fn";
PCWSTR g_pszArg1UserMiddleInitial   = L"mi";
PCWSTR g_pszArg1UserLastName        = L"ln";
PCWSTR g_pszArg1UserDisplayName     = L"display";
PCWSTR g_pszArg1UserEmployeeID      = L"empid";
PCWSTR g_pszArg1UserOffice          = L"office";
PCWSTR g_pszArg1UserTelephone       = L"tel"; 
PCWSTR g_pszArg1UserEmail           = L"email";
PCWSTR g_pszArg1UserHomeTelephone   = L"hometel";
PCWSTR g_pszArg1UserPagerNumber     = L"pager"; 
PCWSTR g_pszArg1UserMobileNumber    = L"mobile"; 
PCWSTR g_pszArg1UserFaxNumber       = L"fax";
PCWSTR g_pszArg1UserIPTel           = L"iptel";
PCWSTR g_pszArg1UserWebPage         = L"webpg";
PCWSTR g_pszArg1UserTitle           = L"title";
PCWSTR g_pszArg1UserDepartment      = L"dept"; 
PCWSTR g_pszArg1UserCompany         = L"company";
PCWSTR g_pszArg1UserManager         = L"mgr";
PCWSTR g_pszArg1UserHomeDirectory   = L"hmdir";
PCWSTR g_pszArg1UserHomeDrive       = L"hmdrv";
PCWSTR g_pszArg1UserProfile         = L"profile";
PCWSTR g_pszArg1UserLogonScript     = L"loscr";
PCWSTR g_pszArg1UserMustChangePwd   = L"mustchpwd";
PCWSTR g_pszArg1UserCanChangePwd    = L"canchpwd";
PCWSTR g_pszArg1UserPwdNeverExpires = L"pwdneverexpires";
PCWSTR g_pszArg1UserReversiblePwd   = L"reversiblepwd";
PCWSTR g_pszArg1UserDisableAccount  = L"disabled";
PCWSTR g_pszArg1UserAcctExpires     = L"acctexpires";
PCWSTR g_pszArg1UserMemberOf        = L"memberof";
PCWSTR g_pszArg1UserExpand          = L"expand";

//
// Computer switches
//
PCWSTR g_pszArg1ComputerDN          = L"dn"; 
PCWSTR g_pszArg1ComputerSAMID       = L"samid";
PCWSTR g_pszArg1ComputerSID         = L"sid";
PCWSTR g_pszArg1ComputerLoc         = L"loc"; 
PCWSTR g_pszArg1ComputerDisableAccount = L"disabled";
PCWSTR g_pszArg1ComputerMemberOf    = L"memberof"; 
PCWSTR g_pszArg1ComputerExpand      = L"expand";

//
// Group switches
//
PCWSTR g_pszArg1GroupDN             = L"dn"; 
PCWSTR g_pszArg1GroupSamid          = L"samid"; 
PCWSTR g_pszArg1GroupSID            = L"sid";
PCWSTR g_pszArg1GroupSecGrp         = L"secgrp";
PCWSTR g_pszArg1GroupScope          = L"scope"; 
PCWSTR g_pszArg1GroupMemberOf       = L"memberof";
PCWSTR g_pszArg1GroupMembers        = L"members";
PCWSTR g_pszArg1GroupExpand         = L"expand";
 
//
// Ou switches
//
PCWSTR g_pszArg1OUDN                = L"dn"; 


//
// Server switches
//
PCWSTR g_pszArg1ServerDN            = L"dn";
PCWSTR g_pszArg1ServerDnsName       = L"dnsname";
PCWSTR g_pszArg1ServerSite          = L"site";
PCWSTR g_pszArg1ServerIsGC          = L"isgc";

//
// Site switches
//
PCWSTR g_pszArg1SiteDN              = L"dn";
PCWSTR g_pszArg1SiteAutotopology    = L"autotopology";
PCWSTR g_pszArg1SiteCacheGroups     = L"cachegroups";
PCWSTR g_pszArg1SitePrefGCSite      = L"prefGCsite";

//
// Subnet switches
//
PCWSTR g_pszArg1SubnetDN            = L"dn";
PCWSTR g_pszArg1SubnetLocation      = L"loc";
PCWSTR g_pszArg1SubnetSite          = L"site";

//
// Values
//
PCWSTR g_pszYes                     = L"yes";
PCWSTR g_pszNo                      = L"no";
PCWSTR g_pszNotConfigured           = L"not configured";
PCWSTR g_pszNever                   = L"never";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\gettable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      gettable.cpp
//
//  Contents:  Defines Table DSGet
//
//  History:   13-Oct-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "gettable.h"
#include "display.h"
#include "usage.h"

//+--------------------------------------------------------------------------
//
//  Member:     CDSGetDisplayInfo::AddValue
//
//  Synopsis:   Adds a value to the value array and allocates more space
//              if necessary.
//
//  Arguments:  [pszValue IN] : new value to be added
//
//  Returns:    HRESULT : E_OUTOFMEMORY if we failed to allocate space
//                        S_OK if we succeeded in setting the password
//
//  History:    23-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CDSGetDisplayInfo::AddValue(PCWSTR pszValue)
{
   ENTER_FUNCTION_HR(LEVEL8_LOGGING, CDSGetDisplayInfo::AddValue, hr);
   
   do // false loop
   {
      //
      // Verify parameters
      //
      if (!pszValue)
      {
         ASSERT(pszValue);
         hr = E_INVALIDARG;
         break;
      }

      if (m_dwAttributeValueCount == m_dwAttributeValueSize)
      {
         DWORD dwNewSize = m_dwAttributeValueSize + 5;

         //
         // Allocate a new array with more space
         //
         PWSTR* ppszNewArray = new PWSTR[dwNewSize];
         if (!ppszNewArray)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         m_dwAttributeValueSize = dwNewSize;

         //
         // Copy the old values
         //
         memcpy(ppszNewArray, m_ppszAttributeStringValue, m_dwAttributeValueCount * sizeof(PWSTR));

         //
         // Delete the old array
         //
         if (m_ppszAttributeStringValue)
         {
            delete[] m_ppszAttributeStringValue;
         }
         m_ppszAttributeStringValue = ppszNewArray;
      }

      //
      // Add the new value to the end of the array
      //
      m_ppszAttributeStringValue[m_dwAttributeValueCount] = new WCHAR[wcslen(pszValue) + 1];
      if (!m_ppszAttributeStringValue[m_dwAttributeValueCount])
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      wcscpy(m_ppszAttributeStringValue[m_dwAttributeValueCount], pszValue);
      m_dwAttributeValueCount++;

   } while (false);

   return hr;
}

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------

ARG_RECORD DSGET_COMMON_COMMANDS[] = 
{
#ifdef DBG
   //
   // -debug, -debug
   //
   0,(LPWSTR)c_sz_arg1_com_debug, 
   0,NULL,
   ARG_TYPE_DEBUG, ARG_FLAG_OPTIONAL|ARG_FLAG_HIDDEN,  
   NULL,     
   0,  NULL,
#endif

   //
   // h, ?
   //
   0,(LPWSTR)c_sz_arg1_com_help, 
   0,(LPWSTR)c_sz_arg2_com_help, 
   ARG_TYPE_HELP, ARG_FLAG_OPTIONAL,  
   NULL,     
   0,  NULL,

   //
   // objecttype
   //
   0,(LPWSTR)c_sz_arg1_com_objecttype, 
   0,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,  
   0,    
   0,  NULL,

   //
   // s,server
   //
   0,(LPWSTR)c_sz_arg1_com_server, 
   0,(LPWSTR)c_sz_arg2_com_server, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // d,domain
   //
   0,(LPWSTR)c_sz_arg1_com_domain, 
   0,(LPWSTR)c_sz_arg2_com_domain, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // u, username    
   //
   0,(LPWSTR)c_sz_arg1_com_username, 
   0,(LPWSTR)c_sz_arg2_com_username, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // w, password
   //
   0,(LPWSTR)c_sz_arg1_com_password, 
   0,(LPWSTR)c_sz_arg2_com_password, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  ValidateAdminPassword,

   //
   // c  Continue
   //
   0,(PWSTR)c_sz_arg1_com_continue,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)_T(""),
   0, NULL,

   //
   // q,q
   //
   0,(LPWSTR)c_sz_arg1_com_quiet, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // l  List
   //
   0,(LPWSTR)c_sz_arg1_com_listformat, 
   0,NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN|ARG_FLAG_DN,
   0,    
   0,  NULL,

   //
   // dn
   //
   0, (PWSTR)g_pszArg1UserDN, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // description
   //
   0, (PWSTR)c_sz_arg1_com_description,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   ARG_TERMINATOR

};


ARG_RECORD DSGET_USER_COMMANDS[]=
{
   //
   // SamID
   //
   0, (PWSTR)g_pszArg1UserSAMID, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // sid
   //
   0, (PWSTR)g_pszArg1UserSID,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // upn
   //
   0, (PWSTR)g_pszArg1UserUPN, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // empid   Employee ID
   //
   0, (PWSTR)g_pszArg1UserEmployeeID,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // iptel  IP phone#
   //
   0, (PWSTR)g_pszArg1UserIPTel,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // webpg  Web Page
   //
   0, (PWSTR)g_pszArg1UserWebPage,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mgr  Manager
   //
   0, (PWSTR)g_pszArg1UserManager,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // hmdir  Home Directory
   //
   0, (PWSTR)g_pszArg1UserHomeDirectory,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // hmdrv  Home Drive
   //
   0, (PWSTR)g_pszArg1UserHomeDrive,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // profile  Profile
   //
   0, (PWSTR)g_pszArg1UserProfile,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // loscr  Logon Script
   //
   0, (PWSTR)g_pszArg1UserLogonScript,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // mustchpwd Must Change Password at next logon
   //
   0, (PWSTR)g_pszArg1UserMustChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // canchpwd Can Change Password
   //
   0, (PWSTR)g_pszArg1UserCanChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,
   
   //
   // pwdneverexpires Password never expires
   //
   0, (PWSTR)g_pszArg1UserPwdNeverExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,
 
   //
   // disabled  Disable Account
   //
   0, (PWSTR)g_pszArg1UserDisableAccount, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // acctexpires  Account Expires
   //
   0, (PWSTR)g_pszArg1UserAcctExpires,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // reversiblepwd  Password stored with reversible encryption
   //
   0, (PWSTR)g_pszArg1UserReversiblePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // memberof  Member of group
   //
   0, (PWSTR)g_pszArg1UserMemberOf, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // expand  Recursively expand group membership
   //
   0, (PWSTR)g_pszArg1UserExpand, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR
};

ARG_RECORD DSGET_COMPUTER_COMMANDS[]=
{
   //
   // SamID
   //
   0, (PWSTR)g_pszArg1ComputerSAMID, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // sid
   //
   0, (PWSTR)g_pszArg1ComputerSID,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // loc
   //
   0, (PWSTR)g_pszArg1ComputerLoc,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // disabled  Disable Account
   //
   0, (PWSTR)g_pszArg1ComputerDisableAccount, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // memberof  Member of group
   //
   0, (PWSTR)g_pszArg1ComputerMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // expand   Recursively expand group membership
   //
   0, (PWSTR)g_pszArg1ComputerExpand,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)_T(""),
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSGET_GROUP_COMMANDS[]=
{
   //
   // samname
   //
   0, (PWSTR)g_pszArg1GroupSamid,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // sid
   //
   0, (PWSTR)g_pszArg1GroupSID,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // secgrp Security enabled
   //
   0, (PWSTR)g_pszArg1GroupSecGrp,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // scope Group scope (local/global/universal)
   //
   0, (PWSTR)g_pszArg1GroupScope,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // memberof  Member of groups
   //
   0, (PWSTR)g_pszArg1GroupMemberOf,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // members  Contains members
   //
   0, (PWSTR)g_pszArg1GroupMembers,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // expand   Recursively expand group membership
   //
   0, (PWSTR)g_pszArg1GroupExpand,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   ARG_TERMINATOR,
};


ARG_RECORD DSGET_CONTACT_COMMANDS[]=
{
   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,

};


ARG_RECORD DSGET_SERVER_COMMANDS[]=
{
   //
   // dnsname dnsHostName
   //
   0, (PWSTR)g_pszArg1ServerDnsName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // site 
   //
   0, (PWSTR)g_pszArg1ServerSite, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // isGC
   //
   0, (PWSTR)g_pszArg1ServerIsGC, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSGET_SITE_COMMANDS[]=
{
   //
   // dnsname dnsHostName
   //
   0, (PWSTR)g_pszArg1SiteAutotopology, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // site 
   //
   0, (PWSTR)g_pszArg1SiteCacheGroups, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // isGC
   //
   0, (PWSTR)g_pszArg1SitePrefGCSite, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSGET_SUBNET_COMMANDS[]=
{
   //
   // loc Location
   //
   0, (PWSTR)g_pszArg1SubnetLocation, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // site 
   //
   0, (PWSTR)g_pszArg1SubnetSite, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,
};


//+-------------------------------------------------------------------------
// Attributes
//--------------------------------------------------------------------------

//
// Description
//
DSGET_ATTR_TABLE_ENTRY descriptionEntry =
{
   c_sz_arg1_com_description,
   L"description",
   eCommDescription,
   CommonDisplayStringFunc,   
};

//
// SamID
//
DSGET_ATTR_TABLE_ENTRY UserSAMEntry =
{
   g_pszArg1UserSAMID,
   L"sAMAccountName",
   eUserSamID,
   CommonDisplayStringFunc,
};

//
// SamID
//
DSGET_ATTR_TABLE_ENTRY ComputerSAMEntry =
{
   g_pszArg1ComputerSAMID,
   L"sAMAccountName",
   eComputerSamID,
   CommonDisplayStringFunc,
};

//
// SID
//
DSGET_ATTR_TABLE_ENTRY UserSIDEntry =
{
   g_pszArg1UserSID,
   L"objectSID",
   eUserSID,
   CommonDisplayStringFunc,
};

//
// SID
//
DSGET_ATTR_TABLE_ENTRY ComputerSIDEntry =
{
   g_pszArg1ComputerSID,
   L"objectSID",
   eComputerSID,
   CommonDisplayStringFunc,
};

//
// SID
//
DSGET_ATTR_TABLE_ENTRY GroupSIDEntry =
{
   g_pszArg1GroupSID,
   L"objectSID",
   eGroupSID,
   CommonDisplayStringFunc,
};

//
// UPN
//
DSGET_ATTR_TABLE_ENTRY UserUPNEntry =
{
   g_pszArg1UserUPN,
   L"userPrincipalName",
   eUserUpn,
   CommonDisplayStringFunc,
};


//
// First name
//
DSGET_ATTR_TABLE_ENTRY firstNameUserEntry =
{
   g_pszArg1UserFirstName,
   L"givenName",
   eUserFn,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY firstNameContactEntry =
{
   g_pszArg1UserFirstName,
   L"givenName",
   eContactFn,
   CommonDisplayStringFunc,
};

//
// Middle Initial
//
DSGET_ATTR_TABLE_ENTRY middleInitialUserEntry =
{
   g_pszArg1UserMiddleInitial,
   L"initials",
   eUserMi,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY middleInitialContactEntry =
{
   g_pszArg1UserMiddleInitial,
   L"initials",
   eContactMi,
   CommonDisplayStringFunc,
};

//
// Last name
//
DSGET_ATTR_TABLE_ENTRY lastNameUserEntry =
{
   g_pszArg1UserLastName,
   L"sn",
   eUserLn,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY lastNameContactEntry =
{
   g_pszArg1UserLastName,
   L"sn",
   eContactLn,
   CommonDisplayStringFunc,
};

//
// Display name
//
DSGET_ATTR_TABLE_ENTRY displayNameUserEntry =
{
   g_pszArg1UserDisplayName,
   L"displayName",
   eUserDisplay,
   CommonDisplayStringFunc,
};

//
// Employee ID
//
DSGET_ATTR_TABLE_ENTRY employeeIDUserEntry =
{
   g_pszArg1UserEmployeeID,
   L"employeeID",
   eUserEmpID,
   CommonDisplayStringFunc,
};



DSGET_ATTR_TABLE_ENTRY displayNameContactEntry =
{
   g_pszArg1UserDisplayName,
   L"displayName",
   eContactDisplay,
   CommonDisplayStringFunc,
};

//
// Office
//
DSGET_ATTR_TABLE_ENTRY officeUserEntry =
{
   g_pszArg1UserOffice,
   L"physicalDeliveryOfficeName",
   eUserOffice,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY officeContactEntry =
{
   g_pszArg1UserOffice,
   L"physicalDeliveryOfficeName",
   eContactOffice,
   CommonDisplayStringFunc,
};

//
// Telephone
//
DSGET_ATTR_TABLE_ENTRY telephoneUserEntry =
{
   g_pszArg1UserTelephone,
   L"telephoneNumber",
   eUserTel,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY telephoneContactEntry =
{
   g_pszArg1UserTelephone,
   L"telephoneNumber",
   eContactTel,
   CommonDisplayStringFunc,
};

//
// Email
//
DSGET_ATTR_TABLE_ENTRY emailUserEntry =
{
   g_pszArg1UserEmail,
   L"mail",
   eUserEmail,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY emailContactEntry =
{
   g_pszArg1UserEmail,
   L"mail",
   eContactEmail,
   CommonDisplayStringFunc,
};

//
// Home Telephone
//
DSGET_ATTR_TABLE_ENTRY homeTelephoneUserEntry =
{
   g_pszArg1UserHomeTelephone,
   L"homePhone",
   eUserHometel,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY homeTelephoneContactEntry =
{
   g_pszArg1UserHomeTelephone,
   L"homePhone",
   eContactHometel,
   CommonDisplayStringFunc,
};

//
// Pager
//
DSGET_ATTR_TABLE_ENTRY pagerUserEntry =
{
   g_pszArg1UserPagerNumber,
   L"pager",
   eUserPager,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY pagerContactEntry =
{
   g_pszArg1UserPagerNumber,
   L"pager",
   eContactPager,
   CommonDisplayStringFunc,
};

//
// Mobile phone
//
DSGET_ATTR_TABLE_ENTRY mobileUserEntry =
{
   g_pszArg1UserMobileNumber,
   L"mobile",
   eUserMobile,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY mobileContactEntry =
{
   g_pszArg1UserMobileNumber,
   L"mobile",
   eContactMobile,
   CommonDisplayStringFunc,
};

//
// Fax
//
DSGET_ATTR_TABLE_ENTRY faxUserEntry =
{
   g_pszArg1UserFaxNumber,
   L"facsimileTelephoneNumber",
   eUserFax,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY faxContactEntry =
{
   g_pszArg1UserFaxNumber,
   L"facsimileTelephoneNumber",
   eContactFax,
   CommonDisplayStringFunc,
};

//
// IP phone #
//
DSGET_ATTR_TABLE_ENTRY ipPhoneUserEntry =
{
   g_pszArg1UserIPTel,
   L"ipPhones",
   eUserIPTel,
   CommonDisplayStringFunc,
};

//
// Web Page
//
DSGET_ATTR_TABLE_ENTRY webPageUserEntry =
{
   g_pszArg1UserWebPage,
   L"wWWHomePage",
   eUserWebPage,
   CommonDisplayStringFunc,
};


//
// Title
//
DSGET_ATTR_TABLE_ENTRY titleUserEntry =
{
   g_pszArg1UserTitle,
   L"title",
   eUserTitle,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY titleContactEntry =
{
   g_pszArg1UserTitle,
   L"title",
   eContactTitle,
   CommonDisplayStringFunc,
};

//
// Department
//
DSGET_ATTR_TABLE_ENTRY departmentUserEntry =
{
   g_pszArg1UserDepartment,
   L"department",
   eUserDept,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY departmentContactEntry =
{
   g_pszArg1UserDepartment,
   L"department",
   eContactDept,
   CommonDisplayStringFunc,
};

//
// Company
//
DSGET_ATTR_TABLE_ENTRY companyUserEntry =
{
   g_pszArg1UserCompany,
   L"company",
   eUserCompany,
   CommonDisplayStringFunc,
};

DSGET_ATTR_TABLE_ENTRY companyContactEntry =
{
   g_pszArg1UserCompany,
   L"company",
   eContactCompany,
   CommonDisplayStringFunc,
};

//
// Manager
//
DSGET_ATTR_TABLE_ENTRY managerUserEntry =
{
   g_pszArg1UserManager,
   L"manager",
   eUserManager,
   CommonDisplayStringFunc,
};

//
// Home directory
//
DSGET_ATTR_TABLE_ENTRY homeDirectoryUserEntry =
{
   g_pszArg1UserHomeDirectory,
   L"homeDirectory",
   eUserHomeDirectory,
   CommonDisplayStringFunc,
};

//
// Home drive
//
DSGET_ATTR_TABLE_ENTRY homeDriveUserEntry =
{
   g_pszArg1UserHomeDrive,
   L"homeDrive",
   eUserHomeDrive,
   CommonDisplayStringFunc,
};

//
// Profile path
//
DSGET_ATTR_TABLE_ENTRY profilePathUserEntry =
{
   g_pszArg1UserProfile,
   L"profilePath",
   eUserProfilePath,
   CommonDisplayStringFunc,
};

//
// Logon script
//
DSGET_ATTR_TABLE_ENTRY logonScriptUserEntry =
{
   g_pszArg1UserLogonScript,
   L"scriptPath",
   eUserLogonScript,
   CommonDisplayStringFunc,
};

//
// pwdLastSet
//
DSGET_ATTR_TABLE_ENTRY mustChangePwdUserEntry =
{
   g_pszArg1UserMustChangePwd,
   L"pwdLastSet",
   eUserMustchpwd,
   DisplayMustChangePassword, 
};

//
// user account control 
//
DSGET_ATTR_TABLE_ENTRY disableUserEntry =
{
   g_pszArg1UserDisableAccount,
   L"userAccountControl",
   eUserDisabled,
   DisplayAccountDisabled
};

DSGET_ATTR_TABLE_ENTRY disableComputerEntry =
{
   g_pszArg1ComputerDisableAccount,
   L"userAccountControl",
   eComputerDisabled,
   DisplayAccountDisabled
};

DSGET_ATTR_TABLE_ENTRY pwdNeverExpiresUserEntry =
{
   g_pszArg1UserPwdNeverExpires,
   L"userAccountControl",
   eUserPwdneverexpires,
   DisplayPasswordNeverExpires
};

DSGET_ATTR_TABLE_ENTRY reverisblePwdUserEntry =
{
   g_pszArg1UserReversiblePwd,
   L"userAccountControl",
   eUserReversiblePwd,
   DisplayReversiblePassword
};

//
// Account expires
//
DSGET_ATTR_TABLE_ENTRY accountExpiresUserEntry =
{
   g_pszArg1UserAcctExpires,
   L"accountExpires",
   eUserAcctExpires,
   DisplayAccountExpires,
};

//
// SAM Account Name
//
DSGET_ATTR_TABLE_ENTRY samNameGroupEntry =
{
   g_pszArg1GroupSamid,
   L"sAMAccountName",
   eGroupSamname,
   CommonDisplayStringFunc,
};

//
// Group Type
//
DSGET_ATTR_TABLE_ENTRY groupScopeTypeEntry =
{
   g_pszArg1GroupScope,
   L"groupType",
   eGroupScope,
   DisplayGroupScope
};

DSGET_ATTR_TABLE_ENTRY groupSecurityTypeEntry =
{
   g_pszArg1GroupSecGrp,
   L"groupType",
   eGroupSecgrp,
   DisplayGroupSecurityEnabled
};

//
// Group Members
//
DSGET_ATTR_TABLE_ENTRY membersGroupEntry =
{
   g_pszArg1GroupMembers,
   L"member",
   eGroupMembers,
   CommonDisplayStringFunc
};

//
// MemberOf
//
DSGET_ATTR_TABLE_ENTRY memberOfUserEntry =
{
   L"Member of",
   L"memberOf",
   eUserMemberOf,
   DisplayUserMemberOf
};

DSGET_ATTR_TABLE_ENTRY memberOfComputerEntry =
{
   g_pszArg1UserMemberOf,
   L"memberOf",
   eComputerMemberOf,
   DisplayComputerMemberOf
};

DSGET_ATTR_TABLE_ENTRY memberOfGroupEntry =
{
   g_pszArg1GroupMemberOf,
   L"memberOf",
   eGroupMemberOf,
   DisplayGroupMemberOf  
};

//
// User Can Change Password
//
DSGET_ATTR_TABLE_ENTRY canChangePwdUserEntry =
{
   g_pszArg1UserCanChangePwd,
   NULL,
   eUserCanchpwd,
   DisplayCanChangePassword
};

//
// Server entries
//
DSGET_ATTR_TABLE_ENTRY dnsNameServerEntry =
{
   g_pszArg1ServerDnsName,
   L"dnsHostName",
   eServerDnsName,
   CommonDisplayStringFunc  
};

DSGET_ATTR_TABLE_ENTRY siteServerEntry =
{
   g_pszArg1ServerSite,
   NULL,
   eServerSite,
   DisplayGrandparentRDN
};

DSGET_ATTR_TABLE_ENTRY isGCServerEntry =
{
   g_pszArg1ServerIsGC,
   NULL,
   eServerIsGC,
   IsServerGCDisplay
};

//
// Site entries
//
DSGET_ATTR_TABLE_ENTRY autoTopSiteEntry =
{
   g_pszArg1SiteAutotopology,
   NULL,
   eSiteAutoTop,
   IsAutotopologyEnabledSite  
};

DSGET_ATTR_TABLE_ENTRY cacheGroupsSiteEntry =
{
   g_pszArg1SiteCacheGroups,
   NULL,
   eSiteCacheGroups,
   IsCacheGroupsEnabledSite
};

DSGET_ATTR_TABLE_ENTRY prefGCSiteEntry =
{
   g_pszArg1SitePrefGCSite,
   NULL,
   eSitePrefGC,
   DisplayPreferredGC
};

// Computer entries

DSGET_ATTR_TABLE_ENTRY locComputerEntry =
{
   g_pszArg1ComputerLoc,
   L"location",
   eComputerLoc,
   CommonDisplayStringFunc
};


//
// Subnet entries
//
DSGET_ATTR_TABLE_ENTRY locSubnetEntry =
{
   g_pszArg1SubnetLocation,
   L"location",
   eSubnetLocation,
   CommonDisplayStringFunc
};

DSGET_ATTR_TABLE_ENTRY siteSubnetEntry =
{
   g_pszArg1SubnetSite,
   L"siteObject",
   eSubnetSite,
   CommonDisplayStringFunc
};

//
//Attribute Table entries and ObjectTableEntries
//

//
// User
//

PDSGET_ATTR_TABLE_ENTRY UserAttributeTable[] =
{
   &descriptionEntry,
   &UserSAMEntry,
   &UserSIDEntry,
   &UserUPNEntry,
   &firstNameUserEntry,
   &middleInitialUserEntry,
   &lastNameUserEntry,
   &displayNameUserEntry,
   &employeeIDUserEntry,
   &officeUserEntry,
   &telephoneUserEntry,
   &emailUserEntry,
   &homeTelephoneUserEntry,
   &pagerUserEntry,
   &mobileUserEntry,
   &faxUserEntry,
   &ipPhoneUserEntry,
   &webPageUserEntry,
   &titleUserEntry,
   &departmentUserEntry,
   &companyUserEntry,
   &managerUserEntry,
   &homeDirectoryUserEntry,
   &homeDriveUserEntry,
   &profilePathUserEntry,
   &logonScriptUserEntry,
   &mustChangePwdUserEntry,
   &canChangePwdUserEntry,
   &reverisblePwdUserEntry,
   &pwdNeverExpiresUserEntry,
   &accountExpiresUserEntry,
   &disableUserEntry,
   &memberOfUserEntry
};

DSGetObjectTableEntry g_UserObjectEntry = 
{
   L"user",
   g_pszUser,
   DSGET_USER_COMMANDS,
   USAGE_DSGET_USER,
   sizeof(UserAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   UserAttributeTable,
};

//
// Contact
//

PDSGET_ATTR_TABLE_ENTRY ContactAttributeTable[] =
{
   &descriptionEntry,
   &firstNameContactEntry,
   &middleInitialContactEntry,
   &lastNameContactEntry,
   &displayNameContactEntry,
   &officeContactEntry,
   &telephoneContactEntry,
   &emailContactEntry,
   &homeTelephoneContactEntry,
   &pagerContactEntry,
   &mobileContactEntry,
   &faxContactEntry,
   &titleContactEntry,
   &departmentContactEntry,
   &companyContactEntry,
};

DSGetObjectTableEntry g_ContactObjectEntry = 
{
   L"contact",
   g_pszContact,
   DSGET_CONTACT_COMMANDS,
   USAGE_DSGET_CONTACT,
   sizeof(ContactAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ContactAttributeTable,
};

//
// Computer
//

PDSGET_ATTR_TABLE_ENTRY ComputerAttributeTable[] =
{
   &descriptionEntry,
   &ComputerSAMEntry,
   &ComputerSIDEntry,
   &locComputerEntry,
   &disableComputerEntry,
   &memberOfComputerEntry,
};

DSGetObjectTableEntry g_ComputerObjectEntry = 
{
   L"computer",
   g_pszComputer,
   DSGET_COMPUTER_COMMANDS,
   USAGE_DSGET_COMPUTER,
   sizeof(ComputerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ComputerAttributeTable,
};

//
// Group
//
PDSGET_ATTR_TABLE_ENTRY GroupAttributeTable[] =
{
   &descriptionEntry,
   &samNameGroupEntry,
   &GroupSIDEntry,
   &groupScopeTypeEntry,
   &groupSecurityTypeEntry,
   &memberOfGroupEntry,
   &membersGroupEntry,
};

DSGetObjectTableEntry g_GroupObjectEntry = 
{
   L"group",
   g_pszGroup,
   DSGET_GROUP_COMMANDS,
   USAGE_DSGET_GROUP,
   sizeof(GroupAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   GroupAttributeTable,
};


//
// OU
//
PDSGET_ATTR_TABLE_ENTRY OUAttributeTable[] =
{
   &descriptionEntry
};

DSGetObjectTableEntry g_OUObjectEntry = 
{
   L"ou",
   g_pszOU,
   NULL,
   USAGE_DSGET_OU,
   sizeof(OUAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   OUAttributeTable,
};


//
// Server
//
PDSGET_ATTR_TABLE_ENTRY ServerAttributeTable[] =
{
   &dnsNameServerEntry,
   &siteServerEntry,
   &isGCServerEntry
};

DSGetObjectTableEntry g_ServerObjectEntry = 
{
   L"server",
   g_pszServer,
   DSGET_SERVER_COMMANDS,
   USAGE_DSGET_SERVER,
   sizeof(ServerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ServerAttributeTable,
};

//
// Site
//
PDSGET_ATTR_TABLE_ENTRY SiteAttributeTable[] =
{
   &autoTopSiteEntry,
   &cacheGroupsSiteEntry,
   &prefGCSiteEntry
};

DSGetObjectTableEntry g_SiteObjectEntry = 
{
   L"site",
   g_pszSite,
   DSGET_SITE_COMMANDS,
   USAGE_DSGET_SITE,
   sizeof(SiteAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   SiteAttributeTable,
};

//
// Subnet
//
PDSGET_ATTR_TABLE_ENTRY SubnetAttributeTable[] =
{
   &descriptionEntry,
   &locSubnetEntry,
   &siteSubnetEntry
};

DSGetObjectTableEntry g_SubnetObjectEntry = 
{
   L"subnet",
   g_pszSubnet,
   DSGET_SUBNET_COMMANDS,
   USAGE_DSGET_SUBNET,
   sizeof(SubnetAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   SubnetAttributeTable,
};

//+-------------------------------------------------------------------------
// Object Table
//--------------------------------------------------------------------------
PDSGetObjectTableEntry g_DSObjectTable[] =
{
   &g_OUObjectEntry,
   &g_UserObjectEntry,
   &g_ContactObjectEntry,
   &g_ComputerObjectEntry,
   &g_GroupObjectEntry,
   &g_ServerObjectEntry,
   &g_SiteObjectEntry,
   &g_SubnetObjectEntry,
   NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\gettable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      gettable.h
//
//  Contents:  Defines Enum for dsget.
//
//  History:   16-Oct-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _GETTABLE_H_
#define _GETTABLE_H_

//forward declarations
struct _DSGET_ATTRTABLE_ENTRY;
struct _DSGetObjectTableEntry;

//+--------------------------------------------------------------------------
//
//  Class:      CDSGetDisplayInfo
//
//  Purpose:    Object for maintaining attribute values which will be displayed
//
//  History:    23-Oct-2000 JeffJon  Created
//
//---------------------------------------------------------------------------
class CDSGetDisplayInfo
{
public:
   //
   // Constructor
   //
   CDSGetDisplayInfo() 
      : m_pszAttributeDisplayName(NULL),
        m_dwAttributeValueCount(0),
        m_ppszAttributeStringValue(NULL),
        m_dwAttributeValueSize(0)
   {}

   //
   // Desctructor
   //
   ~CDSGetDisplayInfo() 
   {
      if (m_ppszAttributeStringValue)
      {
         delete[] m_ppszAttributeStringValue;
         m_ppszAttributeStringValue = NULL;
      }
   }

   //
   // Public Accessors
   //
   void     SetDisplayName(PCWSTR pszDisplayName) { m_pszAttributeDisplayName = pszDisplayName; }
   PCWSTR   GetDisplayName() { return m_pszAttributeDisplayName; }

   PCWSTR   GetValue(DWORD dwIdx)
   {
      if (dwIdx < m_dwAttributeValueCount)
      {
         return m_ppszAttributeStringValue[dwIdx];
      }
      return NULL;
   }
   HRESULT  AddValue(PCWSTR pszValue);

   DWORD    GetValueCount() { return m_dwAttributeValueCount; }

private:
   //
   // The name of the attribute as it is to be displayed in the output
   //
   PCWSTR m_pszAttributeDisplayName;

   //
   // The number of values in ppszAttributeStringValueArray
   //
   DWORD m_dwAttributeValueCount;

   //
   // The string value as it is to be displayed in the output
   //
   PWSTR* m_ppszAttributeStringValue;

   //
   // The size of the attribute array
   //
   DWORD m_dwAttributeValueSize;
};

typedef CDSGetDisplayInfo* PDSGET_DISPLAY_INFO;

//+-------------------------------------------------------------------------
// 
//  Type:      PGETDISPLAYSTRINGFUNC
//
//  Synopsis:  The definition of a function that prepares ldapFilter from
//             the infix filter given on the commandline.
//
//
//  Returns:   S_OK if the pAttr members were successfully set.
//             S_FALSE if the function failed but displayed its own error message. 
//
//  History:   25-Sep-2000    hiteshr     Created
//
//---------------------------------------------------------------------------
typedef HRESULT (*PGETDISPLAYSTRINGFUNC)(PCWSTR pszDN,
                                         CDSCmdBasePathsInfo& refBasePathsInfo,
                                         const CDSCmdCredentialObject& refCredentialObject,
                                         _DSGetObjectTableEntry* pEntry,
                                         ARG_RECORD* pRecord,
                                         PADS_ATTR_INFO pAttrInfo,
                                         CComPtr<IDirectoryObject>& spDirObject,
                                         PDSGET_DISPLAY_INFO pDisplayInfo);

//+--------------------------------------------------------------------------
//
//  Struct:     _DSGET_ATTRTABLE_ENTRY
//
//  Purpose:    Definition of a table entry that describes the attribute for
//              which filter can be specified at commandline.
//
//  History:    25-Sep-2000 hiteshr  Created
//
//---------------------------------------------------------------------------
typedef struct _DSGET_ATTRTABLE_ENTRY
{
   //
   // The name that will be used for display (ie "Account disabled" instead of
   // "userAccountControl")
   //
   PCWSTR          pszDisplayName;

   //
   // The ldapDisplayName of the attribute
   //
   PWSTR          pszName;

   //
   // The unique identifier for this attribute that cooresponds to
   // the command line switch
   //
   UINT           nAttributeID;

   //
   //  function that gets the string to display for
   //  the value
   //
   PGETDISPLAYSTRINGFUNC pDisplayStringFunc;

} DSGET_ATTR_TABLE_ENTRY, *PDSGET_ATTR_TABLE_ENTRY;

//+--------------------------------------------------------------------------
//
//  Struct:     _DSGetObjectTableEntry
//
//  Purpose:    Definition of a table entry that describes attributes of a given
//              objecttype
//
//  History:    25-Sep-2000 hiteshr Created
//
//---------------------------------------------------------------------------

typedef struct _DSGetObjectTableEntry
{
   //
   // The objectClass of the object to be created or modified
   //
   PCWSTR pszObjectClass;

   //
   // The command line string used to determine the object class
   // This is not always identical to pszObjectClass
   //
   PCWSTR pszCommandLineObjectType;

   //
   // The table to merge with the common switches for the parser
   //
   ARG_RECORD* pParserTable;

   //
   // The ID of the Usage help text for this 
   //
   UINT nUsageID;

   //
   // A count of the number of attributes in the table below
   //
   DWORD dwAttributeCount;

   //
   // A table of attributes for
   // which filter can be specified at commandline.
   //
   DSGET_ATTR_TABLE_ENTRY** pAttributeTable; 

} DSGetObjectTableEntry, *PDSGetObjectTableEntry;


typedef enum COMMON_COMMAND
{
   //
   // Common switches
   //
#ifdef DBG
   eCommDebug,
#endif
   eCommHelp,
   eCommObjectType,   
   eCommServer,
   eCommDomain,
   eCommUserName,
   eCommPassword,
   eCommContinue,
   eCommQuiet,
   eCommList,
   eCommObjectDNorName,
   eCommDN,
   eCommDescription,
   eTerminator,

   //
   // User switches
   //
   eUserSamID = eTerminator,
   eUserSID,
   eUserUpn,
   eUserFn,
   eUserMi,
   eUserLn,
   eUserDisplay,
   eUserEmpID,
   eUserOffice,
   eUserTel,
   eUserEmail,
   eUserHometel,
   eUserPager,
   eUserMobile,
   eUserFax,
   eUserIPTel,
   eUserWebPage,
   eUserTitle,
   eUserDept,
   eUserCompany,
   eUserManager,
   eUserHomeDirectory,
   eUserHomeDrive,
   eUserProfilePath,
   eUserLogonScript,
   eUserMustchpwd,
   eUserCanchpwd,
   eUserPwdneverexpires,
   eUserDisabled,
   eUserAcctExpires,
   eUserReversiblePwd,
   eUserMemberOf,
   eUserExpand,
   eUserLast = eUserExpand,

   //
   // Contact switches
   //
   eContactFn = eTerminator,
   eContactMi,
   eContactLn,
   eContactDisplay,
   eContactOffice,
   eContactTel,
   eContactEmail,
   eContactHometel,
   eContactPager,
   eContactMobile,
   eContactFax,
   eContactTitle,
   eContactDept,
   eContactCompany,
   eContactLast = eContactCompany,

   //
   // Computer switches
   //
   eComputerSamID = eTerminator,
   eComputerSID,
   eComputerLoc,
   eComputerDisabled,
   eComputerMemberOf,
   eComputerExpand,
   eComputerLast = eComputerExpand,

   //
   // Group switches
   //
   eGroupSamname = eTerminator,
   eGroupSID,
   eGroupSecgrp,
   eGroupScope,
   eGroupMemberOf,
   eGroupMembers,
   eGroupExpand,
   eGroupLast = eGroupExpand,

   //
   // OU doesn't have any additional switches
   //

   //
   // Server switches
   //
   eServerDnsName = eTerminator,
   eServerSite,
   eServerIsGC,
   eServerLast = eServerIsGC,

   //
   // Site switches
   //
   eSiteAutoTop = eTerminator,
   eSiteCacheGroups ,
   eSitePrefGC,
   eSiteLast = eSitePrefGC,


   //
   // Subnet switches
   //
   eSubnetLocation = eTerminator,
   eSubnetSite,
   eSubnetLast = eSubnetSite,

/*
   //
   // Site Link switches
   //
   eSLinkIp = eTerminator,
   eSLinkSmtp,
   eSLinkAddsite,
   eSLinkRmsite,
   eSLinkCost,
   eSLinkRepint,
   eSLinkAutobacksync,
   eSLinkNotify,

   //
   // Site Link Bridge switches
   //
   eSLinkBrIp = eTerminator,
   eSLinkBrSmtp,
   eSLinkBrAddslink,
   eSLinkBrRmslink,

   //
   // Replication Connection switches
   // 
   eConnTransport = eTerminator,
   eConnEnabled,
   eConnManual,
   eConnAutobacksync,
   eConnNotify,
*/
};

//
// The parser table
//
extern ARG_RECORD DSGET_COMMON_COMMANDS[];

//
// The table of supported objects
//
extern PDSGetObjectTableEntry g_DSObjectTable[];

#endif //_QUERYTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsget.rc
//
#define IDS_MSG_FAILED_INIT_PATH_INFO   100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\output.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      output.cpp
//
//  Contents:  Defines the functions which displays the query output
//  History:   05-OCT-2000    hiteshr  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "gettable.h"
#include "display.h"
#include "query.h"
#include "resource.h"
#include "stdlib.h"
#include "output.h"


HRESULT LocalCopyString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (wcslen(pString)+1)*sizeof(WCHAR) );

    if ( !*ppResult )
        return E_OUTOFMEMORY;

    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success
}


//+--------------------------------------------------------------------------
//
//  Function:   DisplayList
//
//  Synopsis:   Dispalys a name and value in list format.
//  Arguments:  [szName - IN] : name of the attribute
//              [szValue - IN]: value of the attribute
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
VOID DisplayList(LPCWSTR szName, LPCWSTR szValue)
{
    if(!szName)
        return;
    CComBSTR strTemp;
    strTemp = szName;
    strTemp += L": ";
    if(szValue)
        strTemp += szValue;
    DisplayOutput(strTemp);
}
    
//+--------------------------------------------------------------------------
//
//  Function:   FindAttrInfoForName
//
//  Synopsis:   This function finds the ADS_ATTR_INFO associated with an
//              attribute name
//
//  Arguments:  [pAttrInfo IN]   : Array of ADS_ATTR_INFOs
//              [dwAttrCount IN] : Count of attributes in array
//              [pszAttrName IN] : name of attribute to search for
//                                  
//  Returns:    PADS_ATTR_INFO : pointer to the ADS_ATTR_INFO struct associated
//                               with the attribute name, otherwise NULL
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

PADS_ATTR_INFO FindAttrInfoForName(PADS_ATTR_INFO pAttrInfo,
                                   DWORD dwAttrCount,
                                   PCWSTR pszAttrName)
{
   ENTER_FUNCTION(FULL_LOGGING, FindAttrInfoForName);

   PADS_ATTR_INFO pRetAttrInfo = 0;

   do // false loop
   {
      //
      // Validate Parameters
      //
      if (!pszAttrName)
      {
         ASSERT(pszAttrName);
         break;
      }

      //
      // If pAttrInfo is NULL then there is nothing to retrieve
      // that is acceptable if the value was not set
      //
      if (!pAttrInfo ||
          dwAttrCount == 0)
      {
         break;
      }

      for (DWORD dwIdx = 0; dwIdx < dwAttrCount; dwIdx++)
      {
         if (_wcsicmp(pAttrInfo[dwIdx].pszAttrName, pszAttrName) == 0)
         {
            pRetAttrInfo = &(pAttrInfo[dwIdx]);
            break;
         }
      }
   } while (false);

   return pRetAttrInfo;
}


//+--------------------------------------------------------------------------
//
//  Function:   DsGetOutputValuesList
//
//  Synopsis:   This function gets the values for the columns and then adds
//              the row to the format helper
//
//  Arguments:  [pszDN IN]        : the DN of the object
//              [refBasePathsInfo IN] : reference to path info
//              [refCredentialObject IN] : reference to the credential manager
//              [pCommandArgs IN] : Command line arguments
//              [pObjectEntry IN] : Entry in the object table being processed
//              [dwAttrCount IN]  : Number of arributes in above array
//              [pAttrInfo IN]    : the values to display
//              [spDirObject IN]  : Interface pointer to the object
//              [refFormatInfo IN]: Reference to the format helper
//                                  
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//
//  History:    16-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT DsGetOutputValuesList(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& refBasePathsInfo,
                              const CDSCmdCredentialObject& refCredentialObject,
                              PARG_RECORD pCommandArgs,
                              PDSGetObjectTableEntry pObjectEntry,
                              DWORD dwAttrCount,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& spDirObject,
                              CFormatInfo& refFormatInfo)
{    
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, DsGetOutputValuesList, hr);

   do // false loop
   {
      if(!pszDN ||
         !pCommandArgs ||
         !pObjectEntry)
      {
         ASSERT(pszDN);
         ASSERT(pCommandArgs);
         ASSERT(pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }


      DWORD dwDisplayInfoArraySize = pObjectEntry->dwAttributeCount;
      if (pCommandArgs[eCommDN].bDefined)
      {
         dwDisplayInfoArraySize++;
      }

      PDSGET_DISPLAY_INFO pDisplayInfoArray = new CDSGetDisplayInfo[dwDisplayInfoArraySize];
      if (!pDisplayInfoArray)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      DWORD dwDisplayCount = 0;
      if (pCommandArgs[eCommDN].bDefined)
      {
         // JonN 5/10/01 256583 output DSCMD-escaped DN
         CComBSTR sbstrOutputDN;
         hr = GetOutputDN( &sbstrOutputDN, pszDN );
         if (FAILED(hr))
         {
             ASSERT(FALSE);
             break;
         }

         pDisplayInfoArray[dwDisplayCount].SetDisplayName(g_pszArg1UserDN);
         pDisplayInfoArray[dwDisplayCount].AddValue(sbstrOutputDN);
         dwDisplayCount++;
      }

      //
      // Loop through the attributes getting their display values
      //
      for(DWORD i = 0; i < pObjectEntry->dwAttributeCount; i++)
      {
         if (pObjectEntry->pAttributeTable[i])
         {
            UINT nCommandEntry = pObjectEntry->pAttributeTable[i]->nAttributeID;
            if (pCommandArgs[nCommandEntry].bDefined &&
                pObjectEntry->pAttributeTable[i]->pDisplayStringFunc)
            {
               //
               // Find the ADS_ATTR_INFO structure associated with this attribute
               //
               PADS_ATTR_INFO pAttrInfoDisplay = NULL;
               if (pObjectEntry->pAttributeTable[i]->pszName)
               {
                  pAttrInfoDisplay = FindAttrInfoForName(pAttrInfo,
                                                         dwAttrCount,
                                                         pObjectEntry->pAttributeTable[i]->pszName);
               }

               //
               // Fill in the column header even if there isn't a value
               //
               pDisplayInfoArray[dwDisplayCount].SetDisplayName(pCommandArgs[nCommandEntry].strArg1);

               //
               // Format the output strings
               // Note: this could actually involve some operation if the value isn't
               // retrieved by GetObjectAttributes (ie Can change password)
               //
               hr = pObjectEntry->pAttributeTable[i]->pDisplayStringFunc(pszDN,
                                                                         refBasePathsInfo,
                                                                         refCredentialObject,
                                                                         pObjectEntry,
                                                                         pCommandArgs,
                                                                         pAttrInfoDisplay,
                                                                         spDirObject,
                                                                         &(pDisplayInfoArray[dwDisplayCount]));
               if (FAILED(hr))
               {
                  DEBUG_OUTPUT(LEVEL5_LOGGING, 
                               L"Failed display string func for %s: hr = 0x%x",
                               pObjectEntry->pAttributeTable[i]->pszName,
                               hr);
               }
               dwDisplayCount++;
            }
         }
      }


      DEBUG_OUTPUT(FULL_LOGGING, L"Attributes returned with values:");

#ifdef DBG
      for (DWORD dwIdx = 0; dwIdx < dwDisplayCount; dwIdx++)
      {
         for (DWORD dwValue = 0; dwValue < pDisplayInfoArray[dwIdx].GetValueCount(); dwValue++)
         {
            if (pDisplayInfoArray[dwIdx].GetDisplayName() &&
                pDisplayInfoArray[dwIdx].GetValue(dwValue))
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"\t%s = %s", 
                            pDisplayInfoArray[dwIdx].GetDisplayName(),
                            pDisplayInfoArray[dwIdx].GetValue(dwValue));
            }
            else if (pDisplayInfoArray[dwIdx].GetDisplayName() &&
                     !pDisplayInfoArray[dwIdx].GetValue(dwValue))
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"\t%s = ", 
                            pDisplayInfoArray[dwIdx].GetDisplayName());
            }
            else if (!pDisplayInfoArray[dwIdx].GetDisplayName() &&
                     pDisplayInfoArray[dwIdx].GetValue(dwValue))
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"\t??? = %s", 
                            pDisplayInfoArray[dwIdx].GetValue(dwValue));
            }
            else
            {
               DEBUG_OUTPUT(FULL_LOGGING, L"\t??? = ???");
            }
         }
      }
#endif

      hr = refFormatInfo.AddRow(pDisplayInfoArray, dwDisplayCount);

   } while (false);

   return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   GetStringFromADs
//
//  Synopsis:   Converts Value into string depending upon type
//  Arguments:  [pValues - IN]: Value to be converted to string
//              [dwADsType-IN]: ADSTYPE of pValue
//              [pBuffer - OUT]:Output buffer which gets the string 
//              [dwBufferLen-IN]:Size of output buffer
//  Returns     HRESULT         S_OK if Successful
//                              E_INVALIDARG
//                              Anything else is a failure code from an ADSI 
//                              call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetStringFromADs(IN const ADSVALUE *pValues,
                         IN ADSTYPE   dwADsType,
                         OUT LPWSTR pBuffer, 
                         IN DWORD dwBufferLen)
{
    if(!pValues || !pBuffer || !dwBufferLen)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    pBuffer[0] = 0;
    if( dwADsType == ADSTYPE_INVALID )
    {
        return E_INVALIDARG;
    }

        switch( dwADsType ) 
        {
        case ADSTYPE_DN_STRING : 
            {
                CComBSTR sbstrOutputDN;
                HRESULT hr = GetOutputDN( &sbstrOutputDN, pValues->DNString );
                if (FAILED(hr))
                    return hr;
                wcsncpy(pBuffer, (BSTR)sbstrOutputDN, dwBufferLen-1);
            }
            break;

        case ADSTYPE_CASE_EXACT_STRING :
                    wcsncpy(pBuffer ,pValues->CaseExactString, dwBufferLen-1);
                        break;

        case ADSTYPE_CASE_IGNORE_STRING:
                    wcsncpy(pBuffer ,pValues->CaseIgnoreString, dwBufferLen-1);
                        break;

        case ADSTYPE_PRINTABLE_STRING  :
            wcsncpy(pBuffer ,pValues->PrintableString, dwBufferLen-1);
                        break;

        case ADSTYPE_NUMERIC_STRING    :
                    wcsncpy(pBuffer ,pValues->NumericString, dwBufferLen-1);
                        break;
    
        case ADSTYPE_OBJECT_CLASS    :
                    wcsncpy(pBuffer ,pValues->ClassName, dwBufferLen-1);
                        break;
    
        case ADSTYPE_BOOLEAN :
            wsprintf(pBuffer ,L"%s", ((DWORD)pValues->Boolean) ? L"TRUE" : L"FALSE");
                        break;
    
        case ADSTYPE_INTEGER           :
                    wsprintf(pBuffer ,L"%d", (DWORD) pValues->Integer);
                        break;
    
        case ADSTYPE_OCTET_STRING      :
                {               
                    BYTE  b;
            WCHAR sOctet[128];
            DWORD dwLen = 0;
                        for ( DWORD idx=0; idx<pValues->OctetString.dwLength; idx++) 
                        {                        
                            b = ((BYTE *)pValues->OctetString.lpValue)[idx];
                                wsprintf(sOctet,L"0x%02x ", b);                                                         
                dwLen += static_cast<DWORD>(wcslen(sOctet));
                if(dwLen > (dwBufferLen - 1) )
                    break;
                else
                    wcscat(pBuffer,sOctet);
            }
        }
                break;
    
                case ADSTYPE_LARGE_INTEGER :     
        {
            CComBSTR strLarge;   
            LARGE_INTEGER li = pValues->LargeInteger;
                    litow(li, strLarge);
            wcsncpy(pBuffer,strLarge,dwBufferLen-1);
        }
                break;
    
                case ADSTYPE_UTC_TIME          :
                    wsprintf(pBuffer,
                                        L"%02d/%02d/%04d %02d:%02d:%02d", pValues->UTCTime.wMonth, pValues->UTCTime.wDay, pValues->UTCTime.wYear,
                                         pValues->UTCTime.wHour, pValues->UTCTime.wMinute, pValues->UTCTime.wSecond 
                                        );
            break;

        case ADSTYPE_NT_SECURITY_DESCRIPTOR: // I use the ACLEditor instead
		{
         //ISSUE:2000/01/05-hiteshr
         //I am not sure what to do with the NT_SECURITY_DESCRIPTOR and also
         //with someother datatypes not coverd by dsquery.
   		}
        break;

                default :
                    break;
    }
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CFormatInfo::CFormatInfo
//
//  Synopsis:   Constructor for the format info class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CFormatInfo::CFormatInfo()
   : m_bInitialized(false),
     m_bListFormat(false),
     m_bQuiet(false),
     m_dwSampleSize(0),
     m_dwTotalRows(0),
     m_dwNumColumns(0),
     m_pColWidth(NULL),
     m_ppDisplayInfoArray(NULL)
{};

//+--------------------------------------------------------------------------
//
//  Member:     CFormatInfo::~CFormatInfo
//
//  Synopsis:   Destructor for the format info class
//
//  Arguments:  
//
//  Returns:    
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CFormatInfo::~CFormatInfo()
{        
   if (m_pColWidth)
   {
      delete[] m_pColWidth;
      m_pColWidth = NULL;
   }

   if (m_ppDisplayInfoArray)
   {
      delete[] m_ppDisplayInfoArray;
      m_ppDisplayInfoArray = NULL;
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CFormatInfo::Initialize
//
//  Synopsis:   Initializes the CFormatInfo object with the data
//
//  Arguments:  [dwSamplesSize IN] : Number of rows to use for formatting info
//              [bShowAsList IN]   : Display should be in list or table format
//              [bQuiet IN]        : Don't display anything to stdout
//
//  Returns:    HRESULT : S_OK if everything succeeded    
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CFormatInfo::Initialize(DWORD dwSampleSize, 
                                bool bShowAsList,
                                bool bQuiet)
{
   ENTER_FUNCTION_HR(LEVEL8_LOGGING, CFormatInfo::Initialize, hr);

   do // false loop
   {
      //
      // Validate Parameters
      //
      if(!dwSampleSize)
      {
         ASSERT(dwSampleSize);
         hr = E_INVALIDARG;
         break;
      }
        
      m_dwSampleSize = dwSampleSize; 
      m_bListFormat = bShowAsList;
      m_bQuiet = bQuiet;

      //
      // Allocate the array of rows
      //
      m_ppDisplayInfoArray = new PDSGET_DISPLAY_INFO[m_dwSampleSize];
      if (!m_ppDisplayInfoArray)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      memset(m_ppDisplayInfoArray, 0, sizeof(m_ppDisplayInfoArray));

      //
      // We are now initialized
      //
      m_bInitialized = true;                      
   } while (false);

   return hr;
};

                 
//+--------------------------------------------------------------------------
//
//  Member:     CFormatInfo::AddRow
//
//  Synopsis:   Cache and update the columns for specified row
//
//  Arguments:  [pDisplayInfoArray IN] : Column headers and values
//              [dwColumnCount IN]     : Number of columns
//
//  Returns:    HRESULT : S_OK if everything succeeded    
//
//  History:    17-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CFormatInfo::AddRow(PDSGET_DISPLAY_INFO pDisplayInfo,
                            DWORD dwColumnCount)
{
   ENTER_FUNCTION_HR(LEVEL5_LOGGING, CFormatInfo::AddRow, hr);

   do // false loop
   {
      //
      // Make sure we have been initialized
      //
      if (!m_bInitialized)
      {
         DEBUG_OUTPUT(MINIMAL_LOGGING, L"CFormatInfo::Initialize has not been called yet!");
         ASSERT(m_bInitialized);
         hr = E_FAIL;
         break;
      }

      //
      // Verify parameters
      //
      if (!pDisplayInfo)
      {
         ASSERT(pDisplayInfo);
         hr = E_INVALIDARG;
         break;
      }

      if (m_bListFormat)
      {
         //
         // No reason to cache for the list format just output all the name/value pairs
         //
         for (DWORD dwIdx = 0; dwIdx < dwColumnCount; dwIdx++)
         {
            if (pDisplayInfo[dwIdx].GetValueCount())
            {
               for (DWORD dwValue = 0; dwValue < pDisplayInfo[dwIdx].GetValueCount(); dwValue++)
               {
                  DisplayList(pDisplayInfo[dwIdx].GetDisplayName(),
                              pDisplayInfo[dwIdx].GetValue(dwValue));
               }
            }
            else
            {
               DisplayList(pDisplayInfo[dwIdx].GetDisplayName(),
                           NULL);
            }
         }
         NewLine();
      }
      else // table format
      {
         //
         // Set the row in the array
         //
         m_ppDisplayInfoArray[m_dwTotalRows] = pDisplayInfo;

         //
         // If this is the first row, update the column count
         // and allocate the column widths array
         //
         if (m_dwTotalRows == 0)
         {
            DEBUG_OUTPUT(LEVEL8_LOGGING, 
                         L"Initializing column count to %d",
                         dwColumnCount);

            m_dwNumColumns = dwColumnCount;

            m_pColWidth = new DWORD[m_dwNumColumns];
            if (!m_pColWidth)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

            memset(m_pColWidth, 0, sizeof(m_pColWidth));

            //
            // Set the initial column widths from the column headers
            //
            for (DWORD dwIdx = 0; dwIdx < m_dwNumColumns; dwIdx++)
            {
               if (pDisplayInfo[dwIdx].GetDisplayName())
               {
                  m_pColWidth[dwIdx] = static_cast<DWORD>(wcslen(pDisplayInfo[dwIdx].GetDisplayName()));
               }
               else
               {
                  ASSERT(false);
                  DEBUG_OUTPUT(MINIMAL_LOGGING, L"The display name for column %d wasn't set!", dwIdx);
               }
            }

         }
         else
         {
            if (m_dwNumColumns != dwColumnCount)
            {
               DEBUG_OUTPUT(MINIMAL_LOGGING, 
                            L"Column count of new row (%d) does not equal the current column count (%d)",
                            dwColumnCount,
                            m_dwNumColumns);
               ASSERT(m_dwNumColumns == dwColumnCount);
            }
         }

         //
         // Go through the columns and update the widths if necessary
         //
         for (DWORD dwIdx = 0; dwIdx < m_dwNumColumns; dwIdx++)
         {
            for (DWORD dwValue = 0; dwValue < pDisplayInfo[dwIdx].GetValueCount(); dwValue++)
            {
               if (pDisplayInfo[dwIdx].GetValue(dwValue))
               {
                  size_t sColWidth = wcslen(pDisplayInfo[dwIdx].GetValue(dwValue));
                  m_pColWidth[dwIdx] = (DWORD)__max(sColWidth, m_pColWidth[dwIdx]);
               }
            }
         }

         //
         // Increment the row count
         //
         m_dwTotalRows++;
      }
   } while (false);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\display.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      display.h
//
//  Contents:  Defines the functions used to convert values to strings
//             for display purposes
//
//  History:   17-Oct-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

//
// All these functions are of type PGETDISPLAYSTRINGFUNC as defined in
// gettable.h
//

HRESULT CommonDisplayStringFunc(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& spDirObject,
                                PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayCanChangePassword(PCWSTR pszDN,
                                 CDSCmdBasePathsInfo& refBasePathsInfo,
                                 const CDSCmdCredentialObject& refCredentialObject,
                                 _DSGetObjectTableEntry* pEntry,
                                 ARG_RECORD* pRecord,
                                 PADS_ATTR_INFO pAttrInfo,
                                 CComPtr<IDirectoryObject>& spDirObject,
                                 PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayMustChangePassword(PCWSTR pszDN,
                                  CDSCmdBasePathsInfo& refBasePathsInfo,
                                  const CDSCmdCredentialObject& refCredentialObject,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& spDirObject,
                                  PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayAccountDisabled(PCWSTR pszDN,
                               CDSCmdBasePathsInfo& refBasePathsInfo,
                               const CDSCmdCredentialObject& refCredentialObject,
                               _DSGetObjectTableEntry* pEntry,
                               ARG_RECORD* pRecord,
                               PADS_ATTR_INFO pAttrInfo,
                               CComPtr<IDirectoryObject>& spDirObject,
                               PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayPasswordNeverExpires(PCWSTR pszDN,
                                    CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& spDirObject,
                                    PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayReversiblePassword(PCWSTR pszDN,
                                  CDSCmdBasePathsInfo& refBasePathsInfo,
                                  const CDSCmdCredentialObject& refCredentialObject,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& spDirObject,
                                  PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayAccountExpires(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& refBasePathsInfo,
                              const CDSCmdCredentialObject& refCredentialObject,
                              _DSGetObjectTableEntry* pEntry,
                              ARG_RECORD* pRecord,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& spDirObject,
                              PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGroupScope(PCWSTR pszDN,
                          CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          _DSGetObjectTableEntry* pEntry,
                          ARG_RECORD* pRecord,
                          PADS_ATTR_INFO pAttrInfo,
                          CComPtr<IDirectoryObject>& spDirObject,
                          PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGroupSecurityEnabled(PCWSTR pszDN,
                                    CDSCmdBasePathsInfo& refBasePathsInfo,
                                    const CDSCmdCredentialObject& refCredentialObject,
                                    _DSGetObjectTableEntry* pEntry,
                                    ARG_RECORD* pRecord,
                                    PADS_ATTR_INFO pAttrInfo,
                                    CComPtr<IDirectoryObject>& spDirObject,
                                    PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayUserMemberOf(PCWSTR pszDN,
                            CDSCmdBasePathsInfo& refBasePathsInfo,
                            const CDSCmdCredentialObject& refCredentialObject,
                            _DSGetObjectTableEntry* pEntry,
                            ARG_RECORD* pRecord,
                            PADS_ATTR_INFO pAttrInfo,
                            CComPtr<IDirectoryObject>& spDirObject,
                            PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayComputerMemberOf(PCWSTR pszDN,
                                CDSCmdBasePathsInfo& refBasePathsInfo,
                                const CDSCmdCredentialObject& refCredentialObject,
                                _DSGetObjectTableEntry* pEntry,
                                ARG_RECORD* pRecord,
                                PADS_ATTR_INFO pAttrInfo,
                                CComPtr<IDirectoryObject>& /*spDirObject*/,
                                PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGroupMemberOf(PCWSTR pszDN,
                             CDSCmdBasePathsInfo& refBasePathsInfo,
                             const CDSCmdCredentialObject& refCredentialObject,
                             _DSGetObjectTableEntry* pEntry,
                             ARG_RECORD* pRecord,
                             PADS_ATTR_INFO pAttrInfo,
                             CComPtr<IDirectoryObject>& spDirObject,
                             PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayGrandparentRDN(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& refBasePathsInfo,
                              const CDSCmdCredentialObject& refCredentialObject,
                              _DSGetObjectTableEntry* pEntry,
                              ARG_RECORD* pRecord,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& spDirObject,
                              PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT IsServerGCDisplay(PCWSTR pszDN,
                          CDSCmdBasePathsInfo& refBasePathsInfo,
                          const CDSCmdCredentialObject& refCredentialObject,
                          _DSGetObjectTableEntry* pEntry,
                          ARG_RECORD* pRecord,
                          PADS_ATTR_INFO pAttrInfo,
                          CComPtr<IDirectoryObject>& spDirObject,
                          PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT IsAutotopologyEnabledSite(PCWSTR pszDN,
                                  CDSCmdBasePathsInfo& refBasePathsInfo,
                                  const CDSCmdCredentialObject& refCredentialObject,
                                  _DSGetObjectTableEntry* pEntry,
                                  ARG_RECORD* pRecord,
                                  PADS_ATTR_INFO pAttrInfo,
                                  CComPtr<IDirectoryObject>& spDirObject,
                                  PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT IsCacheGroupsEnabledSite(PCWSTR pszDN,
                                 CDSCmdBasePathsInfo& refBasePathsInfo,
                                 const CDSCmdCredentialObject& refCredentialObject,
                                 _DSGetObjectTableEntry* pEntry,
                                 ARG_RECORD* pRecord,
                                 PADS_ATTR_INFO pAttrInfo,
                                 CComPtr<IDirectoryObject>& spDirObject,
                                 PDSGET_DISPLAY_INFO pDisplayInfo);

HRESULT DisplayPreferredGC(PCWSTR pszDN,
                           CDSCmdBasePathsInfo& refBasePathsInfo,
                           const CDSCmdCredentialObject& refCredentialObject,
                           _DSGetObjectTableEntry* pEntry,
                           ARG_RECORD* pRecord,
                           PADS_ATTR_INFO pAttrInfo,
                           CComPtr<IDirectoryObject>& spDirObject,
                           PDSGET_DISPLAY_INFO pDisplayInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmod\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

//
// The command line executable name
//
PCWSTR g_pszDSCommandName           = L"dsmod";

//
// Object types as are typed on the command line
//
PCWSTR g_pszOU                      = L"ou";
PCWSTR g_pszUser                    = L"user";
PCWSTR g_pszContact                 = L"contact";
PCWSTR g_pszComputer                = L"computer";
PCWSTR g_pszGroup                   = L"group";
PCWSTR g_pszServer                  = L"server";

//
// Common switches
//
PCWSTR c_sz_arg1_com_debug          = L"debug";
PCWSTR c_sz_arg1_com_help           = L"h";
PCWSTR c_sz_arg2_com_help           = L"?";
PCWSTR c_sz_arg1_com_server         = L"s";
PCWSTR c_sz_arg2_com_server         = L"server";
PCWSTR c_sz_arg1_com_domain         = L"d";
PCWSTR c_sz_arg2_com_domain         = L"domain";
PCWSTR c_sz_arg1_com_username       = L"u";
PCWSTR c_sz_arg2_com_username       = L"username";
PCWSTR c_sz_arg1_com_password       = L"p";
PCWSTR c_sz_arg2_com_password       = L"password";
PCWSTR c_sz_arg1_com_quiet          = L"q";
PCWSTR c_sz_arg1_com_continue       = L"c";
PCWSTR c_sz_arg1_com_description    = L"desc";
PCWSTR c_sz_arg1_com_objecttype     = L"objecttype";
PCWSTR c_sz_arg1_com_objectDN       = L"Target object for this command";

//
// User and Contact switches
//
PCWSTR g_pszArg1UserUPN             = L"upn"; 
PCWSTR g_pszArg1UserFirstName       = L"fn";
PCWSTR g_pszArg1UserMiddleInitial   = L"mi";
PCWSTR g_pszArg1UserLastName        = L"ln";
PCWSTR g_pszArg1UserDisplayName     = L"display";
PCWSTR g_pszArg1UserEmpID           = L"empid";
PCWSTR g_pszArg1UserPassword        = L"pwd";
PCWSTR g_pszArg1UserOffice          = L"office";
PCWSTR g_pszArg1UserTelephone       = L"tel"; 
PCWSTR g_pszArg1UserEmail           = L"email";
PCWSTR g_pszArg1UserHomeTelephone   = L"hometel";
PCWSTR g_pszArg1UserPagerNumber     = L"pager"; 
PCWSTR g_pszArg1UserMobileNumber    = L"mobile"; 
PCWSTR g_pszArg1UserFaxNumber       = L"fax";
PCWSTR g_pszArg1UserIPTel           = L"iptel";
PCWSTR g_pszArg1UserWebPage         = L"webpg";
PCWSTR g_pszArg1UserTitle           = L"title";
PCWSTR g_pszArg1UserDepartment      = L"dept"; 
PCWSTR g_pszArg1UserCompany         = L"company";
PCWSTR g_pszArg1UserManager         = L"mgr";
PCWSTR g_pszArg1UserHomeDirectory   = L"hmdir";
PCWSTR g_pszArg1UserHomeDrive       = L"hmdrv";
PCWSTR g_pszArg1UserProfilePath     = L"profile";
PCWSTR g_pszArg1UserScriptPath      = L"loscr";
PCWSTR g_pszArg1UserMustChangePwd   = L"mustchpwd";
PCWSTR g_pszArg1UserCanChangePwd    = L"canchpwd";
PCWSTR g_pszArg1UserReversiblePwd   = L"reversiblepwd";
PCWSTR g_pszArg1UserPwdNeverExpires = L"pwdneverexpires";
PCWSTR g_pszArg1UserAccountExpires  = L"acctexpires";
PCWSTR g_pszArg1UserDisableAccount  = L"disabled";

//
// Computer switches
//
PCWSTR g_pszArg1ComputerLocation    = L"loc";
PCWSTR g_pszArg1ComputerDisabled    = L"disabled";
PCWSTR g_pszArg1ComputerReset       = L"reset";

//
// Group switches
//
PCWSTR g_pszArg1GroupSAMName        = L"samid";
PCWSTR g_pszArg1GroupSec            = L"secgrp";
PCWSTR g_pszArg1GroupScope          = L"scope";
PCWSTR g_pszArg1GroupAddMember      = L"addmbr";
PCWSTR g_pszArg1GroupRemoveMember   = L"rmmbr";
PCWSTR g_pszArg1GroupChangeMember   = L"chmbr";

//
// Server switches
//
PCWSTR g_pszArg1ServerIsGC          = L"isgc";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsget\output.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      output.h
//
//  Contents:  Header file for classes and function used for display
//
//  History:   3-oct-2000 hiteshr Created
//
//--------------------------------------------------------------------------

#include "gettable.h"

HRESULT LocalCopyString(LPTSTR* ppResult, LPCTSTR pString);

//+--------------------------------------------------------------------------
//
//  Class:      CDisplay
//
//  Purpose:    This class is used for displaying a column
//
//  History:    3-oct-2000 hiteshr Created
//
//---------------------------------------------------------------------------

class CDisplay
{
#define MAXPAD 80
public:

    //
    //Initialize the Pad
    //    
    CDisplay()
    {
        PadChar = L' ';
        //Initialize the pad.
        for( int i = 0; i < MAXPAD; ++i)
            Pad[i] = PadChar;
    }

    //
    //Display width number of Pad Charachter
    //
    VOID DisplayPad(LONG width)
    {
        if(width <= 0 )
            return;
        if(width >= MAXPAD)
            width = MAXPAD -1;
        Pad[width] = 0;

        WriteStandardOut(L"%s",Pad);

        Pad[width] = PadChar;
    }
        
    //
    //Dispaly a column with two starting pad,
    //column value and two ending pad
    //
    VOID DisplayColumn(LONG width, PCWSTR lpszValue)
    {
        //Display Two PadChar in the begining
        DisplayPad(2);
        if(lpszValue)
        {
            WriteStandardOut(lpszValue);
            DisplayPad(width- static_cast<LONG>(wcslen(lpszValue)));
        }
        else
            DisplayPad(width);

                
        //Display Two Trailing Padchar
        DisplayPad(2);
    }        
    
    //
    //Display Newline
    //    
    VOID DisplayNewLine()
    {
        WriteStandardOut(L"%s",L"\n");
    }
private:
    WCHAR Pad[MAXPAD];    
    WCHAR PadChar;

};

//+--------------------------------------------------------------------------
//
//  Class:      CFormatInfo
//
//  Purpose:    Used to format table columns and display table
//
//  History:    17-Oct-2000 JeffJon Created
//
//---------------------------------------------------------------------------
class CFormatInfo
{
public:
   //
   // Constructor
   //
   CFormatInfo();

   //
   // Destructor
   //
   ~CFormatInfo();


   //
   // Public methods
   //
   HRESULT Initialize(DWORD dwSampleSize, bool bShowAsList = false, bool bQuiet = false);
                 
   inline DWORD GetColWidth(DWORD dwColNum)
   { 
      ASSERT(m_bInitialized);
      if(dwColNum >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return 0;
      }
      return m_pColWidth[dwColNum]; 
   }

   inline void SetColWidth(DWORD dwColNum, DWORD dwWidth)
   {
      ASSERT(m_bInitialized);
      if(dwColNum >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return;
      }

      if(dwWidth > m_pColWidth[dwColNum])
      {
         m_pColWidth[dwColNum] = dwWidth;
      }
   }

   HRESULT AddRow(PDSGET_DISPLAY_INFO pDisplayInfo, DWORD dwColumnCount);
   DWORD   GetRowCount() { return m_dwTotalRows; }
    
   inline HRESULT Get(DWORD dwRow, DWORD dwCol, CComBSTR& refsbstrColValue)
   {
      refsbstrColValue.Empty();

      ASSERT(m_bInitialized);
      if(dwRow >= m_dwTotalRows || dwCol >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return E_INVALIDARG;
      }

      refsbstrColValue += m_ppDisplayInfoArray[dwRow][dwCol].GetValue(0);
      for (DWORD dwIdx = 1; dwIdx < m_ppDisplayInfoArray[dwRow][dwCol].GetValueCount(); dwIdx++)
      {
         refsbstrColValue += L";";
         refsbstrColValue += m_ppDisplayInfoArray[dwRow][dwCol].GetValue(dwIdx);
      }

      return S_OK;
   }

   void DisplayHeaders()
   {    
      ASSERT(m_bInitialized);
      if (!m_bQuiet)
      {
         for( DWORD i = 0; i < m_dwNumColumns; ++i)
         {
            m_display.DisplayColumn(GetColWidth(i),m_ppDisplayInfoArray[0][i].GetDisplayName());
         }
         NewLine();
      }
   }

   void DisplayColumn(DWORD dwRow, DWORD dwCol)
   {
      ASSERT(m_bInitialized);
      if(dwRow >= m_dwTotalRows || dwCol >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return ;
      }

      if (!m_bQuiet)
      {
         CComBSTR sbstrValue;
         HRESULT hr  = Get(dwRow, dwCol, sbstrValue);
         if (SUCCEEDED(hr))
         {
            m_display.DisplayColumn(GetColWidth(dwCol), sbstrValue);
         }
      }
   }

   void DisplayColumn(DWORD dwCol, PCWSTR pszValue)
   {
      ASSERT(m_bInitialized);
      if(dwCol >= m_dwNumColumns)
      {
         ASSERT(FALSE);
         return;
      }

      if (!m_bQuiet)
      {
         m_display.DisplayColumn(GetColWidth(dwCol), pszValue);
      }
   }

   void Display()
   {
      ASSERT(m_bInitialized);

      if (!m_bListFormat && !m_bQuiet)
      {
         DisplayHeaders();
         for(DWORD i = 0; i < m_dwTotalRows; ++i)
         {
            for(DWORD j = 0; j < m_dwNumColumns; ++j)
            {
               DisplayColumn(i,j);
            }
            NewLine();
         }
      }
   }

   void NewLine() 
   {
      if (!m_bQuiet)
      {
         m_display.DisplayNewLine(); 
      }
   }
   
private:

   //
   // Private data
   //
   bool m_bInitialized;
   bool m_bListFormat;
   bool m_bQuiet;

   //
   //Number of rows to be used for calulating
   //column width. This is also the size of the table.
   //
   DWORD m_dwSampleSize;

   //
   //Count of rows in cache
   //
   DWORD m_dwTotalRows;

   //
   //Number of columns
   //
   DWORD m_dwNumColumns;

   //
   // Array of column widths
   //
   DWORD* m_pColWidth;

   //
   // Array of column header/value pairs
   //
   PDSGET_DISPLAY_INFO* m_ppDisplayInfoArray;

   CDisplay m_display;
};

//+--------------------------------------------------------------------------
//
//  Function:   DsGetOutputValuesList
//
//  Synopsis:   This function gets the values for the columns and then adds
//              the row to the format helper
//
//  Arguments:  [pszDN IN]        : the DN of the object
//              [refBasePathsInfo IN] : reference to path info
//              [refCredentialObject IN] : reference to the credential manager
//              [pCommandArgs IN] : Command line arguments
//              [pObjectEntry IN] : Entry in the object table being processed
//              [pAttrInfo IN]    : the values to display
//              [dwAttrCount IN]  : Number of arributes in above array
//              [spDirObject IN]  : Interface pointer to the object
//              [refFormatInfo IN]: Reference to the format helper
//                                  
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//
//  History:    16-Oct-2000   JeffJon   Created
//
//---------------------------------------------------------------------------

HRESULT DsGetOutputValuesList(PCWSTR pszDN,
                              CDSCmdBasePathsInfo& refBasePathsInfo,
                              const CDSCmdCredentialObject& refCredentialObject,
                              PARG_RECORD pCommandArgs,
                              PDSGetObjectTableEntry pObjectEntry,
                              DWORD dwAttrCount,
                              PADS_ATTR_INFO pAttrInfo,
                              CComPtr<IDirectoryObject>& spDirObject,
                              CFormatInfo& refFormatInfo);

//+--------------------------------------------------------------------------
//
//  Function:   GetStringFromADs
//
//  Synopsis:   Converts Value into string depending upon type
//  Arguments:  [pValues - IN]: Value to be converted to string
//              [dwADsType-IN]: ADSTYPE of pValue
//              [pBuffer - OUT]:Output buffer which gets the string 
//              [dwBufferLen-IN]:Size of output buffer
//  Returns     HRESULT         S_OK if Successful
//                              E_INVALIDARG
//                              Anything else is a failure code from an ADSI 
//                              call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetStringFromADs(IN const ADSVALUE *pValues,
                         IN ADSTYPE   dwADsType,
                         OUT LPWSTR pBuffer, 
                         IN DWORD dwBufferLen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmod\modtable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.cpp
//
//  Contents:  Defines a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "modtable.h"
#include "usage.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------

ARG_RECORD DSMOD_COMMON_COMMANDS[] = 
{
#ifdef DBG
   //
   // -debug, -debug
   //
   0,(LPWSTR)c_sz_arg1_com_debug, 
   ID_ARG2_NULL,NULL,
   ARG_TYPE_DEBUG, ARG_FLAG_OPTIONAL|ARG_FLAG_HIDDEN,  
   (CMD_TYPE)0,     
   0,  NULL,
#endif

   //
   // h, ?
   //
   0,(LPWSTR)c_sz_arg1_com_help, 
   0,(LPWSTR)c_sz_arg2_com_help, 
   ARG_TYPE_HELP, ARG_FLAG_OPTIONAL,  
   (CMD_TYPE)FALSE,     
   0,  NULL,

   //
   // s,server
   //
   0,(LPWSTR)c_sz_arg1_com_server, 
   0,(LPWSTR)c_sz_arg2_com_server, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // d,domain
   //
   0,(LPWSTR)c_sz_arg1_com_domain, 
   0,(LPWSTR)c_sz_arg2_com_domain, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // u, username    
   //
   0,(LPWSTR)c_sz_arg1_com_username, 
   0,(LPWSTR)c_sz_arg2_com_username, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // w, password
   //
   0,(LPWSTR)c_sz_arg1_com_password, 
   0,(LPWSTR)c_sz_arg2_com_password, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   (CMD_TYPE)_T(""),    
   0,  ValidateAdminPassword,

   //
   // q,q
   //
   0,(LPWSTR)c_sz_arg1_com_quiet, 
   ID_ARG2_NULL,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   (CMD_TYPE)_T(""),    
   0,  NULL,

   //
   // c  Continue
   //
   0,(PWSTR)c_sz_arg1_com_continue,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)_T(""),
   0, NULL,

   //
   // objecttype
   //
   0,(LPWSTR)c_sz_arg1_com_objecttype, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN,  
   0,    
   0,  NULL,

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   ID_ARG2_NULL,NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN|ARG_FLAG_DN,
   0,    
   0,  NULL,

   //
   // description
   //
   0, (PWSTR)c_sz_arg1_com_description,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0, NULL,

   ARG_TERMINATOR
};

ARG_RECORD DSMOD_USER_COMMANDS[]=
{
   //
   // upn
   //
   0, (PWSTR)g_pszArg1UserUPN, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // empid  Employee ID
   //
   0, (PWSTR)g_pszArg1UserEmpID, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // pwd Password
   //
   0, (PWSTR)g_pszArg1UserPassword, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateUserPassword,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // iptel IP Telephone
   //
   0, (PWSTR)g_pszArg1UserIPTel, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // webpg  Web Page
   //
   0, (PWSTR)g_pszArg1UserWebPage, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mgr Manager
   //
   0, (PWSTR)g_pszArg1UserManager, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE|ARG_FLAG_DN,  
   0,    
   0,  NULL,

   //
   // hmdir  Home Directory
   //
   0, (PWSTR)g_pszArg1UserHomeDirectory, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // hmdrv  Home Drive
   //
   0, (PWSTR)g_pszArg1UserHomeDrive, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // profile Profile path
   //
   0, (PWSTR)g_pszArg1UserProfilePath, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // loscr Script path
   //
   0, (PWSTR)g_pszArg1UserScriptPath, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mustchpwd Must Change Password at next logon
   //
   0, (PWSTR)g_pszArg1UserMustChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,

   //
   // canchpwd Can Change Password
   //
   0, (PWSTR)g_pszArg1UserCanChangePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,
   
   //
   // reversiblepwd  Password stored with reversible encryption
   //
   0, (PWSTR)g_pszArg1UserReversiblePwd, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,

   //
   // pwdneverexpires Password never expires
   //
   0, (PWSTR)g_pszArg1UserPwdNeverExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,
 
   //
   // acctexpires Account Expires
   //
   0, (PWSTR)g_pszArg1UserAccountExpires, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_INTSTR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateNever,
  
   //
   // disabled  Disable Account
   //
   0, (PWSTR)g_pszArg1UserDisableAccount, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,

   ARG_TERMINATOR
};

ARG_RECORD DSMOD_COMPUTER_COMMANDS[]=
{
   //
   // loc Location
   //
   0, (PWSTR)g_pszArg1ComputerLocation,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  NULL,

   //
   // disabled
   //
   0, (PWSTR)g_pszArg1ComputerDisabled,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  ValidateYesNo,

   //
   //reset
   //
   0, (PWSTR)g_pszArg1ComputerReset,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   (CMD_TYPE)_T(""),
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSMOD_GROUP_COMMANDS[]=
{
   //
   // samname
   //
   0, (PWSTR)g_pszArg1GroupSAMName,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  NULL,

   //
   // secgrp Security enabled
   //
   0, (PWSTR)g_pszArg1GroupSec,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  ValidateYesNo,

   //
   // scope Group scope (local/global/universal)
   //
   0, (PWSTR)g_pszArg1GroupScope,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,
   0,
   0,  ValidateGroupScope,

   //
   // addmbr  Add a member to the group
   //
   0, (PWSTR)g_pszArg1GroupAddMember,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE|ARG_FLAG_DN,
   0,
   0,  NULL,

   //
   // rmmbr  Remove a member from the group
   //
   0, (PWSTR)g_pszArg1GroupRemoveMember,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE|ARG_FLAG_DN,
   0,
   0,  NULL,

   //
   // chmbr  Change the entire membership list
   //
   0, (PWSTR)g_pszArg1GroupChangeMember,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE|ARG_FLAG_DN,
   0,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSMOD_CONTACT_COMMANDS[]=
{
   //
   // fn. FirstName
   //
   0, (PWSTR)g_pszArg1UserFirstName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mi  Middle Initial
   //
   0, (PWSTR)g_pszArg1UserMiddleInitial, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // ln   LastName
   //
   0, (PWSTR)g_pszArg1UserLastName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // display  DisplayName
   //
   0, (PWSTR)g_pszArg1UserDisplayName, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // office Office Location
   //
   0, (PWSTR)g_pszArg1UserOffice, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // tel Telephone
   //
   0, (PWSTR)g_pszArg1UserTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // email E-mail
   //
   0, (PWSTR)g_pszArg1UserEmail, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // hometel Home Telephone
   //
   0, (PWSTR)g_pszArg1UserHomeTelephone, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // pager Pager number
   //
   0, (PWSTR)g_pszArg1UserPagerNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // mobile Mobile Telephone Number
   //
   0, (PWSTR)g_pszArg1UserMobileNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // fax Fax Number
   //
   0, (PWSTR)g_pszArg1UserFaxNumber, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // title Title
   //
   0, (PWSTR)g_pszArg1UserTitle, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // dept Department
   //
   0, (PWSTR)g_pszArg1UserDepartment, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   //
   // company Company
   //
   0, (PWSTR)g_pszArg1UserCompany, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,

};
/*
ARG_RECORD DSMOD_SUBNET_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SUBNET_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SUBNET_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SUBNET_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //site
    IDS_ARG1_SUBNET_SITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSMOD_SITE_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SITE_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
        ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SITE_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SITE_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autotopology
    IDS_ARG1_SITE_AUTOTOPOLOGY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSMOD_SLINK_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SLINK_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //ip
    IDS_ARG1_SLINK_IP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //smtp
    IDS_ARG1_SLINK_SMTP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SLINK_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //addsite
    IDS_ARG1_SLINK_ADDSITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //rmsite
    IDS_ARG1_SLINK_RMSITE, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //cost
    IDS_ARG1_SLINK_COST, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //repint
    IDS_ARG1_SLINK_REPINT, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SLINK_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autobacksync
    IDS_ARG1_SLINK_AUTOBACKSYNC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //notify
    IDS_ARG1_SLINK_NOTIFY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSMOD_SLINKBR_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_SLINKBR_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //ip
    IDS_ARG1_SLINKBR_IP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //smtp
    IDS_ARG1_SLINKBR_SMTP, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //name
    IDS_ARG1_SLINKBR_NAME, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //addslink
    IDS_ARG1_SLINKBR_ADDSLINK, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //rmslink
    IDS_ARG1_SLINKBR_RMSLINK, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_SLINKBR_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};


ARG_RECORD DSMOD_CONN_COMMANDS[]=
{
    //name_or_objectdn
    IDS_ARG1_CONN_NAME_OR_OBJECTDN, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,
    0,
    0,  NULL,
    //transport
    IDS_ARG1_CONN_TRANSPORT, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //enabled
    IDS_ARG1_CONN_ENABLED, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //desc
    IDS_ARG1_CONN_DESC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //manual
    IDS_ARG1_CONN_MANUAL, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //autobacksync
    IDS_ARG1_CONN_AUTOBACKSYNC, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,
    //notify
    IDS_ARG1_CONN_NOTIFY, NULL,
    ID_ARG2_NULL, NULL,
    ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
    0,
    0,  NULL,

    ARG_TERMINATOR,
};
*/
ARG_RECORD DSMOD_SERVER_COMMANDS[]=
{
   //
   // isGC
   //
   0, (PWSTR)g_pszArg1ServerIsGC, 
   ID_ARG2_NULL, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_ATLEASTONE,  
   0,    
   0,  ValidateYesNo,

   ARG_TERMINATOR
};



//+-------------------------------------------------------------------------
// Attributes
//--------------------------------------------------------------------------

//
// Description
//
DSATTRIBUTEDESCRIPTION description =
{
   {
      L"description",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY descriptionEntry =
{
   L"description",
   eCommDescription,
   0,
   &description,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// UPN
//
DSATTRIBUTEDESCRIPTION upn =
{
   {
      L"userPrincipalName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY upnUserEntry =
{
   L"userPrincipalName",
   eUserUpn,
   0,
   &upn,
   FillAttrInfoFromObjectEntry,
   NULL
};


//
// First name
//
DSATTRIBUTEDESCRIPTION firstName =
{
   {
      L"givenName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY firstNameUserEntry =
{
   L"givenName",
   eUserFn,
   0,
   &firstName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY firstNameContactEntry =
{
   L"givenName",
   eContactFn,
   0,
   &firstName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Middle Initial
//
DSATTRIBUTEDESCRIPTION middleInitial =
{
   {
      L"initials",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY middleInitialUserEntry =
{
   L"initials",
   eUserMi,
   0,
   &middleInitial,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY middleInitialContactEntry =
{
   L"initials",
   eContactMi,
   0,
   &middleInitial,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Last name
//
DSATTRIBUTEDESCRIPTION lastName =
{
   {
      L"sn",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY lastNameUserEntry =
{
   L"sn",
   eUserLn,
   0,
   &lastName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY lastNameContactEntry =
{
   L"sn",
   eContactLn,
   0,
   &lastName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Display name
//
DSATTRIBUTEDESCRIPTION displayName =
{
   {
      L"displayName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY displayNameUserEntry =
{
   L"displayName",
   eUserDisplay,
   0,
   &displayName,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY displayNameContactEntry =
{
   L"displayName",
   eContactDisplay,
   0,
   &displayName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Employee ID
//
DSATTRIBUTEDESCRIPTION employeeID =
{
   {
      L"employeeID",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY employeeIDUserEntry =
{
   L"employeeID",
   eUserEmpID,
   0,
   &employeeID,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Password
//
DSATTRIBUTEDESCRIPTION password =
{
   {
      NULL,
      ADS_ATTR_UPDATE,
      ADSTYPE_INVALID,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY passwordUserEntry =
{
   L"password",
   eUserPwd,
   0,
   &password,
   ResetUserPassword,
   NULL
};

//
// Office
//
DSATTRIBUTEDESCRIPTION office =
{
   {
      L"physicalDeliveryOfficeName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY officeUserEntry =
{
   L"physicalDeliveryOfficeName",
   eUserOffice,
   0,
   &office,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY officeContactEntry =
{
   L"physicalDeliveryOfficeName",
   eContactOffice,
   0,
   &office,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Telephone
//
DSATTRIBUTEDESCRIPTION telephone =
{
   {
      L"telephoneNumber",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY telephoneUserEntry =
{
   L"telephoneNumber",
   eUserTel,
   0,
   &telephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY telephoneContactEntry =
{
   L"telephoneNumber",
   eContactTel,
   0,
   &telephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Email
//
DSATTRIBUTEDESCRIPTION email =
{
   {
      L"mail",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY emailUserEntry =
{
   L"mail",
   eUserEmail,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &email,
   FillAttrInfoFromObjectEntryExpandUsername,
   NULL
};

DSATTRIBUTETABLEENTRY emailContactEntry =
{
   L"mail",
   eContactEmail,
   0,
   &email,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Telephone
//
DSATTRIBUTEDESCRIPTION homeTelephone =
{
   {
      L"homePhone",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeTelephoneUserEntry =
{
   L"homePhone",
   eUserHometel,
   0,
   &homeTelephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY homeTelephoneContactEntry =
{
   L"homePhone",
   eContactHometel,
   0,
   &homeTelephone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Pager
//
DSATTRIBUTEDESCRIPTION pager =
{
   {
      L"pager",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY pagerUserEntry =
{
   L"pager",
   eUserPager,
   0,
   &pager,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY pagerContactEntry =
{
   L"pager",
   eContactPager,
   0,
   &pager,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Mobile phone
//
DSATTRIBUTEDESCRIPTION mobile =
{
   {
      L"mobile",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY mobileUserEntry =
{
   L"mobile",
   eUserMobile,
   0,
   &mobile,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY mobileContactEntry =
{
   L"mobile",
   eContactMobile,
   0,
   &mobile,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Fax
//
DSATTRIBUTEDESCRIPTION fax =
{
   {
      L"facsimileTelephoneNumber",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY faxUserEntry =
{
   L"facsimileTelephoneNumber",
   eUserFax,
   0,
   &fax,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY faxContactEntry =
{
   L"facsimileTelephoneNumber",
   eContactFax,
   0,
   &fax,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Title
//
DSATTRIBUTEDESCRIPTION title =
{
   {
      L"title",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY titleUserEntry =
{
   L"title",
   eUserTitle,
   0,
   &title,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY titleContactEntry =
{
   L"title",
   eContactTitle,
   0,
   &title,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Department
//
DSATTRIBUTEDESCRIPTION department =
{
   {
      L"department",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY departmentUserEntry =
{
   L"department",
   eUserDept,
   0,
   &department,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY departmentContactEntry =
{
   L"department",
   eContactDept,
   0,
   &department,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Company
//
DSATTRIBUTEDESCRIPTION company =
{
   {
      L"company",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY companyUserEntry =
{
   L"company",
   eUserCompany,
   0,
   &company,
   FillAttrInfoFromObjectEntry,
   NULL
};

DSATTRIBUTETABLEENTRY companyContactEntry =
{
   L"company",
   eContactCompany,
   0,
   &company,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Web Page
//
DSATTRIBUTEDESCRIPTION webPage =
{
   {
      L"wwwHomePage",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY webPageUserEntry =
{
   L"wwwHomePage",
   eUserWebPage,
   0,
   &webPage,
   FillAttrInfoFromObjectEntryExpandUsername,
   NULL
};

//
// IP Phone
//
DSATTRIBUTEDESCRIPTION ipPhone =
{
   {
      L"ipPhone",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY ipPhoneUserEntry =
{
   L"ipPhone",
   eUserIPPhone,
   0,
   &ipPhone,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Script Path
//
DSATTRIBUTEDESCRIPTION scriptPath =
{
   {
      L"scriptPath",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY scriptPathUserEntry =
{
   L"scriptPath",
   eUserScriptPath,
   0,
   &scriptPath,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Home Directory
//
DSATTRIBUTEDESCRIPTION homeDirectory =
{
   {
      L"homeDirectory",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeDirectoryUserEntry =
{
   L"homeDirectory",
   eUserHomeDir,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &homeDirectory,
   FillAttrInfoFromObjectEntryExpandUsername,
   NULL
};

//
// Home Drive
//
DSATTRIBUTEDESCRIPTION homeDrive =
{
   {
      L"homeDrive",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY homeDriveUserEntry =
{
   L"homeDrive",
   eUserHomeDrive,
   0,
   &homeDrive,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Profile Path
//
DSATTRIBUTEDESCRIPTION profilePath =
{
   {
      L"profilePath",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY profilePathUserEntry =
{
   L"profilePath",
   eUserProfilePath,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &profilePath,
   FillAttrInfoFromObjectEntryExpandUsername,
   NULL
};

//
// pwdLastSet
//
DSATTRIBUTEDESCRIPTION pwdLastSet =
{
   {
      L"pwdLastSet",
      ADS_ATTR_UPDATE,
      ADSTYPE_LARGE_INTEGER,
      NULL,
      0
   },
   0
};
DSATTRIBUTETABLEENTRY mustChangePwdUserEntry =
{
   L"pwdLastSet",
   eUserMustchpwd,
   DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_POSTCREATE,
   &pwdLastSet,
   ChangeMustChangePwd,
   NULL
};

//
// accountExpires
//
DSATTRIBUTEDESCRIPTION accountExpires =
{
   {
      L"accountExpires",
      ADS_ATTR_UPDATE,
      ADSTYPE_LARGE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY accountExpiresUserEntry =
{
   L"accountExpires",
   eUserAcctexpires,
   0,
   &accountExpires,
   AccountExpires,
   NULL
};

//
// user account control 
//
DSATTRIBUTEDESCRIPTION userAccountControl =
{
   {
      L"userAccountControl",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY disableComputerEntry =
{
   L"userAccountControl",
   eComputerDisabled,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   DisableAccount,
   NULL
};

DSATTRIBUTETABLEENTRY disableUserEntry =
{
   L"userAccountControl",
   eUserDisabled,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   DisableAccount,
   NULL
};

DSATTRIBUTETABLEENTRY pwdNeverExpiresUserEntry =
{
   L"userAccountControl",
   eUserPwdneverexpires,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   PwdNeverExpires,
   NULL
};

DSATTRIBUTETABLEENTRY reverisblePwdUserEntry =
{
   L"userAccountControl",
   eUserReversiblePwd,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &userAccountControl,
   ReversiblePwd,
   NULL
};

//
// SAM Account Name
//
DSATTRIBUTEDESCRIPTION samAccountName =
{
   {
      L"sAMAccountName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY samNameGroupEntry =
{
   L"sAMAccountName",
   eGroupSamname,
   0,
   &samAccountName,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Manager
//
DSATTRIBUTEDESCRIPTION manager =
{
   {
      L"manager",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY managerUserEntry =
{
   L"manager",
   eUserManager,
   0,
   &manager,
   FillAttrInfoFromObjectEntry,
   NULL
};

//
// Group Type
//
DSATTRIBUTEDESCRIPTION groupType =
{
   {
      L"groupType",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupScopeTypeEntry =
{
   L"groupType",
   eGroupScope,
   0,
   &groupType,
   ChangeGroupScope,
   NULL
};

DSATTRIBUTETABLEENTRY groupSecurityTypeEntry =
{
   L"groupType",
   eGroupSecgrp,
   0,
   &groupType,
   ChangeGroupSecurity,
   NULL
};

//
// Add Group Members
//
DSATTRIBUTEDESCRIPTION groupAddMember =
{
   {
      L"member",
      ADS_ATTR_APPEND,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupAddMemberEntry =
{
   L"member",
   eGroupAddMember,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &groupAddMember,
   ModifyGroupMembers,
   NULL
};

//
// Remove Group Members
//
DSATTRIBUTEDESCRIPTION groupRemoveMember =
{
   {
      L"member",
      ADS_ATTR_UPDATE,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupRemoveMemberEntry =
{
   L"member",
   eGroupRemoveMember,
   DS_ATTRIBUTE_NOT_REUSABLE,
   &groupRemoveMember,
   RemoveGroupMembers,
   NULL
};

//
// Change Group Members
//
DSATTRIBUTEDESCRIPTION groupChangeMember =
{
   {
      L"member",
      ADS_ATTR_UPDATE,
      ADSTYPE_DN_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY groupChangeMemberEntry =
{
   L"member",
   eGroupChangeMember,
   0,
   &groupChangeMember,
   ModifyGroupMembers,
   NULL
};

// Location
//
DSATTRIBUTEDESCRIPTION location =
{
   {
      L"location",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY locationComputerEntry =
{
   L"location",
   eComputerLocation,
   DS_ATTRIBUTE_ONCREATE,
   &location,
   FillAttrInfoFromObjectEntry,
   NULL
};


//
// Reset Computer account
//
DSATTRIBUTETABLEENTRY resetComputerEntry =
{
   NULL,
   eComputerReset,
   DS_ATTRIBUTE_NOT_REUSABLE,
   NULL,
   ResetComputerAccount,
   NULL
};

//
// User Can Change Password
//
DSATTRIBUTETABLEENTRY canChangePwdUserEntry =
{
   NULL,
   eUserCanchpwd,
   DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_POSTCREATE,
   NULL,
   ChangeCanChangePassword,
   NULL
};

//
// Server is GC
//
DSATTRIBUTEDESCRIPTION options =
{
   {
      L"options",
      ADS_ATTR_UPDATE,
      ADSTYPE_INTEGER,
      NULL,
      0
   },
   0
};

DSATTRIBUTETABLEENTRY serverIsGCEntry =
{
   L"options",
   eServerIsGC,
   DS_ATTRIBUTE_NOT_REUSABLE | DS_ATTRIBUTE_POSTCREATE,
   &options,
   SetIsGC,
   NULL
};

//+-------------------------------------------------------------------------
// Objects
//--------------------------------------------------------------------------

//
// Organizational Unit
//

PDSATTRIBUTETABLEENTRY OUAttributeTable[] =
{
   &descriptionEntry
};

DSOBJECTTABLEENTRY g_OUObjectEntry = 
{
   L"organizationalUnit",
   g_pszOU,
   NULL,       // Uses just the common switches
   USAGE_DSMOD_OU,
   sizeof(OUAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   OUAttributeTable
};


//
// User
//

PDSATTRIBUTETABLEENTRY UserAttributeTable[] =
{
   &descriptionEntry,
   &upnUserEntry,
   &firstNameUserEntry,
   &middleInitialUserEntry,
   &lastNameUserEntry,
   &displayNameUserEntry,
   &employeeIDUserEntry,
   &passwordUserEntry,
   &officeUserEntry,
   &telephoneUserEntry,
   &emailUserEntry,
   &homeTelephoneUserEntry,
   &pagerUserEntry,
   &mobileUserEntry,
   &faxUserEntry,
   &ipPhoneUserEntry,
   &webPageUserEntry,
   &titleUserEntry,
   &departmentUserEntry,
   &companyUserEntry,
   &managerUserEntry,
   &homeDirectoryUserEntry,
   &homeDriveUserEntry,
   &profilePathUserEntry,
   &scriptPathUserEntry,
   &mustChangePwdUserEntry,
   &canChangePwdUserEntry,
   &reverisblePwdUserEntry,
   &pwdNeverExpiresUserEntry,
   &accountExpiresUserEntry,
   &disableUserEntry,
};

DSOBJECTTABLEENTRY g_UserObjectEntry = 
{
   L"user",
   g_pszUser,
   DSMOD_USER_COMMANDS,
   USAGE_DSMOD_USER,
   sizeof(UserAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   UserAttributeTable
};

//
// Contact
//

PDSATTRIBUTETABLEENTRY ContactAttributeTable[] =
{
   &descriptionEntry,
   &firstNameContactEntry,
   &middleInitialContactEntry,
   &lastNameContactEntry,
   &displayNameContactEntry,
   &officeContactEntry,
   &telephoneContactEntry,
   &emailContactEntry,
   &homeTelephoneContactEntry,
   &pagerContactEntry,
   &mobileContactEntry,
   &faxContactEntry,
   &titleContactEntry,
   &departmentContactEntry,
   &companyContactEntry
};

DSOBJECTTABLEENTRY g_ContactObjectEntry = 
{
   L"contact",
   g_pszContact,
   DSMOD_CONTACT_COMMANDS,
   USAGE_DSMOD_CONTACT,
   sizeof(ContactAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ContactAttributeTable
};

//
// Computer
//

PDSATTRIBUTETABLEENTRY ComputerAttributeTable[] =
{
   &descriptionEntry,
   &locationComputerEntry,
   &disableComputerEntry,
   &resetComputerEntry,
};

DSOBJECTTABLEENTRY g_ComputerObjectEntry = 
{
   L"computer",
   g_pszComputer,
   DSMOD_COMPUTER_COMMANDS,
   USAGE_DSMOD_COMPUTER,
   sizeof(ComputerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ComputerAttributeTable
};

//
// Group
//
PDSATTRIBUTETABLEENTRY GroupAttributeTable[] =
{
   &descriptionEntry,
   &samNameGroupEntry,
   &groupScopeTypeEntry,
   &groupSecurityTypeEntry,
   &groupAddMemberEntry,
   &groupRemoveMemberEntry,
   &groupChangeMemberEntry
};

DSOBJECTTABLEENTRY g_GroupObjectEntry = 
{
   L"group",
   g_pszGroup,
   DSMOD_GROUP_COMMANDS,
   USAGE_DSMOD_GROUP,
   sizeof(GroupAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   GroupAttributeTable
};

//
// Server
//
PDSATTRIBUTETABLEENTRY ServerAttributeTable[] =
{
   &descriptionEntry,
   &serverIsGCEntry
};

DSOBJECTTABLEENTRY g_ServerObjectEntry = 
{
   L"server",
   g_pszServer,
   DSMOD_SERVER_COMMANDS,
   USAGE_DSMOD_SERVER,
   sizeof(ServerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ServerAttributeTable
};

//+-------------------------------------------------------------------------
// Object Table
//--------------------------------------------------------------------------
PDSOBJECTTABLEENTRY g_DSObjectTable[] =
{
   &g_OUObjectEntry,
   &g_UserObjectEntry,
   &g_ContactObjectEntry,
   &g_ComputerObjectEntry,
   &g_GroupObjectEntry,
   &g_ServerObjectEntry,
   NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmod\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

//
// The command line executable name
//
extern PCWSTR g_pszDSCommandName;

//
// Object types as are typed on the command line
//
extern PCWSTR g_pszOU;
extern PCWSTR g_pszUser;
extern PCWSTR g_pszContact;
extern PCWSTR g_pszComputer;
extern PCWSTR g_pszGroup;
extern PCWSTR g_pszServer;

//
// Common switches
//
extern PCWSTR c_sz_arg1_com_debug;
extern PCWSTR c_sz_arg1_com_help;
extern PCWSTR c_sz_arg2_com_help;
extern PCWSTR c_sz_arg1_com_server;
extern PCWSTR c_sz_arg2_com_server;
extern PCWSTR c_sz_arg1_com_domain;
extern PCWSTR c_sz_arg2_com_domain;
extern PCWSTR c_sz_arg1_com_username;
extern PCWSTR c_sz_arg2_com_username;
extern PCWSTR c_sz_arg1_com_password;
extern PCWSTR c_sz_arg2_com_password;
extern PCWSTR c_sz_arg1_com_quiet;
extern PCWSTR c_sz_arg1_com_continue;
extern PCWSTR c_sz_arg1_com_description;
extern PCWSTR c_sz_arg1_com_objecttype;
extern PCWSTR c_sz_arg1_com_objectDN;

//
// User and contact switches
//
extern PCWSTR g_pszArg1UserUPN; 
extern PCWSTR g_pszArg1UserFirstName;
extern PCWSTR g_pszArg1UserMiddleInitial;
extern PCWSTR g_pszArg1UserLastName;
extern PCWSTR g_pszArg1UserDisplayName;
extern PCWSTR g_pszArg1UserEmpID;
extern PCWSTR g_pszArg1UserPassword;
extern PCWSTR g_pszArg1UserOffice;
extern PCWSTR g_pszArg1UserTelephone;
extern PCWSTR g_pszArg1UserEmail;
extern PCWSTR g_pszArg1UserHomeTelephone;
extern PCWSTR g_pszArg1UserPagerNumber;
extern PCWSTR g_pszArg1UserMobileNumber;
extern PCWSTR g_pszArg1UserFaxNumber;
extern PCWSTR g_pszArg1UserIPTel;
extern PCWSTR g_pszArg1UserWebPage;
extern PCWSTR g_pszArg1UserTitle;
extern PCWSTR g_pszArg1UserDepartment;
extern PCWSTR g_pszArg1UserCompany;
extern PCWSTR g_pszArg1UserManager;
extern PCWSTR g_pszArg1UserHomeDirectory;
extern PCWSTR g_pszArg1UserHomeDrive;
extern PCWSTR g_pszArg1UserProfilePath;
extern PCWSTR g_pszArg1UserScriptPath;
extern PCWSTR g_pszArg1UserMustChangePwd;
extern PCWSTR g_pszArg1UserCanChangePwd;
extern PCWSTR g_pszArg1UserReversiblePwd;
extern PCWSTR g_pszArg1UserPwdNeverExpires;
extern PCWSTR g_pszArg1UserDisableAccount;
extern PCWSTR g_pszArg1UserAccountExpires;

//
// Computer switches
//
extern PCWSTR g_pszArg1ComputerLocation;
extern PCWSTR g_pszArg1ComputerDisabled;
extern PCWSTR g_pszArg1ComputerReset;

//
// Group switches
//
extern PCWSTR g_pszArg1GroupSAMName;
extern PCWSTR g_pszArg1GroupSec;
extern PCWSTR g_pszArg1GroupScope;
extern PCWSTR g_pszArg1GroupAddMember;
extern PCWSTR g_pszArg1GroupRemoveMember;
extern PCWSTR g_pszArg1GroupChangeMember;

//
// Server switches
//
extern PCWSTR g_pszArg1ServerIsGC;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmod\dsmod.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsMod.cpp
//
//  Contents:  Defines the main function and parser tables for the DSMod
//             command line utility
//
//  History:   06-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "modtable.h"
#include "resource.h"

//
// Function Declarations
//
HRESULT DoModValidation(PARG_RECORD pCommandArgs);
HRESULT DoMod(PARG_RECORD pCommandArgs, PDSOBJECTTABLEENTRY pObjectEntry);


int __cdecl _tmain( VOID )
{

   int argc;
   LPTOKEN pToken = NULL;
   HRESULT hr = S_OK;

   //
   // Initialize COM
   //
   hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
   if (FAILED(hr))
   {
      DisplayErrorMessage(g_pszDSCommandName, 
                          NULL,
                          hr);
      return hr;
   }

   if( !GetCommandInput(&argc,&pToken) )
   {
      PARG_RECORD pNewCommandArgs = 0;

      //
      // False loop
      //
      do
      {
         if(argc == 1)
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSMOD);
            hr = E_INVALIDARG;
            break;
         }

         //
         // Find which object table entry to use from
         // the second command line argument
         //
         PDSOBJECTTABLEENTRY pObjectEntry = NULL;
         UINT idx = 0;
         while (true)
         {
            pObjectEntry = g_DSObjectTable[idx];
            if (!pObjectEntry)
            {
               break;
            }

            PWSTR pszObjectType = (pToken+1)->GetToken();
            if (0 == _wcsicmp(pObjectEntry->pszCommandLineObjectType, pszObjectType))
            {
               break;
            }
            idx++;
         }

         if (!pObjectEntry)
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSMOD);
            hr = E_INVALIDARG;
            break;
         }

         //
         // Now that we have the correct table entry, merge the command line table
         // for this object with the common commands
         //
         hr = MergeArgCommand(DSMOD_COMMON_COMMANDS, 
                              pObjectEntry->pParserTable, 
                              &pNewCommandArgs);
         if (FAILED(hr))
         {
            //
            // Display the error message and then break out of the false loop
            //
            DisplayErrorMessage(g_pszDSCommandName, L"", hr);
            break;
         }

         if (!pNewCommandArgs)
         {
            //
            // Display the usage text and then break out of the false loop
            //
            DisplayMessage(pObjectEntry->nUsageID);
            hr = E_FAIL;
            break;
         }

         PARSE_ERROR Error;
         if(!ParseCmd(pNewCommandArgs,
                      argc-1, 
                      pToken+1,
                      pObjectEntry->nUsageID, 
                      &Error,
                      TRUE))
         {
            if (Error.Error != PARSE_ERROR_HELP_SWITCH)
            {
               //
               // Display the usage text and then break out of the false loop
               //
               DisplayMessage(pObjectEntry->nUsageID);
            }
            hr = E_INVALIDARG;
            break;
         }
         else
         {
            //
            // Check to see if we are doing debug spew
            //
#ifdef DBG
            bool bDebugging = pNewCommandArgs[eCommDebug].bDefined && 
                              pNewCommandArgs[eCommDebug].nValue;
            if (bDebugging)
            {
               ENABLE_DEBUG_OUTPUT(pNewCommandArgs[eCommDebug].nValue);
            }
#else
            DISABLE_DEBUG_OUTPUT();
#endif
            //
            // Be sure that mutually exclusive and dependent switches are correct
            //
            hr = DoModValidation(pNewCommandArgs);
            if (FAILED(hr))
            {
               DisplayMessage(pObjectEntry->nUsageID);
               break;
            }

            //
            // Command line parsing succeeded
            //
            hr = DoMod(pNewCommandArgs, pObjectEntry);
         }

      } while (false);

      //
      // Free the memory associated with the command values
      //
      if (pNewCommandArgs)
      {
         FreeCmd(pNewCommandArgs);
      }

      //
      // Free the tokens
      //
      if (pToken)
      {
         delete[] pToken;
         pToken = 0;
      }
   }

   //
   // Uninitialize COM
   //
   ::CoUninitialize();

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoModValidation
//
//  Synopsis:   Checks to be sure that command line switches that are mutually
//              exclusive are not both present and those that are dependent are
//              both presetn
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    19-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoModValidation(PARG_RECORD pCommandArgs)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoModValidation, hr);

   do // false loop
   {
      //
      // Check the user switches
      //
      if (pCommandArgs[eCommObjectType].bDefined &&
          pCommandArgs[eCommObjectType].strValue &&
          0 == _wcsicmp(g_pszUser, pCommandArgs[eCommObjectType].strValue))
      {
         //
         // Can't have user must change password if user can change password is no
         //
         if ((pCommandArgs[eUserMustchpwd].bDefined &&
              pCommandArgs[eUserMustchpwd].bValue) &&
             (pCommandArgs[eUserCanchpwd].bDefined &&
              !pCommandArgs[eUserCanchpwd].bValue))
         {
            DisplayErrorMessage(g_pszDSCommandName, NULL, S_OK, IDS_MUSTCHPWD_CANCHPWD_CONFLICT);
            hr = E_INVALIDARG;
            break;
         }

         if (pCommandArgs[eUserPwd].bDefined &&
             pCommandArgs[eUserPwd].strValue)
         {
            size_t pwdLen = wcslen(pCommandArgs[eUserPwd].strValue);
            if (pwdLen > MAX_PASSWORD_LENGTH - 1)
            {
               DisplayErrorMessage(g_pszDSCommandName, NULL, S_OK, IDS_PASSWORD_TOO_LONG);
               hr = E_INVALIDARG;
               break;
            }
         }
      }
   } while (false);

   return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoMod
//
//  Synopsis:   Finds the appropriate object in the object table and fills in
//              the attribute values and then applies the changes
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    07-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoMod(PARG_RECORD pCommandArgs, PDSOBJECTTABLEENTRY pObjectEntry)
{
   ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoMod, hr);

   PADS_ATTR_INFO pAttrs = NULL;

   do // false loop
   {
      if (!pCommandArgs || !pObjectEntry)
      {
         ASSERT(pCommandArgs && pObjectEntry);
         hr = E_INVALIDARG;
         break;
      }

      CDSCmdCredentialObject credentialObject;
      if (pCommandArgs[eCommUserName].bDefined)
      {
         credentialObject.SetUsername(pCommandArgs[eCommUserName].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      if (pCommandArgs[eCommPassword].bDefined)
      {
         credentialObject.SetPassword(pCommandArgs[eCommPassword].strValue);
         credentialObject.SetUsingCredentials(true);
      }

      //
      // Initialize the base paths info from the command line args
      // 
      CDSCmdBasePathsInfo basePathsInfo;
      if (pCommandArgs[eCommServer].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommServer].strValue,
                                               true);
      }
      else if (pCommandArgs[eCommDomain].bDefined)
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, 
                                               pCommandArgs[eCommDomain].strValue,
                                               false);
      }
      else
      {
         hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
      }

      if (FAILED(hr))
      {
         //
         // Display error message and return
         //
         DEBUG_OUTPUT(MINIMAL_LOGGING, L"CDSBasePathsInfo::InitializeFromName failed: hr = 0x%x", hr);
         DisplayErrorMessage(g_pszDSCommandName, NULL, hr);
         break;
      }

      //
      // Now that we have the table entry loop through the other command line
      // args and see which ones can be applied
      //
      DWORD dwAttributeCount = 0;
      DWORD dwCount = pObjectEntry->dwAttributeCount; 
      pAttrs = new ADS_ATTR_INFO[dwCount];
      if (!pAttrs)
      {
         //
         // Display error message and return
         //
         DisplayErrorMessage(g_pszDSCommandName, NULL, E_OUTOFMEMORY);
         hr = E_OUTOFMEMORY;
         break;
      }

      //
      // The DNs or Names should be given as a \0 separated list
      // So parse it and loop through each object
      //
      UINT nStrings = 0;
      PWSTR* ppszArray = NULL;
      ParseNullSeparatedString(pCommandArgs[eCommObjectDNorName].strValue,
                               &ppszArray,
                               &nStrings);
      if (nStrings < 1 ||
          !ppszArray)
      {
         //
         // Display the usage text and then fail
         //
         DisplayMessage(pObjectEntry->nUsageID);
         hr = E_INVALIDARG;
         break;
      }

      //
      // Loop through each of the objects
      //
      for (UINT nNameIdx = 0; nNameIdx < nStrings; nNameIdx++)
      {
         dwAttributeCount = 0;
         do // false loop
         {
            //
            // Get the objects DN
            //
            PWSTR pszObjectDN = ppszArray[nNameIdx];
            if (!pszObjectDN)
            {
               //
               // Display the usage text and then fail
               //
               DisplayMessage(pObjectEntry->nUsageID);
               hr = E_INVALIDARG;
               break;
            }
            DEBUG_OUTPUT(MINIMAL_LOGGING, L"Object DN = %s", pszObjectDN);

            //
            // Compose the objects path
            //
            CComBSTR sbstrObjectPath;
            basePathsInfo.ComposePathFromDN(pszObjectDN, sbstrObjectPath);

            //
            // Verify that the object type matches the one entered on the command line
            //
            CComPtr<IDirectoryObject> spDirObject;
            hr = DSCmdOpenObject(credentialObject,
                                 sbstrObjectPath,
                                 IID_IDirectoryObject,
                                 (void**)&spDirObject,
                                 true);

            if (FAILED(hr))
            {
               //
               // Display error message and return
               //
               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr);
               break;
            }

            CComQIPtr<IADs> spADs(spDirObject);
            if (!spADs)
            {
               ASSERT(spADs);
               hr = E_INVALIDARG;
               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr);
               break;
            }


            CComBSTR sbstrClass;
            hr = spADs->get_Class(&sbstrClass);
            if (FAILED(hr))
            {
               //
               // Display error message and return
               //
               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr);
               break;
            }

            if (_wcsicmp(sbstrClass, pObjectEntry->pszObjectClass))
            {
               //
               // Display error message and return
               //
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Command line type does not match object class", dwAttributeCount);
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"command line type = %s", pCommandArgs[eCommObjectType].strValue);
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"object class = %s", sbstrClass);

               DisplayErrorMessage(g_pszDSCommandName,
                                   pszObjectDN,
                                   hr,
                                   IDS_ERRMSG_CLASS_NOT_EQUAL);
               hr = E_INVALIDARG;
               break;
            }

            UINT nModificationsAttempted = 0;
            for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
            {
               ASSERT(pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc);

               UINT nAttributeIdx = pObjectEntry->pAttributeTable[dwIdx]->nAttributeID;

               if (pCommandArgs[nAttributeIdx].bDefined)
               {
                  if (!(pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_DIRTY) ||
                      pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE)
                  {
                     //
                     // Call the evaluation function to get the ADS_ATTR_INFO set
                     //
                     PADS_ATTR_INFO pNewAttr = NULL;
                     hr = pObjectEntry->pAttributeTable[dwIdx]->pEvalFunc(pszObjectDN,
                                                                          basePathsInfo,
                                                                          credentialObject,
                                                                          pObjectEntry, 
                                                                          pCommandArgs[nAttributeIdx],
                                                                          dwIdx, 
                                                                          &pNewAttr);
                     DEBUG_OUTPUT(MINIMAL_LOGGING, L"pEvalFunc returned hr = 0x%x", hr);
                     if (SUCCEEDED(hr) && hr != S_FALSE)
                     {
                        if (pNewAttr)
                        {
                           //
                           // Mark the attribute entry as DIRTY so that we don't have to 
                           // do the computation for the next object
                           //
                           pObjectEntry->pAttributeTable[dwIdx]->dwFlags |= DS_ATTRIBUTE_DIRTY;

                           //
                           // Copy the value
                           //
                           pAttrs[dwAttributeCount] = *pNewAttr;
                           dwAttributeCount++;
                        }
                     }
                     else
                     {
                        //
                        // Don't show an error if the eval function returned S_FALSE
                        //
                        if (hr != S_FALSE)
                        {
                           //
                           // Display an error
                           //
                           DisplayErrorMessage(g_pszDSCommandName,
                                               pszObjectDN,
                                               hr);
                        }
            
                        if (hr == S_FALSE)
                        {
                           //
                           // Return a generic error code so that we don't print the success message
                           //
                           hr = E_FAIL;
                        }
                        break;           
                     }
                  }
                  else
                  {
                    //
                    // Need to count previously retrieved values too
                    //
                    dwAttributeCount++;
                  }
                  nModificationsAttempted++;
               }
            }

            if (SUCCEEDED(hr) && dwAttributeCount > 0)
            {
               //
               // Now that we have the attributes ready, lets set them in the DS
               //

               DEBUG_OUTPUT(MINIMAL_LOGGING, L"Setting %d attributes", dwAttributeCount);
   #ifdef DBG
               DEBUG_OUTPUT(FULL_LOGGING, L"Modified Attributes:");
               SpewAttrs(pAttrs, dwAttributeCount);
   #endif

               DWORD dwAttrsModified = 0;
               hr = spDirObject->SetObjectAttributes(pAttrs, 
                                                     dwAttributeCount,
                                                     &dwAttrsModified);
               if (FAILED(hr))
               {
                  //
                  // Display error message and return
                  //
                  DEBUG_OUTPUT(MINIMAL_LOGGING, L"SetObjectAttributes failed: hr = 0x%x", hr);

                  DisplayErrorMessage(g_pszDSCommandName,
                                      pszObjectDN,
                                      hr);
                  break;
               }
               DEBUG_OUTPUT(MINIMAL_LOGGING, L"SetObjectAttributes succeeded");
            }
            else if (SUCCEEDED(hr) && nModificationsAttempted == 0)
            {
               //
               // Display the usage text and then break out of the false loop
               //

               //
               // REVIEW_JEFFJON : this is causing a first-chance exception
               //
               DisplayMessage(pObjectEntry->nUsageID);
               hr = E_INVALIDARG;
               break;
            }
         } while (false);

         //
         // Loop through the attributes again, clearing any values for 
         // attribute entries that are marked DS_ATTRIBUTE_NOT_REUSABLE
         //
         DEBUG_OUTPUT(LEVEL5_LOGGING, L"Cleaning up memory and flags for object %d", nNameIdx);
         for (DWORD dwIdx = 0; dwIdx < dwCount; dwIdx++)
         {
            if (pObjectEntry->pAttributeTable[dwIdx]->dwFlags & DS_ATTRIBUTE_NOT_REUSABLE)
            {
               if (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc &&
                   ((pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_READ) ||
                    (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags & DS_ATTRIBUTE_DIRTY)))
               {
                  //
                  // Cleanup the memory associated with the value
                  //
                  if (pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues)
                  {
                     delete[] pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues;
                     pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->adsAttrInfo.pADsValues = NULL;
                  }

                  //
                  // Cleanup the flags so that the attribute will be read for the next object
                  //
                  pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags &= ~(DS_ATTRIBUTE_READ);
                  pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags &= ~(DS_ATTRIBUTE_DIRTY);

                  DEBUG_OUTPUT(LEVEL5_LOGGING, 
                               L"Flags for attribute %s = %d",
                               pObjectEntry->pAttributeTable[dwIdx]->pszName,
                               pObjectEntry->pAttributeTable[dwIdx]->pAttrDesc->dwFlags);
               }
            }
         }

         if (FAILED(hr) && !pCommandArgs[eCommContinue].bDefined)
         {
            break;
         }

         //
         // Display the success message
         //
         if (SUCCEEDED(hr) && !pCommandArgs[eCommQuiet].bDefined)
         {
            DisplaySuccessMessage(g_pszDSCommandName,
                                  ppszArray[nNameIdx]);
         }

      } // Name for loop
   } while (false);

   //
   // Cleanup
   //
   if (pAttrs)
   {
      delete[] pAttrs;
      pAttrs = NULL;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmod\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsmod.rc
//
#define IDS_MSG_FAILED_INIT_PATH_INFO   100
#define IDS_PASSWORD_TOO_LONG           101
#define IDS_ERRMSG_CLASS_NOT_EQUAL      102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmod\modtable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.h
//
//  Contents:  Declares a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _MODTABLE_H_
#define _MODTABLE_H_

typedef enum COMMON_COMMAND
{
   //
   // Common switches
   //
#ifdef DBG
   eCommDebug,
#endif
   eCommHelp,
   eCommServer,
   eCommDomain,
   eCommUserName,
   eCommPassword,
   eCommQuiet,
   eCommContinue,
   eCommObjectType,
   eCommObjectDNorName,
   eCommDescription,
   eTerminator,

   //
   // User and Contact switches
   //
   eUserUpn = eTerminator,
   eUserFn,
   eUserMi,
   eUserLn,
   eUserDisplay,
   eUserEmpID,
   eUserPwd,
   eUserOffice,
   eUserTel,
   eUserEmail,
   eUserHometel,
   eUserPager,
   eUserMobile,
   eUserFax,
   eUserIPPhone,
   eUserWebPage,
   eUserTitle,
   eUserDept,
   eUserCompany,
   eUserManager,
   eUserHomeDir,
   eUserHomeDrive,
   eUserProfilePath,
   eUserScriptPath,
   eUserMustchpwd,
   eUserCanchpwd,
   eUserReversiblePwd,
   eUserPwdneverexpires,
   eUserAcctexpires,
   eUserDisabled,

   //
   // Contact switches
   //
   eContactFn = eTerminator,
   eContactMi,
   eContactLn,
   eContactDisplay,
   eContactOffice,
   eContactTel,
   eContactEmail,
   eContactHometel,
   eContactPager,
   eContactMobile,
   eContactFax,
   eContactTitle,
   eContactDept,
   eContactCompany,

   //
   // Computer switches
   //
   eComputerLocation = eTerminator,
   eComputerDisabled,
   eComputerReset,

   //
   // Group switches
   //
   eGroupSamname = eTerminator,
   eGroupSecgrp,
   eGroupScope,
   eGroupAddMember,
   eGroupRemoveMember,
   eGroupChangeMember,

   //
   // OU doesn't have any additional switches
   //

   //
   // Subnet switches
   //
   eSubnetSite = eTerminator,

   //
   // Site switches
   // 
   eSiteAutotopology = eTerminator,

   //
   // Site Link switches
   //
   eSLinkIp = eTerminator,
   eSLinkSmtp,
   eSLinkAddsite,
   eSLinkRmsite,
   eSLinkCost,
   eSLinkRepint,
   eSLinkAutobacksync,
   eSLinkNotify,

   //
   // Site Link Bridge switches
   //
   eSLinkBrIp = eTerminator,
   eSLinkBrSmtp,
   eSLinkBrAddslink,
   eSLinkBrRmslink,

   //
   // Replication Connection switches
   // 
   eConnTransport = eTerminator,
   eConnEnabled,
   eConnManual,
   eConnAutobacksync,
   eConnNotify,

   //
   // Server switches
   //
   eServerIsGC = eTerminator,
};

//
// The parser table
//
extern ARG_RECORD DSMOD_COMMON_COMMANDS[];

//
// The table of supported objects
//
extern PDSOBJECTTABLEENTRY g_DSObjectTable[];

#endif //_MODTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmove\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

PCWSTR c_sz_arg1_com_debug       = L"debug";
PCWSTR c_sz_arg1_com_help        = L"h";
PCWSTR c_sz_arg2_com_help        = L"?";
PCWSTR c_sz_arg1_com_server      = L"s";
PCWSTR c_sz_arg2_com_server      = L"server";
PCWSTR c_sz_arg1_com_domain      = L"d";
PCWSTR c_sz_arg2_com_domain      = L"domain";
PCWSTR c_sz_arg1_com_username    = L"u";
PCWSTR c_sz_arg2_com_username    = L"username";
PCWSTR c_sz_arg1_com_password    = L"p";
PCWSTR c_sz_arg2_com_password    = L"password";
PCWSTR c_sz_arg1_com_quiet       = L"q";
PCWSTR c_sz_arg1_com_newparent   = L"newparent";
PCWSTR c_sz_arg1_com_newname     = L"newname";
PCWSTR c_sz_arg1_com_objectDN    = L"Target object for this command";
PCWSTR g_pszDSCommandName        = L"dsmove";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmove\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

extern PCWSTR c_sz_arg1_com_debug;
extern PCWSTR c_sz_arg1_com_help;
extern PCWSTR c_sz_arg2_com_help;
extern PCWSTR c_sz_arg1_com_server;
extern PCWSTR c_sz_arg2_com_server;
extern PCWSTR c_sz_arg1_com_domain;
extern PCWSTR c_sz_arg2_com_domain;
extern PCWSTR c_sz_arg1_com_username;
extern PCWSTR c_sz_arg2_com_username;
extern PCWSTR c_sz_arg1_com_password;
extern PCWSTR c_sz_arg2_com_password;
extern PCWSTR c_sz_arg1_com_quiet;
extern PCWSTR c_sz_arg1_com_newparent;
extern PCWSTR c_sz_arg1_com_newname;
extern PCWSTR c_sz_arg1_com_objectDN;
extern PCWSTR g_pszDSCommandName;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmove\movetable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.cpp
//
//  Contents:  Defines a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "movetable.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------
ARG_RECORD DSMOVE_COMMON_COMMANDS[] = 
{
#ifdef DBG
   //
   // -debug, -debug
   //
   0,(LPWSTR)c_sz_arg1_com_debug, 
   0,NULL,
   ARG_TYPE_DEBUG, ARG_FLAG_OPTIONAL|ARG_FLAG_HIDDEN,  
   (CMD_TYPE)0,     
   0,  NULL,
#endif

   //
   // h, ?
   //
   0,(LPWSTR)c_sz_arg1_com_help, 
   0,(LPWSTR)c_sz_arg2_com_help, 
   ARG_TYPE_HELP, ARG_FLAG_OPTIONAL,  
   (CMD_TYPE)FALSE,     
   0,  NULL,

   //
   // s,server
   //
   0,(LPWSTR)c_sz_arg1_com_server, 
   0,(LPWSTR)c_sz_arg2_com_server, 
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // d,domain
   //
   0,(LPWSTR)c_sz_arg1_com_domain, 
   0,(LPWSTR)c_sz_arg2_com_domain, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // u, username    
   //
   0,(LPWSTR)c_sz_arg1_com_username, 
   0,(LPWSTR)c_sz_arg2_com_username, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // w, password
   //
   0,(LPWSTR)c_sz_arg1_com_password, 
   0,(LPWSTR)c_sz_arg2_com_password, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  ValidateAdminPassword,

   //
   // q,q
   //
   0,(LPWSTR)c_sz_arg1_com_quiet, 
   0,NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   0,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN|ARG_FLAG_DN,
   NULL,    
   0,  NULL,

   //
   // newparent
   //
   0, (PWSTR)c_sz_arg1_com_newparent,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,

   //
   // newname
   //
   0, (PWSTR)c_sz_arg1_com_newname,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,


   ARG_TERMINATOR
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmove\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsmod.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmove\dsmove.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsmove.cpp
//
//  Contents:  Defines the main function and parser tables for the dsmove
//             command line utility
//
//  History:   06-Sep-2000    hiteshr Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "stdio.h"
#include "cstrings.h"
#include "usage.h"
#include "movetable.h"

//
// Function Declarations
//
HRESULT DoMove();
HRESULT DoMoveValidation();

int __cdecl _tmain( VOID )
{

    int argc;
    LPTOKEN pToken = NULL;
    HRESULT hr = S_OK;
    
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if(FAILED(hr))
        goto exit_gracefully;
    
    if( !GetCommandInput(&argc,&pToken) )
    {
        if(argc == 1)
        {
			DisplayMessage(USAGE_DSMOVE);
            hr = E_INVALIDARG;
            goto exit_gracefully;
        }
        PARSE_ERROR Error;
        if(!ParseCmd(DSMOVE_COMMON_COMMANDS,
                     argc-1, 
                     pToken+1,
                     USAGE_DSMOVE, 
                     &Error,
                     TRUE))
        {
            if(Error.ErrorSource == ERROR_FROM_PARSER 
               && Error.Error == PARSE_ERROR_HELP_SWITCH)
            {
                hr = S_OK;
                goto exit_gracefully;
            }

            DisplayMessage(USAGE_DSMOVE);
            hr = E_INVALIDARG;
        }
        else
        {
            hr =DoMoveValidation();
            if(FAILED(hr))
            {
                DisplayMessage(USAGE_DSMOVE);
                goto exit_gracefully;
            }
             //
             // Command line parsing succeeded
             //
             hr = DoMove();
        }
    }

exit_gracefully:

    //
    // Display the success message
    //
    if (SUCCEEDED(hr) && !DSMOVE_COMMON_COMMANDS[eCommQuiet].bDefined)
    {
        DisplaySuccessMessage(g_pszDSCommandName,
                              DSMOVE_COMMON_COMMANDS[eCommObjectDN].strValue);
    }

    // Free Command Array
    FreeCmd(DSMOVE_COMMON_COMMANDS);
    // Free Token
    if(pToken)
        delete []pToken;

    //
    // Uninitialize COM
    //
    CoUninitialize();

   return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   DoMoveValidation
//
//  Synopsis:   Does advanced switch dependency validation which parser cannot do.
//
//  Arguments:  
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        
//  History:    07-Sep-2000   Hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT DoMoveValidation()
{
    HRESULT hr = S_OK;
    if(!DSMOVE_COMMON_COMMANDS[eCommNewParent].bDefined &&
       !DSMOVE_COMMON_COMMANDS[eCommNewName].bDefined )
    {
        return E_INVALIDARG;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoMove
//
//  Synopsis:   Finds the appropriate object in the object table and fills in
//              the attribute values and then applies the changes
//
//  Arguments:  
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    07-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DoMove()
{
    HRESULT hr = S_OK;

    PWSTR pszObjectDN = DSMOVE_COMMON_COMMANDS[eCommObjectDN].strValue;
    if (!pszObjectDN)
    {
        return E_INVALIDARG;
    }    

    CDSCmdCredentialObject credentialObject;
    if (DSMOVE_COMMON_COMMANDS[eCommUserName].bDefined &&
        DSMOVE_COMMON_COMMANDS[eCommUserName].strValue)
    {
        credentialObject.SetUsername(DSMOVE_COMMON_COMMANDS[eCommUserName].strValue);
        credentialObject.SetUsingCredentials(true);
    }

    if (DSMOVE_COMMON_COMMANDS[eCommPassword].bDefined &&
        DSMOVE_COMMON_COMMANDS[eCommPassword].strValue)
    {
        credentialObject.SetPassword(DSMOVE_COMMON_COMMANDS[eCommPassword].strValue);
        credentialObject.SetUsingCredentials(true);
    }


    //
    // Initialize the base paths info from the command line args
    // 
    CDSCmdBasePathsInfo basePathsInfo;
    if (DSMOVE_COMMON_COMMANDS[eCommServer].bDefined &&
        DSMOVE_COMMON_COMMANDS[eCommServer].strValue)
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, 
                                              DSMOVE_COMMON_COMMANDS[eCommServer].strValue,
                                              true);
    }
    else if (DSMOVE_COMMON_COMMANDS[eCommDomain].bDefined &&
             DSMOVE_COMMON_COMMANDS[eCommDomain].strValue)
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, 
                                                DSMOVE_COMMON_COMMANDS[eCommDomain].strValue,
                                                false);
    }
    else
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
    }
    if (FAILED(hr))
    {
        //
        // Display error message and return
        //
        DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
        return hr;
    }

    CComBSTR sbstrObjectPath;    
    basePathsInfo.ComposePathFromDN(pszObjectDN, sbstrObjectPath);


    //Get The ParentObjectPath
    CComBSTR sbstrParentObjectPath;
    if(DSMOVE_COMMON_COMMANDS[eCommNewParent].bDefined &&
       DSMOVE_COMMON_COMMANDS[eCommNewParent].strValue )
    {
        LPWSTR szParentDN = DSMOVE_COMMON_COMMANDS[eCommNewParent].strValue;
        basePathsInfo.ComposePathFromDN(szParentDN, sbstrParentObjectPath);
    }
    else
    {
        CPathCracker pathCracker;
        CComBSTR sbstrParentDN;
        hr = pathCracker.GetParentDN(pszObjectDN, sbstrParentDN);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
            return hr;
        }
        basePathsInfo.ComposePathFromDN(sbstrParentDN,sbstrParentObjectPath);
    }

    //
    //Get the RDN for NewName. User enters the only name. We need to convert it
    //into cn=name or ou=name format. To do this strip the leaf node from the
    //objectDN and replace the string after "=" by NewName
    //
    CComBSTR sbstrNewName;
    if(DSMOVE_COMMON_COMMANDS[eCommNewName].bDefined &&
       DSMOVE_COMMON_COMMANDS[eCommNewName].strValue )
    {
        CPathCracker pathCracker;
        CComBSTR sbstrLeafNode;
        hr = pathCracker.GetObjectRDNFromDN(pszObjectDN,sbstrLeafNode);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
            return hr;
        }
        sbstrNewName.Append(sbstrLeafNode,3);
        //Enclose the name in quotes to allow for special names like
        //test1,ou=ou1 NTRAID#NTBUG9-275556-2000/11/13-hiteshr
        sbstrNewName.Append(L"\"");
        sbstrNewName.Append(DSMOVE_COMMON_COMMANDS[eCommNewName].strValue);       
        sbstrNewName.Append(L"\"");
    }
    
    //Get IADsContainer pointer
    CComPtr<IADsContainer> spDsContainer;
    hr = DSCmdOpenObject(credentialObject,
                         sbstrParentObjectPath,
                         IID_IADsContainer,
                         (void**)&spDsContainer,
                         true);

    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
        return hr;
    }
    IDispatch * pDispObj = NULL;
    hr = spDsContainer->MoveHere(sbstrObjectPath,
                                 sbstrNewName,
                                 &pDispObj);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, pszObjectDN, hr);
        return hr;
    }

    if(pDispObj)
    {
        pDispObj->Release();
        pDispObj = NULL;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsmove\movetable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.h
//
//  Contents:  Declares a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _MOVETABLE_H_
#define _MOVETABLE_H_

typedef enum COMMON_COMMAND
{
#ifdef DBG
   eCommDebug,
#endif
   eCommHelp,
   eCommServer,
   eCommDomain,
   eCommUserName,
   eCommPassword,
   eCommQuiet,
   eCommObjectDN,   
   eCommNewParent,
   eCommNewName,
   eTerminator
};

//
// The parser table
//
extern ARG_RECORD DSMOVE_COMMON_COMMANDS[];

#endif //_MOVETABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\dsquery.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsquery.cpp
//
//  Contents:  Defines the main function    DSQUERY
//             command line utility
//
//  History:   06-Sep-2000    hiteshr  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "querytable.h"
#include "querybld.h"
#include "dsquery.h"
#include "query.h"
#include "resource.h"
#include "output.h"
#include <dscmn.h>

//
//Structure Defined to Store Global Values at one place.
//
typedef struct _GlobalInfo
{
    ADS_SCOPEENUM scope;                //Scope of query
    DSQUERY_OUTPUT_FORMAT outputFormat; //Output Format    
}GLOBAL_INFO,*PGLOBAL_INFO;
    
bool g_bQuiet = false;
int g_iQueryLimit = 100;
bool g_bDeafultLimit = true;

//
// Forward Function Declarations
//
HRESULT DoQueryValidation(PARG_RECORD pCommandArgs,
                          PDSQueryObjectTableEntry pObjectEntry,
                          PGLOBAL_INFO pcommon_info);

HRESULT DoQuery(PARG_RECORD pCommandArgs, 
                PDSQueryObjectTableEntry pObjectEntry,
                PGLOBAL_INFO pcommon_info);

HRESULT GetAttributesToFetch(IN PGLOBAL_INFO pcommon_info,
                             IN PARG_RECORD pCommandArgs,
                             IN PDSQueryObjectTableEntry pObjectEntry,
                             OUT LPWSTR **ppszAttributes,
                             OUT DWORD * pCount);
VOID FreeAttributesToFetch( IN LPWSTR *ppszAttributes,
                            IN DWORD  dwCount);

HRESULT GetSearchRoot(IN IN PDSQueryObjectTableEntry pObjectEntry,
					  IN PARG_RECORD               pCommandArgs,
                      IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                      OUT CComBSTR&                refsbstrDN,
					  OUT BOOL *pbSearchAtForestRoot,
					  OUT BOOL *pbSearchAtGC);

HRESULT GetSearchObject(IN IN PDSQueryObjectTableEntry pObjectEntry,
                        IN CDSCmdBasePathsInfo& refBasePathsInfo,
						IN PARG_RECORD pCommandArgs,
						IN CDSCmdCredentialObject& refCredentialObject,
						IN CComBSTR& refsbstrDN,
						IN BOOL bSearchAtForestRoot,
						IN BOOL bSearchAtGC,
						OUT CComPtr<IDirectorySearch>& refspSearchObject);



//
//Main Function
//
int __cdecl _tmain( VOID )
{

    int argc = 0;
    LPTOKEN pToken = NULL;
    HRESULT hr = S_OK;
    PARG_RECORD pNewCommandArgs = 0;

    //
    // False loop
    //
    do
    {
        //
        // Initialize COM
        //
        hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);

            break;
        }

        //Get CommandLine Input
        hr = HRESULT_FROM_WIN32(GetCommandInput(&argc,&pToken));
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);

            break;
        }
    
        if(argc == 1)
        {
            //
            //  Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSQUERY);
            hr = E_INVALIDARG;
            break;
        }
    
        //
        // Find which object table entry to use from
        // the second command line argument
        //
        PDSQueryObjectTableEntry pObjectEntry = NULL;
        UINT idx = 0;
        PWSTR pszObjectType = (pToken+1)->GetToken();
        while (true)
        {
            pObjectEntry = g_DSObjectTable[idx++];
            if (!pObjectEntry)
            {
                break;
            }
            if (0 == _wcsicmp(pObjectEntry->pszCommandLineObjectType, pszObjectType))
            {
                break;
            }
        }

        if (!pObjectEntry)
        {
            
            hr = E_INVALIDARG;
            if(argc == 2)
            {
                if(pToken[1].IsSwitch())
                {
                    if(!wcscmp(pToken[1].GetToken(),L"/?") ||
                       !wcscmp(pToken[1].GetToken(),L"/h") ||
                       !wcscmp(pToken[1].GetToken(),L"-?") ||
                       !wcscmp(pToken[1].GetToken(),L"-h"))
                        
                            hr = S_OK;
                }
            }
            //
            // Display the error message and then break out of the false loop
            //
            DisplayMessage(USAGE_DSQUERY);
            if (FAILED(hr))
            {
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

            }            

            break;
        }

        //
        // Now that we have the correct table entry, merge the command line table
        // for this object with the common commands
        //
        hr = MergeArgCommand(DSQUERY_COMMON_COMMANDS, 
                             pObjectEntry->pParserTable, 
                             &pNewCommandArgs);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);

            break;
        }
        

        //
        //Parse the Input
        //
        PARSE_ERROR Error;
        if(!ParseCmd(pNewCommandArgs,
                     argc-1, 
                     pToken+1,
                     pObjectEntry->nUsageID, 
                     &Error,
                     TRUE))
        {
            if(Error.ErrorSource == ERROR_FROM_PARSER 
               && Error.Error == PARSE_ERROR_HELP_SWITCH)
            {
                hr = S_OK;
                break;            
            }
			hr = E_INVALIDARG;
			DisplayMessage(pObjectEntry->nUsageID);
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);

            break;
        }

        //
        // Check to see if we are doing debug spew
        //
#ifdef DBG
        bool bDebugging = pNewCommandArgs[eCommDebug].bDefined && 
                          pNewCommandArgs[eCommDebug].nValue;
        if (bDebugging)
        {
           ENABLE_DEBUG_OUTPUT(pNewCommandArgs[eCommDebug].nValue);
        }
#else
        DISABLE_DEBUG_OUTPUT();
#endif

        //
        // Set the global quiet flag
        //
        g_bQuiet = pNewCommandArgs[eCommQuiet].bDefined &&
                   pNewCommandArgs[eCommQuiet].bValue;

		//
		//
		//
		if(pNewCommandArgs[eCommLimit].bDefined)
		{
			g_iQueryLimit = pNewCommandArgs[eCommLimit].nValue;
			g_bDeafultLimit = false;
		}
		

        GLOBAL_INFO common_info;
        common_info.scope = ADS_SCOPE_SUBTREE;
        common_info.outputFormat = DSQUERY_OUTPUT_DN;
        
        //
        // Do extra validation like switch dependency check etc.
        // Also collect Query Scope and Output format
        //
        hr = DoQueryValidation(pNewCommandArgs,
                               pObjectEntry,
                               &common_info);
        if (FAILED(hr))
            break;

        //
        // Command line parsing succeeded
        //
        hr = DoQuery(pNewCommandArgs, 
                     pObjectEntry,
                     &common_info);
        if(FAILED(hr))
            break;
         

    } while (false);    //False Loop

    //
    //Do the CleanUp
    //

    //
    // Free the memory associated with the command values
    //
    if(pNewCommandArgs)
        FreeCmd(pNewCommandArgs);

    //
    // Free the tokens
    //
    if (pToken)
    {
        delete[] pToken;
        pToken = 0;
    }
   

    //
    // Uninitialize COM
    //
    CoUninitialize();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoQueryValidation
//
//  Synopsis:   Checks to be sure that command line switches that are mutually
//              exclusive are not both present and those that are dependent are
//              both presetn, and other validations which cannot be done by parser.
//
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be queryied
//              [pcommon_info - OUT]: gets scope and output format info
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT DoQueryValidation(IN PARG_RECORD pCommandArgs,
                          IN PDSQueryObjectTableEntry pObjectEntry,
                          OUT PGLOBAL_INFO pcommon_info)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoQueryValidation, hr);

    if (!pCommandArgs || !pObjectEntry || !pcommon_info)
    {
        ASSERT(pCommandArgs);
        ASSERT(pObjectEntry);
        ASSERT(pcommon_info);
        hr = E_INVALIDARG;
        return hr;
    }

    //
    //Validate OutputFormat for "dsquery objectType"
    //
    if(_wcsicmp(pObjectEntry->pszCommandLineObjectType,g_pszStar))
    {        
        DEBUG_OUTPUT(MINIMAL_LOGGING, L"dsquery <objectType> processing will be performed");

        if(pCommandArgs[eCommOutputFormat].bDefined &&
           pCommandArgs[eCommOutputFormat].strValue)
        {
            //
            //ppValidOutput contains the validoutput type for a 
            //given object type
            //
            ASSERT(pObjectEntry->ppValidOutput);
            BOOL bMatch = FALSE;
            for(UINT i = 0; i < pObjectEntry->dwOutputCount; ++i)             
            {
                if(_wcsicmp(pCommandArgs[eCommOutputFormat].strValue,
                            pObjectEntry->ppValidOutput[i]->pszOutputFormat) == 0 )
                {
                    bMatch = TRUE;
                    pcommon_info->outputFormat = pObjectEntry->ppValidOutput[i]->outputFormat;
                    break;
                }
            }
            if(!bMatch)
            {
                DisplayMessage(pObjectEntry->nUsageID);
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

                return hr;
            }
        }
        //
        //default output format is DN
        //
        else 
            pcommon_info->outputFormat = DSQUERY_OUTPUT_DN;
    }
    else
    {
        //
        //-o is invalid switch form dsquery *, but since its 
        //common for all other objects its kept in common table 
        //and we do the special casing for dsquery *
        //
        if(pCommandArgs[eCommOutputFormat].bDefined &&
           pCommandArgs[eCommOutputFormat].strValue)
        {
            DisplayMessage(pObjectEntry->nUsageID);
            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
            return hr;
        }

        DEBUG_OUTPUT(MINIMAL_LOGGING, L"dsquery * processing will be performed");
		if(pCommandArgs[eStarAttrsOnly].bDefined)
			pcommon_info->outputFormat = DSQUERY_OUTPUT_ATTRONLY;
		else
			pcommon_info->outputFormat = DSQUERY_OUTPUT_ATTR;
    }

    //
    //Validate Scope string.    
    //default scope is subtree.
    //
    pcommon_info->scope = ADS_SCOPE_SUBTREE;     
    if(pObjectEntry->nScopeID != -1)
    {
        if( pCommandArgs[pObjectEntry->nScopeID].bDefined &&
            pCommandArgs[pObjectEntry->nScopeID].strValue )
        {
            LPCWSTR pszScope = pCommandArgs[pObjectEntry->nScopeID].strValue;
            if( _wcsicmp(pszScope,g_pszSubTree) == 0 )
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING, L"scope = subtree");
                pcommon_info->scope = ADS_SCOPE_SUBTREE;     
            }
            else if( _wcsicmp(pszScope,g_pszOneLevel) == 0 )
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING, L"scope = onelevel");
                pcommon_info->scope = ADS_SCOPE_ONELEVEL;     
            }
            else if( _wcsicmp(pszScope,g_pszBase) == 0 )
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING, L"scope = base");
                pcommon_info->scope = ADS_SCOPE_BASE;    
            }
            else
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING, L"Unknown scope = %s", pszScope);
                DisplayMessage(pObjectEntry->nUsageID);
                hr = E_INVALIDARG;
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);

                return hr;
            }
        }
    }
	
	//
	//Limit must be 0 or greater
	//
	if(pCommandArgs[eCommLimit].bDefined)
	{
		if(pCommandArgs[eCommLimit].nValue < 0)
		{
			DisplayMessage(pObjectEntry->nUsageID);
            hr = E_INVALIDARG;
            DisplayErrorMessage(g_pszDSCommandName, 
								NULL,
                                hr);
			return hr;
		}
	}

    
    //    
    //Forestwide Search implies the -GC switch so define it if it isn't already
    //
    if(pCommandArgs[eCommStartNode].bDefined &&
       pCommandArgs[eCommStartNode].strValue )
    {
        if(_wcsicmp(pCommandArgs[eCommStartNode].strValue,g_pszForestRoot) == 0)
        {
            if(!(pCommandArgs[eCommGC].bDefined &&
                 pCommandArgs[eCommGC].bValue))
            {
                pCommandArgs[eCommGC].bDefined = TRUE;
                pCommandArgs[eCommGC].bValue = TRUE;
            }
        }
    }

	//
	//For dsquery server, if none of the -domain, -forest, -site is 
	//specified, then define -domain as its default
	//
	if(!_wcsicmp(pObjectEntry->pszCommandLineObjectType,g_pszServer))
	{
		//
		//Value is assigned in DoQuery function
		//
		if(!pCommandArgs[eServerDomain].bDefined &&
		   !pCommandArgs[eServerForest].bDefined &&
		   !pCommandArgs[eServerSite].bDefined)
		{		   
		   pCommandArgs[eServerDomain].bDefined = TRUE;
		}			
	}		


    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Does the query
//  Arguments:  [pCommandArgs - IN] : the command line argument structure used
//                                    to retrieve the values for each switch
//              [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//              [pcommon_info - IN] : scope and outputformat info
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT DoQuery(PARG_RECORD pCommandArgs, 
                PDSQueryObjectTableEntry pObjectEntry,
                PGLOBAL_INFO pcommon_info)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, DoQuery, hr);

    if (!pCommandArgs || !pObjectEntry || !pcommon_info)
    {
        ASSERT(pCommandArgs);
        ASSERT(pObjectEntry);
        ASSERT(pcommon_info);
        hr = E_INVALIDARG;
        return hr;
    }

    CDSCmdCredentialObject credentialObject;
    if (pCommandArgs[eCommUserName].bDefined)
    {
        credentialObject.SetUsername(pCommandArgs[eCommUserName].strValue);
        credentialObject.SetUsingCredentials(true);
    }

    if (pCommandArgs[eCommPassword].bDefined)
    {
        credentialObject.SetPassword(pCommandArgs[eCommPassword].strValue);
        credentialObject.SetUsingCredentials(true);
    }

    //
    // Initialize the base paths info from the command line args
    // 
    CDSCmdBasePathsInfo basePathsInfo;
    if (pCommandArgs[eCommServer].bDefined)
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, 
                                              pCommandArgs[eCommServer].strValue,
                                              true);
    }
    else if (pCommandArgs[eCommDomain].bDefined)
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, 
                                              pCommandArgs[eCommDomain].strValue,
                                              false);
    }
    else
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, NULL, false);
    }

    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }

    //
    //Check if to search GC and get the search root path
    //    
    BOOL bSearchAtGC = FALSE;
    BOOL bSearchAtForestRoot = FALSE;
    CComBSTR sbstrObjectDN;

	hr = GetSearchRoot(pObjectEntry,
					   pCommandArgs,
                       basePathsInfo,
					   sbstrObjectDN,
					   &bSearchAtForestRoot,
					   &bSearchAtGC);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }

    
    DEBUG_OUTPUT(MINIMAL_LOGGING, L"start node = %s", sbstrObjectDN);

    //
    //Build The Filter For Query
    //
    
	PVOID pParam = NULL;
	if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszSubnet) == 0)
	{
		CComBSTR strSubSiteSuffix;
		GetSiteContainerPath(basePathsInfo, strSubSiteSuffix);
		pParam = (PVOID)&strSubSiteSuffix;
	}		

	CComBSTR strLDAPFilter;
    hr = BuildQueryFilter(pCommandArgs, 
                          pObjectEntry,
						  pParam,
                          strLDAPFilter);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }



    //
    //Create The IDirectorySearchObject
    //
    CComPtr<IDirectorySearch> spSearchObject;
	hr = GetSearchObject(pObjectEntry,
                         basePathsInfo,
						 pCommandArgs,
						 credentialObject,
						 sbstrObjectDN,
						 bSearchAtForestRoot,
						 bSearchAtGC,
						 spSearchObject);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }



    
    //
    //Get the arributes to fetch
    //
    LPWSTR *ppszAttributes = NULL;
    DWORD dwCountAttr = 0;
    hr = GetAttributesToFetch(pcommon_info,
                              pCommandArgs,
                              pObjectEntry,
                              &ppszAttributes,
                              &dwCountAttr);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }

    //
    //Lets Query Now
    //
    CDSSearch searchObject;
    hr = searchObject.Init(spSearchObject);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING, 
                     L"Initializing search object failed: hr = 0x%x",
                     hr);
        FreeAttributesToFetch(ppszAttributes, dwCountAttr);
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }

    searchObject.SetFilterString(strLDAPFilter);
    searchObject.SetSearchScope(pcommon_info->scope);
    searchObject.SetAttributeList(ppszAttributes,dwCountAttr?dwCountAttr:-1);
    hr = searchObject.DoQuery();
    if(FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING, L"DoQuery failed hr = 0x%x", hr);
        FreeAttributesToFetch(ppszAttributes,dwCountAttr);
        DisplayErrorMessage(g_pszDSCommandName, 
                            NULL,
                            hr);
        return hr;
    }        
    //
    //Find out the display format for dsquery *
    //It can be either List or Table
    //
    BOOL bListFormat = TRUE;
    if(pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTR)
    {     
        //
        //If all attributes are to be displayed, only List Format is valid
        //If attributes to fetch are specified at commandline, Table is default format.   
        if(dwCountAttr && 
           !pCommandArgs[eStarList].bDefined)
            bListFormat = FALSE;
    }
          
    bool bUseStandardOutput = true;
    if (pCommandArgs[eCommObjectType].bDefined &&
        _wcsicmp(pCommandArgs[eCommObjectType].strValue, g_pszServer) == 0)
    {
        //
        // "dsquery server" requires additional processing if either the
        // -isgc or the -hasfsmo switch is specified
        //
        if ((pCommandArgs[eServerIsGC].bDefined && pCommandArgs[eServerIsGC].bValue) ||
            (pCommandArgs[eServerHasFSMO].bDefined && pCommandArgs[eServerHasFSMO].strValue)||
            (pCommandArgs[eServerDomain].bDefined && pCommandArgs[eServerDomain].strValue))
        {
            bUseStandardOutput = false;
            hr = DsQueryServerOutput(pcommon_info->outputFormat,
                                     ppszAttributes,
                                     dwCountAttr,
                                     searchObject,
                                     credentialObject,
                                     basePathsInfo,
                                     pCommandArgs);
            if (FAILED(hr))
            {
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);
            }

        }
    }

    if (bUseStandardOutput)
    {
        //
        //Output the result of search       
        //
        hr = DsQueryOutput(pcommon_info->outputFormat,
                           ppszAttributes,
                           dwCountAttr,
                           &searchObject,
                           bListFormat);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
        }
    }

    FreeAttributesToFetch(ppszAttributes,dwCountAttr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetAttributesToFetch
//
//  Synopsis:   Make an array of attributes to fetch.
//  Arguments:  [pcommon_info - IN] : outputformat and scope info
//              [ppszAttributes - OUT] : array of attributes to fetch
//              [pCount - OUT] : count of attributes in array 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetAttributesToFetch(IN PGLOBAL_INFO pcommon_info,
                             IN PARG_RECORD pCommandArgs,
                             IN PDSQueryObjectTableEntry pObjectEntry,
                             OUT LPWSTR **ppszAttributes,
                             OUT DWORD * pCount)
{
    ENTER_FUNCTION_HR(MINIMAL_LOGGING, GetAttributesToFetch, hr);

    if(!pcommon_info || !pCommandArgs || !pObjectEntry)
    {   
        ASSERT(pcommon_info);
        ASSERT(pCommandArgs);
        ASSERT(pObjectEntry);
        hr = E_INVALIDARG;
        return hr;
    }

    if(pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTR ||
	   pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTRONLY)
    {
        if(pCommandArgs[eStarAttr].bDefined)
        {
            //                
            //If input is "*", fetch all attributes
            //
            if(wcscmp(pCommandArgs[eStarAttr].strValue,L"*") == 0 )
            {
                *ppszAttributes = NULL;
                *pCount = 0;
                return hr;
            }
            

			LPWSTR *ppszTemp = NULL;
            UINT argc = 0;
			ParseNullSeparatedString(pCommandArgs[eStarAttr].strValue,
								     &ppszTemp,
								     &argc);


            LPWSTR *ppszAttr = (LPWSTR *)LocalAlloc(LPTR,argc*sizeof(LPCTSTR));
            if(!ppszAttr)
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            for(UINT i = 0; i < argc; ++i)
            {
                if(FAILED(LocalCopyString(ppszAttr+i, ppszTemp[i])))
                {
                    LocalFree(ppszAttr);
                    hr = E_OUTOFMEMORY;
                    return hr;
                }
            }
            *ppszAttributes = ppszAttr;
            *pCount = argc;
			if(ppszTemp)
				LocalFree(ppszTemp);
            hr = S_OK;
            return hr;

        }
    }
    
    
    LPCWSTR pszAttr = NULL;
	if(pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTR)
    {   
		//
        //If eStarAttr is not defined, Fetch only DN
        pcommon_info->outputFormat = DSQUERY_OUTPUT_DN;
		pszAttr = g_szAttrDistinguishedName;
    }
	else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_ATTRONLY)	
		pszAttr = g_szAttrDistinguishedName;
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_DN)           
        pszAttr = g_szAttrDistinguishedName;
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_UPN)
        pszAttr = g_szAttrUserPrincipalName;
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_SAMID)
        pszAttr = g_szAttrSamAccountName;
    else if(pcommon_info->outputFormat == DSQUERY_OUTPUT_RDN)
        pszAttr = g_szAttrRDN;

    //
    // Always include the DN in the search results as well.  It is quite useful.
    //
    size_t entries = 2;
    if (pCommandArgs[eServerDomain].bDefined &&
        pCommandArgs[eServerDomain].strValue)
    {
       // 
       // If the scope is DOMAIN then add an addition space for the serverReference
       ++entries;
    }

    LPWSTR *ppszAttr = (LPWSTR *)LocalAlloc(LPTR,sizeof(LPWSTR) * entries);
    if(!ppszAttr)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    ZeroMemory(ppszAttr, sizeof(LPWSTR) * entries);

    if(FAILED(LocalCopyString(ppszAttr,pszAttr)))
    {
        LocalFree(ppszAttr);
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //
    // Always include the DN in the search results as well.  It is quite useful.
    //
    if (FAILED(LocalCopyString(&(ppszAttr[1]), g_szAttrDistinguishedName)))
    {
        LocalFree(ppszAttr);
        hr = E_OUTOFMEMORY;
        return hr;
    }

    if (pCommandArgs[eServerDomain].bDefined &&
        pCommandArgs[eServerDomain].strValue)
    {
       ASSERT(entries >= 3);
       if (FAILED(LocalCopyString(&(ppszAttr[2]), g_szAttrServerReference)))
       {
          LocalFree(ppszAttr);
          hr = E_OUTOFMEMORY;
          return hr;
       }
    }

    *ppszAttributes = ppszAttr;
    *pCount = static_cast<DWORD>(entries);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   FreeAttributesToFetch
//
//  Synopsis:   Function to free memory allocated by GetAttributesToFetch
//  Arguments:  [dwszAttributes - in] : array of attributes to fetch
//              [dwCount - in] : count of attributes in array 
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
VOID FreeAttributesToFetch( IN LPWSTR *ppszAttributes,
                            IN DWORD  dwCount)
{
    while(dwCount)
    {
        LocalFree(ppszAttributes[--dwCount]);
    }
    LocalFree(ppszAttributes);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetSearchRoot
//
//  Synopsis:   Builds the path to the root of the search as determined by
//              the parameters passed in from the command line.
//
//  Arguments:  [pObjectEntry - IN] : pointer to the object table entry for the
//                                    object type that will be modified
//				[pCommandArgs IN]     : the table of the command line input
//              [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//				[pbSearchAtForestRoot] :Set to true is startnode is equal to 
//									    forestroot
//
//  Returns:    HRESULT 
//
//  History:    24-April-2001   hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT GetSearchRoot(IN IN PDSQueryObjectTableEntry pObjectEntry,
					  IN PARG_RECORD               pCommandArgs,
                      IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                      OUT CComBSTR&                refsbstrDN,
					  OUT BOOL *pbSearchAtForestRoot,
					  OUT BOOL *pbSearchAtGC)
{
	if(!pCommandArgs || 
		!pObjectEntry || 
		!pbSearchAtForestRoot || 
		!pbSearchAtGC)
	{		
		return E_POINTER;
	}

    PWSTR pszInputDN = NULL;

	if(pCommandArgs[eCommGC].bDefined &&
	   pCommandArgs[eCommGC].bValue)
    {
        DEBUG_OUTPUT(LEVEL5_LOGGING, L"Searching the GC");
        *pbSearchAtGC = TRUE;
    }

   
    //
    //Get the starting node
    //
    if(pCommandArgs[eCommStartNode].bDefined &&
       pCommandArgs[eCommStartNode].strValue )
    {
        pszInputDN = pCommandArgs[eCommStartNode].strValue;
        if(_wcsicmp(pszInputDN,g_pszDomainRoot) == 0)
        {
            refsbstrDN = refBasePathsInfo.GetDefaultNamingContext();
        }
        else if(_wcsicmp(pszInputDN,g_pszForestRoot) == 0)
        {   
            *pbSearchAtForestRoot = TRUE;
        }
        else
        {   
            //
            //DN is entered
            //
            refsbstrDN = pszInputDN;
        }
    }   
    else
    {   
        if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszServer) == 0)
        {
			if (pCommandArgs[eServerDomain].bDefined && 
				!pCommandArgs[eServerDomain].strValue)
			{
				PWSTR pszName = 0;
				PWSTR pszDomainName = refBasePathsInfo.GetDefaultNamingContext();
				HRESULT hr = CrackName(pszDomainName,
								       &pszName,
									   GET_DNS_DOMAIN_NAME,
									   NULL);
				if (FAILED(hr))
				{
					DEBUG_OUTPUT(LEVEL3_LOGGING,
								 L"Failed to crack the DN into a domain name: hr = 0x%x",
								 hr);
					DisplayErrorMessage(g_pszDSCommandName, 
										NULL,
										hr);
					return hr;

				}
				pCommandArgs[eServerDomain].strValue = pszName;
			}				

            //
            // Get the base path that corresponds with the scope
            //
            GetServerSearchRoot(pCommandArgs,
                                refBasePathsInfo,
                                refsbstrDN);
        }
        else if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszSite) == 0)
        {
            //
            // Scope is the configuration container
            //
            refsbstrDN = refBasePathsInfo.GetConfigurationNamingContext();
        }
		else if (_wcsicmp(pObjectEntry->pszObjectClass, g_pszSubnet) == 0)
        {
            //
            // Get the base path that corresponds with the scope
            //
            GetSubnetSearchRoot(refBasePathsInfo,
                                refsbstrDN);
        }
        else
        {
            //
            //default is Domain DN
            //
            refsbstrDN = refBasePathsInfo.GetDefaultNamingContext();
        }
    }
	return S_OK;
}

HRESULT GetSearchObject(IN IN PDSQueryObjectTableEntry pObjectEntry,
                        IN CDSCmdBasePathsInfo& refBasePathsInfo,
						IN PARG_RECORD pCommandArgs,
						IN CDSCmdCredentialObject& refCredentialObject,
						IN CComBSTR& refsbstrDN,
						IN BOOL bSearchAtForestRoot,
						IN BOOL bSearchAtGC,
						OUT CComPtr<IDirectorySearch>& refspSearchObject)
{

	HRESULT hr = S_OK;

	if(!pObjectEntry || !pCommandArgs)
		return E_POINTER;

    if(!bSearchAtForestRoot)
    {
        CComBSTR sbstrObjectPath; 
        bool bBindToServer = true;
        if(bSearchAtGC)
        {    
            //
            //Change the provider in sbstrObjectPath from LDAP to GC
            //
            CComPtr<IADsPathname> spPathNameObject;
            hr = CoCreateInstance(CLSID_Pathname,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname,
                                  (LPVOID*)&spPathNameObject);
            if (FAILED(hr))
            {
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);
                return hr;
            }

            //Set Provider to GC
            hr = spPathNameObject->Set(L"GC", ADS_SETTYPE_PROVIDER);
            ASSERT(SUCCEEDED(hr));

            //Set the DN
            hr = spPathNameObject->Set(refsbstrDN, ADS_SETTYPE_DN);
            ASSERT(SUCCEEDED(hr));

            hr = spPathNameObject->Retrieve(ADS_FORMAT_X500_NO_SERVER, &sbstrObjectPath);
            ASSERT(SUCCEEDED(hr));

            //
            //No server name in path
            //
            bBindToServer = false;
        }        
        else
        {
            //
            // Convert the DN to an ADSI path
            //
            refBasePathsInfo.ComposePathFromDN(refsbstrDN, sbstrObjectPath);            
            
            if((_wcsicmp(pObjectEntry->pszObjectClass, g_pszUser) == 0 &&
                pCommandArgs[eUserInactive].bDefined) ||
               (_wcsicmp(pObjectEntry->pszObjectClass, g_pszComputer) == 0 && 
                pCommandArgs[eComputerInactive].bDefined))
            {
                INT nDomainBehaviorVersion = 0;
                CComPtr<IADs> spDomain;
                CComBSTR sbstrBasePath; 
                refBasePathsInfo.ComposePathFromDN(refBasePathsInfo.GetDefaultNamingContext(),
                                                sbstrBasePath);
                hr = DSCmdOpenObject(refCredentialObject,
                                     sbstrBasePath,
                                     IID_IADs,
                                     (void**)&spDomain,
                                     bBindToServer);  
                                                     
                
                if (FAILED(hr))
                {
                  nDomainBehaviorVersion = 0;
                }

                CComVariant varVer;
                hr = spDomain->GetInfo();

				if(SUCCEEDED(hr))
				{
					CComBSTR bstrVer = L"msDS-Behavior-Version";
					hr = spDomain->Get(bstrVer, &varVer);
				}
                
                if (FAILED(hr))
                {
                  nDomainBehaviorVersion = 0;                  
                }
				else
				{					
					ASSERT(varVer.vt == VT_I4);
					nDomainBehaviorVersion = static_cast<UINT>(varVer.lVal);
				}
                
				if(nDomainBehaviorVersion == 0)
                {
                    DisplayMessage(pObjectEntry->nUsageID);
                    DisplayErrorMessage(g_pszDSCommandName, 
                                        NULL,
                                        hr,
                                        IDS_FILTER_LAST_LOGON_VERSION);                    
                    hr = E_INVALIDARG;

                    return hr;
                                                           
                }
            }
        }

        hr = DSCmdOpenObject(refCredentialObject,
                             sbstrObjectPath,
                             IID_IDirectorySearch,
                             (void**)&refspSearchObject,
                             bBindToServer);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
            return hr;
        }
    }
    else
    { 
        //
        //BIND to GC to search entire forest
        //        
        CComPtr<IADsContainer> spContainer;
        hr = DSCmdOpenObject(refCredentialObject,
                             L"GC:",
                             IID_IADsContainer,
                             (void**)&spContainer,
                              false);

        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
            return hr;
        }
        //
        // Get an enumeration interface for the GC container to enumerate the 
        // contents. The "real" GC is the only child of the GC container.
        //
        CComPtr<IEnumVARIANT> spEnum = NULL;
        hr = ADsBuildEnumerator(spContainer, &spEnum);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
            return hr;
        }
        
        //
        // Now enumerate. There's only one child of the GC: object.
        //
        VARIANT var;
        ULONG lFetch;

        hr = spEnum->Next(1, &var, &lFetch);
        if (FAILED(hr))
        {
            DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
            return hr;
        }
 
        // Get the IDirectorySearch pointer.
        if (lFetch == 1)     
        {    
            CComPtr<IDispatch> spDisp = V_DISPATCH(&var);
            hr = spDisp->QueryInterface( IID_IDirectorySearch, (void**)&refspSearchObject); 
            if (FAILED(hr))
            {
                DisplayErrorMessage(g_pszDSCommandName, 
                                    NULL,
                                    hr);
                return hr;
            }

        }
		else
		{
			//
			//Need to put a better message here
			//			
			DisplayErrorMessage(g_pszDSCommandName, 
                                NULL,
                                hr);
			return E_FAIL;
		}
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   24-Sep-2000    hiteshr  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

//
// The command line executable name
//
extern PCWSTR g_pszDSCommandName;

//
// Object types as are typed on the command line
//
extern PCWSTR g_pszStar;
extern PCWSTR g_pszOU;
extern PCWSTR g_pszUser;
extern PCWSTR g_pszContact;
extern PCWSTR g_pszComputer;
extern PCWSTR g_pszGroup;   
extern PCWSTR g_pszServer;
extern PCWSTR g_pszSite;
extern PCWSTR g_pszSubnet;

//
// Common switches
//
extern PCWSTR c_sz_arg1_com_debug;
extern PCWSTR c_sz_arg1_com_help;
extern PCWSTR c_sz_arg2_com_help;
extern PCWSTR c_sz_arg1_com_server;
extern PCWSTR c_sz_arg2_com_server;
extern PCWSTR c_sz_arg1_com_domain;
extern PCWSTR c_sz_arg2_com_domain;
extern PCWSTR c_sz_arg1_com_username;
extern PCWSTR c_sz_arg2_com_username;
extern PCWSTR c_sz_arg1_com_password;
extern PCWSTR c_sz_arg2_com_password;
extern PCWSTR c_sz_arg1_com_quiet;
extern PCWSTR c_sz_arg1_com_objecttype;
extern PCWSTR c_sz_arg1_com_recurse;
extern PCWSTR c_sz_arg1_com_gc;
extern PCWSTR c_sz_arg1_com_output;
extern PCWSTR c_sz_arg1_com_startnode;
extern PCWSTR c_sz_arg1_com_limit;
;
//;
// Star switches;
//
extern PCWSTR g_pszArg1StarScope;
extern PCWSTR g_pszArg1StarFilter;
extern PCWSTR g_pszArg1StarAttr;
extern PCWSTR g_pszArg1StarAttrsOnly;
extern PCWSTR g_pszArg1StarList;

//
// User switches
//
extern PCWSTR g_pszArg1UserScope;
extern PCWSTR g_pszArg1UserName;
extern PCWSTR g_pszArg1UserDesc;
extern PCWSTR g_pszArg1UserUpn;
extern PCWSTR g_pszArg1UserSamid;
extern PCWSTR g_pszArg1UserInactive;
extern PCWSTR g_pszArg1UserDisabled;
extern PCWSTR g_pszArg1UserStalepwd;

//
// Computer switches
//
extern PCWSTR g_pszArg1ComputerScope;
extern PCWSTR g_pszArg1ComputerName;
extern PCWSTR g_pszArg1ComputerDesc;
extern PCWSTR g_pszArg1ComputerSamid;
extern PCWSTR g_pszArg1ComputerInactive;
extern PCWSTR g_pszArg1ComputerDisabled;
extern PCWSTR g_pszArg1ComputerStalepwd;
//
// Group switches
//
extern PCWSTR g_pszArg1GroupScope;
extern PCWSTR g_pszArg1GroupName;
extern PCWSTR g_pszArg1GroupDesc;
extern PCWSTR g_pszArg1GroupSamid;

//
// Ou switches
//
extern PCWSTR g_pszArg1OUScope;
extern PCWSTR g_pszArg1OUName;
extern PCWSTR g_pszArg1OUDesc;

//
// Server switches
//
extern PCWSTR g_pszArg1ServerForest;
extern PCWSTR g_pszArg1ServerSite;
extern PCWSTR g_pszArg1ServerName;
extern PCWSTR g_pszArg1ServerDesc;
extern PCWSTR g_pszArg1ServerHasFSMO;
extern PCWSTR g_pszArg1ServerIsGC;

//
// Site switches
//
extern PCWSTR g_pszArg1SiteName;
extern PCWSTR g_pszArg1SiteDesc;

//
// Subnet switches
//
extern PCWSTR g_pszArg1SubnetName;
extern PCWSTR g_pszArg1SubnetDesc;
extern PCWSTR g_pszArg1SubnetLoc;
extern PCWSTR g_pszArg1SubnetSite;

//
// Valid Output formats{dn, rdn, upn, samid, ntlmid} 
//
extern PCWSTR g_pszDN;
extern PCWSTR g_pszRDN;
extern PCWSTR g_pszUPN;
extern PCWSTR g_pszSamId;
extern PCWSTR g_pszNtlmId;

//
//Valid Scope Strings
//
extern PCWSTR g_pszSubTree;
extern PCWSTR g_pszOneLevel;
extern PCWSTR g_pszBase;

//Default Filter and Prefix filter
extern PCWSTR g_pszDefStarFilter;
extern PCWSTR g_pszDefUserFilter;
extern PCWSTR g_pszDefComputerFilter;
extern PCWSTR g_pszDefGroupFilter;
extern PCWSTR g_pszDefOUFilter;
extern PCWSTR g_pszDefServerFilter;
extern PCWSTR g_pszDefSiteFilter;
extern PCWSTR g_pszDefSubnetFilter;
extern PCWSTR g_pszDefContactFilter;

//Valid start node values
extern PCWSTR g_pszDomainRoot;
extern PCWSTR g_pszForestRoot;
extern PCWSTR g_pszSiteRoot;

//Attributes to fetch
extern PCWSTR g_szAttrDistinguishedName;
extern PCWSTR g_szAttrUserPrincipalName;
extern PCWSTR g_szAttrSamAccountName;
extern PCWSTR g_szAttrRDN;
extern PCWSTR g_szAttrServerReference;

// FSMOs
extern PCWSTR g_pszSchema;
extern PCWSTR g_pszName;
extern PCWSTR g_pszInfr;
extern PCWSTR g_pszPDC;
extern PCWSTR g_pszRID;


#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\output.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      output.cpp
//
//  Contents:  Defines the functions which displays the query output
//  History:   05-OCT-2000    hiteshr  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "usage.h"
#include "querytable.h"
#include "querybld.h"
#include "dsquery.h"
#include "query.h"
#include "resource.h"
#include "stdlib.h"
#include "output.h"
#include "sddl.h"

#include <dscmn.h>

//
// list was causing unused formal parameter warnings when compiling with /W4
//
#pragma warning(disable : 4100)
#include <list>
#pragma warning(default : 4100)

HRESULT GetStringFromADs(const ADSVALUE *pValues,
                         ADSTYPE   dwADsType,
                         LPWSTR pBuffer, 
                         DWORD dwBufferLen,
						 LPCWSTR lpszAttrName);

HRESULT OutputFetchAttr(IN LPWSTR * ppszAttributes,
                        IN DWORD cAttributes,
                        IN CDSSearch *pSearch,
                        IN BOOL bListFormat);

HRESULT OutputAllAttr(IN CDSSearch *pSearch, BOOL bAttrOnly);


HRESULT OutputSingleAttr(IN LPWSTR * ppszAttributes,
                         IN DWORD cAttributes,
                         IN CDSSearch *pSearch);

BOOL IsQueryLimitReached(int iResultsDisplayed)
{
	if(g_iQueryLimit != 0)
	{
		if(iResultsDisplayed == g_iQueryLimit)
		{
			if(!g_bQuiet)
			{
				if(g_bDeafultLimit)
					WriteStringIDToStandardOut(IDS_DEFAULT_QUERY_LIMIT_REACHED);
				else
					WriteStringIDToStandardOut(IDS_QUERY_LIMIT_REACHED);
			}
			return TRUE;
		}
	}
	return FALSE;
}


HRESULT LocalCopyString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (wcslen(pString)+1)*sizeof(WCHAR) );

    if ( !*ppResult )
        return E_OUTOFMEMORY;

    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success
}


//+--------------------------------------------------------------------------
//
//  Function:   DisplayList
//
//  Synopsis:   Dispalys a name and value in list format.
//  Arguments:  [szName - IN] : name of the attribute
//              [szValue - IN]: value of the attribute
//              [bShowAttribute - IN] : if true the attribute name will be
//                              prepended to the output
//
//
//  History:    05-OCT-2000   hiteshr   Created
//              13-Dec-2000   JeffJon   Modified - Added the bShowAttribute flag
//                                      so that the caller can determine whether
//                                      or not to show the attribute name
//
//---------------------------------------------------------------------------
VOID DisplayList(LPCWSTR szName, LPCWSTR szValue, bool bShowAttribute = true)
{
    if(!szName)
        return;
    CComBSTR strTemp;
    if (bShowAttribute)
    {
      strTemp = szName;
      strTemp += L": ";
    }
    if(szValue)
        strTemp += szValue;
    DisplayOutput(strTemp);
}
    

//+--------------------------------------------------------------------------
//
//  Function:   DsQueryOutput
//
//  Synopsis:   This functions outputs the query results.
//
//  Arguments:  [outputFormat IN]   Output format specified at commandline.
//              [ppszAttributes IN] List of attributes fetched by query
//              [cAttributes,IN]    Number of arributes in above array
//              [*pSeach,IN]        Search Object which has queryhandle
//              [bListFormat IN]    Is Output to shown in List Format.
//                                  This is valid for "dsquery *" only.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT DsQueryOutput( IN DSQUERY_OUTPUT_FORMAT outputFormat,
                       IN LPWSTR * ppszAttributes,
                       IN DWORD cAttributes,
                       IN CDSSearch *pSearch,
                       IN BOOL bListFormat )
{    
    ENTER_FUNCTION_HR(FULL_LOGGING, DsQueryOutput, hr);

    if(!pSearch)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

	if(outputFormat == DSQUERY_OUTPUT_ATTRONLY)
	{
		hr = OutputAllAttr(pSearch, TRUE);
        return hr;
	}
    else if(outputFormat == DSQUERY_OUTPUT_ATTR)
    {   
        //
        //Attributes to display were specified at command line
        //
        if(cAttributes)
        {
            hr = OutputFetchAttr(ppszAttributes,
                                   cAttributes,
                                   pSearch,
                                   bListFormat);                            
            return hr;
        }
        else
        {   
            //
            //No attributes were specified at commandline Display All the attributes.
            //
            hr = OutputAllAttr(pSearch, FALSE);
            return hr;
        }
    }
    else
    {
        //
        //Do the output for "dsquery objecttype"
        //
        hr = OutputSingleAttr(ppszAttributes,
                              cAttributes,
                              pSearch);
        return hr;
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   GetServerSearchRoot
//
//  Synopsis:   Builds the path to the root of the search as determined by
//              the parameters passed in from the command line.
//
//  Arguments:  [pCommandArgs IN]     : the table of the command line input
//              [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//
//  Returns:    SERVER_QUERY_SCOPE : a value from the enumeration that represents
//                                   the scope that will be searched
//
//  History:    11-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
DWORD GetServerSearchRoot(IN PARG_RECORD               pCommandArgs,
                          IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                          OUT CComBSTR&                refsbstrDN)
{
    ENTER_FUNCTION(LEVEL3_LOGGING, GetServerSearchRoot);

    DWORD scope = SERVER_QUERY_SCOPE_FOREST;
    CComBSTR sbstrRootDN = L"CN=Sites,";
    sbstrRootDN += refBasePathsInfo.GetConfigurationNamingContext();
    
    do // false loop
    {
        //
        // Validate parameters
        //
        if (!pCommandArgs)
        {
            ASSERT(pCommandArgs);
            break;
        }

        if (pCommandArgs[eServerSite].bDefined &&
            pCommandArgs[eServerSite].strValue)
        {
            DEBUG_OUTPUT(FULL_LOGGING,
                         L"Using the site as the root of the search: %s",
                         pCommandArgs[eServerSite].strValue);

            //
            // Prepend the named site container to the current root
            //
            CComBSTR sbstrTemp = L"CN=";
            sbstrTemp += pCommandArgs[eServerSite].strValue;
            sbstrTemp += L",";
            sbstrTemp += sbstrRootDN;
            sbstrRootDN = sbstrTemp;

            DEBUG_OUTPUT(FULL_LOGGING,
                         L"scope = SERVER_QUERY_SCOPE_SITE");
            scope = SERVER_QUERY_SCOPE_SITE;
        }
        else
        {
            DEBUG_OUTPUT(FULL_LOGGING,
                         L"scope = SERVER_QUERY_SCOPE_FOREST");
            scope = SERVER_QUERY_SCOPE_FOREST;
        }

        if (pCommandArgs[eServerDomain].bDefined &&
			pCommandArgs[eServerDomain].strValue)
		{        
            DEBUG_OUTPUT(FULL_LOGGING,
                         L"scope |= SERVER_QUERY_SCOPE_DOMAIN");
            scope |= SERVER_QUERY_SCOPE_DOMAIN;
		}

        refsbstrDN = sbstrRootDN;
        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"search root = %s",
                     refsbstrDN);
        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"search scope = 0x%x",
                     scope);
    } while (false);

    return scope;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetSubnetSearchRoot
//
//  Synopsis:   Builds search root path for Subnet. Its always
//				cn=subnet,cn=site in configuration container
//
//  Arguments:  [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//
//  Returns:    HRESULT
//
//  History:    24-April-2001   hiteshr Created
//
//---------------------------------------------------------------------------
VOID GetSubnetSearchRoot(IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                            OUT CComBSTR&                refsbstrDN)
{
    ENTER_FUNCTION(LEVEL3_LOGGING, GetSubnetSearchRoot);

    refsbstrDN = L"CN=subnets,CN=Sites,";
    refsbstrDN += refBasePathsInfo.GetConfigurationNamingContext();
	return;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetSiteContainerPath
//
//  Synopsis:   Returns the DN for site container in Configuration
//				container
//
//  Arguments:  [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN 
//
//  Returns:    HRESULT
//
//  History:    24-April-2001   hiteshr Created
//
//---------------------------------------------------------------------------
VOID GetSiteContainerPath(IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                            OUT CComBSTR&                refSubSiteSuffix)
{
    ENTER_FUNCTION(LEVEL3_LOGGING, GetSubnetSearchRoot);

    refSubSiteSuffix = L"CN=Sites,";
    refSubSiteSuffix += refBasePathsInfo.GetConfigurationNamingContext();
	return;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetGCList
//
//  Synopsis:   Does a search from the passed in path looking for GCs
//
//  Arguments:  [pszSearchRootPath IN]  : the path to the root of the search
//              [refCredObject IN]      : reference to the credential object
//              [refGCList OUT]         : reference to an STL list that will
//                                        take the DNs of the GCs
//                                       
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  Remarks:    Caller must free all strings added to the list by calling
//              SysFreeString()
//
//  History:    08-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT GetGCList( IN  PCWSTR                   pszSearchRootPath,
                   IN  const CDSCmdCredentialObject& refCredObject,
                   OUT std::list<PWSTR>&        refGCList)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, GetGCList, hr);

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pszSearchRootPath)
        {
            ASSERT(pszSearchRootPath);

            hr = E_INVALIDARG;
            break;
        }

        //
        // Search for NTDSDSA objects that have the options bit set for a GC
        //
        CDSSearch gcSearchObj;
        hr = gcSearchObj.Init(pszSearchRootPath,
                              refCredObject);
        if (FAILED(hr))
        {
          break;
        }

        //
        // Prepare the search object
        //
        PWSTR ppszAttrs[] = { L"distinguishedName" };
        DWORD dwAttrCount = sizeof(ppszAttrs)/sizeof(PCWSTR);
        PWSTR pszGCFilter = L"(&(objectClass=nTDSDSA)(options:LDAP_MATCHING_RULE_BIT_AND_W:=1))";

        gcSearchObj.SetFilterString(pszGCFilter);
        gcSearchObj.SetSearchScope(ADS_SCOPE_SUBTREE);
        gcSearchObj.SetAttributeList(ppszAttrs, dwAttrCount);
        
        hr = gcSearchObj.DoQuery();
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Failed to search for NTDSDSA objects that are GCs: hr = 0x%x",
                         hr);
            break;
        }

        while (SUCCEEDED(hr))
        {
            hr = gcSearchObj.GetNextRow();
            if (FAILED(hr))
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"GetNextRow() failed: hr = 0x%x",
                             hr);
                break;
            }

            if (hr == S_ADS_NOMORE_ROWS)
            {
                hr = S_OK;
                break;
            }

            ADS_SEARCH_COLUMN column;
            ZeroMemory(&column, sizeof(ADS_SEARCH_COLUMN));

            hr = gcSearchObj.GetColumn(ppszAttrs[0], &column);
            if (FAILED(hr))
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"Failed to get column %s",
                             ppszAttrs[0]);
                break;
            }

            ASSERT(0 == _wcsicmp(column.pszAttrName, ppszAttrs[0]));
            if (column.dwNumValues == 1 &&
                column.pADsValues)
            { 
                //
                // Since the server is really the parent of the NTDSDSA object,
                // get the server DN and add it to the list
                //
                CComBSTR sbstrParentDN;
                hr = CPathCracker::GetParentDN(column.pADsValues->DNString, 
                                               sbstrParentDN);
                if (SUCCEEDED(hr))
                {
                    refGCList.push_back(sbstrParentDN.Copy());
                    DEBUG_OUTPUT(FULL_LOGGING,
                                 L"GC found: %s",
                                 column.pADsValues->DNString);
                }
                else
                {
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"Failed to get the parent DN from the NTDSDSA DN: %s",
                                 column.pADsValues->DNString);
                    break;
                }
            }
            else
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"The column has no values!");
            }

            hr = gcSearchObj.FreeColumn(&column);
            ASSERT(SUCCEEDED(hr));
        }
    } while (false);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetFSMOList
//
//  Synopsis:   Does a search from the passed in path looking for the FSMO
//              role owners
//
//  Arguments:  [pszSearchRootPath IN]    : the path to the root of the search
//              [refBasePathsInfo IN]     : reference to the base paths info
//              [refCredObject IN]        : reference to the credential object
//              [pszFSMOArg IN]           : the value of the -hasfsmo arg
//              [refFSMOList OUT]         : reference to the search object that
//                                          will hold the results
//                                       
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  Remarks:    Caller must free all strings added to the list by calling
//              SysFreeString()
//
//  History:    11-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT GetFSMOList( IN  PCWSTR                     pszSearchRootPath,
                     IN  CDSCmdBasePathsInfo&       refBasePathsInfo,
                     IN  const CDSCmdCredentialObject& refCredObject,
                     IN  PCWSTR                     pszFSMOArg,
                     OUT std::list<PWSTR>&          refFSMOList)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, GetFSMOList, hr);

    do // false loop
    {
        //
        // Verify parameters
        //
        if (!pszSearchRootPath ||
            !pszFSMOArg)
        {
            ASSERT(pszSearchRootPath);

            hr = E_INVALIDARG;
            break;
        }

        FSMO_TYPE fsmoType = SCHEMA_FSMO;

        if (0 == _wcsicmp(pszFSMOArg, g_pszSchema))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the schema FSMO holder");
            fsmoType = SCHEMA_FSMO;
        }
        else if (0 == _wcsicmp(pszFSMOArg, g_pszName))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the domain naming master FSMO holder");
            fsmoType = DOMAIN_NAMING_FSMO;
        }
        else if (0 == _wcsicmp(pszFSMOArg, g_pszInfr))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the infrastructure FSMO holder");
            fsmoType = INFRASTUCTURE_FSMO;
        }
        else if (0 == _wcsicmp(pszFSMOArg, g_pszPDC))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the PDC FSMO holder");
            fsmoType = PDC_FSMO;
        }
        else if (0 == _wcsicmp(pszFSMOArg, g_pszRID))
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching for the RID FSMO holder");
            fsmoType = RID_POOL_FSMO;
        }
        else
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Unknown FSMO was passed in: %s",
                         pszFSMOArg);
            hr = E_INVALIDARG;
            break;
        }

        CComBSTR sbstrServerDN;
        hr = FindFSMOOwner(refBasePathsInfo,
                           refCredObject,
                           fsmoType,
                           sbstrServerDN);
        if (FAILED(hr))
        {
            break;
        }
        refFSMOList.push_back(sbstrServerDN.Copy());
    } while (false);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsObjectValidInAllLists
//
//  Synopsis:   Determines if the passed in DN exists in the other lists
//
//  Arguments:  [pszDN IN]        : DN to search for in the lists
//              [refGCList IN]    : reference to the list of GCs found
//              [bUseGCList IN]   : if true refGCList will be used to validate DN
//              [refFSMOList IN]  : reference to the list of FSMO holders found
//              [bUseFSMOList IN] : if true refFSMOList will be used to validate DN
//
//  Returns:    bool : true if the object is in all valid lists
//                     false otherwise
//
//  History:    12-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
bool IsObjectValidInAllLists(IN PCWSTR              pszDN,
                             IN DWORD               scope,
                             IN PCWSTR              pszDomain,
                             IN const std::list<PWSTR>&   refGCList, 
                             IN bool                bUseGCList,
                             IN const std::list<PWSTR>&   refFSMOList,
                             IN bool                bUseFSMOList)
{
    ENTER_FUNCTION(LEVEL3_LOGGING, IsObjectValidInAllLists);

    bool bReturn = false;
	PWSTR pszName = 0;
    do // false loop
    {
        //
        // Validate parameters
        //
        if (!pszDN)
        {
            ASSERT(pszDN);
            return false;
        }

        bool bFoundInGCList = false;
        bool bFoundInFSMOList = false;

        DEBUG_OUTPUT(LEVEL7_LOGGING,
                     L"Searching for %s",
                     pszDN);

        if (scope & SERVER_QUERY_SCOPE_DOMAIN)
        {
            if (!pszDomain)
            {
                //
                // If no domain was specified there is no way we could find a match
                //
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"The scope is domain but no domain argument was specified!");
                bReturn = false;
                break;
            }

            DEBUG_OUTPUT(FULL_LOGGING,
                         L"Looking for domain: %s",
                         pszDomain);

            //
            // Use CrackName to get the domain name from the DN
            //
    
            HRESULT hr = CrackName(const_cast<PTSTR>(pszDN),
                                   &pszName,
                                   GET_DNS_DOMAIN_NAME,
                                   NULL);
            if (FAILED(hr))
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"Failed to crack the DN into a domain name: hr = 0x%x",
                             hr);
                bReturn = false;
                break;
            }

            if (0 != _wcsicmp(pszName, pszDomain))
            {
                DEBUG_OUTPUT(LEVEL3_LOGGING,
                             L"Domain names don't match");
                bReturn = false;
                break;
            }
        }


        if (bUseGCList)
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching through GC list...");

            std::list<PWSTR>::iterator itr;
            for (itr = refGCList.begin(); itr != refGCList.end(); ++itr)
            {
                if (0 == _wcsicmp(*itr, pszDN))
                {
                    bFoundInGCList = true;
                    break;
                }
            }
        }

        if (bUseFSMOList)
        {
            DEBUG_OUTPUT(LEVEL3_LOGGING,
                         L"Searching through FSMO list...");

            std::list<PWSTR>::iterator itr;
            for (itr = refFSMOList.begin(); itr != refFSMOList.end(); ++itr)
            {
                DEBUG_OUTPUT(FULL_LOGGING,
                             L"Comparing: %s and %s",
                             *itr,
                             pszDN);
                if (0 == _wcsicmp(*itr, pszDN))
                {
                    bFoundInFSMOList = true;
                    break;
                }
            }
        }

        bReturn = ((bUseGCList && bFoundInGCList) || !bUseGCList) &&
                  ((bUseFSMOList && bFoundInFSMOList) || !bUseFSMOList);
        
    } while (false);


	if(pszName)
		LocalFree(pszName);


    if (bReturn)
    {
        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"%s is a valid result",
                     pszDN);
    }
    else
    {
        DEBUG_OUTPUT(LEVEL3_LOGGING,
                     L"%s is NOT a valid result",
                     pszDN);
    }

    return bReturn;
}


//+--------------------------------------------------------------------------
//
//  Function:   OutputValidSearchResult
//
//  Synopsis:   Determines if the passed in DN exists in the other lists
//
//  Arguments:  [refSearchObject - IN] : reference to the object that performed
//                                       the search
//              [ppszAttributes - IN]  : list of attributes to be displayed
//              [cAttributes - IN]     : count of attributes in ppszAttributes
//
//  Returns:   
//
//  History:    12-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void OutputValidSearchResult(IN DSQUERY_OUTPUT_FORMAT outputFormat,
                             IN CDSSearch&            refSearchObject,
                             IN PWSTR*                ppszAttributes,
                             IN DWORD                 cAttributes)
{
    ENTER_FUNCTION(LEVEL5_LOGGING, OutputValidSearchResult);

    HRESULT hr = S_OK;
    WCHAR pBuffer[MAXSTR];

    if (!ppszAttributes ||
        cAttributes == 0)
    {
        ASSERT(cAttributes > 0);
        ASSERT(ppszAttributes);
        return;
    }

    //
    // Output in list format, note that we are only displaying one attribute
    // The first attribute in the array must be the one we want to display
    //
    ADS_SEARCH_COLUMN ColumnData;
    hr = refSearchObject.GetColumn(ppszAttributes[0], &ColumnData);
    if(SUCCEEDED(hr))
    {
        ADSVALUE *pValues = ColumnData.pADsValues;
        for( DWORD j = 0; j < ColumnData.dwNumValues && pValues; ++j )
        {                        
            hr = GetStringFromADs(pValues,
                                  ColumnData.dwADsType,
                                  pBuffer, 
                                  MAXSTR,
								  ppszAttributes[0]);
            if(SUCCEEDED(hr))
            {

                CComBSTR sbstrTemp;
                if (outputFormat == DSQUERY_OUTPUT_DN)
                {
                    sbstrTemp = L"\"";
                    sbstrTemp += pBuffer;
                    sbstrTemp += L"\"";
                }
                else
                {
                    sbstrTemp = pBuffer;
                }
                DisplayList(ppszAttributes[0], sbstrTemp, false);
            }
            ++pValues;
        }
        refSearchObject.FreeColumn(&ColumnData);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   DsQueryServerOutput
//
//  Synopsis:   This functions outputs the query results for server object.
//
//  Arguments:  [outputFormat IN]   Output format specified at commandline.
//              [ppszAttributes IN] List of attributes fetched by query
//              [cAttributes,IN]    Number of arributes in above array
//              [refServerSearch,IN]reference to the search Object
//              [refBasePathsInfo IN] reference to the base paths info
//              [pCommandArgs,IN]   The pointer to the commands table
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  History:    08-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DsQueryServerOutput( IN DSQUERY_OUTPUT_FORMAT     outputFormat,
                             IN LPWSTR*                   ppszAttributes,
                             IN DWORD                     cAttributes,
                             IN CDSSearch&                refServerSearch,
                             IN const CDSCmdCredentialObject&  refCredObject,
                             IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                             IN PARG_RECORD               pCommandArgs)
{    
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, DsQueryServerOutput, hr);

    std::list<PWSTR> gcList;
    std::list<PWSTR> fsmoList;

    do // false loop
    {
        //
        // Validate parameters
        //
        if (!ppszAttributes ||
            !pCommandArgs)
        {
            ASSERT(ppszAttributes);
            ASSERT(pCommandArgs);
            hr = E_INVALIDARG;
            break;
        }

        //
        // Determine the scope that should be used
        //
        CComBSTR sbstrSearchRootDN;
        DWORD scope = GetServerSearchRoot(pCommandArgs, 
                                          refBasePathsInfo,
                                          sbstrSearchRootDN);
        CComBSTR sbstrSearchRootPath;
        refBasePathsInfo.ComposePathFromDN(sbstrSearchRootDN, sbstrSearchRootPath);

        //
        // Build the list of GCs if needed
        //
        bool bUseGCSearchResults = false;
        if (pCommandArgs[eServerIsGC].bDefined &&
            pCommandArgs[eServerIsGC].bValue)
        {
            hr = GetGCList(sbstrSearchRootPath, 
                           refCredObject,
                           gcList);
            if (FAILED(hr))
            {
                break;
            }

            //
            // If we didn't get any values then there is no reason to continue
            // since we won't have anything that matches the -isgc flag
            //
            if (gcList.size() < 1)
            {
                break;
            }
            bUseGCSearchResults = true;
        }

        //
        // Build the list of FSMO owners if needed
        //
        bool bUseFSMOSearchResults = false;
        if (pCommandArgs[eServerHasFSMO].bDefined &&
            pCommandArgs[eServerHasFSMO].strValue)
        {
            hr = GetFSMOList(sbstrSearchRootPath,
                             refBasePathsInfo,
                             refCredObject,
                             pCommandArgs[eServerHasFSMO].strValue,
                             fsmoList);
            if (FAILED(hr))
            {
                break;
            }
            bUseFSMOSearchResults = true;
        }

        //
        // See if we need to filter on domain
        //
        bool bUseDomainFiltering = false;
        if (pCommandArgs[eServerDomain].bDefined &&
            pCommandArgs[eServerDomain].strValue)
        {
            bUseDomainFiltering = true;
        }

        if (!bUseGCSearchResults &&
            !bUseFSMOSearchResults &&
            !bUseDomainFiltering)
        {
            hr = DsQueryOutput(outputFormat,
                               ppszAttributes,
                               cAttributes,
                               &refServerSearch,
                               true);
        }
        else
        {
            //
            // Either -isgc or -hasfsmo was specified so we have to take the intersection
            // of the lists of objects found in each search to use as output
            //
            while (SUCCEEDED(hr))
            {
                hr = refServerSearch.GetNextRow();
                if (FAILED(hr))
                {
                    break;
                }

                if (hr == S_ADS_NOMORE_ROWS)
                {
                    hr = S_OK;
                    break;
                }
        
                ADS_SEARCH_COLUMN column;
                ZeroMemory(&column, sizeof(ADS_SEARCH_COLUMN));

                //
                // Get the DN
                //
                hr = refServerSearch.GetColumn((PWSTR)g_szAttrServerReference, &column);
                if (FAILED(hr))
                {
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"Failed to get the distinguishedName for a column: hr = 0x%x",
                                 hr);
                    DEBUG_OUTPUT(LEVEL3_LOGGING,
                                 L"continuing...");
                    hr = S_OK;
                    continue;
                }

                if (column.dwNumValues == 1 &&
                    column.pADsValues)
                {
                    //
                    // Search the lists and determine if the DN exists in all the lists
                    //
                    bool bValidEntry = IsObjectValidInAllLists(column.pADsValues->DNString,
                                                               scope,
                                                               pCommandArgs[eServerDomain].strValue,
                                                               gcList, 
                                                               bUseGCSearchResults,
                                                               fsmoList,
                                                               bUseFSMOSearchResults);
                    if (bValidEntry)
                    {
                        //
                        // Output this server object since it matches all search criteria
                        //
                        OutputValidSearchResult(outputFormat,
                                                refServerSearch,
                                                ppszAttributes,
                                                cAttributes);
                    }
                }

                hr = refServerSearch.FreeColumn(&column);
                ASSERT(SUCCEEDED(hr));
            }
        }

    } while (false);

    std::list<PWSTR>::iterator gcItr;
    for (gcItr = gcList.begin(); gcItr != gcList.end(); ++gcItr)
    {
        SysFreeString(*gcItr);
    }

    std::list<PWSTR>::iterator fsmoItr;
    for (fsmoItr = fsmoList.begin(); fsmoItr != fsmoList.end(); ++fsmoItr)
    {
        SysFreeString(*fsmoItr);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   OutputFetchAttr
//
//  Synopsis:   Dispalys the fetched attributes in either list or table format
//  Arguments:  [ppszAttributes - IN] : Array containing list of attributes to display
//              [cAttributes - IN]: Count of attributes in ppszAttributes
//              [pSearch - IN]: pointer to search object
//              [bListFormat - IN]: List or Table format
//  Returns     HRESULT  S_OK if Successful
//                       E_INVALIDARG
//                       Anything else is a failure code from an ADSI call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT OutputFetchAttr(IN LPWSTR * ppszAttributes,
                        IN DWORD cAttributes,
                        IN CDSSearch *pSearch,
                        IN BOOL bListFormat)
{
    ENTER_FUNCTION_HR(FULL_LOGGING, OutputFetchAttr, hr);

    WCHAR pBuffer[MAXSTR];
    ZeroMemory(pBuffer, sizeof(pBuffer));
        
    if(bListFormat)
    {
		//
		//Display in list format
		//
		int cListDisplayed = 0;
        while(TRUE)
        {
            hr = pSearch->GetNextRow();

			if(IsQueryLimitReached(cListDisplayed))
					break;
        
            if(hr == S_ADS_NOMORE_ROWS || FAILED(hr))
                break;

            bool bShowAttributes = false;
            if (cAttributes > 1)
            {
                bShowAttributes = true;
            }

            for(DWORD i = 0; i < cAttributes; ++i)
            {
                ADS_SEARCH_COLUMN ColumnData;
                hr = pSearch->GetColumn(ppszAttributes[i], &ColumnData);
                if(SUCCEEDED(hr))
                {
                    ADSVALUE *pValues = ColumnData.pADsValues;
                    for( DWORD j = 0; j < ColumnData.dwNumValues; ++j )
                    {                        
                        hr = GetStringFromADs(pValues,
                                              ColumnData.dwADsType,
                                              pBuffer, 
                                              MAXSTR,
											  ppszAttributes[i]);
                        if(SUCCEEDED(hr))
                            DisplayList(ppszAttributes[i], pBuffer, bShowAttributes);

                        ++pValues;
                    }
                    pSearch->FreeColumn(&ColumnData);
                }
				else if(hr == E_ADS_COLUMN_NOT_SET)
					DisplayList(ppszAttributes[i], L"", bShowAttributes);
            }
			cListDisplayed++;
			
        }
        if(hr == S_ADS_NOMORE_ROWS)
            hr = S_OK;

        return hr;
    }
    else    
    {
        //
        //Display in table format
        //

        //
        //format will use first 80 rows to calculate column width
        //
        CFormatInfo format;
        LONG sampleSize = 80;

		//
		//sampleSize should be lessthan or equal to QueryLimit
		//
		if(g_iQueryLimit != 0 && (sampleSize > g_iQueryLimit))
			sampleSize = g_iQueryLimit;		

        LONG cRow = 0;
        hr = format.Init(sampleSize,cAttributes,ppszAttributes);
		if(FAILED(hr))
			return hr;

        //
        //Display in table format
        //
        while(TRUE)
        {

            //
            //we have reached sampleSize, so display column headers and
            //display all the sample rows.
			//
            if(cRow == sampleSize)
            {
                format.DisplayHeaders();
                format.DisplayAllRows();
            }

            hr = pSearch->GetNextRow();
			//We are done
            if(hr == S_ADS_NOMORE_ROWS || FAILED(hr))
                break;

			//
			//Check if we have reached querylimit
			//
			if(IsQueryLimitReached(cRow))
				break;

            //
            //Fetch columns
            //
            for( DWORD i = 0; i < cAttributes; ++i )
            {
                ADS_SEARCH_COLUMN ColumnData;
                hr = pSearch->GetColumn(ppszAttributes[i], &ColumnData);
				CComBSTR strValue;
                if(SUCCEEDED(hr))
                {
					strValue = "";
                    ADSVALUE *pValues = ColumnData.pADsValues;                    
                    for( DWORD j = 0; j < ColumnData.dwNumValues; ++j )
                    {                        
                        hr = GetStringFromADs(pValues,
                                              ColumnData.dwADsType,
                                              pBuffer, 
                                              MAXSTR,
											  ppszAttributes[i]);
                        //
                        //In table format multiple values are shown separated by ;
                        //
                        if(SUCCEEDED(hr))
                        {
                            strValue += pBuffer;
                            if(ColumnData.dwNumValues > 1)
                            {
                                strValue += L";";              
                            }
                        }
                        ++pValues;
                    }
					pSearch->FreeColumn(&ColumnData);
				}   
				
				if(SUCCEEDED(hr) || hr == E_ADS_COLUMN_NOT_SET)
				{
                    if(cRow < sampleSize)
                    {
                        //
                        //Cache this value in format and use it to calculate column width
                        //
                        format.Set(cRow,i,strValue);
                    }
                    else 
                    {
                        //
                        //Display the column value
                        //
                        format.DisplayColumn(i,strValue);
                        if(i == (cAttributes - 1))
                            format.NewLine();

                    }                    
                }
            }
            
            ++cRow;

        }//End of while loop
        if(hr == S_ADS_NOMORE_ROWS)
            hr = S_OK;

        if(cRow && (cRow < sampleSize))
        {
            //
            //if total number of rows is less that sample size they are not 
            //displayed yet. Display them
            //
            format.DisplayHeaders();
            format.DisplayAllRows();
        }

        return hr;
    }
}



//+--------------------------------------------------------------------------
//
//  Function:   OutputSingleAttr
//
//  Synopsis:   Displays the single attribute which user has asked for.
//  Arguments:  [ppszAttributes - IN] : Array containing list of attributes to display
//              [cAttributes - IN]: Count of attributes in ppszAttributes. Should be 1
//              [pSearch - IN]: pointer to search object
//  Returns     HRESULT  S_OK if Successful
//                       E_INVALIDARG
//                       Anything else is a failure code from an ADSI call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT OutputSingleAttr(IN LPWSTR * ppszAttributes,
                         IN DWORD cAttributes,
                         IN CDSSearch *pSearch)
{
    ENTER_FUNCTION_HR(FULL_LOGGING, OutputSingleAttr, hr);

    if(!ppszAttributes || !cAttributes || !pSearch)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    ASSERT(cAttributes > 0);

    WCHAR pBuffer[MAXSTR];
    ZeroMemory(pBuffer, sizeof(pBuffer));
	LONG cRow = 0;

    while(TRUE)
    {
        hr = pSearch->GetNextRow();
        
        //We are done
        if(hr == S_ADS_NOMORE_ROWS || FAILED(hr))
            break;
		//
		//Check if we have reached querylimit
		//
		if(IsQueryLimitReached(cRow))
			break;

        ADS_SEARCH_COLUMN ColumnData;
        hr = pSearch->GetColumn(ppszAttributes[0], &ColumnData);
        if(SUCCEEDED(hr))
        {
            hr = GetStringFromADs(ColumnData.pADsValues,
                                  ColumnData.dwADsType,
                                  pBuffer, 
                                  MAXSTR,
								  ppszAttributes[0]);
            if(SUCCEEDED(hr))
            {
				//Display the output enclosed in Double Quotes
                CComBSTR strTemp;
                strTemp = L"\"" ;
                strTemp += pBuffer;
                strTemp += L"\"";
                DisplayOutput(strTemp);
			}
            pSearch->FreeColumn(&ColumnData);
        }
        else if(hr == E_ADS_COLUMN_NOT_SET)
        {
            //
            //If Attribute is not set display ""
            //
            DisplayOutput(L"\"\"");
        }
		//
		//Increment number of Row displayed
		//
		cRow++;
    }//End of while loop
    
    if(hr == S_ADS_NOMORE_ROWS)
        hr = S_OK;

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   OutputAllAttr
//
//  Synopsis:   Displays all the attributes.
//  Arguments:  [pSearch - IN]: pointer to search object
//				[bAttrOnly - IN]: display attributes names only
//  Returns     HRESULT         S_OK if Successful
//                              E_INVALIDARG
//                              Anything else is a failure code from an ADSI 
//                              call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT OutputAllAttr(IN CDSSearch *pSearch, BOOL bAttrOnly)
{
    ENTER_FUNCTION_HR(FULL_LOGGING, OutputAllAttr, hr);

    if(!pSearch)
    {        
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }
    WCHAR pBuffer[MAXSTR];
	LONG cRow = 0;

    while(TRUE)
    {
        hr = pSearch->GetNextRow();
        
        //We are done
        if(hr == S_ADS_NOMORE_ROWS || FAILED(hr))
            break;

		//
		//Check if we reached querylimit
		//
		if(IsQueryLimitReached(cRow))
			break;
        
		LPWSTR pszColumnName;
		BOOL bColumnNameDisplayed = FALSE;
        //
        //Get the name of next column which has value
        //
        while(pSearch->GetNextColumnName(&pszColumnName) != S_ADS_NOMORE_COLUMNS)
        {
			if(bAttrOnly)
			{
				wsprintf(pBuffer, L"%ws ", pszColumnName);
				DisplayOutputNoNewline(pBuffer);
				bColumnNameDisplayed = TRUE;
			}
			else
			{
				ADS_SEARCH_COLUMN ColumnData;
				hr = pSearch->GetColumn(pszColumnName, &ColumnData);
				if(SUCCEEDED(hr))
				{
					ADSVALUE *pValues = ColumnData.pADsValues;
					for( DWORD j = 0; j < ColumnData.dwNumValues; ++j )
					{                        
						hr = GetStringFromADs(pValues,
											  ColumnData.dwADsType,
											  pBuffer, 
											  MAXSTR,
											  pszColumnName);
						if(SUCCEEDED(hr))
							DisplayList(pszColumnName, pBuffer);
						++pValues;
					}
					pSearch->FreeColumn(&ColumnData);                
				}
				else if(hr == E_ADS_COLUMN_NOT_SET)
					DisplayList(pszColumnName, L"");
			}
            pSearch->FreeColumnName(pszColumnName);            
        }

		
		if(bAttrOnly)
		{
			if(bColumnNameDisplayed)
			{				
				DisplayOutputNoNewline(L"\r\n");
				cRow++;
			}
		}
		else
			cRow++;

    }//End of while loop

    if(hr == S_ADS_NOMORE_ROWS)
        hr = S_OK;

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetStringFromADs
//
//  Synopsis:   Converts Value into string depending upon type
//  Arguments:  [pValues - IN]: Value to be converted to string
//              [dwADsType-IN]: ADSTYPE of pValue
//              [pBuffer - OUT]:Output buffer which gets the string 
//              [dwBufferLen-IN]:Size of output buffer
//  Returns     HRESULT         S_OK if Successful
//                              E_INVALIDARG
//                              Anything else is a failure code from an ADSI 
//                              call
//
//
//  History:    05-OCT-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT GetStringFromADs(IN const ADSVALUE *pValues,
                         IN ADSTYPE   dwADsType,
                         OUT LPWSTR pBuffer, 
                         IN DWORD dwBufferLen,
						 IN LPCWSTR pszAttrName)
{
    ENTER_FUNCTION_HR(FULL_LOGGING, GetStringFromADs, hr);

    if(!pValues || !pBuffer || !dwBufferLen)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    pBuffer[0] = 0;
    if( dwADsType == ADSTYPE_INVALID )
    {
	    hr = E_INVALIDARG;
      return hr;
    }

	switch( dwADsType ) 
	{
	    case ADSTYPE_DN_STRING : 
            {
                CComBSTR sbstrOutputDN;
                HRESULT hr = GetOutputDN( &sbstrOutputDN, pValues->DNString );
                if (FAILED(hr))
                    return hr;
                wcsncpy(pBuffer, (BSTR)sbstrOutputDN, dwBufferLen-1);
            }
            break;

        case ADSTYPE_CASE_EXACT_STRING :
		    wcsncpy(pBuffer ,pValues->CaseExactString, dwBufferLen-1);
			break;

        case ADSTYPE_CASE_IGNORE_STRING:
		    wcsncpy(pBuffer ,pValues->CaseIgnoreString, dwBufferLen-1);
			break;

        case ADSTYPE_PRINTABLE_STRING  :
            wcsncpy(pBuffer ,pValues->PrintableString, dwBufferLen-1);
			break;

        case ADSTYPE_NUMERIC_STRING    :
		    wcsncpy(pBuffer ,pValues->NumericString, dwBufferLen-1);
			break;
    
        case ADSTYPE_OBJECT_CLASS    :
		    wcsncpy(pBuffer ,pValues->ClassName, dwBufferLen-1);
			break;
    
        case ADSTYPE_BOOLEAN :
            wsprintf(pBuffer ,L"%s", ((DWORD)pValues->Boolean) ? L"TRUE" : L"FALSE");
			break;
    
        case ADSTYPE_INTEGER           :
		    wsprintf(pBuffer ,L"%d", (DWORD) pValues->Integer);
			break;
    
        case ADSTYPE_OCTET_STRING      :
		{		
		    BYTE  b;
            WCHAR sOctet[128];
            DWORD dwLen = 0;
			//
			//Special case objectguid and objectsid attribute
			//
			if(pszAttrName && !_wcsicmp(pszAttrName, L"objectguid"))
			{
				GUID *pguid = (GUID*)pValues->OctetString.lpValue;
				StringFromGUID2(*pguid,(LPOLESTR)pBuffer,dwBufferLen);
				break;
			}
			
			if(pszAttrName && !_wcsicmp(pszAttrName, L"objectsid"))
			{
				LPWSTR pszSid = NULL;
				PSID pSid = (PSID)pValues->OctetString.lpValue;
				if(ConvertSidToStringSid(pSid, &pszSid))
				{
					wcscpy(pBuffer,pszSid);
					LocalFree(pszSid);
					break;
				}
			}

			for ( DWORD idx=0; idx<pValues->OctetString.dwLength; idx++) 
			{                        
			    b = ((BYTE *)pValues->OctetString.lpValue)[idx];
				wsprintf(sOctet,L"0x%02x ", b);						                
                dwLen += static_cast<DWORD>(wcslen(sOctet));
                if(dwLen > (dwBufferLen - 1) )
                    break;
                else
                    wcscat(pBuffer,sOctet);
            }
        }
		break;
    
		case ADSTYPE_LARGE_INTEGER :     
        {
            CComBSTR strLarge;   
            LARGE_INTEGER li = pValues->LargeInteger;
		    litow(li, strLarge);
            wcsncpy(pBuffer,strLarge,dwBufferLen-1);
        }
		break;
    
		case ADSTYPE_UTC_TIME          :
		    wsprintf(pBuffer,
					L"%02d/%02d/%04d %02d:%02d:%02d", pValues->UTCTime.wMonth, pValues->UTCTime.wDay, pValues->UTCTime.wYear,
					 pValues->UTCTime.wHour, pValues->UTCTime.wMinute, pValues->UTCTime.wSecond 
					);
            break;

        case ADSTYPE_NT_SECURITY_DESCRIPTOR: // I use the ACLEditor instead
		{
            //ISSUE:2000/01/05-hiteshr
            //I am not sure what to do with the NT_SECURITY_DESCRIPTOR and also
            //with someother datatypes not coverd by dsquery.
   		}
        break;

		default :
		    break;
    }
  
    DEBUG_OUTPUT(FULL_LOGGING, L"string = %w", pBuffer);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   24-Sep-2000    hiteshr  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

//
// The command line executable name
//
PCWSTR g_pszDSCommandName           = L"dsquery";

//
// Object types as are typed on the command line
//
PCWSTR g_pszStar                    = L"*";
PCWSTR g_pszOU                      = L"ou";
PCWSTR g_pszUser                    = L"user";
PCWSTR g_pszContact                 = L"contact";
PCWSTR g_pszComputer                = L"computer";
PCWSTR g_pszGroup                   = L"group";
PCWSTR g_pszServer                  = L"server";
PCWSTR g_pszSite                    = L"site";
PCWSTR g_pszSubnet					= L"subnet";

//
// Common switches
//
PCWSTR c_sz_arg1_com_debug          = L"debug";
PCWSTR c_sz_arg1_com_help           = L"h";
PCWSTR c_sz_arg2_com_help           = L"?";
PCWSTR c_sz_arg1_com_server         = L"s";
PCWSTR c_sz_arg2_com_server         = L"server";
PCWSTR c_sz_arg1_com_domain         = L"d";
PCWSTR c_sz_arg2_com_domain         = L"domain";
PCWSTR c_sz_arg1_com_username       = L"u";
PCWSTR c_sz_arg2_com_username       = L"username";
PCWSTR c_sz_arg1_com_password       = L"p";
PCWSTR c_sz_arg2_com_password       = L"password";
PCWSTR c_sz_arg1_com_quiet          = L"q";
PCWSTR c_sz_arg1_com_objecttype     = L"objecttype";
PCWSTR c_sz_arg1_com_recurse        = L"r";
PCWSTR c_sz_arg1_com_gc             = L"gc";
PCWSTR c_sz_arg1_com_output         = L"o";
PCWSTR c_sz_arg1_com_startnode      = L"startnode";
PCWSTR c_sz_arg1_com_limit		    = L"limit";

//
// Star switches
//
PCWSTR g_pszArg1StarScope           = L"scope";
PCWSTR g_pszArg1StarFilter          = L"filter";
PCWSTR g_pszArg1StarAttr            = L"attr";
PCWSTR g_pszArg1StarAttrsOnly       = L"attrsonly";
PCWSTR g_pszArg1StarList            = L"l";

//
// User switches
//
PCWSTR g_pszArg1UserScope           = L"scope"; 
PCWSTR g_pszArg1UserName            = L"name";
PCWSTR g_pszArg1UserDesc            = L"desc"; 
PCWSTR g_pszArg1UserUpn             = L"upn";
PCWSTR g_pszArg1UserSamid           = L"samid"; 
PCWSTR g_pszArg1UserInactive        = L"inactive";
PCWSTR g_pszArg1UserDisabled        = L"disabled";
PCWSTR g_pszArg1UserStalepwd        = L"stalepwd";

//
// Computer switches
//
PCWSTR g_pszArg1ComputerScope           = L"scope"; 
PCWSTR g_pszArg1ComputerName            = L"name";
PCWSTR g_pszArg1ComputerDesc            = L"desc"; 
PCWSTR g_pszArg1ComputerSamid           = L"samid"; 
PCWSTR g_pszArg1ComputerInactive        = L"inactive";
PCWSTR g_pszArg1ComputerDisabled        = L"disabled";
PCWSTR g_pszArg1ComputerStalepwd        = L"stalepwd";

//
// Group switches
//
PCWSTR g_pszArg1GroupScope           = L"scope"; 
PCWSTR g_pszArg1GroupName            = L"name";
PCWSTR g_pszArg1GroupDesc            = L"desc"; 
PCWSTR g_pszArg1GroupSamid           = L"samid"; 

//
// Ou switches
//
PCWSTR g_pszArg1OUScope           = L"scope"; 
PCWSTR g_pszArg1OUName            = L"name";
PCWSTR g_pszArg1OUDesc            = L"desc"; 

//
// Server switches
//
PCWSTR g_pszArg1ServerForest      = L"forest";
PCWSTR g_pszArg1ServerSite        = L"site";
PCWSTR g_pszArg1ServerName        = L"name";
PCWSTR g_pszArg1ServerDesc        = L"desc";
PCWSTR g_pszArg1ServerHasFSMO     = L"hasfsmo";
PCWSTR g_pszArg1ServerIsGC        = L"isgc";

//
// Site switches
//
PCWSTR g_pszArg1SiteName            = L"name";
PCWSTR g_pszArg1SiteDesc            = L"desc"; 

//
// Subnet switches
//
PCWSTR g_pszArg1SubnetName			= L"name";
PCWSTR g_pszArg1SubnetDesc			= L"desc";
PCWSTR g_pszArg1SubnetLoc			= L"loc";
PCWSTR g_pszArg1SubnetSite			= L"site";


//
// Valid Output formats{dn, rdn, upn, samid, ntlmid} 
//
PCWSTR g_pszDN      = L"dn";
PCWSTR g_pszRDN     = L"rdn";
PCWSTR g_pszUPN     = L"upn";
PCWSTR g_pszSamId   = L"samid";
PCWSTR g_pszNtlmId  = L"ntlmid";

//
//Valid Scope Strings
//
PCWSTR g_pszSubTree  = L"subtree";
PCWSTR g_pszOneLevel = L"onelevel";
PCWSTR g_pszBase     = L"base";


//Default Filter and Prefix filter
PCWSTR g_pszDefStarFilter     = L"(objectClass=*)";
PCWSTR g_pszDefUserFilter     = L"&(objectCategory=person)(objectClass=user)";
PCWSTR g_pszDefComputerFilter = L"&(objectCategory=Computer)";
PCWSTR g_pszDefGroupFilter    = L"&(objectCategory=Group)";
PCWSTR g_pszDefOUFilter       = L"&(objectCategory=organizationalUnit)";
PCWSTR g_pszDefServerFilter   = L"&(objectCategory=server)";
PCWSTR g_pszDefSiteFilter     = L"&(objectCategory=site)";
PCWSTR g_pszDefSubnetFilter     = L"&(objectCategory=subnet)";
PCWSTR g_pszDefContactFilter  = L"&(objectCategory=person)(objectClass=contact)";

//Valid start node values
PCWSTR g_pszDomainRoot = L"domainroot";
PCWSTR g_pszForestRoot = L"forestroot";
PCWSTR g_pszSiteRoot   = L"site";



//Attributes to fetch
PCWSTR g_szAttrDistinguishedName = L"distinguishedName";
PCWSTR g_szAttrUserPrincipalName = L"userPrincipalName";
PCWSTR g_szAttrSamAccountName = L"sAMAccountName";
PCWSTR g_szAttrRDN = L"name";
PCWSTR g_szAttrServerReference = L"serverReference";


// FSMOs
PCWSTR g_pszSchema    = L"schema";
PCWSTR g_pszName      = L"name";
PCWSTR g_pszInfr      = L"infr";
PCWSTR g_pszPDC       = L"pdc";
PCWSTR g_pszRID       = L"rid";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\output.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      output.h
//
//  Contents:  Header file for classes and function used for display
//
//  History:   3-oct-2000 hiteshr Created
//
//--------------------------------------------------------------------------

extern bool g_bQuiet;
extern int g_iQueryLimit;
extern bool g_bDeafultLimit;

HRESULT LocalCopyString(LPTSTR* ppResult, LPCTSTR pString);

//+--------------------------------------------------------------------------
//
//  Class:      CDisplay
//
//  Purpose:    This class is used for displaying a column
//
//  History:    3-oct-2000 hiteshr Created
//
//---------------------------------------------------------------------------

class CDisplay
{
#define MAXPAD 80
public:

    //
    //Initialize the Pad
    //    
    CDisplay()
    {
        PadChar = L' ';
        //Initialize the pad.
        for( int i = 0; i < MAXPAD; ++i)
            Pad[i] = PadChar;
    }

    //
    //Display width number of Pad Charachter
    //
    VOID DisplayPad(LONG width)
    {
        if(width <= 0 )
            return;
        if(width >= MAXPAD)
            width = MAXPAD -1;
        Pad[width] = 0;
		DisplayOutputNoNewline(Pad);

        Pad[width] = PadChar;
    }
        
    //
    //Dispaly a column with two starting pad,
    //column value and two ending pad
    //
    VOID DisplayColumn(LONG width, LPWSTR lpszValue)
    {
        //Display Two PadChar in the begining
        DisplayPad(2);
        if(lpszValue)
        {
            DisplayOutputNoNewline(lpszValue);

            DisplayPad(width- static_cast<LONG>(wcslen(lpszValue)));
        }
        else
            DisplayPad(width);

                
        //Display Two Trailing Padchar
        DisplayPad(2);
    }        
    
    //
    //Display Newline
    //    
    VOID DisplayNewLine()
    {
        DisplayOutputNoNewline(L"\r\n");
    }
private:
    WCHAR Pad[MAXPAD];    
    WCHAR PadChar;

};

//+--------------------------------------------------------------------------
//
//  Class:      CFormaInfo
//
//  Purpose:    Used to format table columns and display table
//
//  History:    3-oct-2000 hiteshr Created
//
//---------------------------------------------------------------------------
class CFormatInfo
{
public:
    CFormatInfo():m_cCol(0),
                  m_ppszOutPutVal(NULL),
                  m_pColWidth(NULL),
                  m_bInit(FALSE),
                  m_cTotalRow(-1)
    {};

    ~CFormatInfo()
    {   
		if(m_ppszOutPutVal)
		{
			for(LONG i = 0; i < m_SampleSize*m_cCol; ++i)
				LocalFree(m_ppszOutPutVal[i]);
		}
        LocalFree(m_ppszOutPutVal);        
        LocalFree(m_pColWidth);
    }

    //
    //Do the initialization
    //
    HRESULT Init(LONG sampleSize, LONG cCol, LPWSTR * ppszColHeaders)
    {
        if(!sampleSize || !cCol || !ppszColHeaders)
        {
            ASSERT(FALSE);
            return E_INVALIDARG;
        }
        
        m_SampleSize = sampleSize; 
        m_cCol = cCol;
        m_ppszColHeaders = ppszColHeaders;
        m_ppszOutPutVal = (LPWSTR*)LocalAlloc(LPTR,m_SampleSize*cCol*sizeof(LPWSTR*));
        if(!m_ppszOutPutVal)
            return E_OUTOFMEMORY;
        
        m_pColWidth = (LONG*)LocalAlloc(LPTR, cCol*sizeof(LONG*));
        if(!m_pColWidth)
           return E_OUTOFMEMORY;   

        //
        //Initialize the minimum column width to width of column heading
        //
        for(LONG i = 0; i < m_cCol; ++i)
            m_pColWidth[i] = static_cast<LONG>(wcslen(m_ppszColHeaders[i]));

        m_bInit = TRUE;                      

        return S_OK;
    };

                 
    //
    //Get the Column Width
    //
    inline
    LONG GetColWidth(LONG col)
    { 
        ASSERT(m_bInit);
        if(col >= m_cCol)
        {
            ASSERT(FALSE);
            return 0;
        }
        return m_pColWidth[col]; 
    }

    //
    //Set the column Width
    //
    inline
    VOID SetColWidth(LONG col, LONG width)
    {
        ASSERT(m_bInit);
        if(col >= m_cCol)
        {
            ASSERT(FALSE);
            return;
        }
        
        if(width > m_pColWidth[col])
            m_pColWidth[col] = width;
    }

    //
    //Cache the value and update column width
    //
    BOOL Set(LONG row, LONG col, LPWSTR pszValue)
    {
        ASSERT(m_bInit);
        if(row >= m_SampleSize || col >= m_cCol)
        {
            ASSERT(FALSE);
            return FALSE;
        }
        if(pszValue)
        {
            SetColWidth(col, static_cast<LONG>(wcslen(pszValue)));
            LocalCopyString((LPWSTR*)(m_ppszOutPutVal + (row*m_cCol) + col),pszValue);                             
        }
        if(row>= m_cTotalRow)
            m_cTotalRow = row +1;

        return TRUE;
    }

    //
    //Total number of rows in cache
    //
    LONG GetRowCount()
    {
        return m_cTotalRow;
    }
    
    //
    //Get the value
    //
    inline
    LPWSTR Get(LONG row, LONG col)
    {
        ASSERT(m_bInit);
        if(row >= m_cTotalRow || col >= m_cCol)
        {
            ASSERT(FALSE);
            return NULL;
        }

        return (LPWSTR)(*(m_ppszOutPutVal + row*m_cCol +col));
    }

    //
    //Display headers 
    //
    VOID DisplayHeaders()
    {    
        if (g_bQuiet)
        {
            return;
        }
        if(!m_ppszColHeaders)
        {
            ASSERT(m_ppszColHeaders);    
            return;
        }
        for( long i = 0; i < m_cCol; ++i)
        {
            m_display.DisplayColumn(GetColWidth(i),m_ppszColHeaders[i]);
        }
        NewLine();
    }

    //
    //Display a coulmn which is in cache
    //
    VOID DisplayColumn(LONG row,LONG col)
    {
        ASSERT(m_bInit);
        if(row >= m_cTotalRow || col >= m_cCol)
        {
            ASSERT(FALSE);
            return ;
        }

        m_display.DisplayColumn(GetColWidth(col),Get(row,col));
    }

    //
    //Display the value using column width for col
    //
    VOID DisplayColumn(LONG col, LPWSTR pszValue)
    {
        if(col >= m_cCol)
        {
            ASSERT(FALSE);
            return;
        }

        m_display.DisplayColumn(GetColWidth(col),pszValue);
    }

    //
    //Display all rows in cache
    //
    VOID DisplayAllRows()
    {
        for(long i = 0; i < m_cTotalRow; ++i)
        {
            for(long j = 0; j < m_cCol; ++j)
                DisplayColumn(i,j);
            NewLine();
        }
    }

    //
    //Display a newline
    //
    VOID NewLine(){m_display.DisplayNewLine();}
   
private:
    //
    //True if Init is called
    //
    BOOL m_bInit;
    //
    //Number of rows to be used for calulating
    //column width. This is also the size of the table.
    //
    LONG m_SampleSize;
    //
    //Count of rows in cache
    //
    LONG m_cTotalRow;
    //
    //Number of columns
    //
    LONG m_cCol;

    LPWSTR *m_ppszOutPutVal;    
    LONG * m_pColWidth;
    //
    // Array of column headers. Its assumed that its length is same as m_cCol
    //
    LPWSTR *m_ppszColHeaders;
    CDisplay m_display;

};

//+--------------------------------------------------------------------------
//
//  Synopsis:     Defines the scopes that a search can be run against when
//                looking for a server object
//
//  NOTE:         If SERVER_QUERY_SCOPE_FOREST is not set then we are scoped
//                against a site.
//
//---------------------------------------------------------------------------
#define  SERVER_QUERY_SCOPE_SITE    0x00000001
#define  SERVER_QUERY_SCOPE_FOREST  0x00000002
#define  SERVER_QUERY_SCOPE_DOMAIN  0x00000004

//+--------------------------------------------------------------------------
//
//  Function:   GetServerSearchRoot
//
//  Synopsis:   Builds the path to the root of the search as determined by
//              the parameters passed in from the command line.
//
//  Arguments:  [pCommandArgs IN]     : the table of the command line input
//              [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//
//  Returns:    DWORD : one of: SERVER_QUERY_SCOPE_FOREST,
//                              SERVER_QUERY_SCOPE_DOMAIN,
//                              SERVER_QUERY_SCOPE_SITE 
//                      which define the scope being used
//
//  History:    11-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
DWORD GetServerSearchRoot(IN PARG_RECORD               pCommandArgs,
                          IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                          OUT CComBSTR&                refsbstrDN);

//+--------------------------------------------------------------------------
//
//  Function:   GetSubnetSearchRoot
//
//  Synopsis:   Builds search root path for Subnet. Its always
//				cn=subnet,cn=site in configuration container
//
//  Arguments:  [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN at which to start
//                                      the search
//
//  Returns:    HRESULT
//
//  History:    11-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
VOID GetSubnetSearchRoot(IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                            OUT CComBSTR&                refsbstrDN);

//+--------------------------------------------------------------------------
//
//  Function:   GetSiteContainerPath
//
//  Synopsis:   Returns the DN for site container in Configuration
//				container
//
//  Arguments:  [refBasePathsInfo IN] : reference to the base paths info
//              [refsbstrDN OUT]      : reference to a CComBSTR that will
//                                      receive the DN 
//
//  Returns:    HRESULT
//
//  History:    24-April-2001   hiteshr Created
//
//---------------------------------------------------------------------------
VOID GetSiteContainerPath(IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                            OUT CComBSTR&                refSubSiteSuffix);



//+--------------------------------------------------------------------------
//
//  Function:   DsQueryServerOutput
//
//  Synopsis:   This functions outputs the query results for server object.
//
//  Arguments:  [outputFormat IN]   Output format specified at commandline.
//              [ppszAttributes IN] List of attributes fetched by query
//              [cAttributes,IN]    Number of arributes in above array
//              [refServerSearch,IN]reference to the search Object
//              [refCredObject IN]  reference to the credential object
//              [refBasePathsInfo IN] reference to the base paths info
//              [pCommandArgs,IN]   The pointer to the commands table
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  History:    08-Dec-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT DsQueryServerOutput( IN DSQUERY_OUTPUT_FORMAT     outputFormat,
                             IN LPWSTR*                   ppszAttributes,
                             IN DWORD                     cAttributes,
                             IN CDSSearch&                refServerSearch,
                             IN const CDSCmdCredentialObject& refCredObject,
                             IN CDSCmdBasePathsInfo&      refBasePathsInfo,
                             IN PARG_RECORD               pCommandArgs);

//+--------------------------------------------------------------------------
//
//  Function:   DsQueryOutput
//
//  Synopsis:   This functions outputs the query results.
//
//  Arguments:  [outputFormat IN]   Output format specified at commandline.
//              [ppszAttributes IN] List of attributes fetched by query
//              [cAttributes,IN]    Number of arributes in above array
//              [*pSeach,IN]        Search Object which has queryhandle
//              [bListFormat IN]    Is Output to shown in List Format.
//                                  This is valid for "dsquery *" only.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG 
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT DsQueryOutput( IN DSQUERY_OUTPUT_FORMAT outputFormat,
                       IN LPWSTR * ppszAttributes,
                       IN DWORD cAttributes,
                       IN CDSSearch *pSearch,
                       IN BOOL bListFormat );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\querytable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      querytable.cpp
//
//  Contents:  Defines Table For Parser.
//
//  History:   24-Sep-2000    Hiteshr  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "querytable.h"
#include "usage.h"
#include "querybld.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------

ARG_RECORD DSQUERY_COMMON_COMMANDS[] = 
{
#ifdef DBG
   //
   // -debug, -debug
   //
   0,(LPWSTR)c_sz_arg1_com_debug, 
   0,NULL,
   ARG_TYPE_DEBUG, ARG_FLAG_OPTIONAL|ARG_FLAG_HIDDEN,  
   NULL,     
   0,  NULL,
#endif

   //
   // h, ?
   //
   0,(LPWSTR)c_sz_arg1_com_help, 
   0,(LPWSTR)c_sz_arg2_com_help, 
   ARG_TYPE_HELP, ARG_FLAG_OPTIONAL,  
   NULL,     
   0,  NULL,

   //
   // s,server
   //
   0,(LPWSTR)c_sz_arg1_com_server, 
   0,(LPWSTR)c_sz_arg2_com_server, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // d,domain
   //
   0,(LPWSTR)c_sz_arg1_com_domain, 
   0,NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // u, username    
   //
   0,(LPWSTR)c_sz_arg1_com_username, 
   0,(LPWSTR)c_sz_arg2_com_username, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // w, password
   //
   0,(LPWSTR)c_sz_arg1_com_password, 
   0,(LPWSTR)c_sz_arg2_com_password, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  ValidateAdminPassword,

   //
   // q,q
   //
   0,(LPWSTR)c_sz_arg1_com_quiet, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // objecttype
   //
   0,(LPWSTR)c_sz_arg1_com_objecttype, 
   0,NULL, 
   ARG_TYPE_STR, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG,  
   0,    
   0,  NULL,

   //
   // r,r
   //
   0,(LPWSTR)c_sz_arg1_com_recurse, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // gc,gc
   //
   0,(LPWSTR)c_sz_arg1_com_gc, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,


   //
   // o,outputformat
   //
   0,(LPWSTR)c_sz_arg1_com_output, 
   0,NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // startnode,startnode
   //
   // JonN 4/28/01 256583
   // Note that startnode can also be "domainroot" or "forestroot",
   // which just happen to be unaffected by the escaping functions.
   0,(LPWSTR)c_sz_arg1_com_startnode, 
   0,NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL|ARG_FLAG_DN,
   NULL,    
   0,  NULL,

   //
   // limit
   //
   0,(LPWSTR)c_sz_arg1_com_limit,
   0,NULL,
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,


   ARG_TERMINATOR

};

ARG_RECORD DSQUERY_STAR_COMMANDS[]=
{
   //
   // scope
   //
   0, (PWSTR)g_pszArg1StarScope, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // filter
   //
   0, (PWSTR)g_pszArg1StarFilter, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // attr
   //
   0, (PWSTR)g_pszArg1StarAttr, 
   0, NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // attrsonly
   //
   0, (PWSTR)g_pszArg1StarAttrsOnly, 
   0, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // l, listoutput
   //
   0, (PWSTR)g_pszArg1StarList, 
   0, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR
};


ARG_RECORD DSQUERY_USER_COMMANDS[]=
{

   //
   // scope
   //
   0, (PWSTR)g_pszArg1UserScope, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Name
   //
   0, (PWSTR)g_pszArg1UserName, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Desc
   //
   0, (PWSTR)g_pszArg1UserDesc, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Upn
   //
   0, (PWSTR)g_pszArg1UserUpn, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Samid
   //
   0, (PWSTR)g_pszArg1UserSamid, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // inactive
   //
   0, (PWSTR)g_pszArg1UserInactive, 
   0, NULL, 
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // stalepwd
   //
   0, (PWSTR)g_pszArg1UserStalepwd, 
   0, NULL, 
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,


   //
   // -disabled
   //
   0, (PWSTR)g_pszArg1UserDisabled, 
   0, NULL, 
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,


   ARG_TERMINATOR
};

ARG_RECORD DSQUERY_COMPUTER_COMMANDS[]=
{
   //
   // scope
   //
   0, (PWSTR)g_pszArg1ComputerScope,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  ValidateYesNo,

   //
   //name
   //
   0, (PWSTR)g_pszArg1ComputerName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1ComputerDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //samid
   //
   0, (PWSTR)g_pszArg1ComputerSamid,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //inactive
   //
   0, (PWSTR)g_pszArg1ComputerInactive,
   0, NULL,
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   // stalepwd
   //
   0, (PWSTR)g_pszArg1ComputerStalepwd, 
   0, NULL, 
   ARG_TYPE_INT, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,


   //
   //disabled
   //
   0, (PWSTR)g_pszArg1ComputerDisabled,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSQUERY_GROUP_COMMANDS[]=
{
   //
   // scope
   //
   0, (PWSTR)g_pszArg1GroupScope,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  ValidateYesNo,

   //
   //name
   //
   0, (PWSTR)g_pszArg1GroupName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1GroupDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //samid
   //
   0, (PWSTR)g_pszArg1GroupSamid,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,
};

ARG_RECORD DSQUERY_OU_COMMANDS[]=
{
   //
   // scope
   //
   0, (PWSTR)g_pszArg1OUScope,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  ValidateYesNo,

   //
   //name
   //
   0, (PWSTR)g_pszArg1OUName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1OUDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSQUERY_CONTACT_COMMANDS[]=
{

   //
   // scope
   //
   0, (PWSTR)g_pszArg1UserScope, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Name
   //
   0, (PWSTR)g_pszArg1UserName, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   //
   // Desc
   //
   0, (PWSTR)g_pszArg1UserDesc, 
   0, NULL, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   0,    
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSQUERY_SERVER_COMMANDS[]=
{
   //
   // forest - Forest
   //
   0, (PWSTR)g_pszArg1ServerForest,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // domain - Domain
   //
   0, (PWSTR)c_sz_arg2_com_domain,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0, NULL,

   //
   // site - Site
   //
   0, (PWSTR)g_pszArg1ServerSite,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   0,
   0,  NULL,

   //
   // name - Name
   //
   0, (PWSTR)g_pszArg1ServerName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1ServerDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   // hasfsmo 
   //
   0, (PWSTR)g_pszArg1ServerHasFSMO,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   // isgc 
   //
   0, (PWSTR)g_pszArg1ServerIsGC,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSQUERY_SITE_COMMANDS[]=
{
   //
   //name
   //
   0, (PWSTR)g_pszArg1SiteName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1SiteDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,

};

ARG_RECORD DSQUERY_SUBNET_COMMANDS[]=
{
   //
   //name
   //
   0, (PWSTR)g_pszArg1SubnetName,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //desc
   //
   0, (PWSTR)g_pszArg1SubnetDesc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //Location
   //
   0, (PWSTR)g_pszArg1SubnetLoc,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   //
   //site
   //
   0, (PWSTR)g_pszArg1SubnetSite,
   0, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   NULL,
   0,  NULL,

   ARG_TERMINATOR,

};


//+-------------------------------------------------------------------------
// Attributes
//--------------------------------------------------------------------------
//
// filter, this is no ds attribute, but dummy attribute for commandline filter 
// specified in case of dsquery *

//Star Filter
DSQUERY_ATTR_TABLE_ENTRY StarFilterEntry =
{
   L"filter",
   eStarFilter,
   NULL,
   StarFilterFunc,   
};


//
// name
//
DSATTRIBUTEDESCRIPTION name=
{
   {
      L"cn",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

//User Name
DSQUERY_ATTR_TABLE_ENTRY UserNameEntry =
{
   L"cn",
   eUserName,
   &name,
   CommonFilterFunc,   
};

//Computer Name
DSQUERY_ATTR_TABLE_ENTRY ComputerNameEntry =
{
   L"cn",
   eComputerName,
   &name,
   CommonFilterFunc,   
};

//Group Name
DSQUERY_ATTR_TABLE_ENTRY GroupNameEntry =
{
   L"cn",
   eGroupName,
   &name,
   CommonFilterFunc,   
};

//OU Name
DSQUERY_ATTR_TABLE_ENTRY OUNameEntry =
{
   L"ou",
   eOUName,
   &name,
   CommonFilterFunc,   
};

// Server Name
DSQUERY_ATTR_TABLE_ENTRY ServerNameEntry =
{
   L"cn",
   eServerName,
   &name,
   CommonFilterFunc,
};

// Site Name
DSQUERY_ATTR_TABLE_ENTRY SiteNameEntry =
{
   L"cn",
   eSiteName,
   &name,
   CommonFilterFunc,
};

// Contact Name
DSQUERY_ATTR_TABLE_ENTRY ContactNameEntry =
{
   L"cn",
   eContactName,
   &name,
   CommonFilterFunc,
};

// Subnet Name
DSQUERY_ATTR_TABLE_ENTRY SubnetNameEntry =
{
   L"cn",
   eSubnetName,
   &name,
   CommonFilterFunc,
};


//
// Description
//
DSATTRIBUTEDESCRIPTION description =
{
   {
      L"description",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

//User Description
DSQUERY_ATTR_TABLE_ENTRY UserDescEntry =
{
   L"description",
   eUserDesc,
   &description,
   CommonFilterFunc,   
};

//Computer Description
DSQUERY_ATTR_TABLE_ENTRY ComputerDescEntry =
{
   L"description",
   eComputerDesc,
   &description,
   CommonFilterFunc,   
};

//Group Description
DSQUERY_ATTR_TABLE_ENTRY GroupDescEntry =
{
   L"description",
   eGroupDesc,
   &description,
   CommonFilterFunc,   
};

//OU Description
DSQUERY_ATTR_TABLE_ENTRY OUDescEntry =
{
   L"description",
   eOUDesc,
   &description,
   CommonFilterFunc,   
};

//Server Description
DSQUERY_ATTR_TABLE_ENTRY ServerDescEntry =
{
   L"description",
   eServerDesc,
   &description,
   CommonFilterFunc,   
};

//Site Description
DSQUERY_ATTR_TABLE_ENTRY SiteDescEntry =
{
   L"description",
   eSiteDesc,
   &description,
   CommonFilterFunc,   
};

//Cotnact Description
DSQUERY_ATTR_TABLE_ENTRY ContactDescEntry =
{
   L"description",
   eContactDesc,
   &description,
   CommonFilterFunc,   
};

//Subnet Description
DSQUERY_ATTR_TABLE_ENTRY SubnetDescEntry =
{
   L"description",
   eSubnetDesc,
   &description,
   CommonFilterFunc,   
};

//
// UPN
//
DSATTRIBUTEDESCRIPTION upn =
{
   {
      L"userPrincipalName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

//User Upn
DSQUERY_ATTR_TABLE_ENTRY UserUPNEntry =
{
   L"userPrincipalName",
   eUserUPN,
   &upn,
   CommonFilterFunc,
};


//
// SAM Account Name
//
DSATTRIBUTEDESCRIPTION samAccountName =
{
   {
      L"sAMAccountName",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};

//User SAM Account
DSQUERY_ATTR_TABLE_ENTRY UserSamidEntry =
{
   L"sAMAccountName",
   eUserSamid,
   &samAccountName,
   CommonFilterFunc,   
};
//Computer samAccountName
DSQUERY_ATTR_TABLE_ENTRY ComputerSamidEntry =
{
   L"sAMAccountName",
   eComputerSamid,
   &samAccountName,
   CommonFilterFunc,   
};

//Group samAccountName
DSQUERY_ATTR_TABLE_ENTRY GroupSamidEntry =
{
   L"sAMAccountName",
   eGroupSamid,
   &samAccountName,
   CommonFilterFunc,   
};

//User Disabled
DSQUERY_ATTR_TABLE_ENTRY UserDisabledEntry =
{
   L"disabled",
   eUserDisabled,
   NULL,
   DisabledFilterFunc,   
};

//Computer Disabled
DSQUERY_ATTR_TABLE_ENTRY ComputerDisabledEntry =
{
   L"disabled",
   eComputerDisabled,
   NULL,
   DisabledFilterFunc,   
};

//User Inactive
DSQUERY_ATTR_TABLE_ENTRY UserInactiveEntry =
{
   L"inactive",
   eUserInactive,
   NULL,
   InactiveFilterFunc,   
};

//Computer Inactive
DSQUERY_ATTR_TABLE_ENTRY ComputerInactiveEntry =
{
   L"inactive",
   eComputerInactive,
   NULL,
   InactiveFilterFunc,   
};

//User stalepwd
DSQUERY_ATTR_TABLE_ENTRY UserStalepwdEntry =
{
   L"stalepwd",
   eUserStalepwd,
   NULL,
   StalepwdFilterFunc,   
};

//Computer stalepwd
DSQUERY_ATTR_TABLE_ENTRY ComputerStalepwdEntry =
{
   L"stalepwd",
   eComputerStalepwd,
   NULL,
   StalepwdFilterFunc,   
};

//
// Locations
//
DSATTRIBUTEDESCRIPTION location =
{
   {
      L"location",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};
//Subnet location
DSQUERY_ATTR_TABLE_ENTRY SubnetLocEntry=
{
   L"location",
   eSubnetLoc,
   &location,
   CommonFilterFunc,   
};

//
// SiteObject
//
DSATTRIBUTEDESCRIPTION siteObject=
{
   {
      L"siteObject",
      ADS_ATTR_UPDATE,
      ADSTYPE_CASE_IGNORE_STRING,
      NULL,
      0
   },
   0
};
//Subnet Site
DSQUERY_ATTR_TABLE_ENTRY SubnetSiteEntry=
{
   L"siteObject",
   eSubnetSite,
   &siteObject,
   SubnetSiteFilterFunc,   
};

//
//Valid OutputStrings for each objecttype
//
//

DSQUERY_OUTPUT_FORMAT_MAP g_format_dn =
{
    g_pszDN,
    DSQUERY_OUTPUT_DN
};

DSQUERY_OUTPUT_FORMAT_MAP g_format_rdn =
{
    g_pszRDN,
    DSQUERY_OUTPUT_RDN
};

DSQUERY_OUTPUT_FORMAT_MAP g_format_upn =
{
    g_pszUPN,
    DSQUERY_OUTPUT_UPN
};

DSQUERY_OUTPUT_FORMAT_MAP g_format_samid =
{
    g_pszSamId,
    DSQUERY_OUTPUT_SAMID
};

DSQUERY_OUTPUT_FORMAT_MAP g_format_ntlmid =
{
    g_pszNtlmId,
    DSQUERY_OUTPUT_NTLMID
};

PDSQUERY_OUTPUT_FORMAT_MAP UserOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn,
   &g_format_upn,
   &g_format_samid,
   &g_format_ntlmid
};
//Computer
PDSQUERY_OUTPUT_FORMAT_MAP ComputerOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn,
   &g_format_samid,
   &g_format_ntlmid
};
//Group
PDSQUERY_OUTPUT_FORMAT_MAP GroupOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn,
   &g_format_samid,
   &g_format_ntlmid
};
//OU
PDSQUERY_OUTPUT_FORMAT_MAP OuOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Contact
PDSQUERY_OUTPUT_FORMAT_MAP ContactOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Server
PDSQUERY_OUTPUT_FORMAT_MAP ServerOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Site
PDSQUERY_OUTPUT_FORMAT_MAP SiteOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};

//Subnet
PDSQUERY_OUTPUT_FORMAT_MAP SubnetOutputFormatMap[] =
{
   &g_format_dn,
   &g_format_rdn
};


//Attribute Table entries and ObjectTableEntries
//
//
//* Star
//
PDSQUERY_ATTR_TABLE_ENTRY StarAttributeTable[] =
{
   &StarFilterEntry,   
};

DSQueryObjectTableEntry g_StarObjectEntry = 
{
   L"*",
   g_pszStar,
   DSQUERY_STAR_COMMANDS,
   USAGE_DSQUERY_STAR,
   sizeof(StarAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   StarAttributeTable,
   0,
   NULL,
   eStarScope,
   g_pszDefStarFilter,
   NULL
};


//
// User
//

PDSQUERY_ATTR_TABLE_ENTRY UserAttributeTable[] =
{
   &UserNameEntry,
   &UserUPNEntry,
   &UserDescEntry,
   &UserSamidEntry,
   &UserDisabledEntry,
   &UserInactiveEntry,
   &UserStalepwdEntry
};

DSQueryObjectTableEntry g_UserObjectEntry = 
{
   L"user",
   g_pszUser,
   DSQUERY_USER_COMMANDS,
   USAGE_DSQUERY_USER,
   sizeof(UserAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   UserAttributeTable,
   sizeof(UserOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   UserOutputFormatMap,
   eUserScope,
   g_pszDefUserFilter,
   g_pszDefUserFilter
};


//
// Computer
//

PDSQUERY_ATTR_TABLE_ENTRY ComputerAttributeTable[] =
{
   &ComputerNameEntry,   
   &ComputerDescEntry,
   &ComputerSamidEntry,
   &ComputerDisabledEntry,
   &ComputerInactiveEntry,
   &ComputerStalepwdEntry
};

DSQueryObjectTableEntry g_ComputerObjectEntry = 
{
   L"computer",
   g_pszComputer,
   DSQUERY_COMPUTER_COMMANDS,
   USAGE_DSQUERY_COMPUTER,
   sizeof(ComputerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ComputerAttributeTable,
   sizeof(ComputerOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   ComputerOutputFormatMap,
   eComputerScope,
   g_pszDefComputerFilter,
   g_pszDefComputerFilter
};

//
// Group
//
PDSQUERY_ATTR_TABLE_ENTRY GroupAttributeTable[] =
{
   &GroupNameEntry,   
   &GroupDescEntry,
   &GroupSamidEntry
};

DSQueryObjectTableEntry g_GroupObjectEntry = 
{
   L"group",
   g_pszGroup,
   DSQUERY_GROUP_COMMANDS,
   USAGE_DSQUERY_GROUP,
   sizeof(GroupAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   GroupAttributeTable,
   sizeof(GroupOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   GroupOutputFormatMap,
   eGroupScope,
   g_pszDefGroupFilter,
   g_pszDefGroupFilter
};


//
// OU
//
PDSQUERY_ATTR_TABLE_ENTRY OUAttributeTable[] =
{
   &OUNameEntry,   
   &OUDescEntry
};

DSQueryObjectTableEntry g_OUObjectEntry = 
{
   L"ou",
   g_pszOU,
   DSQUERY_OU_COMMANDS,
   USAGE_DSQUERY_OU,
   sizeof(OUAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   OUAttributeTable,
   sizeof(OuOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   OuOutputFormatMap,
   eOUScope,
   g_pszDefOUFilter,
   g_pszDefOUFilter
};

//
// Server
//
PDSQUERY_ATTR_TABLE_ENTRY ServerAttributeTable[] =
{
   &ServerNameEntry,   
   &ServerDescEntry
};

DSQueryObjectTableEntry g_ServerObjectEntry = 
{
   L"server",
   g_pszServer,
   DSQUERY_SERVER_COMMANDS,
   USAGE_DSQUERY_SERVER,
   sizeof(ServerAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ServerAttributeTable,
   sizeof(ServerOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   ServerOutputFormatMap,
   static_cast<UINT>(-1),
   g_pszDefServerFilter,
   g_pszDefServerFilter
};

//
// Site
//
PDSQUERY_ATTR_TABLE_ENTRY SiteAttributeTable[] =
{
   &SiteNameEntry,   
   &SiteDescEntry
};

DSQueryObjectTableEntry g_SiteObjectEntry = 
{
   L"site",
   g_pszSite,
   DSQUERY_SITE_COMMANDS,
   USAGE_DSQUERY_SITE,
   sizeof(SiteAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   SiteAttributeTable,
   sizeof(SiteOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   SiteOutputFormatMap,
   static_cast<UINT>(-1),
   g_pszDefSiteFilter,
   g_pszDefSiteFilter
};

//
// Contact
//

PDSQUERY_ATTR_TABLE_ENTRY ContactAttributeTable[] =
{
   &ContactNameEntry,
   &ContactDescEntry,
};

DSQueryObjectTableEntry g_ContactObjectEntry = 
{
   L"contact",
   g_pszContact,
   DSQUERY_CONTACT_COMMANDS,
   USAGE_DSQUERY_USER,
   sizeof(ContactAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   ContactAttributeTable,
   sizeof(ContactOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   ContactOutputFormatMap,
   eContactScope,
   g_pszDefContactFilter,
   g_pszDefContactFilter
};

//
// Subnet
//
PDSQUERY_ATTR_TABLE_ENTRY SubnetAttributeTable[] =
{
   &SubnetNameEntry,   
   &SubnetDescEntry,
   &SubnetLocEntry,
   &SubnetSiteEntry,
};

DSQueryObjectTableEntry g_SubnetObjectEntry = 
{
   L"subnet",
   g_pszSubnet,
   DSQUERY_SUBNET_COMMANDS,
   USAGE_DSQUERY_SUBNET,
   sizeof(SubnetAttributeTable)/sizeof(PDSATTRIBUTETABLEENTRY),
   SubnetAttributeTable,
   sizeof(SubnetOutputFormatMap)/sizeof(PDSQUERY_OUTPUT_FORMAT_MAP),
   SubnetOutputFormatMap,
   static_cast<UINT>(-1),
   g_pszDefSubnetFilter,
   g_pszDefSubnetFilter
};



//+-------------------------------------------------------------------------
// Object Table
//--------------------------------------------------------------------------
PDSQueryObjectTableEntry g_DSObjectTable[] =
{
   &g_StarObjectEntry,
   &g_OUObjectEntry,
   &g_UserObjectEntry,
   &g_ComputerObjectEntry,
   &g_GroupObjectEntry,
   &g_ServerObjectEntry,
   &g_SiteObjectEntry,
   &g_ContactObjectEntry,
   &g_SubnetObjectEntry,
   NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsmod.rc
//
#define IDS_MSG_FAILED_INIT_PATH_INFO   100
#define IDS_FILTER_LAST_LOGON_VERSION   101
#define IDS_DEFAULT_QUERY_LIMIT_REACHED 102
#define IDS_QUERY_LIMIT_REACHED         103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\querytable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      querytable.h
//
//  Contents:  Defines Enum for parsertable.
//
//  History:   25-Sep-2000    hiteshr Created
//
//--------------------------------------------------------------------------

#ifndef _QUERYTABLE_H_
#define _QUERYTABLE_H_

//forward declarations
struct _DSQUERY_ATTRTABLE_ENTRY;

//+-------------------------------------------------------------------------
// 
//  Type:      PMAKEFILTERFUNC
//
//  Synopsis:  The definition of a function that prepares ldapFilter from
//             the infix filter given on the commandline.
//
//
//  Returns:   S_OK if the pAttr members were successfully set.
//             S_FALSE if the function failed but displayed its own error message. 
//
//  History:   25-Sep-2000    hiteshr     Created
//
//---------------------------------------------------------------------------
typedef HRESULT (*PMAKEFILTERFUNC)(_DSQUERY_ATTRTABLE_ENTRY *pEntry,
                                   ARG_RECORD* pRecord,
                                   PVOID pVoid,
                                   CComBSTR &strFilter);

//+--------------------------------------------------------------------------
//
//  Struct:     _DSQUERY_ATTRTABLE_ENTRY
//
//  Purpose:    Definition of a table entry that describes the attribute for
//              which filter can be specified at commandline.
//
//  History:    25-Sep-2000 hiteshr  Created
//
//---------------------------------------------------------------------------
typedef struct _DSQUERY_ATTRTABLE_ENTRY
{
   //
   // The ldapDisplayName of the attribute
   //
   PWSTR          pszName;

   //
   // The unique identifier for this attribute that cooresponds to
   // the command line switch
   //
   UINT           nAttributeID;

   //
   // Pointer to the description of the attribute
   //
   PDSATTRIBUTEDESCRIPTION pAttrDesc;

   //
   //  function that prepares ldapFilter from
   //  the infix filter given on the commandline.
   //
   PMAKEFILTERFUNC pMakeFilterFunc;

} DSQUERY_ATTR_TABLE_ENTRY, *PDSQUERY_ATTR_TABLE_ENTRY;

typedef enum{
	DSQUERY_OUTPUT_ATTRONLY,	//Only the names of attributes
    DSQUERY_OUTPUT_ATTR,		//Attribute list given at commandline
    DSQUERY_OUTPUT_DN,			//DN
    DSQUERY_OUTPUT_RDN,			//RDN
    DSQUERY_OUTPUT_UPN,			//UPN
    DSQUERY_OUTPUT_SAMID,		//SAMID
    DSQUERY_OUTPUT_NTLMID,
}DSQUERY_OUTPUT_FORMAT;


typedef struct _DSQUERY_OUTPUT_FORMAT_MAP
{
    LPCWSTR pszOutputFormat;
    DSQUERY_OUTPUT_FORMAT  outputFormat;
}DSQUERY_OUTPUT_FORMAT_MAP,*PDSQUERY_OUTPUT_FORMAT_MAP;


//+--------------------------------------------------------------------------
//
//  Struct:     _DSQueryObjectTableEntry
//
//  Purpose:    Definition of a table entry that describes attributes of a given
//              objecttype
//
//  History:    25-Sep-2000 hiteshr Created
//
//---------------------------------------------------------------------------

typedef struct _DSQueryObjectTableEntry
{
   //
   // The objectClass of the object to be created or modified
   //
   PCWSTR pszObjectClass;

   //
   // The command line string used to determine the object class
   // This is not always identical to pszObjectClass
   //
   PCWSTR pszCommandLineObjectType;

   //
   // The table to merge with the common switches for the parser
   //
   ARG_RECORD* pParserTable;

   //
   // The ID of the Usage help text for this 
   //
   UINT nUsageID;

   //
   // A count of the number of attributes in the table below
   //
   DWORD dwAttributeCount;

   //
   // A table of attributes for
   // which filter can be specified at commandline.
   //
   DSQUERY_ATTR_TABLE_ENTRY** pAttributeTable; 

   //
   // A count of the number of output formats in the table below
   //
   DWORD dwOutputCount;

   //
   // Array of valid values for Output format. NULL in case of dsquery *
   //
   PDSQUERY_OUTPUT_FORMAT_MAP *ppValidOutput;

   //
   // The unique identifier for commandline scope switch in ParserTable
   // -1 if not applicable
   //
   UINT           nScopeID;

   //
   //This is the default fiter to use in case no filter is specified on commandline
   //
   LPCWSTR pszDefaultFilter;

   //
   //Append this filter to filter specifed at commandline.
   //
   LPCWSTR pszPrefixFilter;

   // Some sort of creation function
} DSQueryObjectTableEntry, *PDSQueryObjectTableEntry;


typedef enum COMMON_COMMAND
{
   //
   // Common switches
   //
#ifdef DBG
   eCommDebug,
#endif
   eCommHelp,
   eCommServer,
   eCommDomain,
   eCommUserName,
   eCommPassword,
   eCommQuiet,
   eCommObjectType,   
   eCommRecurse,
   eCommGC,
   eCommOutputFormat,
   eCommStartNode,   
   eCommLimit,
   eTerminator,

   //
   // Star switches
   //
   eStarScope = eTerminator,
   eStarFilter,
   eStarAttr,
   eStarAttrsOnly,
   eStarList,

   //
   // User switches
   //
   eUserScope= eTerminator,
   eUserName,
   eUserDesc,
   eUserUPN,
   eUserSamid,
   eUserInactive,
   eUserStalepwd,
   eUserDisabled,

   //
   // Computer switches
   //
   eComputerScope= eTerminator,
   eComputerName,
   eComputerDesc,
   eComputerSamid,
   eComputerInactive,
   eComputerStalepwd,
   eComputerDisabled,

   //
   // Group switches
   //
   eGroupScope = eTerminator,
   eGroupName,
   eGroupDesc,
   eGroupSamid,

   //
   // OU switches
   //
   eOUScope = eTerminator,
   eOUName,
   eOUDesc,

   //
   // Server switches
   //
   eServerForest = eTerminator,
   eServerDomain,
   eServerSite,
   eServerName,
   eServerDesc,
   eServerHasFSMO,
   eServerIsGC,

   //
   // Site switches
   //
   eSiteName = eTerminator,
   eSiteDesc,

   //
   //Contact switches
   //
   eContactScope = eTerminator,
   eContactName,
   eContactDesc,

   //
   //Subnet switches
   //
   eSubnetName = eTerminator,
   eSubnetDesc,
   eSubnetLoc,
   eSubnetSite,      

};

//
// The parser table
//
extern ARG_RECORD DSQUERY_COMMON_COMMANDS[];

//
// The table of supported objects
//
extern PDSQueryObjectTableEntry g_DSObjectTable[];

#endif //_QUERYTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsrm\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.cpp
//
//  Contents:  Defines the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#include "pch.h"

PCWSTR c_sz_arg1_com_debug       = L"debug";
PCWSTR c_sz_arg1_com_help        = L"h";
PCWSTR c_sz_arg2_com_help        = L"?";
PCWSTR c_sz_arg1_com_server      = L"s";
PCWSTR c_sz_arg2_com_server      = L"server";
PCWSTR c_sz_arg1_com_domain      = L"d";
PCWSTR c_sz_arg2_com_domain      = L"domain";
PCWSTR c_sz_arg1_com_username    = L"u";
PCWSTR c_sz_arg2_com_username    = L"username";
PCWSTR c_sz_arg1_com_password    = L"p";
PCWSTR c_sz_arg2_com_password    = L"password";
PCWSTR c_sz_arg1_com_quiet       = L"q";
PCWSTR c_sz_arg1_com_noprompt    = L"noprompt";
PCWSTR c_sz_arg1_com_continue    = L"C";
PCWSTR c_sz_arg1_com_subtree     = L"subtree";
PCWSTR c_sz_arg1_com_exclude     = L"exclude";
PCWSTR c_sz_arg1_com_objectDN    = L"Target object for this command";
PCWSTR g_pszDSCommandName        = L"dsrm";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsrm\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      cstrings.h
//
//  Contents:  Declares the global strings that are used in the parser
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

extern PCWSTR c_sz_arg1_com_debug;
extern PCWSTR c_sz_arg1_com_help;
extern PCWSTR c_sz_arg2_com_help;
extern PCWSTR c_sz_arg1_com_server;
extern PCWSTR c_sz_arg2_com_server;
extern PCWSTR c_sz_arg1_com_domain;
extern PCWSTR c_sz_arg2_com_domain;
extern PCWSTR c_sz_arg1_com_username;
extern PCWSTR c_sz_arg2_com_username;
extern PCWSTR c_sz_arg1_com_password;
extern PCWSTR c_sz_arg2_com_password;
extern PCWSTR c_sz_arg1_com_quiet;
extern PCWSTR c_sz_arg1_com_continue;
extern PCWSTR c_sz_arg1_com_noprompt;
extern PCWSTR c_sz_arg1_com_subtree;
extern PCWSTR c_sz_arg1_com_exclude;
extern PCWSTR c_sz_arg1_com_objectDN;
extern PCWSTR g_pszDSCommandName;

#endif //_CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\querybld.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      querybld.cpp
//
//  Contents:  Contains implementatin of functions to build query.
//
//  History:   24-Sep-2000    Hiteshr  Created
//             
//
//--------------------------------------------------------------------------


#include "pch.h"
#include "cstrings.h"
#include "querytable.h"
#include "usage.h"
#include "querybld.h"
#include <lmaccess.h> // UF_ACCOUNTDISABLE and UF_DONT_EXPIRE_PASSWD
#include <ntldap.h>   // LDAP_MATCHING_RULE_BIT_AND_W

static const LPWSTR g_szUserAccountCtrlQuery = L"(userAccountControl:" LDAP_MATCHING_RULE_BIT_AND_W L":=%u)";
static const LPWSTR g_szServerIsGCQuery = L"(&(objectCategory=NTDS-DSA)(options:" LDAP_MATCHING_RULE_BIT_AND_W L":=1))";


static const LPWSTR g_szCommonQueryFormat= L"(%s=%s)"; 




//+--------------------------------------------------------------------------
//
//  Function:   LdapEscape
//
//  Synopsis:   Escape the characters in *[pszInput] as required by
//              RFC 2254.
//
//  Arguments:  [pszInput] - string to escape
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      RFC 2254
//
//              If a value should contain any of the following characters
//
//                     Character       ASCII value
//                     ---------------------------
//                     *               0x2a
//                     (               0x28
//                     )               0x29
//                     \               0x5c
//                     NUL             0x00
//
//              the character must be encoded as the backslash '\'
//              character (ASCII 0x5c) followed by the two hexadecimal
//              digits representing the ASCII value of the encoded
//              character.  The case of the two hexadecimal digits is not
//              significant.
//
//---------------------------------------------------------------------------

bool
LdapEscape(IN LPCWSTR pszInput, OUT CComBSTR& strFilter)
{
	if(!pszInput)
		return FALSE;


	int iLen = (int)wcslen(pszInput);
	
	for( int i = 0; i < iLen; ++i)
	{
        switch (*(pszInput+i))
        {
        case L'(':
            strFilter += L"\\28";
            break;

        case L')':
            strFilter += L"\\29";
            break;

        case L'\\':
			if( i + 1 < iLen )
			{
				// \\ is treated as '\'
				switch (*(pszInput+i + 1))
				{
				case L'\\':
					strFilter += L"\\5c";
					i++;
					break;
				// \* is treated as '*'					
				case L'*':
					strFilter += L"\\2a";
					i++;
					break;
				default:
				// \X is treated \X only
					strFilter += L"\\5c";
					break;
				}
			}
			else
				strFilter += L"\\5c";
			           
            break;

        default:
			strFilter.Append(pszInput+i,1);
			break;
        }
    }
	return TRUE;
}


HRESULT MakeQuery(IN LPCWSTR pszAttrName,
                  IN LPCWSTR pszCommandLineFilter,
                  OUT CComBSTR& strFilter)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, MakeQuery, hr);

    if(!pszAttrName || !pszCommandLineFilter)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

	CComBSTR strEscapedCLFilter;
	LdapEscape(pszCommandLineFilter,strEscapedCLFilter);

    strFilter = L"(";
    strFilter += pszAttrName;
    strFilter += L"=";
    strFilter += strEscapedCLFilter;
    strFilter += L")";
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   CommonFilterFunc
//
//  Synopsis:   This function takes the input filter from the commandline
//              and converts it into ldapfilter.
//              For ex -user (ab* | bc*) is converted to |(cn=ab*)(cn=bc*)               
//              The pEntry->pszName given the attribute name to use in
//              filter( cn in above example).
//
//  Arguments:  [pRecord - IN] :    the command line argument structure used
//                                  to retrieve the filter entered by user
//              [pObjectEntry - IN] : pointer to the DSQUERY_ATTR_TABLE_ENTRY
//                                    which has info on attribute corresponding
//                                    switch in pRecord
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT CommonFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                         IN ARG_RECORD* pRecord,
                         IN PVOID ,
                         OUT CComBSTR& strFilter)   
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, CommonFilterFunc, hr);

    //validate input
    if( !pEntry || !pRecord
        //validate DSQUERY_ATTR_TABLE_ENTRY entry
        || !pEntry->pszName || !pEntry->nAttributeID 
        //validate pRecord
        || !pRecord->bDefined || !pRecord->strValue)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    //Make Query
    hr = MakeQuery(pEntry->pszName,
                   pRecord->strValue,
                   strFilter);

    DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   StarFilterFunc
//
//  Synopsis:   Filter Function for dsquery *. It returns the value of 
//              -filter flag.                
//
//  Arguments:  [pRecord - IN] :    the command line argument structure used
//                                  to retrieve the filter entered by user
//              [pObjectEntry - IN] : pointer to the DSQUERY_ATTR_TABLE_ENTRY
//                                    which has info on attribute corresponding
//                                    switch in pRecord
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StarFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                         IN ARG_RECORD* pRecord,
                         IN PVOID ,
                         OUT CComBSTR& strFilter)   
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, StarFilterFunc, hr);

    //validate input
    if(!pEntry || !pRecord
        //validate DSQUERY_ATTR_TABLE_ENTRY entry
       || !pEntry->nAttributeID 
       //validate pRecord
       || !pRecord->bDefined || !pRecord->strValue)
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    strFilter = pRecord->strValue;
    DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   InactiveFilterFunc
//
//  Synopsis:   Filter Function for account disabled query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT InactiveFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN PVOID ,
                           OUT CComBSTR& strFilter)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, InactiveFilterFunc, hr);

    if( !pEntry || !pRecord || !pRecord->bDefined )
    {
        hr = E_INVALIDARG;
        return hr;
    }

	//
	//Unit at commandline is Week
	//
    int nDays = pRecord->nValue * 7;

    FILETIME ftCurrent;
    ::GetSystemTimeAsFileTime(&ftCurrent);

    LARGE_INTEGER li;
    li.LowPart = ftCurrent.dwLowDateTime;
    li.HighPart = ftCurrent.dwHighDateTime;

	//
	//Get the number of days since the reference time
	//
	int nDaysSince1600 = (int)(li.QuadPart/(((LONGLONG) (24 * 60) * 60) * 10000000));

	if(nDaysSince1600 < nDays)
	{
		hr = E_INVALIDARG;
		return hr;
	}

	li.QuadPart -= ((((LONGLONG)nDays * 24) * 60) * 60) * 10000000;
	
    CComBSTR strTime;
    litow(li, strTime);
    WCHAR buffer[256];
    wsprintf(buffer,L"(lastLogonTimestamp<=%s)",strTime);
    strFilter = buffer;

    DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   StalepwdFilterFunc
//
//  Synopsis:   Filter Function for Stale Password query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StalepwdFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN PVOID ,
                           OUT CComBSTR& strFilter)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, StalepwdFilterFunc, hr);

    if( !pEntry || !pRecord || !pRecord->bDefined )
    {
        hr = E_INVALIDARG;
        return hr;
    }

    int nDays = pRecord->nValue;

    FILETIME ftCurrent;
    ::GetSystemTimeAsFileTime(&ftCurrent);

    LARGE_INTEGER li;
    li.LowPart = ftCurrent.dwLowDateTime;
    li.HighPart = ftCurrent.dwHighDateTime;
	//
	//Get the number of days since the reference time
	//
	int nDaysSince1600 = (int)(li.QuadPart/(((LONGLONG) (24 * 60) * 60) * 10000000));

	if(nDaysSince1600 < nDays)
	{
		hr = E_INVALIDARG;
		return hr;
	}


    li.QuadPart -= ((((ULONGLONG)nDays * 24) * 60) * 60) * 10000000;

    CComBSTR strTime;
    litow(li, strTime);
    WCHAR buffer[256];
    wsprintf(buffer,L"(pwdLastSet<=%s)",strTime);
    strFilter = buffer;

    DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);
    return hr;
}
//+--------------------------------------------------------------------------
//
//  Function:   DisabledFilterFunc
//
//  Synopsis:   Filter Function for account disabled query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT DisabledFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
                         IN ARG_RECORD* ,
                         IN PVOID ,
                         OUT CComBSTR& strFilter)   
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, DisabledFilterFunc, hr);

    WCHAR buffer[256]; //This is long enough
    wsprintf(buffer, g_szUserAccountCtrlQuery,UF_ACCOUNTDISABLE);
    strFilter = buffer;

    DEBUG_OUTPUT(LEVEL3_LOGGING, L"filter = %s", strFilter);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   SubnetSiteFilterFunc
//
//  Synopsis:   Filter Function for -site switch in dsquery subnet. 
//
//  Arguments:  [pEntry - IN] :  Not Used
//              [pRecord - IN] : Command Line value supplied by user
//              [pVoid - IN]   : suffix for the siteobject attribute.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    24-April-2001   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT SubnetSiteFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
							 IN ARG_RECORD* pRecord,
                             IN PVOID pParam,
                             OUT CComBSTR& strFilter)  
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, InactiveFilterFunc, hr);

    if( !pRecord || !pRecord->bDefined || !pParam)
    {
        hr = E_INVALIDARG;
        return hr;
    }

	CComBSTR strEscapedCLFilter;
	LdapEscape(pRecord->strValue,strEscapedCLFilter);
	

	strFilter = L"(siteobject=cn=";
	strFilter += strEscapedCLFilter;
	strFilter += L",";
	strFilter += *(static_cast<BSTR*>(pParam));
	strFilter += L")";
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildQueryFilter
//
//  Synopsis:   This function builds the LDAP query filter for given object type.
//
//  Arguments:  [pCommandArgs - IN] :the command line argument structure used
//                                  to retrieve the values of switches
//              [pObjectEntry - IN] :Contains info about the object type
//				[pParam		   -IN]	:This value is passed to filter function.
//              [strLDAPFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT BuildQueryFilter(PARG_RECORD pCommandArgs, 
                         PDSQueryObjectTableEntry pObjectEntry,
						 PVOID pParam,
                         CComBSTR& strLDAPFilter)
{
    ENTER_FUNCTION_HR(LEVEL3_LOGGING, BuildQueryFilter, hr);

    if( !pCommandArgs || !pObjectEntry )
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        return hr;
    }

    DSQUERY_ATTR_TABLE_ENTRY** pAttributeTable; 
    DWORD dwAttributeCount;


    pAttributeTable = pObjectEntry->pAttributeTable;
    dwAttributeCount = pObjectEntry->dwAttributeCount;

    if( !pAttributeTable || !dwAttributeCount )
    {
        hr = E_INVALIDARG;
        return hr;
    }

    BOOL bUseDefaultFilter = TRUE;
    CComBSTR strFilter;
    for( UINT i = 0; i < dwAttributeCount; ++i )
    {
        if(pCommandArgs[pAttributeTable[i]->nAttributeID].bDefined)
        {
            bUseDefaultFilter = FALSE;
            CComBSTR strLocalFilter;
            hr = pAttributeTable[i]->pMakeFilterFunc(pAttributeTable[i],
                                                    pCommandArgs + pAttributeTable[i]->nAttributeID,
                                                    pParam,
                                                    strLocalFilter);
            if(FAILED(hr))
                return hr;
            
            strFilter += strLocalFilter;
            DEBUG_OUTPUT(FULL_LOGGING, L"Current filter = %s", strFilter);
        }   
    }
    //
    //If none of the commandline filter switches are specified, use
    //default filter
    //
    strLDAPFilter = L"(";
    if(bUseDefaultFilter)
    {
        strLDAPFilter += pObjectEntry->pszDefaultFilter;
    }
    else
    {
        if(pObjectEntry->pszPrefixFilter)
        {
            strLDAPFilter += pObjectEntry->pszPrefixFilter;
            strLDAPFilter += strFilter;
        }
        else
             strLDAPFilter += strFilter;
    }
    strLDAPFilter += L")";

    DEBUG_OUTPUT(LEVEL3_LOGGING, L"ldapfilter = %s", strLDAPFilter);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsquery\querybld.h ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      querybld.h
//
//  Contents:  Contains declarations of functions to build query.
//
//  History:   24-Sep-2000    Hiteshr  Created
//             
//
//--------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Function:   CommonFilterFunc
//
//  Synopsis:   This function takes the input filter from the commandline
//              and converts it into ldapfilter.
//              For ex -user (ab* | bc*) is converted to |(cn=ab*)(cn=bc*)               
//              The pEntry->pszName given the attribute name to use in
//              filter( cn in above example).
//
//  Arguments:  [pRecord - IN] :    the command line argument structure used
//                                  to retrieve the filter entered by user
//              [pObjectEntry - IN] : pointer to the DSQUERY_ATTR_TABLE_ENTRY
//                                    which has info on attribute corresponding
//                                    switch in pRecord
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT CommonFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                         IN ARG_RECORD* pRecord,
                         IN PVOID pVoid,
                         OUT CComBSTR& strFilter);
                         
                         
//+--------------------------------------------------------------------------
//
//  Function:   StarFilterFunc
//
//  Synopsis:   Filter Function for dsquery *. It returns the value of 
//              -filter flag.                
//
//  Arguments:  [pRecord - IN] :    the command line argument structure used
//                                  to retrieve the filter entered by user
//              [pObjectEntry - IN] : pointer to the DSQUERY_ATTR_TABLE_ENTRY
//                                    which has info on attribute corresponding
//                                    switch in pRecord
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StarFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                         IN ARG_RECORD* pRecord,
                         IN PVOID pVoid,
                         OUT CComBSTR& strFilter);   
                            


//
//  Function:   DisabledFilterFunc
//
//  Synopsis:   Filter Function for account disabled query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT DisabledFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *,
                         IN ARG_RECORD* ,
                         IN PVOID ,
                         OUT CComBSTR& strFilter);   

//+--------------------------------------------------------------------------
//
//  Function:   InactiveFilterFunc
//
//  Synopsis:   Filter Function for account disabled query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT InactiveFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN PVOID ,
                           OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   StalepwdFilterFunc
//
//  Synopsis:   Filter Function for stale password query. 
//
//  Arguments:  [pRecord - IN] :    Not Used
//              [pObjectEntry - IN] : Not Used
//              [pVoid - IN]        :Not used.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT StalepwdFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
                           IN ARG_RECORD* pRecord,
                           IN PVOID ,
                           OUT CComBSTR& strFilter);  


//+--------------------------------------------------------------------------
//
//  Function:   SubnetSiteFilterFunc
//
//  Synopsis:   Filter Function for -site switch in dsquery subnet. 
//
//  Arguments:  [pEntry - IN] :  Not Used
//              [pRecord - IN] : Command Line value supplied by user
//              [pVoid - IN]   : suffix for the siteobject attribute.
//              [strFilter - OUT]   :Contains the output filter.
//  Returns:    HRESULT : S_OK if everything succeeded
//
//  History:    24-April-2001   hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT SubnetSiteFilterFunc(IN DSQUERY_ATTR_TABLE_ENTRY *pEntry,
							 IN ARG_RECORD* pRecord,
                             IN PVOID pParam,
                             OUT CComBSTR& strFilter);

//+--------------------------------------------------------------------------
//
//  Function:   BuildQueryFilter
//
//  Synopsis:   This function builds the LDAP query filter for given object type.
//
//  Arguments:  [pCommandArgs - IN] :the command line argument structure used
//                                  to retrieve the values of switches
//              [pObjectEntry - IN] :Contains info about the object type
//				[pParam		   -IN]	:This value is passed to filter function.
//              [strLDAPFilter - OUT]   :Contains the output filter.		
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//                        Anything else is a failure code from an ADSI call
//
//  History:    25-Sep-2000   hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT BuildQueryFilter(PARG_RECORD pCommandArgs, 
                         PDSQueryObjectTableEntry pObjectEntry,
						 PVOID pParam,
                         CComBSTR& strLDAPFilter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parser\parser.h ===
#define IDS_PARSE_ERROR_SWITCH_NOTDEFINED       8001
#define IDS_PARSE_ERROR_SWITCH_VALUE            8002
#define IDS_PARSE_ERROR_UNKNOWN_INPUT_PARAMETER 8003
#define IDS_PARSE_ERROR_MULTIPLE_DEF            8004       
#define IDS_PARSE_ERROR_SWICH_NO_VALUE          8005
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parser\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef _pch_h
#define _pch_h

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include "parser.h"
#include "strings.h"
#include "util.h"
#include "varg.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsrm\rmtable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.cpp
//
//  Contents:  Defines a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "cstrings.h"
#include "rmtable.h"

//+-------------------------------------------------------------------------
// Parser table
//--------------------------------------------------------------------------
ARG_RECORD DSRM_COMMON_COMMANDS[] = 
{
#ifdef DBG
   //
   // -debug, -debug
   //
   0,(LPWSTR)c_sz_arg1_com_debug, 
   ID_ARG2_NULL,NULL,
   ARG_TYPE_DEBUG, ARG_FLAG_OPTIONAL|ARG_FLAG_HIDDEN,  
   (CMD_TYPE)0,     
   0,  NULL,
#endif

   //
   // h, ?
   //
   0,(LPWSTR)c_sz_arg1_com_help, 
   0,(LPWSTR)c_sz_arg2_com_help, 
   ARG_TYPE_HELP, ARG_FLAG_OPTIONAL,  
   (CMD_TYPE)FALSE,     
   0,  NULL,

   //
   // s,server
   //
   0,(LPWSTR)c_sz_arg1_com_server, 
   0,(LPWSTR)c_sz_arg2_com_server, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // d,domain
   //
   0,(LPWSTR)c_sz_arg1_com_domain, 
   0,(LPWSTR)c_sz_arg2_com_domain, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // u, username    
   //
   0,(LPWSTR)c_sz_arg1_com_username, 
   0,(LPWSTR)c_sz_arg2_com_username, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // w, password
   //
   0,(LPWSTR)c_sz_arg1_com_password, 
   0,(LPWSTR)c_sz_arg2_com_password, 
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  ValidateAdminPassword,

   //
   // q,q
   //
   0,(LPWSTR)c_sz_arg1_com_quiet, 
   0,NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,  
   NULL,    
   0,  NULL,

   //
   // objectDN
   //
   0,(LPWSTR)c_sz_arg1_com_objectDN, 
   0,NULL, 
   ARG_TYPE_MSZ, ARG_FLAG_REQUIRED|ARG_FLAG_NOFLAG|ARG_FLAG_STDIN|ARG_FLAG_DN,  
   NULL,    
   0,  NULL,

   //
   // continue
   //
   0, (PWSTR)c_sz_arg1_com_continue,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,

   //
   // noprompt
   //
   0, (PWSTR)c_sz_arg1_com_noprompt,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,

   //
   // subtree
   //
   0, (PWSTR)c_sz_arg1_com_subtree,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,

   //
   // exclude
   //
   0, (PWSTR)c_sz_arg1_com_exclude,
   0, NULL,
   ARG_TYPE_BOOL, ARG_FLAG_OPTIONAL,
   NULL,
   0, NULL,


   ARG_TERMINATOR
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsrm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsrm.rc
//

#define IDS_DELETE_PROMPT 101
#define IDS_DELETE_PROMPT_EXCLUDE 102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsrm\dsrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      dsrm.cpp
//
//  Contents:  Defines the main function and parser tables for the dsrm
//             command line utility
//
//  History:    07-Sep-2000   HiteshR   Created dsmove
//              13-Sep-2000   JonN      Templated dsrm from dsmove
//              26-Sep-2000   JonN      Cleanup in several areas
//             
//--------------------------------------------------------------------------

/*
Error message strategy:

-- If errors occur before any particular directory object
   is contacted, they will be reported as "dsrm failed: <error>".

-- For each target, either one or more errors will be reported,
   or (if "quiet" is not specified) one success will be reported.
   If "continue" is not specified, nothing will be reported on
   targets after the first one to experience an error.

-- More than one error can be reported on a target, but only if
   the "subtree", "exclude" and "continue" flags are all specified.
   In this case, DSRM will continue to delete the other children
   of that specified target object.

-- If a subtree is being deleted and the error actually relates to
   a child object, the error reported will reference the particular
   child object, rather than the specified target object.

-- Failure to delete a system object will be reported as
   ERROR_DS_CANT_DELETE_DSA_OBJ or ERROR_DS_CANT_DELETE.

-- Failure to delete the logged-in user will be reported as
   ERROR_DS_CANT_DELETE.  This test will only be performed on the
   specified target object, not on any of its child objects.
*/

#include "pch.h"
#include "stdio.h"
#include "cstrings.h"
#include "usage.h"
#include "rmtable.h"
#include "resource.h" // IDS_DELETE_PROMPT[_EXCLUDE]
#include <ntldap.h>   // LDAP_MATCHING_RULE_BIT_AND_W
#define SECURITY_WIN32
#include <security.h> // GetUserNameEx

//
// Function Declarations
//
HRESULT ValidateSwitches();
HRESULT DoRm( PWSTR pszDoubleNullObjectDN );
HRESULT DoRmItem( CDSCmdCredentialObject& credentialObject,
                  CDSCmdBasePathsInfo& basePathsInfo,
                  PWSTR pszObjectDN,
                  bool* pfErrorReported );
HRESULT IsCriticalSystemObject( CDSCmdBasePathsInfo& basePathsInfo,
                                IADs* pIADs,
                                const BSTR pszClass,
                                const BSTR pszObjectDN,
                                bool* pfErrorReported );
HRESULT RetrieveStringColumn( IDirectorySearch* pSearch,
                              ADS_SEARCH_HANDLE SearchHandle,
                              LPWSTR szColumnName,
                              CComBSTR& sbstr );
HRESULT SetSearchPreference(IDirectorySearch* piSearch, ADS_SCOPEENUM scope);
HRESULT IsThisUserLoggedIn( const BSTR bstrUserDN );
HRESULT DeleteChildren( CDSCmdCredentialObject& credentialObject,
                        IADs* pIADs,
                        bool* pfErrorReported );


//
// Global variables
//
BOOL fSubtree  = false; // BOOL is used in parser structure
BOOL fExclude  = false;
BOOL fContinue = false;
BOOL fQuiet    = false;
BOOL fNoPrompt = false;
LPWSTR g_lpszLoggedInUser = NULL;

//+--------------------------------------------------------------------------
//
//  Function:   _tmain
//
//  Synopsis:   Main function for command-line app
//              beyond what parser can do.
//
//  Returns:    int : HRESULT to be returned from command-line app
//                        
//  History:    07-Sep-2000   HiteshR   Created dsmove
//              13-Sep-2000   JonN      Templated from dsmove
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------
int __cdecl _tmain( VOID )
{

    int argc = 0;
    LPTOKEN pToken = NULL;
    HRESULT hr = S_OK;
    
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        DisplayErrorMessage(g_pszDSCommandName, NULL, hr);
        goto exit_gracefully;
    }
    
    hr = HRESULT_FROM_WIN32( GetCommandInput(&argc,&pToken) );
    if (FAILED(hr) || argc == 1)
    {
        if (FAILED(hr)) // JonN 3/27/01 344920
            DisplayErrorMessage( g_pszDSCommandName, NULL, hr );
        DisplayMessage(USAGE_DSRM);
        goto exit_gracefully;
    }

    PARSE_ERROR Error;
    ::ZeroMemory( &Error, sizeof(Error) );
    if(!ParseCmd(DSRM_COMMON_COMMANDS,
             argc-1, 
             pToken+1,
             USAGE_DSRM, 
             &Error,
             TRUE))
    {
        // JonN 11/2/00 ParseCmd displays "/?" help
        if (Error.Error != PARSE_ERROR_HELP_SWITCH)
        {
            DisplayMessage(USAGE_DSRM);
        }
        hr = E_INVALIDARG;
        goto exit_gracefully;
    }

    hr = ValidateSwitches();
    if (FAILED(hr))
    {
        DisplayMessage(USAGE_DSRM);
        goto exit_gracefully;
    }

    //
    // Command line parsing succeeded
    //
    hr = DoRm( DSRM_COMMON_COMMANDS[eCommObjectDN].strValue );

exit_gracefully:

    // Free Command Array
    FreeCmd(DSRM_COMMON_COMMANDS);
    // Free Token
    if(pToken)
        delete []pToken;

    if (NULL != g_lpszLoggedInUser)
        delete[] g_lpszLoggedInUser;

    //
    // Uninitialize COM
    //
    CoUninitialize();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateSwitches
//
//  Synopsis:   Does advanced switch dependency validation
//              beyond what parser can do.
//
//  Arguments:  
//
//  Returns:    S_OK or E_INVALIDARG
//                        
//  History:    07-Sep-2000   HiteshR   Created dsmove
//              13-Sep-2000   JonN      Templated from dsmove
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------

HRESULT ValidateSwitches()
{
    // read subtree parameters
    fSubtree  = DSRM_COMMON_COMMANDS[eCommSubtree].bDefined;
    fExclude  = DSRM_COMMON_COMMANDS[eCommExclude].bDefined;
    fContinue = DSRM_COMMON_COMMANDS[eCommContinue].bDefined;
    fQuiet    = DSRM_COMMON_COMMANDS[eCommQuiet].bDefined;
    fNoPrompt = DSRM_COMMON_COMMANDS[eCommNoPrompt].bDefined;

    if (   NULL == DSRM_COMMON_COMMANDS[eCommObjectDN].strValue
        || L'\0' == DSRM_COMMON_COMMANDS[eCommObjectDN].strValue[0]
        || (fExclude && !fSubtree) )
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING, L"ValidateSwitches: Invalid switches");
        return E_INVALIDARG;
    }

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoRm
//
//  Synopsis:   Deletes the appropriate object(s)
//              DoRm reports its own error and success messages
//
//  Arguments:  pszDoubleNullObjectDN: double-null-terminated stringlist
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              Could be almost any ADSI error
//
//  History:    13-Sep-2000   JonN      templated from DoMove
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------
HRESULT DoRm( PWSTR pszDoubleNullObjectDN )
{
    ASSERT(   NULL != pszDoubleNullObjectDN
           && L'\0' != *pszDoubleNullObjectDN );

    //
    // Check to see if we are doing debug spew
    //
#ifdef DBG
    bool bDebugging = DSRM_COMMON_COMMANDS[eCommDebug].bDefined &&
                      DSRM_COMMON_COMMANDS[eCommDebug].nValue;
    if (bDebugging)
    {
       ENABLE_DEBUG_OUTPUT(DSRM_COMMON_COMMANDS[eCommDebug].nValue);
    }
#else
    DISABLE_DEBUG_OUTPUT();
#endif
    ENTER_FUNCTION(MINIMAL_LOGGING, DoRm);

    HRESULT hr = S_OK;

    CDSCmdCredentialObject credentialObject;
    if (DSRM_COMMON_COMMANDS[eCommUserName].bDefined &&
        DSRM_COMMON_COMMANDS[eCommUserName].strValue)
    {
        credentialObject.SetUsername(
            DSRM_COMMON_COMMANDS[eCommUserName].strValue);
        credentialObject.SetUsingCredentials(true);
    }

    if (DSRM_COMMON_COMMANDS[eCommPassword].bDefined &&
        DSRM_COMMON_COMMANDS[eCommPassword].strValue)
    {
        credentialObject.SetPassword(
            DSRM_COMMON_COMMANDS[eCommPassword].strValue);
        credentialObject.SetUsingCredentials(true);
    }

    //
    // Initialize the base paths info from the command line args
    // 
    // CODEWORK should I just make this global?
    CDSCmdBasePathsInfo basePathsInfo;
    if (DSRM_COMMON_COMMANDS[eCommServer].bDefined &&
        DSRM_COMMON_COMMANDS[eCommServer].strValue)
    {
        hr = basePathsInfo.InitializeFromName(
                credentialObject, 
                DSRM_COMMON_COMMANDS[eCommServer].strValue);
    }
    else if (DSRM_COMMON_COMMANDS[eCommDomain].bDefined &&
             DSRM_COMMON_COMMANDS[eCommDomain].strValue)
    {
        hr = basePathsInfo.InitializeFromName(
                credentialObject, 
                DSRM_COMMON_COMMANDS[eCommDomain].strValue);
    }
    else
    {
        hr = basePathsInfo.InitializeFromName(credentialObject, NULL);
    }
    if (FAILED(hr))
    {
        //
        // Display error message and return
        //
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRm: InitializeFromName failure:  0x%08x",
                     hr);
        DisplayErrorMessage(g_pszDSCommandName, NULL, hr);
        return hr;
    }

    // count through double-NULL-terminated string list
    for ( ;
          L'\0' != *pszDoubleNullObjectDN;
          pszDoubleNullObjectDN += (wcslen(pszDoubleNullObjectDN)+1) )
    {
        bool fErrorReported = false;
        // return the error value for the first error encountered
        HRESULT hrThisItem = DoRmItem( credentialObject,
                                       basePathsInfo,
                                       pszDoubleNullObjectDN,
                                       &fErrorReported );
        if (FAILED(hrThisItem))
        {
            if (!FAILED(hr))
                hr = hrThisItem;
            if (!fErrorReported)
                DisplayErrorMessage(g_pszDSCommandName,
                                    pszDoubleNullObjectDN,
                                    hrThisItem);
            if (fContinue)
                continue;
            else
                break;
        }

        // display success message for each individual deletion
        if (!fQuiet && S_FALSE != hrThisItem)
        {
            DisplaySuccessMessage(g_pszDSCommandName,
                                  pszDoubleNullObjectDN);
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoRmItem
//
//  Synopsis:   Deletes a single target
//
//  Arguments:  credentialObject
//              basePathsInfo
//              pszObjectDN: X500 DN of object to delete
//              *pfErrorReported: Will be set to true if DoRmItem takes
//                                care of reporting the error itself
//
//  Returns:    HRESULT : error code to be returned from command-line app
//                        Could be almost any ADSI error
//                        S_FALSE indicates the operation was cancelled
//
//  History:    13-Sep-2000   JonN      Created
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------

HRESULT DoRmItem( CDSCmdCredentialObject& credentialObject,
                  CDSCmdBasePathsInfo& basePathsInfo,
                  PWSTR pszObjectDN,
                  bool* pfErrorReported )
{
    ASSERT(   NULL != pszObjectDN
           && L'\0' != *pszObjectDN
           && NULL != pfErrorReported );

    ENTER_FUNCTION(LEVEL3_LOGGING, DoRmItem);

    HRESULT hr = S_OK;

    CComBSTR sbstrADsPath;
    basePathsInfo.ComposePathFromDN(pszObjectDN,sbstrADsPath);

    CComPtr<IADs> spIADsItem;
    hr = DSCmdOpenObject(credentialObject,
                         sbstrADsPath,
                         IID_IADs,
                         (void**)&spIADsItem,
                         true);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRmItem(%s): DsCmdOpenObject failure: 0x%08x",
                     sbstrADsPath, hr);
        return hr;
    }
    ASSERT( !!spIADsItem );

    // CODEWORK Is this a remote LDAP operation, or does the ADsOpenObject
    // already retrieve the class?  I can bundle the class retrieval into
    // the IsCriticalSystemObject search if necessary.
    CComBSTR sbstrClass;
    hr = spIADsItem->get_Class( &sbstrClass );
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRmItem(%s): get_class failure: 0x%08x",
                     sbstrADsPath, hr);
        return hr;
    }
    ASSERT( !!sbstrClass && L'\0' != sbstrClass[0] );

    // Check whether this is a critical system object
    // This method will report its own errors
    hr = IsCriticalSystemObject( basePathsInfo,
                                 spIADsItem,
                                 sbstrClass,
                                 pszObjectDN,
                                 pfErrorReported );
    if (FAILED(hr))
        return hr;

    if (!fNoPrompt)
    {
        while (true)
        {
            // display prompt
            // CODEWORK allow "a" for all?
            CComBSTR sbstrPrompt;
            if (!sbstrPrompt.LoadString(
                    ::GetModuleHandle(NULL),
                    (fExclude) ? IDS_DELETE_PROMPT_EXCLUDE
                               : IDS_DELETE_PROMPT))
            {
                ASSERT(FALSE);
                sbstrPrompt = (fExclude)
                    ? L"Are you sure you wish to delete %1 (Y/N)? "
                    : L"Are you sure you wish to delete all children of %1 (Y/N)? ";
            }
            PTSTR ptzSysMsg = NULL;
            DWORD cch = ::FormatMessage(
                  FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_STRING
                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                sbstrPrompt,
                0,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&ptzSysMsg,
                0,
                (va_list*)&pszObjectDN );
            if (0 == cch)
            {
                DEBUG_OUTPUT(MINIMAL_LOGGING,
                             L"DoRmItem(%s): FormatMessage failure: 0x%08x",
                             sbstrADsPath, hr);
                return HRESULT_FROM_WIN32( ::GetLastError() );
            }
            DisplayOutputNoNewline( ptzSysMsg );
            (void) ::LocalFree( ptzSysMsg );

            // read a line of console input
            WCHAR ach[129];
            ::ZeroMemory( ach, sizeof(ach) );
            DWORD cchRead = 0;
            if (!ReadConsole(GetStdHandle(STD_INPUT_HANDLE),
                             ach,
                             128,
                             &cchRead,
                             NULL))
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_INSUFFICIENT_BUFFER == dwErr)
                    continue;
                DEBUG_OUTPUT(MINIMAL_LOGGING,
                             L"DoRmItem(%s): ReadConsole failure: %d",
                             sbstrADsPath, dwErr);
                return HRESULT_FROM_WIN32(dwErr);
            }
            if (cchRead < 1)
                continue;

            // return S_FALSE if user types 'n'
            WCHAR wchUpper = (WCHAR)::CharUpper( (LPTSTR)(ach[0]) );
            if (L'N' == wchUpper)
                return S_FALSE;
            else if (L'Y' == wchUpper)
                break;

            // loop back to prompt
        }
    }

    if (fExclude)
    {
        return DeleteChildren( credentialObject, spIADsItem, pfErrorReported );
    }
    else if (fSubtree)
    {
        // delete the whole subtree
        CComQIPtr<IADsDeleteOps> spDeleteOps( spIADsItem );
        ASSERT( !!spDeleteOps );
        if ( !spDeleteOps )
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"DoRmItem(%s): IADsDeleteOps init failure",
                         sbstrADsPath);
            return E_FAIL;
        }
        hr = spDeleteOps->DeleteObject( NULL );
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"DoRmItem(%s): DeleteObject failure: 0x%08x",
                         sbstrADsPath, hr);
        }
        else
        {
            DEBUG_OUTPUT(FULL_LOGGING,
                         L"DoRmItem(%s): DeleteObject succeeds: 0x%08x",
                         sbstrADsPath, hr);
        }
        return hr;
    }

    // Single-object deletion

    // get IADsContainer for parent object
    CComBSTR sbstrParentObjectPath;
    hr = spIADsItem->get_Parent( &sbstrParentObjectPath );
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRmItem(%s): get_Parent failure: 0x%08x",
                     sbstrADsPath, hr);
        return hr;
    }
    ASSERT(   !!sbstrParentObjectPath
           && L'\0' != sbstrParentObjectPath[0] );
    CComPtr<IADsContainer> spDsContainer;
    hr = DSCmdOpenObject(credentialObject,
                         sbstrParentObjectPath,
                         IID_IADsContainer,
                         (void**)&spDsContainer,
                         true);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DoRmItem(%s): DSCmdOpenObject failure: 0x%08x",
                     sbstrParentObjectPath, hr);
        return hr;
    }
    ASSERT( !!spDsContainer );

    // get leaf name
    CComBSTR sbstrLeafWithDecoration; // will contain "CN="
    CPathCracker pathCracker;
    hr = pathCracker.Set(pszObjectDN, ADS_SETTYPE_DN);
    ASSERT(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    hr = pathCracker.GetElement(0, &sbstrLeafWithDecoration);
    ASSERT(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    ASSERT(   !!sbstrLeafWithDecoration
           && L'\0' != sbstrLeafWithDecoration[0] );

    // delete just this object
    hr = spDsContainer->Delete( sbstrClass, sbstrLeafWithDecoration );
    DEBUG_OUTPUT((FAILED(hr)) ? MINIMAL_LOGGING : FULL_LOGGING,
                 L"DoRmItem(%s): Delete(%s, %s) returns 0x%08x",
                 sbstrADsPath, sbstrClass, sbstrLeafWithDecoration, hr);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsCriticalSystemObject
//
//  Synopsis:   Checks whether a single target is a critical system
//              object or whether the subtree contains any such objects.
//              The root object is tested on these criteria (if "exclude"
//              is not specified):
//              (1) is of class user and represents the logged-in user
//              (2) is of class nTDSDSA
//              (3) is of class trustedDomain
//              (3.5) is of class interSiteTransport (212232 JonN 10/27/00)
//              (4) is of class computer and userAccountControl indicates
//                  that this is a DC
//              The entire subtree is tested on these criteria (if "subtree"
//              is specified, excepting the root object if "exclude"
//              is specified):
//              (1) isCriticalSystemObject is true
//              (2) is of class nTDSDSA
//              (3) is of class trustedDomain
//              (3.5) is of class interSiteTransport (212232 JonN 10/27/00)
//              (4) is of class computer and userAccountControl indicates
//                  that this is a DC
//
//  Arguments:  credentialObject
//              basePathsInfo
//              pszObjectDN: X500 DN of object to delete
//              *pfErrorReported: Will be set to true if DoRmItem takes
//                                care of reporting the error itself
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              Could be almost any ADSI error, although likely codes are
//              ERROR_DS_CANT_DELETE
//              ERROR_DS_CANT_DELETE_DSA_OBJ
//              ERROR_DS_CANT_FIND_DSA_OBJ
//
//  History:    13-Sep-2000   JonN      Created
//              26-Sep-2000   JonN      Updated error reporting
//
//---------------------------------------------------------------------------
// CODEWORK This could use the pszMessage parameter to ReportErrorMessage
// to provide additional details on why the object is protected.
HRESULT IsCriticalSystemObject( CDSCmdBasePathsInfo& basePathsInfo,
                                IADs* pIADs,
                                const BSTR pszClass,
                                const BSTR pszObjectDN,
                                bool* pfErrorReported )
{
    ASSERT( pIADs && pszClass && pszObjectDN && pfErrorReported );
    if ( !pIADs || !pszClass || !pszObjectDN || !pfErrorReported )
        return E_INVALIDARG;

    ENTER_FUNCTION(LEVEL5_LOGGING, IsCriticalSystemObject);

    HRESULT hr = S_OK;

    // Class-specific checks
    // Let the parent report errors on the root object
    if (fExclude)
    {
        // skip tests on root object, it won't be deleted anyhow
    }
    else if (!_wcsicmp(L"user",pszClass))
    {
        // CODEWORK we could do this check for the entire subtree
        hr = IsThisUserLoggedIn(pszObjectDN);
        if (FAILED(hr))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"IsCriticalSystemObject(%s): User is logged in: 0x%08x",
                         pszObjectDN, hr);
            return hr;
        }
    }
    else if (!_wcsicmp(L"nTDSDSA",pszClass))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"IsCriticalSystemObject(%s): Object is an nTDSDSA",
                     pszObjectDN);
        return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE_DSA_OBJ);
    }
    else if (!_wcsicmp(L"trustedDomain",pszClass))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"IsCriticalSystemObject(%s): Object is a trustedDomain",
                     pszObjectDN);
        return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE);
    }
    else if (!_wcsicmp(L"interSiteTransport",pszClass))
    {
        // 212232 JonN 10/27/00 Protect interSiteTransport objects
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"IsCriticalSystemObject(%s): Object is an interSiteTransport",
                     pszObjectDN);
        return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE);
    }
    else if (!_wcsicmp(L"computer",pszClass)) 
    {
        // Figure out if the account is a DC
        CComVariant Var;
        hr = pIADs->Get(L"userAccountControl", &Var);
        if ( SUCCEEDED(hr) && (Var.lVal & ADS_UF_SERVER_TRUST_ACCOUNT))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
      L"IsCriticalSystemObject(%s): Object is a DC computer object",
                         pszObjectDN);
            return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE_DSA_OBJ);
        }
    }

    if (!fSubtree)
        return S_OK;

    // The user passed the "subtree" flag.  Search the entire subtree.
    // Note that the checks are not identical to the single-object
    // checks, they generally conform to what DSADMIN/SITEREPL does.

    CComQIPtr<IDirectorySearch,&IID_IDirectorySearch> spSearch( pIADs );
    ASSERT( !!spSearch );
    if ( !spSearch )
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
            L"IsCriticalSystemObject(%s): Failed to load IDirectorySearch",
                     pszObjectDN);
        return E_FAIL;
    }

    hr = SetSearchPreference(spSearch, ADS_SCOPE_SUBTREE);
    ASSERT( !FAILED(hr) );
    if (FAILED(hr))
        return hr;

    CComBSTR sbstrDSAObjectCategory = L"CN=NTDS-DSA,";
    sbstrDSAObjectCategory += basePathsInfo.GetSchemaNamingContext();
    CComBSTR sbstrComputerObjectCategory = L"CN=Computer,";
    sbstrComputerObjectCategory += basePathsInfo.GetSchemaNamingContext();
    CComBSTR sbstrFilter;
    sbstrFilter = L"(|(isCriticalSystemObject=TRUE)(objectCategory=";
    sbstrFilter +=        sbstrDSAObjectCategory;
    sbstrFilter +=  L")(objectCategory=CN=Trusted-Domain,";
    sbstrFilter +=        basePathsInfo.GetSchemaNamingContext();

    // 212232 JonN 10/27/00 Protect interSiteTransport objects
    sbstrFilter +=  L")(objectCategory=CN=Inter-Site-Transport,";
    sbstrFilter +=        basePathsInfo.GetSchemaNamingContext();

    sbstrFilter +=  L")(&(objectCategory=";
    sbstrFilter +=          sbstrComputerObjectCategory;
    sbstrFilter +=     L")(userAccountControl:";
    sbstrFilter +=           LDAP_MATCHING_RULE_BIT_AND_W L":=8192)))";

    LPWSTR pAttrs[2] = { L"aDSPath",
                         L"objectCategory"};

    ADS_SEARCH_HANDLE SearchHandle = NULL;
    hr = spSearch->ExecuteSearch (sbstrFilter,
                                  pAttrs,
                                  2,
                                  &SearchHandle);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
     L"IsCriticalSystemObject(%s): Search with filter %s fails: 0x%08x",
                     pszObjectDN, sbstrFilter, hr);
        return hr;
    }
        DEBUG_OUTPUT(LEVEL6_LOGGING,
     L"IsCriticalSystemObject(%s): Search with filter %s succeeds: 0x%08x",
                     pszObjectDN, sbstrFilter, hr);

    while ( hr = spSearch->GetNextRow( SearchHandle ),
            SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS )
    {
        CComBSTR sbstrADsPathThisItem;
        hr = RetrieveStringColumn( spSearch,
                                   SearchHandle,
                                   pAttrs[0],
                                   sbstrADsPathThisItem );
        ASSERT( !FAILED(hr) );
        if (FAILED(hr))
            return hr;
        // only compare DNs
        CPathCracker pathcracker;
        hr = pathcracker.Set( sbstrADsPathThisItem, ADS_SETTYPE_FULL );
        ASSERT( SUCCEEDED(hr) );
        CComBSTR sbstrDN;
        hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrDN );
        ASSERT( SUCCEEDED(hr) );

        // ignore matches on root object if fExclude, it won't
        // be deleted anyway
        if (fExclude && !_wcsicmp( pszObjectDN, sbstrDN ))
            continue;

        CComBSTR sbstrObjectCategory;
        hr = RetrieveStringColumn( spSearch,
                                   SearchHandle,
                                   pAttrs[1],
                                   sbstrObjectCategory );
        ASSERT( !FAILED(hr) );
        if (FAILED(hr))
            return hr;

        hr = (   !_wcsicmp(sbstrObjectCategory,sbstrDSAObjectCategory)
              || !_wcsicmp(sbstrObjectCategory,sbstrComputerObjectCategory) )
            ? HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE_DSA_OBJ)
            : HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE);

        DisplayErrorMessage(g_pszDSCommandName,
                            sbstrDN,
                            hr);
        *pfErrorReported = TRUE;
        return hr; // do not permit deletion
    }

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   RetrieveStringColumn
//
//  Synopsis:   Extracts a string value from a SearchHandle
//              beyond what parser can do.
//
//  Arguments:  IDirectorySearch*
//              SearchHandle: must be current on an active record
//              szColumnName: as passed to ExecuteSearch
//              sbstr: returns contents of string value
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              errors should not occur here
//                        
//  History:    26-Sep-2000   JonN      Created
//
//---------------------------------------------------------------------------
HRESULT RetrieveStringColumn( IDirectorySearch* pSearch,
                              ADS_SEARCH_HANDLE SearchHandle,
                              LPWSTR szColumnName,
                              CComBSTR& sbstr )
{
    ASSERT( pSearch && szColumnName );
    ADS_SEARCH_COLUMN col;
    ::ZeroMemory( &col, sizeof(col) );
    HRESULT hr = pSearch->GetColumn( SearchHandle, szColumnName, &col );
    ASSERT( !FAILED(hr) );
    if (FAILED(hr))
        return hr;
    ASSERT( col.dwNumValues == 1 );
    if ( col.dwNumValues != 1 )
    {
        (void) pSearch->FreeColumn( &col );
        return E_FAIL;
    }
    switch (col.dwADsType)
    {
    case ADSTYPE_CASE_IGNORE_STRING:
        sbstr = col.pADsValues[0].CaseIgnoreString;
        break;
    case ADSTYPE_DN_STRING:
        sbstr = col.pADsValues[0].DNString;
        break;
    default:
        ASSERT(FALSE);
        hr = E_FAIL;
        break;
    }
    (void) pSearch->FreeColumn( &col );
    return hr;
}


#define QUERY_PAGESIZE 50

//+--------------------------------------------------------------------------
//
//  Function:   SetSearchPreference
//
//  Synopsis:   Sets default search parameters
//
//  Arguments:  IDirectorySearch*
//              ADS_SCOPEENUM: scope of search
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              errors should not occur here
//                        
//  History:    26-Sep-2000   JonN      Created
//
//---------------------------------------------------------------------------
HRESULT SetSearchPreference(IDirectorySearch* piSearch, ADS_SCOPEENUM scope)
{
  if (NULL == piSearch)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  ADS_SEARCHPREF_INFO aSearchPref[4];
  aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
  aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
  aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
  aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
  aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
  aSearchPref[2].vValue.Integer = FALSE;
  aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
  aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[3].vValue.Integer = scope;

  return piSearch->SetSearchPreference (aSearchPref, 4);
}


//+--------------------------------------------------------------------------
//
//  Function:   IsThisUserLoggedIn
//
//  Synopsis:   Checks whether the object with this DN represents
//              the currently logged-in user
//
//  Arguments:  bstrUserDN: DN of object to check
//
//  Returns:    HRESULT : error code to be returned from command-line app
//              ERROR_DS_CANT_DELETE indicates that this user is logged in
//                        
//  History:    26-Sep-2000   JonN      Created
//
//---------------------------------------------------------------------------
HRESULT IsThisUserLoggedIn( const BSTR bstrUserDN )
{
    ENTER_FUNCTION(LEVEL7_LOGGING, IsThisUserLoggedIn);

    if (g_lpszLoggedInUser == NULL) {
        // get the size passing null pointer
        DWORD nSize = 0;
        // this is expected to fail
        if (GetUserNameEx(NameFullyQualifiedDN , NULL, &nSize))
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                L"IsThisUserLoggedIn(%s): GetUserNameEx unexpected success",
                         bstrUserDN);
            return E_FAIL;
        }
    
        if( nSize == 0 )
        {
            // JonN 3/16/01 344862
            // dsrm from workgroup computer cannot remotely delete users from domain
            // This probably failed because the local computer is in a workgroup
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"IsThisUserLoggedIn(%s): GetUserNameEx nSize==0",
                         bstrUserDN);
            return S_OK; // allow user deletion
        }
    
        g_lpszLoggedInUser = new WCHAR[ nSize ];
        if( g_lpszLoggedInUser == NULL )
        {
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"IsThisUserLoggedIn(%s): out of memory",
                         bstrUserDN);
            return E_OUTOFMEMORY;
        }
        ::ZeroMemory( g_lpszLoggedInUser, nSize*sizeof(WCHAR) );

        // this is expected to succeed
        if (!GetUserNameEx(NameFullyQualifiedDN, g_lpszLoggedInUser, &nSize ))
        {
            // JonN 3/16/01 344862
            // dsrm from workgroup computer cannot remotely delete users from domain
            // This probably failed because the local computer is in a workgroup
            DWORD dwErr = ::GetLastError();
            DEBUG_OUTPUT(MINIMAL_LOGGING,
                         L"IsThisUserLoggedIn(%s): GetUserNameEx unexpected failure: %d",
                         bstrUserDN, dwErr);
            return S_OK; // allow user deletion
        }
    }

    if (!_wcsicmp (g_lpszLoggedInUser, bstrUserDN))
        return HRESULT_FROM_WIN32(ERROR_DS_CANT_DELETE);

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteChildren
//
//  Synopsis:   Deletes only the children of a single target
//
//  Arguments:  credentialObject
//              basePathsInfo
//              pIADs: IADs pointer to the object
//              *pfErrorReported: Will be set to true if DeleteChildren
//                                takes care of reporting the error itself
//
//  Returns:    HRESULT : error code to be returned from command-line app
//                        Could be almost any ADSI error
//                        Returns S_OK if there are no children
//
//  History:    26-Sep-2000   JonN      Created
//
//---------------------------------------------------------------------------

HRESULT DeleteChildren( CDSCmdCredentialObject& credentialObject,
                        IADs* pIADs,
                        bool* pfErrorReported )
{
    ENTER_FUNCTION(LEVEL5_LOGGING, DeleteChildren);

    ASSERT( pIADs && pfErrorReported );
    if ( !pIADs || !pfErrorReported )
        return E_POINTER;

    CComQIPtr<IDirectorySearch,&IID_IDirectorySearch> spSearch( pIADs );
    ASSERT( !!spSearch );
    if ( !spSearch )
        return E_FAIL;
    HRESULT hr = SetSearchPreference(spSearch, ADS_SCOPE_ONELEVEL);
    ASSERT( !FAILED(hr) );
    if (FAILED(hr))
        return hr;

    LPWSTR pAttrs[1] = { L"aDSPath" };
    ADS_SEARCH_HANDLE SearchHandle = NULL;
    hr = spSearch->ExecuteSearch (L"(objectClass=*)",
                                  pAttrs,
                                  1,
                                  &SearchHandle);
    if (FAILED(hr))
    {
        DEBUG_OUTPUT(MINIMAL_LOGGING,
                     L"DeleteChildren: ExecuteSearch failure: 0x%08x",
                     hr);
        return hr;
    }

    while ( hr = spSearch->GetNextRow( SearchHandle ),
            SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS )
    {
        CComBSTR sbstrADsPathThisItem;
        hr = RetrieveStringColumn( spSearch,
                                   SearchHandle,
                                   pAttrs[0],
                                   sbstrADsPathThisItem );
        ASSERT( !FAILED(hr) );
        if (FAILED(hr))
            break;

        CComPtr<IADsDeleteOps> spDeleteOps;
        // return the error value for the first error encountered
        HRESULT hrThisItem = DSCmdOpenObject(credentialObject,
                                             sbstrADsPathThisItem,
                                             IID_IADsDeleteOps,
                                             (void**)&spDeleteOps,
                                             true);
        if (FAILED(hrThisItem))
        {
            DEBUG_OUTPUT(
                MINIMAL_LOGGING,
                L"DeleteChildren: DsCmdOpenObject(%s) failure: 0x%08x",
                sbstrADsPathThisItem, hrThisItem);
        }
        else
        {
            ASSERT( !!spDeleteOps );
            hrThisItem = spDeleteOps->DeleteObject( NULL );
            if (FAILED(hrThisItem))
            {
                DEBUG_OUTPUT(
                    MINIMAL_LOGGING,
                    L"DeleteChildren: DeleteObject(%s) failure: 0x%08x",
                    sbstrADsPathThisItem, hrThisItem);
            }
        }
        if (!FAILED(hrThisItem))
            continue;

        // an error occurred

        if (!FAILED(hr))
            hr = hrThisItem;

        CComBSTR sbstrDN;
        CPathCracker pathcracker;
        HRESULT hr2 = pathcracker.Set( sbstrADsPathThisItem, ADS_SETTYPE_FULL );
        ASSERT( !FAILED(hr2) );
        if (FAILED(hr2))
            break;
        hr2 = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrDN );
        ASSERT( !FAILED(hr2) );
        if (FAILED(hr2))
            break;

        // Report error message for the child which could not be deleted
        DisplayErrorMessage(g_pszDSCommandName,
                            sbstrDN,
                            hrThisItem);
        *pfErrorReported = true;

        if (!fContinue)
            break;
    }
    if (hr != S_ADS_NOMORE_ROWS)
    {
        DEBUG_OUTPUT(FULL_LOGGING,
                     L"DeleteChildren: abandoning search");
        (void) spSearch->AbandonSearch( SearchHandle );
    }

    return (hr == S_ADS_NOMORE_ROWS) ? S_OK : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parser\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.cpp
//
//  Useful string manipulation functions.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*sizeof(TCHAR))

/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, StringByteSize(pString) );

    if ( !*ppResult )
        return E_OUTOFMEMORY;

    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success
}


/*----------------------------------------------------------------------------
/ LocalAllocStringLen
/ ---------------------
/   Given a length return a buffer of that size.
/
/ In:
/   ppResult -> receives the pointer to the string
/   cLen = length in characters to allocate
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen)
{
    if ( !ppResult || cLen == 0 )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (cLen+1) * sizeof(TCHAR));

    return *ppResult ? S_OK:E_OUTOFMEMORY; 

}


/*-----------------------------------------------------------------------------
/ LocalFreeString
/ -----------------
/   Release the string pointed to be *ppString (which can be null) and
/   then reset the pointer back to NULL.   
/
/ In:
/   ppString -> pointer to string pointer to be free'd
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void LocalFreeString(LPTSTR* ppString)
{
    if ( ppString )
    {
        if ( *ppString )
            LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }
}


//*************************************************************
//
//  SizeofStringResource
//
//  Purpose:    Find the length (in chars) of a string resource
//
//  Parameters: HINSTANCE hInstance - module containing the string
//              UINT idStr - ID of string
//
//
//  Return:     UINT - # of chars in string, not including NULL
//
//  Notes:      Based on code from user32.
//
//*************************************************************
UINT
SizeofStringResource(HINSTANCE hInstance,
                     UINT idStr)
{
    UINT cch = 0;
    HRSRC hRes = FindResource(hInstance, (LPTSTR)((LONG_PTR)(((USHORT)idStr >> 4) + 1)), RT_STRING);
    if (NULL != hRes)
    {
        HGLOBAL hStringSeg = LoadResource(hInstance, hRes);
        if (NULL != hStringSeg)
        {
            LPWSTR psz = (LPWSTR)LockResource(hStringSeg);
            if (NULL != psz)
            {
                idStr &= 0x0F;
                while(true)
                {
                    cch = *psz++;
                    if (idStr-- == 0)
                        break;
                    psz += cch;
                }
            }
        }
    }
    return cch;
}


//*************************************************************
//
//  LoadStringAlloc
//
//  Purpose:    Loads a string resource into an alloc'd buffer
//
//  Parameters: ppszResult - string resource returned here
//              hInstance - module to load string from
//              idStr - string resource ID
//
//  Return:     same as LoadString
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
int
LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr)
{
    int nResult = 0;
    UINT cch = SizeofStringResource(hInstance, idStr);
    if (cch)
    {
        cch++; // for NULL
        *ppszResult = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (*ppszResult)
            nResult = LoadString(hInstance, idStr, *ppszResult, cch);
    }
    return nResult;
}


//*************************************************************
//
//  String formatting functions
//
//*************************************************************

DWORD
FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, idStr);
    dwResult = vFormatStringID(ppszResult, hInstance, idStr, &args);
    va_end(args);
    return dwResult;
}

DWORD
FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, pszFormat);
    dwResult = vFormatString(ppszResult, pszFormat, &args);
    va_end(args);
    return dwResult;
}

DWORD
vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs)
{
    DWORD dwResult = 0;
    LPTSTR pszFormat = NULL;
    if (LoadStringAlloc(&pszFormat, hInstance, idStr))
    {
        dwResult = vFormatString(ppszResult, pszFormat, pargs);
        LocalFree(pszFormat);
    }
    return dwResult;
}

DWORD
vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                         pszFormat,
                         0,
                         0,
                         (LPTSTR)ppszResult,
                         1,
                         pargs);
}


//*************************************************************
//
//  GetSystemErrorText
//
//  Purpose:    Retrieve error text for a win32 error value
//
//  Parameters: ppszResult - string resource returned here
//              dwErr - error ID
//
//  Return:     same as FormatMessage
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
DWORD
GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwErr,
                         0,
                         (LPTSTR)ppszResult,
                         0,
                         NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parser\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef __strings_h
#define __strings_h

HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString);
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen);
void    LocalFreeString(LPTSTR* ppString);

UINT SizeofStringResource(HINSTANCE hInstance, UINT idStr);
int LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr);

// String formatting functions - *ppszResult must be LocalFree'd
DWORD FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...);
DWORD FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...);
DWORD vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs);
DWORD vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs);

DWORD GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\dsrm\rmtable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      modtable.h
//
//  Contents:  Declares a table which contains the object types on which
//             a modification can occur and the attributes that can be changed
//
//  History:   07-Sep-2000    JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef _RMTABLE_H_
#define _RMTABLE_H_

typedef enum COMMON_COMMAND
{
#ifdef DBG
   eCommDebug,
#endif
   eCommHelp,
   eCommServer,
   eCommDomain,
   eCommUserName,
   eCommPassword,
   eCommQuiet,
   eCommObjectDN,   
   eCommContinue,
   eCommNoPrompt,
   eCommSubtree,
   eCommExclude,
   eTerminator
};

//
// The parser table
//
extern ARG_RECORD DSRM_COMMON_COMMANDS[];

#endif //_RMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parser\util.h ===
#ifndef _UTIL_H_8_25_2000
#define _UTIL_H_8_25_2000

#define INIT_SIZE 1024


//General Utility Functions
DWORD ResizeByTwo( LPTSTR *ppBuffer,
                   LONG *pSize );
BOOL StringCopy( LPWSTR *ppDest, LPWSTR pSrc);

LONG ReadFromIn(LPTSTR *ppBuffer);













#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parser\varg.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)
            
    Copyright (c) 1998-2000 Microsoft Corporation
    
 
\*****************************************************************************/

#ifndef _VARG_H_012599_
#define _VARG_H_012599_

#define MAXSTR                   1025




//Class CToken
//It represents a Single Token.
class CToken
{
public:
    CToken(LPWSTR psz, BOOL bQuote);
    CToken();
    ~CToken();
    VOID Init(LPWSTR psz, BOOL bQuote);   
    LPWSTR GetToken();    
    BOOL IsSwitch();
    BOOL IsSlash();
private:
    LPWSTR m_pszToken;
    BOOL   m_bInitQuote;
};
typedef CToken * LPTOKEN;



#define ARG_TYPE_INT             0
#define ARG_TYPE_BOOL            1
#define ARG_TYPE_STR             2
#define ARG_TYPE_HELP            3
#define ARG_TYPE_DEBUG           4
#define ARG_TYPE_MSZ             5
#define ARG_TYPE_INTSTR          6
#define ARG_TYPE_LAST            7


#define ARG_FLAG_OPTIONAL        0x00000001     
#define ARG_FLAG_REQUIRED        0x00000002
#define ARG_FLAG_DEFAULTABLE     0x00000004     
#define ARG_FLAG_NOFLAG          0x00000008     //For parameters like target name
#define ARG_FLAG_HIDDEN          0x00000010
#define ARG_FLAG_VERB            0x00000020     
#define ARG_FLAG_STDIN           0x00000040     //This must be Required. If not sepcified read from standard input
#define ARG_FLAG_ATLEASTONE      0x00000080     //If this flag is specified on one or more switch, at
                                                //least one of those switches must be defined
#define ARG_FLAG_DN              0x00000100     //JonN 4/26/01 256583 add ADSI escaping


#define ARG_TERMINATOR           0,NULL,0,NULL,ARG_TYPE_LAST,0,(CMD_TYPE)0,FALSE,NULL
#define ID_ARG2_NULL                (LONG)-1

#define CMD_TYPE    void*

typedef struct _ARG_RECORD
{
    LONG    idArg1;
    LPTSTR  strArg1;
    LONG    idArg2;
    LPTSTR  strArg2;
    int     fType;
	DWORD   fFlag;
    union{
        void*   vValue;
        LPTSTR  strValue;
        int     nValue;
        BOOL    bValue;
    };
    BOOL	bDefined;
    DWORD	(*fntValidation)(PVOID pArg);
} ARG_RECORD, *PARG_RECORD;


//Error Source
#define ERROR_FROM_PARSER   1
#define ERROR_FROM_VLDFN    2
#define ERROR_WIN32_ERROR   3

//Parse Errors for when ERROR_SOURCE is ERROR_FROM_PARSER
/*
SWITCH value is incorrect.
ArgRecIndex is index of record.
ArgvIndex is index of token.
*/
#define PARSE_ERROR_SWITCH_VALUE        1
/*No Value is given for a swich when one is expected.
ArgRecIndex is index of record.
ArgvIndex is -1.
*/
#define PARSE_ERROR_SWICH_NO_VALUE      2
/*
Invalid Input
ArgRecIndex is -1, 
ArgvIndex is index of token.
*/
#define PARSE_ERROR_UNKNOWN_INPUT_PARAMETER   3
/*
Required switch is not defined. 
ArgRecIndex is index of record.
ArgvIndex is -1.
*/
#define PARSE_ERROR_SWITCH_NOTDEFINED   4
/*
Switch or Parameter is defined twice.
ArgRecIndex is index of record.
ArgvIndex is -1
*/
#define PARSE_ERROR_MULTIPLE_DEF        5
/*
Error Reading From STDIN.
ArgRecIndex is -1.
ArgvIndex is -1.
*/
#define ERROR_READING_FROM_STDIN        6
/*
Parser Encountered Help Switch
ArgRecIndex is index of record.
ArgvIndex is -1
*/
#define PARSE_ERROR_HELP_SWITCH         7
/*
The ARG_FLAG_ATLEASTONE flag was
defined on one or more switch yet
none of these switches were defined
ArgRecIndex is -1
ArgvIndex is -1
*/
#define PARSE_ERROR_ATLEASTONE_NOTDEFINED 8


//Parse Errors for when ERROR_SOURCE is VLDFN

/*
Use this error code when Validation Function has handled the error and
Shown appropriate error message.
*/
#define VLDFN_ERROR_NO_ERROR    1


//Error is returned by Parser in PARSE_ERROR structure
//ErrorSource: Source of Error. Parser or Validation Function
//Error This is the actual error code. Its value depend on ErrorSource value.
//  if( ErrorSource == PARSE_ERROR )
//      possible values are   ERROR_FROM_PARSER ERROR_FROM_VLDFN       
//  if( ErrorSource == ERROR_FROM_VLDFN )
//      depends on the function
//  ArgRecIndex is appropriate index in the ARG_RECORD, if applicable else -1
//  ArgvIndex is approproate index in the agrv array, if applicable else -1
typedef struct _PARSE_ERROR
{
    INT ErrorSource;
    DWORD Error;
    INT ArgRecIndex;
    INT ArgvIndex;
} PARSE_ERROR, *PPARSE_ERROR;

BOOL ParseCmd(IN ARG_RECORD *Commands,
              IN int argc, 
              IN CToken *pToken,
              IN DWORD UsageMessageId, 
              OUT PPARSE_ERROR pError,
              IN BOOL bValidate = TRUE);

void FreeCmd(ARG_RECORD *Commands);

DWORD GetCommandInput(OUT int *pargc,           //Number of Tokens
                      OUT LPTOKEN *ppToken);    //Array of CToken


DWORD Tokenize(IN LPWSTR pBuf,
               IN LONG BufLen,
               IN LPWSTR pszDelimiters,
               OUT CToken **ppToken,
               OUT int *argc);

LONG GetToken(IN LPWSTR pBuf,
              IN LONG BufLen,
              IN LPWSTR pszDelimiters,
              OUT BOOL *bQuote,
              OUT LPWSTR *ppToken);

BOOL DisplayParseError(IN PPARSE_ERROR pError,
                       IN ARG_RECORD *Commands,
                       IN CToken *pToken);


//Function to display string to STDERR
VOID DisplayError(IN LPWSTR pszError);
//Function to display string to STDOUT, appending newline
VOID DisplayOutput(IN LPWSTR pszOut);
//Function to display string to STDOUT, without newline
VOID DisplayOutputNoNewline(IN LPWSTR pszOut);
//Function to display Message to Standard Error.
VOID DisplayMessage(DWORD MessageId,...);



// Copied from JSchwart on 2/19/2001

void
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    );


void
WriteStandardOut(PCWSTR pszFormat, ...);

void
WriteStandardError(PCWSTR pszFormat, ...);

#endif //_VARG_H_012599_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\cabs\makefile.inc ===
!if "$(NOPASS0)" == "1"

all: cabs all-cabs

cabs: obj\$(TARGET_DIRECTORY)\sidtools.cab 

all-cabs:
	copy ..\migrate\cabs\obj\$(TARGET_DIRECTORY)\*.cab obj\$(TARGET_DIRECTORY)
	cabarc n obj\$(TARGET_DIRECTORY)\all.cab obj\$(TARGET_DIRECTORY)\*.cab

obj\$(TARGET_DIRECTORY)\sidtools.cab: ..\$(@B)\obj\$(TARGET_DIRECTORY)\$(@B).dll
	cabarc n $@ $** 

!else

!message Nothing to build in pass 0
all: 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parser\varg.cpp ===
/*****************************************************************************\

    Author: Hiteshr
    Copyright (c) 1998-2000 Microsoft Corporation
    Change History:
    Adapted From Parser Implemenation of Corey Morgan
\*****************************************************************************/

#include "pch.h"
#include "..\dsutil2.h" // GetEscapedElement

BOOL ValidateCommands(IN ARG_RECORD *Commands,OUT PPARSE_ERROR pError);
// void DisplayDebugInfo(IN ARG_RECORD *Commands);

// JonN 4/26/01 256583
DWORD AddDNEscaping_Commands( IN OUT ARG_RECORD *Commands );
DWORD AddDNEscaping_DN( OUT LPWSTR* ppszOut, IN LPWSTR pszIn );
BOOL StartBuffer( OUT LPTSTR* pbuffer,
                  OUT LONG* pmaxSize,
                  OUT LONG* pcurrentSize );
DWORD AddToBuffer( IN LPCTSTR psz,
                   IN OUT LPTSTR* pbuffer,
                   IN OUT LONG* pmaxSize,
                   IN OUT LONG* pcurrentSize,
                   IN BOOL fMSZBuffer);

#define FILL_ERROR(pError,source,error_code,rec_index,argv_index) \
pError->ErrorSource = source;         \
pError->Error = error_code;           \
pError->ArgRecIndex = rec_index;      \
pError->ArgvIndex = argv_index;

BOOL IsCmd( PARG_RECORD arg, LPTOKEN pToken)
{
    if(!arg || !pToken)
        return FALSE;    
    
    LPWSTR str = pToken->GetToken();

    if(!str)
        return FALSE;

    if(pToken->IsSwitch())
    {
        str++;
    }else
    {
        if( (arg->fFlag & ARG_FLAG_NOFLAG) && !arg->bDefined )
        {
            return TRUE;
        }
        if( !(arg->fFlag & ARG_FLAG_VERB) )
        {
            return FALSE;
        }
    }
    
    if( ( arg->strArg1 && !_tcsicmp( str, arg->strArg1 ) )
       ||(arg->strArg2 && !_tcsicmp( str, arg->strArg2 )) )
    {
        return TRUE;
    }
    return FALSE;
}



void FreeCmd(ARG_RECORD *Commands)
{
    int i;
    for(i=0;Commands[i].fType != ARG_TYPE_LAST;i++)
    {
        if((Commands[i].fType == ARG_TYPE_STR || 
            Commands[i].fType == ARG_TYPE_MSZ ) && 
            Commands[i].bDefined )
        {                       
            LocalFree( Commands[i].strValue );
            Commands[i].strValue = NULL;
        }
        if( Commands[i].idArg1 && Commands[i].strArg1 != NULL )
        {
            LocalFree(Commands[i].strArg1);
        }
        if( Commands[i].idArg2 && Commands[i].strArg2 != NULL )
        {
            LocalFree( Commands[i].strArg2  );
        }
        Commands[i].bDefined = FALSE;
    }
}

BOOL LoadCmd(ARG_RECORD *Commands)
{
    int i;
    BOOL bRet = TRUE;
    for( i=0; Commands[i].fType!=ARG_TYPE_LAST; i++ )
    {
        if(Commands[i].idArg1 !=0)
            if(!LoadStringAlloc(&Commands[i].strArg1, NULL,Commands[i].idArg1))
            {
                bRet = FALSE;
                break;   
            }                
        if(Commands[i].idArg2 !=0 && Commands[i].idArg2 != ID_ARG2_NULL)
            if(!LoadStringAlloc(&Commands[i].strArg2, NULL,Commands[i].idArg2))
            {
                bRet = FALSE;
                break;
            }
    }   
    return bRet;
}
           
BOOL
ValidateCommands(ARG_RECORD *Commands, PPARSE_ERROR pError)
{

    int i = 0;
    LONG cReadFromStdin = 0;
    ARG_RECORD *CommandsIn = NULL;
    LPWSTR pBuffer=NULL;    
    LONG BufferLen = 0;
    LPTOKEN pToken = NULL;   
    int argc=0;
    BOOL bRet = FALSE;

    bool bAtLeastOne = false;
    bool bAtLeastOneDefined = false;

    if(!Commands || !pError)
        goto exit_gracefully;
    
    for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
    {
        if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined)
        {
            if(Commands[i].fFlag & ARG_FLAG_STDIN)
            {
                cReadFromStdin++;
            }
            else
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_NOTDEFINED,
                           i,
                           -1);
                goto exit_gracefully;
            }
        }

        if (Commands[i].fFlag & ARG_FLAG_ATLEASTONE)
        {
            bAtLeastOne = true;
 
            if (Commands[i].bDefined)
            {
                bAtLeastOneDefined = true;
            }
        }
    }
    
    if (bAtLeastOne && !bAtLeastOneDefined)
    {
       pError->ErrorSource = ERROR_FROM_PARSER;
       pError->Error = PARSE_ERROR_ATLEASTONE_NOTDEFINED;
       pError->ArgRecIndex = -1;
       pError->ArgvIndex = -1;
       goto exit_gracefully;
    }

    if(!cReadFromStdin)
    {   
        bRet = TRUE;
        goto exit_gracefully;
    }
    
    //Read From STDIN
    BufferLen = ReadFromIn(&pBuffer);  
    if(BufferLen == -1)
    {
        FILL_ERROR(pError,
                   ERROR_WIN32_ERROR,
                   GetLastError(),
                   -1,
                   -1);
        goto exit_gracefully;
    }
    
    if(BufferLen == 0)
    {
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined)
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_NOTDEFINED,
                           i,
                           -1);
                goto exit_gracefully;
            }
        }
    }
    
    if(BufferLen)
    {
        //Tokenize what you have read from STDIN
        DWORD dwErr;
        WCHAR szDelimiters[] = L" \n\t";
        dwErr = Tokenize(pBuffer,
                         BufferLen,
                         szDelimiters,
                         &pToken,
                         &argc);
        if( dwErr != ERROR_SUCCESS )
        {
            FILL_ERROR(pError,
                       ERROR_WIN32_ERROR,
                       dwErr,
                       -1,
                       -1);
            goto exit_gracefully;
        }

        //Prepare a CommandArray for them
        CommandsIn = (ARG_RECORD*)LocalAlloc(LPTR,sizeof(ARG_RECORD)*(cReadFromStdin+1));
        if(!CommandsIn)
        {
            FILL_ERROR(pError,
                       ERROR_WIN32_ERROR,
                       ERROR_NOT_ENOUGH_MEMORY,
                       -1,
                       -1);
            goto exit_gracefully;
        }
        int j;
        j = 0;
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if((Commands[i].fFlag & ARG_FLAG_REQUIRED) && 
               (Commands[i].fFlag & ARG_FLAG_STDIN) &&
               !Commands[i].bDefined)
            {
                CommandsIn[j++] = Commands[i];        
            }
        }
        //Copy the Last One
        CommandsIn[j] = Commands[i];


        if(!ParseCmd(CommandsIn,
                    argc,
                    pToken,
                    0,
                    pError,
                    FALSE))
        {        
            goto exit_gracefully;
        }
       
        //Copy the values back to Commands
        j=0;
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if((Commands[i].fFlag & ARG_FLAG_REQUIRED) && 
               (Commands[i].fFlag & ARG_FLAG_STDIN) &&
               !Commands[i].bDefined)
            {
                Commands[i] = CommandsIn[j++];        
            }
        }
        
        //Validate Commands
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined)
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_NOTDEFINED,
                           i,
                           -1);
                goto exit_gracefully;
            }
        }

    }   
    bRet = TRUE;
exit_gracefully:
    if(CommandsIn)
        LocalFree(CommandsIn);
    if(pBuffer)
        LocalFree(pBuffer);
    if(pToken)
    {
       delete []pToken;
    }
    return bRet;
}


BOOL ParseCmd(IN ARG_RECORD *Commands,
              IN int argc, 
              IN LPTOKEN pToken,
              IN DWORD UsageMessageId, 
              OUT PPARSE_ERROR pError,
              IN BOOL bValidate )
{
    int i;
    BOOL bFound;
    BOOL bDoDebug = FALSE;
    int argCount;
    DWORD dwErr = ERROR_SUCCESS;
	BOOL bReturn = TRUE;
	LPTOKEN pTokenCopy = pToken;

    if(!Commands || argc == 0 || !pToken || !pError)
	{
        bReturn = FALSE;
		goto exit_gracefully;
	}

    if(!LoadCmd(Commands))
	{
        bReturn = FALSE;
		goto exit_gracefully;
	}

    argCount = argc;

    while( argc > 0 )
    {
        
        bFound = FALSE;
        for(i=0; Commands[i].fType != ARG_TYPE_LAST && (!bFound);i++)
        {
            
            if( IsCmd( &Commands[i], pToken) )
            {

                if(Commands[i].bDefined)
                {
                    FILL_ERROR(pError,
                               ERROR_FROM_PARSER,
                               PARSE_ERROR_MULTIPLE_DEF,
                               i,
                               -1);
					bReturn = FALSE;
					goto exit_gracefully;
                }

                if( pToken->IsSwitch() || Commands[i].fFlag & ARG_FLAG_VERB ){
                    pToken++;argc--;
                }

                bFound = TRUE;

                Commands[i].bDefined = TRUE;

                switch( Commands[i].fType ){
                case ARG_TYPE_HELP:
				{
                    Commands[i].bValue = TRUE;
                    if( Commands[i].fntValidation != NULL )
                    {
                        Commands[i].fntValidation( Commands + i );
                    }
                    FILL_ERROR(pError,
                               ERROR_FROM_PARSER,
                               PARSE_ERROR_HELP_SWITCH,
                               i,
                               -1);
                    if(UsageMessageId)
                        DisplayMessage(UsageMessageId);

					bReturn = FALSE;
					goto exit_gracefully;
				}
                break;
                case ARG_TYPE_DEBUG:
                   //
                   // REVIEW_JEFFJON : removed for now because it was AVing for dsadd group -secgrp
                   //
//                    bDoDebug = TRUE;
                    Commands[i].fFlag |= ARG_FLAG_DEFAULTABLE;
                case ARG_TYPE_INT:
				{
                    if( argc > 0 && !pToken->IsSwitch())
                    {
                        PWSTR pszToken = pToken->GetToken();
                        Commands[i].nValue = _ttoi( pszToken);
                        if (Commands[i].nValue == 0 &&
                            !iswdigit(pszToken[0]))
                        {
                           FILL_ERROR(pError,
                                      ERROR_FROM_PARSER,
                                      PARSE_ERROR_SWITCH_VALUE,
                                      i,
                                      argCount - argc);
							bReturn = FALSE;
							goto exit_gracefully;
                        }
                        pToken++;argc--;
                    }
					else if( !(Commands[i].fFlag & ARG_FLAG_DEFAULTABLE) )
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   argCount - argc);
                        bReturn = FALSE;
						goto exit_gracefully;
                    }
				}
                break;
                case ARG_TYPE_BOOL:
                    Commands[i].bValue = TRUE;
                    break;
                case ARG_TYPE_MSZ:
                    if( argc > 0 && !pToken->IsSwitch())
                    {
                        LPTSTR buffer = NULL;
                        LONG maxSize = 0;
                        LONG currentSize = 0;
                        if (!StartBuffer(&buffer,&maxSize,&currentSize))
                        {
                            FILL_ERROR(pError,
                                       ERROR_WIN32_ERROR,
                                       ERROR_NOT_ENOUGH_MEMORY,
                                       -1,
                                       argCount - argc);
                            bReturn = FALSE;
							goto exit_gracefully;
                        }
                        LPCTSTR pszTemp = pToken->GetToken();
                        dwErr = AddToBuffer(pszTemp,&buffer,&maxSize,&currentSize,TRUE);
                        if (NO_ERROR != dwErr)
                        {
                            FILL_ERROR(pError,
                                       ERROR_WIN32_ERROR,
                                       dwErr,
                                       i,
                                       -1);
                            bReturn = FALSE;
                            goto exit_gracefully;
                        }
                        pToken++;argc--;
                        while( argc > 0 && !pToken->IsSwitch() )
                        {
                            pszTemp = pToken->GetToken();
                            dwErr = AddToBuffer(pszTemp,&buffer,&maxSize,&currentSize,TRUE);
                            if (NO_ERROR != dwErr)
                            {
                                FILL_ERROR(pError,
                                           ERROR_WIN32_ERROR,
                                           dwErr,
                                           i,
                                           -1);
                                bReturn = FALSE;
                                goto exit_gracefully;
                            }
                           pToken++;argc--;
                        }
                        Commands[i].strValue = buffer;
                    }
                    else if( Commands[i].fFlag & ARG_FLAG_DEFAULTABLE ){
                        LPTSTR strValue = Commands[i].strValue;
                        Commands[i].strValue = (LPTSTR)LocalAlloc(LPTR, (_tcslen(strValue)+1) * sizeof(TCHAR) );
                        if( Commands[i].strValue != NULL ){
                            _tcscpy( Commands[i].strValue, strValue );
                        }
                    }
                    else
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   -1);
                        bReturn = FALSE;
						goto exit_gracefully;
                    }
                    break;
                case ARG_TYPE_STR:
                    if( argc > 0 && !pToken->IsSwitch())
                    {
                        Commands[i].strValue = (LPTSTR)LocalAlloc(LPTR, (_tcslen(pToken->GetToken())+2) * sizeof(TCHAR) );
                        if( Commands[i].strValue != NULL )
                        {
                            _tcscpy( Commands[i].strValue, pToken->GetToken() );
                        }
			            pToken++;argc--;
                    }else if( Commands[i].fFlag & ARG_FLAG_DEFAULTABLE )
                    {
                        LPTSTR strValue = Commands[i].strValue;
                        Commands[i].strValue = (LPTSTR)LocalAlloc(LPTR, (_tcslen(strValue)+2) * sizeof(TCHAR) );
                        if( Commands[i].strValue != NULL )
                        {
                            _tcscpy( Commands[i].strValue, strValue );
                        }
                    }else
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   -1);
                        bReturn = FALSE;
						goto exit_gracefully;
                    }
                    break;

                case ARG_TYPE_INTSTR:
                    //
                    // We use IsSlash here instead of IsSwitch because we want to allow
                    // negative numbers
                    //
                    if( argc > 0 && !pToken->IsSlash())
                    {
                        PWSTR pszToken = pToken->GetToken();
                        size_t strLen = wcslen(pszToken);
                        
                        Commands[i].nValue = _ttoi( pszToken);
                        Commands[i].fType = ARG_TYPE_INT;
                        if (Commands[i].nValue == 0 &&
                            !iswdigit(pszToken[0]))
                        {
                           //
                           // Then treat as a string
                           //
                           Commands[i].strValue = (LPTSTR)LocalAlloc(LPTR, (_tcslen(pToken->GetToken())+2) * sizeof(TCHAR) );
                           if( Commands[i].strValue != NULL )
                           {
                              _tcscpy( Commands[i].strValue, pToken->GetToken() );
                              Commands[i].fType = ARG_TYPE_STR;
                           }
                        }
                        pToken++;argc--;
                    }
                    else if( !(Commands[i].fFlag & ARG_FLAG_DEFAULTABLE) )
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   argCount - argc);
                        bReturn = FALSE;
						goto exit_gracefully;
                    }
                    break;
                }

                if( Commands[i].bDefined && Commands[i].fntValidation != NULL )
                {
                    dwErr = Commands[i].fntValidation(Commands + i);
                    if( dwErr != ERROR_SUCCESS )
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_VLDFN,
                                   dwErr,
                                   i,
                                   -1);
                        bReturn = FALSE;
						goto exit_gracefully;
                    }
                }

            }
        }

        if (!bFound)
        {
            pError->ErrorSource = ERROR_FROM_PARSER;
            pError->Error = PARSE_ERROR_UNKNOWN_INPUT_PARAMETER;
            pError->ArgRecIndex = -1;
            pError->ArgvIndex = argCount - argc;
            bReturn = FALSE;
			goto exit_gracefully;
        }
    }

    if( bDoDebug )
    {
//        DisplayDebugInfo(Commands);
    }
    if(bValidate && !ValidateCommands(Commands,pError))
    {
        bReturn = FALSE;
        goto exit_gracefully;
    }

    // JonN 4/26/01 256583
    // Note that this must be called after ValidateCommands, which completes
    // reading parameters from STDIN.  If !bValidate, then we are in the
    // middle of a call to ValidateCommands.
    if (bValidate)
    {
        dwErr = AddDNEscaping_Commands(Commands);
        if( dwErr != ERROR_SUCCESS )
        {
            FILL_ERROR(pError,
                       ERROR_WIN32_ERROR,
                       dwErr,
                       -1,
                       -1);
            bReturn = FALSE;
            goto exit_gracefully;
        }
    }

exit_gracefully:
	if(!bReturn)
		DisplayParseError(pError, Commands, pTokenCopy);

    return bReturn;
}

/*
void
DisplayDebugInfo(ARG_RECORD *Commands)
{
    int i;
    int nOut;

    for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
    {
        if( Commands[i].fType == ARG_TYPE_HELP ){
            continue;
        }
        nOut = _tprintf( _T("%s"), Commands[i].strArg1 );
        while( ++nOut < 10 )
        {
            _tprintf( _T(" ") );
        }
        _tprintf( _T("= ") );
        switch( Commands[i].fType )
        {
        case ARG_TYPE_DEBUG:
        case ARG_TYPE_INT:
            _tprintf( _T("%d"),
                Commands[i].nValue 
                );
            break;
        case ARG_TYPE_BOOL:
            _tprintf( _T("%s"),
                Commands[i].bValue ? _T("TRUE") : _T("FALSE")
                );
            break;
        case ARG_TYPE_MSZ:
            if( NULL != Commands[i].strValue && _tcslen( Commands[i].strValue ) )
            {
                _tprintf( _T("%s ..."), Commands[i].strValue);
            }else
            {
                _tprintf( _T("%s"),_T("-") );
            }
            break;
        case ARG_TYPE_STR:
            _tprintf( _T("%s"),
                (Commands[i].strValue == NULL || !(_tcslen(Commands[i].strValue)) ) ? 
                _T("-") : Commands[i].strValue
                );
            break;
        }
        _tprintf( _T("\n") );
       
    }
    _tprintf( _T("\n") );
}
*/


//This Function reads from the Command Line, 
//return it in tokenized format.
DWORD GetCommandInput( OUT int *pargc,           //Number of Tokens
                       OUT LPTOKEN *ppToken)    //Array of CToken
{
    
    LPWSTR pBuffer = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR szDelimiters[] = L" \n\t";
    
    *pargc = 0;
    //Read the commandline input
    pBuffer = GetCommandLine();
    if(pBuffer)
        dwErr = Tokenize(pBuffer, 
                         wcslen(pBuffer),
                         szDelimiters,
                         ppToken,
                         pargc);

    return dwErr;
}

BOOL IsDelimiter(WCHAR ch, LPWSTR pszDelimiters)
{
    while(*pszDelimiters)
        if((WCHAR)*pszDelimiters++ == ch)
            return TRUE;

    return FALSE;
}

/*
This Function Tokenize the input buffer. It needs to be called in two step.
First time you call it, provide pBuf and Buflen. First Call will return 
the first token. To get next token, call the function with NULL for pBuf and
0 for Buflen.
Output: pbQuote is true if this token was enclosed in a quote.
        ppToken: Token string. Call LocalFree to free it.
Return Value:Length of Token if token found.
             0 if no token found.
             -1 in case of error. Call GetLastError to get the error.
*/
LONG GetToken(IN LPWSTR pBuf,
              IN LONG BufLen,
              IN LPWSTR pszDelimiters,
              OUT BOOL *pbQuote,
              OUT LPWSTR *ppToken)
{
    static LPWSTR pBuffer;
    static LONG BufferLen;

    DWORD dwErr = ERROR_SUCCESS;
    if(pbQuote)
        *pbQuote = FALSE;

    if(ppToken)
        *ppToken = NULL;

    LONG MaxSize = INIT_SIZE;
    LONG pos = 0;
 

    if(pBuf)
        pBuffer = pBuf;

    if(BufLen)
        BufferLen = BufLen;

    if(!BufferLen)
        return pos;
 
    do
    {
        BOOL bQuoteBegin = FALSE;
        LPTSTR pItem = NULL;
        //Find the begining of Next Token
//        while( pBuffer[0] == L' '  ||
//               pBuffer[0] == L'\t' ||
//               pBuffer[0] == L'\n'  && BufferLen)
        while(BufferLen && IsDelimiter(pBuffer[0],pszDelimiters) )
        {
            ++pBuffer;--BufferLen;
        }
       
        if(!BufferLen)
            break;
        
        //Does Token Start with '"'
        if( pBuffer[0] == L'"' )
        {
            if(pbQuote)
                *pbQuote = TRUE;
            bQuoteBegin = TRUE;
            pBuffer++; --BufferLen;
        }
        if(!BufferLen)
            break;
        if(ppToken)
        {
            pItem = (LPTSTR)LocalAlloc(LPTR,sizeof(WCHAR)*INIT_SIZE);
            if(!pItem)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return -1;
            }
        }
        
        //Now get the end
        WCHAR ch;
        while( BufferLen )
        {
            BOOL bChar = TRUE;
            if( BufferLen >= 2 && *pBuffer == L'\\' && *(pBuffer+1) == L'"')
            {
                ch = L'"';
                pBuffer +=2; BufferLen -=2;
            }
            else if(pBuffer[0] == L'"')
            {
                //A Matching Quote Found.
                if(bQuoteBegin)
                {
                    ++pBuffer;
                    --BufferLen;
                    if(BufferLen)
                    {
                        //If next char is whitespace endof token
                        //Ex "ABC" "xyz" . after C its endof token
                        //if(pBuffer[0] == L' '  ||
                        //   pBuffer[0] == L'\t' || 
                        //   pBuffer[0] == L'\n')
                        if(IsDelimiter(pBuffer[0],pszDelimiters) )
                            break;
                        else
                        {
                            //Ex "ABC"xyz 
                            if(pBuffer[0] != L'"')
                                bQuoteBegin = FALSE;
                            //"ABC""xyz"
                            else
                            {    
                                ++pBuffer;
                                --BufferLen;                                
                            }
                        }
                    }
                    bChar = FALSE;
                    //
                    // Don't break because "" means that we want to clear the field out
                    //
//                    else
//                        break;
                }
                //ABC" xyz" will get one token 'ABC xyz'
                else
                {
                    bQuoteBegin = TRUE;
                    ++pBuffer;
                    --BufferLen;
                    bChar = FALSE;
                }

            }
//            else if(!bQuoteBegin && (pBuffer[0] == L' '  ||
//                                     pBuffer[0] == L'\t' || 
//                                     pBuffer[0] == L'\n'))
            else if(!bQuoteBegin && IsDelimiter(pBuffer[0],pszDelimiters))
            {
                ++pBuffer;
                --BufferLen;
                break;
            }
            else
            {
                ch = pBuffer[0];
                ++pBuffer;
                --BufferLen;
            }
            if(bChar && ppToken)
            {
                if(pos == MaxSize -1)
                    if(ERROR_SUCCESS != ResizeByTwo(&pItem,&MaxSize))
                    {
                        LocalFree(pItem);
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return -1;
                    }            
                pItem[pos] = ch;
            }
            if(bChar)   
                ++pos;
        }
        if(pos ||
           (!pos && bQuoteBegin))
        {
            if(ppToken)
            {
                pItem[pos] = '\0';
                *ppToken = pItem;
            }
            ++pos;
        }
    }while(0);
    return pos;
}

/*
Function to convert string an array of CTokens.
INPUT: pBuf Input Buffer
       BufLen   Length of bBuf
OUTPUT:ppToken  Gets Pointer to array of CToken
       argc     Lenght of array of CToken
Return Value: WIN32 Error

*/
DWORD Tokenize(IN LPWSTR pBuf,
               IN LONG BufLen,
               LPWSTR szDelimiters,
               OUT CToken **ppToken,
               OUT int *argc)
{
    *argc = 0;
    CToken *pToken = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL bQuote;
    LPWSTR pszItem = NULL;
    //Get First Token
    LONG ret = GetToken(pBuf,
                        BufLen,
                        szDelimiters,
                        &bQuote,
                        NULL);
    if(ret == -1)
    {
        dwErr = GetLastError();
        goto exit_gracefully;
    }

    while(ret)
    {
        ++(*argc);
        ret = GetToken(NULL,
                       NULL,
                       szDelimiters,
                       &bQuote,
                       NULL);
        if(ret == -1)
        {
            dwErr = GetLastError();
            goto exit_gracefully;
        }
    }

    if(*argc)
    {
        int i =0;
        pToken = new CToken[*argc];
        if(!pToken)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto exit_gracefully;
        }
        ret = GetToken(pBuf,
                       BufLen,
                       szDelimiters,
                       &bQuote,
                       &pszItem);
        if(ret == -1)
        {
            dwErr = GetLastError();
            goto exit_gracefully;
        }
            
        while(ret)
        {
            pToken[i++].Init(pszItem,bQuote); 
            if(pszItem)
                LocalFree(pszItem);                                       
            pszItem = NULL;


            ret = GetToken(NULL,
                           NULL,
                           szDelimiters,
                           &bQuote,
                           &pszItem);
            if(ret == -1)
            {
                dwErr = GetLastError();
                goto exit_gracefully;
            }

        }
    }

exit_gracefully:
    if(dwErr != ERROR_SUCCESS)
    {
        if(pToken)
        {
            delete [] pToken ;
        }       
        return dwErr;
    }
    *ppToken = pToken;
    return dwErr;
}

/*
Function to display the parsing errors. If function cannot 
handle some error, it will return False and calling function
must handle that error.
*/
BOOL DisplayParseError(IN PPARSE_ERROR pError,
                       IN ARG_RECORD *Commands,
                       IN CToken *pToken)
{

    if(!pError)
        return FALSE;

    VOID *parg1 = NULL;
    VOID *parg2 = NULL;

    UINT idStr = 0;

	BOOL bReturn = TRUE;
    switch(pError->ErrorSource)
    {
        case ERROR_FROM_PARSER:
        {
            switch(pError->Error)
            {
                case PARSE_ERROR_SWITCH_VALUE:
                {
					idStr = IDS_PARSE_ERROR_SWITCH_VALUE;
					parg1 = Commands[pError->ArgRecIndex].strArg1;
                }
                break;

				case PARSE_ERROR_SWICH_NO_VALUE:
				{
					idStr = IDS_PARSE_ERROR_SWICH_NO_VALUE;
					parg1 = Commands[pError->ArgRecIndex].strArg1;                
				}
				break;

                case PARSE_ERROR_UNKNOWN_INPUT_PARAMETER:   
                {
					idStr = IDS_PARSE_ERROR_UNKNOWN_INPUT_PARAMETER;
					parg1 = (pToken + pError->ArgvIndex)->GetToken();
                }
                break;
                
                case PARSE_ERROR_SWITCH_NOTDEFINED:   
                {
                    idStr = IDS_PARSE_ERROR_SWITCH_NOTDEFINED;
                    parg1 = Commands[pError->ArgRecIndex].strArg1;
                }
                break;
                case PARSE_ERROR_MULTIPLE_DEF:
                {
					idStr = IDS_PARSE_ERROR_MULTIPLE_DEF;
					parg1 = Commands[pError->ArgRecIndex].strArg1;
                }        
				break;
				default:
					bReturn = FALSE;
            }

			if(idStr)
			{
				//Format the string
				LPWSTR pBuffer = NULL;
				FormatStringID(&pBuffer,
								NULL,
								idStr,
								parg1,
								parg2);

				//Display it
				if(pBuffer)
					DisplayError(pBuffer);

				LocalFreeString(&pBuffer);
			}

        }
        break;
        
        case ERROR_FROM_VLDFN:
        {
			if(pError->Error != VLDFN_ERROR_NO_ERROR)
					bReturn = FALSE;			
        }
        break;
        
        case ERROR_WIN32_ERROR:
        {
			LPWSTR pBuffer = NULL;
			if(GetSystemErrorText(&pBuffer, pError->Error))
			{
				if(pBuffer)
				{
					DisplayError(pBuffer);
					LocalFreeString(&pBuffer);
				}
				else
					bReturn = FALSE;
			}
			else
				bReturn = FALSE;
		}
        break;

		default:
			bReturn = FALSE;
		break;
    }

    return bReturn;
}

VOID DisplayError(LPWSTR pszError)
{
    if(pszError)
        WriteStandardError(L"%s\n",pszError);
}

VOID DisplayOutput(LPWSTR pszOutput)
{
    if(pszOutput)
        WriteStandardOut(L"%s\r\n",pszOutput);
}

VOID DisplayOutputNoNewline(LPWSTR pszOutput)
{
    if(pszOutput)
        WriteStandardOut(L"%s",pszOutput);
}

/*******************************************************************

    NAME:       DisplayMessage

    SYNOPSIS:   Loads Message from Message Table and Formats its
    IN          Indent - Number of tabs to indent
                MessageId - Id of the message to load
                ... - Optional list of parameters

    RETURNS:    NONE

********************************************************************/
VOID DisplayMessage(DWORD MessageId,...)
{
    PWSTR MessageDisplayString;
    va_list ArgList;
    ULONG Length;

    va_start( ArgList, MessageId );

    Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,
                            MessageId,
                            0,
                            (PWSTR)&MessageDisplayString,
                            0,
                            &ArgList );

    if ( Length != 0 ) {

        WriteStandardError(L"%s",MessageDisplayString);
        LocalFree( MessageDisplayString );
    }

    va_end( ArgList );
}


/*
Class CToken

*/
CToken::CToken(LPWSTR psz, BOOL bQuote)
{
        StringCopy(&m_pszToken,psz);
        m_bInitQuote = bQuote;
}

CToken::CToken():m_bInitQuote(FALSE),m_pszToken(NULL){}

CToken::~CToken()
{
        LocalFree(m_pszToken);
}

VOID CToken::Init(LPWSTR psz, BOOL bQuote)
{
    StringCopy(&m_pszToken,psz);
    m_bInitQuote = bQuote;
}
    
LPWSTR CToken::GetToken(){return m_pszToken;}
    
BOOL CToken::IsSwitch()
{
    //Assert(m_pszToken);
    if(!m_pszToken)
        return FALSE;
    if(m_bInitQuote)
        return FALSE;
    if(m_pszToken[0] == L'/' ||
        m_pszToken[0] == L'-')
        return TRUE;
        
    return FALSE;
}

BOOL CToken::IsSlash()
{
   if (!m_pszToken)
      return FALSE;
   if (m_bInitQuote)
      return FALSE;
   if (m_pszToken[0] == L'/')
      return TRUE;
   return FALSE;
}




// Copied from JSchwart

BOOL
FileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}


void
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
        WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
    }
    else
    {
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, cchBuffer * sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            lpBuffer,
                                            cchBuffer,
                                            lpAnsiBuffer,
                                            cchBuffer * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL);
            }

            LocalFree(lpAnsiBuffer);
        }
    }
}


void
WriteStandardOut(PCWSTR pszFormat, ...)
{
   static HANDLE standardOut = GetStdHandle(STD_OUTPUT_HANDLE);

   //
   // Verify parameters
   //
   if (!pszFormat)
   {
      return;
   }

	va_list args;
	va_start(args, pszFormat);

	int nBuf;
	WCHAR szBuffer[4 * MAX_PATH];
   ZeroMemory(szBuffer, sizeof(szBuffer));

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), pszFormat, args);

   //
   // Output the results
   //
   if (nBuf > 0)
   {
      MyWriteConsole(standardOut,
                     szBuffer,
                     nBuf);
   }
   va_end(args);

}

void
WriteStandardError(PCWSTR pszFormat, ...)
{
   static HANDLE standardErr = GetStdHandle(STD_ERROR_HANDLE);

   //
   // Verify parameters
   //
   if (!pszFormat)
   {
      return;
   }

	va_list args;
	va_start(args, pszFormat);

	int nBuf;
	WCHAR szBuffer[100 * MAX_PATH];
   ZeroMemory(szBuffer, sizeof(szBuffer));

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), pszFormat, args);

   //
   // Output the results
   //
   if (nBuf > 0)
   {
      MyWriteConsole(standardErr,
                     szBuffer,
                     nBuf);
   }
   va_end(args);

}


/*******************************************************************

    NAME:       AddDNEscaping_Commands

    SYNOPSIS:   Adds full ADSI escaping to DN arguments

********************************************************************/
DWORD AddDNEscaping_Commands( IN OUT ARG_RECORD *Commands )
{
    for( int i=0; ARG_TYPE_LAST != Commands[i].fType; i++ )
    {
        if (!(ARG_FLAG_DN & Commands[i].fFlag))
            continue;

        if (ARG_TYPE_STR == Commands[i].fType)
        {
            if (NULL == Commands[i].strValue)
                continue;
            LPWSTR pszEscaped = NULL;
            DWORD dwErr = AddDNEscaping_DN(&pszEscaped, Commands[i].strValue);
            if (ERROR_SUCCESS != dwErr)
                return dwErr;
            LocalFree(Commands[i].strValue);
            Commands[i].strValue = pszEscaped;
            continue;
        }
        
        if (ARG_TYPE_MSZ != Commands[i].fType)
        {
            continue; // shouldn't happen
        }

        if (NULL == Commands[i].strValue)
            continue;

        // count through double-NULL-terminated string list
        PWSTR pszDoubleNullObjectDN = Commands[i].strValue;
        LPTSTR buffer = NULL;
        LONG maxSize = 0;
        LONG currentSize = 0;
        if (!StartBuffer(&buffer,&maxSize,&currentSize))
            return ERROR_NOT_ENOUGH_MEMORY;
        for ( ;
                NULL != pszDoubleNullObjectDN &&
                L'\0' != *pszDoubleNullObjectDN;
                pszDoubleNullObjectDN += (wcslen(pszDoubleNullObjectDN)+1) )
        {
            LPWSTR pszEscaped = NULL;
            DWORD dwErr = AddDNEscaping_DN(&pszEscaped, pszDoubleNullObjectDN);
            if (ERROR_SUCCESS != dwErr)
                return dwErr;
            dwErr = AddToBuffer(pszEscaped,
                                &buffer,&maxSize,&currentSize,TRUE);
            if (ERROR_SUCCESS != dwErr)
                return dwErr;
            LocalFree(pszEscaped);
        }
        LocalFree(Commands[i].strValue);
        Commands[i].strValue = buffer;
    }

    return ERROR_SUCCESS;
} // AddDNEscaping_Commands

DWORD AddDNEscaping_DN( OUT LPWSTR* ppszOut, IN LPWSTR pszIn )
{
    //
    // JonN 5/12/01 special-case "domainroot" and "forestroot" which can be
    // parameters to "-startnode" but fail IADsPathname::GetEscapedElement().
    //
    if (!pszIn ||
        !*pszIn ||
        !_tcsicmp(L"domainroot",pszIn) ||
        !_tcsicmp(L"forestroot",pszIn))
    {
        return (StringCopy(ppszOut,pszIn))
            ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;
    }

    LONG maxSize = 0;
    LONG currentSize = 0;
    if (!StartBuffer(ppszOut,&maxSize,&currentSize))
        return ERROR_NOT_ENOUGH_MEMORY;

    // copy pszIn into temporary buffer
    LPWSTR pszCopy = NULL;
    if (!StringCopy(&pszCopy,pszIn) || NULL == pszCopy)
        return ERROR_NOT_ENOUGH_MEMORY;

    WCHAR* pchElement = pszCopy;
    WCHAR* pch = pszCopy;
    do {
        if (L'\\' == *pch && (L',' == *(pch+1) || L'\\' == *(pch+1)))
        {
            //
            // manual escaping on command line
            //

            // also copies trailing L'\0'
            memmove(pch, pch+1, wcslen(pch)*sizeof(WCHAR));
        }
        else if (L',' == *pch || L'\0' == *pch)
        {
            //
            // completes path element
            //

            WCHAR chTemp = *pch;
            *pch = L'\0';

            LPWSTR pszEscaped = NULL;
            HRESULT hr = GetEscapedElement( &pszEscaped, pchElement );

            if (FAILED(hr) || NULL == pszEscaped)
                return ERROR_NOT_ENOUGH_MEMORY; // CODEWORK can FILL_ERROR handle an HRESULT?

            if (NULL != *ppszOut && L'\0' != **ppszOut)
            {
                // add seperator to DN
                DWORD dwErr = AddToBuffer(L",",
                                          ppszOut,&maxSize,&currentSize,
                                          FALSE); // not MSZ output
                if (ERROR_SUCCESS != dwErr)
                    return dwErr;
            }
            // add path element to DN
            DWORD dwErr = AddToBuffer(pszEscaped,
                                      ppszOut,&maxSize,&currentSize,
                                      FALSE); // not MSZ output
            if (ERROR_SUCCESS != dwErr)
                return dwErr;

            ::LocalFree(pszEscaped);

            if (L'\0' == chTemp)
                break;

            *pch = chTemp;
            pchElement = pch+1;
        }

        pch++;
    } while (true);

    LocalFree(pszCopy);

    return ERROR_SUCCESS;
} // AddDNEscaping_DN

BOOL StartBuffer( OUT LPTSTR* pbuffer,
                  OUT LONG* pmaxSize,
                  OUT LONG* pcurrentSize )
{
    *pbuffer = (LPTSTR)LocalAlloc(LPTR,MAXSTR*sizeof(TCHAR)); // init to zero
    *pmaxSize = MAXSTR;
    *pcurrentSize = 0;
    return (NULL != pbuffer);
}

DWORD AddToBuffer( IN LPCTSTR psz,
                   IN OUT LPTSTR* pbuffer,
                   IN OUT LONG* pmaxSize,
                   IN OUT LONG* pcurrentSize,
                   BOOL fMSZBuffer)
{
    LONG len = (LONG)wcslen(psz);
    //-2 as last string is delimited by two null
    while(((*pcurrentSize) + len) > ((*pmaxSize) - 2))
    {
        DWORD dwErr = ResizeByTwo(pbuffer,pmaxSize);
        if (dwErr != ERROR_SUCCESS)
            return dwErr;
    }
    _tcscpy(((*pbuffer) + (*pcurrentSize)), psz);
    (*pcurrentSize) += len;
    //tail end of pbuffer is all NULLs
    if (fMSZBuffer)
        (*pcurrentSize)++;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dscmd\parser\util.cpp ===
#include "pch.h"







//Read From Stdin
//Return Value:
//  Number of WCHAR read if successful 
//  -1 in case of Failure. Call GetLastError to get the error.
LONG ReadFromIn(OUT LPWSTR *ppBuffer)
{
    LPWSTR pBuffer = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    pBuffer = (LPWSTR)LocalAlloc(LPTR,INIT_SIZE*sizeof(WCHAR));        
    if(!pBuffer)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return -1;
    }

    LONG Pos = 0;
    LONG MaxSize = INIT_SIZE;
    wint_t ch;
    while((ch = getwchar()) != WEOF)
    {
        if(Pos == MaxSize -1 )
        {
            if(ERROR_SUCCESS != ResizeByTwo(&pBuffer,&MaxSize))
            {
                LocalFree(pBuffer);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return -1;
            }
        }
        pBuffer[Pos++] = (WCHAR)ch;
    }
    pBuffer[Pos] = L'\0';
    *ppBuffer = pBuffer;
    return Pos;
}



//General Utility Functions
DWORD ResizeByTwo( LPTSTR *ppBuffer,
                   LONG *pSize )
{
    LPWSTR pTempBuffer = (LPWSTR)LocalAlloc(LPTR,(*pSize)*2*sizeof(WCHAR));        
    if(!pTempBuffer)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pTempBuffer,*ppBuffer,*pSize*sizeof(WCHAR));
    LocalFree(*ppBuffer);
    *ppBuffer = pTempBuffer;
    *pSize *=2;
    return ERROR_SUCCESS;
}

BOOL StringCopy( LPWSTR *ppDest, LPWSTR pSrc)
{
    *ppDest = NULL;
    if(!pSrc)
        return TRUE;

    *ppDest = (LPWSTR)LocalAlloc(LPTR, (wcslen(pSrc) + 1)*sizeof(WCHAR));
    if(!*ppDest)
        return FALSE;
    wcscpy(*ppDest,pSrc);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\adsihelpers.hpp ===
// ADSI Helper functions
//
// Copyright (c) 2001 Microsoft Corporation
//
// 1 Mar 2001 sburns



#ifndef ADSIHELPERS_HPP_INCLUDED
#define ADSIHELPERS_HPP_INCLUDED



// CODEWORK: consider putting this, and some of the more general purpose
// adsi goodies from admin\snapin\localsec\src\adsi.hpp|.cpp into an
// adsi header in burnslib.



// Template function that actually calls ADsOpenObject.
//
// Interface - The IADsXXX interface of the object to be bound.
//
// path - in, The ADSI path of the object to be bound.
//
// ptr - out, A null smart pointer to be bound to the interface of the object.

template <class Interface>
HRESULT
AdsiOpenObject(
   const String&              path,
   SmartInterface<Interface>& ptr)
{
   LOG_FUNCTION2(AdsiOpenObject, path);
   ASSERT(!path.empty());

   Interface* p = 0;
   HRESULT hr =
      ::ADsOpenObject(
         path.c_str(),
         0,
         0,
         ADS_SECURE_AUTHENTICATION,         
         __uuidof(Interface),
         reinterpret_cast<void**>(&p));
   if (SUCCEEDED(hr))
   {
      ptr.Acquire(p);
   }

   LOG_HRESULT(hr);
   
   return hr;
}



#endif   // ADSIHELPERS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\analisysresults.hpp ===
#ifndef ANALISYS_RESULTS_HPP
#define ANALISYS_RESULTS_HPP

#include "global.hpp"

using namespace std;



// This file contains the data structure with the analisys results
struct ObjectId
{
   long locale;
   String object;

   ObjectId(long locale_,String &object_):
			locale(locale_),object(object_) {};
   
   // The operator below is necessary for structs
   // to be map keys. It ends up defining the order
   // in which the ldiff entries will appear, i.e.
   // first by locale and then by object.
   bool operator < (const ObjectId& idArg) const
   {
      return   (idArg.locale > locale) ||
               (idArg.object > object);
               
   }
};


struct ValueActions
{
   StringList addValues;
   StringList delValues;
};


typedef map < 
				   String,
				   ValueActions,
               less<String>, 
				   Burnslib::Heap::Allocator<ValueActions> 
			   > PropertyActions;



typedef map	< 
				   ObjectId,
				   PropertyActions,
               less<ObjectId>, 
				   Burnslib::Heap::Allocator<PropertyActions> 
			   > ObjectActions;

   // The previous map was thought keeping in mind the repair phase.
   // It accumulates additions and removals for properties 
   // in order to provide an ldiff layout where all actions 
   // related to a property would be grouped under all
   // actions related to an object
   //
   // The repair phase will do something like
   // For each element of objectActions
   //    write the header for the object 
   //    like "dn: CN=object,CN=401,CN=DisplaySpecifiers...\n"
   //    write "changetype: ntdsSchemaModify\n"
   //    For each Property in the object
   //       get the list of actions for the property
   //       if you have a reset, write "delete: property\n-"
   //       if you have additions
   //          write "add: property\n"
   //          write all additions in the form "property: addValue\n"
   //          write "\n-\n"
   //       End if
   //       if you have removals
   //          write "delete: property\n"
   //          write all removals in the form "property: delValue\n"
   //          write "\n-\n"
   //       End if
   //    End For Each
   // End For Each

typedef list <
               ObjectId,
               Burnslib::Heap::Allocator<ObjectId>
             > ObjectIdList;


struct SingleValue
{
   long     locale;
   String   object;
   String   property;
   String   value;
   
   SingleValue
   (
      const long     locale_,
      const String   &object_,
      const String   &property_,
      const String   &value_
   )
   :
      locale(locale_),
      object(object_),
      property(property_),
      value(value_)
   {}
};

typedef list <
               SingleValue,
               Burnslib::Heap::Allocator<SingleValue>
             > SingleValueList;




struct AnalisysResults
{
   LongList          createContainers;
   ObjectIdList      conflictingXPObjects;
   ObjectIdList      createXPObjects;
   ObjectIdList      createW2KObjects;
   ObjectActions     objectActions;
   SingleValueList   customizedValues;
   ObjectActions     extraneousValues;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\constants.hpp ===
#ifndef CONSTANTS_HPP
#define CONSTANTS_HPP

#include <stdlib.h>
#include <set>

using namespace std;



enum TYPE_OF_CHANGE 
{
   // NOP stands for no operation.
   // It gives an alternative way to limit the
   // enumeration of CHANGE_LIST
   NOP,
   ADD_ALL_CSV_VALUES, 
   ADD_VALUE,           // Currently not used in CHANGE_LIST
   REPLACE_W2K_SINGLE_VALUE, 
   REPLACE_W2K_MULTIPLE_VALUE,
   ADD_GUID, 
   REMOVE_GUID
};


#define MAX_CHANGES_PER_OBJECT 20

struct sChange
{
   wchar_t *property;
   wchar_t *value;
   enum TYPE_OF_CHANGE type;
};

struct sChangeList
{

   wchar_t *object;
   struct sChange changes[MAX_CHANGES_PER_OBJECT];
};

#define N_REPLACE_W2K 5


extern const long LOCALEIDS[];
extern const long LOCALE409[];
extern const wchar_t *NEW_XP_OBJECTS[];
extern const struct sChangeList CHANGE_LIST[];

typedef map < 
               pair<long,long>,
               String,
               less< pair<long,long> > ,
               Burnslib::Heap::Allocator< String > 
            > sReplaceW2KStrs;

extern sReplaceW2KStrs replaceW2KStrs;

void setReplaceW2KStrs();

#endif;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\constants.cpp ===
#include "headers.hxx"
#include "constants.hpp"
#include "global.hpp"
#include <set>

using namespace std;


const long LOCALE409[] = {0x409,0};

const long LOCALEIDS[] =
{
   // a list of all the non-english locale IDs that we support
   
   0x401,
   0x404,
   0x405,
   0x406,
   0x407,
   0x408,
   0x40b,
   0x40c,
   0x40d,
   0x40e,
   0x410,
   0x411,
   0x412,
   0x413,
   0x414,
   0x415,
   0x416,
   0x419,
   0x41d,
   0x41f,
   0x804,
   0x816,
   0xc0a,
   0
};




const wchar_t *NEW_XP_OBJECTS[] =
{
   // New objects on windows XP
   L"msMQ-Custom-Recipient-Display",
   L"msMQ-Group-Display",
   L"msCOM-PartitionSet-Display",
   L"msCOM-Partition-Display",
   L"lostAndFound-Display",
   L"inetOrgPerson-Display",
   L"",
};


// In CHANGE_LIST, the entries for REPLACE_W2K_MULTIPLE_VALUE and 
// REPLACE_W2K_SINGLE_VALUE will start with a character representing
// the index to replaceW2KStrs where to find the W2K string.
 
// For REPLACE_W2K_MULTIPLE_VALUE, after the index, there will be
// two additional semicolon separated strings ending with colon. 
// The first string is the beginning of the W2K value and the second
// is the beginning of the Whistler value. They are used to distinguish
// the multiple value from others and they end in colon to make sure
// we have a correct match

// Since replaceW2KStrs has the whole W2K value we will not need
// the beginning of the W2K value for the update. We will needed it
// to get the value that is stored in replaceW2KStrs.
// These values, with the exception of 409 entries, are generated 
// by the W2KStrs companion tool (preBuild folder)
// and pasted in setReplaceW2KStrs further bellow.

const struct sChangeList CHANGE_LIST[] =
{
   // List of changes in objects that existed in W2K and
   // stil exist in XP.
   // This list is a 1 to 1 map of the specification table

   {
      L"DS-UI-Default-Settings",
      {
         {
            L"dSUIAdminNotification",
            L"2,{a00e1768-4a9b-4d97-afc6-99d329f605f2}",
            ADD_GUID
         },
         {
            L"msDS-FilterContainers",
            L"",
            ADD_ALL_CSV_VALUES
         },
         {
            L"msDS-Non-Security-Group-Extra-Classes",
            L"",
            ADD_ALL_CSV_VALUES
         },
         { L"",L"",NOP },
      }
   },
   {
      L"domainDNS-Display",
      {
         {
            L"attributeDisplayNames",
            L"\x0;cn,;dc,", //cn,Name in 409
            REPLACE_W2K_MULTIPLE_VALUE
         },
         { L"",L"",NOP },
      }
   },
   {
      L"computer-Display",
      {
         {
            L"adminPropertyPages",
            L"7,{B52C1E50-1DD2-11D1-BC43-00C04FC31FD3}",
            ADD_GUID
         },
         { L"",L"",NOP },
      }
   },
   {
      L"organizationalUnit-Display",
      {
         {
            L"adminPropertyPages",
            L"6,{FA3E1D55-16DF-446d-872E-BD04D4F39C93}",
            ADD_GUID
         },
         { L"",L"",NOP },
      }
   },
   {
      L"container-Display",
      {
         {
            L"adminContextMenu",
            L"3,{EEBD2F15-87EE-4F93-856F-6AD7E31787B3}",
            ADD_GUID
         },
         {
            L"adminContextMenu",
            L"4,{AB790AA1-CDC1-478a-9351-B2E05CFCAD09}",
            ADD_GUID
         },
         { L"",L"",NOP },
      }
   },

   {
      L"pKICertificateTemplate-Display",
      {
         {
            L"adminPropertyPages",
            L"1,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
            REMOVE_GUID
         },
         {
            L"adminPropertyPages",
            L"1,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
            ADD_GUID
         },
         {
            L"adminPropertyPages",
            L"3,{4e40f770-369c-11d0-8922-00a024ab2dbb}",
            REMOVE_GUID
         },
         {
            L"shellPropertyPages",
            L"1,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
            REMOVE_GUID
         },
         {
            L"shellPropertyPages",
            L"1,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
            ADD_GUID
         },
         {
            L"contextMenu",
            L"0,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
            REMOVE_GUID
         },
         {
            L"contextMenu",
            L"0,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
            ADD_GUID
         },
         {
            L"adminContextMenu",
            L"0,{9bff616c-3e02-11d2-a4ca-00c04fb93209}",
            REMOVE_GUID
         },
         {
            L"adminContextMenu",
            L"0,{11BDCE06-D55C-44e9-BC0B-8655F89E8CC5}",
            ADD_GUID
         },
         {
            L"iconPath",
            L"\x1", 
            // In 409 "capesnpn.dll,-227" will be replaced by
            // "0,certtmpl.dll,-144"
            REPLACE_W2K_SINGLE_VALUE
         },
         { L"",L"",NOP },
      }
   },
   {
      L"default-Display",
      {
         {
            L"adminMultiselectPropertyPages",
            L"1,{50d30563-9911-11d1-b9af-00c04fd8d5b0}",
            ADD_GUID
         },
         {

            L"extraColumns",
            L"",
            ADD_ALL_CSV_VALUES
         },
         { L"",L"",NOP },
      }
   },
   {
      L"nTDSService-Display",
      {
         {
            L"classDisplayName",
            L"\x2", 
            // In 409 "Service" will be replaced by
            // "Active Directory Service"
            REPLACE_W2K_SINGLE_VALUE
         },
         { L"",L"",NOP },
      }
   },
   {
      L"user-Display",
      {
         {
            L"adminMultiselectPropertyPages",
            L"1,{50d30564-9911-11d1-b9af-00c04fd8d5b0}", 
            ADD_GUID
         },
         {
            L"adminPropertyPages",
            L"9,{FA3E1D55-16DF-446d-872E-BD04D4F39C93}", 
            ADD_GUID
         },
         {
            L"attributeDisplayNames",
            L"\x3;internationalISDNNumber,;internationalISDNNumber,",
            REPLACE_W2K_MULTIPLE_VALUE
         },
         {
            L"attributeDisplayNames",
            L"\x4;otherHomePhone;otherHomePhone",
            REPLACE_W2K_MULTIPLE_VALUE
         },
         { L"",L"",NOP },
      }
   },
   {L"",{ L"",L"",NOP }},
};

// All REPLACE entries in CHANGE_LIST
// will have the first wchar_t as an index to this table
sReplaceW2KStrs replaceW2KStrs;


void setReplaceW2KStrs()
{
   LOG_FUNCTION(setReplaceW2KStrs);
   

   replaceW2KStrs.clear();
   pair<long,long> tmpIndxLoc;
   
   // Computer generated code bellow (W2KStrs.exe in the preBuild folder)
   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x401;
   replaceW2KStrs[tmpIndxLoc]=L"cn,&0627&0644&0627&0633&0645";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x401;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x401;
   replaceW2KStrs[tmpIndxLoc]=L"&062e&062f&0645&0629 Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x401;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,&0631&0642&0645 ISDN &0627&0644&062f&0648&0644&064a (&0622&062e&0631)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x401;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,&0631&0642&0645 &0647&0627&062a&0641 &0627&0644&0645&0646&0632&0644 (&0622&062e&0631)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x404;
   replaceW2KStrs[tmpIndxLoc]=L"cn,&540d&7a31";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x404;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x404;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory &670d&52d9";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x404;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,&570b&969b ISDN &865f&78bc (&5176&4ed6)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x404;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,&4f4f&5b85&96fb&8a71&865f&78bc (&5176&4ed6)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x405;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Jm&00e9no";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x405;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x405;
   replaceW2KStrs[tmpIndxLoc]=L"Slu&017eba Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x405;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Mezin&00e1rodn&00ed &010d&00edslo ISDN (dal&0161&00ed &010d&00edsla)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x405;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Telefonn&00ed &010d&00edslo dom&016f (dal&0161&00ed &010d&00edsla)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x406;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Navn";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x406;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x406;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory-tjeneste";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x406;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Internationalt ISDN-nummer (andre)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x406;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Telefonnummer, privat (andre)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x407;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Name";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x407;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x407;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory-Dienst";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x407;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Internationale ISDN-Nummer (Andere)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x407;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Privatrufnummer (Andere)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x408;
   replaceW2KStrs[tmpIndxLoc]=L"cn,&039f&03bd&03bf&03bc&03b1&03c4&03b5&03c0&03ce&03bd&03c5&03bc&03bf";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x408;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x408;
   replaceW2KStrs[tmpIndxLoc]=L"&03a5&03c0&03b7&03c1&03b5&03c3&03af&03b1 &03ba&03b1&03c4&03b1&03bb&03cc&03b3&03bf&03c5 Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x408;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,&0394&03b9&03b5&03b8&03bd&03ae&03c2 &03b1&03c1&03b9&03b8&03bc&03cc&03c2 ISDN (&03ac&03bb&03bb&03bf&03b9)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x408;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,&03a4&03b7&03bb&03ad&03c6&03c9&03bd&03bf &03bf&03b9&03ba&03af&03b1&03c2 (&03ac&03bb&03bb&03b1)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x40b;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Nimi";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x40b;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x40b;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory -palvelu";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x40b;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Kansainv&00e4linen ISDN-numero (muut)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x40b;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Kotipuhelinnumero (muut)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x40c;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Nom";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x40c;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x40c;
   replaceW2KStrs[tmpIndxLoc]=L"Service Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x40c;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Num&00e9ro RNIS international (Autres)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x40c;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Num&00e9ro de t&00e9l&00e9phone domicile (Autres)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x40d;
   replaceW2KStrs[tmpIndxLoc]=L"cn,&05e9&05dd";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x40d;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x40d;
   replaceW2KStrs[tmpIndxLoc]=L"&05e9&05d9&05e8&05d5&05ea Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x40d;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,&05de&05e1&05e4&05e8 ISDN &05d1&05d9&05e0&05dc&05d0&05d5&05de&05d9 (&05d0&05d7&05e8&05d9&05dd)&200f";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x40d;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,&05de&05e1&05e4&05e8 &05d8&05dc&05e4&05d5&05df &05d1&05d1&05d9&05ea (&05d0&05d7&05e8&05d9&05dd)&200f";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x40e;
   replaceW2KStrs[tmpIndxLoc]=L"cn,N&00e9v";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x40e;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x40e;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory szolg&00e1ltat&00e1s";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x40e;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Nemzetk&00f6zi ISDN-sz&00e1m (egy&00e9b)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x40e;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Otthoni telefonsz&00e1m (egy&00e9b)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x410;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Nome utente";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x410;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x410;
   replaceW2KStrs[tmpIndxLoc]=L"Servizio Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x410;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Numero ISDN internazionale (altri)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x410;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Numero telefono abitazione (altri)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x411;
   replaceW2KStrs[tmpIndxLoc]=L"cn,&540d&524d";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x411;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x411;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory &30b5&30fc&30d3&30b9";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x411;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,&56fd&969b ISDN &756a&53f7 (&305d&306e&4ed6)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x411;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,&81ea&5b85&96fb&8a71&756a&53f7 (&305d&306e&4ed6)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x412;
   replaceW2KStrs[tmpIndxLoc]=L"cn,&c774&b984";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x412;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x412;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory &c11c&be44&c2a4";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x412;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,&ad6d&c81c ISDN &bc88&d638 (&ae30&d0c0)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x412;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,&c9d1 &c804&d654 &bc88&d638(&ae30&d0c0)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x413;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Naam";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x413;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x413;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory-service";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x413;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Internationaal ISDN-nummer (overig)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x413;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Telefoonnummer priv&00e9 (overig)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x414;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Navn";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x414;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x414;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory-tjeneste";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x414;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Internasjonalt ISDN-nummer (andre)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x414;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Telefonnummer, privat (andre)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x415;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Nazwa";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x415;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x415;
   replaceW2KStrs[tmpIndxLoc]=L"Us&0142uga Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x415;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Mi&0119dzynarodowy numer sieciowy ISDN (inne)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x415;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Numer telefonu domowego (inne)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x416;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Nome";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x416;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x416;
   replaceW2KStrs[tmpIndxLoc]=L"Servi&00e7o Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x416;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,N&00famero ISDN internacional (outros)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x416;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,N&00famero de telefone residencial (outros)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x419;
   replaceW2KStrs[tmpIndxLoc]=L"cn,&041f&043e&043b&043d&043e&0435 &0438&043c&044f";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x419;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x419;
   replaceW2KStrs[tmpIndxLoc]=L"&0421&043b&0443&0436&0431&0430 &043a&0430&0442&0430&043b&043e&0433&043e&0432 Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x419;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,&041c&0435&0436&0434&0443&043d&0430&0440&043e&0434&043d&044b&0439 &043d&043e&043c&0435&0440 ISDN (&043f&0440&043e&0447&0438&0435)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x419;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,&0414&043e&043c&0430&0448&043d&0438&0439 &0442&0435&043b&0435&0444&043e&043d (&043f&0440&043e&0447&0438&0435)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x41d;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Namn";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x41d;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x41d;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory-tj&00e4nst";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x41d;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,ISDN-nummer (alternativ)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x41d;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Telefonnummer, hem (alternativ)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x41f;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Ad&0131";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x41f;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x41f;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory Hizmeti";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x41f;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,Uluslararas&0131 ISDN Numaras&0131 (Di&011ferleri)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x41f;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,Ev Telefonu Numaras&0131 (Di&011ferleri)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x804;
   replaceW2KStrs[tmpIndxLoc]=L"cn,&540d&79f0";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x804;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x804;
   replaceW2KStrs[tmpIndxLoc]=L"Active Directory &670d&52a1";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x804;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,&56fd&9645 ISDN &53f7&7801(&5176&5b83)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x804;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,&5bb6&5ead&7535&8bdd&53f7&7801 (&5176&5b83)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x816;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Nome";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x816;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x816;
   replaceW2KStrs[tmpIndxLoc]=L"Servi&00e7o do Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x816;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,N&00famero RDIS internacional (outros)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x816;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,N&00famero de telefone da resid&00eancia (outros)";

   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0xc0a;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Nombre";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0xc0a;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0xc0a;
   replaceW2KStrs[tmpIndxLoc]=L"Servicio de Active Directory";

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0xc0a;
   replaceW2KStrs[tmpIndxLoc]=L"internationalISDNNumber,N&00famero ISDN (RDSI) internacional (otros)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0xc0a;
   replaceW2KStrs[tmpIndxLoc]=L"otherHomePhone,N&00famero de tel&00e9fono particular (otros)";
   // End of generated code (W2KStrs.exe in the preBuild folder)

   sReplaceW2KStrs::iterator begin=replaceW2KStrs.begin();
   sReplaceW2KStrs::iterator end=replaceW2KStrs.end();
   while(begin!=end)
   {
      tmpIndxLoc.first=begin->first.first;
      tmpIndxLoc.second=begin->first.second;
      
      replaceW2KStrs[tmpIndxLoc]=unEscape(begin->second);

      begin++;
   }

   // Now we add the 409 Strings
   tmpIndxLoc.first=0;
   tmpIndxLoc.second=0x409;
   replaceW2KStrs[tmpIndxLoc]=L"cn,Name";

   tmpIndxLoc.first=1;
   tmpIndxLoc.second=0x409;
   replaceW2KStrs[tmpIndxLoc]=L"0,capesnpn.dll,-227";

   tmpIndxLoc.first=2;
   tmpIndxLoc.second=0x409;
   replaceW2KStrs[tmpIndxLoc]=L"Service";   

   tmpIndxLoc.first=3;
   tmpIndxLoc.second=0x409;
   replaceW2KStrs[tmpIndxLoc]=
      L"internationalISDNNumber, International ISDN Number (Others)";

   tmpIndxLoc.first=4;
   tmpIndxLoc.second=0x409;
   replaceW2KStrs[tmpIndxLoc]= L"otherHomePhone,Home Phone (Others)";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\csvdsreader.cpp ===
#include "headers.hxx"
#include "CSVDSReader.hpp"
#include "resource.h"
#include "global.hpp"

#include <stdio.h> 
#include <crtdbg.h>



CSVDSReader::CSVDSReader():file(INVALID_HANDLE_VALUE)
{
}



HRESULT 
CSVDSReader::read(
                  const wchar_t  *fileName_,
                  const long *locales)
{
   
   LOG_FUNCTION(CSVDSReader::read);
   
   localeOffsets.clear();
   propertyPositions.clear();
   
   fileName=fileName_;
   
   HRESULT hr=S_OK;
   
   do
   {
      // fill localeOffsets and property positions
      if(!FS::FileExists(fileName)) 
      {
         error=fileName;
         hr=Win32ToHresult(ERROR_FILE_NOT_FOUND);
         break;
      }
      
      
      hr=FS::CreateFile(fileName,file,GENERIC_READ,FILE_SHARE_READ);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      do
      {
         AnsiString unicodeId;
         hr=FS::Read(file, 2, unicodeId);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         if (unicodeId[0]!='\xFF' || unicodeId[1]!='\xFE')
         {
            error = String::format(IDS_INVALID_CSV_UNICODE_ID,
                                                   fileName.c_str());
            hr=E_FAIL;
            break;
         }
         
         hr=parseProperties();
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=parseLocales(locales);
         BREAK_ON_FAILED_HRESULT(hr);
         
      } while(0);
      
      if (FAILED(hr))
      {
         CloseHandle(file);
         file=INVALID_HANDLE_VALUE;
         break;
      }
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}




// Decode first line of the file building propertyPositions
// Expects file to be in the first valid file character (after
//   the unicode identifier)
HRESULT CSVDSReader::parseProperties()
{
   LOG_FUNCTION(CSVDSReader::parseProperties);
   
   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   HRESULT hr=S_OK;
   
   
   do
   {
      
      String csvLine;
      hr=ReadLine(file,csvLine);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      StringList tokens;
      size_t token_count = csvLine.tokenize(back_inserter(tokens),L",");
      ASSERT(token_count == tokens.size());
         
      StringList::iterator begin=tokens.begin();
      StringList::iterator end=tokens.end();
      
      
      long count=0;
      while( begin != end )
      {
         propertyPositions[begin->to_upper()]=count++;
         begin++;
      }
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


// Fill localeOffsets with the starting position of all locales
// Expects file to be in the second line
// Expects the locale order to be the same as the one
// found in the file
HRESULT CSVDSReader::parseLocales(const long *locales)
{

   LOG_FUNCTION(CSVDSReader::parseLocales);

   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   HRESULT hr=S_OK;
   
   do
   {
      
      long count=0;
      bool flagEof=false;

      while(locales[count]!=0 && !flagEof)
      {
         long locale=locales[count];
         
         String localeStr=String::format(L"CN=%1!3x!,", locale);
         
         LARGE_INTEGER pos;
         
         hr = WinGetVLFilePointer(file, &pos);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         String csvLine;
         hr=ReadLine(file,csvLine);
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         if(csvLine.length() > localeStr.length())
         {
            csvLine.erase(localeStr.size()+1);
            
            if( localeStr.icompare(&csvLine[1])==0 )
            {
               localeOffsets[locale]=pos;
               count++;
            }
         }
      }
      
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      if(locales[count]!=0)
      {
         error=String::format(IDS_MISSING_LOCALES,fileName.c_str());
         hr=E_FAIL;
         break;
      }
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}

// get the csv value starting with value to XPValue
// returns S_FALSE if no value is found
HRESULT
CSVDSReader::getCsvValue( 
   const long     locale,
   const wchar_t  *object, 
   const wchar_t  *property,
   const String   &value,
   String         &XPValue) const

{
   LOG_FUNCTION(CSVDSReader::getCsvValue);

   HRESULT hr=S_OK;
   XPValue.erase();

   bool found=false;

   do
   {
      StringList values;
      hr=getCsvValues(locale,object,property,values);
      BREAK_ON_FAILED_HRESULT(hr);
   
      StringList::const_iterator begin,end;
      begin=values.begin();
      end=values.end();
      while(begin!=end && !found)
      {
         if (_wcsnicmp(begin->c_str(),value.c_str(),value.length())==0)
         {
            XPValue=*begin;
            found=true;
         }
         begin++;
      }
   }
   while(0);

   if (!found)
   {
      hr=S_FALSE;
   }

   LOG_HRESULT(hr);
   return hr;
}



HRESULT
CSVDSReader::getCsvValues(
                          const long     locale,
                          const wchar_t  *object, 
                          const wchar_t  *property,
                          StringList     &values)
                          const
{
   LOG_FUNCTION(CSVDSReader::getCsvValues);

   // seek on locale
   // read sequentially until find object
   // call parseLine on the line found to retrieve values
   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   HRESULT hr=S_OK;
   
   do
   {
      
      String propertyString(property);
      
      mapOfPositions::const_iterator propertyPos = 
         propertyPositions.find(propertyString.to_upper());
      
      if (propertyPos==propertyPositions.end())
      {
         error=String::format(IDS_PROPERTY_NOT_FOUND_IN_CSV,
            property,
            fileName.c_str());
         hr=E_FAIL;
         break;
      }
      
      String csvLine;
      hr=getObjectLine(locale,object,csvLine);
      BREAK_ON_FAILED_HRESULT(hr);
      
      
      hr=parseLine(csvLine.c_str(),propertyPos->second,values);
      BREAK_ON_FAILED_HRESULT(hr);
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


// starting from the locale offset
// finds the object and returns its line in csvLine
HRESULT 
CSVDSReader::getObjectLine(   
                           const long     locale,
                           const wchar_t  *object,
                           String         &csvLine
                           ) const
{
   
   LOG_FUNCTION(CSVDSReader::getObjectLine);

   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   HRESULT hr=S_OK;
   
   do
   {
     
      mapOfOffsets::const_iterator offset = 
         localeOffsets.find(locale);
      
      // locale must have been passed to read
      ASSERT(offset!=localeOffsets.end());
      
      String objectStr;
      
      objectStr=String::format(L"CN=%1,CN=%2!3x!",object,locale);
      
      hr=Win::SetFilePointerEx(file,offset->second,0,FILE_BEGIN);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      // first line is the container properties and since we want the
      // properties of an object we will ignore it
      
      bool flagEof=false;
      hr=ReadLine(file,csvLine);
      if(hr==EOF_HRESULT)
      {
         flagEof=true;
         hr=S_OK;
      }
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      bool found=false;
      while(!found && !flagEof)
      {
         hr=ReadLine(file,csvLine);
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         if(csvLine.length() > objectStr.length())
         {
            String auxComp=csvLine.substr(1,objectStr.length());
            
            if( auxComp.icompare(objectStr)==0 )
            {
               found=true;
            }
         }
      }
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      if(!found)
      {
         error = String::format(
            IDS_OBJECT_NOT_FOUND_IN_CSV,
            object,
            locale,
            fileName.c_str()
            );
         hr=E_FAIL;
         break;
      }
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


//Get the values from the line at the position
HRESULT
CSVDSReader::parseLine(
                       const wchar_t  *line, 
                       const long     position,
                       StringList     &values) const
{
   LOG_FUNCTION(CSVDSReader::parseLine);

   ASSERT(line!=NULL);
   ASSERT(file!=INVALID_HANDLE_VALUE);
   HRESULT hr=S_OK;
   
   do
   {

      
      long pos=0;
      const wchar_t *csr=line;
      const wchar_t *sBegin=line;
      size_t count=0;
      
      while(pos<=position && csr!=NULL && *csr!=0)
      {
         while(*csr==L' ' || *csr==L'\t') csr++;

         // The goal of both 'if' and 'else' is setting sBegin and count
         // and leaving csr after the next comma
         if (*csr==L'"')
         {
            sBegin=csr+1;
            csr=wcschr(sBegin,L'"');
            if(csr==NULL)
            {
               error=String::format(IDS_QUOTES_NOT_CLOSED,fileName.c_str());
               break;
            }
            count=csr-sBegin;
            csr=wcschr(csr+1,L',');
            if(csr!=NULL) csr++;
         }
         else
         {
            sBegin=csr;
            csr=wcschr(sBegin,L',');
            
            if(csr!=NULL) 
            {
               count=csr-sBegin;
               csr++;
            }
            else
            {
               count=wcslen(sBegin);
            }
         }
         
         pos++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
      
      String sProp(sBegin,count);
      values.clear();
      size_t token_count = sProp.tokenize(back_inserter(values),L";");
      ASSERT(token_count == values.size());
         
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}



HRESULT CSVDSReader::writeHeader(HANDLE  fileOut) const
{
   LOG_FUNCTION(CSVDSReader::writeHeader);

   HRESULT hr=S_OK;
   do
   {
      char suId[3]={'\xFF','\xFE',0};
      //uId solves ambiguous Write
      AnsiString uId(suId);
      hr=FS::Write(fileOut,uId);
      BREAK_ON_FAILED_HRESULT(hr);
      
      // 2 to skip the unicode identifier
      LARGE_INTEGER pos;
      pos.QuadPart=2;
      hr=Win::SetFilePointerEx(file,pos,0,FILE_BEGIN);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      String csvLine;
      hr=ReadLine(file,csvLine);
      // We are breaking for EOF_HRESULT too, since 
      // there should be more lines in the csv
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
      
      hr=FS::WriteLine(fileOut,csvLine);
      BREAK_ON_FAILED_HRESULT(hr);
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
   
   
}

HRESULT
CSVDSReader::makeLocalesCsv(
                            HANDLE         fileOut,
                            const   long  *locales) const
{
   LOG_FUNCTION(CSVDSReader::makeLocalesCsv);

   HRESULT hr=S_OK;
   ASSERT(file!=INVALID_HANDLE_VALUE);
   ASSERT(fileOut!=INVALID_HANDLE_VALUE);
   
   do
   {
      
     
      LARGE_INTEGER posStartOut;
      hr = WinGetVLFilePointer(fileOut, &posStartOut);
      BREAK_ON_FAILED_HRESULT(hr);
      
      if (posStartOut.QuadPart==0)
      {
         hr=writeHeader(fileOut);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      long count=0;
      String csvLoc;

      while(locales[count]!=0)
      {
         long locale=locales[count];
         mapOfOffsets::const_iterator offset;
         offset = localeOffsets.find(locale);
         
         // locale must have been passed to read
         ASSERT(offset!=localeOffsets.end());         

         hr=Win::SetFilePointerEx(file,offset->second,0,FILE_BEGIN);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         
         String localeStr=String::format(L"CN=%1!3x!,", locale);       
         
         bool flagEof=false;
         String csvLine;
         
         hr=ReadLine(file,csvLine);
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         do 
         {
            hr=FS::WriteLine(fileOut,csvLine);
            BREAK_ON_FAILED_HRESULT(hr);
            
            hr=ReadLine(file,csvLine);
            if(hr==EOF_HRESULT)
            {
               flagEof=true;
               hr=S_OK;
            }
            BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
            
            size_t posComma=csvLine.find(L",");
            if(posComma!=string::npos)
            {
               csvLoc=csvLine.substr(posComma+1,localeStr.length());
            }
            else
            {
               csvLoc.erase();
            }
         } while( 
                  !flagEof && 
                  !csvLoc.empty() &&
                  ( csvLoc.icompare(localeStr) == 0 ) 
                );

         count++;
      }  // while(locales[count]!=0)
      
      
      BREAK_ON_FAILED_HRESULT(hr);
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}


HRESULT
CSVDSReader::makeObjectsCsv(
                            HANDLE              fileOut,
                            const setOfObjects  &objects) const
{

   LOG_FUNCTION(CSVDSReader::makeObjectsCsv);

   HRESULT hr=S_OK;
   ASSERT(file!=INVALID_HANDLE_VALUE);
   
   do
   {
      
      LARGE_INTEGER posStartOut;
      hr = WinGetVLFilePointer(fileOut, &posStartOut);
      BREAK_ON_FAILED_HRESULT(hr);
      
      if (posStartOut.QuadPart==0)
      {
         hr=writeHeader(fileOut);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      setOfObjects::const_iterator begin,end;
      begin=objects.begin();
      end=objects.end();
      
      while(begin!=end)
      {
         String csvLine;
         hr=getObjectLine( begin->second,
            begin->first.c_str(),
            csvLine);
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=FS::WriteLine(fileOut,csvLine);
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
      
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\analisys.cpp ===
#include "headers.hxx"
#include "global.hpp"


#include "Analisys.hpp"
#include "AnalisysResults.hpp"
#include "CSVDSReader.hpp"
#include "resource.h"
#include "AdsiHelpers.hpp"
#include "constants.hpp"
#include "dspecup.hpp"




Analisys::Analisys
   (
      const CSVDSReader&   csvReader409_,
      const CSVDSReader&   csvReaderIntl_,
      const String&        ldapPrefix_,
      const String&        rootContainerDn_,
      AnalisysResults      &res,
      const String         &reportName_,//=L"", 
      void                 *caleeStruct_,//=NULL,
		progressFunction     stepIt_,//=NULL,
		progressFunction     totalSteps_//=NULL,
   )
   :
   csvReader409(csvReader409_),
   csvReaderIntl(csvReaderIntl_),
   ldapPrefix(ldapPrefix_),
   rootContainerDn(rootContainerDn_),
   results(res),
   reportName(reportName_),
   caleeStruct(caleeStruct_),
   stepIt(stepIt_),
   totalSteps(totalSteps_)
{
   LOG_CTOR(Analisys);
   ASSERT(!ldapPrefix.empty());
   ASSERT(!rootContainerDn.empty());

};


// Analisys entry point
HRESULT 
Analisys::run()
{
   LOG_FUNCTION(Analisys::run);

   setReplaceW2KStrs();

   HRESULT hr=S_OK;
   do
   {
      LongList locales;
      for(long t=0;LOCALEIDS[t]!=0;t++)
      {
         locales.push_back(LOCALEIDS[t]);
      }
      locales.push_back(LOCALE409[0]);
      
      if(totalSteps!=NULL)
      {
         // The cast bellow is for IA64 compilation since we know
         // that locales.size() will fit in a long.
         totalSteps(static_cast<long>(locales.size()),caleeStruct);
      }

      BREAK_ON_FAILED_HRESULT(hr);

      LongList::iterator begin=locales.begin();
      LongList::iterator end=locales.end();


      while(begin!=end)
      {
         long locale=*begin;
         bool isPresent;

         hr=dealWithContainer(locale,isPresent);
         BREAK_ON_FAILED_HRESULT(hr);

         if (isPresent)
         {
            hr=dealWithXPObjects(locale);
            BREAK_ON_FAILED_HRESULT(hr);

            hr=dealWithW2KObjects(locale);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if(stepIt!=NULL)
         {
            stepIt(1,caleeStruct);
         }

         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      if(!reportName.empty())
      {
         hr=createReport(reportName);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// add entry to result.createContainers if container is not present
// also returns flag isPresent
HRESULT 
Analisys::dealWithContainer(
   const long  locale,
   bool        &isPresent)
{
   LOG_FUNCTION(Analisys::dealWithContainer);

   ASSERT(locale > 0); 
   ASSERT(!rootContainerDn.empty());
   
     

   HRESULT hr = S_OK;
   

   do
   {
      String container = String::format(L"CN=%1!3x!,", locale);
      String childContainerDn =ldapPrefix +  container + rootContainerDn;

      // Attempt to bind to the container.
         
      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(childContainerDn, iads);
      if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT)
      {
         // The container object does not exist.  This is possible because
         // the user has manually removed the container, or because it
         // was never created due to an aboted post-dcpromo import of the
         // display specifiers when the forest root dc was first promoted.

         results.createContainers.push_back(locale);

         isPresent=false;

         hr = S_OK;
         break;
      }  
      else if (FAILED(hr))
      {
         error=String::format(IDS_ERROR_BINDING_TO_CONTAINER,
                              childContainerDn.c_str());
         break;
      }


      // At this point, the bind succeeded, so the child container exists.
      // So now we want to examine objects in that container.

      isPresent=true;
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// add entries to results.conflictingXPObjects or
// results.createXPObject as necessary
HRESULT 
Analisys::dealWithXPObjects(const long locale)
{
   LOG_FUNCTION(Analisys::dealWithXPObjects);

   ASSERT(locale > 0);
   ASSERT(!rootContainerDn.empty());

   HRESULT hr = S_OK;

   do
   {
      for (
               int i = 0;
               *NEW_XP_OBJECTS[i]!=0;
               ++i
          )
      {
         String objectName = NEW_XP_OBJECTS[i];
         
         String objectPath =
            ldapPrefix +  L"CN=" + objectName + L"," + 
            String::format(L"CN=%1!3x!,", locale) + rootContainerDn;

         SmartInterface<IADs> iads(0);
         hr = AdsiOpenObject<IADs>(objectPath, iads);
         if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT)
         {
            // The object does not exist. This is what we expect. We want
            // to add the object in the repair phase.
            ObjectId tempObj(locale,objectName);
            results.createXPObjects.push_back(tempObj);
            hr = S_OK;
            continue;
         }
         else if (SUCCEEDED(hr))
         {
            // The object already exists. We have a conflict.
            ObjectId tempObj(locale,objectName);
            results.conflictingXPObjects.push_back(tempObj);
          }
         else
         {

            error=String::format(
                  IDS_ERROR_BINDING_TO_OBJECT,
                  objectName.c_str(),
                  objectPath.c_str());
 
            break;
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
   
   LOG_HRESULT(hr);
   return hr;

}



// add entries to results.createW2KObjects 
//       and results.objectActions as necessary
HRESULT 
Analisys::dealWithW2KObjects(const long locale)
{
   LOG_FUNCTION(Analisys::dealWithW2KObjects);
   ASSERT(locale  >0);
   ASSERT(!rootContainerDn.empty());

   HRESULT hr = S_OK;

   do
   {
      for(
            long i = 0;
            *(CHANGE_LIST[i].object)!=0;
            ++i
         )
      {
         String objectName = CHANGE_LIST[i].object;
         String objectPath =
            ldapPrefix +  L"CN=" + objectName + L"," + 
            String::format(L"CN=%1!3x!,", locale) + rootContainerDn;

         SmartInterface<IADs> iads(0);
         hr = AdsiOpenObject<IADs>(objectPath, iads);
         if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT)
         {
            // The object does not exist. 
            ObjectId tempObj(locale,objectName);
            results.createW2KObjects.push_back(tempObj);
            hr = S_OK;
            continue;
         }
         else if (SUCCEEDED(hr))
         {
            // At this point, the display specifier object exists.  Determine if
            // if has been touched since its creation.

            SmartInterface<IDirectoryObject> iDirObj;
            
            hr=iDirObj.AcquireViaQueryInterface(iads); 
           // hr = iads->QueryInterface(IID_IDirectoryObject,(void **)iDirObj);
            BREAK_ON_FAILED_HRESULT(hr);
       
            hr = checkChanges(locale,CHANGE_LIST[i],iDirObj);
            BREAK_ON_FAILED_HRESULT(hr);

         }
         else
         {
            error=String::format(
                  IDS_ERROR_BINDING_TO_OBJECT,
                  objectName.c_str(),
                  objectPath.c_str());

            break;
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
   
   LOG_HRESULT(hr);
   return hr;

}

HRESULT 
Analisys::checkChanges(
   const long locale,
   const sChangeList& changes,
   IDirectoryObject *iDirObj)
{
   LOG_FUNCTION(Analisys::checkChanges);

   wchar_t *object=changes.object;
   HRESULT hr=S_OK;
   for(
      long i = 0;
      *(changes.changes[i].property)!=0;
      ++i)
   {
         struct sChange change=changes.changes[i];
         switch(change.type)
         {
         case ADD_ALL_CSV_VALUES: 
            
            hr = addAllCsvValues
                 (
                     iDirObj,
                     locale,
                     object,
                     change.property
                 );

            if(FAILED(hr))
            {
               LOG_HRESULT(hr);
               return hr;
            }
            break;

         case ADD_VALUE: 
       
            hr = addValue
                 (
                     iDirObj,
                     locale,
                     object,
                     change.property,
                     change.value
                 );
            
            if(FAILED(hr))
            {
               LOG_HRESULT(hr);
               return hr;
            }
            break;

         case REPLACE_W2K_MULTIPLE_VALUE: 

            hr = replaceW2KMultipleValue
                 (
                     iDirObj,
                     locale,
                     object,
                     change.property,
                     change.value
                 );

            if(FAILED(hr))
            {
               LOG_HRESULT(hr);
               return hr;
            }
            break;

         case REPLACE_W2K_SINGLE_VALUE: 

            hr = replaceW2KSingleValue
                 (
                     iDirObj,
                     locale,
                     object,
                     change.property,
                     change.value
                 );

            if(FAILED(hr))
            {
               LOG_HRESULT(hr);
               return hr;
            }
            break;

         case ADD_GUID: 

            hr = addGuid
                 (
                     iDirObj,
                     locale,
                     object,
                     change.property,
                     change.value
                 );

            if(FAILED(hr))
            {
               LOG_HRESULT(hr);
               return hr;
            }
            break;

         case REMOVE_GUID: 

            hr = removeGuid
                 (
                     iDirObj,
                     locale,
                     object,
                     change.property,
                     change.value
                 );

            if(FAILED(hr))
            {
               LOG_HRESULT(hr);
               return hr;
            }
            break;

         default:
            ASSERT(false);
         }
   }
   
   LOG_HRESULT(S_OK);
   return S_OK;
}


// adds ordAndGuid to the property if Guid is not already there.
HRESULT 
Analisys::addGuid(
   IDirectoryObject     *iDirObj,
   const int            locale,
   const wchar_t        *object, 
   const wchar_t        *property, 
   const wchar_t        *ordAndGuid)
{
   LOG_FUNCTION(Analisys::addGuid);

   HRESULT hr = S_OK;

   String propertStr(property);
   String ordAndGuidStr(ordAndGuid);
   
   do
   {
      String guidFound;
      hr=getADGuid(   
                     iDirObj,
                     propertStr,
                     ordAndGuidStr,
                     guidFound
                  );

      BREAK_ON_FAILED_HRESULT(hr);
   
      if (hr == S_FALSE)
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.addValues.push_back(ordAndGuidStr);
      }
       
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// adds all csv values still not on the property
HRESULT
Analisys::addAllCsvValues(
   IDirectoryObject     *iDirObj,
   const long           locale,
   const wchar_t        *object, 
   const wchar_t        *property)
{
   LOG_FUNCTION(Analisys::addAllCsvValues);
   
   HRESULT hr = S_OK;
   const CSVDSReader &csvReader=(locale==0x409)?csvReader409:csvReaderIntl;

   do
   {
      StringList values;
      hr=csvReader.getCsvValues(locale,object,property,values);
      BREAK_ON_FAILED_HRESULT(hr);

      if (values.size()==0)
      {
         error=String::format(IDS_NO_CSV_VALUE,locale,object);
         hr=E_FAIL;
         break;
      }
      StringList::iterator begin=values.begin();
      StringList::iterator end=values.end();
      while(begin!=end)
      {
         hr=addValue(iDirObj,locale,object,property,begin->c_str());
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


// adds value to the property if it is not already there. 
HRESULT 
Analisys::addValue(
   IDirectoryObject     *iDirObj,
   const int            locale,
   const wchar_t        *object, 
   const wchar_t        *property,
   const wchar_t        *value)
{
   LOG_FUNCTION(Analisys::addValue);

   HRESULT hr = S_OK;

   String valueStr(value);
   String propertyStr(property);
   
   do
   {
      hr=isADValuePresent (   
                              iDirObj,
                              propertyStr,
                              valueStr
                          );

      BREAK_ON_FAILED_HRESULT(hr);
   
      if (hr == S_FALSE)
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.addValues.push_back(value);
      }
       
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}



//Auxiliary function for replaceW2KSingleValue
// retrieves csvValue
HRESULT 
Analisys::getCsvSingleValue
          (
            const int               locale,
            const wchar_t           *object, 
            const wchar_t           *property,
            String                  &csvValue
          )
{
   LOG_FUNCTION(Analisys::getCsvReplacementValue);

   const CSVDSReader &csvReader=(locale==0x409)?csvReader409:csvReaderIntl;

  
   HRESULT hr = S_OK;
   do
   {

      StringList XPCsvValues;
      hr=csvReader.getCsvValues(locale,object,property,XPCsvValues);
      BREAK_ON_FAILED_HRESULT(hr);

      // we should have only one value in the csv
      // since we can't distinguish the 
      // value we want to replace from others as
      // in REPLACE_W2K_MULTIPLE_VALE
      if(XPCsvValues.size() != 1)
      {
         error=String::format
                       (
                           IDS_NOT_ONE_CSV_VALUE,
                           XPCsvValues.size(),
                           csvReader.getFileName().c_str(),
                           locale,
                           object,
                           property
                       );
         hr=E_FAIL;
         break;
      }

      csvValue = *XPCsvValues.begin();

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}


// The idea of replaceW2KValue is replacing the W2K value
// for the Whistler. We also make sure we don't extraneous values.
HRESULT 
Analisys::replaceW2KSingleValue
          (
               IDirectoryObject        *iDirObj,
               const int               locale,
               const wchar_t           *object, 
               const wchar_t           *property,
               const wchar_t           *value
          )
{
   LOG_FUNCTION(Analisys::replaceW2KValue);

   long index = *value;
   String objectStr(object);
   String propertyStr(property);

   HRESULT hr = S_OK;
   do
   {
      String XPCsvValue;

      hr=getCsvSingleValue
         (
            locale,
            object, 
            property,
            XPCsvValue
         );

      BREAK_ON_FAILED_HRESULT(hr);


    // Retrieve W2KCsvValue from replaceW2KStrs
      pair<long,long> tmpIndxLoc;
      tmpIndxLoc.first=index;
      tmpIndxLoc.second=locale;
      String &W2KCsvValue=replaceW2KStrs[tmpIndxLoc];

      // There is nothing to do if the Whistler csv value
      // is the same as it was in W2K
      if (XPCsvValue.icompare(W2KCsvValue)==0)
      {
         break;
      }

      // Now we might have a replacement to do since the value
      // changed from W2K to Whistler
      
      hr=isADValuePresent(iDirObj,propertyStr,XPCsvValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // The Whistler value is already there
      {
         // We will remove any other value than the Whistler
         hr=removeExtraneous(iDirObj,locale,objectStr,propertyStr,XPCsvValue);
         break;
      }

      // Now we know that the Whistler value is not present
      // and therefore we will add it if the W2K value is present

      hr=isADValuePresent(iDirObj,propertyStr,W2KCsvValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // The W2K value is there.
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.addValues.push_back(XPCsvValue);
         act.delValues.push_back(W2KCsvValue);

         // remove all but the W2K that we removed in the previous line
         hr=removeExtraneous(iDirObj,locale,objectStr,propertyStr,W2KCsvValue);
         break;
      }

      // Now we know that neither Whistler nor W2K values are present
      // If we have a value we will log that it is a custom value

      String ADValue;
      hr=getADFirstValue(iDirObj,propertyStr,ADValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // We have a value
      {
         SingleValue tmpCustom(locale,objectStr,propertyStr,ADValue);
         results.customizedValues.push_back(tmpCustom);

         // We will remove any other value than the one we found
         hr=removeExtraneous(iDirObj,locale,objectStr,propertyStr,ADValue);
         break;
      }
      
      // Now we know that we don't have any values at all.
      ObjectId tempObj(locale,String(object));

      ValueActions &act=results.objectActions[tempObj][property];
      act.addValues.push_back(XPCsvValue);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}

//Auxiliary function for replaceW2KMultipleValue
// retrieves csvValue and XPStart
HRESULT 
Analisys::getCsvMultipleValue
          (
            const int               locale,
            const wchar_t           *object, 
            const wchar_t           *property,
            const wchar_t           *value,
            String                  &csvValue,
            String                  &XPstart
          )
{
   LOG_FUNCTION(Analisys::getCsvReplacementValue);

   const CSVDSReader &csvReader=(locale==0x409)?csvReader409:csvReaderIntl;

  
   HRESULT hr = S_OK;
   do
   {
      String sW2KXP(value+2); // +2 for index and semicollon
      StringList lW2KXP;
      size_t cnt=sW2KXP.tokenize(back_inserter(lW2KXP),L";");
      XPstart=lW2KXP.back();

      // We have the W2K and the XP start
      ASSERT(cnt==2);

      // Search the csv for the value starting with the XP string 
      hr=csvReader.getCsvValue(
                                 locale,
                                 object,
                                 property,
                                 XPstart.c_str(),
                                 csvValue
                              );

      BREAK_ON_FAILED_HRESULT(hr);

      // We should always find a csv value
      if(hr == S_FALSE)
      {
         error=String::format(
                                 IDS_VALUE_NOT_IN_CSV,
                                 XPstart.c_str(),
                                 locale,
                                 object,
                                 property,
                                 csvReader.getFileName().c_str()
                             );
         hr=E_FAIL;
         break;
      }
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}



// The idea of replaceW2KValue is replacing the W2K value
// for the Whistler. We also make sure we don't extraneous values.
HRESULT 
Analisys::replaceW2KMultipleValue
          (
               IDirectoryObject        *iDirObj,
               const int               locale,
               const wchar_t           *object, 
               const wchar_t           *property,
               const wchar_t           *value
          )
{
   LOG_FUNCTION(Analisys::replaceW2KValue);

   long index = *value;
   String objectStr(object);
   String propertyStr(property);

   HRESULT hr = S_OK;
   do
   {
      String XPCsvValue,XPStart;

      // Get the Whistler csv value and the start of the Whistler value
      hr=getCsvMultipleValue
         (
            locale,
            object, 
            property,
            value,
            XPCsvValue,
            XPStart
         );

      BREAK_ON_FAILED_HRESULT(hr);

      // Retrieve W2KCsvValue from replaceW2KStrs
      pair<long,long> tmpIndxLoc;
      tmpIndxLoc.first=index;
      tmpIndxLoc.second=locale;
      String &W2KCsvValue=replaceW2KStrs[tmpIndxLoc];

      // There is nothing to do if the Whistler csv value
      // is the same as it was in W2K
      if (XPCsvValue.icompare(W2KCsvValue)==0)
      {
         break;
      }

      // Now we might have a replacement to do since the value
      // changed from W2K to Whistler

      // First we should get the beginning of the W2K string
      // for use in removeExtraneous calls
      size_t pos=W2KCsvValue.find(L',');
      String W2KStart;
      // We only need to assert since the W2KStrs tool would 
      // detect any REPLACE_W2K_MULTIPLE_VALUE without a comma
      ASSERT(pos != String::npos);
      W2KStart=W2KCsvValue.substr(0,pos+1);

      
            
      hr=isADValuePresent(iDirObj,propertyStr,XPCsvValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // The Whistler value is already there
      {
         hr=removeExtraneous(
                              iDirObj,
                              locale,
                              objectStr,
                              propertyStr,
                              XPCsvValue,
                              XPStart,
                              W2KStart
                            );
         BREAK_ON_FAILED_HRESULT(hr);

         break;
      }

      // Now we know that the Whistler value is not present
      // and therefore we will add it if the W2K value is present

      hr=isADValuePresent(iDirObj,propertyStr,W2KCsvValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr == S_OK) // The W2K value is there.
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.addValues.push_back(XPCsvValue);
         act.delValues.push_back(W2KCsvValue);

         // remove all but the W2K that we removed in the previous line
         hr=removeExtraneous(
                              iDirObj,
                              locale,
                              objectStr,
                              propertyStr,
                              W2KCsvValue,
                              XPStart,
                              W2KStart
                            );
         break;
      }

      // Now we know that neither Whistler nor W2K values are present
      // If we have a value starting like the W2K we will log that it 
      // is a custom value

        
      String ADValue;

      hr=isADStartValuePresent(iDirObj,propertyStr,W2KStart,ADValue);
      BREAK_ON_FAILED_HRESULT(hr);

      if(hr==S_OK) // Something starts like the W2K csv value
      {
         SingleValue tmpCustom(locale,objectStr,propertyStr,ADValue);
         results.customizedValues.push_back(tmpCustom);

         // We will keep only the first custom value
         hr=removeExtraneous(
                              iDirObj,
                              locale,
                              objectStr,
                              propertyStr,
                              ADValue,
                              XPStart,
                              W2KStart
                            );
         break;
      }
      

      // Now neither Whistler, W2K or W2KStart are present
      if ( XPStart.icompare(W2KStart) != 0 )
      {
         // We have to check the XPStart as well

         hr=isADStartValuePresent(iDirObj,propertyStr,XPStart,ADValue);
         BREAK_ON_FAILED_HRESULT(hr);

         if(hr == S_OK) // Something starts like the Whistler csv value
         {
            SingleValue tmpCustom(locale,objectStr,propertyStr,ADValue);
            results.customizedValues.push_back(tmpCustom);

            // We will keep only the first custom value
            hr=removeExtraneous(
                                 iDirObj,
                                 locale,
                                 objectStr,
                                 propertyStr,
                                 ADValue,
                                 XPStart,
                                 W2KStart
                               );
            break;
         }
      }

      // Now we know that there are no values starting like
      // the Whistler or W2K csv values so we have to add 
      // the Whistler value
      ObjectId tempObj(locale,String(object));

      ValueActions &act=results.objectActions[tempObj][property];
      act.addValues.push_back(XPCsvValue);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}



// removes ordAndGuid from the property if Guid is there. 
HRESULT 
Analisys::removeGuid(
   IDirectoryObject     *iDirObj,
   const int            locale,
   const wchar_t        *object, 
   const wchar_t        *property,
   const wchar_t        *ordAndGuid)
{

   LOG_FUNCTION(Analisys::removeGuid);

   HRESULT hr = S_OK;
   String propertStr(property);
   String ordAndGuidStr(ordAndGuid);
   
   do
   {
      String guidFound;
      hr=getADGuid(   
                     iDirObj,
                     propertStr,
                     ordAndGuidStr,
                     guidFound
                  );
      BREAK_ON_FAILED_HRESULT(hr);
   
      if (hr == S_OK)
      {
         ObjectId tempObj(locale,String(object));
      
         ValueActions &act=results.objectActions[tempObj][property];
         act.delValues.push_back(guidFound);
      }
       
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


//called from RwplaceW2KMultipleValue to remove all values
// starting with start1 or start2 other than keeper
HRESULT
Analisys::removeExtraneous
          (
               IDirectoryObject     *iDirObj,
               const int            locale,
               const String         &object, 
               const String         &property,
               const String         &keeper,
               const String         &start1,
               const String         &start2
          )
{
   LOG_FUNCTION(Analisys::removeExtraneous);

   DWORD   dwReturn;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      BREAK_ON_FAILED_HRESULT(hr);

      if(pAttrInfo==NULL)
      {
         hr = S_FALSE;
         break;

      }

      for (
            long val=0; 
            val < pAttrInfo->dwNumValues;
            val++, pAttrInfo->pADsValues++
          )
      {
         wchar_t *valueAD = pAttrInfo->pADsValues->CaseIgnoreString;

         if (  _wcsicmp(valueAD,keeper.c_str())!=0 &&
               (
                  _wcsnicmp(valueAD,start1.c_str(),start1.size())==0 ||
                  _wcsnicmp(valueAD,start2.c_str(),start2.size())==0
               )
            )
         {
            String value=pAttrInfo->pADsValues->CaseIgnoreString;
            ObjectId tempObj(locale,String(object));

            ValueActions &act=results.extraneousValues[tempObj][property];
            act.delValues.push_back(value);
         }
      }
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// called from RwplaceW2KSingleValue to remove all values
// other than keeper
HRESULT
Analisys::removeExtraneous
          (
               IDirectoryObject     *iDirObj,
               const int            locale,
               const String         &object, 
               const String         &property,
               const String         &keeper
          )
{
   LOG_FUNCTION(Analisys::removeExtraneous);

   DWORD   dwReturn;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      BREAK_ON_FAILED_HRESULT(hr);

      if(pAttrInfo==NULL)
      {
         hr = S_FALSE;
         break;

      }

      for (
            long val=0; 
            val < pAttrInfo->dwNumValues;
            val++, pAttrInfo->pADsValues++
          )
      {
         wchar_t *valueAD = pAttrInfo->pADsValues->CaseIgnoreString;

         if (  _wcsicmp(valueAD,keeper.c_str())!=0 )
         {
            String value=pAttrInfo->pADsValues->CaseIgnoreString;
            ObjectId tempObj(locale,String(object));

            ValueActions &act=results.extraneousValues[tempObj][property];
            act.delValues.push_back(value);
         }
      }
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// if any value exists in the AD with the same guid as guidValue
// it is returned in guidFound, otherwise S_FALSE is returned
HRESULT
Analisys::getADGuid
          (
               IDirectoryObject     *iDirObj,
               const String         &property,
               const String         &guidValue,
               String               &guidFound
          )
{
   LOG_FUNCTION(Analisys::getADGuid);
   
   DWORD   dwReturn;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};

   size_t pos=guidValue.find(L',');
   ASSERT(pos!=String::npos);

   String guid=guidValue.substr(pos+1);

   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      BREAK_ON_FAILED_HRESULT(hr);

      // If there are no values we finish the search
      hr=S_FALSE;

      if(pAttrInfo==NULL)
      {
         break;
      }

      

      for (
            long val=0; 
            val < pAttrInfo->dwNumValues;
            val++, pAttrInfo->pADsValues++
          )
      {
         
         wchar_t *guidAD=wcschr(pAttrInfo->pADsValues->CaseIgnoreString,L',');
         if(guidAD != NULL)
         {
            guidAD++;

            if (_wcsicmp(guid.c_str(),guidAD)==0)
            {
               guidFound=pAttrInfo->pADsValues->CaseIgnoreString;
               hr=S_OK;
               break;
            }
         }
      }

   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


// returns S_OK if value is present or S_FALSE otherwise
HRESULT
Analisys::isADValuePresent
          (
               IDirectoryObject     *iDirObj,
               const String         &property,
               const String         &value
          )
{
   LOG_FUNCTION(Analisys::isADValuePresent);
   
   DWORD   dwReturn;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      BREAK_ON_FAILED_HRESULT(hr);

      
      hr=S_FALSE;

      // If there are no values we finish the search
      if(pAttrInfo==NULL)
      {
         break;
      }

      for (
            long val=0; 
            val < pAttrInfo->dwNumValues;
            val++, pAttrInfo->pADsValues++
          )
      {
         wchar_t *valueAD=pAttrInfo->pADsValues->CaseIgnoreString;
         if (_wcsicmp(value.c_str(),valueAD)==0)
         {
            hr=S_OK;
            break;
         }
      }

   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}


// retrieves the first value starting with valueStart 
// from the Active Directory
// If no value is found S_FALSE is returned.
HRESULT
Analisys::isADStartValuePresent
          (
               IDirectoryObject     *iDirObj,
               const String         &property,
               const String         &valueStart,
               String               &value
          )
{
   LOG_FUNCTION(Analisys::isADStartValuePresent);
   
   DWORD   dwReturn;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      BREAK_ON_FAILED_HRESULT(hr);
      
      value.erase();

      hr = S_FALSE;

      // If there are no values we finish the search
      if(pAttrInfo==NULL)
      {
         break;

      }

      for (
            long val=0; 
            (val < pAttrInfo->dwNumValues);
            val++, pAttrInfo->pADsValues++
          )
      {
         wchar_t *valueAD=pAttrInfo->pADsValues->CaseIgnoreString;
         if (_wcsnicmp(valueStart.c_str(),valueAD,valueStart.size())==0)
         {
            value=pAttrInfo->pADsValues->CaseIgnoreString;
            hr=S_OK;
            break;
         }
      }


   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

// retrieves the first value starting with valueStart 
// from the Active Directory
// If no value is found S_FALSE is returned.
HRESULT
Analisys::getADFirstValue
          (
               IDirectoryObject     *iDirObj,
               const String         &property,
               String               &value
          )
{
   LOG_FUNCTION(Analisys::getADFirstValue);
   
   DWORD   dwReturn;
   ADS_ATTR_INFO *pAttrInfo   =NULL;
   
   // GetObjectAttributes swears that pAttrName is an IN argument.
   // It should have used a LPCWSTR but now we have to pay the 
   // casting price
   LPWSTR pAttrName[] ={const_cast<LPWSTR>(property.c_str())};
   
   HRESULT hr = S_OK;

   do
   {
      hr = iDirObj->GetObjectAttributes( 
                                          pAttrName, 
                                          1, 
                                          &pAttrInfo, 
                                          &dwReturn 
                                        );

      BREAK_ON_FAILED_HRESULT(hr);

      // If there are no values we finish the search
      if(pAttrInfo==NULL)
      {
         hr = S_FALSE;
         break;
      }

      value=pAttrInfo->pADsValues->CaseIgnoreString;

   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}



// auxiliary in the createReport to 
// enumerate an ObjectIdList
HRESULT 
Analisys::reportObjects
          (
               HANDLE file,
               const ObjectIdList &list,
               const String &header
          )
{
   LOG_FUNCTION(Analisys::reportObjects);
   HRESULT hr=S_OK;

   do
   {
      if(list.size()==0) break;
      hr=FS::WriteLine(file,header);
      BREAK_ON_FAILED_HRESULT(hr);

      ObjectIdList::const_iterator begin,end;
      begin=list.begin();
      end=list.end();
      while(begin!=end)
      {

         hr=FS::WriteLine(
                              file,
                              String::format
                              (
                                 IDS_RPT_OBJECT_FORMAT,
                                 begin->object.c_str(),
                                 begin->locale
                              )  
                         );
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}

// auxiliary in the createReport to 
// enumerate a LongList
HRESULT 
Analisys::reportContainers
            (
               HANDLE file,
               const LongList &list,
               const String &header
            )
{
   LOG_FUNCTION(Analisys::reportContainers);
   HRESULT hr=S_OK;

   do
   {
      if(list.size()==0) break;
      hr=FS::WriteLine(file,header);
      BREAK_ON_FAILED_HRESULT(hr);

      LongList::const_iterator begin,end;
      begin=list.begin();
      end=list.end();
      while(begin!=end)
      {

         hr=FS::WriteLine(
                              file,
                              String::format
                              (
                                 IDS_RPT_CONTAINER_FORMAT,
                                 *begin
                              )  
                         );
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}

// auxiliary in the createReport to 
// enumerate a SingleValueList
HRESULT 
Analisys::reportValues
            (
               HANDLE file,
               const SingleValueList &list,
               const String &header
            )
{
   LOG_FUNCTION(Analisys::reportContainers);
   HRESULT hr=S_OK;

   do
   {
      if(list.size()==0) break;
      hr=FS::WriteLine(file,header);
      BREAK_ON_FAILED_HRESULT(hr);

      SingleValueList::const_iterator begin,end;
      begin=list.begin();
      end=list.end();
      while(begin!=end)
      {

         hr=FS::WriteLine(
                              file,
                              String::format
                              (
                                 IDS_RPT_VALUE_FORMAT,
                                 begin->value.c_str(),
                                 begin->locale,
                                 begin->object.c_str(),
                                 begin->property.c_str()
                              )  
                         );
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}


// auxiliary in the createReport to 
// enumerate ObjectActions
HRESULT 
Analisys::reportActions
            (
               HANDLE file,
               const ObjectActions &list,
               const String &header
            )
{
   LOG_FUNCTION(Analisys::reportActions);
   HRESULT hr=S_OK;

   do
   {
      if(list.size()==0) break;
      hr=FS::WriteLine(file,header);
      BREAK_ON_FAILED_HRESULT(hr);

      ObjectActions::const_iterator beginObj=list.begin();
      ObjectActions::const_iterator endObj=list.end();

      while(beginObj!=endObj) 
      {

         hr=FS::WriteLine
                (
                     file,
                     String::format
                     (
                        IDS_RPT_OBJECT_FORMAT,
                        beginObj->first.object.c_str(),
                        beginObj->first.locale
                     )  
                 );
         BREAK_ON_FAILED_HRESULT(hr);
         
    
         PropertyActions::iterator beginAct=beginObj->second.begin();
         PropertyActions::iterator endAct=beginObj->second.end();

         while(beginAct!=endAct)
         {

            StringList::iterator 
               beginDel = beginAct->second.delValues.begin();
            StringList::iterator 
               endDel = beginAct->second.delValues.end();
            while(beginDel!=endDel)
            {
               hr=FS::WriteLine
                      (
                           file,
                           String::format
                           (
                              IDS_RPT_DEL_VALUE_FORMAT,
                              beginAct->first.c_str(),
                              beginDel->c_str()
                           )  
                       );
               BREAK_ON_FAILED_HRESULT(hr);

               beginDel++;
            }
            BREAK_ON_FAILED_HRESULT(hr); // break on if internal while broke


            StringList::iterator 
               beginAdd = beginAct->second.addValues.begin();
            StringList::iterator 
               endAdd = beginAct->second.addValues.end();
            while(beginAdd!=endAdd)
            {
               hr=FS::WriteLine
                      (
                           file,
                           String::format
                           (
                              IDS_RPT_ADD_VALUE_FORMAT,
                              beginAct->first.c_str(),
                              beginAdd->c_str()
                           )  
                       );
               BREAK_ON_FAILED_HRESULT(hr);

               beginAdd++;
            }
            BREAK_ON_FAILED_HRESULT(hr); // break on if internal while broke

            beginAct++;
         } // while(beginAct!=endAct)
         BREAK_ON_FAILED_HRESULT(hr); // break on if internal while broke

         beginObj++;
      } // while(beginObj!=endObj)
      
      BREAK_ON_FAILED_HRESULT(hr);

   }
   while(0);

   LOG_HRESULT(hr);
   return hr;
}


// Create the report from the AnalisysResults
HRESULT
Analisys::createReport(const String& reportName)
{
   LOG_FUNCTION(Analisys::createReport);
   HRESULT hr=S_OK;
   do
   {
      
      HANDLE file;

      hr=FS::CreateFile(reportName,
                        file,
                        GENERIC_WRITE);
   
      if (FAILED(hr))
      {
         error=String::format(IDS_COULD_NOT_CREATE_FILE,reportName.c_str());
         break;
      }


      do
      {
         hr=FS::WriteLine(file,String::load(IDS_RPT_HEADER));
         BREAK_ON_FAILED_HRESULT(hr);


         hr=reportActions (
                              file,
                              results.extraneousValues,
                              String::load(IDS_RPT_EXTRANEOUS)
                          );
         BREAK_ON_FAILED_HRESULT(hr);



         hr=reportValues (
                              file,
                              results.customizedValues,
                              String::load(IDS_RPT_CUSTOMIZED)
                          );
         BREAK_ON_FAILED_HRESULT(hr);

         hr=reportObjects (
                              file,
                              results.conflictingXPObjects,
                              String::load(IDS_RPT_CONFLICTINGXP)
                          );
         BREAK_ON_FAILED_HRESULT(hr);

         hr=reportActions (
                              file,
                              results.objectActions,
                              String::load(IDS_RPT_ACTIONS)
                          );
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=reportObjects  (
                              file,
                              results.createW2KObjects,
                              String::load(IDS_RPT_CREATEW2K)
                           );
         BREAK_ON_FAILED_HRESULT(hr);

         hr=reportObjects  (
                              file,
                              results.createXPObjects,
                              String::load(IDS_RPT_CREATEXP)
                           );
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=reportContainers(
                              file,
                              results.createContainers,
                              String::load(IDS_RPT_CONTAINERS)
                            );
         BREAK_ON_FAILED_HRESULT(hr);

      } while(0);

      CloseHandle(file);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\analisys.hpp ===
#ifndef ANALISYS_HPP
#define ANALISYS_HPP




#include  "AnalisysResults.hpp"
#include  "dspecup.hpp"

class CSVDSReader;
struct sChangeList;


class Analisys
{

public:
   Analisys(   
               const             CSVDSReader& csvReader409_,
               const             CSVDSReader& csvReaderIntl_,
               const             String& ldapPrefix_,
               const             String& rootContainerDn_,
               AnalisysResults   &res,
               const String      &reportName_=L"", 
               void              *caleeStruct_=NULL,
		         progressFunction  stepIt_=NULL,
		         progressFunction  totalSteps_=NULL
            );
   

   HRESULT run();

private:
 

   const CSVDSReader& csvReader409;
   const CSVDSReader& csvReaderIntl;
   String ldapPrefix;
   String rootContainerDn;
   AnalisysResults& results;
   String reportName;
   void *caleeStruct;
   progressFunction stepIt;
   progressFunction totalSteps;
   

  
   // add entry to result.createContainers if container is not present
   // also returns flag isPresent
   HRESULT 
   dealWithContainer(
      const long  locale,
      bool        &isPresent);

   // add entries to results.conflictingXPObjects or
   // results.createXPObject as necessary
   HRESULT 
   dealWithXPObjects(const long locale);

   // add entries to results.createW2KObjects and
   // and results.objectActions as necessary
   HRESULT 
   dealWithW2KObjects(const long locale);
   
   
   // adds ordAndGuid to the property if Guid is not already there.
   HRESULT 
   addGuid
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const wchar_t        *object, 
      const wchar_t        *property, 
      const wchar_t        *ordAndGuid
   );

   // adds all csv values still not on the property
   HRESULT
   addAllCsvValues
   (
      IDirectoryObject     *iDirObj,
      const long           locale,
      const wchar_t        *object, 
      const wchar_t        *property
   );

   // adds value to the property if it is not already there. 
   HRESULT 
   addValue
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const wchar_t        *object, 
      const wchar_t        *property,
      const wchar_t        *value
   );
   

   HRESULT 
   getCsvSingleValue
   (
      const int               locale,
      const wchar_t           *object, 
      const wchar_t           *property,
      String                  &csvValue
   );

   HRESULT 
   replaceW2KSingleValue
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const wchar_t        *object, 
      const wchar_t        *property,
      const wchar_t        *value
   );

   HRESULT 
   getCsvMultipleValue
   (
      const int               locale,
      const wchar_t           *object, 
      const wchar_t           *property,
      const wchar_t           *value,
      String                  &csvValue,
      String                  &XPstart
   );


   HRESULT 
   replaceW2KMultipleValue(
      IDirectoryObject     *iDirObj,
      const int            locale,
      const wchar_t        *object, 
      const wchar_t        *property,
      const wchar_t        *value);

   
   // removes ordAndGuid from the property if Guid is there. 
   HRESULT 
   removeGuid(
      IDirectoryObject     *iDirObj,
      const int            locale,
      const wchar_t        *object, 
      const wchar_t        *property,
      const wchar_t        *ordAndGuid);

   // set previousSuccessfulRun reading from ADSI
   HRESULT 
   setPreviousSuccessfullRun();

   HRESULT 
   checkChanges
   (
      const long locale,
      const sChangeList& changes,
      IDirectoryObject     *iDirObj
   ); 


   HRESULT
   getADFirstValue
   (
      IDirectoryObject     *iDirObj,
      const String         &property,
      String               &value
   );

   HRESULT
   isADStartValuePresent
   (
      IDirectoryObject     *iDirObj,
      const String         &property,
      const String         &valueStart,
      String               &value
   );

   HRESULT
   isADValuePresent
   (
      IDirectoryObject     *iDirObj,
      const String         &property,
      const String         &value
   );

   HRESULT
   getADGuid
   (
      IDirectoryObject     *iDirObj,
      const String         &property,
      const String         &guidValue,
      String               &guidFound
   );

   HRESULT
   removeExtraneous
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property,
      const String         &keeper
   );

   HRESULT
   removeExtraneous
   (
      IDirectoryObject     *iDirObj,
      const int            locale,
      const String         &object, 
      const String         &property,
      const String         &keeper,
      const String         &start1,
      const String         &start2
   );

   HRESULT 
   reportObjects
   (
      HANDLE file,
      const ObjectIdList &list,
      const String &header
   );


   HRESULT 
   reportContainers
   (
      HANDLE file,
      const LongList &list,
      const String &header
   );

   HRESULT 
   reportActions
   (
      HANDLE file,
      const ObjectActions &list,
      const String &header
   );

   HRESULT 
   reportValues
   (
      HANDLE file,
      const SingleValueList &list,
      const String &header
   );

   HRESULT
   createReport(const String& reportName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\csvdsreader.hpp ===
#ifndef CSVDSREADER_HPP
#define CSVDSREADER_HPP

#include <comdef.h>

#include <set>
#include <map>
#include <list>


using namespace std;





typedef set < 
               pair<String,long>,
               less< pair<String,long> > ,
               Burnslib::Heap::Allocator< pair<String,long> > 
            > setOfObjects;

typedef map <  
               long,
               LARGE_INTEGER,
               less<long>,
               Burnslib::Heap::Allocator<LARGE_INTEGER>
            > mapOfOffsets;

typedef
map<  String,
      long,
      less<String>,
      Burnslib::Heap::Allocator<long>
   > mapOfPositions;


class CSVDSReader
{

   
private:
   mapOfOffsets localeOffsets;        // locale x offsets
   mapOfPositions propertyPositions;      // properties x position

   String fileName;
   HANDLE file;                              // csv file
   
   HRESULT parseProperties();

   HRESULT parseLocales(const long *locales);

   HRESULT
   parseLine(
      const wchar_t  *line, 
      const long     position,
      StringList     &values) const;

   HRESULT 
      getObjectLine(   
      const long     locale,
      const wchar_t  *object,
      String         &csvLine) const;

   HRESULT 
      writeHeader(HANDLE  fileOut) const;


public:
   CSVDSReader();
  
   // get all values from the csv
   HRESULT
   getCsvValues(
      const long     locale,
      const wchar_t  *object, 
      const wchar_t  *property,
      StringList     &values)  const;

   // gets the csv value starting with value to XPValue
   // leaves XPValue empty if did not find
   HRESULT
   getCsvValue( 
      const long     locale,
      const wchar_t  *object, 
      const wchar_t  *property,
      const String   &value,
      String         &XPValue) const;


   HRESULT
   makeLocalesCsv(
      HANDLE            fileOut,
      const long     *locales) const;


   HRESULT
   makeObjectsCsv(
      HANDLE              fileOut,
      const setOfObjects  &objects) const;


   virtual ~CSVDSReader()
   {
      if (file!=INVALID_HANDLE_VALUE) CloseHandle(file);
   }
   
   HRESULT 
   read(
         const wchar_t     *fileName,
         const long     *locales);

   const String& getFileName() const {return fileName;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\dspecup.cpp ===
#include "headers.hxx"
#include "dspecup.hpp"
#include "Analisys.hpp"
#include "repair.hpp"
#include "AnalisysResults.hpp"
#include "resource.h"
#include "CSVDSReader.hpp"
#include "constants.hpp"
#include "AdsiHelpers.hpp"



// Variables kept from analisys to repair
bool goodAnalisys=false;
AnalisysResults results;
String targetDomainControllerName;
String csvFileName,csv409Name;
CSVDSReader csvReaderIntl;
CSVDSReader csvReader409;
String rootContainerDn,ldapPrefix,domainName;





HRESULT
FindCsvFile(
            String& csvFilePath,
            String& csv409Path
           )
{
   LOG_FUNCTION(FindCsvFile);

   csvFilePath.erase();
   
   HRESULT hr = S_OK;

   do
   {
      // look for dcpromo.csv and 409.csv file in system 
      // or current directory
      

      // check the default of
      // %windir%\system32\mui\dispspec\dcpromo.csv and
      // .\dcpromo.csv

      String csvname=L"dcpromo.csv";
      
      String sys32dir = Win::GetSystemDirectory();
      String csvPath  = sys32dir + L"\\mui\\dispspec\\" + csvname;

      if (FS::FileExists(csvPath))
      {
         csvFilePath = csvPath;
      }
      else
      {
         csvPath = L".\\" + csvname;
         
         if (FS::FileExists(FS::NormalizePath(csvPath)))
         {
            csvFilePath = csvPath;
         }
         else
         {
            hr=S_FALSE;
            break;
         }
      }
      

      csvname=L"409.csv";
      csvPath  = sys32dir + L"\\mui\\dispspec\\" + csvname;
      
      if (FS::FileExists(csvPath))
      {
         csv409Path = csvPath;
      }
      else
      {
         csvPath = L".\\" + csvname;
         if (FS::FileExists(FS::NormalizePath(csvPath)))
         {
            csv409Path = csvPath;
         }
         else
         {
            hr=S_FALSE;
            break;
         }
      }
   }
   while(0);


   LOG_HRESULT(hr);
   LOG(csvFilePath);
   LOG(csv409Path);
   
   return hr;      
}


HRESULT 
InitializeADSI(
               const String   &targetDcName,
               String         &ldapPrefix,
               String         &rootContainerDn,
               String         &domainName
              )
{
   LOG_FUNCTION(InitializeADSI);

   HRESULT hr=S_OK;
   do
   {
      Computer targetDc(targetDcName);
      hr = targetDc.Refresh();

      if (FAILED(hr))
      {
         error = String::format(
               IDS_CANT_TARGET_MACHINE,
               targetDcName.c_str());
         hr=E_FAIL;
         break;
      }

      if (!targetDc.IsDomainController())
      {
         error=String::format(
               IDS_TARGET_IS_NOT_DC,
               targetDcName.c_str());
         hr=E_FAIL;
         break;
      }

      String dcName = targetDc.GetActivePhysicalFullDnsName();
      ldapPrefix = L"LDAP://" + dcName + L"/";
         
      //
      // Find the DN of the configuration container.
      // 

      // Bind to the rootDSE object.  We will keep this binding handle
      // open for the duration of the analysis and repair phases in order
      // to keep a server session open.  If we decide to pass creds to the
      // AdsiOpenObject call in a later revision, then by keeping the
      // session open we will not need to pass the password to subsequent
      // AdsiOpenObject calls.
      
      SmartInterface<IADs> rootDse;
      
      hr = AdsiOpenObject<IADs>(ldapPrefix + L"RootDSE", rootDse);
      if (FAILED(hr))
      {
         error=String::format(
               IDS_UNABLE_TO_CONNECT_TO_DC,
               dcName.c_str());
         hr=E_FAIL;
         break;      
      }
            
      // read the configuration naming context.

      _variant_t variant;
      hr =
         rootDse->Get(
            AutoBstr(LDAP_OPATT_CONFIG_NAMING_CONTEXT_W),
            &variant);
      if (FAILED(hr))
      {
         LOG(L"can't read config NC");
                  
         error=String::format(IDS_UNABLE_TO_READ_DIRECTORY_INFO);
         hr=E_FAIL;
         break;   
      }

      String configNc = V_BSTR(&variant);

      ASSERT(!configNc.empty());   
      LOG(configNc);

      wchar_t *domain=wcschr(configNc.c_str(),L',');
      ASSERT(domain!=NULL);
      domainName=domain+1;

      rootContainerDn = L"CN=DisplaySpecifiers," + configNc;
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}


HRESULT 
GetInitialInformation(  
                        String &targetDomainControllerName,
                        String &csvFilename,
                        String &csv409Name
                     )
{
   LOG_FUNCTION(GetInitialInformation);

   HRESULT hr = S_OK;
   do
   {
      
      //
      // find the dcpromo.csv file to use
      //
   
      hr = FindCsvFile(csvFilename, csv409Name);
      
      if (hr == S_FALSE)
      {
         // no error looking, just not found.
         error=String::format(IDS_DCPROMO_CSV_FILE_MISSING);
         hr=E_FAIL;
         break;   
      }
      BREAK_ON_FAILED_HRESULT(hr);

      //
      // Determine the target domain controller
      //

      if (targetDomainControllerName.empty())
      {
         // no target specified, default to the current machine
   
         targetDomainControllerName =
            Win::GetComputerNameEx(ComputerNameDnsFullyQualified);
   
         if (targetDomainControllerName.empty())
         {
            // no DNS name?  that's not right...
   
            LOG(L"no default DNS computer name found. Using netbios name.");
   
            targetDomainControllerName = 
               Win::GetComputerNameEx(ComputerNameNetBIOS);
            ASSERT(!targetDomainControllerName.empty());
         }
      }
   } 
   while (0);
   
   LOG_HRESULT(hr);
   return hr;
}


void AllocError(HRESULT &hr,PWSTR *error,const String& src)
{
   if (error==NULL) return; 
   *error=static_cast<PWSTR>(
                                 CoTaskMemAlloc
                                 (
                                    (src.size()+1)*sizeof(wchar_t)
                                 )
                            );
   if(*error==NULL)
   {
      hr = Win32ToHresult(ERROR_NOT_ENOUGH_MEMORY);
   }
   else
   {
      wcscpy(*error,src.c_str());
   }
   return;
}


HRESULT 
RunAnalisys
(
		PWSTR *errorMsg/*=NULL*/,
		void *caleeStruct/*=NULL*/,
		progressFunction stepIt/*=NULL*/,
		progressFunction totalSteps/*=NULL*/
)
{
   LOG_FUNCTION(RunAnalisys);
   HRESULT hr=S_OK;

   goodAnalisys=false;
   results.createContainers.clear();
   results.conflictingXPObjects.clear();
   results.createXPObjects.clear();
   results.createW2KObjects.clear();
   results.objectActions.clear();
   results.customizedValues.clear();
   results.extraneousValues.clear();

   do
   {

      hr=GetInitialInformation(
                                 targetDomainControllerName,
                                 csvFileName,
                                 csv409Name
                              );

      BREAK_ON_FAILED_HRESULT(hr);

      hr=csvReaderIntl.read(csvFileName.c_str(),LOCALEIDS);
      BREAK_ON_FAILED_HRESULT(hr);
   
      hr=csvReader409.read(csv409Name.c_str(),LOCALE409);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=InitializeADSI(
            targetDomainControllerName,
            ldapPrefix,
            rootContainerDn,
            domainName);
      BREAK_ON_FAILED_HRESULT(hr);

      String reportName;

      hr=GetWorkFileName(
                           String::load(IDS_FILE_NAME_REPORT),
                           L"txt",
                           reportName
                        );
      BREAK_ON_FAILED_HRESULT(hr);


      Analisys analisys(
                           csvReader409, 
                           csvReaderIntl,
                           ldapPrefix,
                           rootContainerDn,
                           results,
                           reportName,
                           caleeStruct,
                           stepIt,
                           totalSteps
                        );
   
      hr=analisys.run();
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   if(FAILED(hr))
   {
      AllocError(hr,errorMsg,error);
   }
   else
   {
      goodAnalisys=true;
   }


   LOG_HRESULT(hr);
   return hr;

}




HRESULT 
RunRepair 
(
		PWSTR *errorMsg/*=NULL*/,
		void *caleeStruct/*=NULL*/,
		progressFunction stepIt/*=NULL*/,
		progressFunction totalSteps/*=NULL*/
)
{
   LOG_FUNCTION(RunRepair);
   HRESULT hr=S_OK;
   do
   {
      if (!goodAnalisys)
      {
         hr=E_FAIL;
         AllocError(hr,errorMsg,String::load(IDS_NO_ANALISYS));
         break;
      }

      String ldiffName;

      hr=GetWorkFileName(
                           String::load(IDS_FILE_NAME_LDIF_ACTIONS),
                           L"ldf",
                           ldiffName
                        );
      BREAK_ON_FAILED_HRESULT(hr);

      String csvName;

      hr=GetWorkFileName(
                           String::load(IDS_FILE_NAME_CSV_ACTIONS),
                           L"csv",
                           csvName
                        );
      BREAK_ON_FAILED_HRESULT(hr);
   
      String saveName;

      hr=GetWorkFileName(
                           String::load(IDS_FILE_NAME_UNDO),
                           L"ldf",
                           saveName
                        );

      BREAK_ON_FAILED_HRESULT(hr);

      String logPath;

      hr=GetMyDocuments(logPath);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));

      Repair repair
      (
         csvReader409, 
         csvReaderIntl,
         domainName,
         rootContainerDn,
         results,
         ldiffName,
         csvName,
         saveName,
         logPath,
         caleeStruct,
         stepIt,
         totalSteps
       );

      hr=repair.run();
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   if(FAILED(hr))
   {
      AllocError(hr,errorMsg,error);
   }

   LOG_HRESULT(hr);
   return hr;
}

HRESULT 
UpgradeDisplaySpecifiers 
(
		BOOL dryRun,
		PWSTR *errorMsg/*=NULL*/,
		void *caleeStruct/*=NULL*/,
		progressFunction stepIt/*=NULL*/,
		progressFunction totalSteps/*=NULL*/
)
{
   LOG_FUNCTION(UpgradeDisplaySpecifiers);
   HRESULT hr=S_OK;
   do
   {
      hr=RunAnalisys(errorMsg,caleeStruct,stepIt,totalSteps);
      BREAK_ON_FAILED_HRESULT(hr);

      if(dryRun==false)
      {
         hr=RunRepair(errorMsg,caleeStruct,stepIt,totalSteps);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\dspecup.hpp ===
#ifndef DSPECUP_HPP
#define DSPECUP_HPP


typedef void (*progressFunction)(long arg, void *calleeStruct);

HRESULT 
UpgradeDisplaySpecifiers 
(
		BOOL dryRun,
		PWSTR *errorMsg=NULL,
		void *caleeStruct=NULL,
		progressFunction stepIt=NULL,
		progressFunction totalSteps=NULL
);


HRESULT 
RunAnalisys 
(
		PWSTR *errorMsg=NULL,
		void *caleeStruct=NULL,
		progressFunction stepIt=NULL,
		progressFunction totalSteps=NULL
);

HRESULT 
RunRepair 
(
		PWSTR *errorMsg=NULL,
		void *caleeStruct=NULL,
		progressFunction stepIt=NULL,
		progressFunction totalSteps=NULL
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\adsihelpers.hpp ===
// ADSI Helper functions
//
// Copyright (c) 2001 Microsoft Corporation
//
// 1 Mar 2001 sburns



#ifndef ADSIHELPERS_HPP_INCLUDED
#define ADSIHELPERS_HPP_INCLUDED



// CODEWORK: consider putting this, and some of the more general purpose
// adsi goodies from admin\snapin\localsec\src\adsi.hpp|.cpp into an
// adsi header in burnslib.



// Template function that actually calls ADsOpenObject.
//
// Interface - The IADsXXX interface of the object to be bound.
//
// path - in, The ADSI path of the object to be bound.
//
// ptr - out, A null smart pointer to be bound to the interface of the object.

template <class Interface>
HRESULT
AdsiOpenObject(
   const String&              path,
   SmartInterface<Interface>& ptr)
{
   LOG_FUNCTION2(AdsiOpenObject, path);
   ASSERT(!path.empty());

   Interface* p = 0;
   HRESULT hr =
      ::ADsOpenObject(
         path.c_str(),
         0,
         0,
         ADS_SECURE_AUTHENTICATION,         
         __uuidof(Interface),
         reinterpret_cast<void**>(&p));
   if (SUCCEEDED(hr))
   {
      ptr.Acquire(p);
   }

   LOG_HRESULT(hr);
   
   return hr;
}



#endif   // ADSIHELPERS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDB_WATERMARK256                110
#define IDB_BANNER256                   111
#define IDB_WATERMARK16                 112
#define IDB_BANNER16                    113
#define IDD_WELCOME                     115
#define IDD_ANALISYS                    116
#define IDD_UPDATES_REQUIRED            117
#define IDD_UPDATES                     118
#define IDI_BIG_WARN                    119
#define IDD_FINISH                      119
#define IDC_TEST                        1000
#define IDC_BIG_BOLD_TITLE              1001
#define IDC_PROGRESS_ANALISYS           1001
#define IDC_INTRO1                      1002
#define IDC_ANALISYS_COMPLETE           1002
#define IDC_ANALISYS_RESULT             1002
#define IDC_INTRO2                      1003
#define IDC_DELETE_OBJECTS              1003
#define IDC_CREATE_OBJECTS              1004
#define IDC_UPDATE_OBJECTS              1005
#define IDC_VIEW_DETAILS                1007
#define IDC_UPDATE_COMPLETE             1008
#define IDC_OPEN_LOG                    1009
#define IDC_FILE                        1009
#define IDC_RESTART                     1010
#define IDC_RESULT                      1011
#define IDC_LOG                         1012
#define IDC_CLICK                       1012
#define IDC_PROGRESS_REPAIR             1017
#define IDC_BULLET1                     1035
#define IDC_BULLET2                     1036
#define IDC_BULLET3                     1037
#define IDS_APP_TITLE                   1501
#define IDS_CANT_TARGET_MACHINE         1502
#define IDS_DCPROMO_CSV_FILE_MISSING    1503
#define IDS_ERROR_LOOKING_FOR_CSV_FILE  1504
#define IDS_TARGET_IS_NOT_DC            1505
#define IDS_UNABLE_TO_CONNECT_TO_DC     1506
#define IDS_UNABLE_TO_READ_DIRECTORY_INFO 1507
#define IDS_ERROR_BINDING_TO_OBJECT     1508
#define IDS_ERROR_ENTRY                 1509
#define IDS_ERROR_GETING_FILE_NAME      1510
#define IDS_INVALID_CSV_UNICODE_ID      1511
#define IDS_MISSING_LOCALES             1512
#define IDS_OBJECT_NOT_FOUND_IN_CSV     1513
#define IDS_PROPERTY_NOT_FOUND_IN_CSV   1514
#define IDS_QUOTES_NOT_CLOSED           1515
#define IDS_COULD_NOT_CREATE_CSV        1516
#define IDS_NO_COMA_IN_CSV_LINE         1517
#define IDS_NO_CSV_VALUE                1518
#define IDS_ERROR_BINDING_TO_CONTAINER  1519
#define IDS_COULD_NOT_START_EXE         1521
#define IDS_EXE_NOT_FOUND               1522
#define IDS_NO_WORK_PATH                1524
#define IDS_ERROR_IMP_EXP_FILE          1525
#define IDS_COULD_NOT_CREATE_FILE       1526
#define IDS_NO_DOMAIN                   1527
#define IDS_WELCOME_PAGE_TITLE          1529
#define IDS_WELCOME_PAGE_SUBTITLE       1530
#define IDS_WIZARD_TITLE                1531
#define IDS_BIG_BOLD_FONT_NAME          1532
#define IDS_BIG_BOLD_FONT_SIZE          1533
#define IDS_ANALISYS_PAGE_TITLE         1534
#define IDS_ANALISYS_PAGE_SUBTITLE      1535
#define IDS_IDC_ANALISYS_COMPLETE       1536
#define IDS_UPDATES_REQUIRED_TITLE      1537
#define IDS_UPDATES_REQUIRED_SUBTITLE   1538
#define IDS_IDC_LOG_DETAILS             1539
#define IDS_IDC_LOG_ERRORS              1540
#define IDS_IDC_RESULT_SUCCESS          1541
#define IDS_IDC_RESULT_FAILURE          1542
#define IDS_UPDATES_REQUIRED_PAGE_TITLE 1543
#define IDS_UPDATES_REQUIRED_PAGE_SUBTITLE 1544
#define IDS_CREATE                      1545
#define IDS_UPDATE                      1546
#define IDS_DELETE                      1547
#define IDS_OBJECTS                     1548
#define IDS_FINISH_PAGE_SUBTITLE        1549
#define IDS_FINISH_PAGE_TITLE           1550
#define IDS_UPDATES_PAGE_TITLE          1551
#define IDS_UPDATES_PAGE_SUBTITLE       1552
#define IDS_CONTAINERS                  1553
#define IDS_AND                         1554
#define IDS_CREATED_FORMAT              1555
#define IDS_NUMBER_FORMAT               1556
#define IDS_VALUES                      1557
#define IDS_RPT_OBJECT_FORMAT           1558
#define IDS_RPT_CONTAINER_FORMAT        1559
#define IDS_RPT_ADD_VALUE_FORMAT        1560
#define IDS_RPT_DEL_VALUE_FORMAT        1561
#define IDS_RPT_CONFLICTINGXP           1563
#define IDS_RPT_ACTIONS                 1564
#define IDS_RPT_CREATEW2K               1565
#define IDS_RPT_CREATEXP                1566
#define IDS_RPT_CONTAINERS              1567
#define IDS_RPT_HEADER                  1568
#define IDS_CSVDE_LDIFDE_ERROR_COMPLETE 1569
#define IDS_CSVDE_LDIFDE_ERROR_BASIC    1570
#define IDS_IDC_ANALISYS_RESULT_INCOMPLETE 1571
#define IDS_IDC_ANALISYS_RESULT_COMPLETE 1572
#define IDS_ANALISYS_ERROR              1573
#define IDS_REPAIR_ERROR                1574
#define IDS_IDC_CLICK_SUCCESS           1575
#define IDS_IDC_CLICK_FAILURE           1576
#define IDC_RESULT_SUCCESS              1577
#define IDS_ALREADY_UPDATED             1578
#define IDS_USAGE                       1579
#define IDS_NOUI                        1580
#define IDS_ALREADY_RUNNING             1581
#define IDS_VALUE_NOT_IN_CSV            1582
#define IDS_NO_VALUE_IN_CSV             1583
#define IDS_MANY_CSV_VALUES             1584
#define IDS_CANT_WRITE_OBJECT_VERSION   1585
#define IDS_CANT_READ_OBJECT_VERSION    1586
#define IDS_NOT_ONE_CSV_VALUE           1587
#define IDS_RPT_CUSTOMIZED              1588
#define IDS_RPT_EXTRANEOUS              1589
#define IDS_RPT_VALUE_FORMAT            1590
#define IDS_NO_ANALISYS                 1591
#define IDS_OUT_OF_MEMORY               1592
#define IDS_FILE_NAME_UNDO              1593
#define IDS_FILE_NAME_REPORT            1594
#define IDS_FILE_NAME_CSV_ACTIONS       1595
#define IDS_FILE_NAME_LDIF_ACTIONS      1596
#define IDS_FILE_NAME_CSV_ERROR         1597
#define IDS_FILE_NAME_CSV_LOG           1598
#define IDS_FILE_NAME_LDIF_ERROR        1599
#define IDS_FILE_NAME_LDIF_LOG          1600
#define IDS_NO_ERROR_FILE               1601
#define IDS_EXPORTING                   1602
#define IDS_IMPORTING                   1603

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\global.hpp ===
#ifndef GLOBAL_HPP
#define GLOBAL_HPP

using namespace std;

String unEscape(const String &str);

extern String error;

// The variable bellow was created to share the error hresult
// between UI classes
extern HRESULT hrError;

#define BREAK_ON_FAILED_HRESULT_ERROR(hr,error_) \
if (FAILED(hr))                     \
{                                   \
   error=error_; 				         \
   break;                           \
}

typedef list <
               long,
               Burnslib::Heap::Allocator<long>
             > LongList;


////////////////////////

// Used in ReadLine
#define EOF_HRESULT Win32ToHresult(ERROR_HANDLE_EOF) 

// Used in WinGetVLFilePointer. Declared in global.cpp as ={0};
extern LARGE_INTEGER zero;

// Used in CSVDSReader and ReadLine
#define WinGetVLFilePointer(hFile, lpPositionHigh) \
         Win::SetFilePointerEx(hFile, zero, lpPositionHigh, FILE_CURRENT)

HRESULT
ReadLine(HANDLE handle, 
         String& text,
         bool *endLineFound_=NULL);

HRESULT 
ReadAllFile(const String &fileName,
            String &file);

HRESULT
GetMyDocuments(String &myDoc);

// Retrieves a unique temporary name
HRESULT 
GetWorkTempFileName
(
   const wchar_t     *lpPrefixString,
   String            &name
);


// Retrieves a unique file name
HRESULT 
GetWorkFileName
(
   const String&     baseName,
   const wchar_t     *extension,
   String            &name
);

void 
ShowError(HRESULT hr,
          const String &message);

HRESULT 
Notepad(const String& file);

HRESULT 
GetPreviousSuccessfullRun(
                           const String &ldapPrefix,
                           const String &rootContainerDn,
                           bool &result
                         );
HRESULT 
SetPreviousSuccessfullRun(
                           const String &ldapPrefix,
                           const String &rootContainerDn
                         );


HRESULT 
getADLargeInteger(
                   IDirectoryObject *iDirObj,
                   wchar_t *name,
                   ADS_LARGE_INTEGER &value
                 );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\global.cpp ===
#include "headers.hxx"
#include "global.hpp"
#include "resource.h"
#include "AdsiHelpers.hpp"

String error;
HRESULT hrError=S_OK;


#define H(X) (\
                  (X>='a')?\
                  (\
                     (X-'a'+10)\
                  ):\
                  (\
                     (X>='A')?(X-'A'+10):(X-'0') \
                  )\
             )\



// Converts && to & and &xxxx to the coresponding digit
// There is no error checking. This function
// suposes the string is correctly escaped
// The escape function is in the folder preBuild as a part
// of the W2KStrs tool.
String unEscape(const String &str)
{
   LOG_FUNCTION(unEscape);
   String dest;
   String::const_iterator c=str.begin();
   String::const_iterator end=str.end();
   while(c!=end)
   {
      if(*c=='&') 
      {
         c++;
         if(*c=='&')
         {
            dest+=L'&';
         }
         else
         {
            wchar_t sTmp[2];
            sTmp[0]= static_cast<wchar_t> (
                                             (H(*c)<<12)+
                                             (H(*(c+1))<<8)+
                                             (H(*(c+2))<<4)+
                                             H(*(c+3)) 
                                          );
            sTmp[1]=0;
            dest+=sTmp;
            c+=3;
         }
      }
      else
      {
         dest+=*c;
      }
      c++;
   }
   return dest;
}

// Used in WinGetVLFilePointer.
LARGE_INTEGER zero={0};

//////////////// ReadLine 
#define CHUNK_SIZE 100

HRESULT
ReadLine(HANDLE handle, 
         String& text,
         bool *endLineFound_/*=NULL*/)
{
   LOG_FUNCTION(ReadLine); 
   ASSERT(handle != INVALID_HANDLE_VALUE);
   
   bool endLineFound=false;
   
   text.erase();
   
   // Acumulating chars read on text would cause the same
   // kind of reallocation and copy that text+=chunk will
   static wchar_t chunk[CHUNK_SIZE+1];
   HRESULT hr=S_OK;
   bool flagEof=false;
   
   do
   {
      LARGE_INTEGER pos;
      
      hr = WinGetVLFilePointer(handle,&pos);
      BREAK_ON_FAILED_HRESULT(hr);
      
      long nChunks=0;
      wchar_t *csr=NULL;
      
      while(!flagEof && !endLineFound)
      {
         DWORD bytesRead;
         
         hr = Win::ReadFile(
            handle,
            chunk,
            CHUNK_SIZE*sizeof(wchar_t),
            bytesRead,
            0);
         
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         
         BREAK_ON_FAILED_HRESULT(hr);

         if(bytesRead==0)
         {
            flagEof=true;
         }
         else
         {
         
            *(chunk+bytesRead/sizeof(wchar_t))=0;
         
            csr=wcschr(chunk,L'\n');
         
            if(csr!=NULL)
            {
               pos.QuadPart+= sizeof(wchar_t)*
                  ((nChunks * CHUNK_SIZE) + (csr - chunk)+1);
               hr=Win::SetFilePointerEx(
                  handle,
                  pos,
                  0,
                  FILE_BEGIN);
            
               BREAK_ON_FAILED_HRESULT(hr);
            
               *csr=0;
               endLineFound=true;
            }
         
            text+=chunk;
            nChunks++;
         }
      }
      
      BREAK_ON_FAILED_HRESULT(hr);

      //We know the length will fit in a long
      // and we want IA64 to build.
      long textLen=static_cast<long>(text.length());

      if(textLen!=0 && endLineFound && text[textLen-1]==L'\r')
      {
         text.erase(textLen-1,1);
      }
   
      if(endLineFound_ != NULL)
      {
         *endLineFound_=endLineFound;
      }

      if(flagEof)
      {
         hr=EOF_HRESULT;
      }
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}



//////////////// ReadLine 

HRESULT 
ReadAllFile(const String &fileName,
            String &fileStr)
{
   LOG_FUNCTION(ReadAllFile);

   HRESULT hr=S_OK;

   fileStr.erase();
   
   HANDLE file;
   hr=FS::CreateFile(fileName,
               file,
               GENERIC_READ);
   
   if(FAILED(hr))
   {
      error=fileName;
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      bool flagEof=false;
      while(!flagEof)
      {
         String line;
         hr=ReadLine(file,line);
         if(hr==EOF_HRESULT)
         {
            hr=S_OK;
            flagEof=true;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         fileStr+=line+L"\r\n";
      }
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
   } while(0);

   if ( (fileStr.size() > 0) && (fileStr[0] == 0xfeff) )
   {
      fileStr.erase(0,1);
   }

   CloseHandle(file);

   LOG_HRESULT(hr);
   return hr;   
}


HRESULT
GetMyDocuments(String &myDoc)
{
   LOG_FUNCTION(GetMyDocuments);

   LPMALLOC pMalloc;
   HRESULT hr=S_OK;
   
   do //whoever breaks will go to return hr
   {
      hr=Win::SHGetMalloc(pMalloc);
      BREAK_ON_FAILED_HRESULT(hr);

      do // whoever breaks will go to pMalloc->Release();
      {
         LPITEMIDLIST pidl;
         hr=Win::SHGetSpecialFolderLocation(
                                             Win::GetDesktopWindow(),
                                             CSIDL_PERSONAL,
                                             pidl
                                           );
         BREAK_ON_FAILED_HRESULT(hr);

         myDoc=Win::SHGetPathFromIDList(pidl);
         if(myDoc.empty() || !FS::PathExists(myDoc))
         {
            hr=E_FAIL; // don't break to free pidl
         }

         pMalloc->Free(pidl);

      } while(0);

      pMalloc->Release();

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT
GetTempFileName
(  
  const wchar_t   *lpPathName,      // directory name
  const wchar_t   *lpPrefixString,  // file name prefix
  String          &name             // file name 
)
{
   LOG_FUNCTION(GetTempFileName);

   ASSERT(FS::PathExists(lpPathName));

   HRESULT hr=S_OK;
   do
   {
      if (!FS::PathExists(lpPathName))
      {
         hr=Win32ToHresult(ERROR_FILE_NOT_FOUND);
         error=lpPathName;
         break;
      }

      DWORD result;
      wchar_t lpName[MAX_PATH]={0};

      result=::GetTempFileName(lpPathName,lpPrefixString,0,lpName);
      
      if (result == 0) 
      {
         hr = Win::GetLastErrorAsHresult();
         error=lpPathName;
         break;
      }

      name=lpName;

      if(FS::FileExists(name))
      {
         // GetTempFilename actually created the file !
         hr=Win::DeleteFile(lpName); 
         BREAK_ON_FAILED_HRESULT_ERROR(hr,name);
      }

   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}

// Retrieves a unique temporary file name
HRESULT 
GetWorkTempFileName
(
   const wchar_t     *lpPrefixString,
   String            &name
)
{
   LOG_FUNCTION(GetWorkTempFileName);

   HRESULT hr=S_OK;
   String path;
   do
   {
      hr=GetMyDocuments(path);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));

      hr=GetTempFileName(path.c_str(),lpPrefixString,name);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}



// locate the file with the highest-numbered extension, then add 1 and
// return the result.
int
DetermineNextFileNumber
(
   const String&     dir,
   const String&     baseName,
   const wchar_t     extension[4]
)
{
   LOG_FUNCTION(DetermineNextFileNumber);
   ASSERT(!dir.empty());
   ASSERT(!baseName.empty());

   int largest = 0;

   String filespec = dir + L"\\" + baseName + L".*."+ extension;

   WIN32_FIND_DATA findData;
   HANDLE ff = ::FindFirstFile(filespec.c_str(), &findData);

   if (ff != INVALID_HANDLE_VALUE)
   {
      for (;;)
      {
         String current = findData.cFileName;

         // grab the text between the dots: "nnn" in foo.nnn.ext

         // first dot

         size_t pos = current.find(L".");
         if (pos == String::npos)
         {
            continue;
         }

         String extension = current.substr(pos + 1);

         // second dot

         pos = extension.find(L".");
         if (pos == String::npos)
         {
            continue;
         }
   
         extension = extension.substr(0, pos);

         int i = 0;
         extension.convert(i);
         largest = max(i, largest);

         if (!::FindNextFile(ff, &findData))
         {
            BOOL success = ::FindClose(ff);
            ASSERT(success);

            break;
         }
      }
   }

   // roll over after 255
   
   return (++largest & 0xFF);
}

// auxiliary in GetWorkFileName
void 
GetFileName
(
   const String&     dir,
   const String&     baseName,
   const wchar_t     extension[4],
   String            &fileName
)
{
   LOG_FUNCTION(GetFileName);
   int logNumber = DetermineNextFileNumber(dir,baseName,extension);
   fileName = dir
               +  L"\\"
               +  baseName
               +  String::format(L".%1!03d!.", logNumber)
               +  extension;

   if (::GetFileAttributes(fileName.c_str()) != 0xFFFFFFFF)
   {
      // could exist, as the file numbers roll over

      BOOL success = ::DeleteFile(fileName.c_str());
      ASSERT(success);
   }
}



// Retrieves a unique file name
HRESULT 
GetWorkFileName
(
   const String&     baseName,
   const wchar_t     *extension,
   String            &name
)
{
   LOG_FUNCTION(GetWorkFileName);

   HRESULT hr=S_OK;
   String path;
   do
   {
      hr=GetMyDocuments(path);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));
      GetFileName(path.c_str(),baseName,extension,name);
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}


HRESULT 
Notepad(const String& file)
{
   LOG_FUNCTION(Notepad);
   HRESULT hr=S_OK;
   do
   {
      STARTUPINFO si;
	   PROCESS_INFORMATION pi;
	   GetStartupInfo(&si);

      String curDir = L"";
      String prg = L"notepad " + file;

      hr=Win::CreateProcess
        (
            prg,
            NULL,    // lpProcessAttributes
            NULL,    // lpThreadAttributes
            false,   // dwCreationFlags 
            NORMAL_PRIORITY_CLASS,// fdwCreate 
            NULL,    // lpEnvironment 
            curDir,  // lpEnvironment 
		      si,     // [in] lpStartupInfo 
            pi      // [out] pProcessInformation
        );
      BREAK_ON_FAILED_HRESULT_ERROR(hr,
         String::format(IDS_COULD_NOT_START_EXE,L"notepad"));

      CloseHandle(pi.hProcess);
      CloseHandle(pi.hThread);
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT 
GetPreviousSuccessfullRun(
                           const String &ldapPrefix,
                           const String &rootContainerDn,
                           bool &result
                         )
{
   LOG_FUNCTION(GetPreviousSuccessfullRun);

   ASSERT(!ldapPrefix.empty());
   ASSERT(!rootContainerDn.empty());

   HRESULT hr = S_OK;
   result=false;

   do
   {
      String objectPath = ldapPrefix + rootContainerDn;
      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(objectPath, iads);

      BREAK_ON_FAILED_HRESULT(hr);

      _variant_t variant;

      hr = iads->Get(AutoBstr(L"objectVersion"), &variant);
      if(hr==E_ADS_PROPERTY_NOT_FOUND)
      {
         result=false;
         hr=S_OK;
         break;
      }
      else if (FAILED(hr))
      {
         hr=E_FAIL;
         error=String::format(IDS_CANT_READ_OBJECT_VERSION);
         break;
      }

      result = (variant.lVal==1);

   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT 
SetPreviousSuccessfullRun(
                           const String &ldapPrefix,
                           const String &rootContainerDn
                         )
{
   LOG_FUNCTION(SetPreviousSuccessfullRun);

   ASSERT(!ldapPrefix.empty());
   ASSERT(!rootContainerDn.empty());


   HRESULT hr = S_OK;

   do
   {
      String objectPath = ldapPrefix + rootContainerDn;
      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(objectPath, iads);
      BREAK_ON_FAILED_HRESULT(hr);
      _variant_t variant(1L);
      hr = iads->Put(AutoBstr(L"objectVersion"), variant);
      BREAK_ON_FAILED_HRESULT(hr);
      hr = iads->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      hr=E_FAIL;
      error=String::format(IDS_CANT_WRITE_OBJECT_VERSION);
   }

   LOG_HRESULT(hr);
   return hr;
}

HRESULT 
getADLargeInteger(
       IDirectoryObject *iDirObj,
       wchar_t *name,
       ADS_LARGE_INTEGER &value)
{
   LOG_FUNCTION(getADLargeInteger);
   HRESULT hr=S_OK;
   do
   {
      LPWSTR nameArray[]={name};
      DWORD nAttr;
      PADS_ATTR_INFO attr;
      hr = iDirObj->GetObjectAttributes(nameArray,1,&attr,&nAttr);
      BREAK_ON_FAILED_HRESULT(hr);
      value=attr->pADsValues->LargeInteger;
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\prebuild\w2kstrs.cpp ===
#include "headers.hxx"
#include "..\CSVDSReader.hpp"
#include "..\constants.hpp"
#include "..\global.hpp"

HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available

const wchar_t* RUNTIME_NAME = L"W2KStrs";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;

Popup popup(L"W2KStrs", false);

// Keep all printable characters and escape the others.
// Escaping means representing the character as &xxxx
// where the x is an hexadecimal digit
// This routine also replaces & for &&
// The unescape function is in ..\global.cpp
String escape(const wchar_t *str)
{
   LOG_FUNCTION(escape);
   String dest;
   wchar_t strNum[5];

   while(*str!=0)
   {
      if(*str=='&') 
      {
         dest+=L"&&";
      }
      else
      {
         if (
               (*str >= L'a' && *str <= L'z') ||
               (*str >= L'A' && *str <= L'Z') ||
               (*str >= L'0' && *str <= L'9') ||
               wcschr(L" !@#$%^*()-_=+[{]}\"';:.>,</?\\|",*str)!=NULL
            )
         {
            dest+=*str;
         }
         else
         {
            // I know that a w_char as a string will have
            // exactly 4 hexadecimal digits, so this is one of
            // the very rare wsprintfs that can be considered safe :)
            wsprintf(strNum,L"&%04x",*str);
            dest+=String(strNum);
         }
      }
      str++;
   }
   return dest;
}




int WINAPI
WinMain(
   HINSTANCE   /*hInstance*/,
   HINSTANCE   /*hPrevInstance */ ,
   LPSTR       /*lpszCmdLine, */,
   int         /*nCmdShow */)
{
   LOG_FUNCTION(WinMain);

   
   int argv;
   LPWSTR *argc=CommandLineToArgvW(GetCommandLine(),&argv);

   if(argv!=3)
   {
      MessageBox(NULL,L"Usage: W2KStrs dcpromo2k.csv out.txt",L"Error",MB_OK);
      return 0;
   }
   

   HRESULT hr=S_OK;
   HANDLE file=INVALID_HANDLE_VALUE;
   const wchar_t *W2KFile =argc[1];
   const wchar_t *outFile =argc[2];

   do
   {
   
      CSVDSReader csvIntlW2K;
      hr=csvIntlW2K.read(W2KFile,LOCALEIDS);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=FS::CreateFile(   outFile,
                           file,
                           GENERIC_WRITE);
   
      if FAILED(hr)
      {
         MessageBox(NULL,L"Problems during generation",L"Error",MB_OK);
         LOG_HRESULT(hr);
         return hr;
      }

      for(long l=0;LOCALEIDS[l]!=0;l++)
      {
         for(  long i = 0;
               *(CHANGE_LIST[i].object)!=0; 
               i++)
         {
            wchar_t *object = CHANGE_LIST[i].object;
         
         
            for(  long c = 0; 
                  *(CHANGE_LIST[i].changes[c].property)!=0; 
                  c++)
            {
               enum TYPE_OF_CHANGE type;
               type = CHANGE_LIST[i].changes[c].type;
               
               if(
                     type == REPLACE_W2K_SINGLE_VALUE    ||
                     type == REPLACE_W2K_MULTIPLE_VALUE
                 )
               {
                  
                  wchar_t *property = CHANGE_LIST[i].changes[c].property;
                  wchar_t *value = CHANGE_LIST[i].changes[c].value;
                  long locale = LOCALEIDS[l];
                  String W2KValue;

                  // The goal of if and else is getting the W2KValue
                  if(type==REPLACE_W2K_SINGLE_VALUE)
                  {
                     StringList valuesW2K;
                     hr=csvIntlW2K.getCsvValues(locale,object,property,valuesW2K);
                     BREAK_ON_FAILED_HRESULT(hr);

                     if(valuesW2K.size()==0)
                     {
                        error=L"No values";
                        hr=E_FAIL;
                        break;
                     }

                     if (valuesW2K.size()!=1)
                     {
                        error=L"Size should be 1";
                        hr=E_FAIL;
                        break;
                     }

                     W2KValue=*valuesW2K.begin();
                  }
                  else
                  {
                     // type == REPLACE_W2K_MULTIPLE_VALUE
                     String sW2KXP(value+2); // +2 for index and comma
                     StringList lW2KXP;
                     size_t cnt=sW2KXP.tokenize(back_inserter(lW2KXP),L";");
                     if(cnt!=2)
                     {
                        error=L"There should be two strings (W2K and XP)";
                        hr=E_FAIL;
                        break;
                     }
                     
                     hr=csvIntlW2K.getCsvValue(
                                                locale,
                                                object,
                                                property,
                                                lW2KXP.begin()->c_str(),
                                                W2KValue
                                              );

                     BREAK_ON_FAILED_HRESULT(hr);

                     if(W2KValue.size()==0)
                     {
                        error=L"Did not find value(s)",L"Error";
                        hr=E_FAIL;
                        break;
                     }

                     size_t pos=W2KValue.find(L',');
                     
                     if(pos==String::npos)
                     {
                        error=L"MultipleValue without comma",L"Error";
                        hr=E_FAIL;
                        break;
                     }

                  }
                  // by now the W2KValue is loaded

                  // The test sequence 
                  // This test sequence is usefull when you already have
                  // replaceW2KStrs from a previous run and you want to 
                  // test that the strings have been correctly
                  // retrieved, encoded and decoded
                  //pair<long,long> tmpIndxLoc;
                  //tmpIndxLoc.first=index;
                  //tmpIndxLoc.second=locale;
                  //String tmpValue=replaceW2KStrs[tmpIndxLoc];
                  //if (tmpValue!=W2KValue)
                  //{
                     //hr=E_FAIL;
                     //break;
                  //}

                  long index = *value;

                  hr=FS::WriteLine(file,
                  String::format(L"tmpIndxLoc.first=%1!d!;",index));
                  BREAK_ON_FAILED_HRESULT(hr);

                  hr=FS::WriteLine(file,
                     String::format(L"tmpIndxLoc.second=0x%1!3x!;",locale));
                  BREAK_ON_FAILED_HRESULT(hr);
               
                  hr=FS::Write
                     (
                         file,
                         String::format
                         (
                            L"replaceW2KStrs[tmpIndxLoc]=L\"%1\";\r\n",
                            escape( W2KValue.c_str() ).c_str()
                         )
                     );
                    
                  BREAK_ON_FAILED_HRESULT(hr);
               } // if(changes[c].change== is REPLACE multiple or single
            } // for c (for each change in the entry)
            BREAK_ON_FAILED_HRESULT(hr);
         }// for i (for each entry in the change list)
         BREAK_ON_FAILED_HRESULT(hr);
      }// for l (for each locale)
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   CloseHandle(file);

   if (FAILED(hr))
   {
      MessageBox(NULL,L"Problems during generation",L"Error",MB_OK);
   }
   else
   {
      MessageBox(NULL,L"Generation Successfull",L"Success",MB_OK);
   }

   LOG_HRESULT(hr);
   return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\repair.cpp ===
#include "headers.hxx"


#include "repair.hpp"
#include "CSVDSReader.hpp"
#include "resource.h"



Repair::Repair
   (
      const CSVDSReader&   csvReader409_,
      const CSVDSReader&   csvReaderIntl_,
      const String&        domain_,
      const String&        rootContainerDn_,
      AnalisysResults&     res,
      const String&        ldiffName_,
      const String&        csvName_,
      const String&        saveName_,
      const String&        logPath_,
      void                 *caleeStruct_/*=NULL*/,
		progressFunction     stepIt_/*=NULL*/,
		progressFunction     totalSteps_/*=NULL*/
   )
   :
   results(res),
   domain(domain_),
   rootContainerDn(rootContainerDn_),
   csvReader409(csvReader409_),
   csvReaderIntl(csvReaderIntl_),
   ldiffName(ldiffName_),
   csvName(csvName_),
   saveName(saveName_),
   logPath(logPath_),
   caleeStruct(caleeStruct_),
   stepIt(stepIt_),
   totalSteps(totalSteps_)
{
   LOG_CTOR(Repair);
   ASSERT(!domain.empty());
   ASSERT(!rootContainerDn.empty());
   ASSERT(!ldiffName.empty());
   ASSERT(!csvName.empty());
   ASSERT(!saveName.empty());
   ASSERT(!logPath.empty());
};


void Repair::setProgress()
{
   // We know the numbers bellow will fit in a long
   // and we want IA64 to build
   csvActions = static_cast<long>
                (
                  results.createContainers.size() +
                  results.createW2KObjects.size() +
                  results.createXPObjects.size()
                );
                     

   
   ldiffActions = static_cast<long>
                  (
                     results.objectActions.size() + 
                     results.extraneousValues.size()
                  );



   // We have three main tasks: 
   //   1) building the csv and ldif files to make the changes
   //        (buildCsv, buildChangeLdif)
   //   2) saving the ldif files with objects that will change
   //        (buildSaveLdif)
   //   3) running the csv and ldif files that will actually make
   //          the changes 
   //       (runCsvOrLdif for the buildCsv and buildChangeLdif files)
   // For simplification, The two first tasks will be half of
   // the total work and the the last will be the other half.
   //
   // For task 1, each csv action takes 10 times an ldiff action.
   //
   // Each task 2 action is an ldif export that will be supposed
   // to take 5 times more than an ldif import, since it has to
   // call ldiffde to get each object.
   //
   // The total progress for 1) is 
   //    t1=csvActions*10 + ldiffActions
   // The progress for 2) is t2=5*ldiffActions
   // The progress for 3) is a proportional division of
   //    t1+t2 between csvActions and ldiffActions that will add
   //    up to t1
   //    t3 =  (t1+t2)*csvActions/(csvactions+ldiffActions) +
   //          (t1+t2)*ldiffActions/(csvactions+ldiffActions)

   if(csvActions + ldiffActions == 0)
   {
      // We don't want to update the page if there are no
      // actions
      totalSteps=NULL;
      stepIt=NULL;
   }
   else
   {
      csvBuildStep=10;
      ldiffBuildStep=1;
      ldiffSaveStep=10;

      long totalProgress = csvBuildStep * csvActions + 
                           ldiffBuildStep * ldiffActions +
                           ldiffSaveStep * ldiffActions;
      // totalProgress is accounting for task 1 and 2

      csvRunStep = totalProgress * csvActions /
                              (csvActions+ldiffActions);
      
      ldiffRunStep = totalProgress - csvRunStep;

      // now we compute the total time
      totalProgress*=2;
      
      if(totalSteps!=NULL)
      {
         totalSteps(totalProgress,caleeStruct);
      }
   }

}


HRESULT 
Repair::run()
{
   LOG_FUNCTION(Repair::run);


   setProgress();

   HRESULT hr=S_OK;

   do
   {
      // First we build the csv. If we can't build it
      // we don't want to run the LDIF and delete
      // the recereate objects
      if (csvActions != 0)
      {  
         hr=buildCsv();
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // Now we save the current objects and then
      // create and run the LDIF
      if ( ldiffActions !=0 )
      {
         // If we can't save we definatelly don't 
         // want to change anything
         hr=buildSaveLdif();
         BREAK_ON_FAILED_HRESULT(hr);

         // buildChangeLdif wil build the Ldif that
         // will change the objects saved im
         // buildSaveLdif
         hr=buildChangeLdif();
         BREAK_ON_FAILED_HRESULT(hr);

         
         GetWorkFileName(
                           String::load(IDS_FILE_NAME_LDIF_LOG),
                           L"txt",
                           ldifLog
                        );
         // runs the Ldif built in buildChangeLdif
         hr=runCsvOrLdif(LDIF,IMPORT,ldiffName,L"",ldifLog);
         BREAK_ON_FAILED_HRESULT(hr);

         if(stepIt!=NULL) 
         {
            stepIt(ldiffRunStep,caleeStruct);
         }
      }

      // Finally, we run the csv
      if (csvActions!=0)
      {  
         String opt=L"-c DOMAINPLACEHOLDER \"" + domain + L"\"";

         GetWorkFileName
         (
            String::load(IDS_FILE_NAME_CSV_LOG),
            L"txt",
            csvLog
         );
         hr=runCsvOrLdif(CSV,IMPORT,csvName,opt,csvLog);
         BREAK_ON_FAILED_HRESULT(hr);
         if(stepIt!=NULL) 
         {
            stepIt(csvRunStep,caleeStruct);
         }

      }
   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}



// Get the export results of a single object
HRESULT
Repair::getLdifExportedObject(
                                const long locale,
                                const String &object,
                                String &objectLines
                             )
{
   LOG_FUNCTION(Repair::getLdifExportedObject);
   
   ASSERT(!object.empty());
   ASSERT(locale > 0);
   objectLines.erase();
   
   HRESULT hr=S_OK;

   do
   {
      String dn= L"CN=" + object + 
                 String::format(L",CN=%1!3x!,", locale) +
                 rootContainerDn;
      
      String opt=L"-o ObjectGuid -d \"" + dn + L"\"";

      String tempName;
      hr=GetWorkTempFileName(L"TMP",tempName);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=runCsvOrLdif(LDIF,EXPORT,tempName,opt);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=ReadAllFile(tempName,objectLines);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=Win::DeleteFile(tempName);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);
   
   
   LOG_HRESULT(hr);
   return hr;
}

// buildSaveLdif will save information on
// all objects that will be changed
// or deleted in runChangeLdif.
// This includes information on:
//    results.objectActions
HRESULT 
Repair::buildSaveLdif()
{
   LOG_FUNCTION(Repair::buildSaveLdif);

   HRESULT hr=S_OK;

   HANDLE file;
   
   hr=FS::CreateFile(saveName,
                     file,
                     GENERIC_WRITE);
   
   if FAILED(hr)
   {
      error=String::format(IDS_COULD_NOT_CREATE_FILE,saveName.c_str());
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      String objectLines;

      ObjectActions::iterator beginObj=results.objectActions.begin();
      ObjectActions::iterator endObj=results.objectActions.end();

      while(beginObj!=endObj) 
      {         
         String dn= L"dn: CN=" + beginObj->first.object + 
           String::format(L",CN=%1!3x!,", beginObj->first.locale) +
           rootContainerDn + L"\r\nchangetype: delete\r\n";

         hr=FS::WriteLine(file,dn);
         BREAK_ON_FAILED_HRESULT(hr);

         hr=getLdifExportedObject( 
                                    beginObj->first.locale,
                                    beginObj->first.object,
                                    objectLines
                                  );
         BREAK_ON_FAILED_HRESULT(hr);

         hr=FS::WriteLine(file,objectLines);
         BREAK_ON_FAILED_HRESULT(hr);

         if(stepIt!=NULL) 
         {
            stepIt(ldiffSaveStep,caleeStruct);
         }
         beginObj++;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      beginObj=results.extraneousValues.begin();
      endObj=results.extraneousValues.end();
      while(beginObj!=endObj) 
      {
         ObjectId tempObj(
                           beginObj->first.locale,
                           String(beginObj->first.object)
                         );
         if( 
            results.objectActions.find(tempObj) == 
            results.objectActions.end()
           )
         {
            String dn= L"dn: CN=" + beginObj->first.object + 
               String::format(L",CN=%1!3x!,", beginObj->first.locale) +
               rootContainerDn + L"\r\nchangetype: delete\r\n";

            hr=FS::WriteLine(file,dn);
            BREAK_ON_FAILED_HRESULT(hr);

            hr=getLdifExportedObject( 
                                       beginObj->first.locale,
                                       beginObj->first.object,
                                       objectLines
                                     );
            BREAK_ON_FAILED_HRESULT(hr);

            hr=FS::WriteLine(file,objectLines);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if(stepIt!=NULL) 
         {
            stepIt(ldiffSaveStep,caleeStruct);
         }
         beginObj++;
      }
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   CloseHandle(file);

   LOG_HRESULT(hr);
   return hr;
}



HRESULT
Repair::makeObjectsLdif(HANDLE file,ObjectIdList &objects)
{
   LOG_FUNCTION(Repair::makeObjectsLdif);
   HRESULT hr=S_OK;

   do
   {
      ObjectIdList::iterator begin,end;
      
      String header;

      begin=objects.begin();
      end=objects.end();
      while(begin!=end)
      {
         header= L"\r\ndn: CN=" + begin->object + 
                 String::format(L",CN=%1!3x!,", begin->locale) +
                 rootContainerDn;
         hr=FS::WriteLine(file,header);
         BREAK_ON_FAILED_HRESULT(hr);

         hr=FS::WriteLine(file,L"changetype: delete");
         BREAK_ON_FAILED_HRESULT(hr);

         begin++;
         if(stepIt!=NULL) 
         {
            stepIt(ldiffBuildStep,caleeStruct);
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}


// buildChangeLdif wil build the Ldif that
// will change the objects saved im
// buildSaveLdif
HRESULT 
Repair::buildChangeLdif()
{
   LOG_FUNCTION(Repair::buildChangeLdif);

   HRESULT hr=S_OK;

   HANDLE file;
   
   hr=FS::CreateFile(ldiffName,
                     file,
                     GENERIC_WRITE);
   
   if FAILED(hr)
   {
      error=String::format(IDS_COULD_NOT_CREATE_FILE,ldiffName.c_str());
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      String header;
      String line;

      ObjectActions::iterator beginObj=results.objectActions.begin();
      ObjectActions::iterator endObj=results.objectActions.end();

      while(beginObj!=endObj) 
      {
         header= L"\r\ndn: CN=" + beginObj->first.object + 
                 String::format(L",CN=%1!3x!,", beginObj->first.locale) +
                 rootContainerDn;
         hr=FS::WriteLine(file,header);
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=FS::WriteLine(file,L"changetype: ntdsSchemaModify");
         BREAK_ON_FAILED_HRESULT(hr);
         

         PropertyActions::iterator beginAct=beginObj->second.begin();
         PropertyActions::iterator endAct=beginObj->second.end();

         while(beginAct!=endAct)
         {
            
            if(!beginAct->second.addValues.empty())
            {
               line = L"add: " + beginAct->first;
               hr=FS::WriteLine(file,line);
               BREAK_ON_FAILED_HRESULT(hr);
               
               StringList::iterator 
                  beginAdd = beginAct->second.addValues.begin();
               StringList::iterator 
                  endAdd = beginAct->second.addValues.end();
               while(beginAdd!=endAdd)
               {
                  line = beginAct->first + L": " + *beginAdd;
                  hr=FS::WriteLine(file,line);
                  BREAK_ON_FAILED_HRESULT(hr);

                  beginAdd++;
               }
               BREAK_ON_FAILED_HRESULT(hr); // break on if internal while broke

               hr=FS::WriteLine(file,L"-");
               BREAK_ON_FAILED_HRESULT(hr);
            }

            if(!beginAct->second.delValues.empty())
            {
               line = L"delete: " + beginAct->first;
               hr=FS::WriteLine(file,line);
               BREAK_ON_FAILED_HRESULT(hr);
               
               StringList::iterator 
                  beginDel = beginAct->second.delValues.begin();
               StringList::iterator 
                  endDel = beginAct->second.delValues.end();
               while(beginDel!=endDel)
               {
                  line = beginAct->first + L": " + *beginDel;
                  hr=FS::WriteLine(file,line);
                  BREAK_ON_FAILED_HRESULT(hr);

                  beginDel++;
               }
               BREAK_ON_FAILED_HRESULT(hr); // break on if internal while broke

               hr=FS::WriteLine(file,L"-");
               BREAK_ON_FAILED_HRESULT(hr);
            }

            beginAct++;
         } // while(beginAct!=endAct)
         BREAK_ON_FAILED_HRESULT(hr); // break on if internal while broke

         if(stepIt!=NULL) 
         {
            stepIt(ldiffBuildStep,caleeStruct);
         }
         beginObj++;
      } // while(beginObj!=endObj)
      
      BREAK_ON_FAILED_HRESULT(hr);

      // Now we will add actions to remove the extraneous objects
      beginObj=results.extraneousValues.begin();
      endObj=results.extraneousValues.end();
      while(beginObj!=endObj) 
      {

         header= L"\r\ndn: CN=" + beginObj->first.object + 
           String::format(L",CN=%1!3x!,", beginObj->first.locale) +
           rootContainerDn;

         hr=FS::WriteLine(file,header);
         BREAK_ON_FAILED_HRESULT(hr);
         
         hr=FS::WriteLine(file,L"changetype: ntdsSchemaModify");
         BREAK_ON_FAILED_HRESULT(hr);

         PropertyActions::iterator beginAct=beginObj->second.begin();
         PropertyActions::iterator endAct=beginObj->second.end();

         while(beginAct!=endAct)
         {
            if(!beginAct->second.delValues.empty())
            {
               line = L"delete: " + beginAct->first;
               hr=FS::WriteLine(file,line);
               BREAK_ON_FAILED_HRESULT(hr);
               
               StringList::iterator 
                  beginDel = beginAct->second.delValues.begin();
               StringList::iterator 
                  endDel = beginAct->second.delValues.end();
               while(beginDel!=endDel)
               {
                  line = beginAct->first + L": " + *beginDel;
                  hr=FS::WriteLine(file,line);
                  BREAK_ON_FAILED_HRESULT(hr);

                  beginDel++;
               }
               BREAK_ON_FAILED_HRESULT(hr); // break on if internal while broke

               hr=FS::WriteLine(file,L"-");
               BREAK_ON_FAILED_HRESULT(hr);
            } //if(!beginAct->second.delValues.empty())
            beginAct++;
         } // while(beginAct!=endAct)
         BREAK_ON_FAILED_HRESULT(hr);

         if(stepIt!=NULL) 
         {
            stepIt(ldiffBuildStep,caleeStruct);
         }
         beginObj++;
      } // while(beginObj!=endObj)

      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   CloseHandle(file);
   
   LOG_HRESULT(hr);
   return hr;
}



HRESULT
Repair::makeObjectsCsv(HANDLE file,ObjectIdList &objects)
{
   LOG_FUNCTION(Repair::makeObjectsCsv);
   HRESULT hr=S_OK;

   do
   {
      ObjectIdList::iterator begin,end;

      begin=objects.begin();
      end=objects.end();
      while(begin!=end)
      {
         long locale=begin->locale;
         const CSVDSReader &csvReader=(locale==0x409)?csvReader409:csvReaderIntl;
      
         setOfObjects tempObjs;
         pair<String,long> tempObj;
         tempObj.first=begin->object;
         tempObj.second=begin->locale;
         tempObjs.insert(tempObj);


         hr=csvReader.makeObjectsCsv(file,tempObjs);
         BREAK_ON_FAILED_HRESULT(hr);
         begin++;
         if(stepIt!=NULL) 
         {
            stepIt(csvBuildStep,caleeStruct);
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}


// buildCsv creates a CSV with:
//       results.createContainers, 
//       results.createW2KObjects 
//       results.createXPObjects
HRESULT 
Repair::buildCsv()
{
   LOG_FUNCTION(Repair::buildCsv);
   
   HANDLE file;

   HRESULT hr=S_OK;
   
   hr=FS::CreateFile(csvName,
                     file,
                     GENERIC_WRITE);
   
   if FAILED(hr)
   {
      error=String::format(IDS_COULD_NOT_CREATE_FILE,csvName.c_str());
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      
      LongList::iterator bgCont,endCont;
      bgCont=results.createContainers.begin();
      endCont=results.createContainers.end();

      while(bgCont!=endCont)
      {
         long locale=*bgCont;
         const CSVDSReader &csvReader=(locale==0x409)?csvReader409:csvReaderIntl;
         long locales[2]={locale,0L};
         hr=csvReader.makeLocalesCsv(file,locales);
         BREAK_ON_FAILED_HRESULT(hr);
         bgCont++;
         if(stepIt!=NULL) 
         {
            stepIt(csvBuildStep,caleeStruct);
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);

      hr=makeObjectsCsv(file,results.createW2KObjects);
      BREAK_ON_FAILED_HRESULT(hr);

      hr=makeObjectsCsv(file,results.createXPObjects);
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   CloseHandle(file);
   
   LOG_HRESULT(hr);
   return hr;
}



// This finction will run csvde or ldifde(whichExe)
// to import or export (inOut) file. The options specified
// are -u for unicode, -j for the log/err path -f for the file
// -i if import and the extraOptions.
// The log file will be renamed for logFileArg(if !empty)
// If an error file is generated it will be renamed.
HRESULT 
Repair::runCsvOrLdif(
                        csvOrLdif whichExe,
                        importExport inOut,
                        const String& file,
                        const String& extraOptions,//=L""
                        const String& logFileArg//=L""
                    )
{

   LOG_FUNCTION2(Repair::runCsvOrLdif,file.c_str());

   String baseName = (whichExe==LDIF) ? L"LDIF" : L"CSV";
   String exeName = baseName + L"de.exe";
   String options = (inOut==IMPORT) ? L"-i " + extraOptions : extraOptions;
   String operation = (inOut==IMPORT) ? L"importing" : L"exporting";
  
   HRESULT hr=S_OK;
   do
   {

      String sys32dir = Win::GetSystemDirectory();
      String wholeName = sys32dir + L"\\" + exeName;

      if (!FS::FileExists(wholeName))
      {
         error=String::format(IDS_EXE_NOT_FOUND,wholeName.c_str());
         hr=E_FAIL;
         break;
      }

      if (inOut==IMPORT && !FS::FileExists(file))
      {
         hr=Win32ToHresult(ERROR_FILE_NOT_FOUND);
         error=file;
         break;
      }

      String commandLine = L"\"" + wholeName + L"\" " +
                           options +
                           L" -u -f \"" + 
                           file + 
                           L"\" -j \"" + 
                           logPath + L"\"";

      STARTUPINFO si;
	   PROCESS_INFORMATION pi;
	   GetStartupInfo(&si);

      String curDir=L"";

      String errFile=logPath + L"\\" + baseName + L".err";
      String logFile=logPath + L"\\" + baseName + L".log";
      
      if(FS::FileExists(errFile))
      {
         hr=Win::DeleteFile(errFile);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,errFile);
      }

      if(FS::FileExists(logFile))
      {
         hr=Win::DeleteFile(logFile);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,logFile);
      }

      hr=Win::CreateProcess
              (
                  commandLine,
                  NULL,    // lpProcessAttributes
                  NULL,    // lpThreadAttributes
                  false,   // dwCreationFlags 
                  NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,// fdwCreate 
                  NULL,    // lpEnvironment 
                  curDir,  // lpEnvironment 
		            si,     // [in] lpStartupInfo 
                  pi      // [out] pProcessInformation
              );
      
      BREAK_ON_FAILED_HRESULT_ERROR(hr,
         String::format(IDS_COULD_NOT_START_EXE,commandLine.c_str()));



      String errorInfo=String::format
                        (
                           IDS_CSVDE_LDIFDE_ERROR_BASIC,
                           operation.c_str(),
                           exeName.c_str(),
                           commandLine.c_str()
                        );

      do
      {

         DWORD resWait;
         hr=Win::WaitForSingleObject(pi.hProcess,INFINITE,resWait);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,errorInfo);

         if(!logFileArg.empty())
         {
            hr=FS::MoveFile(logFile.c_str(), logFileArg.c_str());
            BREAK_ON_FAILED_HRESULT_ERROR(hr,logFile);
         }

         DWORD resExit;
         hr=Win::GetExitCodeProcess(pi.hProcess,resExit);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,errorInfo);


         if(resExit!=0)
         {
            String betterErrFile;
            GetWorkFileName
            (
               String::load(
                              (whichExe==LDIF) ? 
                              IDS_FILE_NAME_LDIF_ERROR : 
                              IDS_FILE_NAME_CSV_ERROR
                           ),
               L"txt",
               betterErrFile
            );

            hr=FS::MoveFile(errFile.c_str(), betterErrFile.c_str());
            BREAK_ON_FAILED_HRESULT_ERROR(hr,errFile);
            
            error=String::format
                        (
                           IDS_CSVDE_LDIFDE_ERROR_COMPLETE,
                           operation.c_str(),
                           exeName.c_str(),
                           commandLine.c_str(),
                           betterErrFile.c_str()
                        );
            hr=E_FAIL;
            break;
         }
      } while(0);


      CloseHandle(pi.hProcess);
      CloseHandle(pi.hThread);

   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\repair.hpp ===
#ifndef REPAIR_HPP
#define REPAIR_HPP

#include  "AnalisysResults.hpp"
#include  "dspecup.hpp"

// USED IN runCsvOrLdif
enum csvOrLdif {LDIF,CSV};
enum importExport {IMPORT,EXPORT};

class CSVDSReader;
struct sChangeList;


class Repair
{
public:
   Repair
   (
      const CSVDSReader& csvReader409_,
      const CSVDSReader& csvReaderIntl_,
      const String& domain,
      const String& rootContainerDn_,
      AnalisysResults& res,
      const String& ldiffName_,
      const String& csvName_,
      const String& saveName_,
      const String& logPath_,
      void *caleeStruct_=NULL,
		progressFunction stepIt_=NULL,
		progressFunction totalSteps_=NULL
   );
   

   HRESULT run();

private:
   AnalisysResults& results;
   const CSVDSReader&   csvReader409;
   const CSVDSReader&   csvReaderIntl;
   const String         domain;
   const String         rootContainerDn;
   const String         ldiffName;
   const String         csvName;
   const String         saveName;
   const String         logPath;

   String               csvLog;
   String               ldifLog;

   void                 *caleeStruct;
   progressFunction     stepIt;
   progressFunction     totalSteps;


   long csvBuildStep;
   long ldiffBuildStep;
   long csvRunStep;
   long ldiffRunStep;
   long ldiffSaveStep;
   long csvActions;
   long ldiffActions;

   
   HRESULT buildSaveLdif();
   HRESULT buildChangeLdif();

   HRESULT
   makeObjectsCsv(HANDLE file,ObjectIdList &objects);

   HRESULT
   makeObjectsLdif(HANDLE file,ObjectIdList &objects);

   HRESULT buildCsv();


   HRESULT 
   runCsvOrLdif(
                   csvOrLdif whichExe,
                   importExport inOut,
                   const String& file,
                   const String& extraOptions=L"",
                   const String& logFileArg=L""
                );


   HRESULT
   getLdifExportedObject (
                          const long locale,
                          const String &object,
                          String &objectLines
                         );
   
   void setProgress();


};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\amanuensis.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class Amanuensis, records a log of the analysis phase
//
// 8 Mar 2001 sburns



#ifndef AMANUENSIS_HPP_INCLUDED
#define AMANUENSIS_HPP_INCLUDED



// a.man.u.en.sis [ah mannyoo ehnsiss] (plural a.man.u.en.ses [ah mannyoo ehn
// seez]) noun 1.scribe: somebody employed by an individual to write from his
// or her dictation or to copy manuscripts 2.writers assistant: a writers
// assistant with research and secretarial duties
// 
// [Early 17th century. From Latin, formed from a manu, literally, by hand
// (in the phrase servus a manu enslaved servant with secretarial duties).]



class Amanuensis
{
   public:


   
   explicit
   Amanuensis(int outputInterval = 5);



   void
   AddEntry(const String& entry);



   void
   AddErrorEntry(HRESULT hr, int stringResId);



   void
   AddErrorEntry(HRESULT hr, const String& entry);
   


   void
   Flush();

//    String
//    GetLog() const;   

//    HRESULT
//    SaveLogFile(const String& logFilePath) const;
// 
// 
// 
   


   private:

   StringList           entries;       
   int                  outputInterval;
   StringList::iterator lastOutput;    

   
   
   // not implemented: no copying allowed. You can't copy the copyist. Ha!
   // I crack myself up.

   Amanuensis(const Amanuensis&);
   const Amanuensis& operator=(const Amanuensis&);
};



#endif   // AMANUENSIS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\analyst.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class Analyst: analyzes the display specifiers, logs the findings, and
// compiles a set of corrective actions.
//
// 9 Mar 2001 sburns



#include "headers.hxx"
#include "resource.h"
#include "AdsiHelpers.hpp"
#include "Analyst.hpp"
#include "Amanuensis.hpp"
#include "Repairer.hpp"
#include "ChangedObjectHandlerList.hpp"
#include "ChangedObjectHandler.hpp"



Analyst::Analyst(
   const String& targetDomainControllerName,
   Amanuensis&   amanuensis_,
   Repairer&     repairer_)
   :
   targetDcName(targetDomainControllerName),
   ldapPrefix(),
   rootDse(0),
   
   // alias the objects

   amanuensis(amanuensis_),
   repairer(repairer_)
{
   LOG_CTOR(Analyst);
   ASSERT(!targetDcName.empty());

}



// basic idea: if the error is critical and analysis should not continue, set
// hr to a failure value, and break out, propagating the error backward.  If
// the error is non-critical and analysis should continue, log the error, skip
// the current operation, and set hr to S_FALSE.

HRESULT
AssessErrorSeverity(HRESULT hrIn)
{
   HRESULT hr = hrIn;
   
   if (SUCCEEDED(hr))
   {
      return hr;
   }
   
   switch (hr)
   {
      case 0:
      {
      }
      
      // CODEWORK: we need to define what errors are critical...
      
      default:
      {
         // do nothing

         break;
      }
   }

   return hr;
}
   


HRESULT
Analyst::AnalyzeDisplaySpecifiers()
{
   LOG_FUNCTION(Analyst::AnalyzeDisplaySpecifiers);

   HRESULT hr = S_OK;

   do
   {
      Computer targetDc(targetDcName);
      hr = targetDc.Refresh();

      if (FAILED(hr))
      {
         amanuensis.AddErrorEntry(
            hr,
            String::format(
               IDS_CANT_TARGET_MACHINE,
               targetDcName.c_str()));
         break;
      }

      if (!targetDc.IsDomainController())
      {
         amanuensis.AddEntry(
            String::format(
               IDS_TARGET_IS_NOT_DC,
               targetDcName.c_str()));
         break;
      }

      String dcName = targetDc.GetActivePhysicalFullDnsName();
      ldapPrefix = L"LDAP://" + dcName + L"/";
         
      //
      // Find the DN of the configuration container.
      // 

      // Bind to the rootDSE object.  We will keep this binding handle
      // open for the duration of the analysis and repair phases in order
      // to keep a server session open.  If we decide to pass creds to the
      // AdsiOpenObject call in a later revision, then by keeping the
      // session open we will not need to pass the password to subsequent
      // AdsiOpenObject calls.
      
      hr = AdsiOpenObject<IADs>(ldapPrefix + L"RootDSE", rootDse);
      if (FAILED(hr))
      {
         amanuensis.AddErrorEntry(
            hr,
            String::format(
               IDS_UNABLE_TO_CONNECT_TO_DC,
               dcName.c_str()));
         break;      
      }
            
      // read the configuration naming context.

      _variant_t variant;
      hr =
         rootDse->Get(
            AutoBstr(LDAP_OPATT_CONFIG_NAMING_CONTEXT_W),
            &variant);
      if (FAILED(hr))
      {
         LOG(L"can't read config NC");
         
         amanuensis.AddErrorEntry(
            hr,
            IDS_UNABLE_TO_READ_DIRECTORY_INFO);
         break;   
      }

      String configNc = V_BSTR(&variant);

      LOG(configNc);
      ASSERT(!configNc.empty());      

      //
      // Here we go...
      //
      
      hr = AnalyzeDisplaySpecifierContainers(configNc);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
Analyst::AnalyzeDisplaySpecifierContainers(const String& configurationDn)
{
   LOG_FUNCTION2(Analyst::AnalyzeDisplaySpecifierContainers, configurationDn);
   ASSERT(!configurationDn.empty());

   HRESULT hr = S_OK;
   
   static const int LOCALEIDS[] =
   {
      // a list of all the non-english locale IDs that we support

      0x401,
      0x404,
      0x405,
      0x406,
      0x407,
      0x408,
      0x40b,
      0x40c,
      0x40d,
      0x40e,
      0x410,
      0x411,
      0x412,
      0x413,
      0x414,
      0x415,
      0x416,
      0x419,
      0x41d,
      0x41f,
      0x804,
      0x816,
      0xc0a,
      0
   };

   // compose the LDAP path of the display specifiers container

   String rootContainerDn = L"CN=DisplaySpecifiers," + configurationDn;

   for (
      int i = 0;
         (i < sizeof(LOCALEIDS) / sizeof(int))
      && LOCALEIDS[i];
      ++i)
   {
      hr = AnalyzeDisplaySpecifierContainer(LOCALEIDS[i], rootContainerDn);
      BREAK_ON_FAILED_HRESULT(hr);
   }

   LOG_HRESULT(hr);

   return hr;
}
      


HRESULT
Analyst::AnalyzeDisplaySpecifierContainer(
   int           localeId,
   const String& rootContainerDn)
{
   LOG_FUNCTION2(
      Analyst::AnalyzeDisplaySpecifierContainer,
      rootContainerDn);
   ASSERT(!rootContainerDn.empty());
   ASSERT(localeId);

   HRESULT hr = S_OK;

   do
   {
      String childContainerDn =
            ldapPrefix
         +  String::format(L"CN=%1!3x!,", localeId) + rootContainerDn;

      // Attempt to bind to the container.
         
      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(childContainerDn, iads);
      if (hr == E_ADS_UNKNOWN_OBJECT)
      {
         // The container object does not exist.  This is possible because
         // the user has manually removed the container, or because it
         // was never created due to an aboted post-dcpromo import of the
         // display specifiers when the forest root dc was first promoted.

         repairer.AddCreateContainerWorkItem(localeId);
         hr = S_OK;
         break;
      }

      BREAK_ON_FAILED_HRESULT(hr);      

      // At this point, the bind succeeded, so the child container exists.
      // So now we want to examine objects in that container.

      hr =
         AnalyzeDisplaySpecifierObjects(
            localeId,
            childContainerDn);
   }
   while (0);

   LOG_HRESULT(hr);

   hr = AssessErrorSeverity(hr);
   
   return hr;
}



HRESULT
Analyst::AnalyzeDisplaySpecifierObjects(
   int           localeId,
   const String& containerDn)
{
   LOG_FUNCTION2(Analyst::AnalyzeDisplaySpecifierObjects, containerDn);
   ASSERT(localeId);
   ASSERT(!containerDn.empty());

   HRESULT hr = S_OK;

   do
   {
      // Part 1: deal with new objects added in Whistler

      hr = AnalyzeAddedObjects(localeId, containerDn);
      hr = AssessErrorSeverity(hr);
      BREAK_ON_FAILED_HRESULT(hr);

      // Part 2: deal with objects that have changed from Win2k to Whistler

      hr = AnalyzeChangedObjects(localeId, containerDn);
      hr = AssessErrorSeverity(hr);      
      BREAK_ON_FAILED_HRESULT(hr);
                  
      // Part 3: deal with objects that have been deleted in whistler

      // This part is easy: there are no deletions.
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



bool
RepairWasRunPreviously()
{
   LOG_FUNCTION(RepairWasRunPreviously);

   bool result = false;
   
   // CODEWORK: need to complete

   LOG_BOOL(result);
   
   return result;
}



HRESULT
Analyst::AnalyzeAddedObjects(
   int           localeId,
   const String& containerDn)
{
   LOG_FUNCTION2(Analyst::AnalyzeAddedObjects, containerDn);
   ASSERT(localeId);
   ASSERT(!containerDn.empty());

   HRESULT hr = S_OK;

   do
   {
      static const String ADDED_OBJECTS[] =
      {
         L"msMQ-Custom-Recipient-Display",
         L"msMQ-Group-Display",
         L"msCOM-PartitionSet-Display",
         L"msCOM-Partition-Display",
         L"lostAndFound-Display",
         L"inetOrgPerson-Display",
         L"",
      };

      for (
         int i = 0;
            i < (sizeof(ADDED_OBJECTS) / sizeof(String))
         && !ADDED_OBJECTS[i].empty();
         ++i)
      {
         String objectName = ADDED_OBJECTS[i];
         
         String objectPath =
            ldapPrefix +  L"CN=" + objectName + L"," + containerDn;

         SmartInterface<IADs> iads(0);
         hr = AdsiOpenObject<IADs>(objectPath, iads);
         if (hr == E_ADS_UNKNOWN_OBJECT)
         {
            // The object does not exist. This is what we expect. We want
            // to add the object in the repair phase.

            repairer.AddCreateObjectWorkItem(localeId, objectName);
            hr = S_OK;
            continue;
         }
         else if (SUCCEEDED(hr))
         {
            // The object already exists. Well, that's not expected, unless
            // we've already run the tool.

            if (!RepairWasRunPreviously())
            {
               // we didn't create the object.  If the user did, they did
               // it manually, and we don't support that.
               
               // cause the existing object to be deleted

               repairer.AddDeleteObjectWorkItem(localeId, objectName);

               // cause a new, replacement object to be created.
               
               repairer.AddCreateObjectWorkItem(localeId, objectName);
               hr = S_OK;
               continue;
            }
         }
         else
         {
            ASSERT(FAILED(hr));

            LOG(L"Unexpected error attempting to bind to " + objectName);

            amanuensis.AddErrorEntry(
               hr,
               String::format(
                  IDS_ERROR_BINDING_TO_OBJECT,
                  objectName.c_str(),
                  objectPath.c_str()));
 
            // move on to the next object
            
            hr = S_FALSE;
            continue;
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
   
   LOG_HRESULT(hr);

   return hr;
}
         


HRESULT
Analyst::AnalyzeChangedObjects(
   int           localeId,
   const String& containerDn)
{
   LOG_FUNCTION2(Analyst::AnalyzeChangedObjects, containerDn);
   ASSERT(localeId);
   ASSERT(!containerDn.empty());

   HRESULT hr = S_OK;

   static const ChangedObjectHandlerList handlers;
   
   for (
      ChangedObjectHandlerList::iterator i = handlers.begin();
      i != handlers.end();
      ++i)
   {
      hr = AnalyzeChangedObject(localeId, containerDn, **i);
      hr = AssessErrorSeverity(hr);
            
      BREAK_ON_FAILED_HRESULT(hr);
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
Analyst::AnalyzeChangedObject(
   int                           localeId,
   const String&                 containerDn,
   const ChangedObjectHandler&   changeHandler)
{
   LOG_FUNCTION2(Analyst::AnalyzeChangedObject, changeHandler.GetObjectName());
   ASSERT(localeId);
   ASSERT(!containerDn.empty());

   HRESULT hr = S_OK;

   do
   {
      String objectName = changeHandler.GetObjectName();
         
      String objectPath =
         ldapPrefix +  L"CN=" + objectName + L"," + containerDn;

      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(objectPath, iads);
      if (hr == E_ADS_UNKNOWN_OBJECT)
      {
         // The object does not exist.  This is possible because the user has
         // manually removed the container, or because it was never created
         // due to an aboted post-dcpromo import of the display specifiers
         // when the forest root dc was first promoted.

         // Add a work item to create the missing object
         
         repairer.AddCreateObjectWorkItem(localeId, objectName);
         hr = S_OK;
         break;
      }

      if (FAILED(hr))
      {
         // any other error is quittin' time.

         break;
      }

      // At this point, the display specifier object exists.  Determine if
      // if has been touched since its creation.

      // Compare usnCreated to usnChanged
      
      _variant_t variant;
      hr = iads->Get(AutoBstr(L"usnCreated"), &variant);
      if (FAILED(hr))
      {
         LOG(L"Error reading usnCreated");
         break;
      }


      
      // CODEWORK: need to complete this


      

      hr = changeHandler.HandleChange(
         localeId,
         containerDn,
         iads,
         amanuensis,
         repairer);
         
      
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\changedobjecthandlerlist.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class ChangedObjectHandlerList
//
// 14 Mar 2001 sburns



#include "headers.hxx"
#include "ChangedObjectHandlerList.hpp"
#include "DsUiDefaultSettingsChangeHandler.hpp"



ChangedObjectHandlerList::ChangedObjectHandlerList()
{
   LOG_CTOR(ChangedObjectHandlerList);

   push_back(new DsUiDefaultSettingsChangeHandler);
   
   // push_back(new UserDisplayChangeHandler());
   // push_back(new DomainDnsDisplayChangeHandler());
   // push_back(new ComputerDisplayChangeHandler());
   // push_back(new OrganizationalUnitDisplayChangeHandler());
   // push_back(new ContainerDisplayChangeHandler());
   // push_back(new DefaultDisplayChangeHandler());
   // push_back(new NtdsServiceDisplayChangeHandler());
   // push_back(new PkiCertificateTemplateDisplayChangeHandler());
}



ChangedObjectHandlerList::~ChangedObjectHandlerList()
{
   LOG_DTOR(ChangedObjectHandlerList);

   for (
      iterator i = begin();
      i != end();
      ++i)
   {
      // i is the "pointer" to the pointer, so deref i first
      
      delete *i;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\amanuensisa.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class Amanuensis, records a log of the analysis phase
//
// 8 Mar 2001 sburns



#include "headers.hxx"
#include <iostream>
#include "Amanuensis.hpp"
#include "resource.h"




Amanuensis::Amanuensis(int outputInterval_)
   :
   outputInterval(outputInterval_)
{
   LOG_CTOR(Amanuensis);

   lastOutput = entries.begin();
}



void
Amanuensis::AddEntry(const String& entry)
{
   LOG_FUNCTION2(Amanuensis::AddEntry, entry);

   // empty entries are ok, these are treated as newlines.

   // insert the new entry at the end of the list.
   
   StringList::iterator last =
      entries.insert(entries.end(), entry + L"\r\n");

   if (outputInterval && !(entries.size() % outputInterval))
   {
      Flush();
   }
}



void
Amanuensis::AddErrorEntry(HRESULT hr, int stringResId)
{
   LOG_FUNCTION(Amanuensis::AddErrorEntry);
   ASSERT(FAILED(hr));
   ASSERT(stringResId);

   AddErrorEntry(hr, String::load(stringResId));
}
   


void
Amanuensis::AddErrorEntry(HRESULT hr, const String& message)
{
   LOG_FUNCTION(Amanuensis::AddErrorEntry);
   ASSERT(FAILED(hr));
   ASSERT(!message.empty());

   AddEntry(
      String::format(
         IDS_ERROR_ENTRY,
         message.c_str(),
         GetErrorMessage(hr).c_str()));
}



void
Amanuensis::Flush()
{
   LOG_FUNCTION(Amanuensis::Flush);

   // output all entries since the last entry that we output.

   while (lastOutput != entries.end())
   {
      AnsiString ansi;
      lastOutput->convert(ansi);

      // CODEWORK: here we're just dumping to the console, but we might want
      // an abstraction of the output...
      
      std::cout << ansi;
      ++lastOutput;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\dspecup.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// 1 Mar 2001 sburns



#include "headers.hxx"
#include "resource.h"
#include "AdsiHelpers.hpp"
#include "Repairer.hpp"
#include "Amanuensis.hpp"
#include "Analyst.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available

// don't change this: it is also the name of a mutex that the ui
// uses to determine if it is already running.

const wchar_t* RUNTIME_NAME = L"dspecup";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;

Popup popup(IDS_APP_TITLE, false);

// this is the mutex that indicates the program is running.

HANDLE appRunningMutex = INVALID_HANDLE_VALUE;



// these are the valid exit codes returned as the process exit code

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,
};



// returns true if the parameter was extracted. If so, it is removed from
// args

bool
ExtractParameter(
   ArgMap&        args,
   const String&  parameterName,
   String&        parameterValue)
{
   LOG_FUNCTION2(ExtractParameter, parameterName);
   ASSERT(!parameterName.empty());

   parameterValue.erase();
   bool result = false;
   
   ArgMap::iterator itr = args.find(parameterName);
   if (itr != args.end())
   {
      parameterValue = itr->second;
      args.erase(itr);
      result = true;
   }

   LOG_BOOL(result);
   LOG(parameterValue);

   return result;
}
      
      

// Returns false if the command line is malformed.

bool
ParseCommandLine(
   String& targetMachine,
   String& csvFilename)
{
   LOG_FUNCTION(ParseCommandLine);

   targetMachine.erase();
   csvFilename.erase();
   
   bool result = true;
   
   ArgMap args;
   MapCommandLineArgs(args);
   
   // check for target domain controller parameter

   static const String TARGETDC(L"dc");
   ExtractParameter(args, TARGETDC, targetMachine);

   // check for csv filename parameter

   static const String CSVFILE(L"csv");
   ExtractParameter(args, CSVFILE, csvFilename);

   // anything left over gets you command line help, (one arg will always
   // remain: the name of the exe)

   if (args.size() > 1)
   {
      LOG(L"Unrecognized command line options specified");

      result = false;
   }

   LOG_BOOL(result);
   LOG(targetMachine);
   LOG(csvFilename);

   return result;
}



HRESULT
FindCsvFile(const String& targetPath, String& csvFilePath)
{
   LOG_FUNCTION(CheckPreconditions);

   csvFilePath.erase();
   
   HRESULT hr = S_OK;

   do
   {
      // look for dcpromo.csv file in system or current directory
      
      if (targetPath.empty())
      {
         // no preference given, so check the default of
         // %windir%\system32\mui\dispspec\dcpromo.csv and
         // .\dcpromo.csv

         static const String csvname(L"dcpromo.csv");
         
         String sys32dir = Win::GetSystemDirectory();
         String csvPath  = sys32dir + L"\\mui\\dispspec\\" + csvname;

         if (FS::FileExists(csvPath))
         {
            csvFilePath = csvPath;
            break;
         }
      
         csvPath = L".\\" + csvname;
         if (FS::FileExists(csvPath))
         {
            csvFilePath = csvPath;
            break;
         }
      }
      else
      {
         if (FS::FileExists(targetPath))
         {
            csvFilePath = targetPath;
            break;
         }
      }

      // not found.

      hr = S_FALSE;
   }
   while (0);

   LOG_HRESULT(hr);
   LOG(csvFilePath);
   
   return hr;      
}



HRESULT
Start()
{
   LOG_FUNCTION(Start);

   HRESULT hr = S_OK;
   
   do
   {
      //
      // parse the command line options
      //
      
      String targetDomainControllerName;
      String csvFilename;
      ParseCommandLine(
         targetDomainControllerName,
         csvFilename);

      //
      // find the dcpromo.csv file to use
      //
   
      hr = FindCsvFile(csvFilename, csvFilename);
      if (FAILED(hr))
      {
         // encountered an error looking for the csv file
         
         popup.Error(
            Win::GetDesktopWindow(),
            hr,
            IDS_ERROR_LOOKING_FOR_CSV_FILE);
         break;   
      }
      
      if (hr == S_FALSE)
      {
         // no error looking, just not found.
         
         popup.Error(
            Win::GetDesktopWindow(),
            IDS_DCPROMO_CSV_FILE_MISSING);
         break;   
      }

      //
      // Determine the target domain controller
      //

      if (targetDomainControllerName.empty())
      {
         // no target specified, default to the current machine
   
         targetDomainControllerName =
            Win::GetComputerNameEx(ComputerNameDnsFullyQualified);
   
         if (targetDomainControllerName.empty())
         {
            // no DNS name?  that's not right...
   
            LOG(L"no default DNS computer name found.  Using netbios name.");
   
            targetDomainControllerName = Win::GetComputerNameEx(ComputerNameNetBIOS);
         }
      }

      //
      // Analysis Phase
      //

      // First we need a Repairer object to keep track of the changes we
      // will make during the Repair Phase.

      Repairer
         repairer(
            csvFilename
            // might also need domain NC,
            // might also need targetMachine full name
            );

      // Then we need a scribe to record the analysis.
      
      Amanuensis amanuensis;

      // Then we need an Analyst to figure out what's broken and how to
      // fix it.

      Analyst analyst(targetDomainControllerName, amanuensis, repairer);
            
      hr = analyst.AnalyzeDisplaySpecifiers();
      BREAK_ON_FAILED_HRESULT(hr);

      //
      // Repair Phase
      //

      // CODEWORK: get user confirmation to apply repairs
      
      hr = repairer.BuildRepairFiles();
      BREAK_ON_FAILED_HRESULT(hr);

      hr = repairer.ApplyRepairs();
      BREAK_ON_FAILED_HRESULT(hr);            
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}
         


int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   HRESULT hr = Win::CreateMutex(0, true, RUNTIME_NAME, appRunningMutex);
   if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
   {
      // The application is already running

      // CODEWORK: use FindWindowEx and BringWindowToTop,
      // SetForegroundWindow to transfer focus
      // to the other instance?


   }
   else
   {
      hr = ::CoInitialize(0);
      ASSERT(SUCCEEDED(hr));

      hr = Start();
      if (SUCCEEDED(hr))
      {
         exitCode = EXIT_CODE_SUCCESSFUL;
      }
   }

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\changedobjecthandlerlist.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class ChangedObjectHandlerList
//
// 14 Mar 2001 sburns



#ifndef CHANGEDOBJECTHANDLERLIST_HPP_INCLUDED
#define CHANGEDOBJECTHANDLERLIST_HPP_INCLUDED



class ChangedObjectHandler;



// A fixed collection of instances of ChangedObjectHandler that has the
// same public interface as std::list

class ChangedObjectHandlerList
   :
   public std::list<ChangedObjectHandler*>
{
   public:

   ChangedObjectHandlerList();

   ~ChangedObjectHandlerList();


   
   // CODEWORK: it would be interesting to see if we can cause the interface to
   // be read-only by overriding push_back, pop_front, etc...

   
   
   private:

   // not implemented: no copying allowed

   ChangedObjectHandlerList(const ChangedObjectHandlerList&);
   const ChangedObjectHandlerList& operator=(const ChangedObjectHandlerList&);
};



#endif   // CHANGEDOBJECTHANDLERLIST_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\changedobjecthandler.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class ChangedObjectHandler
//
// 14 Mar 2001 sburns



#ifndef CHANGEDOBJECTHANDLER_HPP_INCLUDED
#define CHANGEDOBJECTHANDLER_HPP_INCLUDED



#include "Amanuensis.hpp"
#include "Repairer.hpp"



// An abstract base class for types that deal with the differences in handling
// the display specifier object changes.
// 
// Concrete instances of this class are used by the Analyst class to deal with
// differences in the individual display specifer objects.  Thus, Analyst and
// ChangedObjectHandler form a variation of the Template Method pattern from
// Gamma, et al. Design Patterns. pp. 325-330 ISBN: 0-201-63361-2

class ChangedObjectHandler
{
   public:


   // lucios: 
   // Removed to solve link error
   // Either remove it or define it would work
   // virtual
   // ~ChangedObjectHandler() = 0;


   
   virtual 
   String
   GetObjectName() const = 0;


   
   virtual
   HRESULT
   HandleChange(
      int                  localeId,
      const String&        containerDn,
      SmartInterface<IADs> iads,
      Amanuensis&          amanuensis,
      Repairer&            repairer) const = 0;
};



#endif   // CHANGEDOBJECTHANDLER_HPP_INCLUDED



      // L"user-Display",
      // L"domainDNS-Display",
      // L"computer-Display",
      // L"organizationalUnit-Display",
      // L"container-Display",
      // L"default-Display",
      // L"nTDSService-Display",
      // L"pKICertificateTemplate-Display",
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\dsuidefaultsettingschangehandler.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class DsUiDefaultSettingsChangeHandler, handler for changes to instances
// of the DS-UI-Default-Settings object.
//
// 14 Mar 2001 sburns



#include "headers.hxx"
#include "DsUiDefaultSettingsChangeHandler.hpp"



DsUiDefaultSettingsChangeHandler::DsUiDefaultSettingsChangeHandler()
{
   LOG_CTOR(DsUiDefaultSettingsChangeHandler);
}



DsUiDefaultSettingsChangeHandler::~DsUiDefaultSettingsChangeHandler()
{
   LOG_DTOR(DsUiDefaultSettingsChangeHandler);
}



String
DsUiDefaultSettingsChangeHandler::GetObjectName() const
{
   static String objName(L"DS-UI-Default-Settings");
   
   return objName;
}



HRESULT
DsUiDefaultSettingsChangeHandler::HandleChange(
   int                  localeId,
   const String&        containerDn,
   SmartInterface<IADs> iads,
   Amanuensis&          /* amanuensis */ ,
   Repairer&            /* repairer */ ) const
{
   LOG_FUNCTION2(DsUiDefaultSettingsChangeHandler::HandleChange, containerDn);
   ASSERT(localeId);
   ASSERT(!containerDn.empty());
   ASSERT(iads);
         
   HRESULT hr = S_OK;

   // CODEWORK:  Needs finishing
   
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\analyst.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class Analyst: analyzes the display specifiers, logs the findings, and
// compiles a set of corrective actions.
//
// 9 Mar 2001 sburns



#ifndef ANALYST_HPP_INCLUDED
#define ANALYST_HPP_INCLUDED



class Amanuensis;
class Repairer;
class ChangedObjectHandler;



class Analyst
{
   public:



   Analyst(
      const String& targetDomainControllerName,
      Amanuensis&   amanuensis,
      Repairer&     repairer);



   HRESULT
   AnalyzeDisplaySpecifiers();


   
   private:



   HRESULT
   AnalyzeAddedObjects(
      int           localeId,
      const String& containerDn);



   HRESULT
   AnalyzeChangedObjects(
      int           localeId,
      const String& containerDn);
      

      
   HRESULT
   AnalyzeChangedObject(
      int                           localeId,
      const String&                 containerDn,
      const ChangedObjectHandler&   changeHandler);
      

   
   HRESULT
   AnalyzeDisplaySpecifierContainers(const String& configurationDn);


   
   HRESULT
   AnalyzeDisplaySpecifierContainer(
      int           localeId,
      const String& rootContainerDn);


      
   HRESULT
   AnalyzeDisplaySpecifierObjects(
      int           localeId,
      const String& containerDn);


      
   String               targetDcName;
   String               ldapPrefix;
   SmartInterface<IADs> rootDse;
   Amanuensis&          amanuensis;
   Repairer&            repairer;
   
   

   // not implemented: no copying allowed.

   Analyst(const Analyst&);
   const Analyst& operator=(const Analyst&);
};



#endif   // ANALYST_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\resource.h ===
#define IDS_APP_TITLE                     1501
#define IDS_CANT_TARGET_MACHINE           1502
#define IDS_DCPROMO_CSV_FILE_MISSING      1503
#define IDS_ERROR_LOOKING_FOR_CSV_FILE    1504
#define IDS_TARGET_IS_NOT_DC              1505
#define IDS_UNABLE_TO_CONNECT_TO_DC       1506
#define IDS_UNABLE_TO_READ_DIRECTORY_INFO 1507
#define IDS_ERROR_BINDING_TO_OBJECT       1508
#define IDS_ERROR_ENTRY                   1509
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\repairer.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class Repairer
//
// keeps a list of the localeIds to be extracted from the dcpromo.csv file,
// and a list of operations to be represented in an LDIF file.
//
// 7 Mar 2001 sburns



#include "headers.hxx"
#include "Repairer.hpp"



// // // make sure that the ldif operations are executed in advance of the csv
// // // operations.  this is so the object creates will not conflict with object
// // // deletes




Repairer::Repairer(
   const String& dcpromoCsvFilePath_)
   :
   dcpromoCsvFilePath(dcpromoCsvFilePath_)
{
   LOG_CTOR(Repairer);
   ASSERT(!dcpromoCsvFilePath.empty());

}



bool
Repairer::IsLocaleInObjectsToCreateTable(int localeId) const
{
   LOG_FUNCTION2(
      Repairer::IsLocaleInObjectsToCreateTable,
      String::format(L"%1!d!", localeId));
   ASSERT(localeId);   

   bool result = false;

   for (
      LocaleIdObjectNamePairList::iterator i = objectsToCreate.begin();
      i != objectsToCreate.end();
      ++i)
   {
      if (i->first == localeId)
      {
         result = true;
         break;
      }
   }

   LOG_BOOL(result);

   return result;
}
      

   
void
Repairer::AddCreateContainerWorkItem(int localeId)
{
   LOG_FUNCTION2(
      Repairer::AddCreateContainerWorkItem,
      String::format(L"%1!d!", localeId));
   ASSERT(localeId);

   do
   {
      LocaleIdList::iterator i =
         std::find(
            containersToCreate.begin(),
            containersToCreate.end(),
            localeId);

      if (i != containersToCreate.end())
      {
         // The locale should not already be in the list, since each locale
         // container is evaluated only once.
      
         LOG(L"locale already in list");
         ASSERT(false);
         break;
      }
         
      if (IsLocaleInObjectsToCreateTable(localeId))
      {
         // We don't expect any entries for this locale to be present in the
         // objects-to-create list, because the containers are evaluated first.

         LOG(L"objects for locale already in object list");
         ASSERT(false);

         // CODEWORK: we should handle this situation anyway, just for
         // robustness' sake. To deal with it, all entires in the objects-
         // to-create list for this locale id should be removed.
         
         break;
      }

      containersToCreate.push_back(localeId);
   }
   while (0);
}

            

void
Repairer::AddCreateObjectWorkItem(
   int            localeId,
   const String&  displaySpecifierObjectName)
{
   LOG_FUNCTION2(
      Repairer::AddCreateObjectWorkItem,
      String::format(
         L"%1!d! %2", localeId, displaySpecifierObjectName.c_str()));
   ASSERT(localeId);
   ASSERT(!displaySpecifierObjectName.empty());
   
   do
   {
      LocaleIdList::iterator i =
         std::find(
            containersToCreate.begin(),
            containersToCreate.end(),
            localeId);

      if (i != containersToCreate.end())
      {
         // The locale is already in the containers-to-create list, which
         // we don't expect, since if the container does not exist, we should
         // not be evaluating which objects should be created in that container.

         ASSERT(false);

         // do nothing, as the object will be created as part of the container
         // creation.

         break;
      }

      LocaleIdObjectNamePair p(localeId, displaySpecifierObjectName);
      LocaleIdObjectNamePairList::iterator j =
         std::find(
            objectsToCreate.begin(),
            objectsToCreate.end(),
            p);
                        
      if (j != objectsToCreate.end())
      {
         // The object is already in the list.  We don't expect this, since
         // each object should be evaluated only once per locale.

         ASSERT(false);

         // do nothing, if the object is already present, then fine.

         break;
      }

      objectsToCreate.push_back(p);
   }
   while (0);
}

void
Repairer::AddDeleteObjectWorkItem(
                        int            localeId,
                        const String&  displaySpecifierObjectName)
{
   //CODEWORK: 
   //lucios: Inserted to remove link error
   localeId++;
   String x=displaySpecifierObjectName;
}



HRESULT  
Repairer::BuildRepairFiles()
{
   LOG_FUNCTION(Repairer::BuildRepairFiles);

   HRESULT hr = S_OK;
   
// CODEWORK   
//    csv file:
//    
//    create a (temp) file
//    copy out the first line of the dcpromo.csv file (the column labels)
//    for each localeid in the list
//       copy out all of the lines in the dcpromo.csv file for that locale
//    for each <localeid, objectname> entry
//       copy out that line from the dcpromo.csv file
// 
//    ldif file:

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
Repairer::ApplyRepairs()
{
   LOG_FUNCTION(Repairer::ApplyRepairs);

   HRESULT hr = S_OK;

   // CODEWORK: needs finishing
   
   LOG_HRESULT(hr);

   return hr;
}



// could have gone with a architecture like:
// 
// repairer.workQueue.Add(new CreateContainerWorkItem(localeId));
// 
// but while that certainly seems more OO, more "extensible" because new work
// item types could be derived. Upon further thought, it seems like a worse
// solution to me, since there are them lots of trivial classes involved, and
// the coordination of those classes becomes a real nuisance. Once all the
// work items are collected, who's responsible for translating them into the
// csv/ldif files?  It would have to be an additional manager class.  The
// extensibility turns out to be an illusion, since adding a new work item
// type requires modifying the manager class.  So the added complexity buys
// nothing.
// 
// The other design choice was whether to make the Repairer a "static class"
// -- my name for a class that is really a namespace, which instead of members
// uses static data that is hidden in a single translation unit as though it
// were private class data. This is a technique that makes the private data
// truly secret, as there is no mention of the data in the header declaration
// for the class at all. It also is a nice way to implement the Singleton
// pattern: there are no instances, and therefore no need to worry about
// constructors, destructors, assignment, stack or heap allocation, no
// "GetInstance" methods, and no lifetime issues.
// 
// The technique gives a slightly nicer syntax as:
// 
// Repairer::AddCreateContainerWorkItem(localeId)
// 
// as opposed to
// 
// Repairer::GetInstance()->AddCreateContainerWorkItem(localeId);
// 
// I decided to go with a real, fully-contained object implementation, instead
// of a singleton, thinking that maybe someday multiple instances could be
// repairing multiple forests at once.  Not likely, but why not?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\dsuidefaultsettingschangehandler.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class DsUiDefaultSettingsChangeHandler, handler for changes to instances
// of the DS-UI-Default-Settings object.
//
// 14 Mar 2001 sburns



#ifndef DSUIDEFAULTSETTINGSCHANGEHANDLER_HPP_INCLUDED
#define DSUIDEFAULTSETTINGSCHANGEHANDLER_HPP_INCLUDED



#include "ChangedObjectHandler.hpp"



class DsUiDefaultSettingsChangeHandler
   :
   public ChangedObjectHandler
{
   public:



   DsUiDefaultSettingsChangeHandler();

   ~DsUiDefaultSettingsChangeHandler();
   

   
   // Returns "DS-UI-Default-Settings"
   
   String
   GetObjectName() const;



   HRESULT
   HandleChange(
      int                  localeId,
      const String&        containerDn,
      SmartInterface<IADs> iads,
      Amanuensis&          amanuensis,
      Repairer&            repairer) const;

      

   private:

   // not implemented: no copying allowed

   DsUiDefaultSettingsChangeHandler(const DsUiDefaultSettingsChangeHandler&);
   const DsUiDefaultSettingsChangeHandler
   operator=(const DsUiDefaultSettingsChangeHandler&);   
};
      
      
   

#endif   // DSUIDEFAULTSETTINGSCHANGEHANDLER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\analisyspage.hpp ===
#ifndef ANALISYS_PAGE_HPP_INCLUDED
#define ANALISYS_PAGE_HPP_INCLUDED

struct AnalisysResults;
class CSVDSReader;

class AnalisysPage : public WizardPage 
{

   public:

      AnalisysPage(
                     const CSVDSReader& csvReader409_,
                     const CSVDSReader& csvReaderIntl_,
                     const String& ldapPrefix_,
                     const String& rootContainerDn_,
                     AnalisysResults& res,
                     const String& reportName_
                  );

      void StepProgress();
      void FinishProgress();

   protected:

      friend long WINAPI startAnalisys(long arg);
      virtual ~AnalisysPage();
   


      // WizardPage overrides


      virtual
      bool
      OnSetActive();

      virtual
      void
      OnInit();
   
      virtual
      bool
      OnWizBack();

      virtual
      bool
      OnWizNext();

   private:
      AnalisysResults& results;
      const CSVDSReader& csvReader409;
      const CSVDSReader& csvReaderIntl;
      String ldapPrefix;
      String rootContainerDn;
      String reportName;

   private:
      long pos;


      // not defined: no copying allowed
      AnalisysPage(const AnalisysPage&);
      const AnalisysPage& operator=(const AnalisysPage&);
};



#endif   // ANALISYS_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\common.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// code common to several pages
//
// 12-16-97 sburns



#include "headers.hxx"
#include "common.hpp"
#include "resource.h"
//#include "state.hpp"
//#include "ds.hpp"
//#include <DiagnoseDcNotFound.hpp>



// Creates the fonts for setLargeFonts().
// 
// hDialog - handle to a dialog to be used to retrieve a device
// context.
// 
// bigBoldFont - receives the handle of the big bold font created.

void
InitFonts(
   HWND     hDialog,
   HFONT&   bigBoldFont)
{

   LOG_FUNCTION(InitFonts);
   ASSERT(Win::IsWindow(hDialog));

   HRESULT hr = S_OK;

   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);

      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT bigBoldLogFont = ncm.lfMessageFont;
      bigBoldLogFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BIG_BOLD_FONT_NAME);

      // ensure null termination 260237

      memset(bigBoldLogFont.lfFaceName, 0, LF_FACESIZE * sizeof(TCHAR));
      size_t fnLen = fontName.length();
      fontName.copy(
         bigBoldLogFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));

      unsigned fontSize = 0;
      String::load(IDS_BIG_BOLD_FONT_SIZE).convert(fontSize);
      ASSERT(fontSize);
 
      HDC hdc = 0;
      hr = Win::GetDC(hDialog, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      bigBoldLogFont.lfHeight =
         - ::MulDiv(
            static_cast<int>(fontSize),
            Win::GetDeviceCaps(hdc, LOGPIXELSY),
            72);

      hr = Win::CreateFontIndirect(bigBoldLogFont, bigBoldFont);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::ReleaseDC(hDialog, hdc);
   }
   while (0);
}



void
SetControlFont(HWND parentDialog, int controlID, HFONT font)
{
   LOG_FUNCTION(SetControlFont);
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(controlID);
   ASSERT(font);

   HWND control = Win::GetDlgItem(parentDialog, controlID);

   if (control)
   {
      Win::SetWindowFont(control, font, true);
   }
}



void
SetLargeFont(HWND dialog, int bigBoldResID)
{
   LOG_FUNCTION(SetLargeFont);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(bigBoldResID);

   static HFONT bigBoldFont = 0;
   if (!bigBoldFont)
   {
      InitFonts(dialog, bigBoldFont);
   }

   SetControlFont(dialog, bigBoldResID, bigBoldFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\test\test.cpp ===
#include "headers.hxx"
#include "..\dspecup.hpp"

const wchar_t* RUNTIME_NAME = L"dspecup";

Popup popup(L"dspecup.lib", false);

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;

HINSTANCE hResourceModuleHandle = 0;


long total;

void stepIt(long arg, void *)
{
   printf("\r"             "\r%ld",total+=arg);
}

void totalSteps(long arg, void *)
{
   total=0;
   printf("\n%ld\n",arg);
}

void PrintError(HRESULT hr,
               const String &message)
{
   LOG_FUNCTION(PrintError);

   if(hr==E_FAIL)
   {
      wprintf(L"%s\n",message.c_str());
   }
   else
   {
      if(message.empty())
      {
         wprintf(L"%s\n",GetErrorMessage(hr).c_str());
      }
      else
      {
         wprintf(L"%s\n",message.c_str());
         wprintf(L"%s\n",GetErrorMessage(hr).c_str());
      }
   }
}


int _cdecl main()
{
   hResourceModuleHandle=::GetModuleHandle(NULL);

   HRESULT hr;
   
   hr = ::CoInitialize(0);
   ASSERT(SUCCEEDED(hr));

   PWSTR errorMsg=NULL;
   do
   {
      hr=UpgradeDisplaySpecifiers(false,&errorMsg,NULL,stepIt,totalSteps);
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   CoUninitialize(); 

   if(FAILED(hr))
   {
      String error;
      if(errorMsg!=NULL)
      {
         error=errorMsg;
         CoTaskMemFree(errorMsg);
      }
      PrintError(hr,error);
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\analisyspage.cpp ===
#include "headers.hxx"
#include "AnalisysPage.hpp"
#include "resource.h"
#include "common.hpp"
#include "AnalisysResults.hpp"
#include "CSVDSReader.hpp"
#include "Analisys.hpp"
#include "global.hpp"
#include "constants.hpp"



AnalisysPage::AnalisysPage
              (
                  const CSVDSReader& csvReader409_,
                  const CSVDSReader& csvReaderIntl_,
                  const String& ldapPrefix_,
                  const String& rootContainerDn_,
                  AnalisysResults& res,
                  const String& reportName_
              )
   :
   csvReader409(csvReader409_),
   csvReaderIntl(csvReaderIntl_),
   ldapPrefix(ldapPrefix_),
   rootContainerDn(rootContainerDn_),
   results(res),
   reportName(reportName_),
   WizardPage
   (
      IDD_ANALISYS,
      IDS_ANALISYS_PAGE_TITLE,
      IDS_ANALISYS_PAGE_SUBTITLE,
      true
   )
{
   LOG_CTOR(AnalisysPage);
}

AnalisysPage::~AnalisysPage()
{
   LOG_DTOR(AnalisysPage);
}


long WINAPI startAnalisys(long arg)
{
   LOG_FUNCTION(startAnalisys);
   AnalisysPage *page=(AnalisysPage *)arg;
   Analisys analisys(
                        page->csvReader409,
                        page->csvReaderIntl,
                        page->ldapPrefix,
                        page->rootContainerDn,
                        page->results,
                        &page->reportName,
                        page
                    );

   // CoInitialize must be called per thread
   HRESULT hr = ::CoInitialize(0);
   ASSERT(SUCCEEDED(hr));

   hrError=analisys.run();

   CoUninitialize();

   page->FinishProgress();
   return 0;
}


// WizardPage overrides

bool
AnalisysPage::OnSetActive()
{
   LOG_FUNCTION(AnalisysPage::OnSetActive);
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), 0);

   pos=0;

   HANDLE hA=CreateThread( 
                           NULL,0,
                           (LPTHREAD_START_ROUTINE) startAnalisys,
				               this,
                           0, 0 
                         );
   CloseHandle(hA);
   return true;
}



void
AnalisysPage::OnInit()
{
   LOG_FUNCTION(AnalisysPage::OnInit);
   HWND prog=GetDlgItem(hwnd,IDC_PROGRESS_ANALISYS);


   // calculate the # of locales
   for(long t=0;LOCALEIDS[t]!=0;t++)
   {
      //empty
   }
   
   SendMessage(prog,PBM_SETRANGE,0,MAKELPARAM(0,t)); 
};


bool
AnalisysPage::OnWizBack()
{
   LOG_FUNCTION(AnalisysPage::OnWizBack);
   GetWizard().SetNextPageID(hwnd,IDD_WELCOME);
   return true;
}

bool
AnalisysPage::OnWizNext()
{
   LOG_FUNCTION(AnalisysPage::OnWizNext);
   if (FAILED(hrError))
   {
      GetWizard().SetNextPageID(hwnd,IDD_FINISH);
   }
   else
   {
      GetWizard().SetNextPageID(hwnd,IDD_UPDATES_REQUIRED);
   }
   return true;
}


void AnalisysPage::StepProgress()
{
   LOG_FUNCTION(AnalisysPage::StepProgress);
   HWND prog=GetDlgItem(hwnd,IDC_PROGRESS_ANALISYS);
   SendMessage(prog,PBM_SETPOS,pos++,0);
}

void AnalisysPage::FinishProgress()
{
   LOG_FUNCTION(AnalisysPage::FinishProgress);
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),PSWIZB_NEXT);

   String result;
   if (FAILED(hrError))
   {
      result=String::format(IDS_IDC_ANALISYS_RESULT_INCOMPLETE);
      error=String::format(IDS_ANALISYS_ERROR,error.c_str());
   }
   else
   {
      result=String::format(IDS_IDC_ANALISYS_RESULT_COMPLETE);
   }
   
   Win::SetDlgItemText(hwnd,IDC_ANALISYS_RESULT,result);

   HWND text=GetDlgItem(hwnd,IDC_ANALISYS_RESULT);
   Win::ShowWindow(text,SW_SHOW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\previoussource\repairer.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class Repairer, represents "work items" to perform to repair display
// specifier objects.
//
// 7 Mar 2001 sburns



#ifndef REPAIRER_HPP_INCLUDED
#define REPAIRER_HPP_INCLUDED



class Repairer
{
   public:



   explicit   
   Repairer(
      const String& dcpromoCsvFilePath);


   
   void
   AddCreateContainerWorkItem(int localeId);


   
   void
   AddCreateObjectWorkItem(
      int            localeId,
      const String&  displaySpecifierObjectName);
      


   void
   AddDeleteObjectWorkItem(
      int            localeId,
      const String&  displaySpecifierObjectName);



   HRESULT
   ApplyRepairs();


      
   HRESULT
   BuildRepairFiles();



   private:


   typedef std::list<int>                    LocaleIdList;
   typedef std::pair<int, String>            LocaleIdObjectNamePair;
   typedef std::list<LocaleIdObjectNamePair> LocaleIdObjectNamePairList;
   
   String                     dcpromoCsvFilePath;
   LocaleIdList               containersToCreate;
   LocaleIdObjectNamePairList objectsToCreate; 


   
   bool
   IsLocaleInObjectsToCreateTable(int localeId) const;


   
   // not implemented: no copying allowed

   Repairer(const Repairer&);
   const Repairer& operator=(const Repairer&);
};



#endif   // REPAIRER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\finishpage.hpp ===
#ifndef FINISH_PAGE_HPP_INCLUDED
#define FINISH_PAGE_HPP_INCLUDED



class FinishPage : public WizardPage
{

   public:

   FinishPage
   (
      const bool someRepairWasRun_,
      const String &logPath_
   );

   protected:

   virtual ~FinishPage();


   // WizardPage overrides


   virtual
   bool
   OnSetActive();

   bool
   OnCommand(
   HWND        windowFrom,
   unsigned    controlIdFrom,
   unsigned    code);   

   virtual
   bool
   OnWizBack();


   private:
   bool someRepairWasRun;
   String logPath;

   // not defined: no copying allowed
   FinishPage(const FinishPage&);
   const FinishPage& operator=(const FinishPage&);
};



#endif   // FINISH_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\common.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// code common to several pages
//
// 12-16-97 sburns



// Sets the font of a given control in a dialog.
// 
// parentDialog - Dialog containing the control.
// 
// controlID - Res ID of the control for which the font will be
// changed.
// 
// font - handle to the new font for the control.

void
SetControlFont(HWND parentDialog, int controlID, HFONT font);



// Sets the font of a control to a large point bold font as per Wizard '97
// spec.
// 
// dialog - handle to the dialog that is the parent of the control
// 
// bigBoldResID - resource id of the control to change

void
SetLargeFont(HWND dialog, int bigBoldResID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\finishpage.cpp ===
#include "headers.hxx"
#include "FinishPage.hpp"
#include "resource.h"
#include "common.hpp"
#include "global.hpp"

FinishPage::FinishPage
   (
      const bool someRepairWasRun_,
      const String &logPath_
   )
   :
   someRepairWasRun(someRepairWasRun_),
   logPath(logPath_),
   WizardPage(
      IDD_FINISH,
      IDS_FINISH_PAGE_TITLE,
      IDS_FINISH_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(FinishPage);
}

FinishPage::~FinishPage()
{
   LOG_DTOR(FinishPage);
}


bool
FinishPage::OnSetActive()
{
   LOG_FUNCTION(FinishPage::OnSetActive);

   // hrError was set in previous pages
   if(FAILED(hrError))
   {
      if(someRepairWasRun)
      {
         Win::ShowWindow(GetDlgItem(hwnd,IDC_FILE),SW_SHOW);
         Win::ShowWindow(GetDlgItem(hwnd,IDC_CLICK),SW_SHOW);
         Win::SetDlgItemText( hwnd,IDC_CLICK, IDS_IDC_CLICK_FAILURE);
      }
      Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),
                                 PSWIZB_FINISH | PSWIZB_BACK);


      if(hrError!=E_FAIL)
      {
         error += L"\r\n" + GetErrorMessage(hrError);
      }
      
      Win::SetDlgItemText( hwnd,IDC_RESULT, error);

      Win::ShowWindow(GetDlgItem(hwnd,IDC_RESTART),SW_SHOW);
   }
   else
   {
      
      Win::SetDlgItemText( hwnd,IDC_RESULT, 
            String::format(IDC_RESULT_SUCCESS));

      Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),
                                 PSWIZB_FINISH);
      Win::ShowWindow(GetDlgItem(hwnd,IDC_FILE),SW_SHOW);
      Win::ShowWindow(GetDlgItem(hwnd,IDC_CLICK),SW_SHOW);
      Win::SetDlgItemText( hwnd,IDC_CLICK, IDS_IDC_CLICK_SUCCESS);
   }
   return true;
}

bool
FinishPage::OnCommand(
                     HWND        /*windowFrom*/,
                     unsigned    controlIdFrom,
                     unsigned    code
                 )
{
   LOG_FUNCTION(FinishPage::OnCommand);
   switch (controlIdFrom)
   {
      case IDC_OPEN_LOG:
      {
         if (code == BN_CLICKED)
         {
            HRESULT hr=S_OK;
            do
            {
               String csvLog = logPath + L"\\csv.log";
               String ldifLog = logPath + L"\\ldif.log";
               if (FS::FileExists(csvLog))
               {
                  hr=Notepad(csvLog);
                  BREAK_ON_FAILED_HRESULT(hr);
               }
               if (FS::FileExists(ldifLog))
               {
                  hr=Notepad(ldifLog);
                  BREAK_ON_FAILED_HRESULT(hr);
               }
            } while(0);
            if (FAILED(hr))
            {
               ShowError(hr,error);
            }
         }
      }
   }
   return true;
}



bool
FinishPage::OnWizBack()
{
   LOG_FUNCTION(FinishPage::OnWizBack);
   GetWizard().SetNextPageID(hwnd,IDD_WELCOME);
   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\display.cpp ===
// Display.cpp : Defines the entry point for the console application.
//

#include "headers.hxx"
#include <comdef.h>
#include <crtdbg.h>

#include "AdsiHelpers.hpp"
#include "CSVDSReader.hpp"
#include "AnalisysResults.hpp"
#include "Analisys.hpp"
#include "repair.hpp"
#include "resource.h"
#include "constants.hpp"
#include "WelcomePage.hpp"
#include "AnalisysPage.hpp"
#include "constants.hpp"
#include "UpdatesRequiredPage.hpp"
#include "UpdatesPage.hpp"
#include "FinishPage.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available

// don't change this: it is also the name of a mutex that the ui
// uses to determine if it is already running.

const wchar_t* RUNTIME_NAME = L"dspecup";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;

Popup popup(IDS_APP_TITLE, false);

// this is the mutex that indicates the program is running.

HANDLE appRunningMutex = INVALID_HANDLE_VALUE;



// these are the valid exit codes returned as the process exit code

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,
};





HRESULT
Start()
{
   LOG_FUNCTION(Start);

   HRESULT hr = S_OK;
   
   do
   {
      String targetDomainControllerName;
      String csvFileName,csv409Name;

      hr=GetInitialInformation(
                                 targetDomainControllerName,
                                 csvFileName,
                                 csv409Name
                              );

      BREAK_ON_FAILED_HRESULT(hr);

      AnalisysResults results;
      CSVDSReader csvReaderIntl;
      hr=csvReaderIntl.read(csvFileName.c_str(),LOCALEIDS);
      BREAK_ON_FAILED_HRESULT(hr);
   
      CSVDSReader csvReader409;
      hr=csvReader409.read(csv409Name.c_str(),LOCALE409);
      BREAK_ON_FAILED_HRESULT(hr);

      String rootContainerDn,ldapPrefix,domainName;
      hr=InitializeADSI(
            targetDomainControllerName,
            ldapPrefix,
            rootContainerDn,
            domainName);
      BREAK_ON_FAILED_HRESULT(hr);

      String reportName;

      hr=GetFileName(L"RPT",reportName);
      BREAK_ON_FAILED_HRESULT(hr);

      Analisys analisys(
         csvReader409, 
         csvReaderIntl,
         ldapPrefix,
         rootContainerDn,
         results,
         &reportName);
   
      hr=analisys.run();
      BREAK_ON_FAILED_HRESULT(hr);

      String ldiffName;

      hr=GetFileName(L"LDF",ldiffName);
      BREAK_ON_FAILED_HRESULT(hr);

      String csvName;

      hr=GetFileName(L"CSV",csvName);
      BREAK_ON_FAILED_HRESULT(hr);
   
      String saveName;

      hr=GetFileName(L"SAV",saveName);
      BREAK_ON_FAILED_HRESULT(hr);

      String logPath;

      hr=GetMyDocuments(logPath);
      if ( FAILED(hr) )
      {
         hr=Win::GetTempPath(logPath);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));
      }

      Repair repair(
         csvReader409, 
         csvReaderIntl,
         domainName,
         rootContainerDn,
         results,
         ldiffName,
         csvName,
         saveName,
         logPath);

      hr=repair.run();
      BREAK_ON_FAILED_HRESULT(hr);

      hr=SetPreviousSuccessfullRun(
                                    ldapPrefix,
                                    rootContainerDn
                                  );
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      ShowError(hr,error);
   }

   LOG_HRESULT(hr);
   return hr;
}

HRESULT
StartUI()
{
   LOG_FUNCTION(StartUI);

   HRESULT hr = S_OK;

   String rootContainerDn,ldapPrefix,domainName;

   do
   {
      String targetDomainControllerName;
      String csvFileName,csv409Name;

      hr=GetInitialInformation(
                                 targetDomainControllerName,
                                 csvFileName,
                                 csv409Name
                              );
      BREAK_ON_FAILED_HRESULT(hr);
   
      AnalisysResults results;
      CSVDSReader csvReaderIntl;
      hr=csvReaderIntl.read(csvFileName.c_str(),LOCALEIDS);
      BREAK_ON_FAILED_HRESULT(hr);
   
      CSVDSReader csvReader409;
      hr=csvReader409.read(csv409Name.c_str(),LOCALE409);
      BREAK_ON_FAILED_HRESULT(hr);

   
      hr=InitializeADSI(
            targetDomainControllerName,
            ldapPrefix,
            rootContainerDn,
            domainName);
      BREAK_ON_FAILED_HRESULT(hr);



      Wizard wiz(
                  IDS_WIZARD_TITLE,
                  IDB_BANNER16,
                  IDB_BANNER256,
                  IDB_WATERMARK16,
                  IDB_WATERMARK256
                );



      wiz.AddPage(new WelcomePage());

      String reportName;

      hr=GetFileName(L"RPT",reportName);
      BREAK_ON_FAILED_HRESULT(hr);

   
      wiz.AddPage(
                     new   AnalisysPage
                           (
                              csvReader409,
                              csvReaderIntl,
                              ldapPrefix,
                              rootContainerDn,
                              results,
                              reportName
                           )
                 );


      wiz.AddPage(
                     new UpdatesRequiredPage
                     (
                        reportName,
                        results
                     )
                 );

      String ldiffName;

      hr=GetFileName(L"LDF",ldiffName);
      BREAK_ON_FAILED_HRESULT(hr);

      String csvName;

      hr=GetFileName(L"CSV",csvName);
      BREAK_ON_FAILED_HRESULT(hr);

      String saveName;

      hr=GetFileName(L"SAV",saveName);
      BREAK_ON_FAILED_HRESULT(hr);


      String logPath;

      hr=GetMyDocuments(logPath);
      if ( FAILED(hr) )
      {
         hr=Win::GetTempPath(logPath);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));
      }

      bool someRepairWasRun=false;

      wiz.AddPage(
                     new   UpdatesPage
                           (
                              csvReader409,
                              csvReaderIntl,
                              domainName,
                              rootContainerDn,
                              ldiffName,
                              csvName,
                              saveName,
                              logPath,
                              results,
                              &someRepairWasRun
                           )
                 );

      wiz.AddPage(
                     new FinishPage(
                                       someRepairWasRun,
                                       logPath
                                   )
                 );


      hr=wiz.ModalExecute(Win::GetDesktopWindow());


      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      ShowError(hr,error);
   }
   else
   {
      if(FAILED(hrError))
      {
         // The error has already been shown to the
         // user, we have only to return it
         hr=hrError;
      }
      else
      {

         hr=SetPreviousSuccessfullRun(
                                       ldapPrefix,
                                       rootContainerDn
                                     );
         if (FAILED(hr))
         {
            ShowError(hr,error);
         }
      }
   }

   LOG_HRESULT(hr);
   return hr;
}




int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR     lpszCmdLine,
   int         /* nCmdShow */)
{
   LOG_FUNCTION(WinMain);

   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;
   HRESULT hr;

   do
   {
      try
      {
         String cmdLine(lpszCmdLine);
         String noUI=String::format(IDS_NOUI);
         if (*lpszCmdLine!=0 && cmdLine.icompare(noUI)!=0)
         {
            error=String::format(IDS_USAGE);
            ShowError(E_FAIL,error);
            exitCode = EXIT_CODE_UNSUCCESSFUL;
            break;
         }


         hr = Win::CreateMutex(0, true, RUNTIME_NAME, appRunningMutex);
         if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
         {
            // The application is already running
            error=String::format(IDS_ALREADY_RUNNING);
            ShowError(E_FAIL,error);
            exitCode = EXIT_CODE_UNSUCCESSFUL;
            break;
         }
         else
         {
            hr = ::CoInitialize(0);
            ASSERT(SUCCEEDED(hr));

            INITCOMMONCONTROLSEX sex;
            sex.dwSize = sizeof(sex);      
            sex.dwICC  = ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES;
            BOOL init = ::InitCommonControlsEx(&sex);
            ASSERT(init);

            setReplaceW2KStrs();      

            if (*lpszCmdLine==0)
            {
               hr = StartUI();
            }
            else
            {
               hr = Start();
            }
            //hr=makeStrings();
            if (SUCCEEDED(hr))
            {
               exitCode = EXIT_CODE_SUCCESSFUL;
            }
            else
            {
               exitCode = EXIT_CODE_UNSUCCESSFUL;
            }
            CoUninitialize(); 
         }
      }
      catch( std::bad_alloc )
      {
        // Since we are in an out of memory condition.
        // we will not show any messages.
        // The allocation functions have already
        // shown the user this condition
        exitCode = EXIT_CODE_UNSUCCESSFUL;
      }
   } while(0);

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDB_WATERMARK256                110
#define IDB_BANNER256                   111
#define IDB_WATERMARK16                 112
#define IDB_BANNER16                    113
#define IDD_WELCOME                     115
#define IDD_ANALISYS                    116
#define IDD_UPDATES_REQUIRED            117
#define IDD_UPDATES                     118
#define IDI_BIG_WARN                    119
#define IDD_FINISH                      119
#define IDC_TEST                        1000
#define IDC_BIG_BOLD_TITLE              1001
#define IDC_PROGRESS_ANALISYS           1001
#define IDC_INTRO1                      1002
#define IDC_ANALISYS_COMPLETE           1002
#define IDC_ANALISYS_RESULT             1002
#define IDC_INTRO2                      1003
#define IDC_DELETE_OBJECTS              1003
#define IDC_CREATE_OBJECTS              1004
#define IDC_UPDATE_OBJECTS              1005
#define IDC_VIEW_DETAILS                1007
#define IDC_UPDATE_COMPLETE             1008
#define IDC_OPEN_LOG                    1009
#define IDC_FILE                        1009
#define IDC_RESTART                     1010
#define IDC_RESULT                      1011
#define IDC_LOG                         1012
#define IDC_CLICK                       1012
#define IDC_PROGRESS_REPAIR             1017
#define IDC_BULLET1                     1035
#define IDC_BULLET2                     1036
#define IDC_BULLET3                     1037
#define IDS_APP_TITLE                   1501
#define IDS_CANT_TARGET_MACHINE         1502
#define IDS_DCPROMO_CSV_FILE_MISSING    1503
#define IDS_ERROR_LOOKING_FOR_CSV_FILE  1504
#define IDS_TARGET_IS_NOT_DC            1505
#define IDS_UNABLE_TO_CONNECT_TO_DC     1506
#define IDS_UNABLE_TO_READ_DIRECTORY_INFO 1507
#define IDS_ERROR_BINDING_TO_OBJECT     1508
#define IDS_ERROR_ENTRY                 1509
#define IDS_ERROR_GETING_FILE_NAME      1510
#define IDS_INVALID_CSV_UNICODE_ID      1511
#define IDS_MISSING_LOCALES             1512
#define IDS_OBJECT_NOT_FOUND_IN_CSV     1513
#define IDS_PROPERTY_NOT_FOUND_IN_CSV   1514
#define IDS_QUOTES_NOT_CLOSED           1515
#define IDS_COULD_NOT_CREATE_CSV        1516
#define IDS_NO_COMA_IN_CSV_LINE         1517
#define IDS_NO_CSV_VALUE                1518
#define IDS_ERROR_BINDING_TO_CONTAINER  1519
#define IDS_COULD_NOT_START_EXE         1521
#define IDS_EXE_NOT_FOUND               1522
#define IDS_NO_WORK_PATH                1524
#define IDS_ERROR_IMP_EXP_FILE          1525
#define IDS_COULD_NOT_CREATE_FILE       1526
#define IDS_NO_DOMAIN                   1527
#define IDS_WELCOME_PAGE_TITLE          1529
#define IDS_WELCOME_PAGE_SUBTITLE       1530
#define IDS_WIZARD_TITLE                1531
#define IDS_BIG_BOLD_FONT_NAME          1532
#define IDS_BIG_BOLD_FONT_SIZE          1533
#define IDS_ANALISYS_PAGE_TITLE         1534
#define IDS_ANALISYS_PAGE_SUBTITLE      1535
#define IDS_IDC_ANALISYS_COMPLETE       1536
#define IDS_UPDATES_REQUIRED_TITLE      1537
#define IDS_UPDATES_REQUIRED_SUBTITLE   1538
#define IDS_IDC_LOG_DETAILS             1539
#define IDS_IDC_LOG_ERRORS              1540
#define IDS_IDC_RESULT_SUCCESS          1541
#define IDS_IDC_RESULT_FAILURE          1542
#define IDS_UPDATES_REQUIRED_PAGE_TITLE 1543
#define IDS_UPDATES_REQUIRED_PAGE_SUBTITLE 1544
#define IDS_CREATE                      1545
#define IDS_UPDATE                      1546
#define IDS_DELETE                      1547
#define IDS_OBJECTS                     1548
#define IDS_FINISH_PAGE_SUBTITLE        1549
#define IDS_FINISH_PAGE_TITLE           1550
#define IDS_UPDATES_PAGE_TITLE          1551
#define IDS_UPDATES_PAGE_SUBTITLE       1552
#define IDS_CONTAINERS                  1553
#define IDS_AND                         1554
#define IDS_CREATED_FORMAT              1555
#define IDS_NUMBER_FORMAT               1556
#define IDS_VALUES                      1557
#define IDS_RPT_OBJECT_FORMAT           1558
#define IDS_RPT_CONTAINER_FORMAT        1559
#define IDS_RPT_ADD_VALUE_FORMAT        1560
#define IDS_RPT_DEL_VALUE_FORMAT        1561
#define IDS_RPT_CONFLICTINGXP           1563
#define IDS_RPT_ACTIONS                 1564
#define IDS_RPT_CREATEW2K               1565
#define IDS_RPT_CREATEXP                1566
#define IDS_RPT_CONTAINERS              1567
#define IDS_RPT_HEADER                  1568
#define IDS_CSVDE_LDIFDE_ERROR_COMPLETE 1569
#define IDS_CSVDE_LDIFDE_ERROR_BASIC    1570
#define IDS_IDC_ANALISYS_RESULT_INCOMPLETE 1571
#define IDS_IDC_ANALISYS_RESULT_COMPLETE 1572
#define IDS_ANALISYS_ERROR              1573
#define IDS_REPAIR_ERROR                1574
#define IDS_IDC_CLICK_SUCCESS           1575
#define IDS_IDC_CLICK_FAILURE           1576
#define IDC_RESULT_SUCCESS              1577
#define IDS_ALREADY_UPDATED             1578
#define IDS_USAGE                       1579
#define IDS_NOUI                        1580
#define IDS_ALREADY_RUNNING             1581
#define IDS_VALUE_NOT_IN_CSV            1582
#define IDS_NO_VALUE_IN_CSV             1583
#define IDS_MANY_CSV_VALUES             1584
#define IDS_CANT_WRITE_OBJECT_VERSION   1585
#define IDS_CANT_READ_OBJECT_VERSION    1586
#define IDS_NOT_ONE_CSV_VALUE           1587
#define IDS_RPT_CUSTOMIZED              1588
#define IDS_RPT_EXTRANEOUS              1589
#define IDS_RPT_VALUE_FORMAT            1590
#define IDS_NO_ANALISYS                 1591
#define IDS_OUT_OF_MEMORY               1592

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\welcomepage.cpp ===
#include "headers.hxx"
#include "WelcomePage.hpp"
#include "resource.h"
#include "common.hpp"
#include "global.hpp"


WelcomePage::WelcomePage()
   :
   WizardPage(
      IDD_WELCOME,
      IDS_WELCOME_PAGE_TITLE,
      IDS_WELCOME_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(WelcomePage);
}

WelcomePage::~WelcomePage()
{
   LOG_DTOR(WelcomePage);
}


// WizardPage overrides

bool
WelcomePage::OnSetActive()
{
   LOG_FUNCTION(WelcomePage::OnSetActive);
   EnableWindow(GetDlgItem(Win::GetParent(hwnd),IDCANCEL),true);
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_NEXT);
   return true;
}

void
WelcomePage::OnInit()
{
   LOG_FUNCTION(WelcomePage::OnInit);
   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),     
      0,
      String::load(IDS_WIZARD_TITLE));
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\showerror.cpp ===
void ShowError(HRESULT hr,
               const String &message)
{
   LOG_FUNCTION(ShowError);

   if(hr==E_FAIL)
   {
      popup.Error(Win::GetDesktopWindow(),message);
   }
   else
   {
      if(message.empty())
      {
         popup.Error(Win::GetDesktopWindow(),GetErrorMessage(hr));
      }
      else
      {
         popup.Error(Win::GetDesktopWindow(),hr,message);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\updatesrequiredpage.hpp ===
#ifndef UPDATES_REQUIRED_PAGE_HPP_INCLUDED
#define UPDATES_REQUIRED_PAGE_HPP_INCLUDED

#include "AnalisysResults.hpp"

class UpdatesRequiredPage : public WizardPage
{

   public:

      UpdatesRequiredPage
      (
         const String& reportName_,
         AnalisysResults &results_
      );

   protected:

      virtual ~UpdatesRequiredPage();


      // WizardPage overrides


      virtual
      bool
      OnSetActive();

      virtual
      void
      OnInit();

      virtual
      bool
      OnWizBack();

      bool
      OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   private:
   
      AnalisysResults &results;
      String reportName;
      

      void
      ShowReport();

      // not defined: no copying allowed
      UpdatesRequiredPage(const UpdatesRequiredPage&);
      const UpdatesRequiredPage& operator=(const UpdatesRequiredPage&);
};



#endif   // UPDATES_REQUIRED_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\inc\dsutils.h ===
// libraryname component of the ProgID of the dsutils COM objects
// use to compose ProgIDs, e.g. DSUTILS_LIBNAME_STRING L".yourclassname.ver"

#define DSUTILS_LIBNAME_STRING L"DSUtils"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\welcomepage.hpp ===
#ifndef WELCOME_PAGE_HPP_INCLUDED
#define WELCOME_PAGE_HPP_INCLUDED



class WelcomePage : public WizardPage
{

   public:

   WelcomePage();

   protected:

   virtual ~WelcomePage();


   // WizardPage overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnSetActive();


   private:

   // not defined: no copying allowed
   WelcomePage(const WelcomePage&);
   const WelcomePage& operator=(const WelcomePage&);
};



#endif   // WELCOME_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\updatespage.cpp ===
#include "headers.hxx"
#include "UpdatesPage.hpp"
#include "resource.h"
#include "common.hpp"

#include "repair.hpp"
#include "AnalisysResults.hpp"
#include "CSVDSReader.hpp"


UpdatesPage::UpdatesPage
   (
      const CSVDSReader& csvReader409_,
      const CSVDSReader& csvReaderIntl_,
      const String& domain_,
      const String& rootContainerDn_,
      const String& ldiffName_,
      const String& csvName_,
      const String& saveName_,
      const String& logPath_,
      AnalisysResults& res,
      bool *someRepairWasRun_
   )
   :
   csvReader409(csvReader409_),
   csvReaderIntl(csvReaderIntl_),
   domain(domain_),
   rootContainerDn(rootContainerDn_),
   ldiffName(ldiffName_),
   csvName(csvName_),
   saveName(saveName_),
   logPath(logPath_),
   results(res),
   someRepairWasRun(someRepairWasRun_),
   WizardPage
   (
      IDD_UPDATES,
      IDS_UPDATES_PAGE_TITLE,
      IDS_UPDATES_PAGE_SUBTITLE,
      true
   )
{
   LOG_CTOR(UpdatesPage);
}

UpdatesPage::~UpdatesPage()
{
   LOG_DTOR(UpdatesPage);
}


long WINAPI startRepair(long arg)
{
   LOG_FUNCTION(startRepair);

   UpdatesPage *page=(UpdatesPage *)arg;

   HRESULT hr=S_OK;
   do
   {
      // CoInitialize must be called per thread
      hr = ::CoInitialize(0);
      ASSERT(SUCCEEDED(hr));

      Repair   repair
               (
                  page->csvReader409, 
                  page->csvReaderIntl,
                  page->domain,
                  page->rootContainerDn,
                  page->results,
                  page->ldiffName,
                  page->csvName,
                  page->saveName,
                  page->logPath,
                  page,
                  page->someRepairWasRun
               );


      HWND prog=GetDlgItem(page->hwnd,IDC_PROGRESS_REPAIR);
   
      long nProgress=repair.getTotalProgress();
      SendMessage(prog,PBM_SETRANGE,0,MAKELPARAM(0, nProgress)); 
      hr=repair.run();

      CoUninitialize();

      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   hrError=hr;
   page->FinishProgress();
   return 0;
}


bool
UpdatesPage::OnSetActive()
{
   LOG_FUNCTION(UpdatesPage::OnSetActive);

   EnableWindow(GetDlgItem(Win::GetParent(hwnd),IDCANCEL),false);
   Win::PropSheet_SetWizButtons(
                                 Win::GetParent(hwnd),
                                 0
                               );

   pos=0;

   HANDLE hA=CreateThread( 
                           NULL,0,
                           (LPTHREAD_START_ROUTINE) startRepair,
				               this,
                           0, 0 
                         );
   CloseHandle(hA);
   return true;
}


void UpdatesPage::StepProgress(long steps)
{
   LOG_FUNCTION(UpdatesPage::StepProgress);

   HWND prog=GetDlgItem(hwnd,IDC_PROGRESS_REPAIR);
   pos+=steps;
   SendMessage(prog,PBM_SETPOS,pos,0);
}


void UpdatesPage::FinishProgress()
{
   LOG_FUNCTION(UpdatesPage::FinishProgress);
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),PSWIZB_NEXT);

   if (FAILED(hrError))
   {
      error=String::format(IDS_REPAIR_ERROR,error.c_str());
   }


   HWND text=GetDlgItem(hwnd,IDC_UPDATE_COMPLETE);
   Win::ShowWindow(text,SW_SHOW);

   Win::PropSheet_SetWizButtons(
                                 Win::GetParent(hwnd),
                                 PSWIZB_NEXT
                               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\updatespage.hpp ===
#ifndef UPDATES_PAGE_HPP_INCLUDED
#define UPDATES_PAGE_HPP_INCLUDED

struct AnalisysResults;
class CSVDSReader;

class UpdatesPage : public WizardPage
{

   public:

   UpdatesPage
   (
      const CSVDSReader& csvReader409_,
      const CSVDSReader& csvReaderIntl_,
      const String& domain_,
      const String& rootContainerDn_,
      const String& ldiffName_,
      const String& csvName_,
      const String& saveName_,
      const String& logPath_,
      AnalisysResults& res_,
      bool *someRepairWasRun_
   );

   void StepProgress(long steps);
   void FinishProgress();


   protected:

   friend long WINAPI startRepair(long arg);
   virtual ~UpdatesPage();


   // WizardPage overrides


   virtual
   bool
   OnSetActive();



   private:
   
   long pos;

   AnalisysResults& results;
   const CSVDSReader& csvReader409;
   const CSVDSReader& csvReaderIntl;
   const String domain;
   const String rootContainerDn;
   const String ldiffName;
   const String csvName;
   const String saveName;
   const String logPath;
   bool *someRepairWasRun;


   // not defined: no copying allowed
   UpdatesPage(const UpdatesPage&);
   const UpdatesPage& operator=(const UpdatesPage&);
};



#endif   // UPDATES_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\displayspecifierupgrade\uiarchive\updatesrequiredpage.cpp ===
#include "headers.hxx"
#include "UpdatesRequiredPage.hpp"
#include "resource.h"
#include "common.hpp"
#include "AnalisysResults.hpp"

UpdatesRequiredPage::UpdatesRequiredPage
   (
      const String& reportName_,
      AnalisysResults &results_
   )
   :
   reportName(reportName_),
   results(results_),
   WizardPage
   (
      IDD_UPDATES_REQUIRED,
      IDS_UPDATES_REQUIRED_PAGE_TITLE,
      IDS_UPDATES_REQUIRED_PAGE_SUBTITLE,
      true
   )
{
   LOG_CTOR(UpdatesRequiredPage);
}

UpdatesRequiredPage::~UpdatesRequiredPage()
{
   LOG_DTOR(UpdatesRequiredPage);
}


// WizardPage overrides

bool
UpdatesRequiredPage::OnSetActive()
{
   LOG_FUNCTION(UpdatesRequiredPage::OnSetActive);

   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),
                                 PSWIZB_NEXT | PSWIZB_BACK);
   return true;
}

bool
UpdatesRequiredPage::OnCommand(
                                 HWND        /*windowFrom*/,
                                 unsigned    controlIdFrom,
                                 unsigned    code
                              )
{
   LOG_FUNCTION(UpdatesRequiredPage::OnCommand);
   switch (controlIdFrom)
   {
      case IDC_VIEW_DETAILS:
      {
         if (code == BN_CLICKED)
         {
            ShowReport();
         }
      }
   }
   return true;
}


bool
UpdatesRequiredPage::OnWizBack()
{
   LOG_FUNCTION(UpdatesRequiredPage::OnWizBack);
   GetWizard().SetNextPageID(hwnd,IDD_ANALISYS);
   return true;
}


void
UpdatesRequiredPage::OnInit()
{
   LOG_FUNCTION(UpdatesRequiredPage::OnInit);

   
   long created = results.createW2KObjects.size() + 
                  results.createXPObjects.size();

   long updated = results.objectActions.size();

   long containers = results.createContainers.size();

   String sCreated,sUpdated;

   if( containers==0)
   {
      sCreated = String::format( 
                                 String::load(IDS_NUMBER_FORMAT).c_str(),
                                 created,
                                 String::load(IDS_OBJECTS).c_str() 
                               );
   }
   else
   {
      sCreated = String::format( 
                                 String::load(IDS_CREATED_FORMAT).c_str(),
                                 created,
                                 String::load(IDS_OBJECTS).c_str(),
                                 String::load(IDS_AND).c_str(), 
                                 containers,
                                 String::load(IDS_CONTAINERS).c_str() 
                               );
   }


   sUpdated = String::format( 
                              String::load(IDS_NUMBER_FORMAT).c_str(),
                              updated,
                              String::load(IDS_VALUES).c_str() 
                            );



   Win::SetDlgItemText( hwnd,IDC_CREATE_OBJECTS, sCreated);
   
   Win::SetDlgItemText( hwnd,IDC_UPDATE_OBJECTS, sUpdated);


   HFONT
   bulletFont = CreateFont(
                   0,
                   0,
                   0,
                   0,
                   FW_NORMAL,
                   0,
                   0,
                   0,
                   SYMBOL_CHARSET,
                   OUT_CHARACTER_PRECIS,
                   CLIP_CHARACTER_PRECIS,
                   PROOF_QUALITY,
                   VARIABLE_PITCH|FF_DONTCARE,
                   L"Marlett");

   if (bulletFont)
   {
      Win::SetDlgItemText(hwnd,IDC_BULLET1,L"h");
      Win::SetDlgItemText(hwnd,IDC_BULLET2,L"h");
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET1), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET2), bulletFont, true);
   }

};



// This function is void because if we cannot show
// the report, this is not a fatal error
void
UpdatesRequiredPage::ShowReport()
{
   LOG_FUNCTION(UpdatesRequiredPage::ShowReport);
   HRESULT hr=S_OK;
   do
   {
      hr=Notepad(reportName);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   if (FAILED(hr))
   {
      ShowError(hr,error);
   }

   LOG_HRESULT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\common.hpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// common routines 
//
// sburns 5-3-99



void
SetComError(
   const String&  desciption,
   DWORD          helpContext = 0);

void
SetComError(
   unsigned descriptionMessageResID,
   DWORD    helpContext = 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\common.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// common routines
//
// sburns 5-3-99



#include "headers.hxx"
#include "common.hpp"



void
SetComError(
   unsigned descriptionMessageResID,
   DWORD    helpContext)
{
   SetComError(String::load(descriptionMessageResID), helpContext);
}



void
SetComError(
   const String&  description,
   DWORD          helpContext)
{
   LOG_FUNCTION2(SetComError, description);

   ICreateErrorInfo* cei = 0;
   HRESULT hr = S_OK;

   do
   {
      hr = ::CreateErrorInfo(&cei);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetGUID(IID_ICloneSecurityPrincipal);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetSource(PROGID_VERSION_STRING);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         cei->SetDescription(
            const_cast<String::value_type*>(description.c_str()));
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetHelpFile(L"" /* HELPFILE_NAME */ );
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetHelpContext(helpContext);
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IErrorInfo> ei;
      hr = ei.AcquireViaQueryInterface(*cei);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = ::SetErrorInfo(0, ei);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (cei)
   {
      cei->Release();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\copyuser.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Implementation of ICloneSecurityPrincipal::CopyDownlevelUserProperties
//
// sburns 5-14-99



#include "headers.hxx"
#include "resource.h"
#include "common.hpp"
#include "implmain.hpp"



// caller must close the handle with SamCloseHandle

HRESULT
OpenSamUser(
   const String&  samName,
   SAM_HANDLE     domainSamHandle,
   SAM_HANDLE&    resultSamHandle)
{
   LOG_FUNCTION2(OpenSamUser, samName);
   ASSERT(!samName.empty());
   ASSERT(domainSamHandle != INVALID_HANDLE_VALUE);
   ASSERT(resultSamHandle == INVALID_HANDLE_VALUE);

   resultSamHandle = INVALID_HANDLE_VALUE;   

   HRESULT       hr   = S_OK;
   ULONG*        rids = 0;   
   PSID_NAME_USE use  = 0;   
   do
   {
      LOG(L"Calling SamLookupNamesInDomain");

      UNICODE_STRING userName;
      ::RtlInitUnicodeString(&userName, samName.c_str());

      hr =
         NtStatusToHRESULT(
            ::SamLookupNamesInDomain(
               domainSamHandle,
               1,
               &userName,
               &rids,
               &use));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_SAM_USER_NOT_FOUND,
               samName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }
      if (!use || *use != SidTypeUser)    // prefix 111381
      {
         hr = Win32ToHresult(ERROR_NO_SUCH_USER);
         SetComError(
            String::format(
               IDS_SAM_NAME_IS_NOT_USER,
               samName.c_str()));
         break;
      }

      LOG(L"Calling SamOpenUser");

      hr = 
         NtStatusToHRESULT(
            ::SamOpenUser(
                domainSamHandle,
                MAXIMUM_ALLOWED,
                rids[0],
                &resultSamHandle));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_OPEN_SAM_USER_FAILED,
               samName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      ASSERT(resultSamHandle != INVALID_HANDLE_VALUE);
   }
   while (0);

   if (rids)
   {
      ::SamFreeMemory(rids);
   }
   if (use)
   {
      ::SamFreeMemory(use);
   }

   return hr;
}



HRESULT
CloneSecurityPrincipal::DoCopyDownlevelUserProperties(
   const String& srcSamName,
   const String& dstSamName,
   long          flags)
{
   LOG_FUNCTION(CloneSecurityPrincipal::DoCopyDownlevelUserProperties);

   if (srcSamName.empty())
   {
      SetComError(IDS_MISSING_SRC_SAM_NAME);
      return E_INVALIDARG;
   }

   if (flags)
   {
      // not used, should be 0
      SetComError(IDS_FLAGS_ARE_UNUSED);
      return E_INVALIDARG;
   }

   if (!connection || !connection->IsConnected())
   {
      SetComError(IDS_MUST_CONNECT_FIRST);
      return Win32ToHresult(ERROR_ONLY_IF_CONNECTED);
   };

   // At this point, the Computer objects contain the normalized
   // source and destination DC names, and their domains, and any
   // necessary authenticated connections to those DCs have been
   // established.

   HRESULT hr = S_OK;
   SAM_HANDLE userSamHandle = INVALID_HANDLE_VALUE;
   USER_ALL_INFORMATION* allInfo = 0;

   do
   {
      // get a handle to the source user

      hr =
         OpenSamUser(
            srcSamName,
            connection->srcDomainSamHandle,
            userSamHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling SamQueryInformationUser");

      hr =
         NtStatusToHRESULT(
            ::SamQueryInformationUser(
               userSamHandle,
               UserAllInformation,
               reinterpret_cast<void**>(&allInfo)));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_QUERY_SAM_USER_FAILED,
               srcSamName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      ::SamCloseHandle(userSamHandle);
      userSamHandle = INVALID_HANDLE_VALUE;

      // get a handle to the target user

      hr =
         OpenSamUser(
            dstSamName,
            connection->dstDomainSamHandle,
            userSamHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      
      ULONG* rids = 0;
      PSID_NAME_USE use = 0;

      UNICODE_STRING userName;
         ::RtlInitUnicodeString(&userName, dstSamName.c_str());

      hr =
         NtStatusToHRESULT(
            ::SamLookupNamesInDomain(
               connection->dstDomainSamHandle,
               1,
               &userName,
               &rids,
               &use));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_SAM_USER_NOT_FOUND,
               dstSamName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }
      if (*use != SidTypeUser)
      {
         hr = Win32ToHresult(ERROR_NO_SUCH_USER);
         SetComError(
            String::format(
               IDS_SAM_NAME_IS_NOT_USER,
               dstSamName.c_str()));
         break;
      }

      allInfo->WhichFields =
            USER_ALL_FULLNAME
         |  USER_ALL_ADMINCOMMENT
         |  USER_ALL_USERCOMMENT
         |  USER_ALL_HOMEDIRECTORY
         |  USER_ALL_HOMEDIRECTORYDRIVE
         |  USER_ALL_SCRIPTPATH
         |  USER_ALL_PROFILEPATH
         |  USER_ALL_WORKSTATIONS
         |  USER_ALL_LOGONHOURS
         //  USER_ALL_BADPASSWORDCOUNT
        //|  USER_ALL_PASSWORDCANCHANGE
        //|  USER_ALL_PASSWORDMUSTCHANGE
        //|  USER_ALL_USERACCOUNTCONTROL

         // this is the reason for all this nonsense
         |  USER_ALL_PARAMETERS

         |  USER_ALL_COUNTRYCODE
         |  USER_ALL_CODEPAGE
         //|  USER_ALL_PASSWORDEXPIRED*/
         ;

         if( *rids != 500 )
            allInfo->WhichFields |=  USER_ALL_ACCOUNTEXPIRES;

         if (rids)
         {
            ::SamFreeMemory(rids);
         }
         if (use)
         {
            ::SamFreeMemory(use);
         }

      // @@ why is user cannot change password not transferring?

      LOG(L"Calling SamSetInformationUser");

      hr =
         NtStatusToHRESULT(
            ::SamSetInformationUser(
               userSamHandle,
               UserAllInformation,
               allInfo));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_SET_SAM_USER_FAILED,
               dstSamName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }
   }
   while (0);

   if (userSamHandle != INVALID_HANDLE_VALUE)
   {
      ::SamCloseHandle(userSamHandle);
   }
   if (allInfo)
   {
      ::SamFreeMemory(allInfo);
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\dllmain.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// DllMain and COM DllXxx functions
//
// sburns 5-3-99



#include "headers.hxx"
#include "implmain.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"clonepr";

DWORD DEFAULT_LOGGING_OPTIONS = OUTPUT_MUTE;

TCHAR   g_szFileName[MAX_PATH];


struct REG_DATA
{
    const wchar_t *keyName;
    const wchar_t *valueName;
    const wchar_t *value;
};



const REG_DATA g_rgEntries[] =
{
   {
      L"CLSID\\" CLSID_STRING,
      0,
      CLASSNAME_STRING
   },
   { 
      L"CLSID\\" CLSID_STRING L"\\InprocServer32",
      0,
      g_szFileName
   },
   { 
      L"CLSID\\" CLSID_STRING L"\\InprocServer32",
      L"ThreadingModel",
      L"Apartment"
   },
   {
      L"CLSID\\" CLSID_STRING L"\\ProgID",
      0,
      PROGID_VERSION_STRING
   },
   {
      L"CLSID\\" CLSID_STRING L"\\VersionIndependentProgID",
      0,
      PROGID_STRING
   },
   {
      PROGID_VERSION_STRING,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_VERSION_STRING L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_STRING L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING L"\\CurVer",
      0,
      PROGID_VERSION_STRING
   },

   // register for IADsSID
   {
      PROGID_VERSION_STRING_ADSSID,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_VERSION_STRING_ADSSID L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING_ADSSID,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_STRING_ADSSID L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING_ADSSID L"\\CurVer",
      0,
      PROGID_VERSION_STRING_ADSSID
   },

   // register for IADsError
   {
      PROGID_VERSION_STRING_ADSERROR,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_VERSION_STRING_ADSERROR L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING_ADSERROR,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_STRING_ADSERROR L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING_ADSERROR L"\\CurVer",
      0,
      PROGID_VERSION_STRING_ADSERROR
   }
};

const int g_cEntries = sizeof(g_rgEntries)/sizeof(*g_rgEntries);

static
HRESULT
Unregister(const REG_DATA *rgEntries, int cEntries)
{
   LOG_FUNCTION(Unregister);

   LOG(L"Calling UnRegisterTypeLib");

   HRESULT hr =
      ::UnRegisterTypeLib(LIBID_CloneSecurityPrincipalLib, 1, 0, 0, SYS_WIN32);

   LOG_HRESULT(hr);

   // don't break: continue on attempting to remove as much as possible
   // of our registration

   bool success = SUCCEEDED(hr);
   for (int i = cEntries - 1; i >= 0; i--)
   {
      LONG err = ::RegDeleteKey(HKEY_CLASSES_ROOT, rgEntries[i].keyName);
      if (err != ERROR_SUCCESS)
      {
         success = false;
      }
   }

   return success ? S_OK : S_FALSE;
}



static HRESULT Register(const REG_DATA *rgEntries, int cEntries)
{

   BOOL bSuccess = TRUE;
   HRESULT hr = S_OK;   // 447822 prefix warning
   const REG_DATA *pEntry = rgEntries;

    while (pEntry < rgEntries + cEntries)
    {
        HKEY hkey;
        LONG err = RegCreateKey(HKEY_CLASSES_ROOT,
                                pEntry->keyName,
                               &hkey);
        if (err == ERROR_SUCCESS)
        {
            if (pEntry->value)
                err = RegSetValueEx(hkey, 
                                pEntry->valueName,
                                0, REG_SZ, 
                                (const BYTE*)pEntry->value,
                                (lstrlen(pEntry->value) + 1) * sizeof(TCHAR));
            if (err != ERROR_SUCCESS)
            {
                bSuccess = FALSE;
                Unregister(rgEntries, static_cast<int>(1 + pEntry - rgEntries));
            }
            RegCloseKey(hkey);
        }
        if (err != ERROR_SUCCESS)
        {
            bSuccess = FALSE;
            if (pEntry != rgEntries)
                Unregister(rgEntries, static_cast<int>(pEntry - rgEntries));
        }
        pEntry++;
    };

   if (bSuccess)
	{
      OLECHAR g_wszFileName[MAX_PATH];      
      lstrcpy(g_wszFileName, g_szFileName);     
		ITypeLib *ptl = 0;
		hr = LoadTypeLib(g_wszFileName, &ptl);
		if (SUCCEEDED(hr))
		{
			hr = RegisterTypeLib(ptl, g_wszFileName, 0);
			ptl->Release();
		}

		if (bSuccess)
			hr = S_OK;
		else
			hr = E_FAIL;
	}

    return hr ;//bSuccess ? S_OK : E_FAIL;
}



BOOL
APIENTRY
DllMain(HINSTANCE h, DWORD dwReason, void *)
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = h;

         LOG(L"DLL_PROCESS_ATTACH");

// @@ remove this 
        GetModuleFileName(h, g_szFileName, MAX_PATH);



         break;
      }
      case DLL_PROCESS_DETACH:
      {

#ifdef DEBUG_BUILD
         LOG(TEXT("DLL_PROCESS_DETACH"));
         if (!ComServerLockState::CanUnloadNow())
         {
            LOG(L"server locks and/or outstanding object instances exit");
         }
         else
         {
            LOG(L"server can unload now.");
         }
#endif

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         break;
      }
   }

   return TRUE;
}



STDAPI
DllRegisterServer()
{
   LOG_FUNCTION(DllRegisterServer);

   return Register(g_rgEntries, g_cEntries);
}



STDAPI
DllUnregisterServer()
{
   LOG_FUNCTION(DllUnregisterServer);

   return Unregister(g_rgEntries, g_cEntries);
}



STDAPI
DllCanUnloadNow()
{
   LOG_FUNCTION(DllCanUnloadNow);

   if (ComServerLockState::CanUnloadNow())
   {
      return S_OK;
   }

   return S_FALSE;
}


STDAPI
DllGetClassObject(
   const CLSID&   classID,
   const IID&     interfaceID,
   void**         interfaceDesired)
{
   LOG_FUNCTION(DllGetClassObject);

   IClassFactory* factory = 0;

   // The class objects are instances of ClassFactory<>, which are ref-counted
   // in the usual fashion (i.e. they track their ref counts, and
   // self-destruct on final Release).  I could have used static instances of
   // a C++ class that ignored the refcounting (ala Don Box's examples in
   // Essential COM)

   if (classID == CLSID_CloneSecurityPrincipal)
   {
      factory = new ClassFactory<CloneSecurityPrincipal>;
   }
   else
   {
      *interfaceDesired = 0;
      return CLASS_E_CLASSNOTAVAILABLE;
   }

   // the class factory instance starts with a ref count of 1.  If the QI
   // fails, then it self-destructs upon Release.
   HRESULT hr = factory->QueryInterface(interfaceID, interfaceDesired);
   factory->Release();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\implmain.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Implementation of ICloneSecurityPrincipal
//
// sburns 5-10-99



#include "headers.hxx"
#include "resource.h"
#include "implmain.hpp"
#include "common.hpp"



const size_t NUMBER_OF_AUTOMATION_INTERFACES = 3;



CloneSecurityPrincipal::CloneSecurityPrincipal()
   :
   connection(0),
   refcount(1),       // implicit AddRef
   m_pSID(NULL)
{
   LOG_CTOR(CloneSecurityPrincipal);

   m_ppTypeInfo = new ITypeInfo*[NUMBER_OF_AUTOMATION_INTERFACES];

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      m_ppTypeInfo[i] = NULL;
   }

   ITypeLib *ptl = 0;
   HRESULT hr = LoadRegTypeLib(LIBID_CloneSecurityPrincipalLib, 1, 0, 0, &ptl);
   if (SUCCEEDED(hr))
   {
      ptl->GetTypeInfoOfGuid(IID_ICloneSecurityPrincipal, &(m_ppTypeInfo[0]));
      ptl->GetTypeInfoOfGuid(IID_IADsSID, &(m_ppTypeInfo[1]));
      ptl->GetTypeInfoOfGuid(IID_IADsError, &(m_ppTypeInfo[2]));

      ptl->Release();
   }
}



CloneSecurityPrincipal::~CloneSecurityPrincipal()
{
   LOG_DTOR(CloneSecurityPrincipal);
   ASSERT(refcount == 0);

   delete connection;

   if ( m_pSID ) 
     FreeADsMem( m_pSID );

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      m_ppTypeInfo[i]->Release();
   }

   delete[] m_ppTypeInfo;
}



HRESULT __stdcall
CloneSecurityPrincipal::QueryInterface(REFIID riid, void **ppv)
{
   LOG_FUNCTION(CloneSecurityPrincipal::QueryInterface);

   if (riid == IID_IUnknown)
   {
      LOG(L"IUnknown");

      *ppv = (IUnknown*)(ICloneSecurityPrincipal*)(this);
   }
   else if (riid == IID_ICloneSecurityPrincipal)
   {
      LOG(L"ICloneSecurityPrincipal");

      *ppv = static_cast<ICloneSecurityPrincipal*>(this);
   }
   else if (riid == IID_IADsSID)
   {
      LOG(L"IADsSID");

      *ppv = static_cast<IADsSID*>(this);
   }
   else if (riid == IID_IADsError)
   {
      LOG(L"IADsError");

      *ppv = static_cast<IADsError*>(this);
   }
   else if (riid == IID_IDispatch && m_ppTypeInfo[0])
   {
      LOG(L"IDispatch");

      *ppv = (IDispatch*)(ICloneSecurityPrincipal*)(this);
   }
   else if (riid == IID_ISupportErrorInfo)
   {
      LOG(L"ISupportErrorInfo");

      *ppv = (ISupportErrorInfo*)(this);
   }
   else
   {
      LOG(L"unknown");

      return (*ppv = 0), E_NOINTERFACE;
   }

   reinterpret_cast<IUnknown*>(*ppv)->AddRef();
   return S_OK;
}



ULONG __stdcall
CloneSecurityPrincipal::AddRef(void)
{
   LOG_ADDREF(CloneSecurityPrincipal);

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
CloneSecurityPrincipal::Release(void)
{
   LOG_RELEASE(CloneSecurityPrincipal);

   if (Win::InterlockedDecrement(refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
CloneSecurityPrincipal::GetTypeInfoCount(UINT *pcti)
{
   LOG_FUNCTION(CloneSecurityPrincipal::GetTypeInfoCount);

    if (pcti == 0)
    {
      return E_POINTER;
    }

    *pcti = 1;
    return S_OK;
}



HRESULT __stdcall
CloneSecurityPrincipal::GetTypeInfo(UINT cti, LCID, ITypeInfo **ppti)
{
   LOG_FUNCTION(CloneSecurityPrincipal::GetTypeInfo);

   if (ppti == 0)
   {
      return E_POINTER;
   }
   if (cti != 0)
   {
      *ppti = 0;
      return DISP_E_BADINDEX;
   }

   (*ppti = m_ppTypeInfo[0])->AddRef();
   return S_OK;
}



HRESULT __stdcall
CloneSecurityPrincipal::GetIDsOfNames(
   REFIID  riid,    
   OLECHAR **prgpsz,
   UINT    cNames,  
   LCID    lcid,    
   DISPID  *prgids) 
{
   LOG_FUNCTION(CloneSecurityPrincipal::GetIDsOfNames);

   HRESULT hr = S_OK;
   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
     hr = (m_ppTypeInfo[i])->GetIDsOfNames(prgpsz, cNames, prgids);
     if (SUCCEEDED(hr) || DISP_E_UNKNOWNNAME != hr)
       break;
   }

   return hr;
}



HRESULT __stdcall
CloneSecurityPrincipal::Invoke(
   DISPID     id,         
   REFIID     riid,       
   LCID       lcid,       
   WORD       wFlags,     
   DISPPARAMS *params,    
   VARIANT    *pVarResult,
   EXCEPINFO  *pei,       
   UINT       *puArgErr) 
{
   LOG_FUNCTION(CloneSecurityPrincipal::Invoke);

   HRESULT    hr = S_OK;
   IDispatch *pDispatch[NUMBER_OF_AUTOMATION_INTERFACES] =
                    {
                     (IDispatch*)(ICloneSecurityPrincipal *)(this),
                     (IDispatch*)(IADsSID *)(this),
                     (IDispatch*)(IADsError *)(this)
                    };

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      hr = (m_ppTypeInfo[i])->Invoke(
         pDispatch[i],
         id,
         wFlags,
         params,
         pVarResult,
         pei,
         puArgErr);

      if (DISP_E_MEMBERNOTFOUND != hr)
        break;
   }

   return hr;
}



HRESULT __stdcall
CloneSecurityPrincipal::InterfaceSupportsErrorInfo(const IID& iid)
{
   LOG_FUNCTION(CloneSecurityPrincipal::InterfaceSupportsErrorInfo);

   if (iid == IID_ICloneSecurityPrincipal ||
       iid == IID_IADsSID ||
       iid == IID_IADsError)
   {
      return S_OK;
   }

   return S_FALSE;
}



HRESULT __stdcall
CloneSecurityPrincipal::Connect(
  BSTR  srcDC,
  BSTR  srcDomain,          
  BSTR  dstDC,
  BSTR  dstDomain)
{
   LOG_FUNCTION(CloneSecurityPrincipal::Connect);

   delete connection;
   connection = new Connection();

   // Even though a null parameter is technically illegal (the types are
   // BSTR),  we thoughtfully accomodate the inattentive C++ user which may
   // prefer to pass null pointers instead of empty BSTRs

   return connection->Connect(
         srcDC       ? srcDC       : L"", 
         srcDomain   ? srcDomain   : L"", 
         dstDC       ? dstDC       : L"", 
         dstDomain   ? dstDomain   : L"");
}



HRESULT __stdcall
CloneSecurityPrincipal::AddSidHistory(
   BSTR srcPrincipalSamName,
   BSTR dstPrincipalSamName,
   long flags)              
{
   LOG_FUNCTION(CloneSecurityPrincipal::AddSidHistory);

   // Even though a null parameter is technically illegal (the types are
   // BSTR),  we thoughtfully accomodate the inattentive C++ user which may
   // prefer to pass null pointers instead of empty BSTRs

   return
      DoAddSidHistory(
         srcPrincipalSamName ? srcPrincipalSamName : L"",
         dstPrincipalSamName ? dstPrincipalSamName : L"",
         flags);
}



HRESULT __stdcall
CloneSecurityPrincipal::CopyDownlevelUserProperties(
   BSTR srcSamName,
   BSTR dstSamName,
   long flags)     
{
   LOG_FUNCTION(CloneSecurityPrincipal::CopyDownlevelUserProperties);

   // Even though a null parameter is technically illegal (the types are
   // BSTR),  we thoughtfully accomodate the inattentive C++ user which may
   // prefer to pass null pointers instead of empty BSTRs

   return
      DoCopyDownlevelUserProperties(
         srcSamName ? srcSamName : L"",
         dstSamName ? dstSamName : L"",
         flags);
}



//+-----------------------------------------------------------------------
//
//  Function:   CloneSecurityPrincipal::GetMembersSIDs
//
//  Synopsis:   retrieve the <sid=XXXX> of all members of dstGroupDN.
//
//------------------------------------------------------------------------

#define ATTRIBUTE_MEMBER                  L"member"

HRESULT __stdcall
CloneSecurityPrincipal::GetMembersSIDs(
   BSTR     dstGroupDN,
   VARIANT* pVal)
{
   // init the OUT parameter to hold an array of variants

   VariantInit(pVal);
   pVal->vt = VT_ARRAY | VT_VARIANT ;

   HRESULT             hr                = S_OK;
   std::vector<BSTR>   values;
   PLDAPMessage        pMsg              = 0;
   LPTSTR              lpszAttrs[]       = {ATTRIBUTE_MEMBER, 0};
   LDAPControl         serverControls    = {LDAP_SERVER_EXTENDED_DN_OID_W, {0, (PCHAR)NULL}, TRUE};
   PLDAPControl        aServerControls[] = {&serverControls, NULL};
   PLDAP               pldap             = connection->m_pldap;

   do
   {
      // the ldap connection to dstDC should have already been established

      if (!pldap)
      {
         hr = E_UNEXPECTED;   

         LOG(L"pldap is null!");
         SetComError(IDS_OBJECT_STATE_BAD);
         break;
      }

      hr =
          Win32ToHresult(
            ldap_search_ext_s(
               pldap,
               dstGroupDN,
               LDAP_SCOPE_BASE,            // scope
               _T("(objectClass=group)"),  // filter
               lpszAttrs,                  // attrs[]
               0,                          // atrssonly
               (PLDAPControl *)&aServerControls, // ServerControls
               NULL,                       // ClientControls
               0,                          // no time limit
               0,                          // no SizeLimit
               &pMsg)); 
      BREAK_ON_FAILED_HRESULT(hr);

      BSTR   bstr     = NULL;                 
      PTSTR  pStart   = NULL;                 
      PTSTR  pEnd     = NULL;                 
      PTSTR* ppValues = ldap_get_values(pldap, pMsg, ATTRIBUTE_MEMBER);

      if (!ppValues)
      {
         break;
      }

      PTSTR *p = ppValues;
      while(*p)
      {
         //  *p is a string in the following format:
         //  "<GUID=42e87199a88c854998dad04be4b8d29f>;<SID=0105000000
         //  00000515000000a23ca6557d03c651772c315d00040000>;CN=S-1-
         //  5-21-1436957858-1371931517-1563503735-1024,CN=Foreign
         //  SecurityPrincipals,DC=linan,DC=nttest,DC=microsoft,DC=com"

         if ( (pStart  = _tcsstr(*p, _T("<SID="))) &&
         (pEnd    = _tcschr(pStart, _T('>'))) )
         {
            // retrieve <sid=XXXXX>, and add it to the vector

            if ( !(bstr = SysAllocStringLen(pStart, static_cast<UINT>(pEnd - pStart + 1))) )
            {
               hr = E_OUTOFMEMORY;
               SetComError(IDS_OUT_OF_MEMORY);
               break;
            }
            values.push_back(bstr);
         }

         p++;
      }

      ldap_value_free(ppValues);

      // SysAllocString may have failed and terminated the preceeding loop

      BREAK_ON_FAILED_HRESULT(hr);

      // populate the OUT parameter: the array of variants

      if (values.size() > 0)
      {
         SAFEARRAYBOUND  bounds = {values.size(), 0};
         SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
         VARIANT*        varArray;

         SafeArrayAccessData(psa, (void**)&varArray);

         int i = 0;
         for (
            std::vector<BSTR>::iterator it = values.begin();
            it != values.end();
            ++it, ++i)
         {
            VariantInit(&(varArray[i]));
            varArray[i].vt        = VT_BSTR;
            varArray[i].bstrVal   = *it;
         }

         SafeArrayUnaccessData(psa);

         pVal->parray = psa;
      }

   }
   while (0);

   if (pMsg)
   {
      ldap_msgfree(pMsg);
   }

   if (FAILED(hr))
   {
      for (
         std::vector<BSTR>::iterator it = values.begin();
         it != values.end();
         ++it)
      {
         SysFreeString(*it);
      }
   }

   return hr;
}



/////////////////////////////////////////////////////////////////////////////
// IADsSID methods

HRESULT VariantToSID(VARIANT *pVar , PSID *ppSID );
HRESULT ByteToHexString(LPBYTE pByte, DWORD dwLength, LPTSTR *ppRet);

// only support ADS_SID_ACTIVE_DIRECTORY_PATH and ADS_SID_WINNT_PATH and ADS_SID_SDDL
STDMETHODIMP CloneSecurityPrincipal::SetAs(long lFormat, VARIANT var)
{
   LOG_FUNCTION(CloneSecurityPrincipal::SetAs);

  PSID    pNew = NULL ;
  HRESULT hr = S_OK;
  
  //
  // performing the necessary indirection if the source is VT_BYREF
  //
  VARIANT varData;
  VariantInit(&varData);
  hr = VariantCopyInd(&varData, (LPVARIANT)&var);
  if (FAILED(hr))
    return hr;

  switch( lFormat )
  {
  case ADS_SID_ACTIVE_DIRECTORY_PATH:
    {
      if ( V_VT(&varData) != VT_BSTR )
        return E_INVALIDARG;

      IDirectoryObject  *pDir;
      hr = ADsGetObject( V_BSTR(&varData), IID_IDirectoryObject, (void**) &pDir );
      if ( FAILED(hr) )
        return hr;

      ADS_ATTR_INFO   *pAttrInfo=NULL;
      DWORD           dwReturn;
      LPWSTR          pAttrNames[]={L"objectSID" };
      DWORD           dwNumAttr=sizeof(pAttrNames)/sizeof(LPWSTR);
      
      hr = pDir->GetObjectAttributes( pAttrNames, 
                                      dwNumAttr, 
                                      &pAttrInfo, 
                                      &dwReturn );
      if ( SUCCEEDED(hr) )
      {
        pNew = (PSID) AllocADsMem( pAttrInfo->pADsValues->OctetString.dwLength );
        if (!pNew)
          hr = E_OUTOFMEMORY;
        else
          CopyMemory( pNew, pAttrInfo->pADsValues->OctetString.lpValue,
                    pAttrInfo->pADsValues->OctetString.dwLength );

        FreeADsMem( pAttrInfo );
      }

      pDir->Release();
    }
    break;

  case ADS_SID_WINNT_PATH:
    {
      if ( V_VT(&varData) != VT_BSTR )
        return E_INVALIDARG;

      IADs *pADs;
      hr = ADsGetObject( V_BSTR(&varData), IID_IADs, (void**) &pADs );
      if ( FAILED(hr) )
        return hr;

      VARIANT var;
      VariantInit(&var);
      hr = pADs->Get(L"objectSID", &var );
      if ( SUCCEEDED(hr) )
        hr = VariantToSID( &var, &pNew );

      pADs->Release();
    }
    break;

  case ADS_SID_SDDL:
    {
      if ( V_VT(&varData) != VT_BSTR )
        return E_INVALIDARG;

      LPCTSTR pszSID = V_BSTR(&varData);
      PSID pSID = NULL;

      if ( !ConvertStringSidToSid( pszSID, &pSID ) )
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      } else
      {
        DWORD dwLength = GetLengthSid(pSID);
        pNew = (PSID)AllocADsMem(dwLength);
        if (!pNew)
          hr = E_OUTOFMEMORY;
        else
          CopyMemory(pNew, pSID, dwLength);

        LocalFree(pSID);
      }
    }
    break;

   case ADS_SID_RAW:
   {
      // raw, meaning a variant (VT_ARRAY | VT_U1) containing the sid in the
      // same format as returned by the ObjectSid property.

      LOG(L"ADS_SID_RAW");

      if (V_VT(&varData) != (VT_ARRAY| VT_UI1))
      {
         return E_INVALIDARG;
      }

      hr = VariantToSID(&varData, &pNew);
      LOG_HRESULT(hr);

      break;
   }

      
  default:
    return E_INVALIDARG; // unrecognized flag.
  }

  if ( FAILED(hr) )
    return hr;

  if ( !pNew )
    return E_FAIL;

  if (!IsValidSid( pNew ) )
  {
    FreeADsMem( pNew );
    return E_FAIL;
  }

  if ( m_pSID ) 
    FreeADsMem( m_pSID );
  m_pSID = pNew;

  return hr;
}

// only support ADS_SID_SDDL and ADS_SID_HEXSTRING
STDMETHODIMP CloneSecurityPrincipal::GetAs(long lFormat, VARIANT *pVar)
{
  if ( !m_pSID )
    return E_INVALIDARG;

  HRESULT hr = S_OK;
  
  VariantClear(pVar);

  switch( lFormat )
  {
  case ADS_SID_HEXSTRING:
    {
      LPTSTR pStr;
      hr = ByteToHexString( (LPBYTE) m_pSID, GetLengthSid( m_pSID), &pStr );
      if ( SUCCEEDED(hr) )
      {
        V_VT( pVar ) = VT_BSTR;
        V_BSTR( pVar ) = SysAllocString(pStr);
        FreeADsMem( pStr );
      }
    }
    break;

  case ADS_SID_SDDL:
    {
      LPTSTR pszSID;
      if ( ConvertSidToStringSid( m_pSID, &pszSID ))
      {
        V_VT( pVar ) = VT_BSTR;
        V_BSTR( pVar ) = SysAllocString(pszSID);
        LocalFree( pszSID );
      } else
        hr = HRESULT_FROM_WIN32(GetLastError());

    }
    break;

  default:
    hr = E_INVALIDARG; // unrecognized flag.
  }

  return hr;
}

HRESULT VariantToSID(VARIANT *pVar , PSID *ppSID )
{
  HRESULT hr = S_OK;
  SAFEARRAY *aList = NULL;
  CHAR HUGEP *pArray = NULL;
  DWORD dwLower, dwUpper, dwLength;

  hr = SafeArrayGetLBound(V_ARRAY(pVar),
                          1,
                          (long FAR *) &dwLower );

  hr = SafeArrayGetUBound(V_ARRAY(pVar),
                          1,
                          (long FAR *) &dwUpper );
    
  dwLength = dwUpper - dwLower;

  *ppSID = (PSID) AllocADsMem( dwLength + 1);

  aList = V_ARRAY( pVar );

  if ( aList == NULL )
      return E_UNEXPECTED;

  hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
  if ( !SUCCEEDED(hr) )
    return hr;

  CopyMemory( *ppSID, pArray, dwLength );

  SafeArrayUnaccessData( aList );

  if (!IsValidSid(*ppSID) )
    return E_FAIL;

  return hr;
}

HRESULT ByteToHexString( LPBYTE pByte, DWORD dwLength, LPTSTR *ppRet )
{
  LPTSTR  pDest=NULL;
  LPTSTR  pHead=NULL;
  
  pDest = pHead = (LPTSTR) AllocADsMem( ((dwLength+1)*2) * sizeof(TCHAR));
  if( pHead == NULL )
    return E_OUTOFMEMORY;

  //////////////////////////////////
  // Convert into the Hex String
  //////////////////////////////////
  for (DWORD idx=0; idx < dwLength; idx++, pDest+=2, pByte++ )
  {
    wsprintf(pDest, _T("%02X"), *pByte );  
  }

  *ppRet = pHead;

  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IADsError methods

HRESULT
GetMessageHelper(
    OUT BSTR        *pbstr,
    IN  HRESULT     hrErr,
    IN  DWORD       dwFlags,
    IN  HINSTANCE   hMsgDll = NULL
);



#define FACILITY_ADSI   0x00005000

String
GetErrorMessageADSIExtended(HRESULT hr)
{
   LOG_FUNCTION2(GetErrorMessageADSIExtended, String::format("%1!08X!", hr));

   if (!FAILED(hr))
   {
      // no messages for success!
      return String();
   }

   String errmsg = GetErrorMessage(hr);
 
   if ((hr & FACILITY_ADSI)  ||         //adsi
       HRESULT_FACILITY(hr) == FACILITY_WIN32  )   // and win32
   {
     WCHAR szBuffer[MAX_PATH];
     WCHAR szName[MAX_PATH];
     DWORD dwError;
    
     HRESULT hrEx = ADsGetLastError( &dwError, szBuffer, (sizeof(szBuffer)/sizeof(WCHAR))-1,
                        szName, (sizeof(szName)/sizeof(WCHAR))-1 );
     if ( SUCCEEDED(hrEx) && dwError != ERROR_INVALID_DATA  && wcslen(szBuffer))
     {
        String errmsgextended;
        errmsgextended = String::format(IDS_ADSI_EXTENDED_ERROR, errmsg.c_str(), szName, szBuffer);
        return errmsgextended;
     }
   }

   return errmsg;
}



HRESULT __stdcall
CloneSecurityPrincipal::GetErrorMsg(
   long  hrErr,  
   BSTR* pbstrMsg)
{
  String s = GetErrorMessageADSIExtended(hrErr);
  *pbstrMsg = SysAllocString(const_cast<String::value_type*>(s.c_str()));

  if (!*pbstrMsg)
    return E_OUTOFMEMORY;

  return S_OK;
}

//
// S_OK: found and returned in pbstr
// S_FALSE: message not found
// hr: some error happened
//
HRESULT
GetMessageHelper(
    OUT BSTR        *pbstr,
    IN  HRESULT     hrErr,
    IN  DWORD       dwFlags,
    IN  HINSTANCE   hMsgDll
)
{
    *pbstr = NULL;

    LPTSTR lpBuffer = NULL;
    DWORD dwRet =
      FormatMessage(
         FORMAT_MESSAGE_ALLOCATE_BUFFER | dwFlags,
         (LPCVOID) hMsgDll,
         hrErr,
         0,
         (LPTSTR) &lpBuffer,
         0,
         NULL);

    if ( !dwRet )
    {
      DWORD dwErr = GetLastError();

      if (ERROR_MR_MID_NOT_FOUND == dwErr)
        return S_FALSE;
      else
        return HRESULT_FROM_WIN32(dwErr);
    }

    *pbstr = SysAllocString(lpBuffer);
    LocalFree(lpBuffer);

    if (!*pbstr)
      return E_OUTOFMEMORY;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\connect.cpp ===
//
// Implementation of ICloneSecurityPrincipal::Connect
//
// sburns 5-10-99



#include "headers.hxx"
#include "resource.h"
#include "common.hpp"
#include "implmain.hpp"



CloneSecurityPrincipal::Connection::Connection()
   :
   dstComputer(0),
   dstDomainSamHandle(INVALID_HANDLE_VALUE),
   dstDsBindHandle(INVALID_HANDLE_VALUE),
   m_pldap(0),
   srcComputer(0),
   srcDcDnsName(),
   srcDomainSamHandle(INVALID_HANDLE_VALUE)
{
   LOG_CTOR(CloneSecurityPrincipal::Connection);
}



CloneSecurityPrincipal::Connection::~Connection()
{
   LOG_DTOR(CloneSecurityPrincipal::Connection);

   Disconnect();
}



HRESULT
ValidateDCAndDomainParameters(
   const String& srcDC,    
   const String& srcDomain,
   const String& dstDC,    
   const String& dstDomain)
{
   LOG_FUNCTION(ValidateDCAndDomainParameters);

   HRESULT hr = S_OK;
   do
   {
      if (srcDC.empty() && srcDomain.empty())
      {
         hr = E_INVALIDARG;
         SetComError(IDS_MUST_SPECIFY_SRC_DC_OR_DOMAIN);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (dstDC.empty() && dstDomain.empty())
      {
         hr = E_INVALIDARG;
         SetComError(IDS_MUST_SPECIFY_DST_DC_OR_DOMAIN);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      if (!srcDC.empty() && !dstDC.empty())
      {
         if (srcDC.icompare(dstDC) == 0)
         {
            // may not be the same dc

            hr = E_INVALIDARG;
            SetComError(IDS_SRC_DC_EQUALS_DST_DC);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }

      if (!srcDomain.empty() && dstDomain.empty())
      {
         if (srcDomain.icompare(dstDomain) == 0)
         {
            // may not be the same domain

            hr = E_INVALIDARG;
            SetComError(IDS_SRC_DOMAIN_EQUALS_DST_DOMAIN);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }
   }
   while (0);

   return hr;
}



// Creates a Computer object representing the domain controller specified, or
// located domain controller for the domain specified.  Does additional
// validation of the dc and domain parameters.

HRESULT
CreateComputer(
   const String&  dc,
   const String&  domain,
   Computer*&     computer)
{
   LOG_FUNCTION(CreateComputer);
   ASSERT(computer == 0);

   computer = 0;
   HRESULT hr = S_OK;
   do
   {
      if (dc.empty())
      {
         // source DC was not specified: find a writeable DC

         // must have supplied the source domain: we checked for that
         // in an earlier call to ValidateDCAndDomainParameters
         ASSERT(!domain.empty());
         if (domain.empty())
         {
            hr = E_INVALIDARG;
            SetComError(IDS_MUST_SPECIFY_SRC_DC_OR_DOMAIN);
            break;
         }

         DOMAIN_CONTROLLER_INFO* info = 0;
         hr =
            Win32ToHresult(
               MyDsGetDcName(
                  0,
                  domain,
                  DS_WRITABLE_REQUIRED | DS_DIRECTORY_SERVICE_PREFERRED,
                  info));

         LOG_HRESULT(hr);

         if (FAILED(hr))
         {
            SetComError(
               String::format(
                  IDS_CANT_FIND_DC,
                  domain.c_str(),
                  GetErrorMessage(hr).c_str()));
            break;
         }
            
         if (info && info->DomainControllerName)
         {
            computer = new Computer(info->DomainControllerName);
            ::NetApiBufferFree(info);
         }
         else
         {
            // should always get a result if successful 
            ASSERT(false);
            hr = E_FAIL;
            break;
         }
      }
      else
      {
         // source dc was supplied

         computer = new Computer(dc);
      }
   }
   while (0);

   return hr;
}



// HRESULT
// Authenticate(
//    const Computer&   computer,
//    const String&     username,
//    const String&     userDomain,
//    const String&     password)
// {
//    LOG_FUNCTION(Authenticate);
// 
//    // attempt to authenticate to the computer.
//    String name = computer.NameWithBackslashes();
// 
//    NETRESOURCE nr;
//    memset(&nr, 0, sizeof(nr));
// 
//    nr.dwType       = RESOURCETYPE_ANY;
//    nr.lpRemoteName = const_cast<String::value_type*>(name.c_str());
// 
//    // see KB articles Q218497, Q180548, Q183366 for the pitfalls here...
// 
//    String u;
//    if (userDomain.empty())
//    {
//       u = username;
//    }
//    else
//    {
//       ASSERT(!username.empty());
//       u = userDomain + L"\\" + username;
//    }
// 
//    LOG(L"Calling WNetAddConnection2");
//    LOG(String::format(L"username : %1", u.empty() ? L"(null)" : u.c_str()));
// 
//    HRESULT hr =
//       Win32ToHresult(
//          ::WNetAddConnection2(
//             &nr,
//             password.c_str(),
//             u.empty() ? 0 : u.c_str(),
//             0));
// 
//    LOG_HRESULT(hr);
// 
//    if (FAILED(hr))
//    {
//       SetComError(
//          String::format(
//             IDS_UNABLE_TO_CONNECT,
//             name.c_str(),
//             GetErrorMessage(hr).c_str()));
//    }
// 
//    return hr;
// }



HRESULT
ValidateInitializedComputer(
   const Computer& computer,
   const String&   domain)  
{
   LOG_FUNCTION(ValidateInitializedComputer);

   HRESULT hr = S_OK;
   do
   {
      if (!computer.IsDomainController())
      {
         hr = E_INVALIDARG;
         SetComError(
            String::format(
               IDS_COMPUTER_IS_NOT_DC,
               computer.GetNetbiosName().c_str()));
         break;
      }

      if (!domain.empty())
      {
         // check that the DC is really a DC of the specified domain
         if (
               computer.GetDomainDnsName().icompare(domain) != 0
            && computer.GetDomainNetbiosName().icompare(domain) != 0)
         {
            hr = E_INVALIDARG;
            SetComError(
               String::format(
                  IDS_NOT_DC_FOR_WRONG_DOMAIN,
                  computer.GetNetbiosName().c_str(),
                  domain.c_str()));
            break;
         }
      }
   }
   while (0);

   return hr;
}



// Returns an open handle to the SAM database for the named domain on the
// given DC.  Should be freed with SamCloseHandle.

HRESULT
OpenSamDomain(
   const String&  dcName,
   const String&  domainNetBiosName,
   SAM_HANDLE&    resultHandle)
{
   LOG_FUNCTION2(OpenSamDomain, dcName);
   ASSERT(!dcName.empty());

   resultHandle = INVALID_HANDLE_VALUE;
      
   HRESULT hr = S_OK;
   SAM_HANDLE serverHandle = INVALID_HANDLE_VALUE;
   PSID domainSID = 0;
   do
   {
      UNICODE_STRING serverName;
      memset(&serverName, 0, sizeof(serverName));
      ::RtlInitUnicodeString(&serverName, dcName.c_str());

      LOG(L"Calling SamConnect");

      hr =
         NtStatusToHRESULT(
            ::SamConnect(
               &serverName,
               &serverHandle,
               MAXIMUM_ALLOWED,
               0));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_CONNECT_TO_SAM_SERVER,
               dcName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      UNICODE_STRING domainName;
      memset(&domainName, 0, sizeof(domainName));
      ::RtlInitUnicodeString(&domainName, domainNetBiosName.c_str());

      hr =
         NtStatusToHRESULT(
            ::SamLookupDomainInSamServer(
               serverHandle,
               &domainName,
               &domainSID));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_LOOKUP_SAM_DOMAIN,
               domainNetBiosName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      hr =
         NtStatusToHRESULT(
            ::SamOpenDomain(
               serverHandle,
               MAXIMUM_ALLOWED,
               domainSID,
               &resultHandle));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_OPEN_SAM_DOMAIN,
               domainNetBiosName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }
   }
   while (0);

   if (serverHandle != INVALID_HANDLE_VALUE)
   {
      ::SamCloseHandle(serverHandle);
   }

   if (domainSID)
   {
      ::SamFreeMemory(domainSID);
   }

   return hr;
}



HRESULT
DetermineSourceDcDnsName(
   const String&  srcDcNetbiosName,
   const String&  srcDomainDnsName,
   String&        srcDcDnsName)
{
   LOG_FUNCTION(DetermineSourceDcDnsName);
   ASSERT(!srcDcNetbiosName.empty());

   srcDcDnsName.erase();

   if (srcDomainDnsName.empty())
   {
      // The computer is not a DS DC, so we don't need its DNS name.
      LOG(L"source DC is not a DS DC");

      return S_OK;
   }

   HRESULT hr = S_OK;
   HANDLE hds = 0;
   do
   {
      // Bind to self
      hr =
         MyDsBind(
            srcDcNetbiosName,
            srcDomainDnsName,
            hds);
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_BIND_FAILED,
               srcDcNetbiosName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      // find all the dc's for my domain.  the list should contain
      // srcDcNetbiosName.

      DS_DOMAIN_CONTROLLER_INFO_1W* info = 0;
      DWORD infoCount = 0;
      hr =
         MyDsGetDomainControllerInfo(
            hds,
            srcDomainDnsName,
            infoCount,
            info);
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_GET_DC_INFO_FAILED,
               GetErrorMessage(hr).c_str()));
         break;
      }

      // there should be at least 1 entry, the source DC itself
      ASSERT(infoCount);
      ASSERT(info);

      if (info)
      {
         for (DWORD i = 0; i < infoCount; i++)
         {
            if (info[i].NetbiosName)   
            {
               LOG(info[i].NetbiosName);

               if (srcDcNetbiosName.icompare(info[i].NetbiosName) == 0)
               {
                  // we found ourselves in the list

                  LOG(L"netbios name found");

                  if (info[i].DnsHostName)
                  {
                     LOG(L"dns hostname found!");                  
                     srcDcDnsName = info[i].DnsHostName;
                     break;
                  }

               }
            }
         }
      }

      ::DsFreeDomainControllerInfo(1, infoCount, info);

      if (srcDcDnsName.empty())
      {
         hr = E_FAIL;
         SetComError(
            String::format(
               IDS_CANT_FIND_SRC_DC_DNS_NAME,
               srcDcNetbiosName.c_str()));
         break;
      }

      LOG(srcDcDnsName);
   }
   while (0);

   if (hds)
   {
      ::DsUnBind(&hds);
      hds = 0;
   }

   return hr;
}



HRESULT
CloneSecurityPrincipal::Connection::Connect(
   const String& srcDC,              
   const String& srcDomain,          
   const String& dstDC,              
   const String& dstDomain)
{
   LOG_FUNCTION(CloneSecurityPrincipal::Connection::Connect);

   HRESULT hr = S_OK;
   do
   {
      hr = ValidateDCAndDomainParameters(srcDC, srcDomain, dstDC, dstDomain);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = CreateComputer(srcDC, srcDomain, srcComputer);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = CreateComputer(dstDC, dstDomain, dstComputer);
      BREAK_ON_FAILED_HRESULT(hr);

      // hr =
      //    Authenticate(
      //       *srcComputer,
      //       srcUsername,
      //       srcUserDomain,
      //       srcPassword);
      // BREAK_ON_FAILED_HRESULT(hr);

      hr = srcComputer->Refresh();
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_READ_COMPUTER_INFO,
               srcComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      hr = ValidateInitializedComputer(*srcComputer, srcDomain);
      BREAK_ON_FAILED_HRESULT(hr);
         
      hr = dstComputer->Refresh();
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_READ_COMPUTER_INFO,
               dstComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      hr = ValidateInitializedComputer(*dstComputer, dstDomain);
      BREAK_ON_FAILED_HRESULT(hr);

      // bind to the destination DC.

      ASSERT(dstDsBindHandle == INVALID_HANDLE_VALUE);

      hr =
         MyDsBind(
            dstComputer->GetNetbiosName(),
            String(),
            dstDsBindHandle);
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_BIND_FAILED,
               dstComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      //
      // open ldap connection to dstDC
      //
      m_pldap = ldap_open(const_cast<String::value_type*>(dstDC.c_str()), LDAP_PORT);
      if (!m_pldap)
      {
         hr = Win::GetLastErrorAsHresult();
         SetComError(
            String::format(
               IDS_LDAPOPEN_FAILED,
               dstComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      // SEC_WINNT_AUTH_IDENTITY authInfo;
      // authInfo.User           = const_cast<wchar_t*>(dstUsername.c_str());
      // authInfo.UserLength     = dstUsername.length();
      // authInfo.Domain         = const_cast<wchar_t*>(dstUserDomain.c_str());
      // authInfo.DomainLength   = dstUserDomain.length();
      // authInfo.Password       = const_cast<wchar_t*>(dstPassword.c_str());
      // authInfo.PasswordLength = dstPassword.length();
      // authInfo.Flags          = SEC_WINNT_AUTH_IDENTITY_UNICODE;

      DWORD dwErr = ldap_bind_s(
                              m_pldap, 
                              NULL,
                              (TCHAR *) 0, 
                              LDAP_AUTH_NEGOTIATE);
      if (LDAP_SUCCESS != dwErr)
      {
         hr = Win::GetLastErrorAsHresult();

         ldap_unbind_s(m_pldap);
         m_pldap = 0;

         SetComError(
            String::format(
               IDS_LDAPBIND_FAILED,
               dstComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      // obtain sam handles to source and dst domains

      ASSERT(srcDomainSamHandle == INVALID_HANDLE_VALUE);

      hr =
         OpenSamDomain(
            srcComputer->GetNetbiosName(),
            srcComputer->GetDomainNetbiosName(),
            srcDomainSamHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(dstDomainSamHandle == INVALID_HANDLE_VALUE);

      hr =
         OpenSamDomain(
            dstComputer->GetNetbiosName(),
            dstComputer->GetDomainNetbiosName(),
            dstDomainSamHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         DetermineSourceDcDnsName(
            srcComputer->GetNetbiosName(),
            srcComputer->GetDomainDnsName(),
            srcDcDnsName);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      Disconnect();
   }

   return hr;
}



bool
CloneSecurityPrincipal::Connection::IsConnected() const
{
   LOG_FUNCTION(CloneSecurityPrincipal::Connection::IsConnected);

   bool result =
         srcComputer
      && dstComputer
      && (dstDsBindHandle != INVALID_HANDLE_VALUE)
      && (srcDomainSamHandle != INVALID_HANDLE_VALUE);

   LOG(
      String::format(
         L"object %1 connected.",
         result ? L"is" : L"is NOT"));

   return result;
}



void
CloneSecurityPrincipal::Connection::Disconnect()
{
   LOG_FUNCTION(CloneSecurityPrincipal::Connection::Disconnect);

   // may be called if Connect fails, so we might be in a partially
   // connected state.  So we need to check the handle values.

   if (srcDomainSamHandle != INVALID_HANDLE_VALUE)
   {
      ::SamCloseHandle(srcDomainSamHandle);
      srcDomainSamHandle = INVALID_HANDLE_VALUE;
   }

   if (dstDsBindHandle != INVALID_HANDLE_VALUE)
   {
      ::DsUnBind(&dstDsBindHandle);
      dstDsBindHandle = INVALID_HANDLE_VALUE;
   }

   if (m_pldap)
   {
      ldap_unbind_s(m_pldap);
      m_pldap = 0;
   }

   delete dstComputer;
   dstComputer = 0;

   delete srcComputer;
   srcComputer = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDS_MUST_SPECIFY_SRC_DC_OR_DOMAIN              1001
#define IDS_MUST_SPECIFY_DST_DC_OR_DOMAIN              1002
#define IDS_SRC_DC_EQUALS_DST_DC                       1003
#define IDS_SRC_DOMAIN_EQUALS_DST_DOMAIN               1004
#define IDS_COMPUTER_IS_NOT_DC                         1005
#define IDS_NOT_DC_FOR_WRONG_DOMAIN                    1006
#define IDS_CANT_FIND_DC                               1007
#define IDS_UNABLE_TO_CONNECT                          1008
#define IDS_MISSING_SRC_SAM_NAME                       1009
#define IDS_FLAGS_ARE_UNUSED                           1010
#define IDS_UNABLE_TO_READ_COMPUTER_INFO               1011
#define IDS_BIND_FAILED                                1012
#define IDS_ADD_SID_HISTORY_FAILED                     1013
#define IDS_MUST_CONNECT_FIRST                         1014
#define IDS_BAD_USERNAME                               1015
#define IDS_UNABLE_TO_CONNECT_TO_SAM_SERVER            1016
#define IDS_UNABLE_TO_LOOKUP_SAM_DOMAIN                1017
#define IDS_UNABLE_TO_OPEN_SAM_DOMAIN                  1018
#define IDS_SAM_USER_NOT_FOUND                         1019
#define IDS_SAM_NAME_IS_NOT_USER                       1020
#define IDS_OPEN_SAM_USER_FAILED                       1021
#define IDS_QUERY_SAM_USER_FAILED                      1022
#define IDS_SET_SAM_USER_FAILED                        1023
#define IDS_ADD_SID_HISTORY_FAILED_WITH_INVALID_HANDLE 1024
#define IDS_ADSI_EXTENDED_ERROR                        1029
#define IDS_LDAPOPEN_FAILED                            1030
#define IDS_LDAPBIND_FAILED                            1031
#define IDS_OBJECT_STATE_BAD                           1032
#define IDS_OUT_OF_MEMORY                              1033
#define IDS_GET_DC_INFO_FAILED                         1034
#define IDS_CANT_FIND_SRC_DC_DNS_NAME 1035

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\scripts\makefile.inc ===
.SUFFIXES : .vbt

# a .vbs file is produced from a .vbt file by executing the C preprocessor
# on the .vbt file, which produces a .i file.  then we rename the .i file
# to .vbs

.vbt{$(O)\}.vbs:
	$(CC) -nologo -EP -Tc$(@B).vbt > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\sidhist.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Implementation of ICloneSecurityPrincipal::AddSidHistory
//
// sburns 5-3-99



#include "headers.hxx"
#include "resource.h"
#include "common.hpp"
#include "implmain.hpp"



HRESULT
CloneSecurityPrincipal::DoAddSidHistory(
   const String& srcPrincipalSamName,
   const String& dstPrincipalSamName,
   long          flags)
{
   LOG_FUNCTION(CloneSecurityPrincipal::DoAddSidHistory);

   if (srcPrincipalSamName.empty())
   {
      SetComError(IDS_MISSING_SRC_SAM_NAME);
      return E_INVALIDARG;
   }

   if (flags)
   {
      // not used, should be 0
      SetComError(IDS_FLAGS_ARE_UNUSED);
      return E_INVALIDARG;
   }

   if (!connection || !connection->IsConnected())
   {
      SetComError(IDS_MUST_CONNECT_FIRST);
      return Win32ToHresult(ERROR_ONLY_IF_CONNECTED);
   };

   // At this point, the Computer objects contain the normalized
   // source and destination DC names, and their domains, and any
   // necessary authenticated connections to those DCs have been
   // established.

   HRESULT hr = S_OK;
   do
   {
      // use DNS names, if we have them

      String srcDc     = connection->srcDcDnsName;                   
      String srcDomain = connection->srcComputer->GetDomainDnsName();
      if (srcDomain.empty())
      {
         // source domain not win2k, so use netbios names.
         srcDomain = connection->srcComputer->GetDomainNetbiosName();
         srcDc     = connection->srcComputer->GetNetbiosName(); 
      }

      // use a DNS domain name as the dest domain is NT 5

      String dstDomain = connection->dstComputer->GetDomainDnsName();

      // if dstPrincipalSamName is not specified, use srcPrincipalSamName

      String dstSamName =
            dstPrincipalSamName.empty()
         ?  srcPrincipalSamName
         :  dstPrincipalSamName;

      SEC_WINNT_AUTH_IDENTITY authInfo;
      authInfo.Flags          = SEC_WINNT_AUTH_IDENTITY_UNICODE;
      authInfo.User           = 0;
      authInfo.UserLength     = 0;
      authInfo.Domain         = 0;
      authInfo.DomainLength   = 0;
      authInfo.Password       = 0;
      authInfo.PasswordLength = 0;

      LOG(L"Calling DsAddSidHistory");
      LOG(String::format(L"Flags               : %1!X!", 0));
      LOG(String::format(L"SrcDomain           : %1", srcDomain.c_str()));
      LOG(String::format(L"SrcPrincipal        : %1", srcPrincipalSamName.c_str()));
      LOG(String::format(L"SrcDomainController : %1", srcDc.c_str()));
      LOG(String::format(L"DstDomain           : %1", dstDomain.c_str()));
      LOG(String::format(L"DstPrincipal        : %1", dstSamName.c_str()));

      hr =
         Win32ToHresult(
            ::DsAddSidHistory(
               connection->dstDsBindHandle,
               0, // unused
               srcDomain.c_str(),
               srcPrincipalSamName.c_str(),
               srcDc.c_str(),
               0, // &authInfo,
               dstDomain.c_str(),
               dstSamName.c_str()));
      LOG_HRESULT(hr);

      if (FAILED(hr))
      {
         unsigned id = IDS_ADD_SID_HISTORY_FAILED;
         if (hr == Win32ToHresult(ERROR_INVALID_HANDLE))
         {
            // this is typically due to misconfiguring the source dc
            id = IDS_ADD_SID_HISTORY_FAILED_WITH_INVALID_HANDLE;
         }

         SetComError(
            String::format(
               id,
               GetErrorMessage(hr).c_str()));
         break;
      }
   }
   while (0);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsweb\dsctl\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsweb\dsctl\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "dsctl_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsutils\migrate\clonepr\implmain.hpp ===
#ifndef IMPLMAIN_HPP_INCLUDED
#define IMPLMAIN_HPP_INCLUDED



class CloneSecurityPrincipal
   :
   public ICloneSecurityPrincipal,
   public ISupportErrorInfo,
   public IADsError,
   public IADsSID
{
   // this is the only entity with access to the ctor of this class
   friend class ClassFactory<CloneSecurityPrincipal>;

	public:

   // IUnknown methods

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& riid, void **ppv);

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

	// IDispatch methods

   virtual 
   HRESULT __stdcall
   GetTypeInfoCount(UINT *pcti);

	virtual 
   HRESULT __stdcall
   GetTypeInfo(UINT cti, LCID, ITypeInfo **ppti);

   virtual 
   HRESULT __stdcall
	GetIDsOfNames(
	   REFIID  riid,    
	   OLECHAR **prgpsz,
	   UINT    cNames,  
	   LCID    lcid,    
	   DISPID  *prgids);

   virtual 
   HRESULT __stdcall
	Invoke(
	   DISPID     id,         
	   REFIID     riid,       
	   LCID       lcid,       
	   WORD       wFlags,     
	   DISPPARAMS *params,    
	   VARIANT    *pVarResult,
	   EXCEPINFO  *pei,       
	   UINT       *puArgErr); 

   // ISupportErrorInfo methods

   virtual 
   HRESULT __stdcall
   InterfaceSupportsErrorInfo(const IID& iid);
      
   // ICloneSecurityPrincipal methods

   virtual
	HRESULT __stdcall
	Connect(
		BSTR srcDomainController,
		BSTR srcDomain,          
		BSTR dstDomainController,
		BSTR dstDomain);         

   virtual
	HRESULT __stdcall
	CopyDownlevelUserProperties(
		BSTR srcSamName,
		BSTR dstSamName,
		long flags);    

   virtual 
   HRESULT __stdcall
   AddSidHistory(
		BSTR srcPrincipalSamName,
		BSTR dstPrincipalSamName,
		long flags);             

   virtual
   HRESULT __stdcall
   GetMembersSIDs(
		BSTR     dstGroupDN,
		VARIANT* pVal);

   // IADsSID methods

   virtual
   HRESULT __stdcall
	SetAs(
      long    lFormat, 
      VARIANT varData);

   virtual
   HRESULT __stdcall
   GetAs(
      long     lFormat,
      VARIANT* pVar);  

  // IADsError methods

   virtual
   HRESULT __stdcall
	GetErrorMsg(
      long  hrErr,
      BSTR* Msg); 

	private:

   // only our friend class factory can instantiate us.   
   CloneSecurityPrincipal();

   // only Release can cause us to be deleted

   virtual
   ~CloneSecurityPrincipal();

   // not implemented: no copying allowed
   CloneSecurityPrincipal(const CloneSecurityPrincipal&);
   const CloneSecurityPrincipal& operator=(const CloneSecurityPrincipal&);

   HRESULT
   DoAddSidHistory(
      const String& srcPrincipalSamName,
      const String& dstPrincipalSamName,
      long          flags);

   HRESULT
   DoCopyDownlevelUserProperties(
      const String& srcSamName,
      const String& dstSamName,
      long          flags);

   // represents the authenticated connection to the source and destination
   // domain controllers, including ds bindings

   class Connection
   {
      friend class CloneSecurityPrincipal;

      public:

      Connection();

      // disconnects, unbinds.
      ~Connection();

      HRESULT
      Connect(
         const String& srcDC,              
         const String& srcDomain,          
         const String& dstDC,              
         const String& dstDomain);

      bool
      IsConnected() const;

      private:

      Computer*  dstComputer;       
      SAM_HANDLE dstDomainSamHandle;
      HANDLE     dstDsBindHandle;   
      PLDAP      m_pldap;           
      Computer*  srcComputer;       
      String     srcDcDnsName;
      SAM_HANDLE srcDomainSamHandle;

      // not implemented: no copying allowed
      Connection(const Connection&);
      const Connection& operator=(const Connection&);

      void
      Disconnect();
   };

   Connection*        connection;  
   ComServerReference dllref;      
   long               refcount;    
   ITypeInfo**        m_ppTypeInfo;

   // used by IADsSID

   PSID	       m_pSID;
};



#endif   // IMPLMAIN_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsweb\dsctl\dsctl.cpp ===
// dsctl.cpp : Implementation of DLL Exports.

// To fully complete this project follow these steps

// You will need the new MIDL compiler to build this project.  Additionally,
// if you are building the proxy stub DLL, you will need new headers and libs.

// 1) Add a custom build step to dsctl.idl
//		You can select all of the .IDL files by holding Ctrl and clicking on
//		each of them.
//
//		Description
//			Running MIDL
//		Build Command(s)
//			midl dsctl.idl
//		Outputs
//			dsctl.tlb
//			dsctl.h
//			dsctl_i.c
//			dsctl_p.c
//			dlldata.c
//
// NOTE: You must use the MIDL compiler from NT 4.0, 
// preferably 3.00.15 or greater

// 2) Add a custom build step to the project to register the DLL
//		For this, you can select all projects at once
//		Description
//			Registering OLE Server...
//		Build Command(s)
//			regsvr32 /s /c "$(TargetPath)"
//			echo regsvr32 exec. time > "$(OutDir)\regsvr32.trg"
//		Outputs
//			$(OutDir)\regsvr32.trg

// 3) To add UNICODE support, follow these steps
//		Select Build|Configurations...
//		Press Add...
//		Change the configuration name to Unicode Release
//		Change the "Copy Settings From" combo to dsctl - Win32 Release
//		Press OK
//		Press Add...
//		Change the configuration name to Unicode Debug
//		Change the "Copy Settings From" combo to dsctl - Win32 Debug
//		Press OK
//		Press "Close"
//		Select Build|Settings...
//		Select the two UNICODE projects and press the C++ tab.
//		Select the "General" category
//		Add _UNICODE to the Preprocessor definitions
//		Select the Unicode Debug project
//		Press the "General" tab
//		Specify DebugU for the intermediate and output directories
//		Select the Unicode Release project
//		Press the "General" tab
//		Specify ReleaseU for the intermediate and output directories

// 4) Proxy stub DLL
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		is turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//		To build a separate proxy/stub DLL, 
//		run nmake -f ps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "dsctl.h"
#include "DsctlObj.h"
#include "dlldatax.h"

#define IID_DEFINED
#include "dsctl_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Dsctl, CDsctlObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hRes = S_OK;
#ifdef _MERGE_PROXYSTUB
	hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	hRes = _Module.RegisterServer(TRUE);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hRes = S_OK;
	_Module.UnregisterServer();
#ifdef _MERGE_PROXYSTUB
	hRes = PrxDllUnregisterServer();
#endif
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsweb\dsctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsctl.rc
//
#define IDS_DSCTL_DESC	1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsweb\dsctl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include "atlimpl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsweb\dsctl\dsctlobj.cpp ===
// DsctlObj.cpp : Implementation of CdsctlApp and DLL registration.

#include "stdafx.h"
#include <wininet.h>
#include "dsctl.h"
#include "DsctlObj.h"
#include <activeds.h>

TCHAR DebugOut[MAX_PATH];

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CDsctlObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	if (riid == IID_IDsctl)
		return S_OK;
	return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsctlObject::DSGetObject
//
//  Synopsis:   Returns a DS object.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDsctlObject::DSGetObject(VARIANT ADsPath, VARIANT * pRetVar)
{
    HRESULT hr;

    VariantInit(pRetVar);
    
    //    DebugBreak();

    if (ADsPath.vt != VT_BSTR)
    {
#ifdef DBG
        OutputDebugString(TEXT("DSctl::DsGetObject not passed a string!\n"));
#endif
        pRetVar->vt = VT_ERROR;
        pRetVar->scode = E_INVALIDARG;
        return E_INVALIDARG;
    }

    m_Path = SysAllocString(ADsPath.bstrVal);

    if (m_Path == NULL)
    {
#ifdef DBG
        OutputDebugString(TEXT("DSctl::DsGetObject allocation failed!\n"));
#endif
        pRetVar->vt = VT_ERROR;
        pRetVar->scode = E_OUTOFMEMORY;
        return E_OUTOFMEMORY;
    }

#ifdef DBG
    wsprintf(DebugOut, TEXT("DSctl::DsGetObject: Path to object is: %ws\n"),
             m_Path);
    OutputDebugString(DebugOut);
#endif

    hr = ADsGetObject(m_Path, IID_IDispatch, (void **)&pRetVar->pdispVal);

    if (FAILED(hr))
    {
#ifdef DBG
        wsprintf(DebugOut,
                 TEXT("DSctl::DsGetObject: ADsGetObject returned: %lx\n"), hr);
        OutputDebugString(DebugOut);
#endif
        pRetVar->vt = VT_ERROR;
        pRetVar->scode = E_FAIL;
        return E_FAIL;
    }

#ifdef DBG
    wsprintf(DebugOut,
             TEXT("DSctl::DsGetObject - Returning Object: 0x%x\n\n"),
             pRetVar->pdispVal);
    OutputDebugString(DebugOut);
#endif

    pRetVar->vt = VT_DISPATCH;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsctlObject::DSGetEnum
//
//  Synopsis:   Returns a container enumerator
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsctlObject::DSGetEnum(VARIANT ADsPath, VARIANT* retval) 
{
	HRESULT hr;

    VARIANT vaResult;
    IADsContainer *pCont;
	VariantInit(&vaResult);
    if (ADsPath.vt == VT_BSTR) {
         m_Path = SysAllocString(ADsPath.bstrVal);
    } else {
        vaResult.vt = VT_ERROR;
        vaResult.scode = E_FAIL;
#ifdef DBG
        OutputDebugString(TEXT("DSctl: DSGetEnum not passed a string path\n"));
#endif
        *retval = vaResult;
        return S_OK;
    }

	//	DebugBreak();

#ifdef DBG
    OutputDebugString(TEXT("DSctl: GetEnum entered...\n"));
    wsprintf (DebugOut, TEXT("DSctl: ptr to object is: %lx\n"), &ADsPath);
    OutputDebugString(DebugOut);
    wsprintf (DebugOut, TEXT("DSctl: Path to object is: %ws\n"), ADsPath.bstrVal);
    OutputDebugString(DebugOut);
#endif
    
    hr = ADsGetObject(m_Path, IID_IADsContainer,(void **)&pCont);
    if (SUCCEEDED(hr)) {
        hr = ADsBuildEnumerator(pCont,(IEnumVARIANT**)&vaResult.punkVal);
        if (SUCCEEDED(hr))
            vaResult.vt = VT_UNKNOWN;
        else {
            vaResult.vt = VT_ERROR;
            vaResult.scode = E_FAIL;
#ifdef DBG
            wsprintf(DebugOut,
                     TEXT("DSctl: OleDSBuildEnumerator returned: %lx\n"), hr);
            OutputDebugString(DebugOut);
#endif
        }
    } else {
        vaResult.vt = VT_ERROR;
        vaResult.scode = E_FAIL;
#ifdef DBG
        wsprintf (DebugOut, TEXT("DSctl: OleDSGetObject returned: %lx\n"), hr);
        OutputDebugString(DebugOut);
#endif
    }

    *retval = vaResult;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsctlObject::DSGetMemberEnum
//
//  Synopsis:   Returns a members (group) object enumerator
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsctlObject::DSGetMemberEnum(VARIANT ObjectPtr, VARIANT* retval) 
{
#ifdef DBG
    OutputDebugString(TEXT("DSctl: GetMemberEnum entered...\n"));
#endif
    VARIANT vaResult;
	VariantInit(&vaResult);
    IUnknown * pDisp;

    //
    // Get the DS object pointer.
    //
    if (ObjectPtr.vt == VT_DISPATCH || ObjectPtr.vt == VT_UNKNOWN)
    {
        pDisp = ObjectPtr.pdispVal;
    }
    else
    {
        if (ObjectPtr.vt == (VT_BYREF | VT_VARIANT))
        {
            if ((ObjectPtr.pvarVal)->vt == VT_DISPATCH ||
                (ObjectPtr.pvarVal)->vt == VT_UNKNOWN)
            {
                pDisp = (ObjectPtr.pvarVal)->pdispVal;
            }
            else
            {
                vaResult.vt = VT_ERROR;
                vaResult.scode = E_FAIL;
                *retval = vaResult;
                return S_OK;
            }
        }
    }
    IADsMembers * pDsMembers;
    HRESULT hr = pDisp->QueryInterface(IID_IADsMembers, (void **)&pDsMembers);

    if (FAILED(hr))
    {
        vaResult.vt = VT_ERROR;
        vaResult.scode = E_FAIL;
        *retval = vaResult;
        return S_OK;
    }

    hr = pDsMembers->get__NewEnum((IUnknown **)&vaResult.punkVal);
    
    if (SUCCEEDED(hr)) {
        vaResult.vt = VT_UNKNOWN;
    } else {
        vaResult.vt = VT_ERROR;
        vaResult.scode = E_FAIL;
#ifdef DBG
        wsprintf(DebugOut,
                 TEXT("DSctl: OleDSBuildEnumerator returned: %lx\n"), hr);
        OutputDebugString(DebugOut);
#endif
    }
    pDsMembers->Release();

    *retval = vaResult;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsctlObject::DSEnumNext
//
//  Synopsis:   Iterates through the enumeration sequence
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsctlObject::DSEnumNext(VARIANT Enum, VARIANT* retval) 
{
	HRESULT hr;
    VARIANT vaResult;
    ULONG   iCount;
    
    VariantInit(&vaResult);

	if (Enum.punkVal == NULL) {
		vaResult.vt = VT_ERROR;
        vaResult.scode = E_FAIL;
	} else {
		//DebugBreak();
		hr = ADsEnumerateNext((IEnumVARIANT*)Enum.punkVal,1,&vaResult,&iCount);
		if (!SUCCEEDED(hr)) {
			ADsFreeEnumerator((IEnumVARIANT*)Enum.punkVal);
			vaResult.vt = VT_ERROR;
			vaResult.scode = E_FAIL;
		}
	}
	*retval = vaResult;
	return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsctlObject::DSIsContainer
//
//  Synopsis:   Checks if the object is a container.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsctlObject::DSIsContainer(VARIANT ObjectPtr, VARIANT* retval) 
{
    VARIANT vaResult;
#ifdef DBG
    OutputDebugString(TEXT("Entering CDsctlObject::DSIsContainer.\n"));
#endif
    VariantInit(&vaResult);
	vaResult.vt = VT_BOOL;
    vaResult.boolVal = VARIANT_FALSE;

    IUnknown * pDisp;

    //
    // Get the DS object pointer.
    //
    if (ObjectPtr.vt == VT_DISPATCH || ObjectPtr.vt == VT_UNKNOWN)
    {
        pDisp = ObjectPtr.pdispVal;
    }
    else
    {
        if (ObjectPtr.vt == (VT_BYREF | VT_VARIANT))
        {
            if ((ObjectPtr.pvarVal)->vt == VT_DISPATCH ||
                (ObjectPtr.pvarVal)->vt == VT_UNKNOWN)
            {
                pDisp = (ObjectPtr.pvarVal)->pdispVal;
            }
            else
            {
                //
                // If we don't know what sort of argument we received, then
                // just return FALSE.
                //
#ifdef DBG
                OutputDebugString(TEXT("DSIsContainer - can't make sense of argument!\n"));
#endif
                *retval = vaResult;
                return S_OK;
            }
        }
    }
    IADs * pDsObject;
    HRESULT hr = pDisp->QueryInterface(IID_IADs, (void **)&pDsObject);

    if (SUCCEEDED(hr))
    {
        //pDisp->Release();
    }
    else
    {
#ifdef DBG
        OutputDebugString(TEXT("DSIsContainer - QI for IID_IADs failed!\n"));
#endif
        *retval = vaResult;
        return S_OK;
    }

    BSTR bstrSchema;
    IADsClass * pDsClass;
    VARIANT_BOOL bIsContainer;

    //
    // Objects are containers if their schema says they are containers...
    //
    if (SUCCEEDED(pDsObject->get_Schema( &bstrSchema )))
    {
        if (SUCCEEDED(ADsGetObject(bstrSchema, IID_IADsClass, (LPVOID *)&pDsClass)))
        {
            if (SUCCEEDED(pDsClass->get_Container(&bIsContainer)))
            {
                vaResult.boolVal = bIsContainer;
#ifdef DBG
                wsprintf(DebugOut, TEXT("DSIsContainer returned: %lx\n"),
                         bIsContainer);
                OutputDebugString(DebugOut);
#endif
            }
    		pDsClass->Release();
        }
        SysFreeString(bstrSchema);
    }
    else
    {
        // If the get_Schema fails, we can assume it's a container (says yihsins)
        vaResult.boolVal = VARIANT_TRUE;
#ifdef DBG
        OutputDebugString(TEXT("DSIsContainer returning TRUE because get_Schema failed.\n"));
#endif
    }

    pDsObject->Release();

	*retval = vaResult;

#ifdef DBG
    OutputDebugString(TEXT("Exiting CDsctlObject::DSIsContainer\n"));
#endif
	return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsctlObject::DSGetLastError
//
//  Synopsis:   Checks ADs extended error.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsctlObject::DSGetLastError(VARIANT* retval) 
{
    VARIANT vaResult;
#ifdef DBG
    OutputDebugString(TEXT("Entering CDsctlObject::DSGetLastError.\n"));
#endif
    VariantInit(&vaResult);
	vaResult.vt = VT_EMPTY;
	vaResult.vt = VT_BSTR;

	*retval = vaResult;

    //
    // There doesn't seem to be a way to detect if the returned string is
    // truncated. Hopefully, this size will be large enough (the function
    // header, in oleds\router\oledserr.cxx, says that 256 bytes is the
    // recommended minimum for the error buffer and that the returned string
    // will always be null terminated).
    //
#   define ERRBUFSIZE 512

    DWORD dwErr;
    WCHAR wszErrBuf[ERRBUFSIZE];

    HRESULT hr = ADsGetLastError(&dwErr,
                                   wszErrBuf,
                                   ERRBUFSIZE,
                                   NULL,
                                   0);

    if (FAILED(hr))
    {
#ifdef DBG
        wsprintf(DebugOut, TEXT("DSctl: ADsGetLastError returned: %lx\n"), hr);
        OutputDebugString(DebugOut);
#endif
        return hr;
    }

    wsprintf(DebugOut, TEXT("DSctl::ADsGetLastError: error = 0x%lx, errstr = %S\n"),
             dwErr, wszErrBuf);
    OutputDebugString(DebugOut);

    BSTR bstr = SysAllocString(wszErrBuf);
    if (bstr == NULL)
    {
        return E_OUTOFMEMORY;
    }

	vaResult.vt = VT_BSTR;
    vaResult.bstrVal = bstr;

	*retval = vaResult;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsctlObject::DecodeURL
//
//  Synopsis:   Returns the decoded URL.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsctlObject::DecodeURL(VARIANT EncodedURL, VARIANT * pRetVar)
{
#ifdef DBG
    wsprintf(DebugOut, TEXT("\nDSctl::DecodeURL: in param address: %x\n"),
             &EncodedURL);
    OutputDebugString(DebugOut);
#endif
    //DebugBreak();

    VariantInit(pRetVar);

    if (EncodedURL.vt != VT_BSTR)
    {
#ifdef DBG
        OutputDebugString(TEXT("DSctl::DecodeURL not passed a string\n"));
#endif
        pRetVar->vt = VT_ERROR;
        pRetVar->scode = E_INVALIDARG;
        return E_INVALIDARG;
    }

#ifdef DBG
    wsprintf(DebugOut, TEXT("DSctl::DecodeURL: input is %ws\n"),
             EncodedURL.bstrVal);
    OutputDebugString(DebugOut);
#endif

    //
    // DeURLize path
    //
    TCHAR szDecodedURL[INTERNET_MAX_URL_LENGTH];
    DWORD dwLen = INTERNET_MAX_URL_LENGTH;

    if (!InternetCanonicalizeUrl(EncodedURL.bstrVal, szDecodedURL, &dwLen,
                                 ICU_DECODE | ICU_NO_ENCODE))
    {
        pRetVar->vt = VT_ERROR;
        pRetVar->scode = E_FAIL;
#ifdef DBG
        wsprintf(DebugOut,
                 TEXT("DSctl: InternetCanonicalizeUrl returned: %lx!\n"),
                 GetLastError());
        OutputDebugString(DebugOut);
#endif
        return E_FAIL;
    }

    if (_tcsstr(szDecodedURL, TEXT("ldap")) != NULL)
    {
        //
        // Convert the protocol sequence to upper case.
        //
        _tcsncpy(szDecodedURL, TEXT("LDAP"), 4);
    }

    pRetVar->vt = VT_BSTR;
    pRetVar->bstrVal = SysAllocString(szDecodedURL);

    if (pRetVar->bstrVal == NULL)
    {
#ifdef DBG
        OutputDebugString(TEXT("DSctl::DecodeURL: allocation failed!\n"));
#endif
        pRetVar->vt = VT_ERROR;
        pRetVar->scode = E_OUTOFMEMORY;
        return E_OUTOFMEMORY;
    }

#ifdef DBG
    wsprintf(DebugOut, TEXT("DSctl::DecodeURL: decoded URL is: %ws\n\n"),
             pRetVar->bstrVal);
    OutputDebugString(DebugOut);
#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsweb\dsctl\dsctlobj.h ===
// DsctlObj.h : Declaration of the CDsctlObject


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// dsctl

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CDsctlObject : 
	public CComDualImpl<IDsctl, &IID_IDsctl, &LIBID_DSCTLLib>, 
	public ISupportErrorInfo,
        public CComObjectRoot,
	public CComCoClass<CDsctlObject, &CLSID_Dsctl>
{
public:
	CDsctlObject() {}
BEGIN_COM_MAP(CDsctlObject)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IDsctl)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CDsctlObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CDsctlObject)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    DECLARE_REGISTRY(CDsctlObject, TEXT("ADS.Connector.1"),
                     TEXT("ADS.Connector.1"), IDS_DSCTL_DESC, THREADFLAGS_BOTH)
// IDsctl
public:
    BSTR m_Path;


    STDMETHOD (DSGetObject) (VARIANT ADsPath, VARIANT* retval);
    STDMETHOD (DSGetEnum) (VARIANT ADsPath, VARIANT* retval);
    STDMETHOD (DSEnumNext) (VARIANT Enum, VARIANT* retval);
    STDMETHOD (DSIsContainer) (VARIANT ObjectPtr, VARIANT* retval);
    STDMETHOD (DSGetLastError) (VARIANT* retval);
    STDMETHOD (DSGetMemberEnum) (VARIANT ObjectPtr, VARIANT* retval);
    STDMETHOD (DecodeURL) (VARIANT EncodedURL, VARIANT * retval);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dsweb\dsctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\accessck.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       AccessCk.cpp
//
//  Contents:   Functions imported and modified from ntos\se\accessck.c
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "AccessCk.h"
#include "adutils.h"


typedef enum {
    UpdateRemaining,
    UpdateCurrentGranted,
    UpdateCurrentDenied
} ACCESS_MASK_FIELD_TO_UPDATE;



//
//  Prototypes
//
BOOLEAN
SepSidInSIDList (
    IN list<PSID>& psidList,
    IN PSID PrincipalSelfSid,
    IN PSID Sid);


HRESULT
SepAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    IN ULONG StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate,
    IN PSID grantingSid
);

BOOLEAN
SepObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    OUT PULONG ReturnedIndex
);


HRESULT
SepUpdateParentTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    IN ULONG StartIndex,
    IN PSID grantingSid
);

HRESULT
SetGrantingSid (
        IOBJECT_TYPE_LIST& ObjectTypeItem, 
        ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate, 
        ACCESS_MASK oldAccessBits,
        ACCESS_MASK newAccessBits,
        PSID grantingSid);

///////////////////////////////////////////////////////////////////////////////


PSID SePrincipalSelfSid = 0;
static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;

HRESULT SepInit ()
{
    HRESULT hr = S_OK;
    ULONG   SidWithOneSubAuthority = RtlLengthRequiredSid (1);


    SePrincipalSelfSid = (PSID) CoTaskMemAlloc (SidWithOneSubAuthority);
    if ( SePrincipalSelfSid )
    {
        SID_IDENTIFIER_AUTHORITY    SeNtAuthority = SepNtAuthority;

        RtlInitializeSid (SePrincipalSelfSid, &SeNtAuthority, 1);
        *(RtlSubAuthoritySid (SePrincipalSelfSid, 0)) = SECURITY_PRINCIPAL_SELF_RID;
    }
    else
        hr = E_OUTOFMEMORY;


    return hr;
}

VOID SepCleanup ()
{
    if ( SePrincipalSelfSid )
    {
        CoTaskMemFree (SePrincipalSelfSid);
        SePrincipalSelfSid = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
SepMaximumAccessCheck(
    list<PSID>& psidList,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN size_t LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN size_t ObjectTypeListLength
    )
/*++

Routine Description:

    Does an access check for maximum allowed or with a result list. The current
    granted access is stored in the Remaining access and then another access
    check is run.

Arguments:
    psidList - list of object sid to check, plus sids of all groups that the object belongs to

    Dacl - ACL to check

    PrincipalSelfSid - Sid to use in replacing the well-known self sid

    LocalTypeListLength - Length of list of types.

    LocalTypeList - List of types.

    ObjectTypeList - Length of caller-supplied list of object types.

Return Value:

    none

--*/

{
    if ( !LocalTypeList || ! Dacl )
        return E_POINTER;

    if ( PrincipalSelfSid && !IsValidSid (PrincipalSelfSid) )
        return E_INVALIDARG;
    _TRACE (1, L"Entering  SepMaximumAccessCheck\n");

    PVOID   Ace = 0;
    ULONG   AceCount = Dacl->AceCount;
    ULONG   Index = 0;
    HRESULT hr = S_OK;

    //
    // granted == NUL
    // denied == NUL
    //
    //  for each ACE
    //
    //      if grant
    //          for each SID
    //              if SID match, then add all that is not denied to grant mask
    //
    //      if deny
    //          for each SID
    //              if SID match, then add all that is not granted to deny mask
    //

    ULONG i = 0;
    for (Ace = FirstAce (Dacl);
          i < AceCount;
          i++, Ace = NextAce (Ace)) 
    {
        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) 
        {
            switch (((PACE_HEADER)Ace)->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                if (SepSidInSIDList(psidList, PrincipalSelfSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart)) 
                {

                    //
                    // Only grant access types from this mask that have
                    // not already been denied
                    //

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) 
                    {
                        // TODO: do granting SID

                        LocalTypeList->CurrentGranted |=
                           (((PACCESS_ALLOWED_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                    } 
                    else 
                    {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       hr = SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateCurrentGranted,
                            &((PACCESS_ALLOWED_ACE)Ace)->SidStart);
                   }
                }
                break;

            //
            // Handle an object specific Access Allowed ACE
            //
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                {
                    //
                    // If no object type is in the ACE,
                    //  treat this as an ACCESS_ALLOWED_ACE.
                    //

                    GUID* ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                    if ( ObjectTypeInAce == NULL ) 
                    {
                        if ( SepSidInSIDList(psidList, PrincipalSelfSid, RtlObjectAceSid(Ace)) ) 
                        {
                            // Optimize 'normal' case
                            if ( LocalTypeListLength == 1 ) 
                            {
                                // TODO: do granting SID
                                LocalTypeList->CurrentGranted |=
                                   (((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                            } 
                            else 
                            {
                                hr = SepAddAccessTypeList(
                                    LocalTypeList,          // List to modify
                                    LocalTypeListLength,    // Length of list
                                    0,                      // Element to update
                                    ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                    UpdateCurrentGranted,
                                    RtlObjectAceSid(Ace));
                            }
                        }

                    //
                    // If no object type list was passed,
                    //  don't grant access to anyone.
                    //

                    } 
                    else if ( ObjectTypeListLength == 0 ) 
                    {

                        // Drop through


                   //
                   // If an object type is in the ACE,
                   //   Find it in the LocalTypeList before using the ACE.
                   //
                    } 
                    else 
                    {

                        if ( SepSidInSIDList(psidList, PrincipalSelfSid, RtlObjectAceSid(Ace)) ) 
                        {
                            if ( SepObjectInTypeList( ObjectTypeInAce,
                                                      LocalTypeList,
                                                      LocalTypeListLength,
                                                      &Index ) ) 
                            {
                                hr = SepAddAccessTypeList(
                                     LocalTypeList,          // List to modify
                                     LocalTypeListLength,   // Length of list
                                     Index,                  // Element already updated
                                     ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                     UpdateCurrentGranted,
                                     RtlObjectAceSid(Ace));
                            }
                        }
                   }
                } 
                break;

            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                //
                //  If we're impersonating, EToken is set to the Client, and if we're not,
                //  EToken is set to the Primary.  According to the DSA architecture, if
                //  we're asked to evaluate a compound ACE and we're not impersonating,
                //  pretend we are impersonating ourselves.  So we can just use the EToken
                //  for the client token, since it's already set to the right thing.
                //


                if ( SepSidInSIDList(psidList, PrincipalSelfSid, RtlCompoundAceClientSid( Ace )) &&
                     SepSidInSIDList(psidList,  NULL, RtlCompoundAceServerSid( Ace )) ) 
                {

                    //
                    // Only grant access types from this mask that have
                    // not already been denied
                    //

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) 
                    {
                        // TODO: do granting SID
                        LocalTypeList->CurrentGranted |=
                           (((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                    } 
                    else 
                    {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       hr = SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateCurrentGranted,
                            RtlCompoundAceClientSid (Ace));
                    }
                }
                break;

            case ACCESS_DENIED_ACE_TYPE:
                if ( SepSidInSIDList(psidList, PrincipalSelfSid, &((PACCESS_DENIED_ACE)Ace)->SidStart)) 
                {
                     //
                     // Only deny access types from this mask that have
                     // not already been granted
                     //

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) 
                    {
                        // TODO: do granting SID
                        LocalTypeList->CurrentDenied |=
                            (((PACCESS_DENIED_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);
                    } 
                    else 
                    {
                        //
                        // The zeroeth object type represents the object itself.
                        //
                        hr = SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_DENIED_ACE)Ace)->Mask, // Access denied
                            UpdateCurrentDenied,
                            &((PACCESS_DENIED_ACE)Ace)->SidStart);
                   }
                }
                break;

            //
            // Handle an object specific Access Denied ACE
            //
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                {
                    PSID    psid = RtlObjectAceSid(Ace);
					ASSERT (IsValidSid (psid));

                    if ( IsValidSid (psid) && SepSidInSIDList(psidList, PrincipalSelfSid, psid) ) 
                    {
                        //
                        // If there is no object type in the ACE,
                        //  or if the caller didn't specify an object type list,
                        //  apply this deny ACE to the entire object.
                        //

                        GUID* ObjectTypeInAce = RtlObjectAceObjectType(Ace);
                        if ( ObjectTypeInAce == NULL ||
                             ObjectTypeListLength == 0 ) 
                        {
                            // TODO: do granting SID
                            LocalTypeList->CurrentDenied |=
                                (((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);

                        //
                        // Otherwise apply the deny ACE to the object specified
                        //  in the ACE.
                        //

                        } 
                        else if ( SepObjectInTypeList( ObjectTypeInAce,
                                                      LocalTypeList,
                                                      LocalTypeListLength,
                                                      &Index ) ) 
                        {
                            hr = SepAddAccessTypeList(
                                LocalTypeList,          // List to modify
                                LocalTypeListLength,    // Length of list
                                Index,                  // Element to update
                                ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask, // Access denied
                                UpdateCurrentDenied,
                                psid);
                        }
                    }
                }
                break;

            default:
                break;
            }
        }
    }

    _TRACE (-1, L"Leaving SepMaximumAccessCheck\n");
    return hr;
}


NTSTATUS
SeCaptureObjectTypeList (
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN size_t ObjectTypeListLength,
    OUT PIOBJECT_TYPE_LIST *CapturedObjectTypeList
)
/*++

Routine Description:

    This routine probes and captures a copy of any object type list
    that might have been provided via the ObjectTypeList argument.

    The object type list is converted to the internal form that explicitly
    specifies the hierarchical relationship between the entries.

    The object typs list is validated to ensure a valid hierarchical
    relationship is represented.

Arguments:

    ObjectTypeList - The object type list from which the type list
        information is to be retrieved.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    CapturedObjectTypeList - Receives the captured type list which
        must be freed using SeFreeCapturedObjectTypeList().

Return Value:

    STATUS_SUCCESS indicates no exceptions were encountered.

    Any access violations encountered will be returned.

--*/

{
    _TRACE (1, L"Entering  SeCaptureObjectTypeList\n");
    NTSTATUS            Status = STATUS_SUCCESS;
    PIOBJECT_TYPE_LIST  LocalTypeList = NULL;
    ULONG               Levels[ACCESS_MAX_LEVEL+1];

    //
    //  Set default return
    //

    *CapturedObjectTypeList = NULL;


    if ( ObjectTypeListLength == 0 ) 
    {

        // Drop through

    } 
    else if ( !ARGUMENT_PRESENT(ObjectTypeList) ) 
    {
        Status = STATUS_INVALID_PARAMETER;

    } 
    else 
    {
        //
        // Allocate a buffer to copy into.
        //

        LocalTypeList = new IOBJECT_TYPE_LIST[ObjectTypeListLength];
        if ( !LocalTypeList ) 
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // Copy the callers structure to the local structure.
        //

        } 
        else 
        {
            GUID * CapturedObjectType = 0;
            for (ULONG i=0; i < ObjectTypeListLength; i++ ) 
            {
                //
                // Limit ourselves
                //
                USHORT CurrentLevel = ObjectTypeList[i].Level;
                if ( CurrentLevel > ACCESS_MAX_LEVEL ) 
                {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy data the caller passed in
                //
                LocalTypeList[i].Level = CurrentLevel;
                LocalTypeList[i].Flags = 0;
                CapturedObjectType = ObjectTypeList[i].ObjectType;
                LocalTypeList[i].ObjectType = *CapturedObjectType;
                LocalTypeList[i].Remaining = 0;
                LocalTypeList[i].CurrentGranted = 0;
                LocalTypeList[i].CurrentDenied = 0;

                //
                // Ensure that the level number is consistent with the
                //  level number of the previous entry.
                //

                if ( i == 0 ) 
                {
                    if ( CurrentLevel != 0 ) 
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                } 
                else 
                {

                    //
                    // The previous entry is either:
                    //  my immediate parent,
                    //  my sibling, or
                    //  the child (or grandchild, etc.) of my sibling.
                    //
                    if ( CurrentLevel > LocalTypeList[i-1].Level + 1 ) 
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                    //
                    // Don't support two roots.
                    //
                    if ( CurrentLevel == 0 ) 
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                }

                //
                // If the above rules are maintained,
                //  then my parent object is the last object seen that
                //  has a level one less than mine.
                //

                if ( CurrentLevel == 0 ) 
                {
                    LocalTypeList[i].ParentIndex = -1;
                } 
                else 
                {
                    LocalTypeList[i].ParentIndex = Levels[CurrentLevel-1];
                }

                //
                // Save this obect as the last object seen at this level.
                //

                Levels[CurrentLevel] = i;

            }

        }

    } // end_if

    *CapturedObjectTypeList = LocalTypeList;
    _TRACE (-1, L"Leaving SeCaptureObjectTypeList: Status = 0x%x\n", Status);
    return Status;
}


BOOLEAN
SepSidInSIDList (
    IN list<PSID>& psidList,
    IN PSID PrincipalSelfSid,
    IN PSID Sid)

/*++

Routine Description:

    Checks to see if a given restricted SID is in the given sid list.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

Arguments:

    psidList - the list of sids to be examined

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest

    DenyAce - The ACE being evaluated is a DENY or ACCESS DENIED ace

    Restricted - The access check being performed uses the restricted sids.

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/

{
    _TRACE (1, L"Entering  SeSidInSIDList\n");
    BOOLEAN bRVal = FALSE;
    PISID   MatchSid = 0;


    ASSERT (IsValidSid (Sid));
    if ( IsValidSid (Sid) )
    {
        //
        // If Sid is the constant PrincipalSelfSid,
        //  replace it with the passed in PrincipalSelfSid.
        //

        if ( PrincipalSelfSid != NULL && EqualSid (SePrincipalSelfSid, Sid) ) 
        {
            Sid = PrincipalSelfSid;
        }

        //
        // Get address of user/group array and number of user/groups.
        //

        //
        // Scan through the user/groups and attempt to find a match with the
        // specified SID.
        //

        ULONG i = 0;
        for (list<PSID>::iterator itr = psidList.begin (); 
                itr != psidList.end (); 
                itr++, i++) 
        {
            ASSERT (IsValidSid (*itr));
            MatchSid = (PISID)*itr;

            if ( ::EqualSid (Sid, *itr) )
            {
                bRVal = true;
                break;
            }
        }
    }

    _TRACE (-1, L"Leaving SeSidInSIDList: %s\n", bRVal ? L"TRUE" : L"FALSE");
    return bRVal;
}

HRESULT
SepAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    IN ULONG StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate,
    IN PSID grantingSid
)
/*++

Routine Description:

    This routine grants the specified AccessMask to all of the objects that
    are descendents of the object specified by StartIndex.

    The Access fields of the parent objects are also recomputed as needed.

    For example, if an ACE granting access to a Property Set is found,
        that access is granted to all the Properties in the Property Set.

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the target element to update.

    AccessMask - Mask of access to grant to the target element and
        all of its decendents

    FieldToUpdate - Indicate which fields to update in object type list

Return Value:

    None.

--*/

{
    if ( !ObjectTypeList )
        return E_POINTER;
    if ( !IsValidSid (grantingSid) )
        return E_INVALIDARG;
    _TRACE (1, L"Entering  SepAddAccessTypeList\n");

    ACCESS_MASK OldRemaining = 0;
    ACCESS_MASK OldCurrentGranted = 0;
    ACCESS_MASK OldCurrentDenied = 0;
    BOOLEAN     AvoidParent = FALSE;
    HRESULT     hr = S_OK;

//    PAGED_CODE();

    //
    // Update the requested field.
    //
    // Always handle the target entry.
    //
    // If we've not actually changed the bits,
    //  early out.
    //

    switch (FieldToUpdate ) 
    {
    case UpdateRemaining:
        OldRemaining = ObjectTypeList[StartIndex].Remaining;
        ObjectTypeList[StartIndex].Remaining = OldRemaining & ~AccessMask;

        if ( OldRemaining == ObjectTypeList[StartIndex].Remaining ) 
        {
            return hr;
        }
        else
        {
            hr = SetGrantingSid (
                    ObjectTypeList[StartIndex], 
                    FieldToUpdate, 
                    OldRemaining,
                    AccessMask & ~ObjectTypeList[StartIndex].Remaining,
                    grantingSid);
        }
        break;

    case UpdateCurrentGranted:
        OldCurrentGranted = ObjectTypeList[StartIndex].CurrentGranted;
        ObjectTypeList[StartIndex].CurrentGranted |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentDenied;

        if ( OldCurrentGranted == ObjectTypeList[StartIndex].CurrentGranted ) 
        {
            //
            // We can't simply return here.
            // We have to visit our children.  Consider the case where there
            // was a previous deny ACE on a child.  That deny would have
            // propagated up the tree to this entry.  However, this allow ACE
            // needs to be added all of the children that haven't been
            // explictly denied.
            //
            AvoidParent = TRUE;
        }
        else
        {
            hr = SetGrantingSid (
                    ObjectTypeList[StartIndex], 
                    FieldToUpdate, 
                    OldCurrentGranted,
                    AccessMask & ~ObjectTypeList[StartIndex].CurrentDenied,
                    grantingSid);
        }
        break;

    case UpdateCurrentDenied:
        OldCurrentDenied = ObjectTypeList[StartIndex].CurrentDenied;
        ObjectTypeList[StartIndex].CurrentDenied |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentGranted;

        if ( OldCurrentDenied == ObjectTypeList[StartIndex].CurrentDenied ) 
        {
            return hr;
        }
        else
        {
            hr = SetGrantingSid (
                    ObjectTypeList[StartIndex], 
                    FieldToUpdate, 
                    OldCurrentDenied,
                    AccessMask & ~ObjectTypeList[StartIndex].CurrentGranted,
                    grantingSid);
        }
        break;

    default:
        return hr;
    }


    //
    // Go update parent of the target.
    //

    if ( !AvoidParent ) 
    {
        hr = SepUpdateParentTypeList( ObjectTypeList,
                                 ObjectTypeListLength,
                                 StartIndex,
                                 grantingSid);
    }

    //
    // Loop handling all children of the target.
    //

    for (ULONG Index = StartIndex + 1; Index < ObjectTypeListLength; Index++) 
    {
        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[StartIndex].Level ) 
        {
            break;
        }

        //
        // Grant access to the children
        //

        switch (FieldToUpdate) 
        {
        case UpdateRemaining:
            ObjectTypeList[Index].Remaining &= ~AccessMask;
            hr = SetGrantingSid (
                    ObjectTypeList[Index], 
                    FieldToUpdate, 
                    OldRemaining,
                    ~AccessMask,
                    grantingSid);
            break;

        case UpdateCurrentGranted:
            ObjectTypeList[Index].CurrentGranted |=
                AccessMask & ~ObjectTypeList[Index].CurrentDenied;
            hr = SetGrantingSid (
                    ObjectTypeList[Index], 
                    FieldToUpdate, 
                    OldCurrentGranted,
                    AccessMask & ~ObjectTypeList[Index].CurrentDenied,
                    grantingSid);
            break;

        case UpdateCurrentDenied:
            ObjectTypeList[Index].CurrentDenied |=
                AccessMask & ~ObjectTypeList[Index].CurrentGranted;
            hr = SetGrantingSid (
                    ObjectTypeList[Index], 
                    FieldToUpdate, 
                    OldCurrentDenied,
                    AccessMask & ~ObjectTypeList[Index].CurrentGranted,
                    grantingSid);
            break;

        default:
            return hr;
        }
    }

    _TRACE (-1, L"Leaving SepAddAccessTypeList\n");
    return hr;
}


BOOLEAN
SepObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    OUT PULONG ReturnedIndex
)
/*++

Routine Description:

    This routine searches an ObjectTypeList to determine if the specified
    object type is in the list.

Arguments:

    ObjectType - Object Type to search for.

    ObjectTypeList - The object type list to search.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    ReturnedIndex - Index to the element ObjectType was found in


Return Value:

    TRUE: ObjectType was found in list.
    FALSE: ObjectType was not found in list.

--*/

{
    if ( !ObjectType || !ObjectTypeList )
        return FALSE;
    _TRACE (1, L"Entering  SepObjectInTypeList\n");

    BOOLEAN bRVal = FALSE;
    GUID*   LocalObjectType = 0;

#if DBG
    HRESULT     hr = S_OK;
    GUID_TYPE*  pType = 0;
    wstring     strClassName1;


    hr = _Module.GetClassFromGUID (*ObjectType, strClassName1, pType);
    ASSERT (SUCCEEDED (hr));
#endif

#pragma warning (disable : 4127)
    ASSERT( sizeof(GUID) == sizeof(ULONG) * 4 );
#pragma warning (default : 4127)

    for (ULONG Index = 0; Index < ObjectTypeListLength; Index++) 
    {
        LocalObjectType = &ObjectTypeList[Index].ObjectType;
#if DBG
        wstring strClassName2;

        hr = _Module.GetClassFromGUID (*LocalObjectType, strClassName2, pType);
        ASSERT (SUCCEEDED (hr));

        _TRACE (0, L"\tComparing %s to %s\n", strClassName1.c_str (), strClassName2.c_str ());
#endif
        if  ( RtlpIsEqualGuid( ObjectType, LocalObjectType ) ) 
        {
            *ReturnedIndex = Index;
            bRVal = TRUE;
            break;
        }
    }

    _TRACE (-1, L"Leaving SepObjectInTypeList: %s\n", bRVal ? L"TRUE" : L"FALSE");
    return bRVal;
}

HRESULT
SepUpdateParentTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    IN ULONG StartIndex,
    PSID    grantingSid
)
/*++

Routine Description:

    Update the Access fields of the parent object of the specified object.


        The "remaining" field of a parent object is the logical OR of
        the remaining field of all of its children.

        The CurrentGranted field of the parent is the collection of bits
        granted to every one of its children..

        The CurrentDenied fields of the parent is the logical OR of
        the bits denied to any of its children.

    This routine takes an index to one of the children and updates the
    remaining field of the parent (and grandparents recursively).

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the "child" element whose parents are to be updated.

Return Value:

    None.


--*/

{
    if ( !ObjectTypeList )
        return E_POINTER;
    if ( !IsValidSid (grantingSid) )
        return E_INVALIDARG;
    _TRACE (1, L"Entering  SepUpdateParentTypeList\n");

    ACCESS_MASK NewRemaining = 0;
    ACCESS_MASK NewCurrentGranted = 0xFFFFFFFF;
    ACCESS_MASK NewCurrentDenied = 0;
    HRESULT     hr = S_OK;
 
    //
    // If the target node is at the root,
    //  we're all done.
    //

    if ( ObjectTypeList[StartIndex].ParentIndex == -1 ) 
    {
        return hr;
    }

    //
    // Get the index to the parent that needs updating and the level of
    // the siblings.
    //

    ULONG   ParentIndex = ObjectTypeList[StartIndex].ParentIndex;
    ULONG   Level = ObjectTypeList[StartIndex].Level;

    //
    // Loop through all the children.
    //

    for (UINT Index=ParentIndex+1; Index<ObjectTypeListLength; Index++ ) 
    {
        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[ParentIndex].Level ) 
        {
            break;
        }

        //
        // Only handle direct children of the parent.
        //

        if ( ObjectTypeList[Index].Level != Level ) 
        {
            continue;
        }

        //
        // Compute the new bits for the parent.
        //

        NewRemaining |= ObjectTypeList[Index].Remaining;
        NewCurrentGranted &= ObjectTypeList[Index].CurrentGranted;
        NewCurrentDenied |= ObjectTypeList[Index].CurrentDenied;

    }

    //
    // If we've not changed the access to the parent,
    //  we're done.
    //

    if ( NewRemaining == ObjectTypeList[ParentIndex].Remaining &&
         NewCurrentGranted == ObjectTypeList[ParentIndex].CurrentGranted &&
        NewCurrentDenied == ObjectTypeList[ParentIndex].CurrentDenied ) 
    {
        return hr;
    }


    //
    // Change the parent.
    //

    hr = SetGrantingSid (
            ObjectTypeList[ParentIndex], 
            UpdateRemaining, 
            ObjectTypeList[ParentIndex].Remaining,
            NewRemaining,
            grantingSid);
    ObjectTypeList[ParentIndex].Remaining = NewRemaining;
    hr = SetGrantingSid (
            ObjectTypeList[ParentIndex], 
            UpdateCurrentGranted, 
            ObjectTypeList[ParentIndex].CurrentGranted,
            NewCurrentGranted,
            grantingSid);
    ObjectTypeList[ParentIndex].CurrentGranted = NewCurrentGranted;
    hr = SetGrantingSid (
            ObjectTypeList[ParentIndex], 
            UpdateCurrentDenied, 
            ObjectTypeList[ParentIndex].CurrentDenied,
            NewCurrentDenied,
            grantingSid);
    ObjectTypeList[ParentIndex].CurrentDenied = NewCurrentDenied;

    //
    // Go update the grand parents.
    //

    hr = SepUpdateParentTypeList( ObjectTypeList,
                             ObjectTypeListLength,
                             ParentIndex,
                             grantingSid);

    _TRACE (-1, L"Leaving SepUpdateParentTypeList\n");
    return hr;
}

PSID AllocAndCopySid (PSID pSid)
{
    if ( !pSid )
        return 0;

    DWORD   dwSidLen = GetLengthSid (pSid);
    PSID    pSidCopy = CoTaskMemAlloc (dwSidLen);
    
    if ( pSidCopy )
    {
        if ( CopySid (dwSidLen, pSidCopy, pSid) )
        {
            ASSERT (IsValidSid (pSidCopy));
        }
    }

    return pSidCopy;
}

HRESULT SetGrantingSid (
        IOBJECT_TYPE_LIST& ObjectTypeItem, 
        ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate, 
        ACCESS_MASK oldAccessBits,
        ACCESS_MASK newAccessBits,
        PSID grantingSid)
{
    if ( !IsValidSid (grantingSid) )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    UINT    nSid = 0;

    for (ULONG nBit = 0x1; nBit; nBit <<= 1, nSid++)
    {
        if ( (newAccessBits & nBit) &&
             !(oldAccessBits & nBit) )
        {
            switch (FieldToUpdate)
            {
            case UpdateCurrentGranted:
                if ( !ObjectTypeItem.grantingSid[nSid] )
                {
                    ObjectTypeItem.grantingSid[nSid] = AllocAndCopySid (grantingSid);
                    if ( !ObjectTypeItem.grantingSid[nSid] )
                        hr = E_OUTOFMEMORY;
                    break;
                }
                break;

            case UpdateCurrentDenied:
                if ( !ObjectTypeItem.denyingSid[nSid] )
                {
                    ObjectTypeItem.denyingSid[nSid] = AllocAndCopySid (grantingSid);
                    if ( !ObjectTypeItem.denyingSid[nSid] )
                        hr = E_OUTOFMEMORY;
                    break;
                }
                break;

            case UpdateRemaining:
                break;

            default:
                break;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\adsiobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ADSIObj.cpp
//
//  Contents:   ADSI Object 
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "ADSIObj.h"
#include "ADUtils.h"


HRESULT CACLAdsiObject::AddAttrGUIDToList (
        const BSTR pszAttrName, 
        list<POBJECT_TYPE_LIST>& guidList)
{
    _TRACE (1, L"Entering  CACLAdsiObject::AddAttrGUIDToList ()\n");
    HRESULT hr = S_OK;
    CComPtr<IADsPathname>   spPathname;

	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);

        hr = spPathname->Set (const_cast <PWSTR> (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (
                    const_cast <PWSTR> (GetPhysicalSchemaNamingContext()),
				    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
                BSTR strAttrCommonName = 0;
                hr = ReadSchemaAttributeCommonName (pszAttrName, &strAttrCommonName);
                if ( SUCCEEDED (hr) )
                {
                    wstring strLeaf;
                    
                    FormatMessage (strLeaf, L"CN=%1", strAttrCommonName);
			        hr = spPathname->AddLeafElement(const_cast <PWSTR> (strLeaf.c_str ()));
			        if ( SUCCEEDED (hr) )
			        {
			            BSTR bstrFullPath = 0;
			            hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
			            if ( SUCCEEDED (hr) )
			            {
				            CComPtr<IDirectoryObject> spDirObj;


				            hr = ADsGetObject (
			                      bstrFullPath,
					              IID_PPV_ARG (IDirectoryObject, &spDirObj));
				            if ( SUCCEEDED (hr) )
				            {
                                GUID*               pGUID = 0;
                                POBJECT_TYPE_LIST   pOtl = 0;
                                bool                bPropertySetFound = false;

                                // Property set GUIDs must be added before property GUIDs
                                // See documentation for "AccessCheckByTypeResultList
                                {
                                    // Get attribute security GUID (property set GUID)
                                    PADS_ATTR_INFO  pAttrs = 0;
                                    DWORD           cAttrs = 0;
                                    LPWSTR          rgpwzAttrNames[] = {L"attributeSecurityGUID"};

                                    hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                        {   
                                            bPropertySetFound = true;
                                            pGUID = (GUID*) CoTaskMemAlloc (sizeof (GUID));
                                            if ( pGUID )
                                            {
                                                bool    bFound = false;
                                            

                                                memcpy (pGUID, 
                                                        pAttrs->pADsValues->OctetString.lpValue,
                                                        pAttrs->pADsValues->OctetString.dwLength);
                                                for (list<POBJECT_TYPE_LIST>::iterator itr = guidList.begin ();
                                                        itr != guidList.end ();
                                                        itr++)
                                                {
                                                    if ( ::IsEqualGUID (*((*itr)->ObjectType), *pGUID) )
                                                    {
                                                        bFound = true;
                                                        break;
                                                    }
                                                }

                                                if ( !bFound )
                                                {
                                                    pOtl = (POBJECT_TYPE_LIST) CoTaskMemAlloc (sizeof (OBJECT_TYPE_LIST));
                                                    if ( pOtl )
                                                    {
                                                        ::ZeroMemory (pOtl, sizeof (POBJECT_TYPE_LIST));
                                                        pOtl->Level = ACCESS_PROPERTY_SET_GUID;
                                                        pOtl->ObjectType = pGUID;
                                                        pOtl->Sbz = 0;
                                                        guidList.push_back (pOtl);
                                                    }
                                                    else
                                                    {
                                                        CoTaskMemFree (pGUID);
                                                        hr = E_OUTOFMEMORY;
                                                    }
                                                }
                                                else
                                                    CoTaskMemFree (pGUID);
                                            }
                                            else
                                                hr = E_OUTOFMEMORY;
                                        }
                                        if ( pAttrs )
                                            FreeADsMem (pAttrs);
                                    }
                                    else
                                    {
                                        _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                                    }
                                }


                                if ( SUCCEEDED (hr) )
                                {
                                    // Get attribute GUID (schemaIDGUID)
                                    PADS_ATTR_INFO  pAttrs = 0;
                                    DWORD           cAttrs = 0;
                                    LPWSTR          rgpwzAttrNames[] = {L"schemaIDGUID"};

                                    hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                        {   
                                            pGUID = (GUID*) CoTaskMemAlloc (sizeof (GUID));
                                            if ( pGUID )
                                            {
                                                memcpy (pGUID, 
                                                        pAttrs->pADsValues->OctetString.lpValue,
                                                        pAttrs->pADsValues->OctetString.dwLength);
                                                pOtl = (POBJECT_TYPE_LIST) CoTaskMemAlloc (sizeof (OBJECT_TYPE_LIST));
                                                if ( pOtl )
                                                {
                                                    ::ZeroMemory (pOtl, sizeof (POBJECT_TYPE_LIST));
                                                    if ( bPropertySetFound )
                                                        pOtl->Level = ACCESS_PROPERTY_GUID;
                                                    else
                                                        pOtl->Level = ACCESS_PROPERTY_SET_GUID;
                                                    pOtl->ObjectType = pGUID;
                                                    pOtl->Sbz = 0;
                                                    guidList.push_back (pOtl);
                                                }
                                                else
                                                {
                                                    CoTaskMemFree (pGUID);
                                                    hr = E_OUTOFMEMORY;
                                                }
                                            }
                                            else
                                                hr = E_OUTOFMEMORY;
                                        }

                                        if ( pAttrs )
                                            FreeADsMem (pAttrs);
                                    }
                                    else
                                    {
                                        _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                                    }
                                }
                            }
                            else
                            {
                                _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath);
                      
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"IADsPathname->AddLeafElement (%s) failed: 0x%x\n", 
                                strLeaf.c_str (), hr);
                    }
                    SysFreeString (strAttrCommonName);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        GetPhysicalSchemaNamingContext(), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CACLAdsiObject::AddAttrGUIDToList (): 0x%x\n", hr);
    return hr;
}


HRESULT CACLAdsiObject::BuildObjectTypeList (POBJECT_TYPE_LIST* pObjectTypeList, size_t& objectTypeListLength)
{
    _TRACE (1, L"Entering  CACLAdsiObject::BuildObjectTypeList ()\n");
    if ( !pObjectTypeList )
        return E_POINTER;

    HRESULT                 hr = S_OK;   
    CComPtr<IADsPathname>   spPathname;
    list<POBJECT_TYPE_LIST> guidList;

	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);

        hr = spPathname->Set (const_cast <PWSTR> (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (
                    const_cast <PWSTR> (GetPhysicalSchemaNamingContext()),
				    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
                wstring strLeaf;
                
                FormatMessage (strLeaf, L"CN=%1", GetSchemaCommonName ());
			    hr = spPathname->AddLeafElement(const_cast <PWSTR> (strLeaf.c_str ()));
			    if ( SUCCEEDED (hr) )
			    {

			        BSTR bstrFullPath = 0;
			        hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
			        if ( SUCCEEDED (hr) )
			        {
				        CComPtr<IDirectoryObject> spDirObj;


				        hr = ADsGetObject (
			                  bstrFullPath,
					          IID_PPV_ARG (IDirectoryObject, &spDirObj));
				        if ( SUCCEEDED (hr) )
				        {
                            GUID*               pGUID = 0;
                            POBJECT_TYPE_LIST   pOtl = 0;


                            {
                                // Get class GUID (schemaIDGUID)
                                LPWSTR          rgpwzAttrNames1[] = {L"schemaIDGUID"};
                                PADS_ATTR_INFO  pAttrs = 0;
                                DWORD           cAttrs = 0;

                                hr = spDirObj->GetObjectAttributes(rgpwzAttrNames1, 1, &pAttrs, &cAttrs);
                                if ( SUCCEEDED (hr) )
                                {
                                    if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                    {   
                                        pGUID = (GUID*) CoTaskMemAlloc (sizeof (GUID));
                                        if ( pGUID )
                                        {
                                            memcpy (pGUID, 
                                                    pAttrs->pADsValues->OctetString.lpValue,
                                                    pAttrs->pADsValues->OctetString.dwLength);

                                            pOtl = (POBJECT_TYPE_LIST) CoTaskMemAlloc (sizeof (OBJECT_TYPE_LIST));
                                            if ( pOtl )
                                            {
                                                ::ZeroMemory (pOtl, sizeof (POBJECT_TYPE_LIST));
                                                pOtl->Level = ACCESS_OBJECT_GUID;
                                                pOtl->ObjectType = pGUID;
                                                pOtl->Sbz = 0;
                                                guidList.push_back (pOtl);
                                            }
                                            else
                                            {
                                                CoTaskMemFree (pGUID);
                                                hr = E_OUTOFMEMORY;
                                            }
                                        }
                                        else
                                            hr = E_OUTOFMEMORY;
                                        
                                    }

                                    if ( pAttrs )
                                        FreeADsMem (pAttrs);
                                }
                                else
                                {
                                    _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                                }
                            }

                            if ( SUCCEEDED (hr) )
                            {
                                //
                                // Get "allowedAttributes" attribute
                                //
                                PADS_ATTR_INFO  pAttrs = 0;
                                DWORD           cAttrs = 0;
                                LPWSTR          rgpwzAttrNames2[] = {L"allowedAttributes"};

                                hr = spDirObj->GetObjectAttributes(rgpwzAttrNames2, 1, &pAttrs, &cAttrs);
                                if ( SUCCEEDED (hr) )
                                {
                                    if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                    {
                                        for (DWORD  dwIdx = 0; 
                                                dwIdx < pAttrs->dwNumValues && SUCCEEDED (hr); 
                                                dwIdx++)
                                        {
                                            hr = AddAttrGUIDToList (
                                                    pAttrs->pADsValues[dwIdx].CaseIgnoreString, 
                                                    guidList);
                                        }
                                    }
                                    if ( pAttrs )
                                        FreeADsMem (pAttrs);
                                }
                                else
                                {
                                    _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                                }
                            }

                            if ( SUCCEEDED (hr) )
                            {
                                objectTypeListLength = guidList.size ();
                                *pObjectTypeList = (POBJECT_TYPE_LIST) CoTaskMemAlloc (
                                        sizeof (OBJECT_TYPE_LIST) + (sizeof (GUID) * objectTypeListLength));
                                if ( *pObjectTypeList )
                                {
                                    DWORD idx = 0;
                                    list<POBJECT_TYPE_LIST>::iterator itr = guidList.begin ();

                                    for (; idx < objectTypeListLength && itr != guidList.end (); 
                                            idx++, itr++)
                                    {
                                        pOtl = *itr;
                                        (*pObjectTypeList)[idx].Level = pOtl->Level;
                                        // Note just copy pointer here and don't free the pOtl->ObjectType later.
                                        (*pObjectTypeList)[idx].ObjectType = pOtl->ObjectType;
                                        pOtl->ObjectType = 0;
                                        (*pObjectTypeList)[idx].Sbz = 0;
                                        CoTaskMemFree (pOtl);
                                    }
                                }
                                else
                                    hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath);
                      
                        }
                    }
                    else
                    {
                        _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->AddLeafElement (%s) failed: 0x%x\n", 
                            strLeaf.c_str (), hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        GetPhysicalSchemaNamingContext(), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CACLAdsiObject::BuildObjectTypeList (): 0x%x\n", hr);
    return hr;
}


HRESULT CACLAdsiObject::ReadSchemaCommonName ()
{
    _TRACE (1, L"Entering  CACLAdsiObject::ReadSchemaCommonName ()\n");
    HRESULT hr = S_OK;
    CComPtr<IADsPathname>   spPathname;


	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);

        hr = spPathname->Set (const_cast <PWSTR> (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (
                    const_cast <PWSTR> (GetPhysicalSchemaNamingContext()),
				    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
			    BSTR bstrFullPath = 0;
			    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
			    if ( SUCCEEDED (hr) )
			    {
				    CComPtr<IDirectoryObject> spDirObj;


				    hr = ADsGetObject (
			              bstrFullPath,
					      IID_PPV_ARG (IDirectoryObject, &spDirObj));
				    if ( SUCCEEDED (hr) )
				    {
		                CComPtr<IDirectorySearch>   spDsSearch;
		                hr = spDirObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
		                if ( SUCCEEDED (hr) )
		                {
                            ASSERT (!!spDsSearch);
			                ADS_SEARCHPREF_INFO pSearchPref[2];
			                DWORD dwNumPref = 2;

			                pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
			                pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
			                pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
			                pSearchPref[1].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
			                pSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
			                pSearchPref[1].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

			                hr = spDsSearch->SetSearchPreference(
					                 pSearchPref,
					                 dwNumPref
					                 );
			                if ( SUCCEEDED (hr) )
			                {
                                PWSTR				rgszAttrList[] = {L"cn"};
			                    ADS_SEARCH_HANDLE	hSearchHandle = 0;
			                    DWORD				dwNumAttributes = 1;
                                wstring            strQuery;
                                ADS_SEARCH_COLUMN   Column;

                                ::ZeroMemory (&Column, sizeof (ADS_SEARCH_COLUMN));
                                FormatMessage (strQuery, 
                                        L"lDAPDisplayName=%1",
                                        this->GetClass ());

				                hr = spDsSearch->ExecuteSearch(
									                 const_cast <LPWSTR>(strQuery.c_str ()),
									                 rgszAttrList,
									                 dwNumAttributes,
									                 &hSearchHandle
									                 );
				                if ( SUCCEEDED (hr) )
				                {
					                hr = spDsSearch->GetFirstRow (hSearchHandle);
					                if ( SUCCEEDED (hr) )
					                {
						                while (hr != S_ADS_NOMORE_ROWS )
						                {
							                //
							                // Getting current row's information
							                //
							                hr = spDsSearch->GetColumn(
									                 hSearchHandle,
									                 rgszAttrList[0],
									                 &Column
									                 );
							                if ( SUCCEEDED (hr) )
							                {
                                                m_strSchemaCommonName = Column.pADsValues->CaseIgnoreString;

								                spDsSearch->FreeColumn (&Column);
								                Column.pszAttrName = NULL;
                                                break;
							                }
							                else if ( hr != E_ADS_COLUMN_NOT_SET )
							                {
								                break;
							                }
                                            else
                                            {
                                                _TRACE (0, L"IDirectorySearch::GetColumn (): 0x%x\n", hr);
                                            }
						                }
					                }
                                    else
                                    {
                                        _TRACE (0, L"IDirectorySearch::GetFirstRow (): 0x%x\n", hr);
                                    }

					                if (Column.pszAttrName)
					                {
						                spDsSearch->FreeColumn(&Column);
					                }
            		                spDsSearch->CloseSearchHandle(hSearchHandle);
				                }
				                else
				                {
                                    _TRACE (0, L"IDirectorySearch::ExecuteSearch (): 0x%x\n", hr);
					                hr = S_OK;
				                }
			                }
                            else
                            {
                                _TRACE (0, L"IDirectorySearch::SetSearchPreference (): 0x%x\n", hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch): 0x%x\n", hr);
                        }
                   }
                    else
                    {
                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath);
                  
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        GetPhysicalSchemaNamingContext(), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CACLAdsiObject::ReadSchemaCommonName (): 0x%x\n", hr);
    return hr;
}

HRESULT CACLAdsiObject::Bind(LPCWSTR lpszLdapPath)
{
    _TRACE (1, L"Entering  CACLAdsiObject::Bind ()\n");
    HRESULT hr = CAdsiObject::Bind (lpszLdapPath);
    if ( SUCCEEDED (hr) )
    {
        hr = ReadSchemaCommonName ();
    }

    _TRACE (-1, L"Leaving CACLAdsiObject::Bind (): 0x%x\n", hr);
    return hr;
}

HRESULT CACLAdsiObject::ReadSchemaAttributeCommonName (const BSTR pszAttrName, BSTR* ppszAttrCommonName)
{
    _TRACE (1, L"Entering  CACLAdsiObject::ReadSchemaAttributeCommonName ()\n");
    if ( !pszAttrName || !ppszAttrCommonName )
        return E_POINTER;

    HRESULT hr = S_OK;
    CComPtr<IADsPathname>   spPathname;


	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);

        hr = spPathname->Set (const_cast <PWSTR> (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (
                    const_cast <PWSTR> (GetPhysicalSchemaNamingContext()),
				    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
			    BSTR bstrFullPath = 0;
			    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
			    if ( SUCCEEDED (hr) )
			    {
				    CComPtr<IDirectoryObject> spDirObj;


				    hr = ADsGetObject (
			              bstrFullPath,
					      IID_PPV_ARG (IDirectoryObject, &spDirObj));
				    if ( SUCCEEDED (hr) )
				    {
		                CComPtr<IDirectorySearch>   spDsSearch;
		                hr = spDirObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
		                if ( SUCCEEDED (hr) )
		                {
                            ASSERT (!!spDsSearch);
			                ADS_SEARCHPREF_INFO pSearchPref[2];
			                DWORD dwNumPref = 2;

			                pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
			                pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
			                pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
			                pSearchPref[1].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
			                pSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
			                pSearchPref[1].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

			                hr = spDsSearch->SetSearchPreference(
					                 pSearchPref,
					                 dwNumPref
					                 );
			                if ( SUCCEEDED (hr) )
			                {
                                PWSTR				rgszAttrList[] = {L"cn"};
			                    ADS_SEARCH_HANDLE	hSearchHandle = 0;
			                    DWORD				dwNumAttributes = 1;
                                wstring             strQuery;
                                ADS_SEARCH_COLUMN   Column;

                                ::ZeroMemory (&Column, sizeof (ADS_SEARCH_COLUMN));
                                FormatMessage (strQuery, 
                                        L"lDAPDisplayName=%1",
                                        pszAttrName);

				                hr = spDsSearch->ExecuteSearch(
									                 const_cast <LPWSTR>(strQuery.c_str ()),
									                 rgszAttrList,
									                 dwNumAttributes,
									                 &hSearchHandle
									                 );
				                if ( SUCCEEDED (hr) )
				                {
					                hr = spDsSearch->GetFirstRow (hSearchHandle);
					                if ( SUCCEEDED (hr) )
					                {
						                while (hr != S_ADS_NOMORE_ROWS )
						                {
							                //
							                // Getting current row's information
							                //
							                hr = spDsSearch->GetColumn(
									                 hSearchHandle,
									                 rgszAttrList[0],
									                 &Column
									                 );
							                if ( SUCCEEDED (hr) )
							                {
                                                *ppszAttrCommonName = SysAllocString (Column.pADsValues->CaseIgnoreString);
                                                if ( !(*ppszAttrCommonName) )
                                                    hr = E_OUTOFMEMORY;
								                spDsSearch->FreeColumn (&Column);
								                Column.pszAttrName = NULL;
                                                break;
							                }
							                else if ( hr != E_ADS_COLUMN_NOT_SET )
							                {
								                break;
							                }
                                            else
                                            {
                                                _TRACE (0, L"IDirectorySearch::GetColumn (): 0x%x\n", hr);
                                            }
						                }
					                }
                                    else
                                    {
                                        _TRACE (0, L"IDirectorySearch::GetFirstRow (): 0x%x\n", hr);
                                    }

					                if (Column.pszAttrName)
					                {
						                spDsSearch->FreeColumn(&Column);
					                }
            		                spDsSearch->CloseSearchHandle(hSearchHandle);
				                }
				                else
				                {
                                    _TRACE (0, L"IDirectorySearch::ExecuteSearch (): 0x%x\n", hr);
					                hr = S_OK;
				                }
			                }
                            else
                            {
                                _TRACE (0, L"IDirectorySearch::SetSearchPreference (): 0x%x\n", hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch): 0x%x\n", hr);
                        }
                   }
                    else
                    {
                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath);
                  
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        GetPhysicalSchemaNamingContext(), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CACLAdsiObject::ReadSchemaAttributeCommonName (): 0x%x\n", hr);
    return hr;
}

HRESULT CACLAdsiObject::GetPrincipalSelfSid(PSID &principalSelfSid)
{
    _TRACE (1, L"Entering  CACLAdsiObject::GetPrincipalSelfSid ()\n");

    HRESULT hr = S_OK;

    ASSERT (!!m_spIADs);
    if ( !!m_spIADs )
    {
		CComPtr<IDirectoryObject> spDirObj;
		hr = m_spIADs->QueryInterface (IID_PPV_ARG(IDirectoryObject, &spDirObj));
		if ( SUCCEEDED (hr) )
		{
            ASSERT ( !!spDirObj);
            //
            // Get "objectSid" attribute
            //
            const PWSTR     wzAllowedAttributes = L"objectSid";
            PADS_ATTR_INFO  pAttrs = 0;
            DWORD           cAttrs = 0;
            LPWSTR          rgpwzAttrNames[] = {wzAllowedAttributes};

            hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
            if ( SUCCEEDED (hr) )
            {
                if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues && 1 == pAttrs->dwNumValues )
                {
                    PSID    pSid = pAttrs->pADsValues->OctetString.lpValue;
                    DWORD   dwSidLen = GetLengthSid (pSid);
                    PSID    pSidCopy = CoTaskMemAlloc (dwSidLen);
                    
                    if ( pSidCopy )
                    {
                        if ( CopySid (dwSidLen, pSidCopy, pSid) )
                        {
                            ASSERT (IsValidSid (pSidCopy));
                            principalSelfSid = pSidCopy;
                        }
                        else
                        {
                            CoTaskMemFree (pSidCopy);
                            hr = GetLastError ();
                            _TRACE (0, L"CopySid () failed: 0x%x\n", hr);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                    principalSelfSid = 0;
                if ( pAttrs )
                    FreeADsMem (pAttrs);
            }
            else
            {
                _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
            }
        }
        else
        {
            _TRACE (0, L"IADs->QueryInterface (IDirectoryObject): 0x%x\n", hr);
        }
    }
    else
        hr = E_UNEXPECTED;
    
    _TRACE (-1, L"Leaving CACLAdsiObject::GetPrincipalSelfSid (): 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\accessck.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       AccessCk.h
//
//  Contents:   Code copied and modified from private\ntos\se\accessck.c
//              
//
//----------------------------------------------------------------------------
#ifndef __ACCESSCK_ADUTILS_H
#define __ACCESSCK_ADUTILS_H

#define SID_ARRAY_SIZE  sizeof (ULONG) * 8

class IOBJECT_TYPE_LIST {
public:
    IOBJECT_TYPE_LIST () :
        Level (0),
        Flags (0),
        ParentIndex (0),
        Remaining (0),
        CurrentGranted (0),
        CurrentDenied (0)
    {
        ::ZeroMemory (&ObjectType, sizeof (GUID));
        ::ZeroMemory (grantingSid, sizeof (PSID) * SID_ARRAY_SIZE);
        ::ZeroMemory (denyingSid, sizeof (PSID) * SID_ARRAY_SIZE);
    }
    ~IOBJECT_TYPE_LIST ()
    {
        for (UINT nIndex = 0; nIndex < SID_ARRAY_SIZE; nIndex++)
        {
            if ( grantingSid[nIndex] )
                CoTaskMemFree (grantingSid[nIndex]);
            if ( denyingSid[nIndex] )
                CoTaskMemFree (denyingSid[nIndex]);
        }
    }


    USHORT Level;
    USHORT Flags;
#define OBJECT_SUCCESS_AUDIT 0x1
#define OBJECT_FAILURE_AUDIT 0x2
    GUID ObjectType;
    LONG ParentIndex;
    ULONG Remaining;
    ULONG CurrentGranted;
    ULONG CurrentDenied;
    PSID  grantingSid[SID_ARRAY_SIZE];
    PSID  denyingSid[SID_ARRAY_SIZE];
};


typedef IOBJECT_TYPE_LIST*  PIOBJECT_TYPE_LIST;


HRESULT SepInit ();
VOID    SepCleanup ();

HRESULT
SepMaximumAccessCheck(
    list<PSID>& psidList,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN size_t LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN size_t ObjectTypeListLength);

NTSTATUS
SeCaptureObjectTypeList (
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN size_t ObjectTypeListLength,
    OUT PIOBJECT_TYPE_LIST *CapturedObjectTypeList
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\acldiag.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ACLDiag.cpp
//
//  Contents:   Defines the entry point for the console application.
//              
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "adutils.h"
#include "SecDesc.h"
#include "schema.h"
#include "ChkDeleg.h"
#include "EffRight.h"

CACLDiagComModule _Module;

// Function prototypes
void DisplayHelp ();


// Command-line options string constants
const wstring strSchemaFlag = L"/schema";
const wstring strCheckDelegationFlag = L"/chkdeleg";
const wstring strGetEffectiveFlag = L"/geteffective:";
const wstring strFixDelegationFlag = L"/fixdeleg";
const wstring strTabDelimitedOutputFlag = L"/tdo";
const wstring strLogFlag = L"/log:";
const wstring strHelpFlag = L"/?"; 
const wstring strSkipDescriptionFlag = L"/skip";

int _cdecl main(int argc, char* argv[])
{
    UNREFERENCED_PARAMETER (argv);

    // If no arguments provided, display the help
    if ( 1 == argc )
    {
        DisplayHelp ();
        return 0;
    }

#if DBG
    CheckDebugOutputLevel ();
#endif

    LPCWSTR * lpServiceArgVectors = 0;  // Array of pointers to string
    int cArgs = 0;						// Count of arguments
    size_t lenFlag = strGetEffectiveFlag.length ();

    lpServiceArgVectors = (LPCWSTR *)CommandLineToArgvW(GetCommandLineW(), OUT &cArgs);
    if (lpServiceArgVectors == NULL)
        return NULL;
    for (int nToken = 1; nToken < cArgs; nToken++)
    {
        ASSERT(lpServiceArgVectors[nToken] != NULL);
        if ( !lpServiceArgVectors[nToken] )
            break;
        
        wstring strToken = lpServiceArgVectors[nToken];	// Copy the string

        switch (nToken)
        {
            case 0:     // appName: skip
                continue;   

            case 1:     // object name or a help flag
                if ( !_wcsnicmp (strHelpFlag.c_str (), strToken.c_str (), 
            		    strToken.length ()) )
                {
                    DisplayHelp ();
                    return 0;
                }
                else
                    _Module.SetObjectDN (strToken);
                break;

            default:
                {
                    size_t lenToken = strToken.length ();
                    if ( !_wcsnicmp (strSchemaFlag.c_str (), strToken.c_str (), 
                		    lenToken))
                    {
                        _Module.SetDoSchema ();
                    }
                    else if ( !_wcsnicmp (strCheckDelegationFlag.c_str (), 
                		    strToken.c_str (), lenToken) )
                    {
                        _Module.SetCheckDelegation ();
                    }
                    else if ( !_wcsnicmp (strGetEffectiveFlag.c_str (), 
                		    strToken.c_str (), lenFlag) )
                    {
                        wstring strUserGroup = strToken.substr(lenFlag,
                                lenToken);
                        _Module.SetDoGetEffective (strUserGroup);
                    }
                    else if ( !_wcsnicmp (strFixDelegationFlag.c_str (), 
                		    strToken.c_str (), lenToken) )
                    {
                        _Module.SetFixDelegation ();
                    }
                    else if ( !_wcsnicmp (strTabDelimitedOutputFlag.c_str (), 
                		    strToken.c_str (), lenToken) )
                    {
                        _Module.SetTabDelimitedOutput ();
                    }
                    else if ( !_wcsnicmp (strLogFlag.c_str (), strToken.c_str (), 
                		    lenFlag) )
                    {
                        wstring strPath = strToken.substr(lenFlag, lenToken);
                        _Module.SetDoLog (strPath);
                    }
                    else if ( !_wcsnicmp (strSkipDescriptionFlag.c_str (), 
                		    strToken.c_str (), lenToken) )
                    {
                        _Module.SetSkipDescription ();;
                    }
                    else if ( !_wcsnicmp (strHelpFlag.c_str (), strToken.c_str (), 
                		    lenToken) )
                    {
                        DisplayHelp ();
                        return 0;
                    }
                    else
                    {
                        wstring    str;

                        FormatMessage (str, IDS_INVALID_OPTION, strToken.c_str ());
                        MyWprintf (str.c_str ());
                        DisplayHelp ();
                        return 0;
                    }
                }
                break;
        }
    }
    LocalFree (lpServiceArgVectors);


    HRESULT hr = CoInitialize(NULL);
    if ( SUCCEEDED (hr) ) 
    {
        hr = _Module.Init ();
        if ( SUCCEEDED (hr) )
        {
            hr = DoSecurityDescription ();

            if ( SUCCEEDED (hr) && _Module.DoSchema () )
                hr = DoSchemaDiagnosis ();

            if ( SUCCEEDED (hr) && _Module.CheckDelegation () )
                hr = CheckDelegation ();

            if ( SUCCEEDED (hr) && _Module.DoGetEffective () )
                hr = EffectiveRightsDiagnosis ();
        }
        else
            DisplayHelp ();
    }
    else
    {
        _TRACE (0, L"CoInitialize Failed with %x\n",hr);
        return 0;
    }

	return 0;
}



///////////////////////////////////////////////////////////////////////////////
//
//  Method: DisplayHelp
//
//  Print the purpose of the tool and each of the command-line options.
//
///////////////////////////////////////////////////////////////////////////////
void DisplayHelp ()
{
    CWString    str;
    int         helpIDs[] = {IDS_HELP_MAIN, 
                            IDS_HELP_SCHEMA, 
                            IDS_HELP_CHKDELEG,
                            IDS_HELP_GETEFFECTIVE,
                            IDS_HELP_CDO,
//                            IDS_HELP_LOG,
                            IDS_HELP_SKIP_DESCRIPTION,
                            0};

    for (int nIndex = 0; helpIDs[nIndex]; nIndex++)
    {
        str.LoadFromResource (helpIDs[nIndex]);
        MyWprintf (str.c_str ());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\adutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ADUtils.cpp
//
//  Contents:   Classes CWString, CACLDiagComModule, ACE_SAMNAME, helper 
//				methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "adutils.h"

#include <util.h>
#include <sddl.h>
#include "dscmn.h"
#include "SecDesc.h"



void StripQuotes (wstring& str)
{
    size_t  qPos = str.find_first_of (L"\"", 0);
    if ( 0 == qPos )
    {
        str = str.substr (1);
        qPos = str.find_last_of (L"\"");
        if ( str.npos != qPos )
            str.replace (qPos, 1, 1, 0);
    }
}

wstring GetSystemMessage (DWORD dwErr)
{
    wstring message;

    if ( E_ADS_BAD_PATHNAME == dwErr )
    {
        CWString    msg;

        msg.LoadFromResource (IDS_ADS_BAD_PATHNAME);
        message = msg;
    }
    else
    {
 	    LPVOID pMsgBuf = 0;
		    
	    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | 
	    				FORMAT_MESSAGE_FROM_SYSTEM,    
			    NULL,
			    dwErr,
			    MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			     (LPWSTR) &pMsgBuf,    0,    NULL );
	    message = (LPWSTR) pMsgBuf;

	    // Free the buffer.
        if ( pMsgBuf ) 
	        LocalFree (pMsgBuf);
    }


    return message;
}

/*
// Attempt to locate a message in a given module.  Return the message string
// if found, the empty string if not.
// 
// flags - FormatMessage flags to use
// 
// module - module handle of message dll to look in, or 0 to use the system
// message table.
// 
// code - message code to look for

String
getMessageHelper(DWORD flags, HMODULE module, HRESULT code)
{
   ASSERT(code);
   ASSERT(flags & FORMAT_MESSAGE_ALLOCATE_BUFFER);

   String message;

   TCHAR* sys_message = 0;
   DWORD result =
      ::FormatMessage(
         flags,
         module,
         static_cast<DWORD>(code),
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
         reinterpret_cast<LPTSTR>(&sys_message),
         0,
         0);
   if (result)
   {
      ASSERT(sys_message);
      if (sys_message)
      {
         message = sys_message;

         ASSERT(result == message.length());

         Win::LocalFree(sys_message);
         message.replace(TEXT("\r\n"), TEXT(" "));
      }
   }

   return message;
}



// Attempts to locate message strings for various facility codes in the
// HRESULT

String
GetErrorMessage(HRESULT hr)
{
   TRACE_FUNCTION2(GetErrorMessage, String::format("%1!08X!", hr));
   ASSERT(FAILED(hr));

   if (!FAILED(hr))
   {
      // no messages for success!
      return String();
   }

   HRESULT code = HRESULT_CODE(hr);

   if (code == -1)
   {
      return String::load(IDS_UNKNOWN_ERROR_CODE);
   }

   String message;

   // default is the system error message table
   HMODULE module = 0;

   DWORD flags =
         FORMAT_MESSAGE_ALLOCATE_BUFFER
      |  FORMAT_MESSAGE_IGNORE_INSERTS
      |  FORMAT_MESSAGE_FROM_SYSTEM;

   int facility = HRESULT_FACILITY(hr);
   switch (facility)
   {
      case FACILITY_WIN32:    // 0x7
      {
         // included here:
         // lanman error codes (in it's own dll) see lmerr.h
         // dns
         // winsock

         // @@ use SafeDLL here?
         static HMODULE lm_err_res_dll = 0;
         if (code >= NERR_BASE && code <= MAX_NERR)
         {
            // use the net error message resource dll
            if (lm_err_res_dll == 0)
            {
               lm_err_res_dll =
                  Win::LoadLibraryEx(
                     TEXT("netmsg.dll"),
                     LOAD_LIBRARY_AS_DATAFILE);
            }

            module = lm_err_res_dll;
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
         }
         break;
      }
      case 0x0:
      {
         if (code >= 0x5000 && code <= 0x50FF)
         {
            // It's an ADSI error.  They put the facility code (5) in the
            // wrong place!

            // @@ use SafeDLL here?
            static HMODULE adsi_err_res_dll = 0;
            // use the net error message resource dll
            if (adsi_err_res_dll == 0)
            {
               adsi_err_res_dll =
                  Win::LoadLibraryEx(
                     TEXT("activeds.dll"),
                     LOAD_LIBRARY_AS_DATAFILE);
            }

            module = adsi_err_res_dll;
            flags |= FORMAT_MESSAGE_FROM_HMODULE;

            // the message dll expects the entire error code
            code = hr;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   message = getMessageHelper(flags, module, code);
   if (message.empty())
   {
      message = String::load(IDS_UNKNOWN_ERROR_CODE);
   }

   return message;
}


*/
///////////////////////////////////////////////////////////////////////
// wstring helper methods

HRESULT wstringFromGUID (wstring& str, REFGUID guid)
{
    HRESULT hr = S_OK;

    const int BUF_LEN = 128;
    WCHAR awch[BUF_LEN];
    hr = StringFromGUID2(guid, awch, BUF_LEN);
    if ( SUCCEEDED (hr) )
        str = OLE2T(awch);
    
    return hr;
}

bool LoadFromResource(wstring& str, UINT uID)
{
    int nBufferSize = 128;
    static const int nCountMax = 4;
    int nCount = 1;

    do 
    {
        LPWSTR lpszBuffer = (LPWSTR)alloca(nCount*nBufferSize*sizeof(WCHAR));
        int iRet = ::LoadString(_Module.GetResourceInstance(), uID, 
			        lpszBuffer, nBufferSize);
        if (iRet == 0)
        {
            str = L"?";
            return false; // not found
        }
        if (iRet == nBufferSize-1) // truncation
        {
            if (nCount > nCountMax)
            {
                // too many reallocations
                str = lpszBuffer;
                return false; // truncation
            }
            // try to expand buffer
            nBufferSize *=2;
            nCount++;
        }
        else
        {
            // got it
            str = lpszBuffer;
            break;
        }
    }
#pragma warning (disable : 4127)
    while (true);
#pragma warning (default : 4127)

	return true;
}

bool FormatMessage(wstring& str, UINT nFormatID, ...)
{
    bool bResult = false;

	// get format string from string table
	wstring strFormat;
	if ( LoadFromResource (strFormat, nFormatID) )
    {
	    // format message into temporary buffer lpszTemp
	    va_list argList;
	    va_start(argList, nFormatID);
	    PWSTR lpszTemp = 0;
	    if (::FormatMessage (FORMAT_MESSAGE_FROM_STRING |
	    		FORMAT_MESSAGE_ALLOCATE_BUFFER,
		    strFormat.c_str (), 0, 0, (PWSTR)&lpszTemp, 0, &argList) == 0 ||
		    lpszTemp == NULL)
	    {
		    return false; 
	    }

	    // assign lpszTemp into the resulting string and free lpszTemp
	    str = lpszTemp;
        bResult = true;
	    LocalFree(lpszTemp);
	    va_end(argList);
    }

    return bResult;
}

bool FormatMessage(wstring& str, LPCTSTR lpszFormat, ...)
{
    bool bResult = false;


	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;

	if ( ::FormatMessage (FORMAT_MESSAGE_FROM_STRING | 
				FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
	{
		return false; //AfxThrowMemoryException();
	}

	// assign lpszTemp into the resulting string and free the temporary
	str = lpszTemp;
    bResult = true;
	LocalFree(lpszTemp);
	va_end(argList);

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
// CACLDiagComModule
CACLDiagComModule::CACLDiagComModule() :
    m_bDoSchema (false),
    m_bDoCheckDelegation (false),
    m_bDoGetEffective (false),
    m_bDoFixDelegation (false),
    m_pSecurityDescriptor (0),
    m_bTabDelimitedOutput (false),
    m_hPrivToken (0),
    m_bLogErrors (false)
{
    DWORD dwPriv = SE_SECURITY_PRIVILEGE;
    m_hPrivToken = EnablePrivileges(&dwPriv, 1);
}

CACLDiagComModule::~CACLDiagComModule ()
{
    if ( m_pSecurityDescriptor )
    {
        LocalFree (m_pSecurityDescriptor);
        m_pSecurityDescriptor = 0;
    }
    ReleasePrivileges(m_hPrivToken);
}


HRESULT CACLDiagComModule::GetClassFromGUID (
		REFGUID rightsGUID, 
		wstring& strClassName, 
		GUID_TYPE* pGuidType)
{
    HRESULT hr = S_OK;
    CSchemaClassInfo*   pInfo = 0;
    bool                bFound = false;

    // Search for a class
    for (int nIndex = 0; nIndex < (int) m_classInfoArray.GetCount (); nIndex++)
    {
        pInfo = m_classInfoArray[nIndex];
        if ( pInfo && IsEqualGUID (*(pInfo->GetSchemaGUID ()), 
        		rightsGUID) )
        {
			PCWSTR	pszDisplayName = pInfo->GetDisplayName ();
            strClassName = pszDisplayName ? pszDisplayName : L"";
            bFound = true;
            if ( pGuidType )
                *pGuidType = GUID_TYPE_CLASS;
            break;
        }
    }

    // Search for an attribute
    if ( !bFound )
    {
        for (int nIndex = 0; nIndex < (int) m_attrInfoArray.GetCount (); nIndex++)
        {
            pInfo = m_attrInfoArray[nIndex];
            if ( pInfo && IsEqualGUID (*(pInfo->GetSchemaGUID ()), 
            		rightsGUID) )
            {
				PCWSTR	pszDisplayName = pInfo->GetDisplayName ();
                strClassName = pszDisplayName ? pszDisplayName : L"";
                bFound = true;
                if ( pGuidType )
                    *pGuidType = GUID_TYPE_ATTRIBUTE;
                break;
            }
        }
    }

    // Search for a control
    if ( !bFound )
    {
        hr = GetControlDisplayName (rightsGUID, strClassName);
        if ( SUCCEEDED (hr) && strClassName.length () )
        {
            if ( pGuidType )
                *pGuidType = GUID_TYPE_CONTROL;
        }
        else
        {
            if ( pGuidType )
                *pGuidType = GUID_TYPE_UNKNOWN;
            strClassName = L"unknown";
        }
    }

    return hr;
}

HRESULT CACLDiagComModule::Init()
{
    // Find out if logged-in users is an Administrator
    BOOL    bIsUserAdministrator = FALSE;
	HRESULT	hr = IsUserAdministrator (bIsUserAdministrator);
    if ( SUCCEEDED (hr) )
    {
        if ( bIsUserAdministrator )
        {
            wstring     strObjectDN;
            LPCWSTR     pszLDAP = L"LDAP://";

            size_t      len = wcslen (pszLDAP);

            if ( m_strObjectDN.compare (0, len, pszLDAP) )
            {
                strObjectDN = pszLDAP;
            }
            strObjectDN += m_strObjectDN;

            hr = m_adsiObject.Bind (strObjectDN.c_str ());
            if ( SUCCEEDED (hr) )
            {
                // Get the class of strObjectDN

                // enumerate all classes in schema
                hr = m_adsiObject.QuerySchemaClasses (&m_classInfoArray, false);
                if ( SUCCEEDED (hr) )
                {
/*
#if DBG
                    // Dump all the class info to the debug window
                    _TRACE (0, L"\n----------------------------------------------------\n");
                    _TRACE (0, L"-- Classes --\n\n");
                    for (int nIndex = 0; nIndex < m_classInfoArray.GetCount (); nIndex++)
                    {
                        CSchemaClassInfo* pInfo = m_classInfoArray[nIndex];
                        if ( pInfo )
                        {
                            _TRACE (0, L"\t%d\t%s\t%s\n", nIndex, pInfo->GetSchemaIDGUID (), 
                                    pInfo->GetDisplayName ());
                        }
                    }
                    _TRACE (0, L"\n----------------------------------------------------\n\n");
#endif // DBG
*/
                    // enumerate all attributes in schema
                    hr = m_adsiObject.QuerySchemaClasses (&m_attrInfoArray, 
                    		true);
                    if ( SUCCEEDED (hr) )
                    {
/*
#if DBG
                        // Dump all the attributes info to the debug window
                        _TRACE (0, L"\n----------------------------------------------------\n");
                        _TRACE (0, L"-- Attributes --\n\n");
                        for (int nIndex = 0; nIndex < m_attrInfoArray.GetCount (); nIndex++)
                        {
                            CSchemaClassInfo* pInfo = m_attrInfoArray[nIndex];
                            if ( pInfo )
                            {
                                _TRACE (0, L"\t%d\t%s\t%s\n", nIndex, pInfo->GetSchemaIDGUID (), 
                                        pInfo->GetDisplayName ());
                            }
                        }
                        _TRACE (0, L"\n----------------------------------------------------\n\n");
#endif // DBG
                        */
                    }
                    wprintf (L"\n");
                }
            }
            else
            {
                wstring    str;


                FormatMessage (str, IDS_INVALID_OBJECT, m_strObjectDN.c_str (), 
                        GetSystemMessage (hr).c_str ());
                wprintf (str.c_str ());
            }
        }
        else
        {
            wstring    str;

            LoadFromResource (str, IDS_USER_MUST_BE_ADMINISTRATOR);
            wprintf (str.c_str ());
        }
    }
    else
    {
        wstring    str;

        FormatMessage (str, IDS_COULD_NOT_VALIDATE_USER_CREDENTIALS, 
                GetSystemMessage (hr).c_str ());
        wprintf (str.c_str ());
    }

    return hr;
}

HRESULT CACLDiagComModule::IsUserAdministrator (BOOL & bIsAdministrator)
{
    bIsAdministrator = TRUE;
    return S_OK;
/*
	_TRACE (1, L"Entering  CACLDiagComModule::IsUserAdministrator\n");
	HRESULT	hr = S_OK;
	DWORD	dwErr = 0;

	bIsAdministrator = FALSE;
	if ( IsWindowsNT () )
	{
		DWORD						dwInfoBufferSize = 0;
		PSID						psidAdministrators;
		SID_IDENTIFIER_AUTHORITY	siaNtAuthority = SECURITY_NT_AUTHORITY;

		BOOL bResult = AllocateAndInitializeSid (&siaNtAuthority, 2,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
				0, 0, 0, 0, 0, 0, &psidAdministrators);
		if ( bResult )
		{
			bResult = CheckTokenMembership (0, psidAdministrators,
					&bIsAdministrator);
			ASSERT (bResult);
			if ( !bResult )
			{
				dwErr = GetLastError ();
				hr = HRESULT_FROM_WIN32 (dwErr);
			}
			FreeSid (psidAdministrators);
		}
		else
		{
			dwErr = GetLastError ();
			hr = HRESULT_FROM_WIN32 (dwErr);
		}
	}

	_TRACE (-1, L"Leaving CACLDiagComModule::IsUserAdministrator\n");
	return hr
*/
}

bool CACLDiagComModule::IsWindowsNT()
{
	OSVERSIONINFO	versionInfo;

	::ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
	versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    BOOL	bResult = ::GetVersionEx (&versionInfo);
	ASSERT (bResult);
	if ( bResult )
	{
		if ( VER_PLATFORM_WIN32_NT == versionInfo.dwPlatformId )
			bResult = TRUE;
	}
		
	return bResult ? true : false;
}


///////////////////////////////////////////////////////////////////////////////
// ACE_SAMNAME

BOOL ACE_SAMNAME::operator==(const ACE_SAMNAME& rAceSAMName) const
{
    // Neutralize INHERITED_ACE flag in Header.AceFlags
    // Consider equivalent if all the mask bits in 'this' are found in rAceSAMName
    BOOL bResult = FALSE;
    if ( (m_AceType == rAceSAMName.m_AceType) && 
            ( !this->m_SAMAccountName.compare (rAceSAMName.m_SAMAccountName)) )
    {
        switch (m_AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            if ( m_pAllowedAce->Mask == rAceSAMName.m_pAllowedAce->Mask &&
                    (m_pAllowedAce->Header.AceFlags | INHERITED_ACE ) == 
                            (rAceSAMName.m_pAllowedAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pAllowedAce->Header.AceSize == rAceSAMName.m_pAllowedAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            if ( m_pAllowedObjectAce->Mask == rAceSAMName.m_pAllowedObjectAce->Mask &&
                    (m_pAllowedObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pAllowedObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                     m_pAllowedObjectAce->Header.AceSize == rAceSAMName.m_pAllowedObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pAllowedObjectAce->ObjectType, rAceSAMName.m_pAllowedObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_DENIED_ACE_TYPE:
            if ( m_pDeniedAce->Mask == rAceSAMName.m_pDeniedAce->Mask &&
                    (m_pDeniedAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pDeniedAce->Header.AceFlags | INHERITED_ACE )  &&
                    m_pDeniedAce->Header.AceSize == rAceSAMName.m_pDeniedAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            if ( m_pDeniedObjectAce->Mask == rAceSAMName.m_pDeniedObjectAce->Mask &&
                    (m_pDeniedObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pDeniedObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pDeniedObjectAce->Header.AceSize == rAceSAMName.m_pDeniedObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pDeniedObjectAce->ObjectType, rAceSAMName.m_pDeniedObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            if ( m_pSystemAuditObjectAce->Mask == rAceSAMName.m_pSystemAuditObjectAce->Mask &&
                    (m_pSystemAuditObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pSystemAuditObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pSystemAuditObjectAce->Header.AceSize == rAceSAMName.m_pSystemAuditObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pSystemAuditObjectAce->ObjectType, rAceSAMName.m_pSystemAuditObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            if ( m_pSystemAuditAce->Mask == rAceSAMName.m_pSystemAuditAce->Mask &&
                    (m_pSystemAuditAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pSystemAuditAce->Header.AceFlags | INHERITED_ACE )  &&
                    m_pSystemAuditAce->Header.AceSize == rAceSAMName.m_pSystemAuditAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        default:
            break;
        }
    }
    return bResult;
}


BOOL ACE_SAMNAME::IsEquivalent (ACE_SAMNAME& rAceSAMName, ACCESS_MASK accessMask)
{
    // Neutralize INHERITED_ACE flag in Header.AceFlags
    BOOL bResult = FALSE;
    if ( m_AceType == rAceSAMName.m_AceType )
    {
        switch (m_AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            if ( (m_pAllowedAce->Mask & accessMask) == 
                        (rAceSAMName.m_pAllowedAce->Mask & accessMask) &&
                    m_pAllowedAce->SidStart == rAceSAMName.m_pAllowedAce->SidStart &&
                    (m_pAllowedAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pAllowedAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pAllowedAce->Header.AceSize == rAceSAMName.m_pAllowedAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            if ( (m_pAllowedObjectAce->Mask & accessMask) == 
                        (rAceSAMName.m_pAllowedObjectAce->Mask & accessMask) &&
                    m_pAllowedObjectAce->SidStart == rAceSAMName.m_pAllowedObjectAce->SidStart &&
                    (m_pAllowedObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pAllowedObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pAllowedObjectAce->Header.AceSize == rAceSAMName.m_pAllowedObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pAllowedObjectAce->ObjectType, rAceSAMName.m_pAllowedObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_DENIED_ACE_TYPE:
            if ( (m_pDeniedAce->Mask & accessMask) == 
                        (rAceSAMName.m_pDeniedAce->Mask & accessMask) &&
                    m_pDeniedAce->SidStart == rAceSAMName.m_pDeniedAce->SidStart &&
                    (m_pDeniedAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pDeniedAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pDeniedAce->Header.AceSize == rAceSAMName.m_pDeniedAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            if ( (m_pDeniedObjectAce->Mask & accessMask) == 
                        (rAceSAMName.m_pDeniedObjectAce->Mask & accessMask) &&
                    m_pDeniedObjectAce->SidStart == rAceSAMName.m_pDeniedObjectAce->SidStart &&
                    (m_pDeniedObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pDeniedObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pDeniedObjectAce->Header.AceSize == rAceSAMName.m_pDeniedObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pDeniedObjectAce->ObjectType, rAceSAMName.m_pDeniedObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            if ( (m_pSystemAuditObjectAce->Mask & accessMask) == 
                        (rAceSAMName.m_pSystemAuditObjectAce->Mask & accessMask) &&
                    m_pSystemAuditObjectAce->SidStart == rAceSAMName.m_pSystemAuditObjectAce->SidStart &&
                    (m_pSystemAuditObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pSystemAuditObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pSystemAuditObjectAce->Header.AceSize == rAceSAMName.m_pSystemAuditObjectAce->Header.AceSize )
            {
                bResult = TRUE;
            }
             break;

        case SYSTEM_AUDIT_ACE_TYPE:
            if ( (m_pSystemAuditAce->Mask & accessMask) == 
                        (rAceSAMName.m_pSystemAuditAce->Mask & accessMask) &&
                    m_pSystemAuditAce->SidStart == rAceSAMName.m_pSystemAuditAce->SidStart &&
                    (m_pSystemAuditAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pSystemAuditAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pSystemAuditAce->Header.AceSize == rAceSAMName.m_pSystemAuditAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        default:
            break;
        }
    }
    return bResult;
}

bool ACE_SAMNAME::IsInherited() const
{
    return (m_pAllowedAce->Header.AceFlags & INHERITED_ACE) ? true : false;
}


void ACE_SAMNAME::DebugOut() const
{
#if DBG == 1
    wstring     strGuidResult;
    GUID_TYPE   guidType = GUID_TYPE_UNKNOWN;
    _TRACE (0, L"\n");

    _TRACE (0, L"Principal Name:   %s\n", m_SAMAccountName.c_str ());
    switch (m_AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        _TRACE (0, L"AceType:  ACCESS_ALLOWED_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pAllowedAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pAllowedAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pAllowedAce->Header.AceSize);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        _TRACE (0, L"AceType: ACCESS_ALLOWED_OBJECT_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pAllowedObjectAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pAllowedObjectAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pAllowedObjectAce->Header.AceSize);
        _Module.GetClassFromGUID (m_pAllowedObjectAce->ObjectType, strGuidResult, &guidType);
        break;

    case ACCESS_DENIED_ACE_TYPE:
        _TRACE (0, L"AceType: ACCESS_DENIED_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pDeniedAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pDeniedAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pDeniedAce->Header.AceSize);
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        _TRACE (0, L"AceType: ACCESS_DENIED_OBJECT_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pDeniedObjectAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pDeniedObjectAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pDeniedObjectAce->Header.AceSize);
        _Module.GetClassFromGUID (m_pDeniedObjectAce->ObjectType, strGuidResult, &guidType);
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        _TRACE (0, L"AceType: SYSTEM_AUDIT_OBJECT_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pSystemAuditObjectAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pSystemAuditObjectAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pSystemAuditObjectAce->Header.AceSize);
        _Module.GetClassFromGUID (m_pSystemAuditObjectAce->ObjectType, strGuidResult, &guidType);
        break;

    case SYSTEM_AUDIT_ACE_TYPE:
        _TRACE (0, L"AceType: SYSTEM_AUDIT_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pSystemAuditAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pSystemAuditAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pSystemAuditAce->Header.AceSize);
        break;
    }

    if ( IsObjectAceType (m_pAllowedAce) )
    {
        wstring strGuidType;
        switch (guidType)
        {
        case GUID_TYPE_CLASS:
            strGuidType = L"GUID_TYPE_CLASS";
            break;

        case GUID_TYPE_ATTRIBUTE:
            strGuidType = L"GUID_TYPE_ATTRIBUTE";
            break;

        case GUID_TYPE_CONTROL:
            strGuidType = L"GUID_TYPE_CONTROL";
            break;

        default:
#pragma warning (disable : 4127)
            ASSERT (0);
#pragma warning (default : 4127)
            // fall through

        case GUID_TYPE_UNKNOWN:
            strGuidType = L"GUID_TYPE_UNKNOWN";
            break;
        }
        _TRACE (0, L"ObjectType type:  %s\n", strGuidType.c_str ());
        _TRACE (0, L"ObjectType value: %s\n", strGuidResult.c_str ());
    }

    _TRACE (0, L"\n");
#endif
}

///////////////////////////////////////////////////////////////////////////////
HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
/*******************************************************************

    NAME:       EnablePrivileges

    SYNOPSIS:   Enables the given privileges in the current token

    ENTRY:      pdwPrivileges - list of privileges to enable

    RETURNS:    On success, the previous thread handle (if present) or NULL
                On failure, INVALID_HANDLE_VALUE

    NOTES:      The returned handle should be passed to ReleasePrivileges
                to ensure proper cleanup.  Otherwise, if not NULL or
                INVALID_HANDLE_VALUE it should be closed with CloseHandle.

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
HANDLE EnablePrivileges(PDWORD pdwPrivileges, ULONG cPrivileges)
{
    BOOL                fResult;
    HANDLE              hToken;
    HANDLE              hOriginalThreadToken;
    PTOKEN_PRIVILEGES   ptp;
    ULONG               nBufferSize;

    if (!pdwPrivileges || !cPrivileges)
        return INVALID_HANDLE_VALUE;

    // Note that TOKEN_PRIVILEGES includes a single LUID_AND_ATTRIBUTES
    nBufferSize = sizeof(TOKEN_PRIVILEGES) + (cPrivileges - 1) * 
    		sizeof(LUID_AND_ATTRIBUTES);
    ptp = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, nBufferSize);
    if (!ptp)
        return INVALID_HANDLE_VALUE;

    //
    // Initialize the Privileges Structure
    //
    ptp->PrivilegeCount = cPrivileges;
    for (ULONG i = 0; i < cPrivileges; i++)
    {
        //ptp->Privileges[i].Luid = RtlConvertUlongToLuid(*pdwPrivileges++);
        ptp->Privileges[i].Luid.LowPart = *pdwPrivileges++;
        ptp->Privileges[i].Luid.HighPart = 0;
        ptp->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    //
    // Open the Token
    //
    hToken = hOriginalThreadToken = INVALID_HANDLE_VALUE;
    fResult = OpenThreadToken (GetCurrentThread (), TOKEN_DUPLICATE, FALSE, 
    		&hToken);
    if (fResult)
        hOriginalThreadToken = hToken;  // Remember the thread token
    else
        fResult = OpenProcessToken (GetCurrentProcess(), TOKEN_DUPLICATE, 
        		&hToken);

    if (fResult)
    {
        HANDLE hNewToken;

        //
        // Duplicate that Token
        //
        fResult = DuplicateTokenEx(hToken,
                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                   NULL,                   // PSECURITY_ATTRIBUTES
                   SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                   TokenImpersonation,     // TokenType
                   &hNewToken);            // Duplicate token
        if (fResult)
        {
            //
            // Add new privileges
            //
            fResult = AdjustTokenPrivileges(hNewToken,  // TokenHandle
                        FALSE,      // DisableAllPrivileges
                        ptp,        // NewState
                        0,          // BufferLength
                        NULL,       // PreviousState
                        NULL);      // ReturnLength
            if (fResult)
            {
                //
                // Begin impersonating with the new token
                //
                fResult = SetThreadToken(NULL, hNewToken);
            }

            CloseHandle(hNewToken);
        }
    }

    // If something failed, don't return a token
    if (!fResult)
        hOriginalThreadToken = INVALID_HANDLE_VALUE;

    // Close the original token if we aren't returning it
    if (hOriginalThreadToken == INVALID_HANDLE_VALUE && 
    		hToken != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hToken);
	}

    // If we succeeded, but there was no original thread token,
    // return NULL to indicate we need to do SetThreadToken(NULL, NULL)
    // to release privs.
    if (fResult && hOriginalThreadToken == INVALID_HANDLE_VALUE)
        hOriginalThreadToken = NULL;

    LocalFree(ptp);

    return hOriginalThreadToken;
}


/*******************************************************************

    NAME:       ReleasePrivileges

    SYNOPSIS:   Resets privileges to the state prior to the corresponding
                EnablePrivileges call.

    ENTRY:      hToken - result of call to EnablePrivileges

    RETURNS:    nothing

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
void ReleasePrivileges(HANDLE hToken)
{
    if (INVALID_HANDLE_VALUE != hToken)
    {
        SetThreadToken(NULL, hToken);
        if (hToken)
            CloseHandle(hToken);
    }
}

VOID LocalFreeStringW(LPWSTR* ppString)
{
    if ( ppString && *ppString )
    {
        LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     GetNameFromSid ()
//
//  Purpose:    Get the name of the object represented by this Sid
//
//  Inputs:     pSid - SID of the object whose name we wish to retrieve
//
//  Outputs:    strPrincipalName - name of the object in NameUserPrincipal
//              pstrFQDN - (optional) name of the object as Fully Qualified DN
//
HRESULT GetNameFromSid (
	PSID pSid, 
	wstring& strPrincipalName, 
	wstring* pstrFQDN, 
	SID_NAME_USE& sne)
{
    ASSERT (IsValidSid (pSid));
    if ( !IsValidSid (pSid) )
        return E_INVALIDARG;

    WCHAR           szName[MAX_PATH];
    WCHAR           szDomain[MAX_PATH];
    DWORD           cchName = MAX_PATH-1;
    DWORD           cchDomain = MAX_PATH-1;
    HRESULT         hr = S_OK;

    if ( LookupAccountSid (NULL, pSid, 
            szName, &cchName, szDomain, 
            &cchDomain, &sne) )
    {
        wstring strSamCompatibleName (szDomain);

        strSamCompatibleName += L"\\";
        strSamCompatibleName += szName;

        // Get Principal Name
        {
            PWSTR   pszTranslatedName = 0;
		    

            hr = CrackName(const_cast<PWSTR> (strSamCompatibleName.c_str ()), 
                    &pszTranslatedName, 
                    GET_OBJ_UPN, //GET_OBJ_NT4_NAME,
                    0);
            if ( SUCCEEDED (hr) )
            {
                strPrincipalName = pszTranslatedName;
                LocalFreeStringW(&pszTranslatedName);
            }
            else
            {
                strPrincipalName = strSamCompatibleName;
            }
        }


        // Get fully qualified DN
        if ( pstrFQDN )
        {
            PWSTR   pszTranslatedName = 0;

            hr = CrackName(const_cast<PWSTR> (strSamCompatibleName.c_str ()), 
                    &pszTranslatedName, 
                    GET_OBJ_1779_DN,
                    0);
            if ( SUCCEEDED (hr) )
            {
                *pstrFQDN = pszTranslatedName;
                LocalFreeStringW(&pszTranslatedName);
            }
            else
            {
                *pstrFQDN = strSamCompatibleName;
            }
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"LookupAccountSid failed: 0x%x\n", dwErr);
        if ( ERROR_NONE_MAPPED == dwErr )
        {
            PWSTR   pszStringSid = 0;
            if ( ::ConvertSidToStringSid (pSid, &pszStringSid) )
            {
                strPrincipalName = pszStringSid;
                if ( pstrFQDN )
                    *pstrFQDN = pszStringSid;

                ::LocalFree (pszStringSid);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = HRESULT_FROM_WIN32 (dwErr);
    }

    return hr;
}

#define MAX_BUF_SIZE	4096
CHAR	AnsiBuf[MAX_BUF_SIZE*3];	/* worst case is DBCS, which	*/
					/* needs more than *2		*/
TCHAR	ConBuf [MAX_BUF_SIZE];

int FileIsConsole(HANDLE fh)
{
    unsigned htype ;

    htype = GetFileType(fh);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}


int MyWriteConsole(int fOutOrErr)
{
    DWORD cch = (DWORD) _tcslen(ConBuf);
    HANDLE	hOut;

    if (fOutOrErr == 1)
	    hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    else
	    hOut = GetStdHandle(STD_ERROR_HANDLE);

    if (FileIsConsole(hOut))
	    WriteConsole(hOut, ConBuf, cch, &cch, NULL);
    else {
	    cch = WideCharToMultiByte(CP_OEMCP, 0,
				  ConBuf, (int) cch,
				  AnsiBuf, MAX_BUF_SIZE*3,
				  NULL, NULL);
	    WriteFile(hOut, AnsiBuf, cch, &cch, NULL);
    }

    return (int) cch;
}

int MyWprintf( const wchar_t *fmt, ... )
{
    va_list     args;

    va_start( args, fmt );
    _vsnwprintf( ConBuf, MAX_BUF_SIZE, fmt, args );
    va_end( args );
    return MyWriteConsole(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\adsiobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ADSIObj.h
//
//  Contents:   Classes CACLAdsiObject
//              
//
//----------------------------------------------------------------------------
#ifndef __ADSIOBJ_ADUTILS_H
#define __ADSIOBJ_ADUTILS_H

#include "stdafx.h"
#include "util.h"

class CACLAdsiObject : public CAdsiObject 
{
public:  
	HRESULT GetPrincipalSelfSid (PSID& principalSelfSid);
    CACLAdsiObject () : CAdsiObject ()
    {
    }

    virtual ~CACLAdsiObject () {};

    HRESULT BuildObjectTypeList (
                POBJECT_TYPE_LIST* pObjectTypeList, 
                size_t& objectTypeListLength);
    LPCWSTR GetSchemaCommonName ()
    {
        return m_strSchemaCommonName.c_str ();
    }
    virtual HRESULT Bind(LPCWSTR lpszLdapPath);

protected:
    HRESULT ReadSchemaCommonName ();
    HRESULT AddAttrGUIDToList (
                const BSTR pszAttrName, 
                list<POBJECT_TYPE_LIST>& rGuidList);
    HRESULT ReadSchemaAttributeCommonName (
                const BSTR pszAttrName,
                BSTR* attrCommonName);

private:
    wstring m_strSchemaCommonName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\chkdeleg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ChkDeleg.h
//
//  Contents:   CheckDelegation and support methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_CHKDELEG_H
#define __ACLDIAG_CHKDELEG_H

#include "stdafx.h"


HRESULT CheckDelegation ();

#endif //__ACLDIAG_CHKDELEG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\chkdeleg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ChkDeleg.cpp
//
//  Contents:   CheckDelegation and support methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <conio.h>
#include <aclapi.h>
#include "adutils.h"
#include <util.h>
#include "ChkDeleg.h"
#include <deltempl.h>
#include <tempcore.h>
#include "SecDesc.h"



#include <sddl.h>
#include <dscmn.h>  // from the admin\display project (CrackName)

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

#include <_util.cpp>
#include <_tempcor.cpp>
#include <_deltemp.cpp>




class CTemplateAccessPermissionsHolderManagerVerify : public CTemplateAccessPermissionsHolderManager
{
public:

  HRESULT ProcessTemplates ();  // for ACLDiag - process each template in turn
  HRESULT ProcessPermissions(
                const wstring& strObjectClass, 
                CTemplate* pTemplate, 
                PACL pAccessList,
                CPrincipalList& principalList);
};




HRESULT CheckDelegation ()
{
    _TRACE (1, L"Entering  CheckDelegation\n");
    HRESULT hr = S_OK;
    wstring str;


    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_DELEGATION_TEMPLATE_DIAGNOSIS);
        MyWprintf (str.c_str ());
    }

    CTemplateAccessPermissionsHolderManagerVerify templateAccessPermissionsHolderManager;

    if ( templateAccessPermissionsHolderManager.LoadTemplates() )
    {
        hr = templateAccessPermissionsHolderManager.ProcessTemplates ();
    }
    else
    {
        LoadFromResource (str, IDS_FAILED_TO_LOAD_TEMPLATES);
        MyWprintf (str.c_str ());
        hr = E_FAIL;
    }

    _TRACE (-1, L"Leaving CheckDelegation: 0x%x\n", hr);
    return hr;
}

PTOKEN_USER EfspGetTokenUser ()
{
	_TRACE (1, L"Entering  EfspGetTokenUser\n");
    HANDLE				hToken = 0;
    DWORD				dwReturnLength = 0;
    PTOKEN_USER			pTokenUser = NULL;

	BOOL	bResult = ::OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &hToken);
	if ( bResult )
	{
        bResult  = ::GetTokenInformation (
                     hToken,
                     TokenUser,
                     NULL,
                     0,
                     &dwReturnLength
                     );

        if ( !bResult && dwReturnLength > 0 )
		{
            pTokenUser = (PTOKEN_USER) malloc (dwReturnLength);

            if (pTokenUser)
			{
                bResult = GetTokenInformation (
                             hToken,
                             TokenUser,
                             pTokenUser,
                             dwReturnLength,
                             &dwReturnLength
                             );

                if ( !bResult)
				{
                    DWORD dwErr = GetLastError ();
					_TRACE (0, L"GetTokenInformation () failed: 0x%x\n", dwErr);
                    free (pTokenUser);
                    pTokenUser = NULL;
                }
            }
        }
		else
		{
            DWORD dwErr = GetLastError ();
			_TRACE (0, L"GetTokenInformation () failed: 0x%x\n", dwErr);
        }

        ::CloseHandle (hToken);
    }
	else
	{
		DWORD	dwErr = GetLastError ();
		_TRACE (0, L"OpenProcessToken () failed: 0x%x\n", dwErr);
    }

	_TRACE (-1, L"Leaving EfspGetTokenUser\n");
    return pTokenUser;
}

HRESULT CTemplateAccessPermissionsHolderManagerVerify::ProcessTemplates ()
{
    HRESULT                 hr = S_OK;

    DWORD   dwErr = 0;

 	// the access list is read in, modified, written back
    // If /fixdeleg is on, this list will be populated from the DS,
    // will receive the permissions associated with selected templates is the
    // user chooses to fix delegation, and then will be written back to the DS.
	PACL pFixDACL = NULL;

    LPCWSTR lpszObjectLdapPath = _Module.m_adsiObject.GetLdapPath();

    // get the security info
    if ( _Module.FixDelegation () && !_Module.DoTabDelimitedOutput () )
    {
        _TRACE (0, L"calling GetNamedSecurityInfo(%s, ...)\n", lpszObjectLdapPath);
        dwErr = ::GetNamedSecurityInfo (
                (LPWSTR) lpszObjectLdapPath,    // name of the object
                SE_DS_OBJECT_ALL,           // type of object
                DACL_SECURITY_INFORMATION,  // type of security information to retrieve
                NULL,                 // receives a pointer to the owner SID
                NULL,                 // receives a pointer to the primary group SID
                &pFixDACL,            // receives a pointer to the DACL
                NULL,                          // receives a pointer to the SACL
                NULL);                  // receives a pointer to the security descriptor
	    if (dwErr != ERROR_SUCCESS)
	    {
            _TRACE (0, L"failed on GetNamedSecurityInfo(): dwErr = 0x%x\n", dwErr);
            wstring str;
            LoadFromResource (str, IDS_DELEGWIZ_ERR_GET_SEC_INFO);
            MyWprintf (str.c_str ());
            _Module.TurnOffFixDelegation ();
	    }
    }

    CPrincipal              principal;  // a dummy placeholder for us to get 
                                        // the incremental rights associated
                                        // with each template

    // We will use the current logged-in user as a placeholder only.
    PTOKEN_USER	pTokenUser = ::EfspGetTokenUser ();
    if ( pTokenUser )
    {
	    hr = principal.Initialize (pTokenUser->User.Sid);
	    free (pTokenUser);
    }

    if ( SUCCEEDED (hr) )
    {
        CTemplateList* pList = m_templateManager.GetTemplateList();
        for (CTemplateList::iterator itr = pList->begin(); itr != pList->end(); itr++)
        {
            CTemplate* pTemplate = *itr;
            ASSERT(pTemplate != NULL);

            // Select the templates one at a time to get the
            // permissions representing them
            pTemplate->m_bSelected = TRUE;

            if ( InitPermissionHoldersFromSelectedTemplates (
                    &_Module.m_classInfoArray,
                    &_Module.m_adsiObject) )
            {
                // This access list will contain only the access control values 
                // associated with the selected template
                PACL pAccessList = 0; //(PACL) ::LocalAlloc (LMEM_ZEROINIT, sizeof (ACL));
                if ( 1 ) //pAccessList )
                {
                    DWORD dwErr = UpdateAccessList (
                            &principal, 
                            _Module.m_adsiObject.GetServerName(),
                            _Module.m_adsiObject.GetPhysicalSchemaNamingContext(),
                            &pAccessList
                            );

                    if ( 0 == dwErr )
                    {
                        CPrincipalList  principalList;
                        PSID            pSid = principal.GetSid ();
                        SID_NAME_USE    sne = SidTypeUnknown;
                        wstring         strPrincipalName;

                        hr = GetNameFromSid (pSid, strPrincipalName, 0, sne);
                        if ( SUCCEEDED (hr) )
                        {
                            hr = ProcessPermissions (_Module.m_adsiObject.GetClass (),
                                    pTemplate, pAccessList, principalList);
                            if ( SUCCEEDED (hr) && _Module.FixDelegation () && !_Module.DoTabDelimitedOutput () )
                            {
	                            // loop thru all the principals and classes
	                            CPrincipalList::iterator i;
                              for (i = principalList.begin(); i != principalList.end(); ++i)
                              {
                                    CPrincipal* pCurrPrincipal = (*i);
                                    dwErr = UpdateAccessList(
                                            pCurrPrincipal, 
                                            _Module.m_adsiObject.GetServerName(),
                                            _Module.m_adsiObject.GetPhysicalSchemaNamingContext(),
                                            &pFixDACL);
                                    if (dwErr != 0)
                                        break;
	                            } // for pCurrPrincipal
                            }
                        }
                    }

                    ::LocalFree (pAccessList);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            pTemplate->m_bSelected = FALSE;
        }

        if ( _Module.FixDelegation () && !_Module.DoTabDelimitedOutput () )
        {
            // commit changes
            _TRACE (0, L"calling SetNamedSecurityInfo(%s, ...)\n", lpszObjectLdapPath);
            dwErr = ::SetNamedSecurityInfoW(
                    (LPWSTR) lpszObjectLdapPath,
                    SE_DS_OBJECT_ALL,
                    DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pFixDACL,
                    0);
            if (dwErr != ERROR_SUCCESS)
            {
                _TRACE (0, L"failed on SetNamedSecurityInfo(): dwErr = 0x%x\n", dwErr);
                wstring str;
                LoadFromResource (str, IDS_DELEGWIZ_ERR_SET_SEC_INFO);
                MyWprintf (str.c_str ());
            }
        }
    }


    if ( pFixDACL )
        ::LocalFree (pFixDACL);


    return hr;
}


class CTemplateStatus 
{
public:
    CTemplateStatus () : 
            m_nACECnt (1),
            m_bApplies (false),
            m_bInherited (false)
    {
    }

    ULONG                       m_nACECnt;
    bool                        m_bApplies;
    bool                        m_bInherited;
    wstring                     m_strObjName;
    PSID                        m_psid;
};

typedef list<CTemplateStatus*>  CStatusList;

HRESULT CTemplateAccessPermissionsHolderManagerVerify::ProcessPermissions(
        const wstring& strObjectClass, 
        CTemplate* pTemplate, 
        PACL pDacl,
        CPrincipalList& principalList)
{
    if ( !pTemplate )
        return E_POINTER;

    HRESULT         hr = S_OK;
    CStatusList     statusList; // This list will contain 1 entry for each 
                                // SidStart/bInherited/bApplies triplet.
                                // The counter for each item will incremented 
                                // each time an ACE is found that belongs to 
                                // the object pointed to by the SidStart.
    ULONG           nExpectedCnt = 0;
    bool            bApplies = pTemplate->AppliesToClass(strObjectClass.c_str ()) ? true : false;
    ACE_SAMNAME*    pAceSAMName = 0;


    // Look in global DACL for each right
    PACCESS_ALLOWED_ACE pAllowedAce = 0;

	// iterate through the template ACES
	for (int i = 0; i < pDacl->AceCount; i++)
	{
		if ( GetAce (pDacl, i, (void **)&pAllowedAce) )
        {
            PSID AceSid = 0;
            if ( IsObjectAceType ( pAllowedAce ) ) 
            {
                AceSid = RtlObjectAceSid( pAllowedAce );
            } 
            else 
            {
                AceSid = &( ( PKNOWN_ACE )pAllowedAce )->SidStart;
            }
            ASSERT (IsValidSid (AceSid));

            if ( !IsValidSid (AceSid) )
                continue;

//            wstring         strPrincipalName;
//            SID_NAME_USE    sne = SidTypeUnknown;
//            hr = GetNameFromSid (AceSid, strPrincipalName, 0, sne);
//            if ( SUCCEEDED (hr) )
            {
                ACE_SAMNAME* pAceTemplate = new ACE_SAMNAME;
                if ( pAceTemplate )
                {
                    pAceTemplate->m_AceType = pAllowedAce->Header.AceType;
                    switch (pAceTemplate->m_AceType)
                    {
                    case ACCESS_ALLOWED_ACE_TYPE:
                        pAceTemplate->m_pAllowedAce = pAllowedAce;
                        break;

                    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                        pAceTemplate->m_pAllowedObjectAce = 
                                reinterpret_cast <PACCESS_ALLOWED_OBJECT_ACE> (pAllowedAce);
                        break;

                    case ACCESS_DENIED_ACE_TYPE:
                        pAceTemplate->m_pDeniedAce = 
                                reinterpret_cast <PACCESS_DENIED_ACE> (pAllowedAce);
                        break;

                    case ACCESS_DENIED_OBJECT_ACE_TYPE:
                        pAceTemplate->m_pDeniedObjectAce = 
                                reinterpret_cast <PACCESS_DENIED_OBJECT_ACE> (pAllowedAce);
                        break;

                    default:
                        break;
                    }
//                    pAceTemplate->m_SAMAccountName = strPrincipalName;
                    pAceTemplate->DebugOut ();
                    nExpectedCnt++;
                    ACE_SAMNAME_LIST::iterator itr = _Module.m_DACLList.begin ();
                    for (; itr != _Module.m_DACLList.end () && SUCCEEDED (hr); itr++)
                    {
                        pAceSAMName = *itr;

                        // to neutralize Sid differences
                        pAceTemplate->m_SAMAccountName = pAceSAMName->m_SAMAccountName;
                        if ( *pAceSAMName == *pAceTemplate )
                        {
                            bool                    bFound = false;
                            CTemplateStatus*        pStatus = 0;
                            CStatusList::iterator   itr = statusList.begin ();
                            wstring                 strObjName;
                            PSID                    psid = 0;


                            if ( ACCESS_ALLOWED_OBJECT_ACE_TYPE == pAceSAMName->m_AceType ) 
                            {
                                psid = RtlObjectAceSid (pAceSAMName->m_pAllowedObjectAce);
                            } 
                            else 
                            {
                                psid = &( ( PKNOWN_ACE )pAceSAMName->m_pAllowedAce )->SidStart;
                            }

                            SID_NAME_USE    sne = SidTypeUnknown;
                            hr = GetNameFromSid (psid, strObjName, 0, sne);
                            if ( SUCCEEDED (hr) )
                            {
                                for (; itr != statusList.end (); itr++)
                                {
                                    pStatus = *itr;
                                    if ( (pStatus->m_bApplies == bApplies) && 
                                            ( pStatus->m_bInherited == pAceSAMName->IsInherited () ) &&
                                            ( !_wcsicmp (
                                                    pStatus->m_strObjName.c_str (), 
                                                    strObjName.c_str ())) )
                                    {
                                        bFound = true;
                                        break;
                                    }
                                }

                                if ( bFound )
                                {
                                    pStatus->m_nACECnt++;
                                }
                                else
                                {
                                    pStatus = new CTemplateStatus;
                                    if ( pStatus )
                                    {
                                        pStatus->m_strObjName = strObjName;
                                        pStatus->m_bApplies = bApplies;
                                        pStatus->m_bInherited = pAceSAMName->IsInherited ();
                                        pStatus->m_psid = psid;
                                        statusList.push_back (pStatus);
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
        }
    }


    // Now, iterate thru status list and evaluate each item
    // If the list is empty, then this template is not present.
    // Otherwise, for each present item, if the class and attr count is less than the required count
    // the template is partial for the item.
    // Otherwise, it is OK.
    CStatusList::iterator   itr = statusList.begin ();
    CTemplateStatus*        pStatus = 0;    
    wstring                 str;
    wstring                 strStatus;


    for (; itr != statusList.end () && SUCCEEDED (hr); itr++)
    {
        pStatus = *itr;

        // Print template description
        bool    bMisconfigured = false;

        if ( _Module.DoTabDelimitedOutput () )
        {
            FormatMessage (str, IDS_DELEGATION_TITLE_CDO, pTemplate->GetDescription (),  
                    pStatus->m_strObjName.c_str ());
        }
        else
        {
            FormatMessage (str, IDS_DELEGATION_TITLE, pTemplate->GetDescription (),  
                    pStatus->m_strObjName.c_str ());
        }
        MyWprintf (str.c_str ());

        // Print "Status: OK/MISCONFIGURED"
        if ( pStatus->m_nACECnt < nExpectedCnt )
        {
            LoadFromResource (strStatus, IDS_MISCONFIGURED);
            bMisconfigured = true;
        }
        else
            LoadFromResource (strStatus, IDS_OK);

        if ( _Module.DoTabDelimitedOutput () )
            FormatMessage (str, IDS_DELTEMPL_STATUS_CDO, strStatus.c_str ());
        else
            FormatMessage (str, IDS_DELTEMPL_STATUS, strStatus.c_str ());
        MyWprintf (str.c_str ());

        // Print "Applies on this object: YES/NO"
        if ( pStatus->m_bApplies )
        {
            LoadFromResource (strStatus, 
                    _Module.DoTabDelimitedOutput () ? IDS_APPLIES : IDS_YES);
        }
        else
        {
            LoadFromResource (strStatus, 
                    _Module.DoTabDelimitedOutput () ? IDS_DOES_NOT_APPLY : IDS_NO);
        }

        if ( _Module.DoTabDelimitedOutput () )
            FormatMessage (str, IDS_APPLIES_ON_THIS_OBJECT_CDO, strStatus.c_str ());
        else
            FormatMessage (str, IDS_APPLIES_ON_THIS_OBJECT, strStatus.c_str ());
        MyWprintf (str.c_str ());

        // Print "Inherited from parent: YES/NO"
        if ( pStatus->m_bInherited )
        {
            LoadFromResource (strStatus, 
                    _Module.DoTabDelimitedOutput () ? IDS_INHERITED : IDS_YES);
        }
        else
        {
            LoadFromResource (strStatus, 
                    _Module.DoTabDelimitedOutput () ? IDS_EXPLICIT : IDS_NO);
        }

        if ( _Module.DoTabDelimitedOutput () )
            FormatMessage (str, IDS_INHERITED_FROM_PARENT_CDO, strStatus.c_str ());
        else
            FormatMessage (str, IDS_INHERITED_FROM_PARENT, strStatus.c_str ());
        MyWprintf (str.c_str ());

        if ( bMisconfigured && _Module.FixDelegation () && !_Module.DoTabDelimitedOutput () )
        {
            LoadFromResource (str, IDS_FIX_DELEGATION_QUERY);

            while (1)
            {
                MyWprintf (str.c_str ());

                int ch = _getche ();
                
                if ( 'y' == ch )
                {
                    CPrincipal* pPrincipal = new CPrincipal;

                    if ( pPrincipal )
                    {
                        if ( SUCCEEDED (pPrincipal->Initialize (pStatus->m_psid)) )
                            principalList.push_back (pPrincipal);
                        else
                            delete pPrincipal;
                    }
                    else
                        hr = E_OUTOFMEMORY;

                    MyWprintf (L"\n\n");
                    break;
                }
                else if ( 'n' == ch )
                {
                    MyWprintf (L"\n\n");
                    break;
                }
                else
                {
                    MyWprintf (L"\n");
                    continue;
                }
            }
        }
    }

    if ( !pStatus ) // None found
    {
        // Print template description
        if ( _Module.DoTabDelimitedOutput () )
        {
            FormatMessage (str, IDS_DELEGATION_NOT_FOUND_CDO, 
                    pTemplate->GetDescription ());
            MyWprintf (str.c_str ());
        }
        else
        {
            FormatMessage (str, L"\t%1\n\n", pTemplate->GetDescription ());
            MyWprintf (str.c_str ());

            LoadFromResource (strStatus, IDS_NOT_PRESENT);
            FormatMessage (str, IDS_DELTEMPL_STATUS, strStatus.c_str ());
            MyWprintf (str.c_str ());
        }
    }

    if ( !_Module.DoTabDelimitedOutput () )
        MyWprintf (L"\n");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#if DBG == 1
#define DEBUG_OUTPUT_NONE       0
#define DEBUG_OUTPUT_ERROR      1
#define DEBUG_OUTPUT_WARNING    2
#define DEBUG_OUTPUT_TRACE      3
#define DEBUGKEY    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\ACLDiag"
#define DEBUGLEVEL  L"debugOutput"

static bool             g_fDebugOutputLevelInit = false;
static unsigned long    g_ulDebugOutput = DEBUG_OUTPUT_NONE;
static int indentLevel = 0;

void TRACE (const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        WCHAR Buffer[512];
        int cb;

        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);

        cb = _vsnwprintf (Buffer, sizeof(Buffer), format, arglist);
        if ( cb )
        {
            OutputDebugStringW (Buffer);
        }

        va_end(arglist);
    }
}

void _TRACE (int level, const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        WCHAR Buffer[512];
        int cb;

        if ( level < 0 )
            indentLevel += level;
        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);

        cb = _vsnwprintf (Buffer, sizeof(Buffer), format, arglist);
        if ( cb )
        {
            OutputDebugStringW (Buffer);
        }

        va_end(arglist);

        if ( level > 0 )
            indentLevel += level;
    }
}


PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

//+----------------------------------------------------------------------------
// Function:    CheckDebugOutputLevel
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void CheckDebugOutputLevel ()
{
    if ( g_fDebugOutputLevelInit ) 
        return;
    g_fDebugOutputLevelInit = true;
    HKEY    hKey = 0;
    DWORD   dwDisposition = 0;
    LONG lResult = ::RegCreateKeyEx (HKEY_LOCAL_MACHINE, // handle of an open key
            DEBUGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
    if (lResult == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(unsigned long);
        lResult = RegQueryValueExW (hKey, DEBUGLEVEL, NULL, NULL,
                                (LPBYTE)&g_ulDebugOutput, &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            g_ulDebugOutput = DEBUG_OUTPUT_NONE;
            if ( ERROR_FILE_NOT_FOUND == lResult )
            {
                RegSetValueExW (hKey, DEBUGLEVEL, 0, REG_DWORD,
                        (LPBYTE)&g_ulDebugOutput, sizeof (g_ulDebugOutput));
            }
        }
        RegCloseKey(hKey);
    }
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void _TRACE (int level, const wchar_t *format, ... );
void TRACE (const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef ASSERT
#undef ASSERT
#undef ASSERTMSG
#endif

#define ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"ACLDiag(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"ACLDiag(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

void CheckDebugOutputLevel ();

#else // !DBG


#define _TRACE 
#define TRACE

#ifndef ASSERT
#define ASSERT(expr)
#endif

#ifndef ASSERTMSG
#define ASSERTMSG(expr, msg)
#endif

#endif


#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\adutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ADUtils.h
//
//  Contents:   Classes CWString, CACLDiagComModule, ACE_SAMNAME, helper methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_ADUTILS_H
#define __ACLDIAG_ADUTILS_H

#include "stdafx.h"
#include "ADSIObj.h"

///////////////////////////////////////////////////////////////////////
// wstring helper methods

HRESULT wstringFromGUID (wstring& str, REFGUID guid);
bool LoadFromResource(wstring& str, UINT uID);
bool FormatMessage(wstring& str, UINT nFormatID, ...);
bool FormatMessage(wstring& str, LPCTSTR lpszFormat, ...);


#include <util.h>

void StripQuotes (wstring& str);
wstring GetSystemMessage (DWORD dwErr);
HRESULT SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si);
HANDLE EnablePrivileges(PDWORD pdwPrivileges, ULONG cPrivileges);
void ReleasePrivileges(HANDLE hToken);

static const GUID NULLGUID =
{ 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };

#define IsObjectAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && \
        (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)    \
            )


#define THROW(e) throw e


#define ACLDIAG_CONFIG_NAMING_CONTEXT  L"configurationNamingContext"
#define ACLDIAG_ROOTDSE                L"RootDSE"

class PSID_FQDN 
{
public:
    PSID_FQDN (PSID psid, const wstring& strFQDN, const wstring& strDownLevelName, SID_NAME_USE sne) :
        m_PSID (psid),
        m_strFQDN (strFQDN),
        m_strDownLevelName (strDownLevelName),
        m_sne (sne)
    {
    }
    PSID            m_PSID;
    wstring         m_strFQDN;
    wstring         m_strDownLevelName;
    SID_NAME_USE    m_sne;
};

///////////////////////////////////////////////////////////////////////////////
// Important note:  m_pAllowedAce is used to refer to the Header and Mask fields.
// This allows most operations because the fields are always in the same place for
// all the structs below.  For anything else, one of the other members of the 
// union must be used, depending on the m_AceType.
class ACE_SAMNAME 
{
public:
    ACE_SAMNAME () : 
        m_AceType (0),
        m_pAllowedAce (0)
    {
    }

	void DebugOut () const;
	bool IsInherited () const;
    BOOL operator==(const ACE_SAMNAME& rAceSAMName) const;
    BOOL IsEquivalent (ACE_SAMNAME& rAceSAMName, ACCESS_MASK accessMask);
    BYTE                        m_AceType;
    union {
        PACCESS_ALLOWED_ACE         m_pAllowedAce;
        PACCESS_ALLOWED_OBJECT_ACE  m_pAllowedObjectAce;
        PACCESS_DENIED_ACE          m_pDeniedAce;
        PACCESS_DENIED_OBJECT_ACE   m_pDeniedObjectAce;
        PSYSTEM_AUDIT_ACE           m_pSystemAuditAce;
        PSYSTEM_AUDIT_OBJECT_ACE    m_pSystemAuditObjectAce;
    };
    wstring                     m_SAMAccountName;
    wstring                     m_strObjectGUID;
    wstring                     m_strInheritedObjectGUID;
};


typedef list<ACE_SAMNAME*>  ACE_SAMNAME_LIST;

typedef list<PSID_FQDN*> PSID_FQDN_LIST;

class SAMNAME_SD {
public:
    SAMNAME_SD (const wstring& upn, PSECURITY_DESCRIPTOR pSecurityDescriptor)
    {
        m_upn = upn;
        m_pSecurityDescriptor = pSecurityDescriptor;
    }
    virtual ~SAMNAME_SD ()
    {
        if ( m_pSecurityDescriptor )
            ::LocalFree (m_pSecurityDescriptor);
    }
    wstring                 m_upn;
    PSECURITY_DESCRIPTOR    m_pSecurityDescriptor;
    ACE_SAMNAME_LIST          m_DACLList;
    ACE_SAMNAME_LIST          m_SACLList;
};


typedef enum {
    GUID_TYPE_UNKNOWN = -1,
    GUID_TYPE_CLASS = 0,
    GUID_TYPE_ATTRIBUTE,
    GUID_TYPE_CONTROL
} GUID_TYPE;

class CACLDiagComModule : public CComModule
{
public:
    CACLDiagComModule();

    virtual ~CACLDiagComModule ();

	HRESULT Init ();

    void SetObjectDN (const wstring& objectDN)
    {
        // strip quotes, if present
        m_strObjectDN = objectDN;
        StripQuotes (m_strObjectDN);
    }

    wstring GetObjectDN () const { return m_strObjectDN;}

    bool DoSchema () const { return m_bDoSchema;}
    void SetDoSchema () { m_bDoSchema = true;}

    bool CheckDelegation () const { return m_bDoCheckDelegation;}
    void SetCheckDelegation () { m_bDoCheckDelegation = true;}
    void TurnOffFixDelegation() { m_bDoFixDelegation = false;}
    bool FixDelegation () const { return m_bDoFixDelegation;}
    void SetFixDelegation () { m_bDoFixDelegation = true;}

    bool DoGetEffective () const { return m_bDoGetEffective;}
    void SetDoGetEffective (const wstring& strUserGroupDN) 
    { 
        // strip quotes, if present
        m_strUserGroupDN = strUserGroupDN;
        StripQuotes (m_strUserGroupDN);
        m_bDoGetEffective = true;
    }
    wstring GetEffectiveRightsPrincipal() const { return m_strUserGroupDN;}

    void SetTabDelimitedOutput () { m_bTabDelimitedOutput = true;}
    bool DoTabDelimitedOutput () const { return m_bTabDelimitedOutput;}

    void SetSkipDescription () { m_bSkipDescription = true;}
    bool SkipDescription () const { return m_bSkipDescription;}

    HRESULT GetClassFromGUID (REFGUID rGuid, wstring& strClassName, GUID_TYPE* pGuidType = 0);

    static HRESULT IsUserAdministrator (BOOL & bIsAdministrator);
    static bool IsWindowsNT();

    void SetDoLog(const wstring &strPath)
    {
        m_bLogErrors = true;
        m_strLogPath = strPath;
    }
    bool DoLog () const { return m_bLogErrors;}
    wstring GetLogPath () const { return m_strLogPath;};

public:    
    // SD of m_strObjectDN
    PSECURITY_DESCRIPTOR    m_pSecurityDescriptor;
    PSID_FQDN_LIST       m_PSIDList;    // SIDs of interest: the owner, the SACL, the DACL

    // DACL and SACL of m_strObjectDN
    ACE_SAMNAME_LIST        m_DACLList;
    ACE_SAMNAME_LIST        m_SACLList;

    // SDs and DACLs for all the parents of m_strObjectDN
    list<SAMNAME_SD*>       m_listOfParentSDs;

    // List of all known classes and properties, with their GUIDs
    CGrowableArr<CSchemaClassInfo>   m_classInfoArray;
    CGrowableArr<CSchemaClassInfo>   m_attrInfoArray;

    CACLAdsiObject m_adsiObject;

private:
	bool m_bSkipDescription;
	wstring m_strLogPath;
    HANDLE      m_hPrivToken;
    wstring     m_strObjectDN;
    wstring     m_strUserGroupDN;
    bool        m_bDoSchema;
    bool        m_bDoCheckDelegation;
    bool        m_bDoGetEffective;
    bool        m_bDoFixDelegation;
    bool        m_bTabDelimitedOutput;
    bool        m_bLogErrors;
};

extern CACLDiagComModule _Module;


VOID LocalFreeStringW(LPWSTR* ppString);
HRESULT GetNameFromSid (PSID pSid, wstring& strPrincipalName, wstring* pstrFQDN, SID_NAME_USE& sne);


int MyWprintf( const wchar_t *format, ... );


#endif __ACLDIAG_ADUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\effright.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       EffRight.cpp
//
//  Contents:   Effective Rights Diagnosis and support methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "adutils.h"
#include "EffRight.h"
#include "AccessCk.h"
#include "SecDesc.h"

// Classes
#pragma warning (disable : 4127)

class CResultObject
{
public:
    CResultObject (
            ACCESS_MASK accessBit, 
            const wstring& strResult, 
            GUID_TYPE guidType,
            USHORT level);
    ~CResultObject () {}

    bool operator== (CResultObject& rResultObject)
    {
        if ( m_accessBit == rResultObject.m_accessBit )
            return true;
        else
            return false;
    }
    bool operator< (CResultObject& rResultObject)
    {
        if ( 0 == m_level )
            return true;

        if ( m_accessBit < rResultObject.m_accessBit )
        {
            return true;
        }
        else
            return false;
    }

    const CResultObject& operator= (const CResultObject& obj)
    {
        UNREFERENCED_PARAMETER (obj);
        ASSERT (0);
    }

    void PrintResult ()
    {
        MyWprintf (m_strResult.c_str ());
    }

    ACCESS_MASK GetRight () const
    {
        return m_accessBit;
    }

    bool IsValid () const
    {
        return m_bIsValid;
    }

    USHORT GetLevel () const
    {
        return m_level;
    }

private:
    const wstring     m_strResult;
    const ACCESS_MASK m_accessBit;
    const GUID_TYPE   m_guidType;
    bool              m_bIsValid;
    const USHORT      m_level;
};

CResultObject::CResultObject (
        ACCESS_MASK accessBit, 
        const wstring& strResult, 
        GUID_TYPE guidType,
        USHORT level) :
    m_accessBit (accessBit),
    m_strResult (strResult),
    m_guidType (guidType),
    m_bIsValid (true),
    m_level (level)
{

//    case ACTRL_DS_LIST:
//    case ACTRL_DELETE:
//    case ACTRL_CHANGE_ACCESS:
//    case ACTRL_CHANGE_OWNER:
//    case ACTRL_DS_LIST_OBJECT:
//    case ACTRL_DS_SELF:

    switch (guidType)
    {
    case GUID_TYPE_CLASS:
        ASSERT (0 == m_level);
        switch (accessBit)
        {
        case ACTRL_DS_CREATE_CHILD:
        case ACTRL_DS_DELETE_CHILD:
        case ACTRL_DS_READ_PROP:         // all
        case ACTRL_DS_WRITE_PROP:       // all
        case ACTRL_DS_LIST:
        case ACTRL_DS_LIST_OBJECT:
        case ACTRL_DS_CONTROL_ACCESS:   // all
        case ACTRL_DS_SELF:
            break;

        default:
            m_bIsValid = false;
            break;
        }
        break;

    case GUID_TYPE_ATTRIBUTE:
        ASSERT (0 != m_level);
        switch (accessBit)
        {
        case ACTRL_DS_READ_PROP:
        case ACTRL_DS_WRITE_PROP:
            break;

        case ACTRL_DS_CREATE_CHILD:
        case ACTRL_DS_DELETE_CHILD:
        case ACTRL_DS_CONTROL_ACCESS:
            m_bIsValid = false;
            break;
        
        default:
            m_bIsValid = false;
            break;
        }
        break;

        break;

    case GUID_TYPE_CONTROL:
        ASSERT (0 != m_level);
        switch (accessBit)
        {
        case ACTRL_DS_CONTROL_ACCESS:
        case ACTRL_DS_CREATE_CHILD:
        case ACTRL_DS_DELETE_CHILD:
            m_bIsValid = false;
            break;

        case ACTRL_DS_READ_PROP:
        case ACTRL_DS_WRITE_PROP:
        case ACTRL_READ_CONTROL:
        default:
            m_bIsValid = false;
            break;
        }
        break;

    default:
        ASSERT (FALSE);
        break;
    }
}

typedef CResultObject* PCResultObject;

bool compare_resultObject (PCResultObject& obj1, PCResultObject& obj2)
{
    return (*obj1) < (*obj2);
}


//
//  Function Prototypes
//

HRESULT GetFQDN (
            PSID_FQDN* pPsidFQDN, 
            wstring& strFQDN);
HRESULT GetDownlevelName (
            PSID_FQDN* pPsidFQDN, 
            wstring& strDownlevelName);
HRESULT ProcessObject (
            const wstring&      strObjectDN, 
            POBJECT_TYPE_LIST   pObjectTypeList, 
            size_t              objectTypeListLength,
            PSID                principalSelfSid,
            const wstring&      strDownlevelName);
HRESULT GetTokenGroups (
            const wstring& strObjectDN, 
            list<PSID>& psidList);
HRESULT EnumerateEffectivePermissions (
            const wstring& strObjectDN, 
            const IOBJECT_TYPE_LIST& otl, 
            const P_TYPE ptype, 
            vector<PCResultObject>& resultList);
HRESULT DisplayEffectivePermission (
            const wstring& strObjectDN, 
            const IOBJECT_TYPE_LIST& otl,
            const ACCESS_MASK accessMask,
            const P_TYPE  ptype,
            const int strIDAll, 
            const int strIDParam, 
            const int strIDCDO,
            vector<PCResultObject>& resultList);
HRESULT DisplayEffectivePermission (
            const wstring& strObjectDN, 
            const IOBJECT_TYPE_LIST& otl,
            const ACCESS_MASK accessMask,
            const P_TYPE  ptype,
            const int strID,
            vector<PCResultObject>& resultList);
void PrintGroupProvenance (
            const ACCESS_MASK accessMask, 
            const IOBJECT_TYPE_LIST& otl,
            const P_TYPE  ptype,
            wstring& strProvenance);
void PrintEffectiveRightsHeader (
            ACCESS_MASK lastRight,
            USHORT level);

HRESULT EffectiveRightsDiagnosis ()
{
    _TRACE (1, L"Entering  EffectiveRightsDiagnosis\n");
    HRESULT hr = S_OK;

    wstring str;

    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_EFFECTIVE_RIGHTS_DIAGNOSIS);

        MyWprintf (str.c_str ());
    }

    POBJECT_TYPE_LIST   pObjectTypeList = 0;
    size_t              objectTypeListLength = 0;

    hr = _Module.m_adsiObject.BuildObjectTypeList (&pObjectTypeList, objectTypeListLength);

    if ( SUCCEEDED (hr) && SUCCEEDED (SepInit ()) )
    {
        PSID principalSelfSid = 0;
        hr = _Module.m_adsiObject.GetPrincipalSelfSid (principalSelfSid);
        if ( !wcscmp (_Module.GetEffectiveRightsPrincipal ().c_str (), L"*") )
        {
            for (PSID_FQDN_LIST::iterator itr = _Module.m_PSIDList.begin (); 
                       itr != _Module.m_PSIDList.end ();// && SUCCEEDED (hr); 
                       itr++)
            {
                wstring strDownlevelName;
                wstring strFQDN;

                hr = GetFQDN (*itr, strFQDN);
                if ( SUCCEEDED (hr) )
                {
                    hr = GetDownlevelName (*itr, strDownlevelName);
                    if ( SUCCEEDED (hr) )
                    {
                        hr = ProcessObject (strFQDN, pObjectTypeList, 
                                objectTypeListLength, principalSelfSid, 
                                strDownlevelName);
                    }
                }
            }
        }
        else
        {
            hr = ProcessObject (_Module.GetEffectiveRightsPrincipal (), 
                    pObjectTypeList, objectTypeListLength, principalSelfSid,
                    _Module.GetEffectiveRightsPrincipal ());
        }

        // Free memory allocated for Sid
        if ( principalSelfSid )
            CoTaskMemFree (principalSelfSid);

        // Free object type list array
        for (DWORD idx = 0; idx < objectTypeListLength; idx++)
        {
            CoTaskMemFree (pObjectTypeList[idx].ObjectType);
        }
        CoTaskMemFree (pObjectTypeList);

        SepCleanup ();
    }

   _TRACE (-1, L"Leaving EffectiveRightsDiagnosis: 0x%x\n", hr);
    return hr;
}

HRESULT GetDownlevelName (PSID_FQDN* pPsidFQDN, wstring& strDownlevelName)
{
    _TRACE (1, L"Entering  GetDownlevelName\n");
    HRESULT hr = S_OK;

    if ( pPsidFQDN )
    {
        switch (pPsidFQDN->m_sne)
        {
        case SidTypeUser:           // Indicates a user SID. 
        case SidTypeGroup:          // Indicates a group SID. 
        case SidTypeAlias:          // Indicates an alias SID. 
        case SidTypeWellKnownGroup: // Indicates an SID for a well-known group. 
        case SidTypeDomain:         // Indicates a domain SID. 
        case SidTypeDeletedAccount: // Indicates an SID for a deleted account. 
            strDownlevelName = pPsidFQDN->m_strDownLevelName;
            break;

        case SidTypeInvalid:        // Indicates an invalid SID. 
        case SidTypeUnknown:        // Indicates an unknown SID type. 
            hr = E_FAIL;
            break;

        default:
            hr = E_UNEXPECTED;
            break;
        }
    }
    else
        hr = E_POINTER;

   _TRACE (-1, L"Leaving GetDownlevelName: 0x%x\n", hr);
    return hr;
}

HRESULT GetFQDN (PSID_FQDN* pPsidFQDN, wstring& strFQDN)
{
    _TRACE (1, L"Entering  GetFQDN\n");
    HRESULT hr = S_OK;

    if ( pPsidFQDN )
    {
        switch (pPsidFQDN->m_sne)
        {
        case SidTypeUser:           // Indicates a user SID. 
        case SidTypeGroup:          // Indicates a group SID. 
        case SidTypeAlias:          // Indicates an alias SID. 
        case SidTypeWellKnownGroup: // Indicates an SID for a well-known group. 
            strFQDN = pPsidFQDN->m_strFQDN;
            break;

        case SidTypeDomain:         // Indicates a domain SID. 
        case SidTypeDeletedAccount: // Indicates an SID for a deleted account. 
        case SidTypeInvalid:        // Indicates an invalid SID. 
        case SidTypeUnknown:        // Indicates an unknown SID type. 
            hr = E_FAIL;
            break;

        default:
            hr = E_UNEXPECTED;
            break;
        }
    }
    else
        hr = E_POINTER;

   _TRACE (-1, L"Leaving GetFQDN: 0x%x\n", hr);
    return hr;
}


HRESULT GetTokenGroups (const wstring& strObjectDN, list<PSID>& psidList)
{
    _TRACE (1, L"Entering  GetTokenGroups\n");
    HRESULT     hr = S_OK;

    
	CComPtr<IADsPathname> spPathname;
	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);
        hr = spPathname->put_EscapedMode (ADS_ESCAPEDMODE_OFF_EX );

        hr = spPathname->Set (const_cast <PWSTR> (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (
                    const_cast <PWSTR> (strObjectDN.c_str ()),
				    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
			    BSTR bstrFullPath = 0;
			    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
			    if ( SUCCEEDED (hr) )
			    {
				    CComPtr<IDirectoryObject> spDirObj;


				    hr = ADsGetObject (
			              bstrFullPath,
					      IID_PPV_ARG (IDirectoryObject, &spDirObj));
				    if ( SUCCEEDED (hr) )
				    {
                        {
                            //
                            // Get "objectSid" attribute
                            //
                            const PWSTR     wzAllowedAttributes = L"objectSid";
                            PADS_ATTR_INFO  pAttrs = 0;
                            DWORD           cAttrs = 0;
                            LPWSTR          rgpwzAttrNames[] = {wzAllowedAttributes};

                            hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                            if ( SUCCEEDED (hr) )
                            {
                                if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                {
                                    for (DWORD  dwIdx = 0; dwIdx < pAttrs->dwNumValues; dwIdx++)
                                    {
                                        PSID    pSid = pAttrs->pADsValues[dwIdx].OctetString.lpValue;
                                        if ( pSid && IsValidSid (pSid) )
                                        { 
                                            DWORD   dwSidLen = GetLengthSid (pSid);
                                            PSID    pSidCopy = CoTaskMemAlloc (dwSidLen);
                                            
                                            if ( pSidCopy )
                                            {
                                                if ( CopySid (dwSidLen, pSidCopy, pSid) )
                                                {
                                                    ASSERT (IsValidSid (pSidCopy));
                                                    psidList.push_back (pSidCopy);
                                                }
                                                else
                                                {
                                                    CoTaskMemFree (pSidCopy);
                                                    hr = GetLastError ();
                                                    _TRACE (0, L"CopySid () failed: 0x%x\n", hr);
                                                    break;
                                                }
                                            }
                                            else
                                            {
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if ( pAttrs )
                                    FreeADsMem (pAttrs);
                            }
                            else
                            {
                                _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                            }
                        }

                        if ( SUCCEEDED (hr) )
                        {
                            //
                            // Get "tokenGroups" attribute
                            //
                            const PWSTR     wzAllowedAttributes = L"tokenGroups";
                            PADS_ATTR_INFO  pAttrs = 0;
                            DWORD           cAttrs = 0;
                            LPWSTR          rgpwzAttrNames[] = {wzAllowedAttributes};

                            hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                            if ( SUCCEEDED (hr) )
                            {
                                if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                {
                                    for (DWORD  dwIdx = 0; dwIdx < pAttrs->dwNumValues; dwIdx++)
                                    {
                                        PSID    pSid = pAttrs->pADsValues[dwIdx].OctetString.lpValue;
                                        if ( pSid && IsValidSid (pSid) )
                                        { 
                                            DWORD   dwSidLen = GetLengthSid (pSid);
                                            PSID    pSidCopy = CoTaskMemAlloc (dwSidLen);
                                            
                                            if ( pSidCopy )
                                            {
                                                if ( CopySid (dwSidLen, pSidCopy, pSid) )
                                                {
                                                    ASSERT (IsValidSid (pSidCopy));
                                                    psidList.push_back (pSidCopy);
                                                }
                                                else
                                                {
                                                    CoTaskMemFree (pSidCopy);
                                                    hr = GetLastError ();
                                                    _TRACE (0, L"CopySid () failed: 0x%x\n", hr);
                                                    break;
                                                }
                                            }
                                            else
                                            {
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if ( pAttrs )
                                    FreeADsMem (pAttrs);
                            }
                            else
                            {
                                _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                            }
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath);
                      
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        strObjectDN.c_str (), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }

   _TRACE (-1, L"Leaving GetTokenGroups: 0x%x\n", hr);
    return hr;
}

HRESULT ProcessObject (
        const wstring&  strObjectDN,         // object having permissions on the 
                                            // target object
        POBJECT_TYPE_LIST pObjectTypeList,  // class, property and property set 
                                            // GUIDs of target object
        size_t          objectTypeListLength,// number of elements in pObjectTypeList
        PSID            principalSelfSid,
        const wstring&  strDownlevelName)
{
    _TRACE (1, L"Entering  ProcessObject\n");
    HRESULT     hr = S_OK;
    list<PSID>  psidList;   // sid of strObjectDN and all groups of which it is a member


    hr = GetTokenGroups (strObjectDN, psidList);
    if ( SUCCEEDED (hr) )
    {
        PACL    pDacl = 0;
        BOOL    bDaclPresent = FALSE;
        BOOL    bDaclDefaulted = FALSE;

        if ( GetSecurityDescriptorDacl (_Module.m_pSecurityDescriptor,
                &bDaclPresent, &pDacl, &bDaclDefaulted) )
        {
            PIOBJECT_TYPE_LIST LocalTypeList = 0;
            //
            // Capture any Object type list
            //

            NTSTATUS    Status = SeCaptureObjectTypeList( pObjectTypeList,
                                              objectTypeListLength,
                                              &LocalTypeList);

            if ( NT_SUCCESS(Status) ) 
            {
                hr = SepMaximumAccessCheck (psidList,
                        pDacl,
                        principalSelfSid,
                        objectTypeListLength,
                        LocalTypeList,
                        objectTypeListLength);

                if ( !_Module.DoTabDelimitedOutput () )
                {
                    wstring str;

                    FormatMessage (str, L"\n%1:\n\n", strDownlevelName.c_str ());
                    MyWprintf (str.c_str ());
                }

                vector<PCResultObject> resultList;

                for (DWORD idx = 0; idx < objectTypeListLength; idx++)
                {
                    EnumerateEffectivePermissions (strDownlevelName, 
                            LocalTypeList[idx], P_ALLOW, resultList);
                    EnumerateEffectivePermissions (strDownlevelName, 
                            LocalTypeList[idx], P_DENY, resultList);
                }

                // Sort LocalTypeList
                // 1. Object Level Rights
                // 2. Property Level Rights
                //      a. Create
                //      b. Delete
                //      c. Read
                //      d. Write
                // 3. Control Rights
                sort (resultList.begin (), resultList.end (), compare_resultObject);
                ACCESS_MASK lastRight = 0;

                for (vector<PCResultObject>::iterator itr = resultList.begin ();
                        itr != resultList.end (); itr++)
                {
                    PCResultObject pResultObject = *itr;

                    if ( lastRight != pResultObject->GetRight () )
                    {
                        lastRight = pResultObject->GetRight ();
                        if ( !_Module.DoTabDelimitedOutput () )
                            PrintEffectiveRightsHeader (lastRight, pResultObject->GetLevel ());
                    }
                    pResultObject->PrintResult ();
                    delete pResultObject;
                }
            }

            if ( LocalTypeList )
                delete [] LocalTypeList;
        }

        // Free memory pointed to by psidList members
        for (list<PSID>::iterator itr = psidList.begin (); 
                itr != psidList.end (); 
                itr++) 
        {
            CoTaskMemFree (*itr);
        }
    }

   _TRACE (-1, L"Leaving ProcessObject: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     EnumerateEffectivePermissions ()
//
//  Purpose:    Print all the permissions contained on the passed in ACE
//
//  Inputs:     otl - structure containing the ACE whose permissions we wish
//              to print
//
//              ptype - allow, deny, succes, failure, success and failure
//
HRESULT EnumerateEffectivePermissions (
        const wstring& strObjectDN, 
        const IOBJECT_TYPE_LIST& otl, 
        const P_TYPE ptype, 
        vector<PCResultObject>& resultList)
{
    HRESULT hr = S_OK;

    hr = DisplayEffectivePermission (strObjectDN,
            otl,
            ACTRL_DS_CREATE_CHILD, 
            ptype,
            IDS_CREATE_ALL_SUBOBJECTS_ER,
            IDS_CREATE_CLASS_OBJECTS_ER,
            IDS_CREATE_CLASS_OBJECTS,
            resultList);
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_DELETE_CHILD,
                ptype,
                IDS_DELETE_ALL_SUBOBJECTS_ER,
                IDS_DELETE_CLASS_OBJECTS_ER,
                IDS_DELETE_CLASS_OBJECTS,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_READ_PROP,
                ptype,
                IDS_READ_ALL_PROPERTIES_ER,
                IDS_READ_PROPERTY_PROPERTY_ER,
                IDS_READ_PROPERTY_PROPERTY,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_WRITE_PROP,
                ptype,
                IDS_WRITE_ALL_PROPERTIES_ER,
                IDS_WRITE_PROPERTY_PROPERTY_ER,
                IDS_WRITE_PROPERTY_PROPERTY,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl, 
                ACTRL_DS_LIST, 
                ptype,
                IDS_LIST_CONTENTS_ER, 
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_LIST_OBJECT,
                ptype,
                IDS_LIST_OBJECT_ER,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        if ( otl.CurrentGranted & ACTRL_DS_CONTROL_ACCESS )
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_CONTROL_ACCESS,
                ptype,
                IDS_ALL_CONTROL_ACCESSES_ER,
                IDS_CONTROL_ACCESS_DISPLAY_NAME,
                IDS_CONTROL_ACCESS_DISPLAY_NAME,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DELETE,
                ptype,
                IDS_DELETE_THIS_OBJECT_ER,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_READ_CONTROL,
                ptype,
                IDS_READ_PERMISSIONS_ER, 
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_CHANGE_ACCESS,
                ptype,
                IDS_MODIFY_PERMISSIONS_ER, 
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_CHANGE_OWNER,
                ptype,
                IDS_TAKE_CHANGE_OWNERSHIP_ER, 
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_SELF,
                ptype,
                IDS_MODIFY_MEMBERSHIP_ER, 
                resultList);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     DisplayEffectivePermission ()
//
//  Purpose:    Print an OBJECT_ACE_TYPE permission
//
//  Inputs:     otl - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
//              bAllow - whether the permission is allowed or denied
//
//              strIDAll - string to print if permission applies to all object 
//              classes
//
//              strIDParam - string print if permission applies to a specific
//              object class
//
HRESULT DisplayEffectivePermission (const wstring& strObjectDN, 
        const IOBJECT_TYPE_LIST& otl,
        const ACCESS_MASK accessMask,
        const P_TYPE  ptype,
        const int strIDAll, 
        const int strIDParam, 
        const int strIDCDO,
        vector<PCResultObject>& resultList)
{
    HRESULT hr = S_OK;

    wstring str;
    wstring strPermission;


    if ( ((P_ALLOW == ptype) && (otl.CurrentGranted & accessMask)) ||
            ((P_DENY == ptype) && (otl.CurrentDenied & accessMask)) )
    {
        wstring strGuidResult;
        GUID_TYPE   guidType = GUID_TYPE_UNKNOWN;

        _Module.GetClassFromGUID (otl.ObjectType, strGuidResult, &guidType);

        switch (guidType)
        {
        case GUID_TYPE_CLASS:
            FormatMessage (strPermission, strIDAll, strGuidResult.c_str ());
            break;

        case GUID_TYPE_ATTRIBUTE:
            switch (accessMask)
            {
            case ACTRL_DS_LIST:
            case ACTRL_DS_LIST_OBJECT:
            case ACTRL_DS_SELF:
//            case ACTRL_DS_CONTROL_ACCESS:
                return S_OK;

            default:
                if ( _Module.DoTabDelimitedOutput () )
                    FormatMessage (strPermission, strIDCDO, strGuidResult.c_str ());
                else
                    FormatMessage (strPermission, strIDParam, strGuidResult.c_str ());
                break;
            }
            break;

        case GUID_TYPE_CONTROL:
            switch (accessMask)
            {
            case ACTRL_DS_LIST:
            case ACTRL_DS_LIST_OBJECT:
            case ACTRL_DS_SELF:
            case ACTRL_DS_CREATE_CHILD:
            case ACTRL_DS_DELETE_CHILD:
            case ACTRL_DELETE:
            case ACTRL_CHANGE_ACCESS:
            case ACTRL_CHANGE_OWNER:
            case ACTRL_DS_CONTROL_ACCESS:
                return S_OK;

            case ACTRL_DS_READ_PROP:
            case ACTRL_DS_WRITE_PROP:
            case ACTRL_READ_CONTROL:
            default:
                FormatMessage (strPermission, strIDParam, strGuidResult.c_str ());
                break;
            }
            break;

        case GUID_TYPE_UNKNOWN:
        default:
            return E_UNEXPECTED;
        }


        int strid = 0;

        switch (ptype)
        {
        case P_ALLOW:
            if ( _Module.DoTabDelimitedOutput () )
                strid = IDS_CAN_CDO;
            else
                strid = IDS_CAN_ER;
            break;

        case P_DENY:
            if ( _Module.DoTabDelimitedOutput () )
                strid = IDS_CANNOT_CDO;
            else
                strid = IDS_CANNOT_EF;
            break;

        default:
            return E_UNEXPECTED;
        }
        if ( _Module.DoTabDelimitedOutput () )
        {
            FormatMessage (str, strid, 
                    strObjectDN.c_str (),
                    strPermission.c_str ());
        }
        else
        {
            FormatMessage (str, strid, 
                    strPermission.c_str ());
        }

        wstring strProvenance;

        PrintGroupProvenance (accessMask, otl, ptype, strProvenance);
        str += strProvenance;

        PCResultObject pResultObject = new CResultObject (accessMask, str, 
                guidType, otl.Level);
        if ( pResultObject )
        {
            if ( pResultObject->IsValid () )
                resultList.push_back (pResultObject);
            else
                delete pResultObject;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     DisplayEffectivePermission ()
//
//  Purpose:    Print a non-OBJECT_ACE_TYPE permission
//
//  Inputs:     otl - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
//              bAllow - whether the permission is allowed or denied
//
//              strID - string to print
//
HRESULT DisplayEffectivePermission (
        const wstring& strObjectDN, 
        const IOBJECT_TYPE_LIST& otl,
        const ACCESS_MASK accessMask,
        const P_TYPE  ptype,
        const int strID,
        vector<PCResultObject>& resultList)
{
    HRESULT     hr = S_OK;
    wstring     str;
    wstring     strPermission;


    if ( ((P_ALLOW == ptype) && (otl.CurrentGranted & accessMask)) ||
            ((P_DENY == ptype) && (otl.CurrentDenied & accessMask)) )
    {
        wstring strGuidResult;
        GUID_TYPE   guidType = GUID_TYPE_UNKNOWN;
        wstring strType;

        _Module.GetClassFromGUID (otl.ObjectType, strGuidResult, &guidType);

        switch (guidType)
        {
        case GUID_TYPE_CLASS:
            LoadFromResource (strType, IDS_CLASS);
            break;

        case GUID_TYPE_ATTRIBUTE:
            switch (accessMask)
            {
            case ACTRL_DS_LIST:
            case ACTRL_DS_LIST_OBJECT:
            case ACTRL_DS_SELF:
                return S_OK;

            default:
                LoadFromResource (strType, IDS_PROPERTY);
                break;
            }
            break;

        case GUID_TYPE_CONTROL:
            switch (accessMask)
            {
            case ACTRL_DS_LIST:
            case ACTRL_DS_LIST_OBJECT:
            case ACTRL_DS_SELF:
            case ACTRL_DS_CREATE_CHILD:
            case ACTRL_DS_DELETE_CHILD:
            case ACTRL_DELETE:
            case ACTRL_CHANGE_ACCESS:
            case ACTRL_CHANGE_OWNER:
            case ACTRL_DS_CONTROL_ACCESS:
                return S_OK;

            case ACTRL_DS_READ_PROP:
            case ACTRL_DS_WRITE_PROP:
            case ACTRL_READ_CONTROL:
            default:
                LoadFromResource (strType, IDS_CONTROL);
                break;
            }
            break;

        case GUID_TYPE_UNKNOWN:
        default:
            return E_UNEXPECTED;
        }

        LoadFromResource (strPermission, strID);

        int id = 0;
        switch (ptype)
        {
        case P_ALLOW:
            if ( _Module.DoTabDelimitedOutput () )
                id = IDS_CAN_CDO;
            else
                id = IDS_CAN;
            break;

        case P_DENY:
            if ( _Module.DoTabDelimitedOutput () )
                id = IDS_CANNOT_CDO;
            else
                id = IDS_CANNOT_EF;
            break;

        default:
            return E_UNEXPECTED;
        }
        if ( _Module.DoTabDelimitedOutput () )
        {
            FormatMessage (str, id, 
                    strObjectDN.c_str (),
                    strPermission.c_str ());
        }
        else
        {
            FormatMessage (str, id,	strPermission.c_str ());
        }

        wstring strProvenance;

        PrintGroupProvenance (accessMask, otl, ptype, strProvenance);
        str += strProvenance;

        PCResultObject pResultObject = new CResultObject (accessMask, str, 
                guidType, otl.Level);
        if ( pResultObject )
        {
            if ( pResultObject->IsValid () )
                resultList.push_back (pResultObject);
            else
                delete pResultObject;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


void PrintGroupProvenance (
        const ACCESS_MASK accessMask, 
        const IOBJECT_TYPE_LIST& otl,
        const P_TYPE ptype,
        wstring& strProvenance)
{
    UINT    nSid = 0;

    for (ULONG nBit = 0x1; nBit; nBit <<= 1, nSid++)
    {
        if ( accessMask & nBit )
        {
            wstring strGroup;
            PSID            psid = 0;
            SID_NAME_USE    sne = SidTypeUnknown;

            if ( P_ALLOW == ptype )
                psid = otl.grantingSid[nSid];
            else
                psid = otl.denyingSid[nSid];
            
            if ( IsValidSid (psid) )
            {
                GetNameFromSid (psid, strGroup, 0, sne);
                if ( SidTypeGroup == sne )
                {
                    if ( _Module.DoTabDelimitedOutput () )
                        FormatMessage (strProvenance, IDS_EFFRIGHT_FROM_GROUP_CDO, strGroup.c_str ());
                    else
                        FormatMessage (strProvenance, IDS_EFFRIGHT_FROM_GROUP, strGroup.c_str ());
                }
            }
            break;
        }
    }
    strProvenance += L"\n";
}


void PrintEffectiveRightsHeader (ACCESS_MASK lastRight, USHORT level)
{
    wstring str;


    if ( 0 == level ) // Object level rights
    {
        return;
    }
    else
    {
        switch (lastRight)
        {
        case ACTRL_DS_LIST:
        case ACTRL_DELETE:
        case ACTRL_READ_CONTROL:
        case ACTRL_CHANGE_ACCESS:
        case ACTRL_CHANGE_OWNER:
            str = L"\n\n";
            break;
        
        case ACTRL_DS_CREATE_CHILD:
            LoadFromResource (str, IDS_CAN_CREATE_FOLLOWING_CHILD_OBJECTS);
            break;

        case ACTRL_DS_DELETE_CHILD:
            LoadFromResource (str, IDS_CAN_DELETE_FOLLOWING_CHILD_OBJECTS);
            break;

        case ACTRL_DS_READ_PROP:
            LoadFromResource (str, IDS_CAN_READ_FOLLOWING_PROPERTIES);
            break;

        case ACTRL_DS_WRITE_PROP:
            LoadFromResource (str, IDS_CAN_WRITE_FOLLOWING_PROPERTIES);
            break;

        case ACTRL_DS_CONTROL_ACCESS:
            LoadFromResource (str, IDS_CAN_DO_FOLLOWING_CONTROL_OPERATIONS);
            break;

        case ACTRL_DS_LIST_OBJECT:
        case ACTRL_DS_SELF:
        default:
            str = L"\n\n";
            break;;
        }
    }

    MyWprintf (str.c_str ());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\makefile.inc ===
!include ..\..\makefile.inc

$(O)\ACLDIAG.res: resource.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\effright.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       EffRight.h
//
//  Contents:   Effective Rights Diagnosis and support methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_EFFRIGHT_H
#define __ACLDIAG_EFFRIGHT_H

#include "stdafx.h"


HRESULT EffectiveRightsDiagnosis ();

#endif //__ACLDIAG_EFFRIGHT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ACLDiag.rc
//
#define IDS_BAD_CL_SYNTAX               1
#define IDS_BAD_CL_SYNTAX_NO_CLOSE_QUOTE 2
#define IDS_SECURITY_DIAGNOSIS_FOR      3
#define IDS_DESCRIPTION                 4
#define IDS_INVALID_OBJECT              5
#define IDS_OWNER                       6
#define IDS_CONFIG_NO_INHERIT           7
#define IDS_ALLOW                       8
#define IDS_DENY                        9
#define IDS_PERMISSIONS_EFFECTIVE       10
#define IDS_CREATE_ALL_SUBOBJECTS       11
#define IDS_CREATE_CLASS_OBJECTS        12
#define IDS_DELETE_ALL_SUBOBJECTS       13
#define IDS_DELETE_CLASS_OBJECTS        14
#define IDS_READ_ALL_PROPERTIES         15
#define IDS_READ_PROPERTY_PROPERTY      16
#define IDS_WRITE_ALL_PROPERTIES        17
#define IDS_WRITE_PROPERTY_PROPERTY     18
#define IDS_LIST_CONTENTS               19
#define IDS_LIST_OBJECT                 20
#define IDS_DELETE_TREE                 21
#define IDS_ALL_CONTROL_ACCESSES        22
#define IDS_CONTROL_ACCESS_DISPLAY_NAME 23
#define IDS_DELETE_THIS_OBJECT          24
#define IDS_READ_PERMISSIONS            25
#define IDS_TAKE_CHANGE_OWNERSHIP       26
#define IDS_MODIFY_PERMISSIONS          27
#define IDS_MODIFY_MEMBERSHIP           28
#define IDS_INHERITED_PERMISSION        29
#define IDS_DELEGWIZ_READ_PROPERTY      30
#define IDS_DELEGWIZ_WRITE_PROPERTY     31
#define IDS_DELEGWIZ_CREATE_CLASS       32
#define IDS_DELEGWIZ_DELETE_CLASS       33
#define IDS_PERMISSIONS_INHERITED_BY_SUBOBJECTS 34
#define IDS_INHERIT_TO_ALL_SUBOBJECTS   35
#define IDS_INHERIT_TO_X_OBJECTS_ONLY   36
#define IDS_AUDITING_EFFECTIVE_ON_THIS_OBJECT 37
#define IDS_SCHEMA_DEFAULTS_DIAGNOSIS   38
#define IDS_SCHEMA_DEFAULTS             39
#define IDS_OBTAINED                    40
#define IDS_ABSENT                      41
#define IDS_PRESENT                     42
#define IDS_PARTIAL                     43
#define IDS_AT_CREATION                 44
#define IDS_BY_INHERITANCE              45
#define IDS_SUCCESS                     46
#define IDS_FAILURE                     47
#define IDS_SUCCESS_AND_FAILURE         48
#define IDS_AUDITING_INHERITED_TO_SUBOBJECTS 49
#define IDS_COULD_NOT_VALIDATE_USER_CREDENTIALS 50
#define IDS_USER_MUST_BE_ADMINISTRATOR  51
#define IDS_UNKNOWN_PARENT              52
#define IDS_HELP_MAIN                   53
#define IDS_ADS_BAD_PATHNAME            54
#define IDS_INVALID_OPTION              55
#define IDS_HELP_SCHEMA                 56
#define IDS_HELP_CHKDELEG               57
#define IDS_HELP_GETEFFECTIVE           58
#define IDS_HELP_CDO                    59
#define IDS_UNABLE_TO_READ_SECURITY_DESCRIPTOR 60
#define IDS_DELEGWIZ_FINISH_TEMPLATE    61
#define IDS_DELEGWIZ_FINISH_PRINCIPALS  62
#define IDS_DELEGWIZ_ERR_OBJ_PEC_PERM   63
#define IDS_DELEGWIZ_FULL_CONTROL       64
#define IDS_DELEGWIZ_FINISH_PERMISSIONS 65
#define IDS_DELEGWIZ_RW_PROPERTYSET     66
#define IDS_DELEGWIZ_ACTRL_FULL         67
#define IDS_DELEGWIZ_ACTRL_READ         68
#define IDS_DELEGWIZ_ACTRL_WRITE        69
#define IDS_DELEGWIZ_ACTRL_DS_CREATE_CHILD 70
#define IDS_DELEGWIZ_ACTRL_DS_DELETE_CHILD 71
#define IDS_DELEGATION_TEMPLATE_DIAGNOSIS 72
#define IDS_DELTEMPL_STATUS             73
#define IDS_OK                          74
#define IDS_NOT_PRESENT                 75
#define IDS_MISCONFIGURED               76
#define IDS_APPLIES_ON_THIS_OBJECT      77
#define IDS_INHERITED_FROM_PARENT       78
#define IDS_YES                         79
#define IDS_NO                          80
#define IDS_DELEGATION_TITLE            81
#define IDS_FIX_DELEGATION_QUERY        82
#define IDS_DELEGWIZ_ERR_SET_SEC_INFO   83
#define IDS_DELEGWIZ_ERR_GET_SEC_INFO   84
#define IDS_EFFECTIVE_RIGHTS_DIAGNOSIS  85
#define IDS_OWNER_CDO                   86
#define IDS_PERMISSIONS_PROTECTED       87
#define IDS_PERMISSIONS_NOT_PROTECTED   88
#define IDS_AUDITING_PROTECTED          89
#define IDS_AUDITING_NOT_PROTECTED      90
#define IDS_ALLOW_CDO                   91
#define IDS_DENY_CDO                    92
#define IDS_THIS_OBJECT                 93
#define IDS_ALL_SUBOBJECTS              94
#define IDS_SUCCESS_CDO                 95
#define IDS_FAILURE_CDO                 96
#define IDS_SUCCESS_AND_FAILURE_CDO     97
#define IDS_INHERITED_PERMISSION_CDO    98
#define IDS_CLASS_OBJECT                99
#define IDS_SCHEMA_DEFAULTS_CDO         100
#define IDS_OBTAINED_CDO                101
#define IDS_DELEGATION_TITLE_CDO        102
#define IDS_DELTEMPL_STATUS_CDO         103
#define IDS_APPLIES_ON_THIS_OBJECT_CDO  104
#define IDS_APPLIES                     105
#define IDS_DOES_NOT_APPLY              106
#define IDS_INHERITED_FROM_PARENT_CDO   107
#define IDS_EXPLICIT                    108
#define IDS_INHERITED                   109
#define IDS_DELEGATION_NOT_FOUND_CDO    110
#define IDS_HELP_LOG                    111
#define IDS_CAN                         112
#define IDS_CAN_CDO                     113
#define IDS_HELP_SKIP_DESCRIPTION       114
#define IDS_CREATE_ALL_SUBOBJECTS_ER    115
#define IDS_DELETE_ALL_SUBOBJECTS_ER    116
#define IDS_READ_ALL_PROPERTIES_ER      117
#define IDS_WRITE_ALL_PROPERTIES_ER     118
#define IDS_ALL_CONTROL_ACCESSES_ER     119
#define IDS_LIST_CONTENTS_ER            123
#define IDS_LIST_OBJECT_ER              124
#define IDS_READ_PERMISSIONS_ER         125
#define IDS_MODIFY_PERMISSIONS_ER       126
#define IDS_TAKE_CHANGE_OWNERSHIP_ER    127
#define IDS_MODIFY_MEMBERSHIP_ER        128
#define IDS_DELETE_THIS_OBJECT_ER       129
#define IDS_CLASS                       130
#define IDS_PROPERTY                    131
#define IDS_CONTROL                     132
#define IDS_CANNOT_EF                   133
#define IDS_CANNOT_CDO                  134
#define IDS_NO_SECDESC_RETURNED         135
#define IDS_NO_SECDESC_RETURNED_WITH_CODE 136
#define IDS_EFFRIGHT_FROM_GROUP         137
#define IDS_EFFRIGHT_FROM_GROUP_CDO     138
#define IDS_CAN_CREATE_FOLLOWING_CHILD_OBJECTS 139
#define IDS_CAN_DELETE_FOLLOWING_CHILD_OBJECTS 140
#define IDS_CAN_READ_FOLLOWING_PROPERTIES 141
#define IDS_CAN_WRITE_FOLLOWING_PROPERTIES 142
#define IDS_CAN_DO_FOLLOWING_CONTROL_OPERATIONS 143
#define IDS_CREATE_CLASS_OBJECTS_ER     144
#define IDS_DELETE_CLASS_OBJECTS_ER     145
#define IDS_READ_PROPERTY_PROPERTY_ER   146
#define IDS_WRITE_PROPERTY_PROPERTY_ER  147
#define IDS_CAN_ER                      148
#define IDS_FAILED_TO_LOAD_TEMPLATES    149
#define IDS_DELEGWIZ_ACTRL_DS_READ_PROP 150
#define IDS_DELEGWIZ_ACTRL_DS_WRITE_PROP 151
#define IDS_GENERATED_INHERITED_PERMISSION 152
#define IDS_GENERATED_INHERITED_PERMISSION_CDO 153

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\secdesc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       SecDesc.cpp
//
//  Contents:   DoSecurityDescription and support methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "ADUtils.h"
#include "SecDesc.h"



///////////////////////////////////////////////////////////////////////////////
//
//  Method:     DoSecurityDescription ()
//
//  Purpose:    Main routine for doing security description
//
//

HRESULT DoSecurityDescription ()
{
    _TRACE (1, L"Entering  DoSecurityDescription\n");
	HRESULT	hr = S_OK;

    wstring    str;

    // Print header
    if ( _Module.DoTabDelimitedOutput () )
    {
        MyWprintf (_Module.GetObjectDN ().c_str ());
        MyWprintf (L"\n");
    }
    else
    {
        FormatMessage (str, IDS_SECURITY_DIAGNOSIS_FOR, _Module.GetObjectDN ().c_str ());
        MyWprintf (str.c_str ());

        if ( !_Module.SkipDescription () )
        {
            LoadFromResource (str, IDS_DESCRIPTION);
            str += L"\n";
            MyWprintf (str.c_str ());
        }
    }

    hr = GetSecurityDescriptor (_Module.GetObjectDN (), &_Module.m_pSecurityDescriptor);
    if ( SUCCEEDED (hr) )
    {
        if ( _Module.m_pSecurityDescriptor )
        {
            hr = DisplayOwner ();
            if ( SUCCEEDED (hr) )
            {
                SECURITY_DESCRIPTOR_CONTROL control;
                DWORD                       dwRevision = 0;

                if ( GetSecurityDescriptorControl (
                        _Module.m_pSecurityDescriptor,
                        &control,
                        &dwRevision) )
                {
                    if ( _Module.DoTabDelimitedOutput () )
                    {
                        MyWprintf (L"\n");
                        if ( control & SE_DACL_PROTECTED )
                            LoadFromResource (str, IDS_PERMISSIONS_PROTECTED);
                        else
                            LoadFromResource (str, IDS_PERMISSIONS_NOT_PROTECTED);

                        MyWprintf (str.c_str ());

                        if ( control & SE_SACL_PROTECTED )
                            LoadFromResource (str, IDS_AUDITING_PROTECTED);
                        else
                            LoadFromResource (str, IDS_AUDITING_NOT_PROTECTED);
                        MyWprintf (str.c_str ());
                    }
                    else
                    {
                        if ( control & SE_DACL_PROTECTED )
                        {
                            LoadFromResource (str, IDS_CONFIG_NO_INHERIT);
                            MyWprintf (str.c_str ());
                        }
                    }

                }
                else
                {
                    _TRACE (0, L"GetSecurityDescriptorControl () failed: 0x%x\n", GetLastError ());
                }

                hr = EnumerateDacl (_Module.m_pSecurityDescriptor, _Module.m_DACLList, true);
                if ( SUCCEEDED (hr) )
                {
                    hr = EnumerateSacl (_Module.m_pSecurityDescriptor, _Module.m_SACLList);
                    if ( SUCCEEDED (hr) && !_Module.SkipDescription () )
                    {
                        hr = PrintEffectivePermissions ();
                        if ( SUCCEEDED (hr) )
                        {
                            hr = PrintInheritedPermissions ();
                            if ( SUCCEEDED (hr) )
                            {
                                hr = PrintAuditingInformation ();
                            }
                        }
                    }
                }
            }
        }
        else
        {
            hr = E_ACCESSDENIED;
            wstring str;
            FormatMessage (str, IDS_UNABLE_TO_READ_SECURITY_DESCRIPTOR, _Module.GetObjectDN ().c_str ());
            MyWprintf (str.c_str ());
        }
    }

    _TRACE (-1, L"Leaving DoSecurityDescription: 0x%x\n", hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     GetSecurityDescriptor ()
//
//  Purpose:    Get ths security descriptor for the indicated object
//
//  Inputs:     strObjectDN - the object show security descriptor we wish to 
//              retrieve
//
//  Outputs:    ppAttrs - returns the security descriptor raw data - this holds the data
//              persistent in memory
//
//              ppSecurityDescriptor - returns the security descriptor
//
HRESULT GetSecurityDescriptor (
        wstring strObjectDN,        // pass by value
        PSECURITY_DESCRIPTOR* ppSecurityDescriptor)
{
    _TRACE (1, L"Entering  GetSecurityDescriptor\n");
    HRESULT hr = S_OK;

    if ( ppSecurityDescriptor )
    {
	    CComPtr<IADsPathname> spPathname;
	    //
	    // Constructing the directory paths
	    //
	    hr = CoCreateInstance(
				    CLSID_Pathname,
				    NULL,
				    CLSCTX_ALL,
				    IID_PPV_ARG (IADsPathname, &spPathname));
	    if ( SUCCEEDED (hr) )
	    {
            ASSERT (!!spPathname);
            LPCWSTR pszLDAP = L"LDAP://";

            // If object name is preceded with LDAP, set the whole name at once.
            if ( !wcsncmp (strObjectDN.c_str (), pszLDAP, wcslen (pszLDAP)) )
            {
                hr = spPathname->Set (
                        const_cast <PWSTR> (strObjectDN.c_str ()),
					    ADS_SETTYPE_FULL);
                if ( FAILED (hr) )
                {
                    _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                            strObjectDN.c_str (), hr);
                }
            }
            else
            {
		        hr = spPathname->Set (const_cast <PWSTR> (ACLDIAG_LDAP),
	                    ADS_SETTYPE_PROVIDER);
		        if ( SUCCEEDED (hr) )
		        {
                    hr = spPathname->Set (
                            const_cast <PWSTR> (strObjectDN.c_str ()),
					        ADS_SETTYPE_DN);
                    if ( FAILED (hr) )
                    {
                        _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                                strObjectDN.c_str (), hr);
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
                }
            }

			if ( SUCCEEDED (hr) )
			{
				BSTR bstrFullPath = 0;
				hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				if ( SUCCEEDED (hr) )
				{
					CComPtr<IDirectoryObject> spDirObj;


					hr = ADsGetObject (
			              bstrFullPath,
						  IID_PPV_ARG (IDirectoryObject, &spDirObj));
					if ( SUCCEEDED (hr) )
					{
                        hr = SetSecurityInfoMask (spDirObj, 
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION |
                                SACL_SECURITY_INFORMATION);

                        //
                        // Get this object's Security Descriptor.
                        //
                        const PWSTR     wzSecDescriptor = L"nTSecurityDescriptor";
                        PADS_ATTR_INFO  pAttrs = 0;
                        DWORD           cAttrs = 0;
                        LPWSTR          rgpwzAttrNames[] = {wzSecDescriptor};

                        hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                        if ( SUCCEEDED (hr) )
                        {
                            if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                            {
                                if (!(pAttrs->pADsValues->SecurityDescriptor.lpValue) ||
                                    !(pAttrs->pADsValues->SecurityDescriptor.dwLength))
                                {
                                    _TRACE (0, L"IADS return bogus SD!\n");
                                    hr =  E_UNEXPECTED;
                                }
                                else if (!IsValidSecurityDescriptor(pAttrs->pADsValues->SecurityDescriptor.lpValue))
                                {
                                    _TRACE (0, L"IsValidSecurityDescriptor failed!\n");
                                    hr = HRESULT_FROM_WIN32(GetLastError());
                                }
                                else
                                {
                                    *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) 
                                            ::LocalAlloc (LMEM_ZEROINIT, pAttrs->pADsValues->SecurityDescriptor.dwLength);
                                    if ( *ppSecurityDescriptor )
                                    {
                                        memcpy (*ppSecurityDescriptor, 
                                                pAttrs->pADsValues->SecurityDescriptor.lpValue,
                                                pAttrs->pADsValues->SecurityDescriptor.dwLength);
                                    }
                                    else
                                        hr = E_OUTOFMEMORY;
                                }
                                FreeADsMem (pAttrs);
                            }
                            else
                            {
                                if ( !wcscmp (strObjectDN.c_str (), _Module.GetObjectDN ().c_str ()) )
                                {
                                    wstring str;

                                    FormatMessage (str, IDS_NO_SECDESC_RETURNED, strObjectDN.c_str ());
                                    MyWprintf (str.c_str ());
                                }
                            }
                        }
                        else
                        {
                            if ( !wcscmp (strObjectDN.c_str (), _Module.GetObjectDN ().c_str ()) )
                            {
                                wstring str;

                                FormatMessage (str, IDS_NO_SECDESC_RETURNED_WITH_CODE, 
                                        strObjectDN.c_str (), GetSystemMessage (hr));
                                MyWprintf (str.c_str ());
                            }
                            _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                        }
                    }
                    else
                    {
                        if ( ERROR_DS_REFERRAL == HRESULT_CODE (hr) )
                            hr = S_FALSE;
                        else
                        {
                            _TRACE (0, L"ADsGetObject (%s): 0x%x\n", bstrFullPath, hr);
                            wstring    strErr;
                   

                            FormatMessage (strErr, IDS_INVALID_OBJECT, 
                                    _Module.GetObjectDN ().c_str (), 
                                    GetSystemMessage (hr).c_str ());
                            MyWprintf (strErr.c_str ());
                        }
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                }
            }
        }
        else
        {
            _TRACE (0, L"CoCreateInstance(CLSID_Pathname): 0x%x\n", hr);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving GetSecurityDescriptor: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     DisplayOwner ()
//
//  Purpose:    Display the owner of this object
//
HRESULT DisplayOwner ()
{
    _TRACE (1, L"Entering  DisplayOwner\n");
    HRESULT hr = S_OK;
    PSID    pSidOwner = 0;
    BOOL    bOwnerDefaulted = FALSE;
    if ( ::GetSecurityDescriptorOwner(
            _Module.m_pSecurityDescriptor,
            &pSidOwner,
            &bOwnerDefaulted) )
    {
        wstring         strPrincipalName;
        wstring         strFQDN;
        SID_NAME_USE    sne = SidTypeUnknown;
            
        hr = GetNameFromSid (pSidOwner, strPrincipalName, &strFQDN, sne);
        if ( SUCCEEDED (hr) && !_Module.SkipDescription () )
        {
            wstring    str;

            if ( _Module.DoTabDelimitedOutput () )
                FormatMessage (str, IDS_OWNER_CDO, strPrincipalName.c_str ());
            else
                FormatMessage (str, IDS_OWNER, strPrincipalName.c_str ());
            MyWprintf (str.c_str ());
        }
        PSID_FQDN* pItem = new PSID_FQDN (pSidOwner, strFQDN, strPrincipalName, sne);
        if ( pItem )
            _Module.m_PSIDList.push_back (pItem);
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"GetSecurityDescriptorOwner () failed: 0x%x\n", 
                dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving DisplayOwner: 0x%x\n", hr);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     EnumerateDacl ()
//
//  Purpose:    Enumerate the DACL and store it in a list
//
//  Inputs:     pSecurityDescriptor - where to get the DACL
//
//  Outputs:    DACLList - return the ACEs in this list
//
HRESULT EnumerateDacl (PSECURITY_DESCRIPTOR pSecurityDescriptor, ACE_SAMNAME_LIST& DACLList, bool bListSids)
{
    _TRACE (1, L"Entering  EnumerateDacl\n");
    HRESULT hr = S_OK;


    PACL    pDacl = 0;
    BOOL    bDaclPresent = FALSE;
    BOOL    bDaclDefaulted = FALSE;
    if ( GetSecurityDescriptorDacl (pSecurityDescriptor,
            &bDaclPresent, &pDacl, &bDaclDefaulted) )
    {
        if ( bDaclPresent )
        {
            PACCESS_ALLOWED_ACE         pAllowedAce;
            PSID_FQDN_LIST::iterator    itrPSID = _Module.m_PSIDList.begin ();
            ACE_SAMNAME*                pAceSAMName = 0;
            PSID_FQDN*                  pPsidFQDN = 0;
            SID_NAME_USE                sne = SidTypeUnknown;

	        // copy the ACES
			for (int i = 0; i < pDacl->AceCount; i++)
			{
				if ( GetAce (pDacl, i, (void **)&pAllowedAce) )
                {
                    PSID AceSid = 0;
                    if ( IsObjectAceType ( pAllowedAce ) ) 
                    {
                        AceSid = RtlObjectAceSid( pAllowedAce );
                    } 
                    else 
                    {
                        AceSid = &( ( PKNOWN_ACE )pAllowedAce )->SidStart;
                    }
                    ASSERT (IsValidSid (AceSid));

                    wstring strPrincipalName;
                    wstring strFQDN;
                    hr = GetNameFromSid (AceSid, strPrincipalName, 
                            bListSids ? &strFQDN : 0, sne);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( bListSids )
                        {
                            bool bFound = false;
                            for (PSID_FQDN_LIST::iterator itrPSIDFind = _Module.m_PSIDList.begin ();
                                    itrPSIDFind != _Module.m_PSIDList.end ();
                                    itrPSIDFind++)
                            {
                                pPsidFQDN = *itrPSIDFind;
                                if ( pPsidFQDN )
                                {
                                    if ( !wcscmp (pPsidFQDN->m_strFQDN.c_str (), strFQDN.c_str ()) )
                                    {
                                        bFound = true;
                                    }
                                }
                            }

                            if ( !bFound )
                            {
                                pPsidFQDN = new PSID_FQDN (AceSid, strFQDN, strPrincipalName, sne);
                                if ( pPsidFQDN )
                                {
                                    _Module.m_PSIDList.push_back (pPsidFQDN);
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                    break;
                                }
                            }
                        }
                        pAceSAMName = new ACE_SAMNAME;
                        if ( pAceSAMName )
                        {
                            pAceSAMName->m_AceType = pAllowedAce->Header.AceType;
                            switch (pAceSAMName->m_AceType)
                            {
                            case ACCESS_ALLOWED_ACE_TYPE:
                                pAceSAMName->m_pAllowedAce = pAllowedAce;
                                break;

                            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                                pAceSAMName->m_pAllowedObjectAce = 
                                        reinterpret_cast <PACCESS_ALLOWED_OBJECT_ACE> (pAllowedAce);
                                break;

                            case ACCESS_DENIED_ACE_TYPE:
                                pAceSAMName->m_pDeniedAce = 
                                        reinterpret_cast <PACCESS_DENIED_ACE> (pAllowedAce);
                                break;

                            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                                pAceSAMName->m_pDeniedObjectAce = 
                                        reinterpret_cast <PACCESS_DENIED_OBJECT_ACE> (pAllowedAce);
                                break;

                            default:
                                break;
                            }
                            pAceSAMName->m_SAMAccountName = strPrincipalName;
                            pAceSAMName->DebugOut ();
                            DACLList.push_back (pAceSAMName);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }
                }
                else
                {
                    _TRACE (0, L"GetAce failed: 0x%x\n", GetLastError ());
                    break;
                }
			}
        }
    }
    else
    {
        _TRACE (0, L"GetSecurityDescriptorDacl () failed: 0x%x\n", GetLastError ());
    }

    _TRACE (-1, L"Leaving EnumerateDacl: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     EnumerateSacl ()
//
//  Purpose:    Enumerate the SACL and store it in a list
//
//  Inputs:     pSecurityDescriptor - where to get the DACL
//
//  Outputs:    The results are store in the _Module.m_SACLList
//
HRESULT EnumerateSacl (PSECURITY_DESCRIPTOR pSecurityDescriptor, ACE_SAMNAME_LIST& SACLList)
{
    _TRACE (1, L"Entering  EnumerateSacl\n");
    HRESULT hr = S_OK;

    PACL    pSacl = 0;
    BOOL    bSaclPresent = FALSE;
    BOOL    bSaclDefaulted = FALSE;
    if ( GetSecurityDescriptorSacl (pSecurityDescriptor,
            &bSaclPresent, &pSacl, &bSaclDefaulted) )
    {
        if ( bSaclPresent && pSacl )
        {
            PACCESS_ALLOWED_ACE         pAllowedAce;
            wstring                     strPrincipalName;
            wstring                     strFQDN;
            ACE_SAMNAME*                pAceSAMName = 0;
            SID_NAME_USE                sne = SidTypeUnknown;

	        // copy the ACES
			for (int i = 0; i < pSacl->AceCount; i++)
			{
				if ( GetAce (pSacl, i, (void **)&pAllowedAce) )
                {
                    PSID AceSid;
                    if ( IsObjectAceType ( pAllowedAce ) ) 
                    {
                        AceSid = RtlObjectAceSid( pAllowedAce );
                    } 
                    else 
                    {
                        AceSid = &( ( PKNOWN_ACE )pAllowedAce )->SidStart;
                    }
                    
                    hr = GetNameFromSid (AceSid, strPrincipalName, 0, sne);
                    if ( SUCCEEDED (hr) )
                    {
                        pAceSAMName = new ACE_SAMNAME;
                        if ( pAceSAMName )
                        {
                            pAceSAMName->m_AceType = pAllowedAce->Header.AceType;
                            switch (pAceSAMName->m_AceType)
                            {
                            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                                pAceSAMName->m_pSystemAuditObjectAce = 
                                        reinterpret_cast <PSYSTEM_AUDIT_OBJECT_ACE> (pAllowedAce);
                                break;

                            case SYSTEM_AUDIT_ACE_TYPE:
                                pAceSAMName->m_pSystemAuditAce = 
                                        reinterpret_cast <PSYSTEM_AUDIT_ACE> (pAllowedAce);
                                break;

                            default:
                                break;
                            }
                            pAceSAMName->m_SAMAccountName = strPrincipalName;
                            pAceSAMName->DebugOut ();
                            SACLList.push_back (pAceSAMName);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }
                }
                else
                {
                    _TRACE (0, L"GetAce failed: 0x%x\n", GetLastError ());
                    break;
                }
			}
        }
    }
    else
    {
        _TRACE (0, L"GetSecurityDescriptorSacl () failed: 0x%x\n", GetLastError ());
    }

    _TRACE (-1, L"Leaving EnumerateSacl: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintEffectivePermissions ()
//
//  Purpose:    Print the permissions effective on the object
//
HRESULT PrintEffectivePermissions ()
{
    HRESULT                     hr = S_OK;
    ACE_SAMNAME_LIST::iterator    itr =  _Module.m_DACLList.begin ();
    wstring                    str;
    ACE_SAMNAME*                    pAceSAMName = 0;


    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_PERMISSIONS_EFFECTIVE);
        MyWprintf (str.c_str ());
    }

    for (itr = _Module.m_DACLList.begin(); itr != _Module.m_DACLList.end(); itr++)
    {
        pAceSAMName = *itr;
        if ( !(pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERIT_ONLY_ACE) )
        {
            switch (pAceSAMName->m_AceType)
            {    
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                hr = EnumeratePermissions (pAceSAMName, P_ALLOW, P_THIS_OBJECT, L"");
                break;

            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
                hr = EnumeratePermissions (pAceSAMName, P_DENY, P_THIS_OBJECT, L"");
                break;

            default:
                break;
            }
        }
    }


    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     EnumeratePermissions ()
//
//  Purpose:    Print all the permissions contained on the passed in ACE
//
//  Inputs:     pAceSAMName - structure containing the ACE whose permissions we wish
//              to print
//
//              ptype - allow, deny, succes, failure, success and failure
//
HRESULT EnumeratePermissions (ACE_SAMNAME*  pAceSAMName, P_TYPE ptype, P_WHO pWho, PCWSTR pwszClassName)
{
    HRESULT hr = S_OK;

    if ( pAceSAMName )
    {
        hr = PrintPermission (pAceSAMName,
                ACTRL_DS_CREATE_CHILD, 
                ptype,
                IDS_CREATE_ALL_SUBOBJECTS,
                IDS_CREATE_CLASS_OBJECTS,
                pWho,
                pwszClassName);
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_DELETE_CHILD,
                    ptype,
                    IDS_DELETE_ALL_SUBOBJECTS,
                    IDS_DELETE_CLASS_OBJECTS,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_READ_PROP,
                    ptype,
                    IDS_READ_ALL_PROPERTIES,
                    IDS_READ_PROPERTY_PROPERTY,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_WRITE_PROP,
                    ptype,
                    IDS_WRITE_ALL_PROPERTIES,
                    IDS_WRITE_PROPERTY_PROPERTY,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName, 
                    ACTRL_DS_LIST, 
                    ptype,
                    IDS_LIST_CONTENTS, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_LIST_OBJECT,
                    ptype,
                    IDS_LIST_OBJECT, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_CONTROL_ACCESS,
                    ptype,
                    IDS_ALL_CONTROL_ACCESSES,
                    IDS_CONTROL_ACCESS_DISPLAY_NAME,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DELETE,
                    ptype,
                    IDS_DELETE_THIS_OBJECT, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_READ_CONTROL,
                    ptype,
                    IDS_READ_PERMISSIONS, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_CHANGE_ACCESS,
                    ptype,
                    IDS_MODIFY_PERMISSIONS, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_CHANGE_OWNER,
                    ptype,
                    IDS_TAKE_CHANGE_OWNERSHIP, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_SELF,
                    ptype,
                    IDS_MODIFY_MEMBERSHIP, false,
                    pWho,
                    pwszClassName);
        }
    }
    else
        hr = E_POINTER;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintPermission ()
//
//  Purpose:    Print an OBJECT_ACE_TYPE permission
//
//  Inputs:     pAceSAMName - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
//              bAllow - whether the permission is allowed or denied
//
//              strIDAll - string to print if permission applies to all object 
//              classes
//
//              strIDParam - string print if permission applies to a specific
//              object class
//
HRESULT PrintPermission (ACE_SAMNAME*  pAceSAMName,
        ACCESS_MASK accessMask,
        P_TYPE  ptype,
        int strIDAll, 
        int strIDParam, 
        P_WHO pWho, 
        PCWSTR pwszClassName)
{
    HRESULT hr = S_OK;

    if ( pAceSAMName )
    {
        wstring str;
        wstring strPermission;


        if ( pAceSAMName->m_pAllowedAce->Mask & accessMask )
        {
            bool    bIsAudit = false;

            switch (pAceSAMName->m_AceType )
            {
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                if ( (pAceSAMName->m_pAllowedObjectAce->Flags & ACE_OBJECT_TYPE_PRESENT) && 
                        !::IsEqualGUID (pAceSAMName->m_pAllowedObjectAce->ObjectType, NULLGUID) )
                {
                    wstring strClass;

                    if ( ACTRL_DS_CONTROL_ACCESS == accessMask )
                    {
                        hr = GetControlDisplayName (
                                pAceSAMName->m_pAllowedObjectAce->ObjectType, strClass);
                    }
                    else
                    {
                        _Module.GetClassFromGUID (
                                pAceSAMName->m_pAllowedObjectAce->ObjectType,
                                strClass);
                    }

                    FormatMessage (strPermission, strIDParam, 
                            strClass.c_str ());
                }
                else
                {
                    LoadFromResource (strPermission, strIDAll);
                }
                break;

            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                if ( (pAceSAMName->m_pDeniedObjectAce->Flags & ACE_OBJECT_TYPE_PRESENT) && 
                        !::IsEqualGUID (pAceSAMName->m_pDeniedObjectAce->ObjectType, NULLGUID) )
                {
                    wstring strClass;


                    if ( ACTRL_DS_CONTROL_ACCESS == accessMask )
                    {
                        hr = GetControlDisplayName (
                                pAceSAMName->m_pDeniedObjectAce->ObjectType, strClass);
                    }
                    else
                    {
                        _Module.GetClassFromGUID (
                                pAceSAMName->m_pDeniedObjectAce->ObjectType,
                                strClass);
                    }
                    FormatMessage (strPermission,strIDParam, 
                            strClass.c_str ());
                }
                else
                {
                    LoadFromResource (strPermission, strIDAll);
                }
                break;

            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                if ( (pAceSAMName->m_pSystemAuditObjectAce->Flags & ACE_OBJECT_TYPE_PRESENT) && 
                        !::IsEqualGUID (pAceSAMName->m_pSystemAuditObjectAce->ObjectType, NULLGUID) )
                {
                    wstring strClass;


                    if ( ACTRL_DS_CONTROL_ACCESS == accessMask )
                    {
                        hr = GetControlDisplayName (
                                pAceSAMName->m_pSystemAuditObjectAce->ObjectType, strClass);
                    }
                    else
                    {
                        _Module.GetClassFromGUID (
                                pAceSAMName->m_pSystemAuditObjectAce->ObjectType,
                                strClass);
                    }

                    FormatMessage (strPermission,strIDParam, 
                            strClass.c_str ());
                }
                else
                {
                    LoadFromResource (strPermission, strIDAll);
                }
                bIsAudit = true;
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
                bIsAudit = true;
                // fall through

            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            default:
                LoadFromResource (strPermission, strIDAll);
                break;
            }
            int strid = 0;

            switch (ptype)
            {
            case P_ALLOW:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_ALLOW_CDO;
                else
                    strid = IDS_ALLOW;
                break;

            case P_DENY:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_DENY_CDO;
                else
                    strid = IDS_DENY;
                break;

            case P_SUCCESS:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_SUCCESS_CDO;
                else
                    strid = IDS_SUCCESS;
                break;

            case P_FAILURE:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_FAILURE_CDO;
                else
                    strid = IDS_FAILURE;
                break;

            case P_SUCCESS_AND_FAILURE:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_SUCCESS_AND_FAILURE_CDO;
                else
                    strid = IDS_SUCCESS_AND_FAILURE;
                break;

            default:
                return E_UNEXPECTED;
            }
            if ( _Module.DoTabDelimitedOutput () )
            {
                wstring     strObject;


                switch ( pWho )
                {
                case P_THIS_OBJECT:
                    LoadFromResource (strObject, IDS_THIS_OBJECT);
                    break;

                case P_ALL_OBJECTS:
                    LoadFromResource (strObject, IDS_ALL_SUBOBJECTS);
                    break;

                case P_CLASS_OBJECT:
                    FormatMessage (strObject, IDS_CLASS_OBJECT, pwszClassName);
                    break;
                }

                FormatMessage (str, strid, 
                        strObject.c_str (),
                        pAceSAMName->m_SAMAccountName.c_str (),
                        strPermission.c_str ());
            }
            else
            {
                FormatMessage (str, strid, 
                        pAceSAMName->m_SAMAccountName.c_str (),
                        strPermission.c_str ());
            }
            MyWprintf (str.c_str ());
            if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE && 
                    (P_ALLOW == ptype || P_DENY == ptype) )
            {
                hr = PrintInheritedPermissionFromDN (pAceSAMName, accessMask, bIsAudit);
            }
            if ( _Module.DoTabDelimitedOutput () )
                MyWprintf (L"\n");
        }
    }
    else
        hr = E_POINTER;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintPermission ()
//
//  Purpose:    Print a non-OBJECT_ACE_TYPE permission
//
//  Inputs:     pAceSAMName - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
//              bAllow - whether the permission is allowed or denied
//
//              strID - string to print
//
HRESULT PrintPermission (ACE_SAMNAME*  pAceSAMName,
        ACCESS_MASK accessMask,
        P_TYPE  ptype,
        int strID,
        bool bIsAudit,
        P_WHO pWho, 
        PCWSTR pwszClassName)
{
    HRESULT     hr = S_OK;
    if ( pAceSAMName )
    {
        wstring    str;
        wstring    strPermission;


        if ( pAceSAMName->m_pAllowedAce->Mask & accessMask )
        {
            LoadFromResource (strPermission, strID);

            int id = 0;
            switch (ptype)
            {
            case P_ALLOW:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_ALLOW_CDO;
                else
                    id = IDS_ALLOW;
                break;

            case P_DENY:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_DENY_CDO;
                else
                    id = IDS_DENY;
                break;

            case P_SUCCESS:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_SUCCESS_CDO;
                else
                    id = IDS_SUCCESS;
                break;

            case P_FAILURE:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_FAILURE_CDO;
                else
                    id = IDS_FAILURE;
                break;

            case P_SUCCESS_AND_FAILURE:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_SUCCESS_AND_FAILURE_CDO;
                else
                    id = IDS_SUCCESS_AND_FAILURE;
                break;

            default:
                return E_UNEXPECTED;
            }
            if ( _Module.DoTabDelimitedOutput () )
            {
                wstring     strObject;


                switch ( pWho )
                {
                case P_THIS_OBJECT:
                    LoadFromResource (strObject, IDS_THIS_OBJECT);
                    break;

                case P_ALL_OBJECTS:
                    LoadFromResource (strObject, IDS_ALL_SUBOBJECTS);
                    break;

                case P_CLASS_OBJECT:
                    FormatMessage (strObject, IDS_CLASS_OBJECT, pwszClassName);
                    break;
                }

                FormatMessage (str, id, 
                        strObject.c_str (),
                        pAceSAMName->m_SAMAccountName.c_str (),
                        strPermission.c_str ());
            }
            else
            {
                FormatMessage (str, id, 
                        pAceSAMName->m_SAMAccountName.c_str (),
                        strPermission.c_str ());
            }

            MyWprintf (str.c_str ());
            if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE )
            {
                hr = PrintInheritedPermissionFromDN (pAceSAMName, accessMask, bIsAudit);
            }
            if ( _Module.DoTabDelimitedOutput () )
                MyWprintf (L"\n");
        }
    }
    else
        hr = E_POINTER;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// GetParentObjectDNWithSameACE ()
//
// This function is called recursively to try to find an ACE that matches the ACE
// contained in pAceSAMName somewhere in the parent container of the object pointed to
// by pPathName.  Each iteration strips a leaf element off pPathName, gets its
// security descriptor and searches the Dacl list for the ACE.  If a match is 
// found, taking into account the INHERITED_ACE flag, we look to see if the 
// INHERITED_ACE flag is set.  If so, we call GetParentObjectDNWithSameACE () again.
// If not, we get the return the object name at this level.
// 
HRESULT GetParentObjectDNWithSameACE (
        IN ACE_SAMNAME*  pAceSAMName, 
        IN IADsPathname* pPathName,
        IN ACCESS_MASK accessMask,
        OUT wstring& strParentDN,
        bool bIsAudit)
{
    _TRACE (1, L"Entering  GetParentObjectDNWithSameACE\n");
    HRESULT hr = pPathName->RemoveLeafElement ();
    if ( SUCCEEDED (hr) )
    {
		BSTR bstrFullPath = 0;
		hr = pPathName->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
		if ( SUCCEEDED (hr) )
		{
            if ( !wcscmp (bstrFullPath, L"LDAP://") )
                return S_FALSE;

            PSECURITY_DESCRIPTOR    pSecurityDescriptor = 0;  
            bool                    bFound = false;
                
            // Check to see if we already have this object's Security Descriptor
            list<SAMNAME_SD*>::iterator sdItr = _Module.m_listOfParentSDs.begin ();
            SAMNAME_SD*                 pCurrSAMNameSD = 0;
            for (; sdItr != _Module.m_listOfParentSDs.end (); sdItr++)
            {
                pCurrSAMNameSD = *sdItr;
                if ( !pCurrSAMNameSD->m_upn.compare (bstrFullPath) )
                {
                    pSecurityDescriptor = pCurrSAMNameSD->m_pSecurityDescriptor;
                    bFound = true; // Note - pSecurityDescriptor could be NULL
                                    // this is expected.
                    break;
                }
            }

            // If we don't already have the SD for this object, get it and cache it.
            if ( !bFound )
            {
                wstring objectDN (bstrFullPath);
                hr = GetSecurityDescriptor  (objectDN, &pSecurityDescriptor);
                if ( SUCCEEDED (hr) )
                {
                    pCurrSAMNameSD = new SAMNAME_SD (bstrFullPath, pSecurityDescriptor);
                    if ( pCurrSAMNameSD )
                    {
                        if ( pSecurityDescriptor )
                        {
                             hr = EnumerateDacl (pSecurityDescriptor, pCurrSAMNameSD->m_DACLList, false);
                             if ( SUCCEEDED (hr) )
                                 hr = EnumerateSacl (pSecurityDescriptor, pCurrSAMNameSD->m_SACLList);
                        }
                        _Module.m_listOfParentSDs.push_back (pCurrSAMNameSD);
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
            }

            if ( SUCCEEDED (hr) && pCurrSAMNameSD )
            {
                ACE_SAMNAME_LIST*    pList = 0;

                if ( bIsAudit )
                    pList = &pCurrSAMNameSD->m_SACLList;
                else
                    pList = &pCurrSAMNameSD->m_DACLList;

                ACE_SAMNAME_LIST::iterator    itr =  pList->begin ();
                ACE_SAMNAME*                    pCurrSAMName = 0;

                for (; itr != pList->end(); itr++)
                {
                    pCurrSAMName = *itr;
                    if ( pCurrSAMName->IsEquivalent (*pAceSAMName, 
                            accessMask) )
                    {
                        if ( pCurrSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE )
                        {
                            hr = GetParentObjectDNWithSameACE (
                                    pAceSAMName, 
                                    pPathName, 
                                    accessMask, 
                                    strParentDN,
                                    bIsAudit);
                        }
                        else
                        {
                            BSTR bstrDN = 0;
		                    hr = pPathName->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
		                    if ( SUCCEEDED (hr) )
		                    {
                                strParentDN = bstrDN;
                            }
                            else
                            {
                                _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                            }
                        }
                        break;
                    }
                }
            }
            SysFreeString (bstrFullPath);
        }
        else
        {
            _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
        }
    }

    if ( SUCCEEDED (hr) && S_FALSE != hr && !strParentDN.length () )
    {
        hr = GetParentObjectDNWithSameACE (pAceSAMName, pPathName, accessMask, 
                strParentDN, bIsAudit);
    }


    _TRACE (-1, L"Leaving GetParentObjectDNWithSameACE: 0x%x\n", hr);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintInheritedPermissionFromDN ()
//
//  Purpose:    Print a message indicating that a permission is inherited from 
//              another object plus that object's DN
//
//  Inputs:     pAceSAMName - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
HRESULT PrintInheritedPermissionFromDN (ACE_SAMNAME* pAceSAMName, ACCESS_MASK accessMask, bool bIsAudit)
{
    _TRACE (1, L"Entering  PrintInheritedPermissionFromDN\n");
    HRESULT hr = S_OK;


    if ( pAceSAMName )
    {
	    CComPtr<IADsPathname> spPathname;
	    //
	    // Constructing the directory paths
	    //
	    hr = CoCreateInstance(
				    CLSID_Pathname,
				    NULL,
				    CLSCTX_ALL,
				    IID_IADsPathname,
				    (void**)&spPathname);
	    if ( SUCCEEDED (hr) )
	    {
            ASSERT (!!spPathname);
		    hr = spPathname->Set((PWSTR)ACLDIAG_LDAP,
							    ADS_SETTYPE_PROVIDER);
		    if ( SUCCEEDED (hr) )
		    {            
                hr = spPathname->Set (
                        const_cast <BSTR> (_Module.GetObjectDN ().c_str ()),
                        ADS_SETTYPE_DN);
                if ( SUCCEEDED (hr) )
                {
                    wstring    str;
                    wstring    strParentDN;

                    hr = GetParentObjectDNWithSameACE (pAceSAMName, 
                    spPathname, accessMask, strParentDN, bIsAudit);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( !strParentDN.length () )
                        {
                            if ( _Module.DoTabDelimitedOutput () )
                            {
                                LoadFromResource (str, 
                                        IDS_GENERATED_INHERITED_PERMISSION_CDO);
                            }
                            else
                            {
                                LoadFromResource (str, 
                                        IDS_GENERATED_INHERITED_PERMISSION);
                            }
                        }
                        else
                        {
                            if ( _Module.DoTabDelimitedOutput () )
                            {
                                FormatMessage (str, IDS_INHERITED_PERMISSION_CDO, 
                                        strParentDN.c_str ());
                            }
                            else
                            {
                                FormatMessage (str, IDS_INHERITED_PERMISSION, 
                                        strParentDN.c_str ());
                            }
                        }
                        MyWprintf (str.c_str ());
                    }
                }
            }
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving PrintInheritedPermissionFromDN: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintInheritedPermissions ()
//
//  Purpose:    Print permissions that are inherited by subobjects
//
HRESULT PrintInheritedPermissions ()
{
    _TRACE (1, L"Entering  PrintInheritedPermissions\n");
    HRESULT                     hr = S_OK;
    ACE_SAMNAME_LIST::iterator  aceItr =  _Module.m_DACLList.begin ();
    wstring                     str;
    ACE_SAMNAME*                pAceSAMName = 0;
    list<GUID*>                 guidList;
    

    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_PERMISSIONS_INHERITED_BY_SUBOBJECTS);
        MyWprintf (str.c_str ());

        LoadFromResource (str, IDS_INHERIT_TO_ALL_SUBOBJECTS);
        MyWprintf (str.c_str ());
    }

    // Second iteration: Each ACE which has CONTAINER_INHERIT is inherited to 
    // sub-objects.
    // Several "subiterations" are done to categorize inherit ACEs to the 
    // subobject type they apply.
    // First subiteration is for ACEs which are not object type or have 
    // InheritedObjectType = NULL.  These apply to "All Subobjects". We'll gather
    // the GUIDs of the InheritedObjectType's which are not NULL at this point to
    // use in the subsequent iterations.
    // Subsequent subiterations are for each unique InheritedObjectType 
    // present in the DACL.
    for (aceItr = _Module.m_DACLList.begin(); aceItr != _Module.m_DACLList.end(); aceItr++)
    {
        pAceSAMName = *aceItr;
        if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & CONTAINER_INHERIT_ACE )
        {
            switch (pAceSAMName->m_AceType)
            {    
            case ACCESS_ALLOWED_ACE_TYPE:
                hr = EnumeratePermissions (pAceSAMName, P_ALLOW, P_ALL_OBJECTS, L"");
                break;

            case ACCESS_DENIED_ACE_TYPE:
                hr = EnumeratePermissions (pAceSAMName, P_DENY, P_ALL_OBJECTS, L"");
                break;

            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                if ( !(pAceSAMName->m_pDeniedObjectAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) && 
                        ::IsEqualGUID (pAceSAMName->m_pDeniedObjectAce->ObjectType, NULLGUID) )
                {
                    hr = EnumeratePermissions (pAceSAMName, P_DENY, P_ALL_OBJECTS, L"");
                }
                else
                {
                    AddToInheritedObjectTypeGUIDList (guidList, 
                            &(pAceSAMName->m_pDeniedObjectAce->ObjectType));
                }
                break;

            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                if ( !(pAceSAMName->m_pAllowedObjectAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) && 
                        ::IsEqualGUID (pAceSAMName->m_pAllowedObjectAce->ObjectType, NULLGUID) )
                {
                    hr = EnumeratePermissions (pAceSAMName, P_ALLOW, P_ALL_OBJECTS, L"");
                }
                else
                {
                    AddToInheritedObjectTypeGUIDList (guidList, 
                            &(pAceSAMName->m_pAllowedObjectAce->ObjectType));
                }
                break;

            default:
                break;
            }
        }
    }

    
    GUID*       pGuid = 0;
    wstring     strClassName;
    GUID_TYPE   guidType;

    for (list<GUID*>::iterator guidItr =  guidList.begin ();
            guidItr != guidList.end ();
            guidItr++)
    {
        pGuid = *guidItr;
        hr = _Module.GetClassFromGUID (*pGuid, strClassName, &guidType);
        if ( SUCCEEDED (hr) && GUID_TYPE_CLASS == guidType )
        {
            if ( !_Module.DoTabDelimitedOutput () )
            {
                FormatMessage (str, IDS_INHERIT_TO_X_OBJECTS_ONLY, strClassName.c_str ());
                MyWprintf (str.c_str ());
            }

            for (aceItr = _Module.m_DACLList.begin(); aceItr != _Module.m_DACLList.end(); aceItr++)
            {
                pAceSAMName = *aceItr;
                if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & CONTAINER_INHERIT_ACE )
                {
                    switch (pAceSAMName->m_AceType)
                    {    
                    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                        if ( ::IsEqualGUID (pAceSAMName->m_pAllowedObjectAce->ObjectType, 
                                *pGuid) )
                        {
                            hr = EnumeratePermissions (pAceSAMName, P_ALLOW, 
                                    P_CLASS_OBJECT, strClassName.c_str ());
                        }
                        break;

                    case ACCESS_DENIED_OBJECT_ACE_TYPE:
                        if ( ::IsEqualGUID (pAceSAMName->m_pDeniedObjectAce->ObjectType, 
                                *pGuid) )
                        {
                            hr = EnumeratePermissions (pAceSAMName, P_DENY, 
                                    P_CLASS_OBJECT, strClassName.c_str ());
                        }
                        break;

                    default:
                        break;
                    }
                }
            }
        }
    }


    _TRACE (1, L"Entering  PrintInheritedPermissions: 0x%x\n", hr);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     AddToInheritedObjectTypeGUIDList ()
//
//  Purpose:    Add a GUID to a list.  Ensure that it is unique.
//
//  Inputs:     guidList - list to which the GUID should be added
//
//              pGuid - GUID to add to the list
//
void AddToInheritedObjectTypeGUIDList (list<GUID*>& guidList, GUID* pGuid)
{
    // The guidList should only contain unique GUIDs.  Verify that the one we
    // wish to add is not already in the list.
    if ( pGuid )
    {
        bool                    bFound = false;
        GUID*                   pCurrGuid = 0;
        list<GUID*>::iterator   guidItr = guidList.begin();

        for (; guidItr != guidList.end(); guidItr++)
        {
            pCurrGuid = *guidItr;
            if ( ::IsEqualGUID (*pCurrGuid, *pGuid) )
            {
                bFound = true;
                break;
            }
        }
        if ( !bFound )
        {
            guidList.push_back (pGuid);
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintAuditingInformation ()
//
//  Purpose:    Print auditing information from the SACL
//
HRESULT PrintAuditingInformation ()
{
    _TRACE (1, L"Entering  PrintAuditingInformation\n");
    HRESULT     hr = S_OK;
    wstring    str;

    MyWprintf (L"\n\n");

    SECURITY_DESCRIPTOR_CONTROL control;
    DWORD                       dwRevision = 0;
    if ( GetSecurityDescriptorControl (
            _Module.m_pSecurityDescriptor,
            &control,
            &dwRevision) )
    {
        if ( !_Module.DoTabDelimitedOutput () && (control & SE_SACL_PROTECTED) )
        {
            wstring    str;

            LoadFromResource (str, IDS_CONFIG_NO_INHERIT);
            MyWprintf (str.c_str ());
        }
    }
    else
    {
        _TRACE (0, L"GetSecurityDescriptorControl () failed: 0x%x\n", GetLastError ());
    }

    hr = PrintEffectiveAuditing ();
    if ( SUCCEEDED (hr) )
        hr = PrintInheritedAuditing ();

    _TRACE (-1, L"Leaving PrintAuditingInformation: 0x%x\n", hr);
    return hr;
}

HRESULT PrintEffectiveAuditing ()
{
    _TRACE (1, L"Entering  PrintEffectiveAuditing\n");
    HRESULT                     hr = S_OK;
    ACE_SAMNAME_LIST::iterator    itr =  _Module.m_SACLList.begin ();
    wstring                    str;
    ACE_SAMNAME*                    pAceSAMName = 0;


    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_AUDITING_EFFECTIVE_ON_THIS_OBJECT);
        MyWprintf (str.c_str ());
    }

    for (itr = _Module.m_SACLList.begin(); itr != _Module.m_SACLList.end(); itr++)
    {
        pAceSAMName = *itr;
        if ( !(pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERIT_ONLY_ACE) )
        {
            switch (pAceSAMName->m_AceType)
            {    
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
                hr = EnumerateAudits (pAceSAMName, P_THIS_OBJECT, L"");
                break;

            default:
                break;
            }
        }
    }

    _TRACE (-1, L"Leaving PrintEffectiveAuditing: 0x%x\n", hr);
    return hr;
}


HRESULT EnumerateAudits (ACE_SAMNAME* pAceSAMName, P_WHO pWho, PCWSTR pwszClassName)
{
    _TRACE (1, L"Entering  EnumerateAudits\n");
    HRESULT hr = S_OK;
    P_TYPE  ptype = P_UNASSIGNED;
    BYTE    byBoth = SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG;

    if ( (pAceSAMName->m_pAllowedAce->Header.AceFlags & byBoth) == byBoth )
    {
        ptype = P_SUCCESS_AND_FAILURE;
    }
    else if (  pAceSAMName->m_pAllowedAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG )
        ptype = P_SUCCESS;
    else if (  pAceSAMName->m_pAllowedAce->Header.AceFlags & FAILED_ACCESS_ACE_FLAG )
        ptype = P_FAILURE;
    else
        return E_UNEXPECTED;

    if ( pAceSAMName )
    {
        hr = PrintPermission (pAceSAMName,
                ACTRL_DS_CREATE_CHILD,
                ptype,
                IDS_CREATE_ALL_SUBOBJECTS,
                IDS_CREATE_CLASS_OBJECTS,
                pWho,
                pwszClassName);
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_DELETE_CHILD,
                    ptype,
                    IDS_DELETE_ALL_SUBOBJECTS,
                    IDS_DELETE_CLASS_OBJECTS,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_READ_PROP,
                    ptype,
                    IDS_READ_ALL_PROPERTIES,
                    IDS_READ_PROPERTY_PROPERTY,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_WRITE_PROP,
                    ptype,
                    IDS_WRITE_ALL_PROPERTIES,
                    IDS_WRITE_PROPERTY_PROPERTY,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName, 
                    ACTRL_DS_LIST, 
                    ptype,
                    IDS_LIST_CONTENTS, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_LIST_OBJECT,
                    ptype,
                    IDS_LIST_OBJECT, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            if ( pAceSAMName->m_pAllowedAce->Mask & ACTRL_DS_CONTROL_ACCESS )
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_CONTROL_ACCESS,
                    ptype,
                    IDS_ALL_CONTROL_ACCESSES,
                    IDS_CONTROL_ACCESS_DISPLAY_NAME,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DELETE,
                    ptype,
                    IDS_DELETE_THIS_OBJECT, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_READ_CONTROL,
                    ptype,
                    IDS_READ_PERMISSIONS, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_CHANGE_ACCESS,
                    ptype,
                    IDS_MODIFY_PERMISSIONS, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_CHANGE_OWNER,
                    ptype,
                    IDS_TAKE_CHANGE_OWNERSHIP, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_SELF,
                    ptype,
                    IDS_MODIFY_MEMBERSHIP, true,
                    pWho,
                    pwszClassName);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving EnumerateAudits: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintInheritedAuditing ()
//
//  Purpose:    Print audits that are inherited to subobjects
//
HRESULT PrintInheritedAuditing ()
{
    _TRACE (1, L"Entering  PrintInheritedAuditing\n");
    HRESULT hr = S_OK;
    ACE_SAMNAME_LIST::iterator    aceItr =  _Module.m_SACLList.begin ();
    wstring                    str;
    ACE_SAMNAME*                    pAceSAMName = 0;
    list<GUID*>                 guidList;
    

    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_AUDITING_INHERITED_TO_SUBOBJECTS);
        MyWprintf (str.c_str ());

        LoadFromResource (str, IDS_INHERIT_TO_ALL_SUBOBJECTS);
        MyWprintf (str.c_str ());
    }

    // Second iteration: Each ACE which has CONTAINER_INHERIT is inherited to 
    // sub-objects.
    // Several "subiterations" are done to categorize inherit ACEs to the 
    // subobject type they apply.
    // First subiteration is for ACEs which are not object type or have 
    // InheritedObjectType = NULL.  These apply to "All Subobjects". We'll gather
    // the GUIDs of the InheritedObjectType's which are not NULL at this point to
    // use in the subsequent iterations.
    // Subsequent subiterations are for each unique InheritedObjectType 
    // present in the DACL.
    for (aceItr = _Module.m_SACLList.begin(); aceItr != _Module.m_SACLList.end(); aceItr++)
    {
        pAceSAMName = *aceItr;
        if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & CONTAINER_INHERIT_ACE )
        {
            switch (pAceSAMName->m_AceType)
            {    
            case SYSTEM_AUDIT_ACE_TYPE:
                hr = EnumerateAudits (pAceSAMName, P_ALL_OBJECTS, L"");
                break;

            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                if ( !(pAceSAMName->m_pSystemAuditObjectAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) && 
                        ::IsEqualGUID (pAceSAMName->m_pSystemAuditObjectAce->ObjectType, NULLGUID) )
                {
                    hr = EnumerateAudits (pAceSAMName, P_ALL_OBJECTS, L"");
                }
                else
                {
                    AddToInheritedObjectTypeGUIDList (guidList, 
                            &(pAceSAMName->m_pSystemAuditObjectAce->ObjectType));
                }
                break;

            default:
                break;
            }
        }
    }

    
    GUID*   pGuid = 0;
    wstring strClassName;


    for (list<GUID*>::iterator guidItr =  guidList.begin ();
            guidItr != guidList.end ();
            guidItr++)
    {
        pGuid = *guidItr;
        hr = _Module.GetClassFromGUID (*pGuid, strClassName);
        if ( SUCCEEDED (hr) )
        {
            if ( !_Module.DoTabDelimitedOutput () )
            {
                FormatMessage (str, IDS_INHERIT_TO_X_OBJECTS_ONLY, strClassName.c_str ());
                MyWprintf (str.c_str ());
            }

            for (aceItr = _Module.m_SACLList.begin(); aceItr != _Module.m_SACLList.end(); aceItr++)
            {
                pAceSAMName = *aceItr;
                if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & CONTAINER_INHERIT_ACE )
                {
                    switch (pAceSAMName->m_AceType)
                    {    
                    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                        if ( ::IsEqualGUID (pAceSAMName->m_pSystemAuditObjectAce->ObjectType, 
                                *pGuid) )
                        {
                            hr = EnumerateAudits (pAceSAMName, P_CLASS_OBJECT, strClassName.c_str ());
                        }
                        break;

                    case SYSTEM_AUDIT_ACE_TYPE:
                    default:
                        break;
                    }
                }
            }
        }
    }


    _TRACE (-1, L"Leaving PrintInheritedAuditing: 0x%x\n", hr);
    return hr;
}


HRESULT GetControlDisplayName (REFGUID guid, wstring& strDisplayName)
{
    HRESULT hr = S_OK;
    wstring strGUID;

    hr = wstringFromGUID (strGUID, guid);
    if ( SUCCEEDED (hr) )
    {
        // strip braces from GUID
        wstring strRightsGUID (strGUID.substr (1, strGUID.length () - 2));

        hr = GetControlDisplayName (strRightsGUID, strDisplayName);
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


// TODO:  Optimize this by searching for all controls and putting them in an 
// array like the classes and attributes
HRESULT GetControlDisplayName (const wstring strGuid, wstring& strDisplayName)
{
    HRESULT hr = S_OK;

	CComPtr<IADsPathname> spPathname;
	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);
		hr = spPathname->Set(const_cast <PWSTR> (ACLDIAG_LDAP),
							ADS_SETTYPE_PROVIDER);
		if ( SUCCEEDED (hr) )
		{
			//
			// Open the root DSE object
			//
			hr = spPathname->AddLeafElement(const_cast <PWSTR> (ACLDIAG_ROOTDSE));
			if ( SUCCEEDED (hr) )
			{
				BSTR bstrFullPath = 0;
				hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				if ( SUCCEEDED (hr) )
				{
					CComPtr<IADs> spRootDSEObject;
					VARIANT varNamingContext;


					hr = ADsGetObject (
			              bstrFullPath,
						  IID_PPV_ARG (IADs, &spRootDSEObject));
					if ( SUCCEEDED (hr) )
					{
                        ASSERT (!!spRootDSEObject);
						//
						// Get the configuration naming context from the root DSE
						//
						hr = spRootDSEObject->Get(const_cast <PWSTR> (ACLDIAG_CONFIG_NAMING_CONTEXT),
											 &varNamingContext);
						if ( SUCCEEDED (hr) )
						{
							hr = spPathname->Set(V_BSTR(&varNamingContext),
												ADS_SETTYPE_DN);
							if ( SUCCEEDED (hr) )
							{
                                hr = spPathname->AddLeafElement (L"CN=Extended-Rights");
                                if ( SUCCEEDED (hr) )
                                {
				                    BSTR bstrFullPath = 0;
				                    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				                    if ( SUCCEEDED (hr) )
				                    {
					                    CComPtr<IDirectoryObject> spExtRightsContObj;


					                    hr = ADsGetObject (
			                                  bstrFullPath,
						                      IID_PPV_ARG (IDirectoryObject, &spExtRightsContObj));
					                    if ( SUCCEEDED (hr) )
					                    {
		                                    CComPtr<IDirectorySearch>   spDsSearch;
		                                    hr = spExtRightsContObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
		                                    if ( SUCCEEDED (hr) )
		                                    {
                                                ASSERT (!!spDsSearch);
			                                    ADS_SEARCHPREF_INFO pSearchPref[2];
			                                    DWORD dwNumPref = 2;

			                                    pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
			                                    pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
			                                    pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
			                                    pSearchPref[1].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
			                                    pSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
			                                    pSearchPref[1].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

			                                    hr = spDsSearch->SetSearchPreference(
					                                     pSearchPref,
					                                     dwNumPref
					                                     );
			                                    if ( SUCCEEDED (hr) )
			                                    {
                                                    PWSTR				rgszAttrList[] = {L"displayName"};
			                                        ADS_SEARCH_HANDLE	hSearchHandle = 0;
			                                        DWORD				dwNumAttributes = 1;
                                                    wstring            strQuery;
                                                    ADS_SEARCH_COLUMN   Column;

                                                    Column.pszAttrName = 0;
                                                    FormatMessage (strQuery,
                                                            L"rightsGUID=%1",
                                                            strGuid.c_str ());

				                                    hr = spDsSearch->ExecuteSearch(
									                                     const_cast <LPWSTR>(strQuery.c_str ()),
									                                     rgszAttrList,
									                                     dwNumAttributes,
									                                     &hSearchHandle
									                                     );
				                                    if ( SUCCEEDED (hr) )
				                                    {
					                                    hr = spDsSearch->GetFirstRow (hSearchHandle);
					                                    if ( SUCCEEDED (hr) )
					                                    {
						                                    while (hr != S_ADS_NOMORE_ROWS )
						                                    {
							                                    //
							                                    // Getting current row's information
							                                    //
							                                    hr = spDsSearch->GetColumn(
									                                     hSearchHandle,
									                                     rgszAttrList[0],
									                                     &Column
									                                     );
							                                    if ( SUCCEEDED (hr) )
							                                    {
                                                                    strDisplayName = Column.pADsValues->CaseIgnoreString;

								                                    spDsSearch->FreeColumn (&Column);
								                                    Column.pszAttrName = NULL;
                                                                    break;
							                                    }
							                                    else if ( hr != E_ADS_COLUMN_NOT_SET )
							                                    {
								                                    break;
							                                    }
                                                                else
                                                                {
                                                                    _TRACE (0, L"IDirectorySearch::GetColumn (): 0x%x\n", hr);
                                                                }
						                                    }
					                                    }
                                                        else
                                                        {
                                                             _TRACE (0, L"IDirectorySearch::GetFirstRow (): 0x%x\n", hr);
                                                        }

					                                    if (Column.pszAttrName)
					                                    {
						                                    spDsSearch->FreeColumn(&Column);
					                                    }
            		                                    spDsSearch->CloseSearchHandle(hSearchHandle);
				                                    }
				                                    else
				                                    {
                                                        _TRACE (0, L"IDirectorySearch::ExecuteSearch (): 0x%x\n", hr);
					                                    hr = S_OK;
				                                    }
			                                    }
                                                else
                                                {
                                                    _TRACE (0, L"IDirectorySearch::SetSearchPreference (): 0x%x\n", hr);
                                                }
                                            }
                                            else
                                            {
                                                _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch): 0x%x\n", hr);
                                            }
                                        }
                                        else
                                        {
                                            _TRACE (0, L"ADsGetObject (%s): 0x%x\n", bstrFullPath, hr);
                                        }
                                    }
                                    else
                                    {
                                        _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                                    }
                                }
                                else
                                {
                                    _TRACE (0, L"IADsPathname->AddLeafElement (%s): 0x%x\n", 
                                            L"CN=Extended-Rights", hr);
                                }
                            }
                            else
                            {
                                _TRACE (0, L"IADsPathname->Set (): 0x%x\n", V_BSTR(&varNamingContext), hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IADs->Get (%s): 0x%x\n", ACLDIAG_CONFIG_NAMING_CONTEXT, hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsGetObject (%s): 0x%x\n", bstrFullPath, hr);
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->AddLeafElement (%s): 0x%x\n", ACLDIAG_ROOTDSE, hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname): 0x%x\n", hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\schema.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       Schema.h
//
//  Contents:   DoSchemaDiagnosis and support methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_SCHEMA
#define __ACLDIAG_SCHEMA

HRESULT DoSchemaDiagnosis ();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__66DB1632_C78B_11D2_AC41_00C04F79DDCA__INCLUDED_)
#define AFX_STDAFX_H__66DB1632_C78B_11D2_AC41_00C04F79DDCA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT

#define _ATL_APARTMENT_THREADED

#pragma warning (disable : 4514)
#pragma warning (push, 3)
//////////////////////////////////////////////
// CRT and C++ headers

#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

//////////////////////////////////////////////
// Windows and ATL headers

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <shellapi.h>
#include <shlobj.h>

#include <objsel.h>

#include <atlbase.h>
using namespace ATL;

#include <iads.h>
#include <adserr.h>
#include <adshlp.h>
#include <adsprop.h>
#include <iadsp.h>
#include <security.h>
#include <seopaque.h>

#include <accctrl.h>
#include <setupapi.h> // to read the .INF file

#pragma warning (pop)

#include "debug.h"


#include "resource.h"

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
	reinterpret_cast<void**>(static_cast<Type **>(Expr))
#define ACLDIAG_LDAP                   L"LDAP"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__66DB1632_C78B_11D2_AC41_00C04F79DDCA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\schema.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       Schema.cpp
//
//  Contents:   DoSchemaDiagnosis and support methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <security.h>
#include <seopaque.h>
#include <sddl.h>
#include "ADUtils.h"
#include "Schema.h"
#include "SecDesc.h"


// Function prototypes
bool FindInGlobalList (const ACE_SAMNAME* pAceSAMNameToFind, const ACE_SAMNAME_LIST& defACLList);
HRESULT GetSchemaDefaultSecurityDescriptor (
            const wstring& strObjectDN, 
            PADS_ATTR_INFO* ppAttrs, 
            PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
            wstring &objectClass);
HRESULT GetObjectClass (const wstring& strObjectDN, wstring& ldapClassName);
HRESULT GetClassSecurityDescriptor (
            PADS_ATTR_INFO* ppAttrs, 
            PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
            CComPtr<IADsPathname>& spPathname,
            const wstring& ldapClassName);
HRESULT GetADClassName (
            CComPtr<IADsPathname>& spPathname, 
            const wstring& ldapClassName, 
            wstring& adClassName);


// Functions
HRESULT DoSchemaDiagnosis ()
{
    _TRACE (1, L"Entering  DoSchemaDiagnosis\n");
    HRESULT         hr = S_OK;
    wstring         str;
    size_t          nDACLAcesFound = 0;
    bool            bAllExplicit = true;
    bool            bAllInherited = true;
    ACE_SAMNAME_LIST  defDACLList;
    ACE_SAMNAME_LIST  defSACLList;

    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_SCHEMA_DEFAULTS_DIAGNOSIS);
        MyWprintf (str.c_str ());
    }

    PSECURITY_DESCRIPTOR    pSecurityDescriptor = 0;
    PADS_ATTR_INFO          pAttrs = NULL;
    wstring                 ldapClassName;
    hr = GetSchemaDefaultSecurityDescriptor (_Module.GetObjectDN (), &pAttrs,
            &pSecurityDescriptor, ldapClassName);
    if ( SUCCEEDED (hr) )
    {
        hr = EnumerateDacl (pSecurityDescriptor, defDACLList, false);
        if ( SUCCEEDED (hr) )
        {
            ACE_SAMNAME*    pAceSAMName = 0;


            // Compare the DACL
            for (ACE_SAMNAME_LIST::iterator itr = defDACLList.begin(); 
                    itr != defDACLList.end(); 
                    itr++)
            {
                pAceSAMName = *itr;
                if ( FindInGlobalList (pAceSAMName, _Module.m_DACLList) )
                {
                    if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE )
                    {
                        switch ( pAceSAMName->m_AceType )
                        {
                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                            {
                                wstring inheritedObjectClass;

                                if ( SUCCEEDED (_Module.GetClassFromGUID (
                                        pAceSAMName->m_pAllowedObjectAce->InheritedObjectType,
                                        inheritedObjectClass) ) )
                                {
                                    if ( !ldapClassName.compare (inheritedObjectClass) )
                                        break;  // matches
                                }
                            }
                            continue;   // not a match

                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
                            {
                                wstring inheritedObjectClass;

                                if ( SUCCEEDED (_Module.GetClassFromGUID (
                                        pAceSAMName->m_pDeniedObjectAce->InheritedObjectType,
                                        inheritedObjectClass) ) )
                                {
                                    if ( !ldapClassName.compare (inheritedObjectClass) )
                                        break;  // matches
                                }
                            }
                            continue;   // not a match

                        default:
                            break;  // matches
                        }
                        bAllExplicit = false;
                    }
                    else
                        bAllInherited = false;
                    nDACLAcesFound++;
                }
            }
        }

        // Compare the SACL
        hr = EnumerateSacl (pSecurityDescriptor, defSACLList);
        if ( SUCCEEDED (hr) )
        {
            ACE_SAMNAME*    pAceSAMName = 0;


            for (ACE_SAMNAME_LIST::iterator itr = defSACLList.begin(); 
                    itr != defSACLList.end(); 
                    itr++)
            {
                pAceSAMName = *itr;
                if ( FindInGlobalList (pAceSAMName, _Module.m_SACLList) )
                {
                    if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE )
                    {
                        switch ( pAceSAMName->m_AceType )
                        {
                        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                            {
                                wstring inheritedObjectClass;

                                if ( SUCCEEDED (_Module.GetClassFromGUID (
                                        pAceSAMName->m_pSystemAuditObjectAce->InheritedObjectType,
                                        inheritedObjectClass) ) )
                                {
                                    if ( !ldapClassName.compare (inheritedObjectClass) )
                                        break;  // matches
                                }
                            }
                            continue;   // not a match

                        case SYSTEM_AUDIT_ACE_TYPE:
                        default:
                            break;  // matches
                        }
                        bAllExplicit = false;
                    }
                    else
                        bAllInherited = false;
                    nDACLAcesFound++;
                }
            }
        }
    }

    wstring    strDefaultState;
    bool        bPresent = false;
    if ( !nDACLAcesFound )
    {
        // absent
        LoadFromResource (strDefaultState, IDS_ABSENT);
    }
    else 
    {
        if ( nDACLAcesFound == defDACLList.size () )
        {
            if ( bAllExplicit | bAllInherited )
            {
                // present
                LoadFromResource (strDefaultState, IDS_PRESENT);
                bPresent = true;
            }
            else
            {
                // partial
                LoadFromResource (strDefaultState, IDS_PARTIAL);
            }
        }
        else
        {
            // partial
            LoadFromResource (strDefaultState, IDS_PARTIAL);
        }
    }
    if ( _Module.DoTabDelimitedOutput () )
        FormatMessage (str, IDS_SCHEMA_DEFAULTS_CDO, strDefaultState.c_str ());
    else
        FormatMessage (str, IDS_SCHEMA_DEFAULTS, strDefaultState.c_str ());
    MyWprintf (str.c_str ());

    if ( bPresent )
    {
        if ( bAllExplicit )
            LoadFromResource (strDefaultState, IDS_AT_CREATION);
        else
            LoadFromResource (strDefaultState, IDS_BY_INHERITANCE);
        if ( _Module.DoTabDelimitedOutput () )
            FormatMessage (str, IDS_OBTAINED_CDO, strDefaultState.c_str ());
        else
            FormatMessage (str, IDS_OBTAINED, strDefaultState.c_str ());
        MyWprintf (str.c_str ());
    }
    else if ( _Module.DoTabDelimitedOutput () )
        MyWprintf (L"\n\n");

    _TRACE (-1, L"Leaving DoSchemaDiagnosis: 0x%x\n", hr);
    return hr;
}

HRESULT GetSchemaDefaultSecurityDescriptor (
        const wstring& strObjectDN, 
        PADS_ATTR_INFO* ppAttrs, 
        PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
        wstring &ldapClassName)
{
    _TRACE (1, L"Entering  GetSchemaDefaultSecurityDescriptor\n");
    HRESULT hr = S_OK;

    if ( ppAttrs && ppSecurityDescriptor )
    {
        hr = GetObjectClass (strObjectDN, ldapClassName);
        if ( SUCCEEDED (hr) )
        {
            wstring  strDC;

            size_t pos = strObjectDN.find (L"DC=", 0);
            if ( strObjectDN.npos != pos )
            {
                strDC = strObjectDN.substr (pos);
	            CComPtr<IADsPathname> spPathname;
	            //
	            // Constructing the directory paths
	            //
	            hr = CoCreateInstance(
				            CLSID_Pathname,
				            NULL,
				            CLSCTX_ALL,
				            IID_PPV_ARG (IADsPathname, &spPathname));
	            if ( SUCCEEDED (hr) )
	            {
                    ASSERT (!!spPathname);
		            hr = spPathname->Set (const_cast <PWSTR> (ACLDIAG_LDAP),
							            ADS_SETTYPE_PROVIDER);
		            if ( SUCCEEDED (hr) )
		            {
                        hr = spPathname->Set (
                                const_cast <PWSTR> (strDC.c_str ()),
					            ADS_SETTYPE_DN);
			            if ( SUCCEEDED (hr) )
			            {
                            hr = spPathname->AddLeafElement (L"CN=Configuration");
                            if ( SUCCEEDED (hr) )
                            {
                                hr = spPathname->AddLeafElement (L"CN=Schema");
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = GetClassSecurityDescriptor (
                                            ppAttrs, 
                                            ppSecurityDescriptor,
                                            spPathname,
                                            ldapClassName);
                                }
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                                    strDC.c_str (), hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
                    }
                }
                else
                {
                    _TRACE (0, L"CoCreateInstance(CLSID_Pathname): 0x%x\n", hr);
                }
            }

        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving GetSchemaDefaultSecurityDescriptor: 0x%x\n", hr);
    return hr;
}

HRESULT GetObjectClass (const wstring& strObjectDN, wstring& ldapClassName)
{
    _TRACE (1, L"Entering  GetObjectClass\n");
    HRESULT hr = S_OK;

	CComPtr<IADsPathname> spPathname;
	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);
		hr = spPathname->Set (const_cast <PWSTR> (ACLDIAG_LDAP),
							ADS_SETTYPE_PROVIDER);
		if ( SUCCEEDED (hr) )
		{
            hr = spPathname->Set (
                    const_cast <PWSTR> (strObjectDN.c_str ()),
					ADS_SETTYPE_DN);
			if ( SUCCEEDED (hr) )
			{
				BSTR bstrFullPath = 0;
				hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				if ( SUCCEEDED (hr) )
				{
					CComPtr<IDirectoryObject> spDirObj;


					hr = ADsGetObject (
			              bstrFullPath,
						  IID_PPV_ARG (IDirectoryObject, &spDirObj));
					if ( SUCCEEDED (hr) )
					{
                        //
                        // Get this object's object class.
                        //
                        const PWSTR wzObjectClass = L"objectClass";
                    
                        DWORD cAttrs = 0;
                        LPWSTR rgpwzAttrNames[] = {wzObjectClass};
                        PADS_ATTR_INFO pAttrs = NULL;

                        hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, 
                                &pAttrs, &cAttrs);
                        if ( SUCCEEDED (hr) )
                        {
                            if ( 1 <= cAttrs && pAttrs && pAttrs->pADsValues )
                            {
                                if (!(pAttrs->pADsValues[pAttrs->dwNumValues-1].CaseIgnoreString) )
                                {
                                    _TRACE (0, L"IADS return bogus object class!\n");
                                    hr =  E_UNEXPECTED;
                                }
                                else
                                {
                                    ldapClassName = 
                                            pAttrs->pADsValues[pAttrs->dwNumValues-1].CaseIgnoreString;
                                }
                                FreeADsMem (pAttrs);
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                        {
                            _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsGetObject (%s): 0x%x\n", bstrFullPath, hr);
                        wstring    strErr;
                   

                        FormatMessage (strErr, IDS_INVALID_OBJECT, 
                                _Module.GetObjectDN ().c_str (), 
                                GetSystemMessage (hr).c_str ());
                        MyWprintf (strErr.c_str ());
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        _Module.GetObjectDN ().c_str (), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname): 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving GetObjectClass: 0x%x\n", hr);
    return hr;
}

bool FindInGlobalList (const ACE_SAMNAME* pAceSAMNameToFind, const ACE_SAMNAME_LIST& defDACLList)
{
    _TRACE (1, L"Entering  FindInGlobalList\n");
    bool        bFound = false;
    ACE_SAMNAME*    pAceSAMName = 0;

    for (ACE_SAMNAME_LIST::iterator itr = defDACLList.begin(); 
            itr != defDACLList.end(); 
            itr++)
    {
        pAceSAMName = *itr;
        // pAceSAMNameToFind must be on the left
        if ( *pAceSAMNameToFind == *pAceSAMName )
        {
            bFound = true;
            break;
        }
    }
    
    _TRACE (-1, L"Leaving FindInGlobalList: %s\n", bFound ? L"found" : L"not found");
    return bFound;
}


HRESULT GetClassSecurityDescriptor (PADS_ATTR_INFO* ppAttrs, 
        PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
        CComPtr<IADsPathname>& spPathname,
        const wstring& ldapClassName)
{
    _TRACE (1, L"Entering  GetClassSecurityDescriptor\n");
    // ldapClassName must be converted from LDAP class to AD class
    wstring adClassName;

    HRESULT hr = GetADClassName (spPathname, ldapClassName, adClassName);
    if ( SUCCEEDED (hr) )
    {
        wstring cnClassName (L"CN=");
        cnClassName += adClassName;
        hr = spPathname->AddLeafElement (
                const_cast<BSTR>(cnClassName.c_str ()));
        if ( SUCCEEDED (hr) )
        {
	        BSTR bstrFullPath = 0;
	        hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
	        if ( SUCCEEDED (hr) )
	        {
		        CComPtr<IDirectoryObject> spDirObj;

		        hr = ADsGetObject (
			          bstrFullPath,
			          IID_PPV_ARG (IDirectoryObject, &spDirObj));
		        if ( SUCCEEDED (hr) )
		        {
                     hr = SetSecurityInfoMask (spDirObj, 
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION |
                            SACL_SECURITY_INFORMATION);

                    //
                    // Get this object's default Security Descriptor.
                    //
                    const PWSTR wzSecDescriptor = L"defaultSecurityDescriptor";

                    DWORD cAttrs = 0;
                    LPWSTR rgpwzAttrNames[] = {wzSecDescriptor};

                    hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, ppAttrs, &cAttrs);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( 1 == cAttrs && *ppAttrs && (*ppAttrs)->pADsValues )
                        {
                            // Caller will delete the SD w/ LocalFree         
                            if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                                    (*ppAttrs)->pADsValues->CaseIgnoreString,
                                    SDDL_REVISION,
                                    ppSecurityDescriptor,
                                    0) )
                            {
                                hr = HRESULT_FROM_WIN32(::GetLastError());
                            }
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    else
                    {
                        _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                    }
                }
                else
                {
                    _TRACE (0, L"ADsGetObject (%s): 0x%x\n", bstrFullPath, hr);
                    wstring    strErr;


                    FormatMessage (strErr, IDS_INVALID_OBJECT, 
                            _Module.GetObjectDN ().c_str (), 
                            GetSystemMessage (hr).c_str ());
                    MyWprintf (strErr.c_str ());
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
            }
        }
    }

    _TRACE (-1, L"Leaving GetClassSecurityDescriptor: 0x%x\n", hr);
    return hr;
}


HRESULT GetADClassName (
            CComPtr<IADsPathname>& spPathname, 
            const wstring& ldapClassName, 
            wstring& adClassName)
{
    _TRACE (1, L"Entering  GetADClassName\n");
    HRESULT hr = S_OK;

    // Get the "CN=Schema,CN=Configuration,DC=..." object
    // Search for a child whose LDAP-Display-Name matches ldapClassName
	BSTR bstrFullPath = 0;
	hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
	if ( SUCCEEDED (hr) )
	{
		CComPtr<IDirectoryObject> spDirObj;

		hr = ADsGetObject (
			  bstrFullPath,
			  IID_PPV_ARG (IDirectoryObject, &spDirObj));
		if ( SUCCEEDED (hr) )
		{
		    CComPtr<IDirectorySearch>   spDsSearch;
		    hr = spDirObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
		    if ( SUCCEEDED (hr) )
		    {
                ASSERT (!!spDsSearch);
			    ADS_SEARCHPREF_INFO pSearchPref[2];
			    DWORD dwNumPref = 2;

			    pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
			    pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
			    pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
			    pSearchPref[1].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
			    pSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
			    pSearchPref[1].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

			    hr = spDsSearch->SetSearchPreference(
					     pSearchPref,
					     dwNumPref
					     );
			    if ( SUCCEEDED (hr) )
			    {
                    PWSTR				rgszAttrList[] = {L"cn"}; //Common-Name", NULL };
			        ADS_SEARCH_HANDLE	hSearchHandle = 0;
			        DWORD				dwNumAttributes = 1;
                    wstring             strQuery;
                    ADS_SEARCH_COLUMN   Column;

                    ::ZeroMemory (&Column, sizeof (ADS_SEARCH_COLUMN));
                    FormatMessage (strQuery, 
                            L"lDAPDisplayName=%1", //L"LDAP-Display-Name=%1",
                            ldapClassName.c_str ());

				    hr = spDsSearch->ExecuteSearch(
									     const_cast <LPWSTR>(strQuery.c_str ()),
									     rgszAttrList,
									     dwNumAttributes,
									     &hSearchHandle
									     );
				    if ( SUCCEEDED (hr) )
				    {
					    hr = spDsSearch->GetFirstRow (hSearchHandle);
					    if ( SUCCEEDED (hr) )
					    {
						    while (hr != S_ADS_NOMORE_ROWS )
						    {
							    //
							    // Getting current row's information
							    //
							    hr = spDsSearch->GetColumn(
									     hSearchHandle,
									     rgszAttrList[0],
									     &Column
									     );
							    if ( SUCCEEDED (hr) )
							    {
                                    adClassName = Column.pADsValues->CaseIgnoreString;

								    spDsSearch->FreeColumn (&Column);
								    Column.pszAttrName = NULL;
                                    break;
							    }
							    else if ( hr != E_ADS_COLUMN_NOT_SET )
							    {
								    break;
							    }
                                else
                                {
                                    _TRACE (0, L"IDirectorySearch::GetColumn (): 0x%x\n", hr);
                                }
						    }
					    }
                        else
                        {
                            _TRACE (0, L"IDirectorySearch::GetFirstRow (): 0x%x\n", hr);
                        }

					    if (Column.pszAttrName)
					    {
						    spDsSearch->FreeColumn(&Column);
					    }
            		    spDsSearch->CloseSearchHandle(hSearchHandle);
				    }
				    else
				    {
                        _TRACE (0, L"IDirectorySearch::ExecuteSearch (): 0x%x\n", hr);
					    hr = S_OK;
				    }
			    }
                else
                {
                    _TRACE (0, L"IDirectorySearch::SetSearchPreference (): 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch): 0x%x\n", hr);
            }
        }
        else
        {
            _TRACE (0, L"ADsGetObject (%s): 0x%x\n", bstrFullPath, hr);
        }
    }
    else
    {
        _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving GetADClassName: 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ACLDiag.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\common\deltempl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       deltempl.h
//
//--------------------------------------------------------------------------


#ifndef _DELTEMPL_H__
#define _DELTEMPL_H__

#include "util.h"
#include "tempcore.h"


///////////////////////////////////////////////////////////////////////
// CTemplateAccessPermissionsHolder

class CTemplateClassReferences; // fwd decl

class CTemplateAccessPermissionsHolder : public CAccessPermissionsHolderBase
{
public:
  CTemplateAccessPermissionsHolder(CSchemaClassInfo* pClassInfo, BOOL bScopeClass);
  virtual ~CTemplateAccessPermissionsHolder();

  HRESULT GetAccessPermissions(CAdsiObject* pADSIObj);
  
  BOOL SetupFromClassReferences(CTemplateObjectTypeListRef* pRefList);

  DWORD UpdateAccessList(CPrincipal* pPrincipal,
                        LPCWSTR lpszServerName,
                        LPCWSTR lpszPhysicalSchemaNamingContext,
                        PACL *ppAcl);

protected:
  virtual HRESULT _LoadAccessRightInfoArrayFromTable( BOOL bIgnore, BOOL bHideListObject);

private:
  BOOL _SetControlRight(LPCWSTR lpszControlRight);
  BOOL _SetAccessMask(LPCWSTR lpszName, ULONG fAccessMask);

  BOOL _SetGeneralRighs(ULONG fAccessMask);
  BOOL _SetPropertyRight(LPCWSTR lpszName, ULONG fAccessMask);
  BOOL _SetSubObjectRight(LPCWSTR lpszName, ULONG fAccessMask);

private:
  CSchemaClassInfo* m_pClassInfo;
  BOOL m_bScopeClass;
};


typedef CGrowableArr<CTemplateAccessPermissionsHolder> CTemplatePermissionHolderArray;


///////////////////////////////////////////////////////////////////////
// CTemplateAccessPermissionsHolderManager

class CTemplateAccessPermissionsHolderManager
{
public:
  CTemplateAccessPermissionsHolderManager()
  {
  }

  BOOL LoadTemplates(); // load template manager from INF file
  
  BOOL HasTemplates(LPCWSTR lpszClass); // tell if there are loaded templates for a class
  BOOL HasSelectedTemplates();  // tell if there is a selection
  void DeselectAll();

  BOOL InitPermissionHoldersFromSelectedTemplates(CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray,
                              CAdsiObject* pADSIObj);

  DWORD UpdateAccessList(CPrincipal* pPrincipal,
                        LPCWSTR lpszServerName,
                        LPCWSTR lpszPhysicalSchemaNamingContext,
                        PACL *ppAcl);

  // UI related operations
  BOOL FillTemplatesListView(CCheckListViewHelper* pListViewHelper, LPCWSTR lpszClass);
  void WriteSummary(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);

protected:
  CTemplatePermissionHolderArray m_permissionHolderArray;

  CTemplateManager  m_templateManager;
};


#endif // _DELTEMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\acldiag\secdesc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       SecDesc.h
//
//  Contents:   DoSecurityDescription and support methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_SECDESC
#define __ACLDIAG_SECDESC

HRESULT DoSecurityDescription ();
HRESULT DisplayOwner ();
HRESULT EnumerateDacl (PSECURITY_DESCRIPTOR pSecurityDescriptor, ACE_SAMNAME_LIST& DACLList, bool bListSids);
HRESULT EnumerateSacl (PSECURITY_DESCRIPTOR pSecurityDescriptor, ACE_SAMNAME_LIST& SACLList);
HRESULT PrintEffectivePermissions ();


typedef enum {
    P_UNASSIGNED = -1,
    P_ALLOW = 0,
    P_DENY,
    P_SUCCESS,
    P_FAILURE,
    P_SUCCESS_AND_FAILURE
} P_TYPE;

typedef enum {
    P_THIS_OBJECT = 0,
    P_ALL_OBJECTS,
    P_CLASS_OBJECT
} P_WHO;

HRESULT PrintPermission (ACE_SAMNAME* pAceSAMName,
        ACCESS_MASK accessMask,
        P_TYPE  ptype,
        int     strIDAll, 
        int     strIDParam,
        P_WHO    pWho, 
        PCWSTR pwszClassName);
HRESULT PrintPermission (ACE_SAMNAME*  pAceSAMName,
        ACCESS_MASK accessMask,
        P_TYPE  ptype,
        int strID,
        bool bIsAudit,
        P_WHO    pWho, 
        PCWSTR pwszClassName);
HRESULT EnumeratePermissions (ACE_SAMNAME*  pAceSAMName, P_TYPE ptype, P_WHO pWho, PCWSTR pwszClassName);
HRESULT GetParentObjectDNWithSameACE (
            ACE_SAMNAME*  pAceSAMName, 
            IADsPathname* pPathName,
            ACCESS_MASK accessMask,
            string  strParentDN,
            bool bIsAudit);
HRESULT PrintInheritedPermissionFromDN (
            ACE_SAMNAME* pAceSAMName, 
            ACCESS_MASK accessMask,
            bool bIsAudit);

HRESULT PrintInheritedPermissions ();
void AddToInheritedObjectTypeGUIDList (list<GUID*>& guidList, GUID* pGuid);
HRESULT PrintAuditingInformation ();
HRESULT GetSecurityDescriptor (
            wstring strObjectDN,    // pass by value
            PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
HRESULT EnumerateAudits (ACE_SAMNAME* pAceSAMName, P_WHO pWho, PCWSTR pwszClassName);
HRESULT PrintEffectiveAuditing ();
HRESULT PrintInheritedAuditing ();
HRESULT GetControlDisplayName (REFGUID guid, wstring& strDisplayName);
HRESULT GetControlDisplayName (const wstring strGuid, wstring& strDisplayName);
#endif	//  __ACLDIAG_SECDESC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\common\stlutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stlutil.h
//
//--------------------------------------------------------------------------

#ifndef _STLUTIL_H__
#define _STLUTIL_H__


#if defined (DBG)
  #define _DUMP
#endif



/////////////////////////////////////////////////////////////////////////
// STL based helper template functions

template <class CNT> void _Clear(CNT* pCnt, BOOL bDel)
{
  if (bDel)
  {
    CNT::iterator i;
    for (i = pCnt->begin(); i != pCnt->end(); ++i)
    {
      if (*i != NULL)
      {
        delete (*i);
        *i = NULL;
      }
    }
  }
  pCnt->clear();
}


template <class CNT, class T> BOOL _Remove(CNT* pCnt, T* p, BOOL bDel = TRUE)
{
  CNT::iterator i;
  i = find(pCnt->begin(), pCnt->end(), p);
  if (i == pCnt->end())
  {
    return FALSE;
  }

  pCnt->erase(i);

  if (bDel)
    delete p;
  return TRUE;
}



///////////////////////////////////////////////////////////////////////
// CCompare<>

template <class T> class CCompare
{
public:
  bool operator()(const T x, const T y)
  {
    return *x < *y;
  }
};

///////////////////////////////////////////////////////////////////////
// CPtrList<>

template <class T> class CPtrList : public list<T>
{
public:
  CPtrList(BOOL bOwnMem)
  {
    m_bOwnMem = bOwnMem;
  }
  ~CPtrList()
  {
    Clear();
  }

#ifdef _DUMP
  void Dump()
  {
    CPtrList<T>::iterator i;
    for (i = this->begin(); i != this->end(); ++i)
    {
      (*i)->Dump();
    }
  }
#endif // _DUMP

  void Clear() { _Clear(this, m_bOwnMem);}
  BOOL Remove(T p) { return _Remove(this, p, m_bOwnMem);}

private:
  BOOL m_bOwnMem;
};

///////////////////////////////////////////////////////////////////////
// CGrowableArr<>

template <class T, class CMP = CCompare<T*> > class CGrowableArr
{
public:
	CGrowableArr(BOOL bOwnMem = TRUE)
	{
    m_bOwnMem = bOwnMem;
	};
	virtual ~CGrowableArr()
	{
		Clear();
	}
  size_t GetCount() { return m_pEntries.size(); }
	BOOL Alloc(long n)
	{
		return TRUE;
	}
  void Clear()
  {
    _Clear(&m_pEntries, m_bOwnMem);
  }

  T* operator[](long i)
  {
    return m_pEntries[i];
  }

  BOOL Add(T* p)
  {
    m_pEntries.push_back(p);
    return TRUE;
  }
  void Sort()
  {
    sort(m_pEntries.begin(), m_pEntries.end(), CMP());
  }

#ifdef _DUMP
  void Dump()
  {
    vector<T*>::iterator i;
    for (i = m_pEntries.begin(); i != m_pEntries.end(); ++i)
    {
      (*i)->Dump();
    }
  }
#endif // _DUMP
private:
  BOOL m_bOwnMem;
  vector<T*> m_pEntries;
};
   




#endif // _STLUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\common\_tempcor.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       _tempcor.cpp
//
//--------------------------------------------------------------------------



#include "tempcore.h"




//////////////////////////////////////////////////////////////////////////////
// Keywords for the INF file format


LPCWSTR g_lpszTemplates = L"Templates";
LPCWSTR g_lpszDelegationTemplates = L"DelegationTemplates";
LPCWSTR g_lpszDescription = L"Description";
LPCWSTR g_lpszAppliesToClasses = L"AppliesToClasses";

LPCWSTR g_lpszScope = L"SCOPE";

LPCWSTR g_lpszControlRight = L"CONTROLRIGHT";
LPCWSTR g_lpszThisObject = L"@";
LPCWSTR g_lpszObjectTypes = L"ObjectTypes";


//////////////////////////////////////////////////////////////////////////////////
// parsing of access bits





const int g_nGrantAll = 0; // first in the array

const _ACCESS_BIT_MAP g_AccessBitMap[] = {

  { L"GA", _GRANT_ALL            },
  { L"CC", ACTRL_DS_CREATE_CHILD },
  { L"DC", ACTRL_DS_DELETE_CHILD },
  { L"RP", ACTRL_DS_READ_PROP    }, 
  { L"WP", ACTRL_DS_WRITE_PROP   }, 
  { L"SW", ACTRL_DS_SELF         }, 
  { L"LC", ACTRL_DS_LIST         }, 
  { L"LO", ACTRL_DS_LIST_OBJECT  },
  { L"DT", ACTRL_DS_DELETE_TREE  }, 
  { L"RC", READ_CONTROL          }, 
  { L"WD", WRITE_DAC             }, 
  { L"WO", WRITE_OWNER           }, 
  { L"SD", DELETE                }, 
  { NULL, 0x0} // end of table

};

const _ACCESS_BIT_MAP* GetTemplateAccessRightsMap()
{
  return g_AccessBitMap;
}


ULONG GetAccessMaskFromString(LPCWSTR lpszAccessBit)
{
  if (wcscmp(lpszAccessBit, g_AccessBitMap[g_nGrantAll].lpsz) == 0 )
  {
    return g_AccessBitMap[g_nGrantAll].fMask;
  }
  _ACCESS_BIT_MAP* pEntry = (_ACCESS_BIT_MAP*)g_AccessBitMap+1;
  while (pEntry->lpsz != NULL)
  {
    if (wcscmp(lpszAccessBit, pEntry->lpsz) == 0 )
    {
      return pEntry->fMask;
    }
    pEntry++;
  }
  return 0x0;
}

void GetStringFromAccessMask(ULONG fAccessMask, wstring& szAccessMask)
{
  if (fAccessMask == g_AccessBitMap[g_nGrantAll].fMask)
  {
    szAccessMask = g_AccessBitMap[g_nGrantAll].lpsz;
    return;
  }
  szAccessMask = L"";
  _ACCESS_BIT_MAP* pEntry = (_ACCESS_BIT_MAP*)(g_AccessBitMap+1);
  while (pEntry->lpsz != NULL)
  {
    if ( fAccessMask & pEntry->fMask)
    {
      szAccessMask += pEntry->lpsz;
      szAccessMask += L"";
    }
    pEntry++;
  }
}

////////////////////////////////////////////////////////////////////////
// CTemplateManager

BOOL CTemplateManager::HasTemplates(LPCWSTR lpszClass)
{
  CTemplateList::iterator i;
  for (i = m_templateList.begin(); i != m_templateList.end(); ++i)
  {
    if ((*i)->AppliesToClass(lpszClass))
    {
      return TRUE;
    }
  }
  return FALSE;
}

BOOL CTemplateManager::HasSelectedTemplates()
{
  CTemplateList::iterator i;
  for (i = m_templateList.begin(); i != m_templateList.end(); ++i)
  {
    if ((*i)->m_bSelected)
    {
      return TRUE;
    }
  }
  return FALSE;
}

void CTemplateManager::DeselectAll()
{
  CTemplateList::iterator i;
  for (i = m_templateList.begin(); i != m_templateList.end(); ++i)
  {
    (*i)->m_bSelected = FALSE;
  }
}




void CTemplateManager::_LoadTemplatePermission(HINF InfHandle, 
                                               LPCWSTR lpszPermissionSection, 
                                               LPCWSTR lpszPermission,
                                               CTemplateObjectType* pObjectType)
{
  CInfList permissionList(InfHandle);
  if (!permissionList.Bind(lpszPermissionSection, lpszPermission))
  {
    return;
  }
  
  TRACE(L"_LoadTemplatePermission(%s)\n", lpszPermission);

  CTemplatePermission* pCurrPermission = NULL;
  // special case control access
  if (wcscmp(lpszPermission, g_lpszControlRight) == 0)
  {
    // read the value as a string
    CInfLine controlAccessLine(InfHandle);
    if (controlAccessLine.Bind(lpszPermissionSection, lpszPermission))
    {
      LPCWSTR lpszControlAccessValue = controlAccessLine.GetBuf();
      if (lpszControlAccessValue != NULL && (lpszControlAccessValue[0] != NULL))
      {
        pCurrPermission = new CTemplatePermission();
        if( pCurrPermission )
            pCurrPermission->SetControlRight(lpszControlAccessValue);
      }
    }

  }
  else
  {
    // any other access mask (including g_lpszThisObject == "@")
    ULONG fAccessMask = 0;
    while(permissionList.MoveNext())
    {
      // read the rights
      TRACE(L"right      <%s>\n", permissionList.GetBuf());
      fAccessMask |= GetAccessMaskFromString(permissionList.GetBuf());
    } // while

    TRACE(L"fAccessMask = 0x%x\n", fAccessMask);
    if ( (fAccessMask != 0) && (pCurrPermission == NULL))
    {
      pCurrPermission = new CTemplatePermission();
      if( pCurrPermission )
         pCurrPermission->SetAccessMask(lpszPermission, fAccessMask);
    }
  }


  if (pCurrPermission != NULL)
  {
    pObjectType->GetPermissionList()->push_back(pCurrPermission);
  }
}

void CTemplateManager::_LoadTemplatePermissionsSection(HINF InfHandle,
                                                       LPCWSTR lpszTemplateName,
                                                       LPCWSTR lpszObject,
                                                       CTemplate* pCurrTemplate)

{

  WCHAR szPermissionSection[N_BUF_LEN];
  wsprintf(szPermissionSection, L"%s.%s", lpszTemplateName, lpszObject);
  TRACE(L"  szPermissionSection = <%s>\n", szPermissionSection);
  
  
  CInfSectionKeys permissionSection(InfHandle);
  
  if (!permissionSection.Bind(szPermissionSection))
  {
    return;
  }
  
  CTemplateObjectType* pObjectType = NULL;

  while (permissionSection.MoveNext())
  {
    if (pObjectType == NULL)
    {
      pObjectType = new CTemplateObjectType(lpszObject);
    }

    TRACE(L"    <%s>\n", permissionSection.GetBuf());
    _LoadTemplatePermission(InfHandle, szPermissionSection, permissionSection.GetBuf(), pObjectType);

  } // while


  if (pObjectType != NULL)
  {
    // need to validate template data
    if (pObjectType->GetPermissionList()->size() > 0)
    {
      pCurrTemplate->GetObjectTypeList()->push_back(pObjectType);
    }
    else
    {
      delete pObjectType;
    }
  }
}

void CTemplateManager::_LoadTemplate(HINF InfHandle, LPCWSTR lpszTemplateName)
{
  
  // read the template description
  CInfLine descriptionLine(InfHandle);
  if (!descriptionLine.Bind(lpszTemplateName, g_lpszDescription))
  {
    TRACE(L"Invalid Template: missing description entry\n");
    return; // missing entry
  }
  TRACE(L"  Description = <%s>\n", descriptionLine.GetBuf());
  if (lstrlen(descriptionLine.GetBuf()) == 0)
  {
    TRACE(L"Invalid Template: empty description\n");
    return; // empty description 
  }

    
  // read the object types field
  CInfList currTemplate(InfHandle);
  if (!currTemplate.Bind(lpszTemplateName, g_lpszObjectTypes))
  {
    TRACE(L"Invalid Template: no objects specified\n");
    return; // no objects specified
  }


  // load the object type sections
  CTemplate* pCurrTemplate = NULL;
  while (currTemplate.MoveNext())
  {
    if (pCurrTemplate == NULL)
      pCurrTemplate = new CTemplate(descriptionLine.GetBuf());

    _LoadTemplatePermissionsSection(InfHandle, lpszTemplateName, currTemplate.GetBuf(), pCurrTemplate);
  } // while


  // add to template list, if not empty
  if (pCurrTemplate != NULL)
  {
    // need to validate template data
    if (pCurrTemplate->GetObjectTypeList()->size() > 0)
    {
      GetTemplateList()->push_back(pCurrTemplate);
    }
    else
    {
      TRACE(L"Discarding template: no valid object type sections\n");
      delete pCurrTemplate;
      pCurrTemplate = NULL;
    }
  }

  if (pCurrTemplate != NULL)
  {

    // read the applicable classes list, if any
    CInfList applicableClasses(InfHandle);
    if (applicableClasses.Bind(lpszTemplateName, g_lpszAppliesToClasses))
    {
      TRACE(L"Applicable to: ");

      while (applicableClasses.MoveNext())
      {
        TRACE(L"<%s>", applicableClasses.GetBuf());
        pCurrTemplate->AddAppliesToClass(applicableClasses.GetBuf());
      }
      TRACE(L"\n");
    }
    TRACE(L"\nTemplate successfully read into memory\n\n");
  } // if

}



BOOL CTemplateManager::_LoadTemplateList(HINF InfHandle)
{
  TRACE(L"CTemplateManager::_LoadTemplateList()\n");

  // acquire the list of templates in the file
  CInfList templatelist(InfHandle);
  if (!templatelist.Bind(g_lpszDelegationTemplates, g_lpszTemplates))
  {
    TRACE(L"CTemplateManager::_LoadTemplateList() failed: invalid template list entry\n");
    return FALSE;
  }

  // loop through the templates and load them
  while(templatelist.MoveNext())
  {
    // process
    TRACE(L"\nTemplate = <%s>\n", templatelist.GetBuf());
    _LoadTemplate(InfHandle, templatelist.GetBuf()); 

  } // while

  if (GetTemplateList()->size() == 0)
  {
    TRACE(L"CTemplateManager::_LoadTemplateList() failed no valid templates\n");
    return FALSE;
  }

#ifdef _DUMP
  TRACE(L"\n\n\n======= LOADED TEMPLATES ====================\n");
  GetTemplateList()->Dump();
  TRACE(L"\n===========================\n\n\n");
#endif // _DUMP
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\common\tempcore.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tempcore.h
//
//--------------------------------------------------------------------------


#ifndef _TEMPCORE_H
#define _TEMPCORE_H


#include "stlutil.h"



//////////////////////////////////////////////////////////////////////////////
// Keywords for the INF file format



extern LPCWSTR g_lpszTemplates;
extern LPCWSTR g_lpszDelegationTemplates;
extern LPCWSTR g_lpszDescription;
extern LPCWSTR g_lpszAppliesToClasses;

extern LPCWSTR g_lpszScope;
extern LPCWSTR g_lpszControlRight;
extern LPCWSTR g_lpszThisObject;
extern LPCWSTR g_lpszObjectTypes;
                          
////////////////////////////////////////////////////////////////////////////////


#define _GRANT_ALL \
  (STANDARD_RIGHTS_REQUIRED | ACTRL_DS_CONTROL_ACCESS | \
  ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD | ACTRL_DS_LIST | ACTRL_DS_SELF | \
  ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP | ACTRL_DS_DELETE_TREE | ACTRL_DS_LIST_OBJECT)






///////////////////////////////////////////////////////////////////////////////
// global functions


struct _ACCESS_BIT_MAP
{
  LPCWSTR lpsz;
  ULONG fMask;
};

const _ACCESS_BIT_MAP* GetTemplateAccessRightsMap();

void GetStringFromAccessMask(ULONG fAccessMask, wstring& szAccessMask);



///////////////////////////////////////////////////////////////////////////////
// CInfFile

class CInfFile
{
public:
  CInfFile()
  {
    m_InfHandle = INVALID_HANDLE_VALUE;
  }

  ~CInfFile()
  {
    Close();
  }
  BOOL Open(LPCWSTR lpszFile)
  {
    Close();
    UINT nErrorLine = 0;
    m_InfHandle = ::SetupOpenInfFile( lpszFile,  // PCTSTR FileName, // name of the INF to open
                                  NULL,             // PCTSTR InfClass, // optional, the class of the INF file
                                  INF_STYLE_WIN4,   // DWORD InfStyle,  // specifies the style of the INF file
                                  &nErrorLine       // PUINT ErrorLine  // optional, receives error information
                                );
  
    if (m_InfHandle == INVALID_HANDLE_VALUE)
    {
      TRACE(L"Failed to open file, line = %d\n", nErrorLine);
      return FALSE;
    }
    return TRUE;
  }
  void Close()
  {
    if(m_InfHandle != INVALID_HANDLE_VALUE)
    {
      ::SetupCloseInfFile(m_InfHandle);
      m_InfHandle = INVALID_HANDLE_VALUE;
    }
  }
  operator HINF() { return m_InfHandle; }
private:
  HINF m_InfHandle;
};


///////////////////////////////////////////////////////////////////////////////
// CInfBase

#define N_BUF_LEN 256

class CInfBase
{
public:
  CInfBase(HINF InfHandle)
  {
    //ASSERT(InfHandle != INVALID_HANDLE_VALUE);
    m_InfHandle = InfHandle;
    m_szBuf[0] = NULL;
  }
  LPCWSTR GetBuf() { return m_szBuf; }
protected:
  HINF m_InfHandle;
  WCHAR m_szBuf[N_BUF_LEN];
  
};



///////////////////////////////////////////////////////////////////////////////
// CInfLine

class CInfLine : public CInfBase
{
public:
  CInfLine(HINF InfHandle) : CInfBase(InfHandle)
  {
  }
  
  BOOL Bind(LPCWSTR lpszSection, LPCWSTR lpszKey)
  {
    DWORD dwRequiredSize;
    if (!SetupGetLineText(NULL, m_InfHandle, lpszSection, lpszKey, 
                         m_szBuf, N_BUF_LEN, &dwRequiredSize))
    {
      m_szBuf[0] = NULL;
      return FALSE;
    }
    return TRUE;
  }
};



///////////////////////////////////////////////////////////////////////////////
// CInfList

class CInfList : public CInfBase
{
public:
  CInfList(HINF InfHandle) : CInfBase(InfHandle)
  {
    m_iField = 0;
  }

  BOOL Bind(LPCWSTR lpszSection, LPCWSTR lpszKey)
  {
    if (SetupFindFirstLine(m_InfHandle, lpszSection, lpszKey, &m_Context))
    {
      m_iField = 1;
      return TRUE;
    }
    return FALSE;
  }

  BOOL MoveNext()
  {
    DWORD dwRequiredSize;
    if (!SetupGetStringField(&m_Context, m_iField, m_szBuf, N_BUF_LEN, &dwRequiredSize))
    {
      m_szBuf[0] = NULL;
      return FALSE;
    }
    m_iField++;
    return TRUE;
  }

private:
  INFCONTEXT m_Context;
  UINT m_iField;
};



///////////////////////////////////////////////////////////////////////////////
// CInfSectionKeys

class CInfSectionKeys : public CInfBase
{
public:
  CInfSectionKeys(HINF InfHandle) : CInfBase(InfHandle)
  {
    m_nLineCount = (ULONG) -1;
    m_iCurrLine = (ULONG) -1;
  }

  BOOL Bind(LPCWSTR lpszSection)
  {
    m_szSection = lpszSection ? lpszSection : L"";
    m_nLineCount = SetupGetLineCount(m_InfHandle, lpszSection);
    if (m_nLineCount <= 0)
    {
      return FALSE;
    }
    m_iCurrLine = 0;
    return TRUE;
  }

  BOOL MoveNext()
  {
    if (m_iCurrLine >= m_nLineCount)
    {
      return FALSE;
    }
    INFCONTEXT Context;
    if (!::SetupGetLineByIndex(m_InfHandle, m_szSection.c_str(), m_iCurrLine, &Context))
      return FALSE;

    DWORD dwRequiredSize;
    if (!::SetupGetStringField(&Context, 0, m_szBuf, N_BUF_LEN, &dwRequiredSize))
    {
      m_szBuf[0] = NULL;
      return FALSE;
    }
    m_iCurrLine++;
    return TRUE;
  }

private:
  LONG m_nLineCount;
  LONG m_iCurrLine;
  wstring m_szSection;
};








////////////////////////////////////////////////////////////////////////
// CTemplatePermission

class CTemplatePermission
{
public:
  CTemplatePermission()
  {
    m_szName = L"";
    m_fAccessMask = 0x0;
    m_szControlRight = L"";
  }


  void SetAccessMask(LPCWSTR lpszName, ULONG fAccessMask)
  {
    m_szName = lpszName;
    m_fAccessMask = fAccessMask;
    m_szControlRight = L"";
  }

  void SetControlRight(LPCWSTR lpszControlRight)
  {
    m_szName = L"";
    m_fAccessMask = 0x0;
    m_szControlRight = lpszControlRight;
  }

  LPCWSTR GetName() { return m_szName.c_str(); }
  LPCWSTR GetControlRight() { return m_szControlRight.c_str();}
  ULONG GetAccessMask() { return m_fAccessMask;}

#ifdef _DUMP
  void Dump()
  {
    wstring szAccessMask;
    GetStringFromAccessMask(GetAccessMask(), szAccessMask);
    TRACE(L"      Right: name = <%s> mask = 0x%x (%s) control right = <%s>\n", 
                                    GetName(),  GetAccessMask(), szAccessMask.c_str(), GetControlRight());
  
  }
#endif // _DUMP

private:
  wstring m_szName;

  ULONG m_fAccessMask;
  wstring m_szControlRight;
};



////////////////////////////////////////////////////////////////////////
// CTemplatePermissionList

class CTemplatePermissionList : public CPtrList<CTemplatePermission*>
{
public:
  CTemplatePermissionList(BOOL bOwnMem = TRUE) : CPtrList<CTemplatePermission*>(bOwnMem) 
  {
  }

};

////////////////////////////////////////////////////////////////////////
// CTemplateObjectType

class CTemplateObjectType
{
public:

  CTemplateObjectType(LPCWSTR lpszObjectName)
  {
    m_szObjectName = lpszObjectName;
  }
  
  LPCWSTR GetObjectName() { return m_szObjectName.c_str(); }
  CTemplatePermissionList* GetPermissionList() { return &m_permissionList; }

#ifdef _DUMP
  void Dump()
  {
    TRACE(L"    ObjectType: <%s>\n", GetObjectName());
    m_permissionList.Dump();
  }
#endif // _DUMP

private:
  wstring m_szObjectName;
  CTemplatePermissionList m_permissionList;
};

////////////////////////////////////////////////////////////////////////
// CTemplateObjectTypeList

class CTemplateObjectTypeList : public CPtrList<CTemplateObjectType*>
{
public:
  CTemplateObjectTypeList(BOOL bOwnMem = TRUE) : CPtrList<CTemplateObjectType*>(bOwnMem) 
  {
  }
};


class CTemplateObjectTypeListRef : public CTemplateObjectTypeList
{
public:
  CTemplateObjectTypeListRef() : CTemplateObjectTypeList(FALSE) {}
};



////////////////////////////////////////////////////////////////////////
// CTemplate

class CTemplate
{
public:

  CTemplate(LPCWSTR lpszDescription)
  {
    m_szDescription = lpszDescription;
    m_bSelected = FALSE;
  }

  LPCWSTR GetDescription() { return m_szDescription.c_str(); }
  CTemplateObjectTypeList* GetObjectTypeList() { return &m_objectTypeList; }

  void AddAppliesToClass(LPCWSTR lpszClass)
  {
    m_appliestToClassesList.push_back(lpszClass);
  }

  BOOL AppliesToClass(LPCWSTR lpszClass)
  {
    if (m_appliestToClassesList.size() == 0)
    {
      // no classes, applies to all
      return TRUE;
    }

    // some classes on the list
    list<wstring>::iterator i;
    for (i = m_appliestToClassesList.begin(); i != m_appliestToClassesList.end(); ++i)
    {
      if (wcscmp((*i).c_str(), lpszClass) == 0)
      {
        return TRUE;
      }
    }
    return FALSE;
  }

#ifdef _DUMP
  void Dump()
  {
    TRACE(L"\n  Template Description: <%s>\n", GetDescription());

    if (m_appliestToClassesList.size() > 0)
    {
      list<wstring>::iterator i;
      TRACE(L"  Applies To Classes: ");
      for (i = m_appliestToClassesList.begin(); i != m_appliestToClassesList.end(); ++i)
      {
        TRACE(L"<%s>", (*i).c_str());
      }
      TRACE(L"\n");
    }
    m_objectTypeList.Dump();
    
  }
#endif // _DUMP


public:
  BOOL m_bSelected;

private:
  wstring m_szDescription;
  CTemplateObjectTypeList m_objectTypeList;
  list<wstring> m_appliestToClassesList;
};


////////////////////////////////////////////////////////////////////////
// CTemplateList

class CTemplateList : public CPtrList<CTemplate*>
{
public:
  CTemplateList(BOOL bOwnMem = TRUE) : CPtrList<CTemplate*>(bOwnMem) 
  {
  }
};



////////////////////////////////////////////////////////////////////////
// CTemplateManager

class CTemplateManager
{
public:
  CTemplateManager()
  {
  }
  CTemplateList* GetTemplateList() { return &m_templateList; }

  BOOL Load(LPCWSTR lpszFileName)
  {
    TRACE(L"CTemplateManager::Load(%s)\n", lpszFileName);
    m_templateList.Clear();
    CInfFile file;
    if (!file.Open(lpszFileName))
    {
      TRACE(L"CTemplateManager::Load(%s) failed on INF file open\n", lpszFileName);
      return FALSE;
    }
  
    return _LoadTemplateList(file);
  }

#ifdef _DUMP
  void Dump()
  {
    TRACE(L"TEMPLATE LIST DUMP BEGIN\n");
    m_templateList.Dump();
    TRACE(L"TEMPLATE LIST DUMP END\n");
  }
#endif // _DUMP

  BOOL HasTemplates(LPCWSTR lpszClass);
  BOOL HasSelectedTemplates();
  void DeselectAll();


private:
  void _LoadTemplatePermission(HINF InfHandle, 
                               LPCWSTR lpszPermissionSection, 
                               LPCWSTR lpszPermission,
                               CTemplateObjectType* pObjectType);

  void _LoadTemplatePermissionsSection(HINF InfHandle, 
                                       LPCWSTR lpszTemplateName,
                                       LPCWSTR lpszObject,
                                       CTemplate* pTemplate);
  void _LoadTemplate(HINF InfHandle, LPCWSTR lpszTemplateName);
  BOOL _LoadTemplateList(HINF InfHandle);


  CTemplateList m_templateList;
};

#endif // _TEMPCORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\atldlgs.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation, 1996 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// Original file obtained from Nenad Stefanovic (ATL Team) as
// part of WTL (Windows Template Library)
// Kept just all the property page and property sheet classes

#ifndef __ATLDLGS_H__
#define __ATLDLGS_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLWIN_H__
	#error atldlgs.h requires atlwin.h to be included first
#endif

#include <commdlg.h>
#include <commctrl.h>

// copied from the new ATLWIN.H file to work with standard ATL 2.1

#define DECLARE_EMPTY_MSG_MAP() \
public: \
	BOOL ProcessWindowMessage(HWND, UINT, WPARAM, LPARAM, LRESULT&, DWORD) \
	{ \
		return FALSE; \
	}


namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CPropertySheetImpl;
class CPropertySheet;
template <class T> class CPropertyPageImpl;


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetImpl - implements a property sheet

template <class T>
class ATL_NO_VTABLE CPropertySheetImpl : public CWindowImplBase
{
public:
	PROPSHEETHEADER m_psh;

// Construction/Destruction
	CPropertySheetImpl(LPCTSTR lpszTitle = NULL, UINT uStartPage = 0)
	{
		memset(&m_psh, 0, sizeof(PROPSHEETHEADER));
		m_psh.dwSize = sizeof(PROPSHEETHEADER);
		m_psh.dwFlags = PSH_USECALLBACK;
		m_psh.phpage = NULL;
		m_psh.nPages = 0;
		m_psh.pszCaption = lpszTitle;
		m_psh.nStartPage = uStartPage;
		m_psh.hwndParent = NULL;	// will be set in DoModal/Create
		m_psh.hInstance	= _Module.GetResourceInstance();
		m_psh.pfnCallback = T::PropSheetCallback;
	}

	~CPropertySheetImpl()
	{
		if(m_psh.phpage != NULL)
			delete[] m_psh.phpage;
	}

	static int CALLBACK PropSheetCallback(HWND hWnd, UINT uMsg, LPARAM)
	{
		if(uMsg == PSCB_INITIALIZED)
		{
			_ASSERTE(hWnd != NULL);
			CWindowImplBase* pT = (CWindowImplBase*)_Module.ExtractCreateWndData();
			pT->SubclassWindow(hWnd);
		}

		return 0;
	}

	HWND Create(HWND hWndParent = NULL)
	{
		_ASSERTE(m_hWnd == NULL);

		m_psh.dwFlags |= PSH_MODELESS;
		m_psh.hwndParent = hWndParent;

		_Module.AddCreateWndData(&m_thunk.cd, (CWindowImplBase*)this);

		HWND hWnd = (HWND)::PropertySheet(&m_psh);

		_ASSERTE(m_hWnd == hWnd);

		return hWnd;
	}

	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		_ASSERTE(m_hWnd == NULL);

		m_psh.dwFlags &= ~PSH_MODELESS;
		m_psh.hwndParent = hWndParent;

		_Module.AddCreateWndData(&m_thunk.cd, (CWindowImplBase*)this);

		int nRet = ::PropertySheet(&m_psh);

		m_hWnd = NULL;
		return nRet;
	}

// Attributes
	UINT GetPageCount() const
	{
		if(m_hWnd == NULL)
			return m_psh.nPages;

		HWND hWndTabCtrl = GetTabControl();
		_ASSERTE(hWndTabCtrl != NULL);
		return (UINT)::SendMessage(hWndTabCtrl, TCM_GETITEMCOUNT, 0, 0L);
	}
	HWND GetActivePage() const
	{
		_ASSERTE(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETCURRENTPAGEHWND, 0, 0L);
	}
	UINT GetActiveIndex() const
	{
		if(m_hWnd == NULL)
			return m_psh.nStartPage;

		HWND hWndTabCtrl = GetTabControl();
		_ASSERTE(hWndTabCtrl != NULL);
		return (UINT)::SendMessage(hWndTabCtrl, TCM_GETCURSEL, 0, 0L);
	}
	HPROPSHEETPAGE GetPage(UINT uPageIndex)
	{
		_ASSERTE(uPageIndex < m_psh.nPages);

		return m_psh.phpage[uPageIndex];
	}
	UINT GetPageIndex(HPROPSHEETPAGE hPage)
	{
		for(UINT i = 0; i < m_psh.nPages; i++)
		{
			if(m_psh.phpage[i] == hPage)
				return i;
		}
		return (UINT)-1;  // hPage not found
	}
	BOOL SetActivePage(UINT uPageIndex)
	{
		if(m_hWnd == NULL)
		{
			m_psh.nStartPage = uPageIndex;
			return TRUE;
		}
		return (BOOL)SendMessage(PSM_SETCURSEL, uPageIndex);
	}
	BOOL SetActivePage(HPROPSHEETPAGE hPage)
	{
		_ASSERTE(hPage != NULL);

		UINT uPageIndex = GetPageIndex(hPage);
		if(uPageIndex == (UINT)-1)
			return FALSE;

		return SetActivePage(uPageIndex);
	}
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
	{
		_ASSERTE((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
		_ASSERTE(lpszText == NULL);

		if(m_hWnd == NULL)
		{
			// set internal state
			m_psh.pszCaption = lpszText;
			m_psh.dwFlags &= ~PSH_PROPTITLE;
			m_psh.dwFlags |= nStyle;
		}
		else
		{
			// set external state
			SendMessage(PSM_SETTITLE, nStyle, (LPARAM)lpszText);
		}
	}
	HWND GetTabControl() const
	{
		_ASSERTE(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETTABCONTROL, 0, 0L);
	}
	void SetWizardMode()
	{
		m_psh.dwFlags |= PSH_WIZARD;
	}
	void SetFinishText(LPCTSTR lpszText)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText);
	}
	void SetWizardButtons(DWORD dwFlags)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
	}

// Operations
	BOOL AddPage(HPROPSHEETPAGE hPage)
	{
		_ASSERTE(hPage != NULL);

		// add page to internal list
		HPROPSHEETPAGE* php = (HPROPSHEETPAGE*)realloc(m_psh.phpage, (m_psh.nPages + 1) * sizeof(HPROPSHEETPAGE));
		if(php == NULL)
			return FALSE;

		m_psh.phpage = php;
		m_psh.phpage[m_psh.nPages] = hPage;
		m_psh.nPages++;

		if(m_hWnd != NULL)
			::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);

		return TRUE;
	}
	BOOL AddPage(LPCPROPSHEETPAGE pPage)
	{
		_ASSERTE(pPage != NULL);

		HPROPSHEETPAGE hPSP = ::CreatePropertySheetPage(pPage);
		if(hPSP == NULL)
			return FALSE;

		AddPage(hPSP);

		return TRUE;
	}
	BOOL RemovePage(HPROPSHEETPAGE hPage)
	{
		_ASSERTE(hPage != NULL);

		int nPage = GetPageIndex(hPage);
		if(nPage == -1)
			return FALSE;

		return RemovePage(nPage);
	}
	BOOL RemovePage(UINT uPageIndex)
	{
		// remove the page externally
		if(m_hWnd != NULL)
			SendMessage(PSM_REMOVEPAGE, uPageIndex);

		// remove the page from internal list
		if(uPageIndex >= m_psh.nPages)
			return FALSE;

		if(!DestroyPropertySheetPage(m_psh.phpage[uPageIndex]))
			return FALSE;

		for(UINT i = uPageIndex; i < m_psh.nPages - 1; i++)
			m_psh.phpage[i] = m_psh.phpage[i+1];

		m_psh.phpage = (HPROPSHEETPAGE*)realloc(m_psh.phpage, (m_psh.nPages - 1) * sizeof(HPROPSHEETPAGE));
		m_psh.nPages--;

		return TRUE;
	}
	BOOL PressButton(int nButton)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_PRESSBUTTON, nButton, 0L);
	}
};

class CPropertySheet : public CPropertySheetImpl<CPropertySheet>
{
public:
	CPropertySheet(LPCTSTR lpszTitle = NULL, UINT uStartPage = 0)
		: CPropertySheetImpl<CPropertySheet>(lpszTitle, uStartPage)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageImpl - implements a property page

template <class T>
class ATL_NO_VTABLE CPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		if(uMsg == PSPCB_CREATE)
		{
			_ASSERTE(hWnd == NULL);
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		_ASSERTE(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	BEGIN_MSG_MAP(CPropertyPageImpl< T >)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = static_cast<T*>(this);
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
//? other values
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
//? other values
			lResult = pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
/**/			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	LRESULT OnWizardBack()
	{
		return 0; // default go to previous page
	}
	LRESULT OnWizardNext()
	{
		return 0; // default go to next page
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

}; //namespace ATL

#endif // __ATLDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\common\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.h
//
//--------------------------------------------------------------------------

#ifndef _UTIL_H__
#define _UTIL_H__

#include <dsclient.h>
#include "stlutil.h"

///////////////////////////////////////////////////////////////////////
// MACROS


// flags to interpret the DSSEC.DAT file values (from JeffreyS)
#define IDC_CLASS_NO_CREATE     0x00000001
#define IDC_CLASS_NO_DELETE     0x00000002
#define IDC_CLASS_NO_INHERIT    0x00000004
#define IDC_PROP_NO_READ        0x00000001
#define IDC_PROP_NO_WRITE       0x00000002

// derived flags
#define IDC_CLASS_NO (IDC_CLASS_NO_CREATE | IDC_CLASS_NO_DELETE | IDC_CLASS_NO_INHERIT)
#define IDC_PROP_NO (IDC_PROP_NO_READ | IDC_PROP_NO_WRITE)

///////////////////////////////////////////////////////////////////////
// strings

// special classes

extern PWSTR g_wzRootDSE;
extern PWSTR g_wzSchemaNamingContext;
extern PWSTR g_wzLDAPAbstractSchemaFormat;


// fwd decl
class CAdsiObject;
class CErrorMessageHandlerBase;

///////////////////////////////////////////////////////////////////////
// CWString

class CWString : public wstring
{
public:
  operator LPCWSTR() { return c_str(); }
  CWString& operator=(LPCWSTR lpsz)
  {
    if (lpsz == NULL)
      lpsz = L"";
    *((wstring*)this) = lpsz;
    return *this;
  }
  BOOL LoadFromResource(UINT uID);
};


///////////////////////////////////////////////////////////////////////
// GLOBAL FUNCTIONS


BOOL LoadStringHelper(UINT uID, LPTSTR lpszBuffer, int nBufferMax);

BOOL GetStringFromHRESULTError(HRESULT hr, CWString& szErrorString, BOOL bTryADsIErrors = TRUE);
BOOL GetStringFromWin32Error(DWORD dwErr, CWString& CWString);

inline HRESULT ADsOpenObjectHelper(LPCWSTR lpszPathName, REFIID riid, void** ppObject)
{
  return ADsOpenObject((LPWSTR)lpszPathName,
                        NULL, //LPWSTR lpszUserName,
                        NULL, //LPWSTR lpszPassword,
                        ADS_SECURE_AUTHENTICATION, //DWORD  dwReserved,
                        riid,    
                        ppObject
                        );
}

HRESULT InitCheckAccess( HWND hwndParent, LPCWSTR pszObjectLADPPath );


// functions to access DSSEC.DAT
ULONG GetClassFlags(LPCWSTR lpszClassName);
ULONG GetAttributeFlags(LPCWSTR lpszClassName, LPCWSTR lpszAttr);

void BuildLdapPathHelper(LPCWSTR lpszServerName, LPCWSTR lpszNamingContext, CWString& szLdapPath);
void BuildWin32PathHelper(LPCWSTR lpszServerName, LPCWSTR lpszNamingContext, CWString& szWin32Path);

HRESULT GetCanonicalNameFromNamingContext(LPCWSTR lpszNamingContext, CWString& szCanonicalName);

HRESULT GetGlobalNamingContexts(LPCWSTR lpszServerName, 
                                CWString& szPhysicalSchemaNamingContext,
                                CWString& szConfigurationNamingContext);

HRESULT GetSchemaClassName(LPCWSTR lpszServerName, LPCWSTR lpszPhysicalSchemaNamingContext,
                           LPCWSTR lpszClassLdapDisplayName, // e.g. "organizationalUnit"
                           CWString& szClassName // e.g. "Organizational-Unit"
                           );

extern LPCWSTR g_lpszSummaryIdent;
extern LPCWSTR g_lpszSummaryNewLine;

void WriteSummaryTitleLine(CWString& szSummary, UINT nTitleID, LPCWSTR lpszNewLine);
void WriteSummaryLine(CWString& szSummary, LPCWSTR lpsz, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);

DWORD AddObjectRightInAcl(IN      PSID pSid, 
                          IN      ULONG uAccess, 
                          IN      const GUID* pRightGUID, 
                          IN      const GUID* pInheritGUID, 
                          IN OUT  PACL* ppAcl);

///////////////////////////////////////////////////////////////////////
//////////////////////////// HELPER CLASSES ///////////////////////////



///////////////////////////////////////////////////////////////////////
// CWaitCursor

class CWaitCursor
{
public:
  CWaitCursor()
  {
    m_hCurrentCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
  }
  ~CWaitCursor()
  {
    ::SetCursor(m_hCurrentCursor);
  }
private:
  HCURSOR m_hCurrentCursor;
};




BOOL FormatStringGUID(LPWSTR lpszBuf, UINT nBufSize, const GUID* pGuid);

BOOL GuidFromString(GUID* pGuid, LPCWSTR lpszGuidString);

///////////////////////////////////////////////////////////////////////
// CFilterBase

class CFilterBase
{
public:
  virtual BOOL CanAdd(LPCWSTR lpsz, ULONG* pFilterFlags) = 0;
};

///////////////////////////////////////////////////////////////////////
// CSidHolder

class CSidHolder
{
public:
  CSidHolder()
  {
    _Init();
  }
  ~CSidHolder()
  {
    _Free();
  }
  
  PSID Get()
  {
    return m_pSID;
  }

  BOOL Copy(PSID p)
  {
    _Free();
    return _Copy(p);
  }

  void Attach(PSID p, BOOL bLocalAlloc)
  {
    _Free();
    m_pSID = p;
    m_bLocalAlloc = bLocalAlloc;
  }

private:
  void _Init()
  {
    m_pSID = NULL;
    m_bLocalAlloc = TRUE;
  }

  void _Free()
  {
    if (m_pSID != NULL)
    {
      if (m_bLocalAlloc)
        ::LocalFree(m_pSID);
      else
        ::FreeSid(m_pSID);
      _Init();
    }
  }

  BOOL _Copy(PSID p)
  {
    if ( (p == NULL) || !::IsValidSid(p) )
      return FALSE;
    DWORD dwLen = ::GetLengthSid(p);
    PSID pNew = ::LocalAlloc(LPTR, dwLen);
    if(!pNew)
        return FALSE;   
    if (!::CopySid(dwLen, pNew, p))
    {
      ::LocalFree(pNew);
      return FALSE;
    }
    m_bLocalAlloc = TRUE;
    m_pSID = pNew;
    ASSERT(dwLen == ::GetLengthSid(m_pSID));
    ASSERT(memcmp(p, m_pSID, dwLen) == 0);
    return TRUE;
  }

  PSID m_pSID;
  BOOL m_bLocalAlloc;
};




///////////////////////////////////////////////////////////////////////
// CPrincipal

class CPrincipal
{
public:
	CPrincipal() 
  { 
    m_hClassIcon = NULL;
  }

  HRESULT Initialize(PDS_SELECTION pDsSelection, HICON hClassIcon);

  HRESULT Initialize (PSID psid);

  BOOL IsEqual(CPrincipal* p);


  PSID GetSid()
  {
    return m_sidHolder.Get();
  }

  LPCWSTR GetClass()
  {
    return m_szClass;
  }

  HICON GetClassIcon()
  {
    return m_hClassIcon;
  }

  LPCWSTR GetDisplayName()
  {
    return m_szDisplayName;
  }

private:
  void _ComposeDisplayName();

  // names
  CWString m_szName; // e.g. "JoeB"
  CWString m_szADsPath; //e.g. "WINNT://FOODOM/JoeB"
  CWString m_szUPN; // e.g. "JoeB@foo.com."
  CWString m_szClass; // e.g. "user"

  CWString m_szDisplayName; // generated, to be shown into the UI

  // other data
  HICON m_hClassIcon;       // icon handle
  CSidHolder m_sidHolder;   // PSID holder
};


///////////////////////////////////////////////////////////////////////
// CPrincipalList


class CPrincipalList : public CPtrList<CPrincipal*>
{
public:
  CPrincipalList(BOOL bOwnMem = TRUE) : CPtrList<CPrincipal*>(bOwnMem) 
  {
  }
  BOOL AddIfNotPresent(CPrincipal* p);
  void WriteSummaryInfo(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);
};



///////////////////////////////////////////////////////////////////////
// CBasicRightInfo

class CBasicRightInfo
{
public:
  CBasicRightInfo()
  {
    m_fAccess = 0x0;
    m_bSelected = FALSE;
  }

  LPCWSTR GetDisplayName() { return m_szDisplayName; }
  ULONG GetAccess() { return m_fAccess; }

  BOOL IsSelected() { return m_bSelected; }
  void Select(BOOL b) { m_bSelected = b; }

protected:
  CWString m_szDisplayName;
  ULONG m_fAccess;
private:
  BOOL m_bSelected;
};


///////////////////////////////////////////////////////////////////////
// CAccessRightInfo

class CTemplateAccessPermissionsHolder; // fwd decl
class CCustomAccessPermissionsHolder; // fwd decl

class CAccessRightInfo : public CBasicRightInfo
{
  friend class CTemplateAccessPermissionsHolder;
  friend class CCustomAccessPermissionsHolder;
};

///////////////////////////////////////////////////////////////////////
// CAccessRightInfoArray


class CAccessRightInfoArray : public CGrowableArr<CAccessRightInfo>
{
};
  

///////////////////////////////////////////////////////////////////////
// CControlRightInfo

class CControlRightInfoArray; //fwd decl

class CControlRightInfo : public CBasicRightInfo
{
public:
  CControlRightInfo()
  {
    ZeroMemory(&m_rightsGUID, sizeof (GUID));
  }

  const GUID* GetRightsGUID() { return &m_rightsGUID;}
  LPCWSTR GetLdapDisplayName() { return m_szLdapDisplayName; }
  LPCWSTR GetLocalizedName() { return m_szLocalizedName; }

  BOOL IsPropertySet() 
  { 
    return ((m_fAccess & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)) != 0);
  }

  void SetLocalizedName(UINT nLocalizationDisplayId, HMODULE hModule);

private:
  GUID m_rightsGUID;
  CWString m_szLdapDisplayName; // this is from the schema, not localized
  CWString m_szLocalizedName;   // this is obtained from NTMARTA

  friend class CControlRightInfoArray;
};

///////////////////////////////////////////////////////////////////////
// CControlRightInfoArray 

class CControlRightInfoArray : public CGrowableArr<CControlRightInfo>
{
public:
  HRESULT InitFromDS(CAdsiObject* pADSIObj,
                         const GUID* pSchemaIDGUID);
};


///////////////////////////////////////////////////////////////////////
// CSchemaObjectInfo

class CSchemaObjectInfo
{
public:
	CSchemaObjectInfo(LPCWSTR lpszName)
	{
        m_bFilter = FALSE;
        if (lpszName != NULL)
        m_szName = lpszName;

        ZeroMemory(&m_schemaIDGUID, sizeof(GUID));
    }
	virtual ~CSchemaObjectInfo()
	{ 
	}

  void SetDisplayName(LPCWSTR lpszDisplayName) 
  { 
    //TRACE(_T("SetDisplayName(%s)\n"),lpszDisplayName); 
    m_szDisplayName = (lpszDisplayName != NULL) ? lpszDisplayName : m_szName;
    //TRACE(_T("m_szDisplayName = (%s)\n"),m_szDisplayName.c_str()); 
  }
  LPCWSTR GetName()
  { 
    return (m_szName.data()[0] == NULL) ? NULL : m_szName.c_str();
  }
  LPCWSTR GetDisplayName() 
  { 
    //TRACE(_T("GetDisplayName() m_szName = (%s) m_szDisplayName = (%s)\n"),
    //  m_szName.c_str(), m_szDisplayName.c_str()); 
    return (m_szDisplayName.data()[0] == NULL) ? NULL : m_szDisplayName.c_str();
  }

  const GUID* GetSchemaGUID()
  {
    return &m_schemaIDGUID;
  }

  bool operator<(CSchemaObjectInfo& x) 
  { 
    if ((GetDisplayName() == NULL) || (x.GetDisplayName() == NULL))
      return false;
    return (_wcsicmp(GetDisplayName(), x.GetDisplayName()) < 0);
  }

  void SetFiltered() { m_bFilter = TRUE;}
  BOOL IsFiltered() { return m_bFilter;}

protected:
  BOOL m_bFilter;
  CWString m_szName;
  CWString m_szDisplayName;
  GUID m_schemaIDGUID;

};

//////////////////////////////////////////////////////////////////////
// CPropertyRightInfo

class CPropertyRightInfoArray; // fwd decl

class CPropertyRightInfo : public CSchemaObjectInfo
{
public:
  CPropertyRightInfo(ULONG filterFlags, LPCWSTR lpszName) 
    : CSchemaObjectInfo(lpszName)
  {
    //TRACE(_T("CPropertyRightInfo(0x%x, %s)\n"),filterFlags, lpszName);
    m_FilterFlags = filterFlags;
    m_nRightCount = m_nRightCountMax;
    if (m_FilterFlags & IDC_PROP_NO_READ)
      m_nRightCount--;
    if (m_FilterFlags & IDC_PROP_NO_WRITE)
      m_nRightCount--;

    ASSERT(m_nRightCount > 0);
    m_Access = 0x0;
  }
  ~CPropertyRightInfo() {}

  static const ULONG m_nRightCountMax;
  static const ULONG m_nReadIndex;
  static const ULONG m_nWriteIndex;

  LPCWSTR GetRightDisplayString(ULONG iRight);
  void SetRight(ULONG iRight, BOOL b);
  ULONG GetRight(ULONG iRight);
  BOOL IsRightSelected(ULONG iRight);
  ULONG GetAccess() { return m_Access;}
  void AddAccessRight(ULONG uRight) { m_Access |= uRight;}
  ULONG GetRightCount() { return m_nRightCount;}

private:
  ULONG m_nRightCount;
  ULONG m_FilterFlags;
  ULONG m_Access;

  friend class CPropertyRightInfoArray;
};

//////////////////////////////////////////////////////////////////////
// CPropertyRightInfoArray

class CPropertyRightInfoFilter : public CFilterBase
{
public:
  virtual BOOL CanAdd(LPCWSTR lpsz, ULONG* pFilterFlags)
  {
    *pFilterFlags = ::GetAttributeFlags(m_szClassName, lpsz);
    if (*pFilterFlags == 0)
      return TRUE; // have no info, so add anyway
    if ((*pFilterFlags & IDC_PROP_NO) == IDC_PROP_NO)
      return FALSE; // have all the hide flags set
    return TRUE; // some of the hide flags not set

  }
  void SetClassName(LPCWSTR lpszClassName)
  {
    if (lpszClassName == NULL)
      m_szClassName = L"";
    else
      m_szClassName = lpszClassName;
  }
private:
  CWString m_szClassName;
};


class CPropertyRightInfoArray : public CGrowableArr<CPropertyRightInfo>
{
public:
  HRESULT InitFromSchema(CAdsiObject* pADSIObj, IADsClass* pDsSchemaClass, 
                         LPCWSTR lpszClassName, BOOL bUseFilter);
};

//////////////////////////////////////////////////////////////////////
// CClassRightInfo

class CClassRightInfoArray; // fwd decl.

class CClassRightInfo : public CSchemaObjectInfo
{
public:
  CClassRightInfo(ULONG filterFlags, LPCWSTR lpszName)
    : CSchemaObjectInfo(lpszName)
  {
    //TRACE(_T("CClassRightInfo(0x%x, %s)\n"),filterFlags, lpszName);

    m_FilterFlags = filterFlags;
    m_nRightCount = m_nRightCountMax;
    if (m_FilterFlags & IDC_CLASS_NO_CREATE)
      m_nRightCount--;
    if (m_FilterFlags & IDC_CLASS_NO_DELETE)
      m_nRightCount--;

    // REVIEW_MARCOC: do we need this?
    //if (m_FilterFlags & IDC_CLASS_NO_INHERIT)
    //  m_nRightCount--;

    ASSERT(m_nRightCount > 0);
    m_Access = 0x0;
  }
  ~CClassRightInfo() {}

  static const ULONG m_nRightCountMax;
  static const ULONG m_nCreateIndex;
  static const ULONG m_nDeleteIndex;

  LPCWSTR GetRightDisplayString(ULONG iRight);
  void SetRight(ULONG iRight, BOOL b);
  ULONG GetRight(ULONG iRight);
  BOOL IsRightSelected(ULONG iRight);
  ULONG GetAccess() { return m_Access;}
  void AddAccessRight(ULONG uRight) { m_Access |= uRight;}
  ULONG GetRightCount() { return m_nRightCount;}

private:
  ULONG m_nRightCount;
  ULONG m_FilterFlags;
  ULONG m_Access;

  friend class CClassRightInfoArray;

};

//////////////////////////////////////////////////////////////////////
// CClassRightInfoArray

class CClassRightInfoFilter : public CFilterBase
{
public:
  virtual BOOL CanAdd(LPCWSTR lpsz, ULONG* pFilterFlags)
  {
    *pFilterFlags = ::GetClassFlags(lpsz);
    if (*pFilterFlags == 0)
      return TRUE; // have no info, so add anyway
    if ((*pFilterFlags & IDC_CLASS_NO) == IDC_CLASS_NO)
      return FALSE; // have all the hide flags set
    return TRUE; // some of the hide flags not set
  }
};

class CClassRightInfoArray : public CGrowableArr<CClassRightInfo>
{
public:
  HRESULT InitFromSchema(CAdsiObject* pADSIObj, IADsClass* pDsSchemaClass, BOOL bUseFilter);
};


///////////////////////////////////////////////////////////////////////
// CSchemaClassInfo
#define CHILD_CLASS_NOT_EXIST   1
#define CHILD_CLASS_EXIST       2
#define CHILD_CLASS_NOT_CALCULATED  3

class CSchemaClassInfo : public CSchemaObjectInfo
{
public:
  CSchemaClassInfo(LPCWSTR lpszName, LPCWSTR lpszSchemaClassName,
                                     const GUID* pSchemaIDGUID)
                  : CSchemaObjectInfo(lpszName)
  { 
    m_szSchemaClassName = lpszSchemaClassName;
    m_schemaIDGUID = *pSchemaIDGUID;
    m_dwChildClass = CHILD_CLASS_NOT_CALCULATED;
    m_bSelected = FALSE;
	m_bAux = FALSE;
  }

  ~CSchemaClassInfo()
  {
  }

  VOID SetAux(){m_bAux=TRUE;}
  BOOL IsAux(){return m_bAux;}
  BOOL	m_bSelected;
  DWORD m_dwChildClass;
  LPCWSTR GetSchemaClassName() { return m_szSchemaClassName; }
private:
  CWString m_szSchemaClassName;
   BOOL  m_bAux;
};


////////////////////////////////////////////////////////////////////////
// CRigthsListViewItem

class CRigthsListViewItem
{
public:
  enum rightType { access, ctrl, prop, subobj };

  CRigthsListViewItem(ULONG iIndex, ULONG iRight, rightType type)
  {
    m_type = type;
    m_iIndex = iIndex;
    m_iRight = iRight;
  }

public:
  rightType m_type;
  ULONG m_iIndex;
  ULONG m_iRight;
};

typedef CGrowableArr<CRigthsListViewItem> CRigthsListViewItemArray;




///////////////////////////////////////////////////////////////////////
// CAccessPermissionsHolderBase

class CAccessPermissionsHolderBase
{
public:
  CAccessPermissionsHolderBase(BOOL bUseFilter);
  virtual ~CAccessPermissionsHolderBase();

  void Clear();

  // entry manipulation functions
  size_t GetTotalCount() 
  { 
    return m_accessRightInfoArr.GetCount() + m_controlRightInfoArr.GetCount()
      + m_propertyRightInfoArray.GetCount() + m_classRightInfoArray.GetCount();
  }

  BOOL HasPermissionSelected();
  
  // backend DS operations
  HRESULT ReadDataFromDS(CAdsiObject* pADSIObj,
                       LPCWSTR lpszObjectNamingContext,
                       LPCWSTR lpszClassName,
                       const GUID* pSchemaIDGUID,
                       BOOL bChildClass,
					   BOOL bHideListObject = FALSE);

  DWORD UpdateAccessList( CPrincipal* pPrincipal,
								          CSchemaClassInfo* pClassInfo,
                          LPCWSTR lpszServerName,
                          LPCWSTR lpszPhysicalSchemaNamingContext,
								          PACL* ppAcl);
protected:

  // standard access rigths
  CAccessRightInfoArray m_accessRightInfoArr; 
  virtual HRESULT _LoadAccessRightInfoArrayFromTable( BOOL bCreateDeleteChild,BOOL bHideListObject) = 0;

  // extended access rigths
  CControlRightInfoArray m_controlRightInfoArr;  


  // array of property rights
  CPropertyRightInfoArray	m_propertyRightInfoArray;

  // array of class rights
  CClassRightInfoArray	m_classRightInfoArray;

  // array of selections in the UI
  BOOL* m_pbSelectedArr;                // selected?

private:

  BOOL m_bUseFilter;

  HRESULT _ReadClassInfoFromDS(CAdsiObject* pADSIObj, LPCWSTR lpszClassName);
  
  DWORD _UpdateAccessListHelper(PSID pSid,
                         const GUID* pClassGUID,
                         PACL *ppAcl,
                         BOOL bChildClass);

};




///////////////////////////////////////////////////////////////////////
// CCustomAccessPermissionsHolder


// bitfields to keep track of the filtering state
#define FILTER_EXP_GEN    0x1
#define FILTER_EXP_PROP   0x2
#define FILTER_EXP_SUBOBJ 0x4
#define FILTER_EXP_GEN_DISABLED 0x8


class CCheckListViewHelper; // fwd decl

class CCustomAccessPermissionsHolder : public CAccessPermissionsHolderBase
{
public:
  CCustomAccessPermissionsHolder();
  virtual ~CCustomAccessPermissionsHolder();

  void Clear();

  // entry manipulation functions

  void Select(IN CRigthsListViewItem* pItem,
              IN BOOL bSelect,
              OUT ULONG* pnNewFilterState);

  void FillAccessRightsListView(
                       CCheckListViewHelper* pListViewHelper, 
                       ULONG nFilterState);

  void UpdateAccessRightsListViewSelection(
                       CCheckListViewHelper* pListViewHelper, 
                       ULONG nFilterState);

  // display finish page summary info
  void WriteSummary(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);

protected:
  virtual HRESULT _LoadAccessRightInfoArrayFromTable(BOOL bCreateDeleteChild,BOOL bHideListObject);

private:
  
  // helper functions to do selection and deselection
  void _SelectAllRigths();
  void _SelectAllPropertyRigths(ULONG fAccessPermission);
  void _SelectAllSubObjectRigths(ULONG fAccessPermission);
  void _DeselectAssociatedRights(ULONG fAccessPermission);

  // array of listview items, for indexing
  CRigthsListViewItemArray m_listViewItemArr;

};



///////////////////////////////////////////////////////////////////////
// CCheckListViewHelper

class CCheckListViewHelper
{
public:
	static BOOL CheckChanged(NM_LISTVIEW* pNMListView);
	static BOOL IsChecked(NM_LISTVIEW* pNMListView);

	CCheckListViewHelper()
	{
		m_hWnd = NULL;
	}

	BOOL Initialize(UINT nID, HWND hParent);
	int InsertItem(int iItem, LPCTSTR lpszText, LPARAM lParam, BOOL bCheck);
	BOOL SetItemCheck(int iItem, BOOL bCheck);
	void SetCheckAll(BOOL bCheck);
	LPARAM GetItemData(int iItem);
  BOOL IsItemChecked(int iItem);
	int GetCheckCount();
	void GetCheckedItems(int nCheckCount, int* nCheckArray);

	BOOL GetCheckState(int iItem)
	{
		return ListView_GetCheckState(m_hWnd,iItem);
	}
	int GetItemCount()
	{
		return ListView_GetItemCount(m_hWnd);
	}

	BOOL DeleteAllItems()
	{
		return ListView_DeleteAllItems(m_hWnd);
	}
	void EnableWindow(BOOL bEnable)
	{
		::EnableWindow(m_hWnd, bEnable);
	}
private:
	HWND m_hWnd;
};

////////////////////////////////////////////////////////////////////////////
// CNamedSecurityInfo
/*
class CNamedSecurityInfo
{
public:
  CNamedSecurityInfo()
  {
    m_pAuditList = NULL;
    m_pOwner = NULL;
    m_pGroup = NULL;

    m_pAccessList = NULL;
  }
  ~CNamedSecurityInfo()
  {
    Reset();
  }

  DWORD Get();
  DWORD Set();
  void Reset();

private:
  CWString m_szObjectName; // name of the object

 	// the following varables are just read and written back
	// i.e. no modification
  PACTRL_AUDIT m_pAuditList;
  LPWSTR m_pOwner;
  LPWSTR m_pGroup;

  // list to be edited and written back
  PACTRL_ACCESS m_pAccessList;

};
*/

////////////////////////////////////////////////////////////////////////////
// CAdsPathNameObj

class CAdsPathNameObj
{
public:
  CAdsPathNameObj(){}
  ~CAdsPathNameObj(){ m_spADsPath = NULL;}

  HRESULT SkipPrefix(LPCWSTR pwzObj, BSTR* pBstr)
  {
    HRESULT hr = _Create();
    if (FAILED(hr))
  	  return hr;

    hr = m_spADsPath->Set((PWSTR)pwzObj, ADS_SETTYPE_FULL);
    if (FAILED(hr))
  	  return hr;

    hr = m_spADsPath->Retrieve(ADS_FORMAT_X500_DN, pBstr);
    return hr;
  }
  HRESULT SkipPrefix(LPCWSTR pwzObj, CWString& str)
  {
    CComBSTR b;
    HRESULT hr = SkipPrefix(pwzObj, &b);
    if (FAILED(hr))
    {
      str = L"";
    }
    else
    {
      str = b;
    }
    return hr;
  }
  HRESULT GetProvider(LPCWSTR pwzObj, BSTR* pBstr)
  {
    HRESULT hr = _Create();
    if (FAILED(hr))
  	  return hr;

    hr = m_spADsPath->Set((PWSTR)pwzObj, ADS_SETTYPE_FULL);
    if (FAILED(hr))
  	  return hr;

    hr = m_spADsPath->Retrieve(ADS_FORMAT_PROVIDER, pBstr);
    return hr;
  }

private:
  CComPtr<IADsPathname>		m_spADsPath;

  HRESULT _Create()
  {
    HRESULT hr = S_OK;
    if (m_spADsPath == NULL)
    {
      hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                            IID_IADsPathname, (PVOID *)&m_spADsPath);
    }
    return hr;
  }

};








////////////////////////////////////////////////////////////////////////////
// CAdsiObject

class CAdsiObject
{
public:
	CAdsiObject():m_iListObjectEnforced(-1)
	{ _Clear(); }
  virtual ~CAdsiObject(){}

  virtual HRESULT Bind(LPCWSTR lpszLdapPath);
  BOOL IsBound() { return m_spIADs != NULL; }
  HRESULT QuerySchemaClasses(CGrowableArr<CSchemaClassInfo>*	pSchemaClassesInfoArray,
                             BOOL bGetAttributes = FALSE);

  // accessor functions
  LPCWSTR GetLdapPath() { return m_szLdapPath; }
  LPCWSTR GetServerName() { return m_szServerName; }
  LPCWSTR GetNamingContext() { return m_szNamingContext; }
  LPCWSTR GetCanonicalName() { return m_szCanonicalName; }
  LPCWSTR GetClass() { return m_szClass; }
  LPCWSTR GetPhysicalSchemaNamingContext() { return m_szPhysicalSchemaNamingContext;}
  LPCWSTR GetConfigurationNamingContext() { return m_szConfigurationNamingContext;}

  // methods to access display specifiers
  HICON   GetClassIcon(LPCWSTR lpszObjectClass);
  HRESULT GetFriendlyClassName(LPCWSTR lpszObjectClass, 
                               LPWSTR lpszBuffer, int cchBuffer);
  HRESULT GetFriendlyAttributeName(LPCWSTR lpszObjectClass, 
                                   LPCWSTR lpszAttributeName,
                                   LPWSTR lpszBuffer, int cchBuffer);


  HRESULT GetClassGuid(LPCWSTR lpszClassLdapDisplayName, BOOL bGetAttribute, GUID& guid);

  CAdsPathNameObj* GetPathNameObject()
  {
    return &m_pathNameObject;
  }

  bool GetListObjectEnforced();

protected:
  CComPtr<IADs>                     m_spIADs;                 // pointer to ADSI object

private:

  int m_iListObjectEnforced;			
  CComPtr<IDsDisplaySpecifier>      m_spIDsDisplaySpecifier;  // pointer to Display Specifier Cache
  CAdsPathNameObj                   m_pathNameObject;         // path cracker object wrapper

  // cached naming strings
  CWString           m_szServerName;     // DNS name the object is bound to ("foo.bar.com.")
  CWString           m_szNamingContext;  // naming context (X500) ("cn=xyz,...");
	CWString						m_szLdapPath;		    // full LDAP path ("LDAP://foo.bar.com.\cn=xyz,...")
  CWString           m_szCanonicalName;  // name in canonical form
  CWString           m_szClass;          // class name in abstract schema, corresponding to 
                                        // LDAPDisplayName attribute in physical schema, 
                                        // (e.g. "organizationalUnit")

  // commonly used naming contexts
  CWString           m_szPhysicalSchemaNamingContext;
  CWString           m_szConfigurationNamingContext;

  void _Clear()
  {
    m_spIADs = NULL;
    m_spIDsDisplaySpecifier = NULL;
    m_szServerName = L"";
    m_szLdapPath = L"";
    m_szCanonicalName = L"";
    m_szClass = L"";

    m_szPhysicalSchemaNamingContext = L"";
    m_szConfigurationNamingContext = L"";
  }

  HRESULT _QueryDNSServerName();
  HRESULT _InitGlobalNamingContexts();

  HRESULT _GetFriendlyClassNames(CGrowableArr<CSchemaClassInfo>*	pSchemaClassesInfoArray);
  

};

////////////////////////////////////////////////////////////////////////////////////////
// CAdsiSearch

class CAdsiSearch
{
public:
  CAdsiSearch()
  {
    m_SearchHandle = NULL;
  }
  ~CAdsiSearch()
  {
    Reset();
  }

  HRESULT Init(LPCWSTR lpszObjectPath)
  {
    Reset();
    return ::ADsOpenObjectHelper(lpszObjectPath, IID_IDirectorySearch,
                    (void**)&m_spSearchObj);
  }

  void Reset()
  {
    if (m_spSearchObj != NULL) 
    {
      if (m_SearchHandle != NULL) 
      {
        m_spSearchObj->CloseSearchHandle(m_SearchHandle);
        m_SearchHandle = NULL;
      }
    }
    m_spSearchObj = NULL;
  }

  HRESULT SetSearchScope(ADS_SCOPEENUM scope)
  {
    if (m_spSearchObj == NULL)
      return E_ADS_BAD_PATHNAME;

    ADS_SEARCHPREF_INFO aSearchPref;
    aSearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    aSearchPref.vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref.vValue.Integer = scope;
    return m_spSearchObj->SetSearchPreference(&aSearchPref, 1);
  }

  HRESULT DoQuery(LPCWSTR lpszFilter, LPCWSTR* pszAttribsArr, const int cAttrs);

  HRESULT GetNextRow()
  {
    if (m_spSearchObj == NULL)
      return E_ADS_BAD_PATHNAME;
    return m_spSearchObj->GetNextRow(m_SearchHandle);
  }

  HRESULT GetColumn(LPCWSTR lpszAttribute,
                     PADS_SEARCH_COLUMN pColumnData)
  {
    if (m_spSearchObj == NULL)
      return E_ADS_BAD_PATHNAME;

    return m_spSearchObj->GetColumn(m_SearchHandle,
                              (LPWSTR)lpszAttribute,
                              pColumnData);
  }
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData)
  {
    if (m_spSearchObj == NULL)
      return E_ADS_BAD_PATHNAME;
    return m_spSearchObj->FreeColumn(pColumnData);
  }

  HRESULT GetColumnString(LPCWSTR lpszAttribute,
                     CWString& szData)
  {
    ADS_SEARCH_COLUMN ColumnData;
    ::ZeroMemory (&ColumnData, sizeof (ADS_SEARCH_COLUMN));
    HRESULT hr = GetColumn(lpszAttribute, &ColumnData);
    if (SUCCEEDED(hr))
    {
      if (ColumnData.dwADsType == ADSTYPE_CASE_IGNORE_STRING)
        szData = ColumnData.pADsValues->CaseIgnoreString;
      else
      {
        szData = L"";
        hr = E_INVALIDARG;
      }
      FreeColumn(&ColumnData);
    }
    return hr;
  }

  HRESULT GetColumnOctectStringGUID(LPCWSTR lpszAttribute,
                     GUID& guid)
  {
    ADS_SEARCH_COLUMN ColumnData;
    ::ZeroMemory (&ColumnData, sizeof (ADS_SEARCH_COLUMN));
    HRESULT hr = GetColumn(lpszAttribute, &ColumnData);
    if (SUCCEEDED(hr))
    {
      if ( (ColumnData.dwADsType == ADSTYPE_OCTET_STRING) &&
            (ColumnData.pADsValues->OctetString.dwLength == 16) )
      {
        // we have a blob containing a GUID in binary form
        memcpy(&guid, ColumnData.pADsValues->OctetString.lpValue, sizeof(GUID));
      }
      else
      {
        guid = GUID_NULL;
        hr = E_INVALIDARG;
      }
      FreeColumn(&ColumnData);
    }
    return hr;
  }

  HRESULT GetColumnOctectStringGUID(LPCWSTR lpszAttribute,
                     CWString& szData)
  {
    GUID guid;
    szData = L"";
    HRESULT hr = GetColumnOctectStringGUID(lpszAttribute, guid);
    if (SUCCEEDED(hr))
    {
      WCHAR szBuf[128];
      if (FormatStringGUID(szBuf, 128, &guid))
      {
        szData = szBuf;
      }
      else
      {
        szData = L"";
        hr = E_INVALIDARG;
      }
    }
    return hr;
  }

  HRESULT GetColumnInteger(LPCWSTR lpszAttribute,
                        ULONG& uVal)
  {
    ADS_SEARCH_COLUMN ColumnData;
    ::ZeroMemory (&ColumnData, sizeof (ADS_SEARCH_COLUMN));
    HRESULT hr = GetColumn(lpszAttribute, &ColumnData);
    if (SUCCEEDED(hr))
    {
      if (ColumnData.dwADsType == ADSTYPE_INTEGER)
        uVal = ColumnData.pADsValues->Integer;
      else
        hr = E_INVALIDARG;
      FreeColumn(&ColumnData);
    }
    return hr;
  }

private:
  CComPtr<IDirectorySearch> m_spSearchObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

};

///////////////////////////////////////////////////////////////////////
// CErrorMessageHandlerBase

class CErrorMessageHandlerBase
{
public:
  CErrorMessageHandlerBase() {}
  virtual ~CErrorMessageHandlerBase() {}

  virtual void ReportHRESULTError(LPCWSTR lpszMsg, HRESULT hr) 
  {
      UNREFERENCED_PARAMETER (lpszMsg);
      UNREFERENCED_PARAMETER (hr);
  }
  virtual void ReportHRESULTError(UINT nStringID, HRESULT hr) 
  {
      UNREFERENCED_PARAMETER (nStringID);
      UNREFERENCED_PARAMETER (hr);
  }
};


DWORD
FormatStringID(LPTSTR *ppszResult, UINT idStr , ...);

#endif // _UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\common\_util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       _util.cpp
//
//--------------------------------------------------------------------