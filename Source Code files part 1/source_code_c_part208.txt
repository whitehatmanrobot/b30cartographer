                                  (LPSTR)lpValueBuf,
                                                             pTotalSize);
                } 
            }
            RpcEndExcept

        }
    }
    if (Error == ERROR_SUCCESS) {
        //
        // Convert results back.
        //
        for (i=0; i < num_vals; i++) {
            val_list[i].ve_valuelen = Values[i].rv_valuelen;
            val_list[i].ve_valueptr = (DWORD_PTR)((LPCSTR)lpValueBuf + Values[i].rv_valueptr);
            val_list[i].ve_type = Values[i].rv_type;
        }
    }

error_exit:
    for (i=0; i < num_vals; i++) {
        if (Names[i].Buffer != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, Names[i].Buffer);
        }
    }

    RtlFreeHeap(RtlProcessHeap(),0,Values);
    RtlFreeHeap(RtlProcessHeap(),0,Names);

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\shutinit.c ===
#include <shutinit_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regsval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    set value APIs. That is:

        - RegSetValueA
        - RegSetValueW
        - RegSetValueExA
        - RegSetValueExW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regsval.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <string.h>
#include <wow64reg.h>


LONG
RegSetValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Win 3.1 ANSI RPC wrapper for setting a value.

--*/

{
    HKEY        ChildKey;
    LONG        Error;
    HKEY        TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Check the value type for compatability w/Win 3.1
    //

    if( (dwType != REG_SZ) || (lpData == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Win3.1ism - Win 3.1 ignores the cbData parameter so it is computed
    // here instead as the length of the string plus the NUL character.
    //

    cbData = strlen( lpData ) + 1;


    //
    // If the sub-key is NULL or points to an empty string then the value is
    // set in this key (i.e.  hKey) otherwise the sub-key needs to be
    // opened/created.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        ChildKey = hKey;

    } else {

        //
        // The sub-key was supplied so attempt to open/create it.
        //

        Error = RegCreateKeyExA(
                    hKey,
                    lpSubKey,
                    0,
                    WIN31_CLASS,
                    0,
                    KEY_SET_VALUE,
                    NULL,
                    &ChildKey,
                    NULL
                    );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }
    }

    //
    // ChildKey contains an HKEY which may be the one supplied (hKey) or
    // returned from RegCreateKeyA. Set the value using the special value
    // name NULL.
    //

    Error = RegSetValueExA(
                ChildKey,
                NULL,
                0,
                dwType,
                lpData,
                cbData
                );

    //
    // If the sub key was opened, close it.
    //

    if( ChildKey != hKey ) {

        Error = RegCloseKey( ChildKey );
        ASSERT( Error == ERROR_SUCCESS );
    }

    //
    // Return the results of setting the value.
    //

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
RegSetValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for setting a value.

--*/

{
    HKEY        ChildKey;
    LONG        Error;
    HKEY        TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Check the value type for compatability w/Win 3.1
    //

    if( (dwType != REG_SZ) || (lpData == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle);
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Win3.1ism - Win 3.1 ignores the cbData parameter so it is computed
    // here instead as the length of the string plus the UNICODE_NUL
    // character.
    //

    cbData = wcslen( lpData ) * sizeof( WCHAR ) + sizeof( UNICODE_NULL );;

    //
    // If the sub-key is NULL or points to an empty string then the value is
    // set in this key (i.e.  hKey) otherwise the sub-key needs to be
    // opened/created.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        ChildKey = hKey;

    } else {

        //
        // The sub-key was supplied attempt to open/create it.
        //

        Error = RegCreateKeyExW(
                    hKey,
                    lpSubKey,
                    0,
                    WIN31_CLASS,
                    0,
                    KEY_SET_VALUE,
                    NULL,
                    &ChildKey,
                    NULL
                    );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }
    }

    //
    // ChildKey contains an HKEY which may be the one supplied (hKey) or
    // returned from RegCreateKeyW. Set the value using the special value
    // name NULL.
    //

    Error = RegSetValueExW(
                ChildKey,
                NULL,
                0,
                dwType,
                ( LPBYTE ) lpData,
                cbData
                );

    //
    // If the sub key was opened/created, close it.
    //

    if( ChildKey != hKey ) {

        RegCloseKey( ChildKey );
    }

    //
    // Return the results of querying the value.
    //

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSetValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for setting a value.

    RegSetValueExA converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegSetValue.

--*/

{
    PUNICODE_STRING     ValueName;
    UNICODE_STRING      TempValueName;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    LPBYTE              ValueData;

    PSTR                AnsiValueBuffer;
    ULONG               AnsiValueLength;
    PWSTR               UnicodeValueBuffer;
    ULONG               UnicodeValueLength;
    ULONG               Index;

    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Ensure Reserved is zero to avoid future compatability problems.
    //

    if( Reserved != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode string 
    //
    if ( lpValueName ) {

        //
        // Convert the SubKey name to a counted Unicode 
        //
        if( !RtlCreateUnicodeStringFromAsciiz(&TempValueName,lpValueName) ) {
            Status = STATUS_NO_MEMORY;
            Error = RtlNtStatusToDosError( Status );
            goto ExitCleanup;
        }

        ValueName = &TempValueName;

        //
        //  Add the NULL to the Length, so that RPC will transmit it
        //
        ValueName->Length += sizeof( UNICODE_NULL );

        if( ValueName->Length == 0 ) {
            //
            // overflow in RtlCreateUnicodeStringFromAsciiz
            //
            Error = ERROR_INVALID_PARAMETER;
            goto ExitCleanup;
        }
    } else {

        //
        //  No name was passed. Use our internal UNICODE string
        //  and set its fields to NULL. We don't use the static
        //  unicode string in the TEB in this case because we
        //  can't mess with its Buffer and MaximumLength fields.
        //
        ValueName = &UnicodeString;
        ValueName->Length           = 0;
        ValueName->MaximumLength    = 0;
        ValueName->Buffer           = NULL;
    }

    //
    // If type is one of the null terminated string types, then do the ANSI to
    // UNICODE translation into an allocated buffer.
    //
    ValueData = ( LPBYTE )lpData;
    if( (ValueData != NULL) && (dwType == REG_SZ || dwType == REG_EXPAND_SZ || dwType == REG_MULTI_SZ)) {

        //
        // Special hack to help out all the people who
        // believe the length of a NULL terminated string is
        // strlen(foo) instead of strlen(foo) + 1.
        //
        if ((cbData > 0) &&
            (lpData[cbData-1] != 0)) {
            //
            // Do this under an exception handler in case the last
            // little bit crosses a page boundary.
            //
            try {
                if (lpData[cbData] == 0) {
                    cbData += 1;        // increase string length to account for NULL terminator
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                ; // guess they really really did not want a NULL terminator

            }
        }
        AnsiValueBuffer        = ValueData;
        AnsiValueLength        = cbData;

        UnicodeValueLength = cbData * sizeof( WCHAR );
        UnicodeValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                              UnicodeValueLength
                                            );
        if (UnicodeValueBuffer == NULL) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            Status = RtlMultiByteToUnicodeN( UnicodeValueBuffer,
                                             UnicodeValueLength,
                                             &Index,
                                             AnsiValueBuffer,
                                             AnsiValueLength
                                           );
            if (!NT_SUCCESS( Status )) {
                Error = RtlNtStatusToDosError( Status );
            } else {
                ValueData   = (LPBYTE)UnicodeValueBuffer;
                cbData      = Index;
                Error       = ERROR_SUCCESS;
            }
        }
    } else {
        Error = ERROR_SUCCESS;
    }

    if ( Error == ERROR_SUCCESS ) {

        //
        // Call the Base API, passing it the supplied parameters and the
        // counted Unicode strings.
        //

        if( IsLocalHandle( hKey )) {

            Error =  (LONG)LocalBaseRegSetValue (
                                hKey,
                                ValueName,
                                dwType,
                                ValueData,
                                cbData
                                );
#if defined(_WIN64)
            if ( Error == 0)
                Wow64RegSetKeyDirty (hKey);
#endif
        } else {

            Error =  (LONG)BaseRegSetValue (
                                DereferenceRemoteHandle( hKey ),
                                ValueName,
                                dwType,
                                ValueData,
                                cbData
                                );
        }
    }

    if( ValueData != lpData ) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValueBuffer );
    }
    if ( lpValueName ) {
        // free the allocated unicode string
        RtlFreeUnicodeString( &TempValueName );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for setting a value.

    RegSetValueExW converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegSetValue.

--*/

{
    UNICODE_STRING      ValueName;
    UNALIGNED WCHAR     *String;
    DWORD               StringLength;
    LONG                Error;
    HKEY                TempHandle = NULL;
    ULONG               Length;
    NTSTATUS            Status;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    if ((hKey == HKEY_PERFORMANCE_TEXT) ||
        (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        return(PerfRegSetValue(hKey,
                               ( LPWSTR )lpValueName,
                               Reserved,
                               dwType,
                               ( LPBYTE )lpData,
                               cbData));
    }

    //
    // Ensure Reserved is zero to avoid future compatability problems.
    //

    if( Reserved != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Special hack to help out all the people who
    // believe the length of a NULL terminated string is
    // strlen(foo) instead of strlen(foo) + 1.
    //
    String = (UNALIGNED WCHAR *)lpData;
    StringLength = cbData/sizeof(WCHAR);
    if( ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ) || (dwType == REG_MULTI_SZ)) &&
        (String != NULL) &&
        (StringLength > 0) &&
        (String[StringLength-1] != 0)) {
        //
        // Do this under an exception handler in case the last
        // little bit crosses a page boundary.
        //
        try {
            if (String[StringLength] == 0) {
                cbData += sizeof(WCHAR);        // increase string length to account for NULL terminator
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ; // guess they really really did not want a NULL terminator

        }
    }


    if( lpValueName != NULL ) {
        Length = wcslen( lpValueName ) * sizeof( WCHAR );    
        ValueName.Length = (USHORT)Length;
        if( Length != (ULONG)ValueName.Length ) {
            //
            // 32K overflow
            //
            Error = ERROR_INVALID_PARAMETER;
            goto ExitCleanup;
        }
    }
    //
    // Convert the value name to a counted Unicode string.
    // This also acounts for the NULL we are adding at the end
    //
    Status = RtlInitUnicodeStringEx(&ValueName, lpValueName);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the Length, so that RPC will transmit it
    //
    ValueName.Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSetValue (
                        hKey,
                        &ValueName,
                        dwType,
                        ( LPBYTE )lpData,
                        cbData
                        );
#if defined(_WIN64)
            if ( Error == 0)
                Wow64RegSetKeyDirty (hKey);
#endif

    } else {

        Error = (LONG)BaseRegSetValue (
                        DereferenceRemoteHandle( hKey ),
                        &ValueName,
                        dwType,
                        ( LPBYTE )lpData,
                        cbData
                        );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\shutdown.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Shutdown.c

Abstract:

    This module contains the client side wrappers for the Win32 remote
    shutdown APIs, that is:

        - InitiateSystemShutdownA
        - InitiateSystemShutdownW
        - AbortSystemShutdownA
        - AbortSystemShutdownW

Author:

    Dave Chalmers (davidc) 29-Apr-1992

Notes:


Revision History:
    
    Dragos C. Sambotin (dragoss) 21-May-1999
        Added support for the new winlogon's Shutdown interface


--*/


#define UNICODE

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include "shutinit.h"
#include "..\regconn\regconn.h"

LONG
BaseBindToMachine(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    );

LONG
ShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PUNICODE_STRING Message,
    IN PVOID Context2
    );

LONG
ShutdownCallbackEx(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PUNICODE_STRING Message,
    IN PVOID Context2
    );

LONG
AbortShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Context1,
    IN PVOID Context2
    );

BOOL
APIENTRY
InitiateSystemShutdownW(
    IN LPWSTR lpMachineName OPTIONAL,
    IN LPWSTR lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown    
    )

/*++

Routine Description:

    Win32 Unicode API for initiating the shutdown of a (possibly remote) machine.

Arguments:

    lpMachineName - Name of machine to shutdown.

    lpMessage -     Message to display during shutdown timeout period.
                           if Message(comment) is longer than MAX_REASON_COMMENT_LEN
                           return FALSE.(ERROR_INVALID_PARAMETER)
                           
    dwTimeout -     Number of seconds to delay before shutting down
                           if dwTimeout is larger than MAX_SHUTDOWN_TIMEOUT,
                           return FALSE. (ERROR_INVALID_PARAMETER)
                           
    bForceAppsClosed - Normally applications may prevent system shutdown.
                    If this flag is set, all applications are terminated
                    unconditionally.

    bRebootAfterShutdown - TRUE if the system should reboot.
                    FALSE if it should be left in a shutdown state.

Return Value:

    Returns TRUE on success, FALSE on failure (GetLastError() returns error code)

    Possible errors :

        ERROR_SHUTDOWN_IN_PROGRESS - a shutdown has already been started on
                                     the specified machine.

--*/

{
    DWORD Result;
    UNICODE_STRING  Message;
    SHUTDOWN_CONTEXT ShutdownContext;
    BOOL    TryOld = TRUE;

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(lpMachineName)) {
        lpMachineName = L"";
        TryOld = FALSE;
    }

    ShutdownContext.dwTimeout = dwTimeout;
    ShutdownContext.bForceAppsClosed = (bForceAppsClosed != 0);
    ShutdownContext.bRebootAfterShutdown = (bRebootAfterShutdown != 0);
    RtlInitUnicodeString(&Message, lpMessage);

    if ( ( Message.Length / sizeof(WCHAR) <  MAX_REASON_COMMENT_LEN ) &&
    	   ( dwTimeout < MAX_SHUTDOWN_TIMEOUT ) ){
	    //
	    // Call the server
	    //
	    
	    //
	    // First try to connect to the new InitShutdown interface
	    //
	    Result = BaseBindToMachineShutdownInterface(lpMachineName,
	                                                NewShutdownCallback,
	                                                &Message,
	                                                &ShutdownContext);

	    if( (Result != ERROR_SUCCESS) && (TryOld == TRUE) ) {
	        //
	        // try the old one, maybe we are calling into a NT4 machine
	        // which doesn't know about the new interface
	        //
	        Result = BaseBindToMachine(lpMachineName,
	                                   ShutdownCallback,
	                                   &Message,
	                                   &ShutdownContext);
	    }
    } 
    else{
    	 Result = ERROR_INVALID_PARAMETER;
    }    	

    if (Result != ERROR_SUCCESS) {
        SetLastError(Result);
    }

    return(Result == ERROR_SUCCESS);
}


BOOL
APIENTRY
InitiateSystemShutdownExW(
    IN LPWSTR lpMachineName OPTIONAL,
    IN LPWSTR lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown,
    IN DWORD dwReason
    )

/*++

Routine Description:

    Win32 Unicode API for initiating the shutdown of a (possibly remote) machine.

Arguments:

    lpMachineName - Name of machine to shutdown.

    lpMessage -     Message to display during shutdown timeout period.
                           if Message(comment) is longer than MAX_REASON_COMMENT_LEN
                           return FALSE.(ERROR_INVALID_PARAMETER)

    dwTimeout -     Number of seconds to delay before shutting down
                           if dwTimeout is larger than MAX_SHUTDOWN_TIMEOUT,
                           return FALSE. (ERROR_INVALID_PARAMETER)

    bForceAppsClosed - Normally applications may prevent system shutdown.
                    If this flag is set, all applications are terminated
                    unconditionally.

    bRebootAfterShutdown - TRUE if the system should reboot.
                    FALSE if it should be left in a shutdown state.

    dwReason        - Reason for initiating the shutdown.  This reason is logged
                        in the eventlog #6006 event.

Return Value:

    Returns TRUE on success, FALSE on failure (GetLastError() returns error code)

    Possible errors :

        ERROR_SHUTDOWN_IN_PROGRESS - a shutdown has already been started on
                                     the specified machine.

--*/

{
    DWORD Result;
    UNICODE_STRING  Message;
    SHUTDOWN_CONTEXTEX ShutdownContext;
    BOOL    TryOld = TRUE;

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(lpMachineName)) {
        lpMachineName = L"";
        TryOld = FALSE;
    }

    ShutdownContext.dwTimeout = dwTimeout;
    ShutdownContext.bForceAppsClosed = (bForceAppsClosed != 0);
    ShutdownContext.bRebootAfterShutdown = (bRebootAfterShutdown != 0);
    ShutdownContext.dwReason = dwReason;
    RtlInitUnicodeString(&Message, lpMessage);

    if ( ( Message.Length / sizeof(WCHAR) < MAX_REASON_COMMENT_LEN ) &&
    	   ( dwTimeout < MAX_SHUTDOWN_TIMEOUT ) ) {
	    	
	    //
	    // Call the server
	    //

	    //
	    // First try to connect to the new InitShutdown interface
	    //
	    Result = BaseBindToMachineShutdownInterface(lpMachineName,
	                                                NewShutdownCallbackEx,
	                                                &Message,
	                                                &ShutdownContext);

	    if( (Result != ERROR_SUCCESS) && (TryOld == TRUE) ) {
	        //
	        // try the old one, maybe we are calling into a NT4 machine
	        // which doesn't know about the new interface
	        //
	        Result = BaseBindToMachine(lpMachineName,
	                                   ShutdownCallbackEx,
	                                   &Message,
	                                   &ShutdownContext);
	    }
    }
    else{
    	Result = ERROR_INVALID_PARAMETER;
   }
    	

    if (Result != ERROR_SUCCESS) {
        SetLastError(Result);
    }

    return(Result == ERROR_SUCCESS);
}


BOOL
APIENTRY
InitiateSystemShutdownA(
    IN LPSTR lpMachineName OPTIONAL,
    IN LPSTR lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown
    )

/*++

Routine Description:

    See InitiateSystemShutdownW

--*/

{
    UNICODE_STRING      MachineName;
    UNICODE_STRING      Message;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    BOOL                Result;

    //
    // Convert the ansi machinename to wide-character
    //

    RtlInitAnsiString( &AnsiString, lpMachineName );
    Status = RtlAnsiStringToUnicodeString(
                &MachineName,
                &AnsiString,
                TRUE
                );

    if( NT_SUCCESS( Status )) {

        //
        // Convert the ansi message to wide-character
        //

        RtlInitAnsiString( &AnsiString, lpMessage );
        Status = RtlAnsiStringToUnicodeString(
                    &Message,
                    &AnsiString,
                    TRUE
                    );

        if (NT_SUCCESS(Status)) {

            //
            // Call the wide-character api
            //

            Result = InitiateSystemShutdownW(
                                MachineName.Buffer,
                                Message.Buffer,
                                dwTimeout,
                                bForceAppsClosed,
                                bRebootAfterShutdown                                
                                );

            RtlFreeUnicodeString(&Message);
        }

        RtlFreeUnicodeString(&MachineName);
    }

    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        Result = FALSE;
    }

    return(Result);
}


BOOL
APIENTRY
InitiateSystemShutdownExA(
    IN LPSTR lpMachineName OPTIONAL,
    IN LPSTR lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown,
    IN DWORD dwReason
    )

/*++

Routine Description:

    See InitiateSystemShutdownW

--*/

{
    UNICODE_STRING      MachineName;
    UNICODE_STRING      Message;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    BOOL                Result;

    //
    // Convert the ansi machinename to wide-character
    //

    RtlInitAnsiString( &AnsiString, lpMachineName );
    Status = RtlAnsiStringToUnicodeString(
                &MachineName,
                &AnsiString,
                TRUE
                );

    if( NT_SUCCESS( Status )) {

        //
        // Convert the ansi message to wide-character
        //

        RtlInitAnsiString( &AnsiString, lpMessage );
        Status = RtlAnsiStringToUnicodeString(
                    &Message,
                    &AnsiString,
                    TRUE
                    );

        if (NT_SUCCESS(Status)) {

            //
            // Call the wide-character api
            //

            Result = InitiateSystemShutdownExW(
                                MachineName.Buffer,
                                Message.Buffer,
                                dwTimeout,
                                bForceAppsClosed,
                                bRebootAfterShutdown,
                                dwReason
                                );

            RtlFreeUnicodeString(&Message);
        }

        RtlFreeUnicodeString(&MachineName);
    }

    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        Result = FALSE;
    }

    return(Result);
}



BOOL
APIENTRY
AbortSystemShutdownW(
    IN LPWSTR lpMachineName OPTIONAL
    )

/*++

Routine Description:

    Win32 Unicode API for aborting the shutdown of a (possibly remote) machine.

Arguments:

    lpMachineName - Name of target machine.

Return Value:

    Returns TRUE on success, FALSE on failure (GetLastError() returns error code)

--*/

{
    DWORD   Result;
    RPC_BINDING_HANDLE binding;
    BOOL    TryOld = TRUE;

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(lpMachineName)) {
        lpMachineName = L"";
        TryOld = FALSE;
    }

    //
    // Call the server
    //

    //
    // First try to connect to the new InitShutdown interface
    //
    Result = BaseBindToMachineShutdownInterface(lpMachineName,
                                                NewAbortShutdownCallback,
                                                NULL,
                                                NULL);

    if( (Result != ERROR_SUCCESS) && (TryOld == TRUE) ) {
        //
        // try the old one, maybe we are calling into a NT4 machine
        // which doesn't know about the new interface
        Result = BaseBindToMachine(lpMachineName,
                                   AbortShutdownCallback,
                                   NULL,
                                   NULL);
    }

    if (Result != ERROR_SUCCESS) {
        SetLastError(Result);
    }

    return(Result == ERROR_SUCCESS);
}



BOOL
APIENTRY
AbortSystemShutdownA(
    IN LPSTR lpMachineName OPTIONAL
    )

/*++

Routine Description:

    See AbortSystemShutdownW

--*/

{
    UNICODE_STRING      MachineName;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    BOOL                Result;

    //
    // Convert the ansi machinename to wide-character
    //

    RtlInitAnsiString( &AnsiString, lpMachineName );
    Status = RtlAnsiStringToUnicodeString(
                &MachineName,
                &AnsiString,
                TRUE
                );

    if( NT_SUCCESS( Status )) {

        //
        // Call the wide-character api
        //

        Result = AbortSystemShutdownW(
                            MachineName.Buffer
                            );

        RtlFreeUnicodeString(&MachineName);
    }


    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        Result = FALSE;
    }

    return(Result);
}

LONG
ShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PUNICODE_STRING Message,
    IN PSHUTDOWN_CONTEXT ShutdownContext
    )
/*++

Routine Description:

    Callback for binding to a machine to initiate a shutdown.

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

    Message - Supplies message to display during shutdown timeout period.

    ShutdownContext - Supplies remaining parameters for BaseInitiateSystemShutdown

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseInitiateSystemShutdown((PREGISTRY_SERVER_NAME)pbinding,
                                            Message,
                                            ShutdownContext->dwTimeout,
                                            ShutdownContext->bForceAppsClosed,
                                            ShutdownContext->bRebootAfterShutdown);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}

LONG
ShutdownCallbackEx(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PUNICODE_STRING Message,
    IN PSHUTDOWN_CONTEXTEX ShutdownContext
    )
/*++

Routine Description:

    Callback for binding to a machine to initiate a shutdown.

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

    Message - Supplies message to display during shutdown timeout period.

    ShutdownContext - Supplies remaining parameters for BaseInitiateSystemShutdown

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseInitiateSystemShutdownEx((PREGISTRY_SERVER_NAME)pbinding,
                                            Message,
                                            ShutdownContext->dwTimeout,
                                            ShutdownContext->bForceAppsClosed,
                                            ShutdownContext->bRebootAfterShutdown,
                                            ShutdownContext->dwReason);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}

LONG
AbortShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Unused1,
    IN PVOID Unused2
    )
/*++

Routine Description:

    Callback for binding to a machine to abort a shutdown.

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseAbortSystemShutdown((PREGISTRY_SERVER_NAME)pbinding);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regsrkey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsrkey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    save/restore key APIs, that is:

        - RegRestoreKeyA
        - RegRestoreKeyW
        - RegSaveKeyA
        - RegSaveKeyW

Author:

    David J. Gilman (davegi) 23-Jan-1992

Notes:

    The RegSaveKey and RegRestoreKey APIs involve up to 3 machines:

    1.- CLIENT: The machine where the API is invoked.
    2.- SERVER: The machine where the Registry resides.
    3.- TARGET: The machine of the specified file.

    Note that both the client and the server will be running Windows NT,
    but that the target machine might not.

    Even though the target might be accessible from the client, it might
    not be accessible from the server (e.g. the share is protected).



Revision History:

    25-Mar-1992     Ramon J. San Andres (ramonsa)
                    Changed to use RPC.

--*/


#include <rpc.h>
#include "regrpc.h"
#include "client.h"




LONG
APIENTRY
RegRestoreKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    Win32 Ansi API for restoring a key.

--*/

{
    PUNICODE_STRING     FileName;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    ASSERT( lpFile != NULL );

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    //
    // Convert the file name to a counted Unicode string using the static
    // Unicode string in the TEB.
    //

    FileName = &NtCurrentTeb( )->StaticUnicodeString;
    ASSERT( FileName != NULL );
    RtlInitAnsiString( &AnsiString, lpFile );
    Status = RtlAnsiStringToUnicodeString(
                FileName,
                &AnsiString,
                FALSE
                );

    //
    // If the file name could not be converted, map the results and return.
    //

    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }


    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName->Length > 0 ) {
        FileName->Length += sizeof( UNICODE_NULL );
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegRestoreKey(
                            hKey,
                            FileName,
                            dwFlags
                            );

    } else {

        Error = (LONG)BaseRegRestoreKey(
                            DereferenceRemoteHandle( hKey ),
                            FileName,
                            dwFlags
                            );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}



LONG
APIENTRY
RegRestoreKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    Restore the tree in the supplied file onto the key referenced by the
    supplied key handle. The restored tree will overwrite all of the
    contents of the supplied hKey except for its name. Pictorially, if
    the file contains:

                    A
                   / \
                  /   \
                 B     C

    and the supplied key refers to a key name X, the resultant tree would
    look like:

                    X
                   / \
                  /   \
                 B     C

Arguments:

    hKey - Supplies a handle to the key where the file is to be restored.

    lpFile - Supplies a pointer to an existing file name whose contents was
        created with RegSaveKey.

    dwFlags - Supplies an optional flag argument which can be:

                - REG_WHOLE_HIVE_VOLATILE

                    If specified this flag causes a new, volatile
                    (i.e. memory only) hive to be created. In this case
                    the hKey can only refer to a child of HKEY_USERS or
                    HKEY_LOCAL_MACHINE.

                    If not specified, hKey can refer to any key in the
                    Registry.


Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING  FileName;
    LONG            Error;
    HKEY            TempHandle = NULL;
    NTSTATUS        Status;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    ASSERT( lpFile != NULL );

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    Status = RtlInitUnicodeStringEx(&FileName, lpFile);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName.Length > 0 ) {
        FileName.Length += sizeof( UNICODE_NULL );
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegRestoreKey(
                                hKey,
                                &FileName,
                                dwFlags
                                );

    } else {

        Error = (LONG)BaseRegRestoreKey(
                                DereferenceRemoteHandle( hKey ),
                                &FileName,
                                dwFlags
                                );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSaveKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    Win32 ANSI wrapper to RegSaveKeyW.

    Save the key (and all of its decsendants) to the non-existant file
    named by the supplied string.

Arguments:

    hKey    - Supplies a handle to the key where the save operation is to
              begin.

    lpFile  - Supplies a pointer to a non-existant file name where the tree
              rooted at the supplied key handle will be saved.

    lpSecurityAttributes - Supplies an optional pointer to a
        SECURITY_ATTRIBUTES structure for the newly created file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    PUNICODE_STRING             FileName;
    ANSI_STRING                 AnsiString;
    NTSTATUS                    Status;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    ASSERT( lpFile != NULL );

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Note that we must map the handle here even though RegSaveKeyW
    //  will map it again. This is so that the second map will not
    //  overwrite the static Unicode string in the TEB that will
    //  contain the file name.
    //

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    //
    // Convert the file name to a counted Unicode string using the static
    // Unicode string in the TEB.
    //
    FileName = &NtCurrentTeb( )->StaticUnicodeString;
    ASSERT( FileName != NULL );
    RtlInitAnsiString( &AnsiString, lpFile );
    Status = RtlAnsiStringToUnicodeString(
                FileName,
                &AnsiString,
                FALSE
                );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName->Length > 0 ) {
        FileName->Length += sizeof( UNICODE_NULL );
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //
        pRpcSA = NULL;
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSaveKey(
                                hKey,
                                FileName,
                                pRpcSA
                                );

    } else {

        Error = (LONG)BaseRegSaveKey(
                                DereferenceRemoteHandle( hKey ),
                                FileName,
                                pRpcSA
                                );
    }
    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer and return the
    //
    if( pRpcSA != NULL ) {
        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSaveKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    Save the key (and all of its decsendants) to the non-existant file
    named by the supplied string.

Arguments:

    hKey - Supplies a handle to the key where the save operation is to
        begin.

    lpFile - Supplies a pointer to a non-existant file name where the tree
            rooted at the supplied key handle will be saved.

    lpSecurityAttributes - Supplies an optional pointer to a
        SECURITY_ATTRIBUTES structure for the newly created file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING              FileName;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    HKEY                        TempHandle = NULL;
    NTSTATUS                    Status;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    ASSERT( lpFile != NULL );


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Note that we must map the handle here even though RegSaveKeyW
    //  will map it again. This is so that the second map will not
    //  overwrite the static Unicode string in the TEB that will
    //  contain the file name.
    //
    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    Status = RtlInitUnicodeStringEx(&FileName, lpFile);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName.Length > 0 ) {
        FileName.Length += sizeof( UNICODE_NULL );
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //
        pRpcSA = NULL;
    }


    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSaveKey(
                                hKey,
                                &FileName,
                                pRpcSA
                                );

    } else {

        Error = (LONG)BaseRegSaveKey(
                                DereferenceRemoteHandle( hKey ),
                                &FileName,
                                pRpcSA
                                );
    }
    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer and return the
    //
    if( pRpcSA != NULL ) {
        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}


LONG
APIENTRY
RegSaveKeyExA (
    HKEY hKey,
    LPCSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD Flags
    )

/*++

Routine Description:

    Win32 ANSI wrapper to RegSaveKeyExW.

    Save the key (and all of its decsendants) to the non-existant file
    named by the supplied string.

Arguments:

    hKey    - Supplies a handle to the key where the save operation is to
              begin.

    lpFile  - Supplies a pointer to a non-existant file name where the tree
              rooted at the supplied key handle will be saved.

    lpSecurityAttributes - Supplies an optional pointer to a
        SECURITY_ATTRIBUTES structure for the newly created file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    PUNICODE_STRING             FileName;
    ANSI_STRING                 AnsiString;
    NTSTATUS                    Status;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    ASSERT( lpFile != NULL );

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Note that we must map the handle here even though RegSaveKeyW
    //  will map it again. This is so that the second map will not
    //  overwrite the static Unicode string in the TEB that will
    //  contain the file name.
    //

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    //
    // Convert the file name to a counted Unicode string using the static
    // Unicode string in the TEB.
    //
    FileName = &NtCurrentTeb( )->StaticUnicodeString;
    ASSERT( FileName != NULL );
    RtlInitAnsiString( &AnsiString, lpFile );
    Status = RtlAnsiStringToUnicodeString(
                FileName,
                &AnsiString,
                FALSE
                );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName->Length > 0 ) {
        FileName->Length += sizeof( UNICODE_NULL );
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //
        pRpcSA = NULL;
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSaveKeyEx(
                                hKey,
                                FileName,
                                pRpcSA,
                                Flags
                                );

    } else {

        Error = (LONG)BaseRegSaveKeyEx(
                                DereferenceRemoteHandle( hKey ),
                                FileName,
                                pRpcSA,
                                Flags
                                );
    }
    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer and return the
    //
    if( pRpcSA != NULL ) {
        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }
ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSaveKeyExW (
    HKEY                    hKey,
    LPCWSTR                 lpFile,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   Flags
    )

/*++

Routine Description:

    Save the key (and all of its decsendants) to the non-existant file
    named by the supplied string.

    This variant is used by setup in order to create a hive in the latest
    format. Helps creating hives in %systemroot%\system32\config in the 
    latest (presumably the best) format, and allows RegSaveKey to use the 
    standard format (bacward compatible) for roaming profiles and tools
    using registry hives on downlevel OSes.

Arguments:

    hKey - Supplies a handle to the key where the save operation is to
        begin.

    lpFile - Supplies a pointer to a non-existant file name where the tree
            rooted at the supplied key handle will be saved.

    lpSecurityAttributes - Supplies an optional pointer to a
        SECURITY_ATTRIBUTES structure for the newly created file.

    Flags - [REG_STANDARD_FORMAT]	- roaming format
            [REG_LATEST_FORMAT]		- latest format
            [REG_NO_COMPRESSION]	- no hive compression : faster

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING              FileName;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    HKEY                        TempHandle = NULL;
    NTSTATUS                    Status;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    ASSERT( lpFile != NULL );


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Note that we must map the handle here even though RegSaveKeyW
    //  will map it again. This is so that the second map will not
    //  overwrite the static Unicode string in the TEB that will
    //  contain the file name.
    //
    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    Status = RtlInitUnicodeStringEx(&FileName, lpFile);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName.Length > 0 ) {
        FileName.Length += sizeof( UNICODE_NULL );
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //
        pRpcSA = NULL;
    }


    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSaveKeyEx(
                                hKey,
                                &FileName,
                                pRpcSA,
                                Flags
                                );

    } else {

        Error = (LONG)BaseRegSaveKeyEx(
                                DereferenceRemoteHandle( hKey ),
                                &FileName,
                                pRpcSA,
                                Flags
                                );
    }

    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer and return the
    //
    if( pRpcSA != NULL ) {
        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }
ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\support.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Support.c

Abstract:

    This module contains support functions for the client side of the
    Win32 Registry APIs. That is:

        - MakeSemiUniqueName

Author:

    David J. Gilman (davegi) 15-Nov-1991

--*/

#include <rpc.h>
#include "regrpc.h"
#include <stdio.h>


#define REG_SUNAME_FORMAT_STRING    "Win32Reg.%08x.%08x"



BOOL
MakeSemiUniqueName (
    OUT PUNICODE_STRING     Name,
    IN  DWORD               Sequence
    )
/*++

Routine Description:

    Forms a name that is very probably unique in the system, based on
    the current process and thread id and a sequence provided by the
    caller.

Arguments:

    Name        -   Supplies a unicode string where the name will be put.
                    This string must contain a valid buffer of size
                    MAX_PATH * sizeof(WCHAR)

    Sequence    -   Supplies a sequence number that will be appended to
                    the name. If a name happens not to be unique, the
                    caller can try again with other sequence numbers.

Return Value:

    BOOL - Returns TRUE if a name was obtained.

--*/
{
    CHAR            NameBuffer[ MAX_PATH ];
    ANSI_STRING     AnsiName;
    NTSTATUS        NtStatus;

    ASSERT( Name && Name->Buffer );

    sprintf( NameBuffer,
             REG_SUNAME_FORMAT_STRING,
             HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
             Sequence
           );


    RtlInitAnsiString( &AnsiName, NameBuffer );

    NtStatus = RtlAnsiStringToUnicodeString(
                    Name,
                    &AnsiName,
                    FALSE
                    );

    return NT_SUCCESS( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\common\common.c ===
/*++
Copyright (c) 1991  Microsoft Corporation

Module Name:
    common.c

Abstract:
    Utility routines used by Lodctr and/or UnLodCtr
    

Author:
    Bob Watson (a-robw) 12 Feb 93

Revision History:
--*/
//
//  Windows Include files
//
#include <windows.h>
#include "strsafe.h"
#include "stdlib.h"
#include <accctrl.h>
#include <aclapi.h>
#include <winperf.h>
#include <initguid.h>
#include <guiddef.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  local include files
//
#define _INIT_WINPERFP_
#include "winperfp.h"
#include "ldprfmsg.h"
#include "common.h"
//
//  Text string Constant definitions
//
LPCWSTR NamesKey                   = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR DefaultLangId              = L"009";
LPCSTR  aszDefaultLangId           = "009";
LPCWSTR DefaultLangTag             = L"000";
LPCWSTR Counters                   = L"Counters";
LPCWSTR Help                       = L"Help";
LPCWSTR VersionStr                 = L"Version";
LPCWSTR BaseIndex                  = L"Base Index";
LPCWSTR LastHelp                   = L"Last Help";
LPCWSTR LastCounter                = L"Last Counter";
LPCWSTR FirstHelp                  = L"First Help";
LPCWSTR FirstCounter               = L"First Counter";
LPCWSTR Busy                       = L"Updating";
LPCWSTR Slash                      = L"\\";
LPCWSTR BlankString                = L" ";
LPCWSTR DriverPathRoot             = L"SYSTEM\\CurrentControlSet\\Services";
LPCWSTR Performance                = L"Performance";
LPCWSTR CounterNameStr             = L"Counter ";
LPCWSTR HelpNameStr                = L"Explain ";
LPCWSTR AddCounterNameStr          = L"Addcounter ";
LPCWSTR AddHelpNameStr             = L"Addexplain ";
LPCWSTR szObjectList               = L"Object List";
LPCWSTR szLibraryValidationCode    = L"Library Validation Code";
LPCWSTR DisablePerformanceCounters = L"Disable Performance Counters";
LPCWSTR szDisplayName              = L"DisplayName";
LPCWSTR szPerfIniPath              = L"PerfIniFile";
LPCSTR  szInfo                     = "info";
LPCSTR  szSymbolFile               = "symbolfile";
LPCSTR  szNotFound                 = "NotFound";
LPCSTR  szLanguages                = "languages";
LPCWSTR szLangCH                   = L"004";
LPCWSTR szLangCHT                  = L"0404";
LPCWSTR szLangCHS                  = L"0804";
LPCWSTR szLangCHH                  = L"0C04";
LPCWSTR szLangPT                   = L"016";
LPCWSTR szLangPT_BR                = L"0416";
LPCWSTR szLangPT_PT                = L"0816";
LPCWSTR szDatExt                   = L".DAT";
LPCWSTR szBakExt                   = L".BAK";
LPCWSTR wszInfo                    = L"info";
LPCWSTR wszDriverName              = L"drivername";
LPCWSTR wszNotFound                = L"NotFound";
LPCSTR  aszDriverName              = "drivername";

BOOLEAN g_bCheckTraceLevel = FALSE;

//  Global (to this module) Buffers
//
static  HANDLE  hMod = NULL;    // process handle
HANDLE hEventLog      = NULL;
HANDLE hLoadPerfMutex = NULL;
//
//  local static data
//
BOOL
__stdcall
DllEntryPoint(
    IN  HANDLE DLLHandle,
    IN  DWORD  Reason,
    IN  LPVOID ReservedAndUnused
)
{
    BOOL    bReturn = FALSE;

    ReservedAndUnused;
    DisableThreadLibraryCalls(DLLHandle);

    switch(Reason) {
    case DLL_PROCESS_ATTACH:
        hMod = DLLHandle;   // use DLL handle , not APP handle

        // register eventlog source
        hEventLog = RegisterEventSourceW(NULL, (LPCWSTR) L"LoadPerf");
        bReturn   = TRUE;
        break;

    case DLL_PROCESS_DETACH:
        if (hEventLog != NULL) {
            if (DeregisterEventSource(hEventLog)) {
                hEventLog = NULL;
            }
        }
        if (hLoadPerfMutex != NULL) {
            CloseHandle(hLoadPerfMutex);
            hLoadPerfMutex = NULL;
        }
        bReturn = TRUE;
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        bReturn = TRUE;
        break;
    }
    return bReturn;
}

LPCWSTR
GetFormatResource(
    UINT  wStringId
)
/*++
    Returns an ANSI string for use as a format string in a printf fn.
--*/
{
    LPCWSTR      szReturn = BlankString;
    static WCHAR TextFormat[DISP_BUFF_SIZE];

    if (! hMod) {
        hMod = (HINSTANCE) GetModuleHandle(NULL); // get instance ID of this module;
    }
    if (hMod) {
        if ((LoadStringW(hMod, wStringId, TextFormat, DISP_BUFF_SIZE)) > 0) {
            szReturn = (LPCWSTR) TextFormat;
        }
    }
    return szReturn;
}

VOID
DisplayCommandHelp(
    UINT iFirstLine,
    UINT iLastLine
)
/*++

DisplayCommandHelp

    displays usage of command line arguments

Arguments

    NONE

Return Value

    NONE

--*/
{
    UINT  iThisLine;
    WCHAR StringBuffer[DISP_BUFF_SIZE];
    CHAR  OemStringBuffer[DISP_BUFF_SIZE];
    int   nStringBufferLen;
    int   nOemStringBufferLen;

    if (! hMod) {
        hMod = (HINSTANCE) GetModuleHandle(NULL);
    }
    if (hMod) {
        for (iThisLine = iFirstLine; iThisLine <= iLastLine; iThisLine++) {
            ZeroMemory(StringBuffer,    DISP_BUFF_SIZE * sizeof(WCHAR));
            ZeroMemory(OemStringBuffer, DISP_BUFF_SIZE * sizeof(CHAR));

            nStringBufferLen = LoadStringW(hMod, iThisLine, StringBuffer, DISP_BUFF_SIZE);
            if (nStringBufferLen > 0) {
                nOemStringBufferLen = DISP_BUFF_SIZE;
                WideCharToMultiByte(CP_OEMCP,
                                    0,
                                    StringBuffer,
                                    nStringBufferLen,
                                    OemStringBuffer,
                                    nOemStringBufferLen,
                                    NULL,
                                    NULL);
                fprintf(stdout, "\n%s", OemStringBuffer);
            }
        }    
    } // else do nothing
} // DisplayCommandHelp

BOOL
TrimSpaces(
    LPWSTR  szString
)
/*++
Routine Description:
    Trims leading and trailing spaces from szString argument, modifying
        the buffer passed in

Arguments:
    IN  OUT LPWSTR  szString
        buffer to process

Return Value:
    TRUE if string was modified
    FALSE if not
--*/
{
    LPWSTR  szSource = szString;
    LPWSTR  szDest   = szString;
    LPWSTR  szLast   = szString;
    BOOL    bChars   = FALSE;

    if (szString != NULL) {
        while (* szSource != L'\0') {
            // skip leading non-space chars
            if (! iswspace(* szSource)) {
                szLast = szDest;
                bChars = TRUE;
            }
            if (bChars) {
                // remember last non-space character
                // copy source to destination & increment both
                * szDest ++ = * szSource ++;
            }
            else {
                szSource ++;
            }
        }
        if (bChars) {
            * ++ szLast = L'\0'; // terminate after last non-space char
        }
        else {
            // string was all spaces so return an empty (0-len) string
            * szString = L'\0';
        }
    }
    return (szLast != szSource);
}

BOOL
IsDelimiter(
    WCHAR  cChar,
    WCHAR  cDelimiter
)
/*++
Routine Description:
    compares the characte to the delimiter. If the delimiter is
        a whitespace character then any whitespace char will match
        otherwise an exact match is required
--*/
{
    if (iswspace(cDelimiter)) {
        // delimiter is whitespace so any whitespace char will do
        return(iswspace(cChar));
    }
    else {
        // delimiter is not white space so use an exact match
        return (cChar == cDelimiter);
    }
}

LPCWSTR
GetItemFromString(
    LPCWSTR  szEntry,
    DWORD    dwItem,
    WCHAR    cDelimiter

)
/*++
Routine Description:
    returns nth item from a list delimited by the cDelimiter Char.
        Leaves (double)quoted strings intact.

Arguments:
    IN  LPWTSTR szEntry
        Source string returned to parse
    IN  DWORD   dwItem
        1-based index indicating which item to return. (i.e. 1= first item
        in list, 2= second, etc.)
    IN  WCHAR   cDelimiter
        character used to separate items. Note if cDelimiter is WhiteSpace
        (e.g. a tab or a space) then any white space will serve as a delim.

Return Value:
    pointer to buffer containing desired entry in string. Note, this
        routine may only be called 4 times before the string
        buffer is re-used. (i.e. don't use this function more than
        4 times in single function call!!)
--*/
{
    static  WCHAR   szReturnBuffer[4][MAX_PATH];
    static  LONG    dwBuff;
    LPWSTR  szSource, szDest;
    DWORD   dwThisItem;
    DWORD   dwStrLeft;

    dwBuff = ++ dwBuff % 4; // wrap buffer index

    szSource = (LPWSTR) szEntry;
    szDest   = & szReturnBuffer[dwBuff][0];

    // clear previous contents
    ZeroMemory(szDest, MAX_PATH * sizeof(WCHAR));

    // find desired entry in string
    dwThisItem = 1;
    while (dwThisItem < dwItem) {
        if (* szSource != L'\0') {
            while (! IsDelimiter(* szSource, cDelimiter) && (* szSource != L'\0')) {
                if (* szSource == cDoubleQuote) {
                    // if this is a quote, then go to the close quote
                    szSource ++;
                    while ((* szSource != cDoubleQuote) && (* szSource != L'\0')) szSource ++;
                }
                if (* szSource != L'\0') szSource ++;
            }
        }
        dwThisItem ++;
        if (* szSource != L'\0') szSource ++;
    }

    // copy this entry to the return buffer
    if (* szSource != L'\0') {
        dwStrLeft = MAX_PATH - 1;
        while (! IsDelimiter(* szSource, cDelimiter) && (* szSource != L'\0')) {
            if (* szSource == cDoubleQuote) {
                // if this is a quote, then go to the close quote
                // don't copy quotes!
                szSource ++;
                while ((* szSource != cDoubleQuote) && (* szSource != L'\0')) {
                    * szDest ++ = * szSource ++;
                    dwStrLeft --;
                    if (! dwStrLeft) break;   // dest is full (except for term NULL
                }
                if (* szSource != L'\0') szSource ++;
            }
            else {
                * szDest ++ = * szSource ++;
                dwStrLeft --;
                if (! dwStrLeft) break;   // dest is full (except for term NULL
            }
        }
        * szDest = L'\0';
    }

    // remove any leading and/or trailing spaces
    TrimSpaces(& szReturnBuffer[dwBuff][0]);
    return & szReturnBuffer[dwBuff][0];
}

void
ReportLoadPerfEvent(
    WORD    EventType,
    DWORD   EventID,
    DWORD   dwDataCount,
    DWORD   dwData1,
    DWORD   dwData2,
    DWORD   dwData3,
    DWORD   dwData4,
    WORD    wStringCount,
    LPWSTR  szString1,
    LPWSTR  szString2,
    LPWSTR  szString3
)
{
    DWORD  dwData[5];
    LPWSTR szMessageArray[4];
    BOOL   bResult           = FALSE;
    WORD   wLocalStringCount = 0;
    DWORD  dwLastError       = GetLastError();

    if (dwDataCount > 4)  dwDataCount  = 4;
    if (wStringCount > 3) wStringCount = 3;

    if (dwDataCount > 0) dwData[0] = dwData1;
    if (dwDataCount > 1) dwData[1] = dwData2;
    if (dwDataCount > 2) dwData[2] = dwData3;
    if (dwDataCount > 3) dwData[3] = dwData4;
    dwDataCount *= sizeof(DWORD);

    if (wStringCount > 0 && szString1) {
        szMessageArray[wLocalStringCount] = szString1;
        wLocalStringCount ++;
    }
    if (wStringCount > 1 && szString2) {
        szMessageArray[wLocalStringCount] = szString2;
        wLocalStringCount ++;
    }
    if (wStringCount > 2 && szString3) {
        szMessageArray[wLocalStringCount] = szString3;
        wLocalStringCount ++;
    }

    if (hEventLog == NULL) {
        hEventLog = RegisterEventSourceW(NULL, (LPCWSTR) L"LoadPerf");
    }

    if (dwDataCount > 0 && wLocalStringCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type 
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     wLocalStringCount,     // number of strings
                     dwDataCount,           // sizeof raw data
                     szMessageArray,        // message text array
                     (LPVOID) & dwData[0]); // raw data
    }
    else if (dwDataCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     0,                     // number of strings
                     dwDataCount,           // sizeof raw data
                     NULL,                  // message text array
                     (LPVOID) & dwData[0]); // raw data
    }
    else if (wLocalStringCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     wLocalStringCount,     // number of strings
                     0,                     // sizeof raw data
                     szMessageArray,        // message text array
                     NULL);                 // raw data
    }
    else {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     0,                     // number of strings
                     0,                     // sizeof raw data
                     NULL,                  // message text array
                     NULL);                 // raw data
    }
#if 0
    if (! bResult) {
        DbgPrint("LOADPERF(%5d,%5d)::(%d,0x%08X,%d)(%d,%d,%d,%d,%d)(%d,\"%ws\",\"%ws\",\"%ws\")\n",
                GetCurrentProcessId(), GetCurrentThreadId(),
                EventType, EventID, GetLastError(),
                dwDataCount, dwData1, dwData2, dwData3, dwData4,
                wStringCount, szString1, szString2, szString3);
    }
#endif
    SetLastError(dwLastError);
}

BOOLEAN LoadPerfGrabMutex()
{
    BOOL                     bResult      = TRUE;
    HANDLE                   hLocalMutex  = NULL;
    DWORD                    dwWaitStatus = 0;
    SECURITY_ATTRIBUTES      SecurityAttributes; 
    PSECURITY_DESCRIPTOR     pSD          = NULL; 
    EXPLICIT_ACCESSW         ea[3]; 
    SID_IDENTIFIER_AUTHORITY authNT       = SECURITY_NT_AUTHORITY; 
    SID_IDENTIFIER_AUTHORITY authWorld    = SECURITY_WORLD_SID_AUTHORITY; 
    PSID                     psidSystem   = NULL;
    PSID                     psidAdmin    = NULL;
    PSID                     psidEveryone = NULL; 
    PACL                     pAcl         = NULL; 

    if (hLoadPerfMutex == NULL) {
        ZeroMemory(ea, 3 * sizeof(EXPLICIT_ACCESS));

        // Get the system sid
        //
        bResult = AllocateAndInitializeSid(& authNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, & psidSystem);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup;
        }

        // Set the access rights for system sid
        //
        ea[0].grfAccessPermissions = MUTEX_ALL_ACCESS;
        ea[0].grfAccessMode        = SET_ACCESS;
        ea[0].grfInheritance       = NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm  = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType  = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName    = (LPWSTR) psidSystem;

        // Get the Admin sid
        //
        bResult = AllocateAndInitializeSid(& authNT,
                                           2,
                                           SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS,
                                           0, 0, 0, 0, 0, 0,
                                           & psidAdmin);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup;
        }

        // Set the access rights for Admin sid
        //
        ea[1].grfAccessPermissions = MUTEX_ALL_ACCESS;
        ea[1].grfAccessMode        = SET_ACCESS;
        ea[1].grfInheritance       = NO_INHERITANCE;
        ea[1].Trustee.TrusteeForm  = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType  = TRUSTEE_IS_GROUP;
        ea[1].Trustee.ptstrName    = (LPWSTR) psidAdmin;

        // Get the World sid
        //
        bResult = AllocateAndInitializeSid(& authWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, & psidEveryone);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup;
        }

        // Set the access rights for world
        //
        ea[2].grfAccessPermissions = READ_CONTROL | SYNCHRONIZE | MUTEX_MODIFY_STATE;
        ea[2].grfAccessMode        = SET_ACCESS;
        ea[2].grfInheritance       = NO_INHERITANCE;
        ea[2].Trustee.TrusteeForm  = TRUSTEE_IS_SID;
        ea[2].Trustee.TrusteeType  = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[2].Trustee.ptstrName    = (LPWSTR) psidEveryone;

        // Create a new ACL that contains the new ACEs. 
        // 
        dwWaitStatus = SetEntriesInAclW(3, ea, NULL, & pAcl);
        if (dwWaitStatus != ERROR_SUCCESS) {
            bResult = FALSE;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup; 
        }

        // Initialize a security descriptor.
        //
        pSD = (PSECURITY_DESCRIPTOR)
              LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH); 
        if (pSD == NULL)  {
            dwWaitStatus = GetLastError();
            bResult      = FALSE;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup; 
        }
  
        bResult = InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup; 
        }

        // Add the ACL to the security descriptor.
        //
        bResult = SetSecurityDescriptorDacl(pSD, TRUE, pAcl, FALSE);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup; 
        }

        SecurityAttributes.nLength              = sizeof(SECURITY_ATTRIBUTES); 
        SecurityAttributes.bInheritHandle       = TRUE; 
        SecurityAttributes.lpSecurityDescriptor = pSD; 

        __try {
            hLocalMutex = CreateMutexW(& SecurityAttributes, FALSE, L"LOADPERF_MUTEX");
            if (hLocalMutex == NULL) {
                bResult      = FALSE;
                dwWaitStatus = GetLastError();
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADPERFGRABMUTEX,
                        0,
                        dwWaitStatus,
                        NULL));
            }
            else if (InterlockedCompareExchangePointer(& hLoadPerfMutex, hLocalMutex, NULL) != NULL) {
                CloseHandle(hLocalMutex);
                hLocalMutex = NULL;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bResult      = FALSE;
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_LOADPERFGRABMUTEX,
                   0,
                   dwWaitStatus,
                   NULL));
        }
    }

    __try {
        dwWaitStatus = WaitForSingleObject(hLoadPerfMutex, H_MUTEX_TIMEOUT);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        bResult      = FALSE;
        dwWaitStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_LOADPERFGRABMUTEX,
               0,
               dwWaitStatus,
               NULL));
    }
    if (dwWaitStatus != WAIT_OBJECT_0 && dwWaitStatus != WAIT_ABANDONED) {
        bResult = FALSE;
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_LOADPERFGRABMUTEX,
               0,
               dwWaitStatus,
               NULL));
    }

Cleanup:
    if (psidSystem)   FreeSid(psidSystem);
    if (psidAdmin)    FreeSid(psidAdmin);
    if (psidEveryone) FreeSid(psidEveryone);
    if (pAcl)         LocalFree(pAcl);
    if (pSD)          LocalFree(pSD);
    if (! bResult)    SetLastError(dwWaitStatus);

    return bResult ? TRUE : FALSE;
}

#define LODWORD(ll)             ((DWORD) ((LONGLONG) ll & 0x00000000FFFFFFFF))
#define HIDWORD(ll)             ((DWORD) (((LONGLONG) ll >> 32) & 0x00000000FFFFFFFF))
#define MAKELONGLONG(low, high) ((LONGLONG) (((DWORD) (low)) | ((LONGLONG) ((DWORD) (high))) << 32))

LPWSTR  g_szInfPath = NULL;

LPWSTR
LoadPerfGetLanguage(LPWSTR szLang, BOOL bPrimary)
{
    LPWSTR szRtnLang = szLang;

    if (bPrimary) {
        if (lstrcmpiW(szLang, szLangCHT) == 0 || lstrcmpiW(szLang, szLangCHS) == 0
                                              || lstrcmpiW(szLang, szLangCHH) == 0) {
            szRtnLang = (LPWSTR) szLangCH;
        }
        else if (lstrcmpiW(szLang, szLangPT_PT) == 0 || lstrcmpiW(szLang, szLangPT_BR) == 0) {
            szRtnLang = (LPWSTR) szLangPT;
        }
    }
    else if (lstrcmpiW(szLang, szLangCH) == 0) {
        DWORD dwLangId = GetUserDefaultUILanguage();

        if (dwLangId == 0x0404 || dwLangId == 0x0C04) szRtnLang = (LPWSTR) szLangCHT;
        else if (dwLangId == 0x0804)                  szRtnLang = (LPWSTR) szLangCHS;
        else                                          szRtnLang = (LPWSTR) szLangCH;
    }
    else if (lstrcmpiW(szLang, szLangPT) == 0) {
        DWORD dwLangId = GetUserDefaultUILanguage();

        if (dwLangId == 0x0416)      szRtnLang = (LPWSTR) szLangPT_BR;
        else if (dwLangId == 0x0816) szRtnLang = (LPWSTR) szLangPT_PT;
        else                         szRtnLang = (LPWSTR) szLangPT;
    }

    return szRtnLang;
}

LPWSTR
LoadPerfGetInfPath()
{
    LPWSTR  szReturn  = NULL;
    DWORD   dwInfPath = 0;
    HRESULT hError    = S_OK;

    if (g_szInfPath == NULL) {
        dwInfPath = GetSystemWindowsDirectoryW(NULL, 0);
        if (dwInfPath > 0) {
            dwInfPath += 6;
            if (dwInfPath < MAX_PATH) dwInfPath = MAX_PATH;
            g_szInfPath = MemoryAllocate(dwInfPath * sizeof(WCHAR));
            if (g_szInfPath != NULL) {
                GetSystemWindowsDirectoryW(g_szInfPath, dwInfPath);
                hError = StringCchCatW(g_szInfPath, dwInfPath, Slash);
                if (SUCCEEDED(hError)) {
                    hError = StringCchCatW(g_szInfPath, dwInfPath, L"inf");
                    if (SUCCEEDED(hError)) {
                        hError = StringCchCatW(g_szInfPath, dwInfPath, Slash);
                    }
                }
                if (SUCCEEDED(hError)) {
                    szReturn = g_szInfPath;
                }
                else {
                    SetLastError(HRESULT_CODE(hError));
                }
            }
            else {
                SetLastError(ERROR_OUTOFMEMORY);
            }
        }
        else {
            SetLastError(ERROR_INVALID_DATA);
        }
        if (szReturn == NULL) {
            MemoryFree(g_szInfPath);
            g_szInfPath = NULL;
        }
    }
    else {
        szReturn = g_szInfPath;
    }
    return szReturn;
}

BOOL
LoadPerfGetIncludeFileName(
    LPCSTR   szIniFile,
    DWORD    dwFileSize,
    DWORD    dwUnicode,
    LPWSTR * szIncFile,
    LPWSTR * szService
)
// Caller LoadPerfBackupIniFile() should free allocated szIncFile and szService.
{
    LPSTR   szIncName  = NULL;
    LPSTR   szPath     = NULL;
    LPSTR   szDrive    = NULL;
    LPSTR   szDir      = NULL;
    LPSTR   aszIncFile = NULL;
    LPSTR   aszService = NULL;
    DWORD   dwSize     = 0;
    BOOL    bReturn    = FALSE;
    HRESULT hr         = S_OK;

    if (szIncFile == NULL || szService == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    * szIncFile = NULL;
    * szService = NULL;

    dwSize    = 6 * dwFileSize;
    szIncName = MemoryAllocate(dwSize * sizeof(CHAR));
    if (szIncName != NULL) {
        LPWSTR wszIniFile = NULL;

        szPath     = (LPSTR) (szIncName  + dwFileSize);
        szDrive    = (LPSTR) (szPath     + dwFileSize);
        szDir      = (LPSTR) (szDrive    + dwFileSize);
        aszIncFile = (LPSTR) (szDir      + dwFileSize);
        aszService = (LPSTR) (aszIncFile + dwFileSize);

        if (dwUnicode != 0) {
            wszIniFile = LoadPerfMultiByteToWideChar(CP_ACP, (LPSTR) szIniFile);
        }
        if (wszIniFile == NULL) {
            dwSize = GetPrivateProfileStringA(szInfo, aszDriverName, szNotFound, aszService, dwFileSize, szIniFile);
            if (lstrcmpiA(aszService, szNotFound) != 0) {
                * szService = LoadPerfMultiByteToWideChar(CP_ACP, aszService);
                bReturn     = TRUE;
            }
            else {
                // name not found, default returned so return NULL string
                SetLastError(ERROR_BAD_DRIVER);
            }
        }
        else {
            * szService = MemoryAllocate(dwFileSize * sizeof(WCHAR));
            if (* szService != NULL) {
                dwSize = GetPrivateProfileStringW(
                                wszInfo, wszDriverName, wszNotFound, * szService, dwFileSize, wszIniFile);
                if (lstrcmpiW(* szService, wszNotFound) == 0) {
                    // name not found, default returned so return NULL string
                    SetLastError(ERROR_BAD_DRIVER);
                }
                else {
                    bReturn = TRUE;
                }
            }
            MemoryFree(wszIniFile);
        }

        dwSize = GetPrivateProfileStringA(szInfo, szSymbolFile, szNotFound, szIncName, dwFileSize, szIniFile);
        if (dwSize == 0 || lstrcmpiA(szIncName, szNotFound) == 0) {
            SetLastError(ERROR_BAD_DRIVER);
            goto Cleanup;
        }
        _splitpath(szIniFile, szDrive, szDir, NULL, NULL);
        hr = StringCchCopyA(szPath, dwFileSize, szDrive);
        if (SUCCEEDED(hr)) {
            hr = StringCchCatA(szPath, dwFileSize, szDir);
        }
        if (FAILED(hr)) {
            goto Cleanup;
        }
        dwSize = SearchPathA(szPath, szIncName, NULL, dwFileSize, aszIncFile, NULL);
        if (dwSize == 0) {
            dwSize = SearchPathA(NULL, szIncName, NULL, dwFileSize, aszIncFile, NULL);
        }
        if (dwSize != 0) {
            * szIncFile = LoadPerfMultiByteToWideChar(CP_ACP, aszIncFile);
        }

        bReturn = (dwSize > 0) ? TRUE : FALSE;
    }

Cleanup:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_GETINCLUDEFILENAME,
            ARG_DEF(ARG_TYPE_STR, 1) | ARG_DEF(ARG_TYPE_STR, 2) | ARG_DEF(ARG_TYPE_STR, 3),
            GetLastError(),
            TRACE_STR(szIniFile),
            TRACE_STR(aszIncFile),
            TRACE_STR(aszService),
            NULL));
    MemoryFree(szIncName);
    return bReturn;
}

BOOL
LoadPerfCheckAndCreatePath(
    LPWSTR szPath
)
{
    BOOL bReturn = CreateDirectoryW(szPath, NULL);
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_CHECKANDCREATEPATH,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            GetLastError(),
            TRACE_WSTR(szPath),
            NULL));
    if (bReturn == FALSE) {
        bReturn = (GetLastError() == ERROR_ALREADY_EXISTS) ? (TRUE) : (FALSE);
    }
    return bReturn;
}

BOOL
LoadPerfCheckAndCopyFile(
    LPCWSTR szThisFile,
    LPWSTR  szBackupFile
)
{
    DWORD         Status  = ERROR_SUCCESS;
    BOOL          bReturn = FALSE;
    HANDLE        hFile1  = NULL;

    hFile1 = CreateFileW(szThisFile,
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
    if (hFile1 == NULL || hFile1 == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
    }
    else {
        CloseHandle(hFile1);
        bReturn = CopyFileW(szThisFile, szBackupFile, FALSE);
        if (bReturn != TRUE) {
            Status = GetLastError();
        }
    }
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_GETINCLUDEFILENAME,
            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
            Status,
            TRACE_WSTR(szThisFile),
            TRACE_WSTR(szBackupFile),
            NULL));
    return bReturn;
}

void
LoadPerfRemovePreviousIniFile(
    LPWSTR szIniName,
    LPWSTR szDriverName
)
{
    LPWSTR           szInfPath = LoadPerfGetInfPath();
    LPWSTR           szIniPath = NULL;
    LPWSTR           szIniFile = NULL;
    HANDLE           hIniFile  = NULL;
    DWORD            Status    = ERROR_SUCCESS;
    DWORD            dwLength;
    BOOL             bContinue;
    BOOL             bDelete;
    WIN32_FIND_DATAW FindFile;
    HRESULT          hr        = S_OK;

    if (szInfPath == NULL) {
        Status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    dwLength  = lstrlenW(szInfPath) + lstrlenW(szDriverName) + lstrlenW(szIniName) + 10;
    if (dwLength < MAX_PATH) dwLength = MAX_PATH;
    szIniPath = MemoryAllocate(2 * dwLength * sizeof(WCHAR));
    if (szIniPath == NULL) {
        Status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    szIniFile = szIniPath + dwLength;

    hr = StringCchPrintfW(szIniPath, dwLength, L"%ws0*", szInfPath);
    if (SUCCEEDED(hr)) {
        hIniFile = FindFirstFileExW(szIniPath, FindExInfoStandard, & FindFile, FindExSearchLimitToDirectories, NULL, 0);
        if (hIniFile == NULL || hIniFile == INVALID_HANDLE_VALUE) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_GETINCLUDEFILENAME,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    GetLastError(),
                    TRACE_WSTR(szIniPath),
                    NULL));
            Status = ERROR_RESOURCE_LANG_NOT_FOUND;
            goto Cleanup;
        }
    }
    else {
        Status = HRESULT_CODE(hr);
        goto Cleanup;
    }

    bContinue = TRUE;
    while (bContinue) {
        hr = StringCchPrintfW(szIniFile, dwLength, L"%ws%ws\\%ws\\%ws",
                         szInfPath, FindFile.cFileName, szDriverName, szIniName);
        if (SUCCEEDED(hr)) {
            bDelete   = DeleteFileW(szIniFile);
            dwLength  = bDelete ? (ERROR_SUCCESS) : (GetLastError());
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_GETINCLUDEFILENAME,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    dwLength,
                    TRACE_WSTR(szIniFile),
                    NULL));
        }
        bContinue = FindNextFileW(hIniFile, & FindFile);
    }

Cleanup:
    MemoryFree(szIniPath);
    if (hIniFile != NULL && hIniFile != INVALID_HANDLE_VALUE) FindClose(hIniFile);
    if (Status != ERROR_SUCCESS) SetLastError(Status);
    return;
}

BOOL
LoadPerfBackupIniFile(
    LPCWSTR   szIniFile,
    LPWSTR    szLangId,
    LPWSTR  * szIniName,
    LPWSTR  * szDriverName,
    BOOL      bExtFile
)
// Caller InstallPerfDllW() should free allocated szIniName and szDriverName.
// Caller UpdatePerfNameFilesX() passes in NULL szIniName and szDriverName. No need to allocate.
{
    BOOL    bReturn       = TRUE;
    LPWSTR  szIniFileName = NULL;
    LPWSTR  szIncFileName = NULL;
    LPWSTR  szInfPath     = NULL;
    LPWSTR  szIncPath     = NULL;
    LPWSTR  szDriver      = NULL;
    LPWSTR  szIniTarget   = NULL;
    LPWSTR  szIncTarget   = NULL;
    LPSTR   szLangList    = NULL;
    LPSTR   szLang        = NULL;
    LPSTR   aszIniFile    = NULL;
    DWORD   dwFileSize    = 0;
    DWORD   dwSize;
    DWORD   dwUnicode     = 0;
    HRESULT hr;

    if (szIniFile == NULL || lstrlenW(szIniFile) == 0) return FALSE;
    if ((szInfPath = LoadPerfGetInfPath()) == NULL) return FALSE;

    if (szIniName != NULL)    * szIniName    = NULL;
    if (szDriverName != NULL) * szDriverName = NULL;

    dwFileSize = LoadPerfGetFileSize((LPWSTR) szIniFile, & dwUnicode, TRUE);
    if (dwFileSize < SMALL_BUFFER_SIZE) dwFileSize = SMALL_BUFFER_SIZE;

    aszIniFile = LoadPerfWideCharToMultiByte(CP_ACP, (LPWSTR) szIniFile);
    if (aszIniFile == NULL) return FALSE;

    for (szIniFileName = (LPWSTR) szIniFile + lstrlenW(szIniFile) - 1;
         szIniFileName != NULL && szIniFileName != szIniFile
                               && (* szIniFileName) != cNull
                               && (* szIniFileName) != cBackslash;
         szIniFileName --);
    if (szIniFileName != NULL && (* szIniFileName) == cBackslash) {
        szIniFileName ++;
    }
    if (szIniFileName != NULL) {
        if (szIniName != NULL) {
            dwSize = lstrlenW(szIniFileName) + 1;
            * szIniName = MemoryAllocate(sizeof(WCHAR) * dwSize);
            if (* szIniName != NULL) {
                hr = StringCchCopyW(* szIniName, dwSize, szIniFileName);
            }
        }
        szIniTarget = MemoryAllocate(dwFileSize * sizeof(WCHAR));
        if (szIniTarget == NULL) {
            bReturn = FALSE;
            goto Cleanup;
        }
    }

    if (bExtFile) {
        bReturn = LoadPerfGetIncludeFileName(aszIniFile, dwFileSize, dwUnicode, & szIncPath, & szDriver);
        if (bReturn != TRUE) goto Cleanup;
        if (szDriver != NULL) {
            if (szDriverName != NULL) {
                dwSize = lstrlenW(szDriver) + 1;
                * szDriverName = MemoryAllocate(sizeof(WCHAR) * dwSize);
                if (* szDriverName != NULL) {
                    hr = StringCchCopyW(* szDriverName, dwSize, szDriver);
                }
            }
        }

        if (szIncPath != NULL) {
            for (szIncFileName = szIncPath + lstrlenW(szIncPath) - 1;
                 szIncFileName != NULL && szIncFileName != szIncPath
                                       && (* szIncFileName) != cNull
                                       && (* szIncFileName) != cBackslash;
                 szIncFileName --);
            if (szIncFileName != NULL && (* szIncFileName) == cBackslash) {
                szIncFileName ++;
            }
        }

        hr = StringCchPrintfW(szIniTarget, dwFileSize, L"%sinc", szInfPath);
        bReturn = LoadPerfCheckAndCreatePath(szIniTarget);
        if (bReturn != TRUE) goto Cleanup;

        hr = StringCchPrintfW(szIniTarget, dwFileSize, L"%sinc%s%ws%s", szInfPath, Slash, szDriver, Slash);
        bReturn = LoadPerfCheckAndCreatePath(szIniTarget);
        if (bReturn != TRUE) goto Cleanup;

        if (szIncFileName != NULL) {
            hr = StringCchCatW(szIniTarget, dwFileSize, szIncFileName);
            bReturn = LoadPerfCheckAndCopyFile(szIncPath, szIniTarget);
        }
        if (bReturn != TRUE) goto Cleanup;

        szLangList = MemoryAllocate(dwFileSize * sizeof(CHAR));
        if (szLangList == NULL) {
            bReturn = FALSE;
            goto Cleanup;
        }

        LoadPerfRemovePreviousIniFile(szIniFileName, szDriver);

        dwSize = GetPrivateProfileStringA(szLanguages, NULL, aszDefaultLangId, szLangList, dwFileSize, aszIniFile);
        for (szLang  = szLangList;
             bReturn && szLang != NULL && szLang[0] != '\0';
             szLang += (lstrlenA(szLang) + 1)) {
            LPWSTR szTmpLang  = LoadPerfMultiByteToWideChar(CP_ACP, szLang);
            if (szTmpLang != NULL) {
                LPWSTR szThisLang = LoadPerfGetLanguage(szTmpLang, FALSE);

                ZeroMemory(szIniTarget, sizeof(WCHAR) * dwFileSize);
                hr = StringCchPrintfW(szIniTarget, dwFileSize, L"%s%s%s", szInfPath, szThisLang, Slash);
                bReturn = LoadPerfCheckAndCreatePath(szIniTarget);
                if (bReturn != TRUE) goto Cleanup;

                hr = StringCchPrintfW(szIniTarget, dwFileSize, L"%s%s%s%ws%s",
                                                szInfPath, szThisLang, Slash, szDriver, Slash);
                bReturn = LoadPerfCheckAndCreatePath(szIniTarget);
                if (bReturn) {
                    hr = StringCchCatW(szIniTarget, dwFileSize, szIniFileName);
                    bReturn = LoadPerfCheckAndCopyFile(szIniFile, szIniTarget);
                }
                MemoryFree(szTmpLang);
            }
            else {
                bReturn = FALSE;
            }
        }
    }
    else if (szLangId != NULL && szIniFileName != NULL) {
        LPWSTR szThisLang = LoadPerfGetLanguage(szLangId, FALSE);

        hr = StringCchPrintfW(szIniTarget, dwFileSize, L"%s%s%s", szInfPath, szThisLang, Slash);
        bReturn = LoadPerfCheckAndCreatePath(szIniTarget);
        if (bReturn) {
            hr = StringCchCatW(szIniTarget, dwFileSize, szIniFileName);
            bReturn = LoadPerfCheckAndCopyFile(szIniFile, szIniTarget);
        }
    }
    else {
        bReturn = FALSE;
    }

Cleanup:
    MemoryFree(aszIniFile);
    MemoryFree(szIncPath);
    MemoryFree(szDriver);
    MemoryFree(szIniTarget);
    MemoryFree(szLangList);
    return bReturn;
}

typedef struct _LOADPERF_LANG_INFO {
    WORD    dwLCID;
    int     cpAnsi;
    int     cpOem;
    int     cpMac;
    LPCWSTR szName;
    LPCWSTR szShotName;
} LOADPERF_LANG_INFO, * PLOADPERF_LANG_INFO;

const LOADPERF_LANG_INFO LocaleTable[] = {
    { 0x0401, 1256,  720, 10004, L"Arabic (Saudi Arabia)",                              L"ARA" },
 // { 0x0801, 1256,  720, 10004, L"Arabic (Iraq)",                                      L"ARI" },
 // { 0x0c01, 1256,  720, 10004, L"Arabic (Egypt)",                                     L"ARE" },
 // { 0x1001, 1256,  720, 10004, L"Arabic (Libya)",                                     L"ARL" },
 // { 0x1401, 1256,  720, 10004, L"Arabic (Algeria)",                                   L"ARG" },
 // { 0x1801, 1256,  720, 10004, L"Arabic (Morocco)",                                   L"ARM" },
 // { 0x1c01, 1256,  720, 10004, L"Arabic (Tunisia)",                                   L"ART" },
 // { 0x2001, 1256,  720, 10004, L"Arabic (Oman)",                                      L"ARO" },
 // { 0x2401, 1256,  720, 10004, L"Arabic (Yemen)",                                     L"ARY" },
 // { 0x2801, 1256,  720, 10004, L"Arabic (Syria)",                                     L"ARS" },
 // { 0x2c01, 1256,  720, 10004, L"Arabic (Jordan)",                                    L"ARJ" },
 // { 0x3001, 1256,  720, 10004, L"Arabic (Lebanon)",                                   L"ARB" },
 // { 0x3401, 1256,  720, 10004, L"Arabic (Kuwait)",                                    L"ARK" },
 // { 0x3801, 1256,  720, 10004, L"Arabic (U.A.E.)",                                    L"ARU" },
 // { 0x3c01, 1256,  720, 10004, L"Arabic (Bahrain)",                                   L"ARH" },
 // { 0x4001, 1256,  720, 10004, L"Arabic (Qatar)",                                     L"ARQ" },
    { 0x0402, 1251,  866, 10007, L"Bulgarian (Bulgaria)",                               L"BGR" },
 // { 0x0403, 1252,  850, 10000, L"Catalan (Spain)",                                    L"CAT" },
    { 0x0404,  950,  950, 10002, L"Chinese(Taiwan) (Taiwan)",                           L"CHT" },
    { 0x0804,  936,  936, 10008, L"Chinese(PRC) (People's Republic of China)",          L"CHS" },
 // { 0x0c04,  936,  936, 10002, L"Chinese(Hong Kong) (Hong Kong)",                     L"ZHH" },
 // { 0x1004,  936,  936, 10008, L"Chinese(Singapore) (Singapore)",                     L"ZHI" },
 // { 0x1404,  936,  936, 10002, L"Chinese(Macau) (Macau)",                             L"ZHM" },
    { 0x0405, 1250,  852, 10029, L"Czech (Czech Republic)",                             L"CSY" },
    { 0x0406, 1252,  850, 10000, L"Danish (Denmark)",                                   L"DAN" },
    { 0x0407, 1252,  850, 10000, L"German (Germany)",                                   L"DEU" },
 // { 0x0807, 1252,  850, 10000, L"German (Switzerland)",                               L"DES" },
 // { 0x0c07, 1252,  850, 10000, L"German (Austria)",                                   L"DEA" },
 // { 0x1007, 1252,  850, 10000, L"German (Luxembourg)",                                L"DEL" },
 // { 0x1407, 1252,  850, 10000, L"German (Liechtenstein)",                             L"DEC" },
    { 0x0408, 1253,  737, 10006, L"Greek (Greece)",                                     L"ELL" },
 // { 0x2008, 1253,  869, 10006, L"Greek 2 (Greece)",                                   L"ELL" },
    { 0x0409, 1252,  437, 10000, L"English (United States)",                            L"ENU" },
 // { 0x0809, 1252,  850, 10000, L"English (United Kingdom)",                           L"ENG" },
 // { 0x0c09, 1252,  850, 10000, L"English (Australia)",                                L"ENA" },
 // { 0x1009, 1252,  850, 10000, L"English (Canada)",                                   L"ENC" },
 // { 0x1409, 1252,  850, 10000, L"English (New Zealand)",                              L"ENZ" },
 // { 0x1809, 1252,  850, 10000, L"English (Ireland)",                                  L"ENI" },
 // { 0x1c09, 1252,  437, 10000, L"English (South Africa)",                             L"ENS" },
 // { 0x2009, 1252,  850, 10000, L"English (Jamaica)",                                  L"ENJ" },
 // { 0x2409, 1252,  850, 10000, L"English (Caribbean)",                                L"ENB" },
 // { 0x2809, 1252,  850, 10000, L"English (Belize)",                                   L"ENL" },
 // { 0x2c09, 1252,  850, 10000, L"English (Trinidad y Tobago)",                        L"ENT" },
 // { 0x3009, 1252,  437, 10000, L"English (Zimbabwe)",                                 L"ENW" },
 // { 0x3409, 1252,  437, 10000, L"English (Republic of the Philippines)",              L"ENP" },
 // { 0x040a, 1252,  850, 10000, L"Spanish - Traditional Sort (Spain)",                 L"ESP" },
 // { 0x080a, 1252,  850, 10000, L"Spanish (Mexico)",                                   L"ESM" },
    { 0x0c0a, 1252,  850, 10000, L"Spanish - International Sort (Spain)",               L"ESN" },
 // { 0x100a, 1252,  850, 10000, L"Spanish (Guatemala)",                                L"ESG" },
 // { 0x140a, 1252,  850, 10000, L"Spanish (Costa Rica)",                               L"ESC" },
 // { 0x180a, 1252,  850, 10000, L"Spanish (Panama)",                                   L"ESA" },
 // { 0x1c0a, 1252,  850, 10000, L"Spanish (Dominican Republic)",                       L"ESD" },
 // { 0x200a, 1252,  850, 10000, L"Spanish (Venezuela)",                                L"ESV" },
 // { 0x240a, 1252,  850, 10000, L"Spanish (Colombia)",                                 L"ESO" },
 // { 0x280a, 1252,  850, 10000, L"Spanish (Peru)",                                     L"ESR" },
 // { 0x2c0a, 1252,  850, 10000, L"Spanish (Argentina)",                                L"ESS" },
 // { 0x300a, 1252,  850, 10000, L"Spanish (Ecuador)",                                  L"ESF" },
 // { 0x340a, 1252,  850, 10000, L"Spanish (Chile)",                                    L"ESL" },
 // { 0x380a, 1252,  850, 10000, L"Spanish (Uruguay)",                                  L"ESY" },
 // { 0x3c0a, 1252,  850, 10000, L"Spanish (Paraguay)",                                 L"ESZ" },
 // { 0x400a, 1252,  850, 10000, L"Spanish (Bolivia)",                                  L"ESB" },
 // { 0x440a, 1252,  850, 10000, L"Spanish (El Salvador)",                              L"ESE" },
 // { 0x480a, 1252,  850, 10000, L"Spanish (Honduras)",                                 L"ESH" },
 // { 0x4c0a, 1252,  850, 10000, L"Spanish (Nicaragua)",                                L"ESI" },
 // { 0x500a, 1252,  850, 10000, L"Spanish (Puerto Rico)",                              L"ESU" },
    { 0x040b, 1252,  850, 10000, L"Finnish (Finland)",                                  L"FIN" },
    { 0x040c, 1252,  850, 10000, L"French (France)",                                    L"FRA" },
 // { 0x080c, 1252,  850, 10000, L"French (Belgium)",                                   L"FRB" },
 // { 0x0c0c, 1252,  850, 10000, L"French (Canada)",                                    L"FRC" },
 // { 0x100c, 1252,  850, 10000, L"French (Switzerland)",                               L"FRS" },
 // { 0x140c, 1252,  850, 10000, L"French (Luxembourg)",                                L"FRL" },
 // { 0x180c, 1252,  850, 10000, L"French (Principality of Monaco)",                    L"FRM" },
    { 0x040d, 1255,  862, 10005, L"Hebrew (Israel)",                                    L"HEB" },
    { 0x040e, 1250,  852, 10029, L"Hungarian (Hungary)",                                L"HUN" },
 // { 0x040f, 1252,  850, 10079, L"Icelandic (Iceland)",                                L"ISL" },
    { 0x0410, 1252,  850, 10000, L"Italian (Italy)",                                    L"ITA" },
 // { 0x0810, 1252,  850, 10000, L"Italian (Switzerland)",                              L"ITS" },
    { 0x0411,  932,  932, 10001, L"Japanese (Japan)",                                   L"JPN" },
    { 0x0412,  949,  949, 10003, L"Korean (Korea)",                                     L"KOR" },
    { 0x0413, 1252,  850, 10000, L"Dutch (Netherlands)",                                L"NLD" },
 // { 0x0813, 1252,  850, 10000, L"Dutch (Belgium)",                                    L"NLB" },
    { 0x0414, 1252,  850, 10000, L"Norwegian (Bokml) (Norway)",                         L"NOR" },
 // { 0x0814, 1252,  850, 10000, L"Norwegian (Nynorsk) (Norway)",                       L"NON" },
    { 0x0415, 1250,  852, 10029, L"Polish (Poland)",                                    L"PLK" },
    { 0x0416, 1252,  850, 10000, L"Portuguese (Brazil)",                                L"PTB" },
    { 0x0816, 1252,  850, 10000, L"Portuguese (Portugal)",                              L"PTG" },
    { 0x0418, 1250,  852, 10029, L"Romanian (Romania)",                                 L"ROM" },
    { 0x0419, 1251,  866, 10007, L"Russian (Russia)",                                   L"RUS" },
    { 0x041a, 1250,  852, 10082, L"Croatian (Croatia)",                                 L"HRV" },
 // { 0x081a, 1250,  852, 10029, L"Serbian (Latin) (Serbia)",                           L"SRL" },
 // { 0x0c1a, 1251,  855, 10007, L"Serbian (Cyrillic) (Serbia)",                        L"SRB" },
    { 0x041b, 1250,  852, 10029, L"Slovak (Slovakia)",                                  L"SKY" },
 // { 0x041c, 1250,  852, 10029, L"Albanian (Albania)",                                 L"SQI" },
    { 0x041d, 1252,  850, 10000, L"Swedish (Sweden)",                                   L"SVE" },
 // { 0x081d, 1252,  850, 10000, L"Swedish (Finland)",                                  L"SVF" },
    { 0x041e,  874,  874, 10000, L"Thai (Thailand)",                                    L"THA" },
    { 0x041f, 1254,  857, 10081, L"Turkish (Turkey)",                                   L"TRK" },
 // { 0x0420, 1256,  720, 10004, L"Urdu (Islamic Republic of Pakistan)",                L"URP" },
 // { 0x0421, 1252,  850, 10000, L"Indonesian (Indonesia)",                             L"IND" },
 // { 0x0422, 1251,  866, 10017, L"Ukrainian (Ukraine)",                                L"UKR" },
 // { 0x0423, 1251,  866, 10007, L"Belarusian (Belarus)",                               L"BEL" },
    { 0x0424, 1250,  852, 10029, L"Slovenian (Slovenia)",                               L"SLV" },
    { 0x0425, 1257,  775, 10029, L"Estonian (Estonia)",                                 L"ETI" },
    { 0x0426, 1257,  775, 10029, L"Latvian (Latvia)",                                   L"LVI" },
    { 0x0427, 1257,  775, 10029, L"Lithuanian (Lithuania)",                             L"LTH" }
 // { 0x0827, 1257,  775, 10029, L"Classic Lithuanian (Lithuania)",                     L"LTC" },
 // { 0x0429, 1256,  720, 10004, L"Farsi (Iran)",                                       L"FAR" },
 // { 0x042a, 1258, 1258, 10000, L"Vietnamese (Viet Nam)",                              L"VIT" },
 // { 0x042b, 1252,  850, 10000, L"Armenian (Republic of Armenia)",                     L"HYE" },
 // { 0x042c, 1250,  852, 10029, L"Azeri (Azerbaijan)",                                 L"AZE" },
 // { 0x082c, 1251,  866, 10007, L"Azeri (Azerbaijan)",                                 L"AZE" },
 // { 0x042d, 1252,  850, 10000, L"Basque (Spain)",                                     L"EUQ" },
 // { 0x042f, 1251,  866, 10007, L"Macedonian (Former Yugoslav Republic of Macedonia)", L"MKI" },
 // { 0x0436, 1252,  850, 10000, L"Afrikaans (South Africa)",                           L"AFK" },
 // { 0x0437, 1252,  850, 10000, L"Georgian (Georgia)",                                 L"KAT" },
 // { 0x0438, 1252,  850, 10079, L"Faeroese (Faeroe Islands)",                          L"FOS" },
 // { 0x0439, 1252,  850, 10000, L"Hindi (India)",                                      L"HIN" },
 // { 0x043e, 1252,  850, 10000, L"Malay (Malaysia)",                                   L"MSL" },
 // { 0x083e, 1252,  850, 10000, L"Malay (Brunei Darussalam)",                          L"MSB" },
 // { 0x043f, 1251,  866, 10007, L"Kazak (Kazakstan)",                                  L"KAZ" },
 // { 0x0441, 1252,  437, 10000, L"Swahili (Kenya)",                                    L"SWK" },
 // { 0x0443, 1250,  852, 10029, L"Uzbek (Republic of Uzbekistan)",                     L"UZB" },
 // { 0x0843, 1251,  866, 10007, L"Uzbek (Republic of Uzbekistan)",                     L"UZB" },
 // { 0x0444, 1251,  866, 10007, L"Tatar (Tatarstan)",                                  L"TAT" },
 // { 0x0445, 1252,  850, 10000, L"Bengali (India)",                                    L"BEN" },
 // { 0x0446, 1252,  850, 10000, L"Punjabi (India)",                                    L"PAN" },
 // { 0x0447, 1252,  850, 10000, L"Gujarati (India)",                                   L"GUJ" },
 // { 0x0448, 1252,  850, 10000, L"Oriya (India)",                                      L"ORI" },
 // { 0x0449, 1252,  850, 10000, L"Tamil (India)",                                      L"TAM" },
 // { 0x044a, 1252,  850, 10000, L"Telugu (India)",                                     L"TEL" },
 // { 0x044b, 1252,  850, 10000, L"Kannada (India)",                                    L"KAN" },
 // { 0x044c, 1252,  850, 10000, L"Malayalam (India)",                                  L"MAL" },
 // { 0x044d, 1252,  850, 10000, L"Assamese (India)",                                   L"ASM" },
 // { 0x044e, 1252,  850, 10000, L"Marathi (India)",                                    L"MAR" },
 // { 0x044f, 1252,  850, 10000, L"Sanskrit (India)",                                   L"SAN" },
 // { 0x0457, 1252,  850, 10000, L"Konkani (India)",                                    L"KOK" }
};
const DWORD dwLocaleSize = sizeof(LocaleTable) / sizeof(LOADPERF_LANG_INFO);

WORD
LoadPerfGetLCIDFromString(
    LPWSTR szLangId
)
{
    WORD  dwLangId  = 0;
    DWORD dwLangLen = lstrlenW(szLangId);
    DWORD i;
    WCHAR szDigit;

    for (i = 0; i < dwLangLen; i ++) {
        dwLangId <<= 4;
        szDigit = szLangId[i];
        if (szDigit >= L'0' && szDigit <= L'9') {
            dwLangId += (szDigit - L'0');
        }
        else if (szDigit >= L'a' && szDigit <= L'f') {
            dwLangId += (10 + szDigit - L'a');
        }
        else if (szDigit >= L'A' && szDigit <= L'F') {
            dwLangId += (10 + szDigit - L'A');
        }
        else {
            dwLangId = 0;
            break;
        }
    }

    return dwLangId;
}

int
LoadPerfGetCodePage(
    LPWSTR szLCID
)
{
    int   CP_Ansi  = CP_ACP;
    int   CP_Oem   = CP_OEMCP;
    int   dwStart  = 0;
    int   dwEnd    = dwLocaleSize - 1;
    int   dwThis;
    WORD  thisLCID;
    WORD  thisprimaryLCID;
    WORD  primaryLCID;

    thisLCID        = LoadPerfGetLCIDFromString(szLCID);
    thisprimaryLCID = PRIMARYLANGID(thisLCID);

    while (dwStart <= dwEnd) {
        dwThis      = (dwEnd + dwStart) / 2;
        primaryLCID = PRIMARYLANGID(LocaleTable[dwThis].dwLCID);
        if (LocaleTable[dwThis].dwLCID == thisLCID) {
            CP_Ansi = LocaleTable[dwThis].cpAnsi;
            CP_Oem  = LocaleTable[dwThis].cpOem;
            break;
        }
        else if (primaryLCID < thisprimaryLCID) {
            dwStart = dwThis + 1;
        }
        else {
            dwEnd = dwThis - 1;
        }
    }
    if (dwStart > dwEnd) {
        dwStart = 0;
        dwEnd   = dwLocaleSize - 1;
        while (dwStart <= dwEnd) {
            dwThis      = (dwEnd + dwStart) / 2;
            primaryLCID = PRIMARYLANGID(LocaleTable[dwThis].dwLCID);
            if (primaryLCID == thisprimaryLCID) {
                CP_Ansi = LocaleTable[dwThis].cpAnsi;
                CP_Oem  = LocaleTable[dwThis].cpOem;
                break;
            }
            else if (primaryLCID < thisprimaryLCID) {
                dwStart = dwThis + 1;
            }
            else {
                dwEnd = dwThis - 1;
            }
        }
    }
    return CP_Ansi;
}

LPSTR
LoadPerfWideCharToMultiByte(
    UINT   CodePage,
    LPWSTR wszString
)
{
    // Callers need to free returned string buffer.
    //    LoadPerfBackupIniFile()
    //    LodctrSetServiceAsTructed()
    //    LoadIncludeFile()
    //    CreateObjectList()
    //    LoadLanguageList()

    LPSTR aszString = NULL;
    int   dwValue   = WideCharToMultiByte(CodePage, 0, wszString, -1, NULL, 0, NULL, NULL);
    if (dwValue != 0) {
        aszString = MemoryAllocate((dwValue + 1) * sizeof(CHAR));
        if (aszString != NULL) {
            WideCharToMultiByte(CodePage, 0, wszString, -1, aszString, dwValue + 1, NULL, NULL);
        }
    }
    return aszString;
}

LPWSTR
LoadPerfMultiByteToWideChar(
    UINT   CodePage,
    LPSTR  aszString
)
{
    // Callers need to free returned string buffer.
    //    UnloadPerfCounterTextStringsA()
    //    LoadPerfGetIncludeFileName(), which relies on caller LoadPerfBackupIniFile() to free this.
    //    LoadPerfBackupIniFile()
    //    BuildLanguageTables()
    //    LoadIncludeFile(). The string is part of SYMBOL_TABLE_ENTRY structure and will be freed at the end
    //            of LoadPerfInstallPerfDll().
    //    GetValue(), which relies on AddEntryToLanguage() (which calls GetValueFromIniKey() then calls GetValue())
    //            to free memory lpLocalStringBuff.
    //    CreateObjectList()
    //    LoadLanguageLists()
    //    InstallPerfDllA()
    //    LoadPerfCounterTextStringsA()
    //    UpdatePerfNameFilesA()
    //    SetServiceAsTrustedA()

    LPWSTR wszString = NULL;
    int    dwValue   = MultiByteToWideChar(CodePage, 0, aszString, -1, NULL, 0);
    if (dwValue != 0) {
        wszString = MemoryAllocate((dwValue + 1) * sizeof(WCHAR));
        if (wszString != NULL) {
            MultiByteToWideChar(CodePage, 0, aszString, -1, wszString, dwValue + 1);
        }
    }
    return wszString;
}

DWORD
LoadPerfGetFileSize(
    LPWSTR   szFileName,
    LPDWORD  pdwUnicode,
    BOOL     bUnicode
)
{
    DWORD  dwFileSize  = 0;
    HANDLE hFile       = NULL;

    if (bUnicode) {
        hFile = CreateFileW(
                szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }
    else {
        hFile = CreateFileA(
                (LPSTR) szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }
    if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
        dwFileSize = GetFileSize(hFile, NULL);

        if (pdwUnicode != NULL) {
            DWORD  dwRead  = dwFileSize;
            DWORD  dwType  = IS_TEXT_UNICODE_NULL_BYTES;
            LPBYTE pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize);
            BOOL   bResult;

            * pdwUnicode = 0;
            if (pBuffer != NULL) {
                bResult = ReadFile(hFile, (LPVOID) pBuffer, dwFileSize, & dwRead, NULL);
                if (bResult) {
                    bResult = IsTextUnicode((LPVOID) pBuffer, dwRead, & dwType);
                    * pdwUnicode = bResult ? 1 : 0;
                }
                HeapFree(GetProcessHeap(), 0, pBuffer);
            }
        }
        CloseHandle(hFile);
    }
    return dwFileSize;
}

LPCWSTR cszWmiLoadEventName   = L"WMI_SysEvent_LodCtr";
LPCWSTR cszWmiUnloadEventName = L"WMI_SysEvent_UnLodCtr";

DWORD LoadPerfSignalWmiWithNewData(DWORD dwEventId)
{
    HANDLE  hEvent;
    DWORD   dwStatus = ERROR_SUCCESS;

    LPWSTR szEventName = NULL;

    switch (dwEventId) {
    case WMI_LODCTR_EVENT:
        szEventName = (LPWSTR) cszWmiLoadEventName;
        break;

    case WMI_UNLODCTR_EVENT:
        szEventName = (LPWSTR) cszWmiUnloadEventName;
        break;

    default:
        dwStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    if (dwStatus == ERROR_SUCCESS) {
        hEvent = OpenEventW(EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE, szEventName);
        if (hEvent != NULL) {
            // set event
            SetEvent(hEvent);
            CloseHandle(hEvent);
        }
        else {
            dwStatus = GetLastError();
        }

    }
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\common\common.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

common.h

    constants and globals that are common to LODCTR and UNLODCTR

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

--*/
#ifndef _LODCTR_COMMON_H_
#define _LODCTR_COMMON_H_
//
//  Local constants
//
#define RESERVED                0L
#define LARGE_BUFFER_SIZE       0x10000         // 64K
#define MEDIUM_BUFFER_SIZE      0x8000          // 32K
#define SMALL_BUFFER_SIZE       0x1000          //  4K
#define FILE_NAME_BUFFER_SIZE   MAX_PATH
#define DISP_BUFF_SIZE          256L
#define SIZE_OF_OFFSET_STRING   15
#define PERFLIB_BASE_INDEX      1847
#define FIRST_EXT_COUNTER_INDEX 1848
#define FIRST_EXT_HELP_INDEX    1849
#define LOADPERF_BUFF_SIZE      1024

#define H_MUTEX_TIMEOUT         10000L
#define LODCTR_UPNF_RESTORE     0x00000001
#define LODCTR_UPNF_REPAIR      0x00000002
#define LODCTR_UPNF_NOINI       0x00000004
#define LODCTR_UPNF_NOBACKUP    0x00000008

#define cC           L'C'
#define cH           L'H'
#define cSpace       L' '
#define cEquals      '='
#define wEquals      L'='
#define cQuestion    L'?'
#define cBackslash   L'\\'
#define cUnderscore  L'_'
#define cHyphen      L'-'
#define cSlash       L'/'
#define cM           L'M'
#define cm           L'm'
#define cNull        L'\0'
#define cDoubleQuote L'\"'

//
//  Data structure and type definitions
//
typedef struct _NAME_ENTRY {
    struct _NAME_ENTRY  * pNext;
    DWORD                 dwOffset;
    DWORD                 dwType;
    LPWSTR                lpText;
} NAME_ENTRY, * PNAME_ENTRY;

typedef struct _LANGUAGE_LIST_ELEMENT {
    struct _LANGUAGE_LIST_ELEMENT  * pNextLang;       // next lang. list
    LPWSTR                           LangId;          // lang ID string for this elem
    DWORD                            dwLangId;
    PNAME_ENTRY                      pFirstName;      // head of name list
    PNAME_ENTRY                      pThisName;       // pointer to current entry
    DWORD                            dwNumElements;   // number of elements in array
    DWORD                            dwNameBuffSize;
    DWORD                            dwHelpBuffSize;
    PBYTE                            NameBuffer;      // buffer to store strings
    PBYTE                            HelpBuffer;      // buffer to store help strings
} LANGUAGE_LIST_ELEMENT, * PLANGUAGE_LIST_ELEMENT;

typedef struct _SYMBOL_TABLE_ENTRY {
    struct _SYMBOL_TABLE_ENTRY  * pNext;
    LPWSTR                        SymbolName;
    DWORD                         Value;
} SYMBOL_TABLE_ENTRY, * PSYMBOL_TABLE_ENTRY;

typedef struct _LANG_ENTRY {
    struct _LANG_ENTRY * pNext;
    LPWSTR               szLang;
    DWORD                dwLang;
    DWORD                dwLastCounter;
    DWORD                dwLastHelp;
    LPWSTR             * lpText;
} LANG_ENTRY, * PLANG_ENTRY;

typedef struct _SERVICE_ENTRY {
    struct _SERVICE_ENTRY * pNext;
    LPWSTR                  szService;
    LPWSTR                  szIniFile;
    DWORD                   dwObjects[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD                   dwNumObjects;
    DWORD                   dwFirstCounter;
    DWORD                   dwFirstHelp;
    DWORD                   dwLastCounter;
    DWORD                   dwLastHelp;
    DWORD                   dwDisable;
} SERVICE_ENTRY, * PSERVICE_ENTRY;

//
//  Utility Routine prototypes for routines in common.c
//
#define StringToInt(in,out) (((swscanf((in), (LPCWSTR) L" %d", (out))) == 1) ? TRUE : FALSE)

//#define _LOADPERF_SHOW_MEM_ALLOC 1
#define MemorySize(x) (x != NULL ? (DWORD) HeapSize(GetProcessHeap(), 0, x) : (DWORD) 0)

#ifndef _LOADPERF_SHOW_MEM_ALLOC
#define MemoryAllocate(x) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x)
#define MemoryFree(x)     if (x != NULL) HeapFree(GetProcessHeap(), 0, x)
#define MemoryResize(x,y) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x, y)
#else
__inline
LPVOID LoadPerfHeapAlloc(LPSTR szSource, DWORD dwLine, SIZE_T x)
{
    LPVOID lpReturn = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x);
    DbgPrint("HeapAlloc(%s#%d)(%d,0x%p)\n",
            szSource, dwLine, (lpReturn != NULL ? x : 0), lpReturn);
    return lpReturn;
}

__inline
BOOL
LoadPerfHeapFree(LPSTR szSource, DWORD dwLine, LPVOID x)
{
    BOOL   bReturn = TRUE;
    SIZE_T dwSize;

    if (x != NULL) {
        dwSize  = HeapSize(GetProcessHeap(), 0, x);
        bReturn = HeapFree(GetProcessHeap(), 0, x);
    DbgPrint("HeapFree(%s#%d)(0x%p,%d)\n",
            szSource, dwLine, x, (bReturn ? dwSize : 0));
    }
    return bReturn;
}

__inline
LPVOID
LoadPerfHeapReAlloc(LPSTR szSource, DWORD dwLine, LPVOID x, SIZE_T y)
{
    LPVOID  lpReturn;
    SIZE_T  dwSize;

    dwSize   = HeapSize(GetProcessHeap(), 0, x);
    lpReturn = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x, y);
    DbgPrint("HeapReAlloc(%s#%d)(0x%p,%d)(0x%p,%d)\n",
            szSource, dwLine, x, dwSize, lpReturn, (lpReturn != NULL ? y : 0));
    return lpReturn;
}

#define MemoryAllocate(x) LoadPerfHeapAlloc(__FILE__,__LINE__,x)
#define MemoryFree(x)     LoadPerfHeapFree(__FILE__,__LINE__,x)
#define MemoryResize(x,y) LoadPerfHeapReAlloc(__FILE__,__LINE__,x,y)
#endif

LPCWSTR
GetFormatResource(
    UINT    wStringId
);

VOID
DisplayCommandHelp(
    UINT    iFirstLine,
    UINT    iLastLine
);

BOOL
TrimSpaces(
    IN  OUT LPWSTR  szString
);

BOOL
IsDelimiter(
    IN  WCHAR   cChar,
    IN  WCHAR   cDelimiter
);

LPCWSTR
GetItemFromString(
    IN  LPCWSTR     szEntry,
    IN  DWORD       dwItem,
    IN  WCHAR       cDelimiter

);

BOOLEAN LoadPerfGrabMutex();
LPWSTR  LoadPerfGetInfPath();
LPWSTR  LoadPerfGetLanguage(LPWSTR szLang, BOOL bPrimary);

BOOL
LoadPerfBackupIniFile(
        LPCWSTR   szIniFile,
        LPWSTR    szLangId,
        LPWSTR  * szIniName,
        LPWSTR  * szDriverName,
        BOOL      bExtFile
);

void
ReportLoadPerfEvent(
    IN  WORD    EventType,
    IN  DWORD   EventID,
    IN  DWORD   dwDataCount,
    IN  DWORD   dwData1,
    IN  DWORD   dwData2,
    IN  DWORD   dwData3,
    IN  DWORD   dwData4,
    IN  WORD    wStringCount,
    IN  LPWSTR  szString1,
    IN  LPWSTR  szString2,
    IN  LPWSTR  szString3
);

LPSTR
LoadPerfWideCharToMultiByte(
        UINT   CodePage,
        LPWSTR wszString
);
LPWSTR
LoadPerfMultiByteToWideChar(
        UINT   CodePage,
        LPSTR  aszString
);

DWORD
LoadPerfGetFileSize(
        LPWSTR  szFileName,
        LPDWORD pdwUnicode,
        BOOL    bUnicode
);

WORD
LoadPerfGetLCIDFromString(
    LPWSTR szLangId
);

int
LoadPerfGetCodePage(
        LPWSTR szLCID
);

LPWSTR
* BuildNameTable(
    HKEY    hKeyRegistry,   // handle to registry db with counter names
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
);

DWORD
LoadPerfInstallPerfDll(
    DWORD          dwMode,
    LPCWSTR        szComputerName,
    LPWSTR         lpDriverName,
    LPCWSTR        lpIniFile,
    PLANG_ENTRY    LangList,
    PSERVICE_ENTRY pService,
    ULONG_PTR      dwFlags
);

DWORD
UpdatePerfNameFilesX(
    LPCWSTR   szNewCtrFilePath, // data file with new base counter strings
    LPCWSTR   szNewHlpFilePath, // data file with new base counter strings
    LPWSTR    szLanguageID,     // Lang ID to update
    ULONG_PTR dwFlags           // flags
);

BOOL
GetInstalledLanguageList(
    HKEY     hPerflibRoot,
    LPWSTR * mszLangList
);

#define WMI_LODCTR_EVENT    1
#define WMI_UNLODCTR_EVENT  2
DWORD
LoadPerfSignalWmiWithNewData(
        DWORD  dwEventId
);

extern LPCWSTR NamesKey;
extern LPCWSTR DefaultLangId;
extern LPCSTR  aszDefaultLangId;
extern LPCWSTR DefaultLangTag;
extern LPCWSTR Counters;
extern LPCWSTR Help;
extern LPCWSTR BaseIndex;
extern LPCWSTR LastHelp;
extern LPCWSTR LastCounter;
extern LPCWSTR FirstHelp;
extern LPCWSTR FirstCounter;
extern LPCWSTR Busy;
extern LPCWSTR Slash;
extern LPCWSTR BlankString;
extern LPCWSTR DriverPathRoot;
extern LPCWSTR Performance;
extern LPCWSTR CounterNameStr;
extern LPCWSTR HelpNameStr;
extern LPCWSTR AddCounterNameStr;
extern LPCWSTR AddHelpNameStr;
extern LPCWSTR VersionStr;
extern LPCWSTR szObjectList;
extern LPCWSTR szLibraryValidationCode;
extern LPCWSTR szDisplayName;
extern LPCWSTR szPerfIniPath;
extern LPCWSTR wszNotFound;
extern LPCSTR  szInfo;
extern LPCSTR  szSymbolFile;
extern LPCSTR  szNotFound;
extern LPCSTR  szLanguages;
extern LPCWSTR szLangUS;
extern LPCWSTR DisablePerformanceCounters;
extern LPCWSTR szDatExt;
extern LPCWSTR szBakExt;
extern LPCSTR  aszDriverName;

extern HANDLE  hEventLog; 
extern HANDLE  hLoadPerfMutex; 

#endif  // _LODCTR_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\common\dumpload.c ===
/*++
Copyright (c) 1991-1999  Microsoft Corporation

Module Name:
    dumpload.c

Abstract:
    functions to dump and load the contents of the performance related registry
    entries

Author:
    Bob Watson (bobw) 13 Jun 99

Revision History:
--*/
//
//  Windows Include files
//
#include <windows.h>
#include "strsafe.h"
#include "stdlib.h"
#include <winperf.h>
#include <loadperf.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  application include files
//
#include "winperfp.h"
#include "common.h"
#include "ldprfmsg.h"

#define DUMPLOAD_SERVICE_SIZE       32768
#define DUMPLOAD_NOSERVICE_SIZE     65536
#define DUMPLOAD_MAX_SERVICE_SIZE 4194304

// headings in save file
LPCWSTR cszFmtSectionHeader        = L"\r\n\r\n[%s]";
LPCWSTR cszFmtServiceSectionHeader = L"\r\n\r\n[PERF_%s]";
LPCWSTR cszFmtServiceSectionName   = L"PERF_%s";
LPCWSTR cszFmtStringSectionHeader  = L"\r\n\r\n[PerfStrings_%s]";
LPCWSTR cszFmtExtCtrString         = L"\r\n%d=%s";
LPCWSTR cszFmtDecimalParam         = L"\r\n%s=%d";
LPCWSTR cszFmtNoParam              = L"\r\n%s=";
LPCWSTR cszExtensiblePerfStrings   = L"Strings";
LPCWSTR cszPerfCounterServices     = L"PerfCounterServices";
LPCWSTR cszNoPerfCounterServices   = L"NoPerfCounterServices";
LPCWSTR cszPerflib                 = L"Perflib";

DWORD
DumpNameTable(
    HANDLE    hOutputFile,
    LPCWSTR   szLangId,
    LPCWSTR * pszNameTable,
    DWORD     dwStartIndex,
    DWORD     dwLastIndex
)
{
    DWORD   dwStatus       = ERROR_SUCCESS;
    DWORD   ndx            = 0;
    LPWSTR  szOutputBuffer = NULL;
    DWORD   dwBufSize      = SMALL_BUFFER_SIZE;
    DWORD   dwSize         = 0;
    DWORD   dwSizeWritten  = 0;
    HRESULT hr;

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
           __LINE__,
           LOADPERF_DUMPNAMETABLE,
           ARG_DEF(ARG_TYPE_WSTR, 1),
           ERROR_SUCCESS,
           TRACE_WSTR(szLangId),
           TRACE_DWORD(dwStartIndex),
           TRACE_DWORD(dwLastIndex),
           NULL));

    szOutputBuffer = MemoryAllocate(sizeof(WCHAR) * dwBufSize);
    if (szOutputBuffer == NULL) {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    hr = StringCchPrintfW(szOutputBuffer, dwBufSize, cszFmtStringSectionHeader, szLangId);
    dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
    WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);

    for (ndx = dwStartIndex; ndx <= dwLastIndex; ndx++) {
        if (pszNameTable[ndx] != NULL) {
            if (dwBufSize <= (DWORD) (lstrlenW(pszNameTable[ndx]) + 11)) {
                MemoryFree((LPVOID) szOutputBuffer);
                dwBufSize = (DWORD) (lstrlenW(pszNameTable[ndx]) + 11);
                szOutputBuffer = MemoryAllocate(dwBufSize * sizeof(WCHAR));
                if (szOutputBuffer == NULL) {
                    dwStatus = GetLastError();
                    goto Cleanup;
                }
            }
            ZeroMemory(szOutputBuffer, dwBufSize * sizeof(WCHAR));
            hr = StringCchPrintfW(szOutputBuffer, dwBufSize, cszFmtExtCtrString, ndx, pszNameTable[ndx]);
            dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
            WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
        }
    }

Cleanup:
    MemoryFree(szOutputBuffer);
    return dwStatus;
}

DWORD
DumpPerfServiceEntries(
    HANDLE  hOutputFile,
    LPCWSTR szServiceName,
    LPDWORD pdwFirstCounter,
    LPDWORD pdwFirstHelp,
    LPDWORD pdwLastCounter,
    LPDWORD pdwLastHelp,
    LPDWORD pdwDisablePerfCounters,
    LPWSTR  szPerfIniFile,
    DWORD   dwPerfIniFile,
    LPWSTR  mszObjectList,
    DWORD   dwObjectList,
    BOOL    bRemove
)
{
    DWORD   dwPerfSubKeyName = 0;
    LPWSTR  szPerfSubKeyName = NULL;
    HKEY    hKeyPerformance  = NULL;
    DWORD   dwItemSize, dwType, dwValue;
    DWORD   dwRegAccessMask;
    DWORD   dwRetStatus      = ERROR_SUCCESS;
    DWORD   dwSize, dwSizeWritten;
    LPWSTR  szOutputBuffer   = NULL;
    HRESULT hr;

    szOutputBuffer = MemoryAllocate(sizeof(WCHAR) * SMALL_BUFFER_SIZE);
    if (szOutputBuffer == NULL) {
        dwRetStatus = GetLastError();
        goto Cleanup;
    }

    // try read-only then
    if (bRemove) {
        dwRegAccessMask = KEY_READ | KEY_WRITE;
    }
    else {
        dwRegAccessMask = KEY_READ;
    }
    dwPerfSubKeyName = lstrlenW(DriverPathRoot) + lstrlenW(Slash)
                     + lstrlenW(szServiceName) + lstrlenW(Slash)
                     + lstrlenW(Performance) + 1;
    szPerfSubKeyName = MemoryAllocate(dwPerfSubKeyName * sizeof(WCHAR));
    if (szPerfSubKeyName != NULL) {
        hr = StringCchPrintfW(szPerfSubKeyName, dwPerfSubKeyName, L"%s%s%s%s%s",
                 DriverPathRoot, Slash, szServiceName, Slash, Performance);
        __try {
            dwRetStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, szPerfSubKeyName, 0L, dwRegAccessMask, & hKeyPerformance);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwRetStatus = GetExceptionCode();
        }
    }
    else {
        dwRetStatus = ERROR_OUTOFMEMORY;
    }

    if (dwRetStatus == ERROR_SUCCESS) {
        // key found so service has perf data
        if (hOutputFile != NULL) {
            ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
            hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtServiceSectionHeader, szServiceName);
            dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
            WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
        }

        // now check to see if the strings have been loaded
        dwType = dwValue = 0;
        dwItemSize = sizeof(dwValue);
        __try {
            dwRetStatus = RegQueryValueExW(hKeyPerformance,
                                           FirstCounter,
                                           NULL,
                                           & dwType,
                                           (LPBYTE) & dwValue,
                                           & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwRetStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFSERVICEENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               dwRetStatus,
               TRACE_WSTR(szServiceName),
               TRACE_WSTR(FirstCounter),
               TRACE_DWORD(dwValue),
               NULL));
        if (dwRetStatus == ERROR_SUCCESS && (dwType == REG_DWORD || dwType == REG_BINARY)) {
            if (pdwFirstCounter != NULL) {
                * pdwFirstCounter = dwValue;
            }
            if (hOutputFile != NULL) {
                ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtDecimalParam, FirstCounter, dwValue);
                dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
                WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
            }
        }

        dwType = dwValue = 0;
        dwItemSize = sizeof(dwValue);
        __try {
            dwRetStatus = RegQueryValueExW(hKeyPerformance,
                                           FirstHelp,
                                           NULL,
                                           & dwType,
                                           (LPBYTE) & dwValue,
                                           & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwRetStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFSERVICEENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               dwRetStatus,
               TRACE_WSTR(szServiceName),
               TRACE_WSTR(FirstHelp),
               TRACE_DWORD(dwValue),
               NULL));
        if (dwRetStatus == ERROR_SUCCESS && (dwType == REG_DWORD || dwType == REG_BINARY)) {
            if (pdwFirstHelp != NULL) {
                * pdwFirstHelp = dwValue;
            }
            if (hOutputFile != NULL) {
                ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtDecimalParam, FirstHelp, dwValue);
                dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
                WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
            }
        }

        dwType = dwValue = 0;
        dwItemSize = sizeof(dwValue);
        __try {
            dwRetStatus = RegQueryValueExW(hKeyPerformance,
                                           LastCounter,
                                           NULL,
                                           & dwType,
                                           (LPBYTE) & dwValue,
                                           & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwRetStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFSERVICEENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               dwRetStatus,
               TRACE_WSTR(szServiceName),
               TRACE_WSTR(LastCounter),
               TRACE_DWORD(dwValue),
               NULL));
        if (dwRetStatus == ERROR_SUCCESS && (dwType == REG_DWORD || dwType == REG_BINARY)) {
            if (pdwLastCounter != NULL) {
                * pdwLastCounter = dwValue;
            }
            if (hOutputFile != NULL) {
                ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtDecimalParam, LastCounter, dwValue);
                dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
                WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
            }
        }

        dwType = dwValue = 0;
        dwItemSize = sizeof(dwValue);
        __try {
            dwRetStatus = RegQueryValueExW(hKeyPerformance,
                                           LastHelp,
                                           NULL,
                                           & dwType,
                                           (LPBYTE) & dwValue,
                                           & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwRetStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFSERVICEENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               dwRetStatus,
               TRACE_WSTR(szServiceName),
               TRACE_WSTR(LastHelp),
               TRACE_DWORD(dwValue),
               NULL));
        if (dwRetStatus == ERROR_SUCCESS && (dwType == REG_DWORD || dwType == REG_BINARY)) {
            if (pdwLastHelp != NULL) {
                * pdwLastHelp = dwValue;
            }
            if (hOutputFile != NULL) {
                ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtDecimalParam, LastHelp, dwValue);
                dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
                WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
            }
        }

        dwType = dwValue = 0;
        dwItemSize = sizeof(dwValue);
        __try {
            dwRetStatus = RegQueryValueExW(hKeyPerformance,
                                           DisablePerformanceCounters,
                                           NULL,
                                           & dwType,
                                           (LPBYTE) & dwValue,
                                           & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwRetStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFSERVICEENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               dwRetStatus,
               TRACE_WSTR(szServiceName),
               TRACE_WSTR(DisablePerformanceCounters),
               TRACE_DWORD(dwValue),
               NULL));
        if (dwRetStatus == ERROR_SUCCESS && (dwType == REG_DWORD || dwType == REG_BINARY)) {
            if (pdwDisablePerfCounters != NULL) {
                * pdwDisablePerfCounters = dwValue;
            }
            if (hOutputFile != NULL) {
                ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtDecimalParam, DisablePerformanceCounters, dwValue);
                dwSize = lstrlenW(szOutputBuffer) * sizeof (WCHAR);
                WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
            }
        }
        else {
            dwRetStatus = ERROR_SUCCESS;
        }

        if (szPerfIniFile != NULL) {
            dwType     = 0;
            dwItemSize = sizeof(WCHAR) * dwPerfIniFile;
            __try {
                dwRetStatus = RegQueryValueExW(hKeyPerformance,
                                               szPerfIniPath,
                                               NULL,
                                               & dwType,
                                               (LPBYTE) szPerfIniFile,
                                               & dwItemSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                dwRetStatus = GetExceptionCode();
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   dwRetStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(DisablePerformanceCounters),
                   TRACE_DWORD(dwValue),
                   NULL));
        }

        if (mszObjectList != NULL) {
            dwType     = 0;
            dwItemSize = sizeof(WCHAR) * dwObjectList;
            __try {
                dwRetStatus = RegQueryValueExW(hKeyPerformance,
                                               szObjectList,
                                               NULL,
                                               & dwType,
                                               (LPBYTE) mszObjectList,
                                               & dwItemSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                dwRetStatus = GetExceptionCode();
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   dwRetStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(DisablePerformanceCounters),
                   TRACE_DWORD(dwValue),
                   NULL));
            if (dwRetStatus == ERROR_SUCCESS && dwType != REG_MULTI_SZ) {
                LPWSTR szChar = mszObjectList;
                while ((szChar != NULL) && (* szChar != cNull)) {
                    if (* szChar == cSpace) * szChar = cNull;
                    szChar ++;
                }
            }
            else {
                dwRetStatus = ERROR_SUCCESS;
            }
        }

        if (bRemove) {
            RegDeleteValueW(hKeyPerformance, FirstCounter);
            RegDeleteValueW(hKeyPerformance, LastCounter);
            RegDeleteValueW(hKeyPerformance, FirstHelp);
            RegDeleteValueW(hKeyPerformance, LastHelp);
            RegDeleteValueW(hKeyPerformance, szObjectList);
        }
        RegCloseKey (hKeyPerformance);
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFSERVICEENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwRetStatus,
               TRACE_WSTR(szServiceName),
               NULL));
    }

Cleanup:
    MemoryFree(szPerfSubKeyName);
    return dwRetStatus;
}

DWORD
DumpPerflibEntries(
    HANDLE  hOutputFile,
    LPDWORD pdwBaseIndex,
    LPDWORD pdwLastCounter,
    LPDWORD pdwLastHelp,
    LPDWORD pdwFirstExtCtrIndex

)
{
    HKEY    hKeyPerflib      = NULL;
    DWORD   dwStatus         = ERROR_SUCCESS;
    DWORD   dwItemSize, dwType, dwValue;
    DWORD   dwSize, dwSizeWritten;
    LPWSTR  szOutputBuffer   = NULL;
    HRESULT hr;

    szOutputBuffer = MemoryAllocate(sizeof(WCHAR) * SMALL_BUFFER_SIZE);
    if (szOutputBuffer == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
    }
    if (dwStatus == ERROR_SUCCESS) {
        __try {
            dwStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, NamesKey, 0L, KEY_READ, & hKeyPerflib);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
    }
    if (dwStatus == ERROR_SUCCESS) {
        if (hOutputFile != NULL) {
            ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
            hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtSectionHeader, cszPerflib);
            dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
        }
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(NamesKey),
               NULL));
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof(dwValue);
        __try {
            dwStatus = RegQueryValueExW(hKeyPerflib, BaseIndex, NULL, & dwType, (LPBYTE) & dwValue, & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(BaseIndex),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            if (pdwBaseIndex != NULL) {
                * pdwBaseIndex = dwValue;
            }
            if (hOutputFile != NULL) {
                ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtDecimalParam, BaseIndex, dwValue);
                dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
                WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
            }
            if (pdwFirstExtCtrIndex != NULL) {
                * pdwFirstExtCtrIndex = dwValue + 1;
            }
        }
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof(dwValue);
        __try {
            dwStatus = RegQueryValueExW(hKeyPerflib, LastCounter, NULL, & dwType, (LPBYTE) & dwValue, & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(LastCounter),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            if (pdwLastCounter != NULL) {
                * pdwLastCounter = dwValue;
            }
            if (hOutputFile != NULL) {
                ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtDecimalParam, LastCounter, dwValue);
                dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
                WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
            }
        }
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof(dwValue);
        __try {
            dwStatus = RegQueryValueExW(hKeyPerflib, LastHelp, NULL, & dwType, (LPBYTE) & dwValue, & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(LastHelp),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            if (pdwLastHelp != NULL) {
                * pdwLastHelp = dwValue;
            }
            if (hOutputFile != NULL) {
                ZeroMemory(szOutputBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                hr = StringCchPrintfW(szOutputBuffer, SMALL_BUFFER_SIZE, cszFmtDecimalParam, LastHelp, dwValue);
                dwSize = lstrlenW(szOutputBuffer) * sizeof(WCHAR);
                WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
            }
        }
    }

    if (hKeyPerflib != NULL)    RegCloseKey(hKeyPerflib);
    MemoryFree(szOutputBuffer);
    return dwStatus;
}

DWORD
BuildServiceLists(
    LPWSTR  mszPerfServiceList,
    LPDWORD pcchPerfServiceListSize,
    LPWSTR  mszNoPerfServiceList,
    LPDWORD pcchNoPerfServiceListSize
)
{
    LONG    lEnumStatus         = ERROR_SUCCESS;
    DWORD   dwServiceIndex      = 0;
    LPWSTR  szServiceSubKeyName = NULL;
    LPWSTR  szPerfSubKeyName    = NULL;
    DWORD   dwNameSize          = MAX_PATH;
    HKEY    hKeyPerformance;
    HKEY    hKeyServices        = NULL;
    DWORD   dwItemSize, dwType, dwValue;
    DWORD   dwRegAccessMask;
    DWORD   bServiceHasPerfCounters;
    DWORD   dwRetStatus         = ERROR_SUCCESS;
    LPWSTR  szNextNoPerfChar, szNextPerfChar;
    DWORD   dwNoPerfSizeRem, dwPerfSizeRem;
    DWORD   dwPerfSizeUsed = 0, dwNoPerfSizeUsed = 0;
    HRESULT hr;

    // try read-only then
    dwRegAccessMask = KEY_READ;
    szServiceSubKeyName = MemoryAllocate(MAX_PATH * sizeof(WCHAR));
    szPerfSubKeyName    = MemoryAllocate((MAX_PATH + 32) * sizeof(WCHAR));
    if (szServiceSubKeyName == NULL || szPerfSubKeyName == NULL) {
        dwRetStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    __try {
        dwRetStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, DriverPathRoot, 0L, dwRegAccessMask, & hKeyServices);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwRetStatus = GetExceptionCode();
    }
    if (dwRetStatus == ERROR_SUCCESS) {
        szNextNoPerfChar = mszNoPerfServiceList;
        szNextPerfChar   = mszPerfServiceList;
        dwNoPerfSizeRem  = * pcchPerfServiceListSize;
        dwPerfSizeRem    = * pcchNoPerfServiceListSize;
        dwPerfSizeUsed   = 0;
        dwNoPerfSizeUsed = 0;

        dwNameSize = MAX_PATH;
        ZeroMemory(szServiceSubKeyName, MAX_PATH * sizeof(WCHAR));
        ZeroMemory(szPerfSubKeyName, (MAX_PATH + 32) * sizeof(WCHAR));
        while ((lEnumStatus = RegEnumKeyExW(hKeyServices,
                                            dwServiceIndex,
                                            szServiceSubKeyName,
                                            & dwNameSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL)) == ERROR_SUCCESS) {
            //try to open the perfkey under this key.
            hr = StringCchPrintfW(szPerfSubKeyName, MAX_PATH + 32, L"%s%s%s", szServiceSubKeyName, Slash, Performance);
            __try {
                dwRetStatus = RegOpenKeyExW(hKeyServices, szPerfSubKeyName, 0L, dwRegAccessMask, & hKeyPerformance);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                dwRetStatus = GetExceptionCode();
            }
            if (dwRetStatus == ERROR_SUCCESS) {
                // key found so service has perf data
                // now check to see if the strings have been loaded
                dwType = dwValue = 0;
                dwItemSize = sizeof(dwValue);
                __try {
                    dwRetStatus = RegQueryValueExW(hKeyPerformance,
                                                   FirstCounter,
                                                   NULL,
                                                   & dwType,
                                                   (LPBYTE) & dwValue,
                                                   & dwItemSize);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    dwRetStatus = GetExceptionCode();
                }
                if (dwRetStatus == ERROR_SUCCESS && (dwType == REG_DWORD || dwType == REG_BINARY)) {
                    bServiceHasPerfCounters = TRUE;
                }
                else {
                    bServiceHasPerfCounters = FALSE;
                }
                RegCloseKey (hKeyPerformance);
            }
            else {
                // key not found so service doesn't have perfdata
                bServiceHasPerfCounters = FALSE;
                dwRetStatus = ERROR_SUCCESS;
            }

            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_BUILDSERVICELISTS,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   dwRetStatus,
                   TRACE_WSTR(szServiceSubKeyName),
                   TRACE_DWORD(bServiceHasPerfCounters),
                   NULL));

            if (bServiceHasPerfCounters != FALSE) {
                // add to the perf service list
                if ((dwNameSize + 1) < dwPerfSizeRem) {
                    // add to list
                    hr = StringCchCopyW(szNextPerfChar, dwPerfSizeRem, szServiceSubKeyName);
                    szNextPerfChar  += dwNameSize;
                    * szNextPerfChar = L'\0';
                    szNextPerfChar ++;
                    dwPerfSizeRem   -= dwNameSize + 1;
                }
                else {
                    dwPerfSizeRem = 0;
                    dwRetStatus   = ERROR_MORE_DATA;
                }
                dwPerfSizeUsed += dwNameSize + 1;
            }
            else {
                // add to the no perf list
                if ((dwNameSize + 1) < dwNoPerfSizeRem) {
                    // add to list
                    hr = StringCchCopyW(szNextNoPerfChar, dwNoPerfSizeRem, szServiceSubKeyName);
                    szNextNoPerfChar  += dwNameSize;
                    * szNextNoPerfChar = L'\0';
                    szNextNoPerfChar ++;
                    dwNoPerfSizeRem   -= dwNameSize + 1;
                }
                else {
                    dwNoPerfSizeRem = 0;
                    dwRetStatus     = ERROR_MORE_DATA;
                }
                dwNoPerfSizeUsed += dwNameSize + 1;
            }
            // reset for next loop
            dwServiceIndex ++;
            dwNameSize = MAX_PATH;
            ZeroMemory(szServiceSubKeyName, MAX_PATH * sizeof(WCHAR));
            ZeroMemory(szPerfSubKeyName, (MAX_PATH + 32) * sizeof(WCHAR));
        }

        // zero term the MSZ
        if (1 < dwPerfSizeRem) {
            * szNextPerfChar = L'\0';
            szNextPerfChar ++;
            dwPerfSizeRem   -= 1;
        }
        else {
            dwRetStatus = ERROR_MORE_DATA;
        }
        dwPerfSizeUsed += 1;

        // zero term the no perf list
        if (1 < dwNoPerfSizeRem) {
            // add to list
            * szNextNoPerfChar = L'\0';
            szNextNoPerfChar ++;
            dwNoPerfSizeRem   -= 1;
        }
        else {
            dwRetStatus = ERROR_MORE_DATA;
        }
        dwNoPerfSizeUsed += 1;
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_BUILDSERVICELISTS,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwRetStatus,
               TRACE_WSTR(DriverPathRoot),
               NULL));
    }

Cleanup:
    if (hKeyServices        != NULL) RegCloseKey(hKeyServices);
    MemoryFree(szServiceSubKeyName);
    MemoryFree(szPerfSubKeyName);

    if (dwRetStatus == ERROR_SUCCESS || dwRetStatus == ERROR_MORE_DATA) {
        * pcchPerfServiceListSize   = dwPerfSizeUsed;
        * pcchNoPerfServiceListSize = dwNoPerfSizeUsed;
    }
    return dwRetStatus;
}

DWORD
BackupPerfRegistryToFileW(
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szCommentString
)
{
    HANDLE    hOutFile                = NULL;
    DWORD     dwStatus                = ERROR_SUCCESS;
    LPWSTR    szNewFileName           = NULL;
    DWORD     dwNewFileNameLen;
    DWORD     dwOrigFileNameLen;
    DWORD     dwFileNameSN;
    LPWSTR    mszPerfServiceList      = NULL;
    DWORD     dwPerfServiceListSize   = 0;
    LPWSTR    mszNoPerfServiceList    = NULL;
    DWORD     dwNoPerfServiceListSize = 0;
    LPWSTR  * lpCounterText           = NULL;
    DWORD     dwLastElement           = 0;
    DWORD     dwFirstExtCtrIndex      = 0;
    LPWSTR    szThisServiceName;
    HRESULT   hr;

    DBG_UNREFERENCED_PARAMETER(szCommentString);

    WinPerfStartTrace(NULL);

    if (szFileName == NULL) {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            dwNewFileNameLen = lstrlenW(szFileName);
            if (dwNewFileNameLen == 0) dwStatus = ERROR_INVALID_PARAMETER;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    }
    if (dwStatus == ERROR_SUCCESS) {
        // open output file
        hOutFile = CreateFileW(szFileName,
                               GENERIC_WRITE,
                               0,                     // no sharing
                               NULL,                  // default security
                               CREATE_NEW,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
        // if the file open failed
        if (hOutFile == INVALID_HANDLE_VALUE) {
            // see if it's because the file already exists
            dwStatus = GetLastError();
            if (dwStatus == ERROR_FILE_EXISTS) {
                // then try appending a serial number to the name
                dwOrigFileNameLen = lstrlenW(szFileName) + 1;
                dwNewFileNameLen  = dwOrigFileNameLen + 4;
                szNewFileName     = MemoryAllocate(dwNewFileNameLen * sizeof(WCHAR));
                if (szNewFileName != NULL) {
                    hr = StringCchCopyW(szNewFileName, dwOrigFileNameLen, szFileName);
                    for (dwFileNameSN = 1; dwFileNameSN < 1000; dwFileNameSN++) {
                        hr = StringCchPrintfW(& szNewFileName[dwOrigFileNameLen - 1],
                                         dwNewFileNameLen,
                                         L"_%3.3d",
                                         dwFileNameSN);
                        hOutFile = CreateFileW(szNewFileName,
                                               GENERIC_WRITE,
                                               0,                     // no sharing
                                               NULL,                  // default security
                                               CREATE_NEW,
                                               FILE_ATTRIBUTE_NORMAL,
                                               NULL);
                        // if the file open failed
                        if (hOutFile == INVALID_HANDLE_VALUE) {
                            dwStatus = GetLastError();
                            if (dwStatus != ERROR_FILE_EXISTS) {
                                // some other error occurred so bail out
                                break;
                            }
                            else {
                                continue; // with the next try
                            }
                        }
                        else {
                            // found one not in use so continue on
                            dwStatus = ERROR_SUCCESS;
                            break;
                        }
                    }
                }
                else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }
        }
        else {
            // file opened so continue
            dwStatus = ERROR_SUCCESS;
        }
    }
    if (dwStatus == ERROR_SUCCESS) {
        // dump perflib key entires
        dwStatus = DumpPerflibEntries(hOutFile, NULL, NULL, NULL, & dwFirstExtCtrIndex);
    }
    if (dwStatus == ERROR_SUCCESS) {
        do {
            MemoryFree(mszPerfServiceList);
            mszPerfServiceList = NULL;
            MemoryFree(mszNoPerfServiceList);
            mszNoPerfServiceList = NULL;

            // build service lists
            dwPerfServiceListSize   += DUMPLOAD_SERVICE_SIZE;
            dwNoPerfServiceListSize += DUMPLOAD_NOSERVICE_SIZE;
            mszPerfServiceList       = MemoryAllocate(dwPerfServiceListSize   * sizeof(WCHAR));
            mszNoPerfServiceList     = MemoryAllocate(dwNoPerfServiceListSize * sizeof(WCHAR));
            if (mszNoPerfServiceList == NULL || mszPerfServiceList  == NULL) {
                dwStatus = ERROR_OUTOFMEMORY;
                break;
            }
            if (dwStatus != ERROR_OUTOFMEMORY) {
                dwStatus = BuildServiceLists(mszPerfServiceList,
                                             & dwPerfServiceListSize,
                                             mszNoPerfServiceList,
                                             & dwNoPerfServiceListSize);
            }
        } while (dwStatus == ERROR_MORE_DATA && dwPerfServiceListSize < DUMPLOAD_MAX_SERVICE_SIZE);
    }

    // dump service entries for those services with perf counters
    if (dwStatus == ERROR_SUCCESS) {
        for (szThisServiceName  = mszPerfServiceList;
                         * szThisServiceName != 0;
                         szThisServiceName += lstrlenW(szThisServiceName) + 1) {
            dwStatus = DumpPerfServiceEntries(hOutFile,
                                              szThisServiceName,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              0,
                                              NULL,
                                              0,
                                              FALSE);
            if (dwStatus != ERROR_SUCCESS) break;
        }
    }

    // dump perf string entries
    if (dwStatus == ERROR_SUCCESS) {
        WCHAR szLangId[8];
        DWORD dwIndex      = 0;
        DWORD dwCopyIndex  = 0;
        DWORD dwTmpStatus  = ERROR_SUCCESS;
        DWORD dwBufferSize;
        HKEY  hPerflibRoot = NULL;

        __try {
            dwStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, NamesKey, RESERVED, KEY_READ, & hPerflibRoot);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
        while (dwStatus == ERROR_SUCCESS) {
            dwBufferSize = 8;
            ZeroMemory(szLangId, 8 * sizeof(WCHAR));
            dwStatus = RegEnumKeyExW(hPerflibRoot,
                                     dwIndex,
                                     szLangId,
                                     & dwBufferSize,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
            if (dwStatus == ERROR_SUCCESS) {
                lpCounterText = BuildNameTable(HKEY_LOCAL_MACHINE, (LPWSTR) szLangId, & dwLastElement);
                if (lpCounterText != NULL) {
                    __try {
                        dwStatus = DumpNameTable(hOutFile, szLangId, lpCounterText, 0, dwLastElement);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwStatus = GetExceptionCode();
                        TRACE((WINPERF_DBG_TRACE_ERROR),
                              (& LoadPerfGuid,
                               __LINE__,
                               LOADPERF_BACKUPPERFREGISTRYTOFILEW,
                               ARG_DEF(ARG_TYPE_WSTR, 1),
                               dwStatus,
                               TRACE_WSTR(szLangId),
                               TRACE_DWORD(dwLastElement),
                               NULL));
                    }
                    MemoryFree(lpCounterText);
                    lpCounterText = NULL;
                }
                else {
                    dwStatus = GetLastError();
                }
                if (dwStatus == ERROR_SUCCESS) {
                    dwCopyIndex ++;
                }
                else {
                    dwTmpStatus = dwStatus;
                    dwStatus    = ERROR_SUCCESS;
                }
            }
            dwIndex ++;
        }
        if (dwStatus == ERROR_NO_MORE_ITEMS) dwStatus = ERROR_SUCCESS;
        if (dwStatus == ERROR_SUCCESS && dwCopyIndex == 0) {
            dwStatus = dwTmpStatus;
        }
        if (hPerflibRoot != NULL) RegCloseKey(hPerflibRoot);
    }

    // free buffers
    MemoryFree(lpCounterText);
    MemoryFree(mszNoPerfServiceList);
    MemoryFree(mszPerfServiceList);
    MemoryFree(szNewFileName);

    // close file handles
    if (hOutFile != NULL && hOutFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hOutFile);
    }
    return dwStatus;
}

DWORD
LoadPerfRepairPerfRegistry()
{
    DWORD             dwStatus      = ERROR_SUCCESS;
    DWORD             dwBaseIndex   = 0;
    DWORD             dwLastCounter = 0;
    DWORD             dwLastHelp    = 0;
    HKEY              hKeyPerflib   = NULL;
    DWORD             dwValue       = 0;
    DWORD             dwIndex       = 0;
    DWORD             dw1Size       = 0;
    DWORD             dwSize        = 0;
    LPWSTR            szInfPath     = NULL;
    LPWSTR            szLangID      = NULL;
    LPWSTR            szCtrFile     = NULL;
    LPWSTR            szHlpFile     = NULL;
    HANDLE            hCtrFile      = NULL;
    HANDLE            hHlpFile      = NULL;
    WIN32_FIND_DATAW  FindCtrFile;
    WIN32_FIND_DATAW  FindHlpFile;
    PLANG_ENTRY       LangList      = NULL;
    PLANG_ENTRY       pThisLang     = NULL;
    LPWSTR            mszService    = NULL;
    DWORD             dwService     = 0;
    LPWSTR            mszObjectList = NULL;
    DWORD             dwObjectList  = 0;
    LPWSTR            mszNonService = NULL;
    DWORD             dwNonService  = 0;
    LPWSTR            szThisService = NULL;
    PSERVICE_ENTRY    ServiceList   = NULL;
    PSERVICE_ENTRY    pThisService  = NULL;
    HRESULT           hr;

    if (LoadPerfGrabMutex() == FALSE) {
        return GetLastError();
    }

    dwStatus = DumpPerflibEntries(NULL, & dwBaseIndex, & dwLastCounter, & dwLastHelp, NULL);
    if (dwStatus != ERROR_SUCCESS) goto Cleanup;

    __try {
        dwStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, NamesKey, RESERVED, KEY_WRITE | KEY_READ, & hKeyPerflib);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = GetExceptionCode();
    }
    if (dwStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_REPAIRPERFREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                dwStatus,
                TRACE_WSTR(NamesKey),
                NULL));
        goto Cleanup;
    }

    if ((szInfPath = LoadPerfGetInfPath()) == NULL) {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    // String format <szInfPath><lang-id>\PERFD<langid>.DAT
    // The buffer size will be lstrlenW(szInfPath) + 18
    //
    dw1Size = lstrlenW(szInfPath) + 20;
    if (dw1Size < MAX_PATH) dw1Size = MAX_PATH;

    dwSize     = dw1Size + dw1Size + 8;
    szCtrFile  = MemoryAllocate(dwSize * sizeof(WCHAR));
    if (szCtrFile == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    szHlpFile  = (LPWSTR) (szCtrFile + dw1Size);
    szLangID   = (LPWSTR) (szHlpFile + dw1Size);

    dwIndex  = 0;
    dwSize   = 8;
    dwStatus = RegEnumKeyExW(hKeyPerflib, dwIndex, szLangID, & dwSize, NULL, NULL, NULL, NULL);
    while (dwStatus == ERROR_SUCCESS) {
        LPWSTR szThisLang = LoadPerfGetLanguage(szLangID, FALSE);
        DWORD  dwLast;

        pThisLang = (PLANG_ENTRY) MemoryAllocate(sizeof(LANG_ENTRY) + sizeof(WCHAR) * (lstrlenW(szThisLang) + 1));
        if (pThisLang == NULL) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        pThisLang->szLang        = (LPWSTR) (((LPBYTE) pThisLang) + sizeof(LANG_ENTRY));
        hr = StringCchCopyW(pThisLang->szLang, (lstrlenW(szThisLang) + 1), szThisLang);
        pThisLang->dwLang        = LoadPerfGetLCIDFromString(pThisLang->szLang);
        pThisLang->dwLastCounter = dwLastCounter;
        pThisLang->dwLastHelp    = dwLastHelp;
        pThisLang->lpText        = BuildNameTable(HKEY_LOCAL_MACHINE, szLangID, & dwLast);
        pThisLang->pNext         = LangList;
        LangList                 = pThisLang;
        dwIndex ++;
        dwSize = 8;
        ZeroMemory(szLangID, 8 * sizeof(WCHAR));
        dwStatus = RegEnumKeyExW(hKeyPerflib, dwIndex, szLangID, & dwSize, NULL, NULL, NULL, NULL);
    }
    if (dwStatus == ERROR_NO_MORE_ITEMS) dwStatus = ERROR_SUCCESS;
    if (dwStatus != ERROR_SUCCESS) goto Cleanup;

    dwValue = dwBaseIndex - 1;
    __try {
        dwStatus = RegSetValueExW(hKeyPerflib, LastCounter, RESERVED, REG_DWORD, (LPBYTE) & dwValue, sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = GetExceptionCode();
    }
    if (dwStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_REPAIRPERFREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                dwStatus,
                TRACE_WSTR(LastCounter),
                TRACE_DWORD(dwValue),
                NULL));
        goto Cleanup;
    }
    dwValue = dwBaseIndex;
    __try {
        dwStatus = RegSetValueExW(hKeyPerflib, LastHelp, RESERVED, REG_DWORD, (LPBYTE) & dwValue, sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = GetExceptionCode();
    }
    if (dwStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_REPAIRPERFREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                dwStatus,
                TRACE_WSTR(LastHelp),
                TRACE_DWORD(dwValue),
                NULL));
        goto Cleanup;
    }

    dwIndex  = 0;
    dwSize   = 8;
    dwStatus = RegEnumKeyExW(hKeyPerflib, dwIndex, szLangID, & dwSize, NULL, NULL, NULL, NULL);
    while (dwStatus == ERROR_SUCCESS) {
        LPWSTR szThisLang = LoadPerfGetLanguage(szLangID, FALSE);
        DWORD  dwLast;

        ZeroMemory(szCtrFile, dw1Size * sizeof(WCHAR));
        hr = StringCchPrintfW(szCtrFile, dw1Size, L"%s%s%s*d%s%s", szInfPath, szThisLang, Slash, szThisLang, szDatExt);
        ZeroMemory(szHlpFile, dw1Size * sizeof(WCHAR));
        hr = StringCchPrintfW(szHlpFile, dw1Size, L"%s%s%s*i%s%s", szInfPath, szThisLang, Slash, szThisLang, szDatExt);
        hCtrFile = FindFirstFileW(szCtrFile, & FindCtrFile);
        hHlpFile = FindFirstFileW(szHlpFile, & FindHlpFile);

        if (hCtrFile == INVALID_HANDLE_VALUE || hHlpFile == INVALID_HANDLE_VALUE) {
            szThisLang = (LPWSTR) DefaultLangId;

            ZeroMemory(szCtrFile, dw1Size * sizeof(WCHAR));
            hr = StringCchPrintfW(szCtrFile, dw1Size, L"%s%s%s*d%s%s", szInfPath, szThisLang, Slash, szThisLang, szDatExt);
            ZeroMemory(szHlpFile, dw1Size * sizeof(WCHAR));
            hr = StringCchPrintfW(szHlpFile, dw1Size, L"%s%s%s*i%s%s", szInfPath, szThisLang, Slash, szThisLang, szDatExt);
            hCtrFile = FindFirstFileW(szCtrFile, & FindCtrFile);
            hHlpFile = FindFirstFileW(szHlpFile, & FindHlpFile);
        }

        if (hCtrFile != INVALID_HANDLE_VALUE && hHlpFile != INVALID_HANDLE_VALUE) {
            ZeroMemory(szCtrFile, dw1Size * sizeof(WCHAR));
            hr = StringCchPrintfW(szCtrFile, dw1Size, L"%s%s%s%s", szInfPath, szThisLang, Slash, FindCtrFile.cFileName);
            ZeroMemory(szHlpFile, dw1Size * sizeof(WCHAR));
            hr = StringCchPrintfW(szHlpFile, dw1Size, L"%s%s%s%s", szInfPath, szThisLang, Slash, FindHlpFile.cFileName);
            FindClose(hCtrFile);
            FindClose(hHlpFile);
            dwStatus = UpdatePerfNameFilesX(szCtrFile, szHlpFile, szLangID, LODCTR_UPNF_REPAIR);
        }
        else {
            dwStatus = GetLastError();
        }
        if (dwStatus == ERROR_SUCCESS) {
            dwIndex ++;
            dwSize = 8;
            ZeroMemory(szLangID, 8 * sizeof(WCHAR));
            dwStatus = RegEnumKeyExW(hKeyPerflib, dwIndex, szLangID, & dwSize, NULL, NULL, NULL, NULL);
        }
    }
    if (dwStatus == ERROR_NO_MORE_ITEMS) dwStatus = ERROR_SUCCESS;
    if (dwStatus != ERROR_SUCCESS) goto Cleanup;

    do {
        MemoryFree(mszService);
        mszService = NULL;
        MemoryFree(mszNonService);
        mszNonService = NULL;

        dwService    += DUMPLOAD_SERVICE_SIZE;
        dwNonService += DUMPLOAD_NOSERVICE_SIZE;
        mszService    = MemoryAllocate(dwService    * sizeof(WCHAR));
        mszNonService = MemoryAllocate(dwNonService * sizeof(WCHAR));

        if (mszService == NULL || mszNonService == NULL) {
            dwStatus = ERROR_OUTOFMEMORY;
            break;
        }

        if (dwStatus == ERROR_SUCCESS) {
            dwStatus = BuildServiceLists(mszService, & dwService, mszNonService, & dwNonService);
        }
    }
    while (dwStatus == ERROR_MORE_DATA && dwService < DUMPLOAD_MAX_SERVICE_SIZE);

    if (dwStatus != ERROR_SUCCESS) goto Cleanup;

    dwObjectList = LOADPERF_BUFF_SIZE;
    mszObjectList = MemoryAllocate(dwObjectList * sizeof(WCHAR));
    if (mszObjectList == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    for (szThisService  = mszService;
             szThisService != NULL && szThisService[0] != cNull && dwStatus == ERROR_SUCCESS;
             szThisService += (lstrlenW(szThisService) + 1)) {
        pThisService = (PSERVICE_ENTRY) MemoryAllocate(sizeof(SERVICE_ENTRY)
                  + sizeof(WCHAR) * (MAX_PATH + lstrlenW(szThisService) + 1));
        if (pThisService == NULL) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        pThisService->pNext = ServiceList;
        ServiceList         = pThisService;

        pThisService->szIniFile = (LPWSTR) (((LPBYTE) pThisService) + sizeof(SERVICE_ENTRY));
        pThisService->szService = (LPWSTR) (((LPBYTE) pThisService->szIniFile) + sizeof(WCHAR) * MAX_PATH);
        hr = StringCchCopyW(pThisService->szService, lstrlenW(szThisService) + 1, szThisService);

        ZeroMemory(mszObjectList, dwObjectList * sizeof(WCHAR));
        dwStatus = DumpPerfServiceEntries(NULL,
                                          pThisService->szService,
                                          & pThisService->dwFirstCounter,
                                          & pThisService->dwFirstHelp,
                                          & pThisService->dwLastCounter,
                                          & pThisService->dwLastHelp,
                                          & pThisService->dwDisable,
                                          pThisService->szIniFile,
                                          MAX_PATH,
                                          mszObjectList,
                                          dwObjectList,
                                          TRUE);
        if (dwStatus == ERROR_SUCCESS) {
            LPWSTR szObjectId = mszObjectList;

            pThisService->dwNumObjects = 0;
            while ((szObjectId != NULL) && (* szObjectId != cNull)) {
                if (pThisService->dwNumObjects
                        >= MAX_PERF_OBJECTS_IN_QUERY_FUNCTION) {
                    break;
                }
                pThisService->dwObjects[pThisService->dwNumObjects] =
                                wcstoul(szObjectId, NULL, 10) - pThisService->dwFirstCounter;
                pThisService->dwNumObjects ++;
                szObjectId += (lstrlenW(szObjectId) + 1);
            }
        }
    }

    for (pThisService  = ServiceList; pThisService != NULL; pThisService  = pThisService->pNext) {
        if (pThisService->szIniFile[0] != cNull) {
            dwStatus = LoadPerfInstallPerfDll(LODCTR_UPNF_REPAIR,
                                              NULL,
                                              pThisService->szService,
                                              pThisService->szIniFile,
                                              NULL,
                                              NULL,
                                              LOADPERF_FLAGS_LOAD_REGISTRY_ONLY);
        }
        else {
            dwStatus = LoadPerfInstallPerfDll(LODCTR_UPNF_REPAIR | LODCTR_UPNF_NOINI,
                                              NULL,
                                              pThisService->szService,
                                              NULL,
                                              LangList,
                                              pThisService,
                                              LOADPERF_FLAGS_LOAD_REGISTRY_ONLY);
        }
        if (dwStatus != ERROR_SUCCESS) {
            ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE,
                    (DWORD) LDPRFMSG_REPAIR_SERVICE_FAIL,
                    2, dwStatus, __LINE__, 0, 0,
                    1, (LPWSTR) pThisService->szService, NULL, NULL);
        }
    }

Cleanup:
    if (hKeyPerflib   != NULL) RegCloseKey(hKeyPerflib);
    MemoryFree(szCtrFile);
    MemoryFree(mszObjectList);
    MemoryFree(mszService);
    MemoryFree(mszNonService);

    pThisLang = LangList;
    while (pThisLang != NULL) {
        PLANG_ENTRY pTmpLang = pThisLang;
        pThisLang = pThisLang->pNext;
        MemoryFree(pTmpLang->lpText);
        MemoryFree(pTmpLang);
    }

    pThisService = ServiceList;
    while (pThisService != NULL) {
        PSERVICE_ENTRY pTmpService = pThisService;
        pThisService = pThisService->pNext;
        MemoryFree(pTmpService);
    }
    ReleaseMutex(hLoadPerfMutex);
    return dwStatus;
}

DWORD
RestorePerfRegistryFromFileW(
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szLangId
)
{
    LONG    lEnumStatus         = ERROR_SUCCESS;
    DWORD   dwServiceIndex      = 0;
    LPWSTR  szServiceSubKeyName = NULL;
    LPWSTR  szPerfSubKeyName    = NULL;
    LPWSTR  wPerfSection        = NULL;
    DWORD   dwNameSize          = MAX_PATH;
    HKEY    hKeyPerformance;
    HKEY    hKeyServices        = NULL;
    HKEY    hKeyPerflib         = NULL;
    DWORD   dwRegAccessMask;
    DWORD   dwRetStatus         = ERROR_SUCCESS;
    UINT    nValue;
    DWORD   dwnValue;
    BOOL    bServiceRegistryOk  = TRUE;
    WCHAR   szLocalLangId[8];
    HRESULT hr;

    WinPerfStartTrace(NULL);

    if (szFileName == NULL) {
        // this is the case to repair performance registry.
        //
        dwRetStatus = LoadPerfRepairPerfRegistry();
        goto Cleanup;
    }
    else {
        __try {
            DWORD dwName = lstrlenW(szFileName);
            if (dwName == 0) dwRetStatus = ERROR_INVALID_PARAMETER;

            if (szLangId != NULL) {
                dwName = lstrlenW(szLangId);
                if (dwName == 0) dwRetStatus = ERROR_INVALID_PARAMETER;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwRetStatus = ERROR_INVALID_PARAMETER;
        }
    }
    if (dwRetStatus != ERROR_SUCCESS) goto Cleanup;

    szServiceSubKeyName = MemoryAllocate(MAX_PATH * sizeof(WCHAR));
    szPerfSubKeyName    = MemoryAllocate((MAX_PATH + 32) * sizeof(WCHAR));
    wPerfSection        = MemoryAllocate((MAX_PATH + 32) * sizeof(WCHAR));
    if (szServiceSubKeyName == NULL || szPerfSubKeyName == NULL || wPerfSection == NULL) {
        dwRetStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    __try {
        dwRetStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, DriverPathRoot, 0L, KEY_READ, & hKeyServices);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwRetStatus = GetExceptionCode();
    }
    if (dwRetStatus == ERROR_SUCCESS) {
        // enum service list
        dwNameSize = MAX_PATH;
        ZeroMemory(szServiceSubKeyName, MAX_PATH * sizeof(WCHAR));
        ZeroMemory(szPerfSubKeyName, (MAX_PATH + 32) * sizeof(WCHAR));
        while ((lEnumStatus = RegEnumKeyExW(hKeyServices,
                                            dwServiceIndex,
                                            szServiceSubKeyName,
                                            & dwNameSize,
                                            NULL, NULL, NULL, NULL)) == ERROR_SUCCESS) {
            //try to open the perfkey under this key.
            hr = StringCchPrintfW(szPerfSubKeyName, MAX_PATH + 32, L"%ws%ws%ws", szServiceSubKeyName, Slash, Performance);

            bServiceRegistryOk = TRUE;
            dwRegAccessMask    = KEY_READ | KEY_WRITE;
            // look for a performance subkey
            __try {
                dwRetStatus = RegOpenKeyExW(hKeyServices, szPerfSubKeyName, 0L, dwRegAccessMask, & hKeyPerformance);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                dwRetStatus = GetExceptionCode();
            }
            if (dwRetStatus == ERROR_SUCCESS) {
                // key found so service has perf data
                // if performance subkey then
                hr = StringCchPrintfW(wPerfSection, MAX_PATH + 32, cszFmtServiceSectionName, szServiceSubKeyName);

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW(wPerfSection, FirstCounter, -1, szFileName);
                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    __try {
                        dwRetStatus = RegSetValueExW(hKeyPerformance,
                                                     FirstCounter,
                                                     0L,
                                                     REG_DWORD,
                                                     (const BYTE *) & nValue,
                                                     sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwRetStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                                     | ARG_DEF(ARG_TYPE_WSTR, 3),
                           dwRetStatus,
                           TRACE_WSTR(szFileName),
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(FirstCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                }
                else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW(wPerfSection, FirstHelp, -1, szFileName);

                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    __try {
                        dwRetStatus = RegSetValueExW(hKeyPerformance,
                                                     FirstHelp,
                                                     0L,
                                                     REG_DWORD,
                                                     (const BYTE *) & nValue,
                                                     sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwRetStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                                     | ARG_DEF(ARG_TYPE_WSTR, 3),
                           dwRetStatus,
                           TRACE_WSTR(szFileName),
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(FirstHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                }
                else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW(wPerfSection, LastCounter, -1, szFileName);
                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    __try {
                        dwRetStatus = RegSetValueExW(hKeyPerformance,
                                                     LastCounter,
                                                     0L,
                                                     REG_DWORD,
                                                     (const BYTE *) & nValue,
                                                     sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwRetStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                                     | ARG_DEF(ARG_TYPE_WSTR, 3),
                           dwRetStatus,
                           TRACE_WSTR(szFileName),
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(LastCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                }
                else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW(wPerfSection, LastHelp, -1, szFileName);
                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    __try {
                        dwRetStatus = RegSetValueExW(hKeyPerformance,
                                                     LastHelp,
                                                     0L,
                                                     REG_DWORD,
                                                     (const BYTE *) & nValue,
                                                     sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwRetStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                                     | ARG_DEF(ARG_TYPE_WSTR, 3),
                           dwRetStatus,
                           TRACE_WSTR(szFileName),
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(LastHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                }
                else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                if (! bServiceRegistryOk) {
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           ERROR_SUCCESS,
                           TRACE_WSTR(szFileName),
                           TRACE_WSTR(szServiceSubKeyName),
                           NULL));
                    // an error occurred so delete the first/last counter/help values
                    RegDeleteValueW(hKeyPerformance, FirstCounter);
                    RegDeleteValueW(hKeyPerformance, FirstHelp);
                    RegDeleteValueW(hKeyPerformance, LastCounter);
                    RegDeleteValueW(hKeyPerformance, LastHelp);
                } // else continiue

                RegCloseKey (hKeyPerformance);
            } // else this service has no perf data so skip
            else {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                       ARG_DEF(ARG_TYPE_WSTR, 1),
                       dwRetStatus,
                       TRACE_WSTR(szServiceSubKeyName),
                       NULL));
                if (dwRetStatus != ERROR_FILE_NOT_FOUND && dwRetStatus != ERROR_NO_MORE_ITEMS) break;
            }

            // reset for next loop
            dwServiceIndex ++;
            dwNameSize = MAX_PATH;
            ZeroMemory(szServiceSubKeyName, MAX_PATH * sizeof(WCHAR));
            ZeroMemory(szPerfSubKeyName, (MAX_PATH + 32) * sizeof(WCHAR));
        } // end enum service list

        if (dwRetStatus == ERROR_NO_MORE_ITEMS || dwRetStatus == ERROR_FILE_NOT_FOUND) dwRetStatus = ERROR_SUCCESS;
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwRetStatus,
               TRACE_WSTR(DriverPathRoot),
               NULL));
    }

    if (hKeyServices != NULL) RegCloseKey(hKeyServices);

    if (dwRetStatus == ERROR_SUCCESS) {
        __try {
            dwRetStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, NamesKey, RESERVED, KEY_ALL_ACCESS, & hKeyPerflib);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwRetStatus = GetExceptionCode();
        }
        if (dwRetStatus != ERROR_SUCCESS) {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   dwRetStatus,
                   TRACE_WSTR(NamesKey),
                   NULL));
        }

        if (szLangId != NULL) {
            // merge registry string values:
            hr = StringCchCopyW(szLocalLangId, 8, szLangId);
            dwRetStatus = UpdatePerfNameFilesX(szFileName, NULL, szLocalLangId, LODCTR_UPNF_RESTORE);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   dwRetStatus,
                   TRACE_WSTR(szFileName),
                   TRACE_WSTR(szLocalLangId),
                   NULL));
        }
        else if (dwRetStatus == ERROR_SUCCESS) {
            DWORD dwIndex = 0;
            DWORD dwBufferSize;

            while (dwRetStatus == ERROR_SUCCESS) {
                dwBufferSize = 8;
                ZeroMemory(szLocalLangId, 8 * sizeof(WCHAR));
                dwRetStatus = RegEnumKeyExW(hKeyPerflib,
                                            dwIndex,
                                            szLocalLangId,
                                            & dwBufferSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                       ARG_DEF(ARG_TYPE_WSTR, 1),
                       dwRetStatus,
                       TRACE_WSTR(szLocalLangId),
                       TRACE_DWORD(dwIndex),
                       TRACE_DWORD(dwBufferSize),
                       NULL));
                if (dwRetStatus == ERROR_SUCCESS) {
                    dwRetStatus = UpdatePerfNameFilesX(szFileName, NULL, szLocalLangId, LODCTR_UPNF_RESTORE);
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           dwRetStatus,
                           TRACE_WSTR(szFileName),
                           TRACE_WSTR(szLocalLangId),
                           NULL));
                }
                dwIndex ++;
            }

            if (dwRetStatus == ERROR_NO_MORE_ITEMS) {
                dwRetStatus = ERROR_SUCCESS;
            }
        }

        if (dwRetStatus == ERROR_SUCCESS) {
            // update the keys in the registry

            if (dwRetStatus == ERROR_SUCCESS) {
               nValue = GetPrivateProfileIntW(cszPerflib, LastCounter, -1, szFileName);
                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    __try {
                        dwRetStatus = RegSetValueExW(hKeyPerflib,
                                                     LastCounter,
                                                     0L,
                                                     REG_DWORD,
                                                     (const BYTE *) & nValue,
                                                     sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwRetStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           dwRetStatus,
                           TRACE_WSTR(LastCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

            if (dwRetStatus == ERROR_SUCCESS) {
                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW(cszPerflib, LastHelp, -1, szFileName);
                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    __try {
                        dwRetStatus = RegSetValueExW(hKeyPerflib,
                                                     LastHelp,
                                                     0L,
                                                     REG_DWORD,
                                                     (const BYTE *) & nValue,
                                                     sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwRetStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           dwRetStatus,
                           TRACE_WSTR(LastHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

            if (dwRetStatus == ERROR_SUCCESS) {
                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW(cszPerflib, BaseIndex, -1, szFileName);
                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    __try {
                        dwRetStatus = RegSetValueExW(hKeyPerflib,
                                                     BaseIndex,
                                                     0L,
                                                     REG_DWORD,
                                                     (const BYTE *) & nValue,
                                                     sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwRetStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           dwRetStatus,
                           TRACE_WSTR(BaseIndex),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

        }
        if (hKeyPerflib != NULL && hKeyPerflib != INVALID_HANDLE_VALUE) RegCloseKey(hKeyPerflib);
        dwRetStatus = dwRetStatus;
    }

Cleanup:
    MemoryFree(szServiceSubKeyName);
    MemoryFree(szPerfSubKeyName);
    MemoryFree(wPerfSection);
    return dwRetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\common\unlodctr.c ===
/*++
Copyright (c) 1991-1999  Microsoft Corporation

Module Name:
    unlodctr.c

Abstract:
    Program to remove the counter names belonging to the driver specified
        in the command line and update the registry accordingly

Author:
    Bob Watson (a-robw) 12 Feb 93

Revision History:
    Bob Watson (bobw)   10 Mar 99 added event log messages
--*/
//
//  Windows Include files
//
#include <windows.h>
#include "strsafe.h"
#define __LOADPERF__
#include <loadperf.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  local include files
//
#include "winperf.h"
#include "winperfp.h"
#include "common.h"
#include "unlodctr.h"
#include "ldprfmsg.h"

#define  OUTPUT_MESSAGE wprintf

LPWSTR
* UnlodctrBuildNameTable(
    HKEY      hKeyPerflib,       // handle to perflib key with counter names
    HKEY      hPerfData,
    LPWSTR    lpszLangId,        // unicode value of Language subkey
    DWORD     dwCounterItems,
    DWORD     dwHelpItems,
    PDWORD    pdwLastItem        // size of array in elements
)
/*++
UnlodctrBuildNameTable
    Caches the counter names and explain text to accelerate name lookups
    for display.

Arguments:
    hKeyPerflib
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.
    lpszLangId
            The unicode id of the language to look up. (default is 009)
    pdwLastItem
            The last array element

Return Value:
    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated TEXT strings.

    A NULL pointer is returned if an error occured. (error value is
    available using the GetLastError function).

    The structure of the buffer returned is:
        Array of pointers to zero terminated strings consisting of
            pdwLastItem elements
        MULTI_SZ string containing counter id's and names returned from
            registry for the specified language
        MULTI_SZ string containing explain text id's and explain text strings
            as returned by the registry for the specified language

    The structures listed above are contiguous so that they may be freed
    by a single "free" call when finished with them, however only the
    array elements are intended to be used.
--*/
{

    LPWSTR * lpReturnValue;       // returned pointer to buffer
    LPWSTR * lpCounterId;         //
    LPWSTR   lpCounterNames;      // pointer to Names buffer returned by reg.
    LPWSTR   lpHelpText;          // pointet to exlpain buffer returned by reg.
    LPWSTR   lpThisName;          // working pointer
    BOOL     bStatus;             // return status from TRUE/FALSE fn. calls
    BOOL     bReported;
    LONG     lWin32Status;        // return status from fn. calls
    DWORD    dwValueType;         // value type of buffer returned by reg.
    DWORD    dwArraySize;         // size of pointer array in bytes
    DWORD    dwBufferSize;        // size of total buffer in bytes
    DWORD    dwCounterSize;       // size of counter text buffer in bytes
    DWORD    dwHelpSize;          // size of help text buffer in bytes
    DWORD    dwThisCounter;       // working counter
    DWORD    dwLastId;            // largest ID value used by explain/counter text
    DWORD    dwLastCounterIdUsed;
    DWORD    dwLastHelpIdUsed;
    LPWSTR   lpValueNameString;   // pointer to buffer conatining subkey name
    LPWSTR   CounterNameBuffer  = NULL;
    LPWSTR   HelpNameBuffer     = NULL;
    HRESULT  hr;

    //initialize pointers to NULL
    lpValueNameString = NULL;
    lpReturnValue     = NULL;

    // check for null arguments and insert defaults if necessary

    if (! lpszLangId) {
        lpszLangId = (LPWSTR) DefaultLangId;
    }

    // use the greater of Help items or Counter Items to size array

    if (dwHelpItems >= dwCounterItems) {
        dwLastId = dwHelpItems;
    }
    else {
        dwLastId = dwCounterItems;
    }

    // array size is # of elements (+ 1, since names are "1" based)
    // times the size of a pointer

    dwArraySize = (dwLastId + 1) * sizeof(LPWSTR);

    // allocate string buffer for language ID key string

    CounterNameBuffer = MemoryAllocate(MAX_PATH * sizeof(WCHAR));
    HelpNameBuffer    = MemoryAllocate(MAX_PATH * sizeof(WCHAR));

    dwBufferSize = sizeof(WCHAR) * lstrlenW(NamesKey)
                 + sizeof(WCHAR) * lstrlenW(Slash)
                 + sizeof(WCHAR) * lstrlenW(lpszLangId)
                 + sizeof(WCHAR);
    lpValueNameString = MemoryAllocate(dwBufferSize);
    if (lpValueNameString == NULL || CounterNameBuffer == NULL || HelpNameBuffer == NULL) {
        lWin32Status = ERROR_OUTOFMEMORY;
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                1, __LINE__, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               0,
               lWin32Status,
               NULL));
        goto BNT_BAILOUT;
    }

    hr = StringCchPrintfW(CounterNameBuffer, MAX_PATH, L"%ws%ws", CounterNameStr, lpszLangId);
    hr = StringCchPrintfW(HelpNameBuffer,    MAX_PATH, L"%ws%ws", HelpNameStr,    lpszLangId);

    lWin32Status = ERROR_SUCCESS;

    // get size of counter names
    dwBufferSize = 0;
    __try {
        lWin32Status = RegQueryValueExW(hPerfData,
                                        CounterNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        NULL,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_WARNING_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                3, lWin32Status, dwBufferSize, __LINE__, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Counters),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }
    dwCounterSize = dwBufferSize;

    // get size of help text
    dwBufferSize = 0;
    __try {
        lWin32Status = RegQueryValueExW(hPerfData,
                                        HelpNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        NULL,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                3, lWin32Status, dwBufferSize, __LINE__, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Help),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }
    dwHelpSize = dwBufferSize;

    // allocate buffer with room for pointer array, counter name
    // strings and help name strings

    lpReturnValue = MemoryAllocate(dwArraySize + dwCounterSize + dwHelpSize);
    if (!lpReturnValue) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                4, dwArraySize, dwCounterSize, dwHelpSize, __LINE__,
                0, NULL, NULL, NULL);
        lWin32Status = ERROR_OUTOFMEMORY;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               0,
               lWin32Status,
               TRACE_DWORD(dwArraySize),
               TRACE_DWORD(dwCounterSize),
               TRACE_DWORD(dwHelpSize),
               NULL));
        goto BNT_BAILOUT;
    }

    // initialize pointers into buffer
    lpCounterId    = lpReturnValue;
    lpCounterNames = (LPWSTR) ((LPBYTE) lpCounterId    + dwArraySize);
    lpHelpText     = (LPWSTR) ((LPBYTE) lpCounterNames + dwCounterSize);

    // read counter names into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Name"
    dwBufferSize = dwCounterSize;
    __try {
        lWin32Status = RegQueryValueExW(hPerfData,
                                        CounterNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        (LPVOID) lpCounterNames,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_WARNING_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                3, lWin32Status, dwBufferSize, __LINE__, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Counters),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }
    // read explain text into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Text..."

    dwBufferSize = dwHelpSize;
    __try {
        lWin32Status = RegQueryValueExW(hPerfData,
                                        HelpNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        (LPVOID) lpHelpText,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                3, lWin32Status, dwBufferSize, __LINE__, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Help),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed    = 0;

    // load counter array items, by locating each text string
    // in the returned buffer and loading the
    // address of it in the corresponding pointer array element.

    bReported = FALSE;
    for (lpThisName = lpCounterNames; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
        // first string should be an integer (in decimal digit characters)
        // so translate to an integer for use in array element identification
        do {
            bStatus = StringToInt(lpThisName, &dwThisCounter);
            if (! bStatus) {
                if (! bReported) {
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_REGISTRY_CORRUPT_MULTI_SZ, // event,
                            1, __LINE__, 0, 0, 0,
                            2, CounterNameBuffer, lpThisName, NULL);
                    TRACE((WINPERF_DBG_TRACE_WARNING),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_UNLODCTR_BUILDNAMETABLE,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           ERROR_BADKEY,
                           TRACE_WSTR(Counters),
                           TRACE_WSTR(lpThisName),
                           NULL));
                    bReported = TRUE;
                }
                lpThisName += (lstrlenW(lpThisName) + 1);
            }
        }
        while ((! bStatus) && (* lpThisName != L'\0'));

        if (! bStatus) {
            lWin32Status = ERROR_BADKEY;
            goto BNT_BAILOUT;  // bad entry
        }
        if (dwThisCounter > dwCounterItems || dwThisCounter > dwLastId) {
            lWin32Status = ERROR_BADKEY;
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT, // event,
                    4, dwThisCounter, dwCounterItems, dwLastId, __LINE__,
                    1, lpThisName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwCounterItems),
                    TRACE_DWORD(dwHelpItems),
                    NULL));
            goto BNT_BAILOUT;
        }

        // point to corresponding counter name which follows the id number
        // string.
        lpThisName += (lstrlenW(lpThisName) + 1);

        // and load array element with pointer to string
        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;
    }

    // repeat the above for the explain text strings
    bReported = FALSE;
    for (lpThisName = lpHelpText; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
        // first string should be an integer (in decimal unicode digits)
        do {
            bStatus = StringToInt(lpThisName, &dwThisCounter);
            if (! bStatus) {
                if (! bReported) {
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_REGISTRY_CORRUPT_MULTI_SZ, // event,
                            1, __LINE__, 0, 0, 0,
                            2, HelpNameBuffer, lpThisName, NULL);
                    TRACE((WINPERF_DBG_TRACE_WARNING),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_UNLODCTR_BUILDNAMETABLE,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           ERROR_BADKEY,
                           TRACE_WSTR(Help),
                           TRACE_WSTR(lpThisName),
                           NULL));
                    bReported = TRUE;
                }
                lpThisName += (lstrlenW(lpThisName) + 1);
            }
        }
        while ((! bStatus) && (* lpThisName != L'\0'));
        if (!bStatus) {
            lWin32Status = ERROR_BADKEY;
            goto BNT_BAILOUT;  // bad entry
        }
        if (dwThisCounter > dwHelpItems || dwThisCounter > dwLastId) {
            lWin32Status = ERROR_BADKEY;
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT, // event,
                    4, dwThisCounter, dwHelpItems, dwLastId, __LINE__,
                    1, lpThisName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwCounterItems),
                    TRACE_DWORD(dwHelpItems),
                    NULL));
            goto BNT_BAILOUT;
        }

        // point to corresponding counter name
        lpThisName += (lstrlenW(lpThisName) + 1);

        // and load array element;
        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
           __LINE__,
           LOADPERF_UNLODCTR_BUILDNAMETABLE,
           0,
           ERROR_SUCCESS,
           TRACE_DWORD(dwLastId),
           TRACE_DWORD(dwLastCounterIdUsed),
           TRACE_DWORD(dwLastHelpIdUsed),
           TRACE_DWORD(dwCounterItems),
           TRACE_DWORD(dwHelpItems),
           NULL));

    if (dwLastHelpIdUsed > dwLastId || dwLastCounterIdUsed > dwLastId) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                4, dwLastId, dwLastCounterIdUsed, dwLastHelpIdUsed, __LINE__,
                0, NULL, NULL, NULL);
        lWin32Status = ERROR_BADKEY;
        goto BNT_BAILOUT;  // bad registry
    }

    // if the last item arugment was used, then load the last ID value in it

    if (pdwLastItem) * pdwLastItem = dwLastId;

BNT_BAILOUT:
    // free the temporary buffer used
    MemoryFree(lpValueNameString);
    MemoryFree(CounterNameBuffer);
    MemoryFree(HelpNameBuffer);

    if (lWin32Status != ERROR_SUCCESS) {
        // if lWin32Status has error, then set last error value to it,
        // otherwise assume that last error already has value in it
        SetLastError(lWin32Status);
        MemoryFree(lpReturnValue);
        lpReturnValue = NULL;
    }
    // exit returning the pointer to the buffer
    return lpReturnValue;

} // UnlodctrBuildNameTable

BOOL
GetDriverFromCommandLine(
    LPWSTR   lpCommandLine,
    HKEY   * hKeyMachine,
    LPWSTR   lpDriverName,
    HKEY   * hDriverPerf,
    HKEY   * hKeyDriver,
    BOOL     bQuietMode
)
/*++
GetDriverFromCommandLine
    locates the first argument in the command line string (after the
    image name) and checks to see if

        a) it's there
        b) it's the name of a device driver listed in the
            Registry\Machine\System\CurrentControlSet\Services key
            in the registry and it has a "Performance" subkey
        c) that the "First Counter" value under the Performance subkey
            is defined.

    if all these criteria are true, then the routine returns TRUE and
    passes the pointer to the driver name back in the argument. If any
    one of them fail, then NULL is returned in the DriverName arg and
    the routine returns FALSE

Arguments
    lpDriverName
        the address of a LPWSTR to recive the pointer to the driver name
    hDriverPerf
        the key to the driver's performance subkey

Return Value
    TRUE if a valid driver was found in the command line
    FALSE if not (see above)
--*/
{
    LPWSTR  lpDriverKey = NULL;    // buffer to build driver key name in
    LPWSTR  lpTmpDrive  = NULL;
    LONG    lStatus;
    DWORD   dwFirstCounter;
    DWORD   dwSize;
    DWORD   dwType;
    BOOL    bReturn       = FALSE;
    HRESULT hr;

    if (! lpDriverName || ! hDriverPerf) {
        SetLastError(ERROR_BAD_ARGUMENTS);
        goto Cleanup;
    }

    * hDriverPerf = NULL;

    // an argument was found so see if it's a driver "<DriverPathRoot>\<pDriverName>\Performance" 
    dwSize      = lstrlenW(DriverPathRoot)+ lstrlenW(lpCommandLine) + 32;
    if (dwSize < SMALL_BUFFER_SIZE) dwSize = SMALL_BUFFER_SIZE;
    lpDriverKey = MemoryAllocate(2 * dwSize * sizeof (WCHAR));
    if (lpDriverKey == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }
    lpTmpDrive = lpDriverKey + dwSize;

    // No remote LODCTR/UNLODCTR cases, so ignore computer name from command-line argument.
    //
    hr = StringCchCopyW(lpTmpDrive,   dwSize, GetItemFromString(lpCommandLine, 2, cSpace));
    hr = StringCchCopyW(lpDriverName, dwSize, GetItemFromString(lpCommandLine, 3, cSpace));
    if (lpTmpDrive[1] == cQuestion) {
        if (! bQuietMode) {
            DisplayCommandHelp(UC_FIRST_CMD_HELP, UC_LAST_CMD_HELP);
        }
        SetLastError(ERROR_SUCCESS);
        goto Cleanup;
    }

    // no /? so process args read
    if (lstrlenW(lpDriverName) == 0) {
        // then no computer name is specifed so assume the local computer
        // and the driver name is listed in the computer name param
        if (lstrlenW(lpTmpDrive) == 0) {
            // no input command-line parameter, bail out now.
            if (! bQuietMode) {
                DisplayCommandHelp(UC_FIRST_CMD_HELP, UC_LAST_CMD_HELP);
            }
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Cleanup;
        }
        else {
            hr = StringCchCopyW(lpDriverName, dwSize, lpTmpDrive);
        }
    }

    * hKeyMachine = HKEY_LOCAL_MACHINE;

    hr = StringCchPrintfW(lpDriverKey, dwSize, L"%ws%ws%ws", DriverPathRoot, Slash, lpDriverName);
    __try {
        lStatus = RegOpenKeyExW(* hKeyMachine, lpDriverKey, RESERVED, KEY_READ | KEY_WRITE, hKeyDriver);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus == ERROR_SUCCESS) {
        hr = StringCchPrintfW(lpDriverKey, dwSize, L"%ws%ws%ws%ws%ws",
                        DriverPathRoot, Slash, lpDriverName, Slash, Performance);
        __try {
            lStatus = RegOpenKeyExW(* hKeyMachine, lpDriverKey, RESERVED, KEY_READ | KEY_WRITE, hDriverPerf);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
    }
    if (lStatus == ERROR_SUCCESS) {
        //  this driver has a performance section so see if its
        //  counters are installed by checking the First Counter
        //  value key for a valid return. If it returns a value
        //  then chances are, it has some counters installed, if
        //  not, then display a message and quit.
        //
        dwType = 0;
        dwSize = sizeof (dwFirstCounter);
        __try {
            lStatus = RegQueryValueExW(* hDriverPerf,
                                       FirstCounter,
                                       RESERVED,
                                       & dwType,
                                       (LPBYTE) & dwFirstCounter,
                                       & dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
        if (lStatus == ERROR_SUCCESS) {
            // counter names are installed so return success
            SetLastError(ERROR_SUCCESS);
            bReturn = TRUE;
        }
        else {
            // counter names are probably not installed so return FALSE
            if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_NOTINSTALLED), lpDriverName);
            * lpDriverName = cNull; // remove driver name
            SetLastError(ERROR_BADKEY);
        }
    }
    else { // key not found
        if (lStatus != ERROR_INVALID_PARAMETER) {
            if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource (UC_DRIVERNOTFOUND), lpDriverKey, lStatus);
        }
        else {
            if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource (UC_BAD_DRIVER_NAME), 0);
        }
        SetLastError(lStatus);
    }

Cleanup:
    MemoryFree(lpDriverKey);
    if (bReturn) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_GETDRIVERFROMCOMMANDLINE,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               ERROR_SUCCESS,
               TRACE_WSTR(lpDriverName),
               NULL));
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_GETDRIVERFROMCOMMANDLINE,
               0,
               GetLastError(),
               NULL));
    }
    return bReturn;
}

LONG
FixNames(
    HANDLE   hKeyLang,
    LPWSTR * lpOldNameTable,
    LPWSTR   lpszLangId,      // unicode value of Language subkey
    DWORD    dwLastItem,
    DWORD    dwFirstNameToRemove,
    DWORD    dwLastNameToRemove,
    LPDWORD  pdwLastCounter,
    LPDWORD  pdwLastHelp,
    BOOL     bQuietMode
   )
{
    LONG    lStatus;
    LPWSTR  lpNameBuffer         = NULL;
    LPWSTR  lpHelpBuffer         = NULL;
    DWORD   dwTextIndex, dwSize, dwValueType;
    LPWSTR  lpNextHelpText;
    DWORD   dwHelpText;
    LPWSTR  lpNextNameText;
    DWORD   dwNameText;
    LPWSTR  AddCounterNameBuffer = NULL;
    LPWSTR  AddHelpNameBuffer    = NULL;
    DWORD   dwLastCounter        = * pdwLastCounter;
    DWORD   dwLastHelp           = * pdwLastHelp;
    HRESULT hr;

    // allocate space for the array of new text it will point
    // into the text buffer returned in the lpOldNameTable buffer)
    lpNameBuffer         = MemoryAllocate(MemorySize(lpOldNameTable) * sizeof(WCHAR));
    lpHelpBuffer         = MemoryAllocate(MemorySize(lpOldNameTable) * sizeof(WCHAR));
    AddCounterNameBuffer = MemoryAllocate(MAX_PATH * sizeof(WCHAR));
    AddHelpNameBuffer    = MemoryAllocate(MAX_PATH * sizeof(WCHAR));
    if (lpNameBuffer == NULL || lpHelpBuffer == NULL || AddCounterNameBuffer == NULL || AddHelpNameBuffer == NULL) {
        lStatus = ERROR_OUTOFMEMORY;
        goto UCN_FinishLang;
    }

    // remove this driver's counters from array

    for (dwTextIndex = dwFirstNameToRemove; dwTextIndex <= dwLastNameToRemove; dwTextIndex++) {
        if (dwTextIndex > dwLastItem) break;
        lpOldNameTable[dwTextIndex] = NULL;
    }

    lpNextHelpText = lpHelpBuffer;
    lpNextNameText = lpNameBuffer;
    dwHelpText     = MemorySize(lpHelpBuffer);
    dwNameText     = MemorySize(lpNameBuffer);

    // build new Multi_SZ strings from New Table

    for (dwTextIndex = 0; dwTextIndex <= dwLastItem; dwTextIndex ++) {
        if (lpOldNameTable[dwTextIndex] != NULL) {
            // if there's a text string at that index, then ...
            if ((dwTextIndex & 0x1) && dwTextIndex != 1) {    // ODD number == Help Text
                hr = StringCchPrintfW(lpNextHelpText, dwHelpText, L"%d", dwTextIndex);
                dwSize          = lstrlenW(lpNextHelpText) + 1;
                dwHelpText     -= dwSize;
                lpNextHelpText += dwSize;
                hr = StringCchCopyW(lpNextHelpText, dwHelpText, lpOldNameTable[dwTextIndex]);
                dwSize          = lstrlenW(lpNextHelpText) + 1;
                dwHelpText     -= dwSize;
                lpNextHelpText += dwSize;
                if (dwTextIndex > dwLastHelp) {
                    dwLastHelp = dwTextIndex;
                }
            }
            else { // EVEN number == counter name text
                hr = StringCchPrintfW(lpNextNameText, dwNameText, L"%d", dwTextIndex);
                dwSize          = lstrlenW(lpNextNameText) + 1;
                dwNameText     -= dwSize;
                lpNextNameText += dwSize;
                hr = StringCchCopyW(lpNextNameText, dwNameText, lpOldNameTable[dwTextIndex]);
                dwSize          = lstrlenW(lpNextNameText) + 1;
                dwNameText     -= dwSize;
                lpNextNameText += dwSize;
                if (dwTextIndex > dwLastCounter) {
                    dwLastCounter = dwTextIndex;
                }
            }
        }
    } // for dwTextIndex

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_FIXNAMES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ERROR_SUCCESS,
            TRACE_WSTR(lpszLangId),
            TRACE_DWORD(dwLastItem),
            TRACE_DWORD(dwLastCounter),
            TRACE_DWORD(dwLastHelp),
            TRACE_DWORD(dwFirstNameToRemove),
            TRACE_DWORD(dwLastNameToRemove),
            NULL));

    if (dwLastCounter < PERFLIB_BASE_INDEX - 1 || dwLastHelp < PERFLIB_BASE_INDEX) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                4, PERFLIB_BASE_INDEX, dwLastCounter, dwLastHelp, __LINE__,
                1, (LPWSTR) Performance, NULL, NULL);
        lStatus = ERROR_BADKEY;
        goto UCN_FinishLang;
    }

    // add MULTI_SZ terminating NULL
    * lpNextNameText ++ = L'\0';
    * lpNextHelpText ++ = L'\0';

    // update counter name text buffer

    dwSize = (DWORD) ((LPBYTE) lpNextNameText - (LPBYTE) lpNameBuffer);
    hr = StringCchPrintfW(AddCounterNameBuffer, MAX_PATH, L"%ws%ws", AddCounterNameStr, lpszLangId);
    __try {
        lStatus = RegQueryValueExW(hKeyLang,
                                   AddCounterNameBuffer,
                                   RESERVED,
                                   & dwValueType,
                                   (LPBYTE) lpNameBuffer,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
       ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_COUNTER_STRINGS, // event,
                3, lStatus, dwSize, __LINE__, 0,
                1, lpszLangId, NULL, NULL);
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLELOADLANG), Counters, lpszLangId, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_FIXNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Counters),
                TRACE_DWORD(dwSize),
                NULL));
        goto UCN_FinishLang;
    }

    dwSize = (DWORD) ((LPBYTE) lpNextHelpText - (LPBYTE) lpHelpBuffer);
    hr = StringCchPrintfW(AddHelpNameBuffer, MAX_PATH, L"%ws%ws", AddHelpNameStr, lpszLangId);
    __try {
        lStatus = RegQueryValueExW(hKeyLang,
                                   AddHelpNameBuffer,
                                   RESERVED,
                                   & dwValueType,
                                   (LPBYTE) lpHelpBuffer,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_HELP_STRINGS, // event,
                3, lStatus, dwSize, __LINE__, 0,
                1, lpszLangId, NULL, NULL);
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLELOADLANG), Help, lpszLangId, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_FIXNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Help),
                TRACE_DWORD(dwSize),
                NULL));
        goto UCN_FinishLang;
    }

UCN_FinishLang:
    * pdwLastCounter = dwLastCounter;
    * pdwLastHelp    = dwLastHelp;
    MemoryFree(lpNameBuffer);
    MemoryFree(lpHelpBuffer);
    MemoryFree(AddCounterNameBuffer);
    MemoryFree(AddHelpNameBuffer);
    MemoryFree(lpOldNameTable);
    return lStatus;
}

LONG
UnloadCounterNames(
    HKEY    hKeyMachine,
    HKEY    hDriverPerf,
    HKEY    hKeyDriver,
    LPWSTR  lpDriverName,
    BOOL    bQuietMode
)
/*++
UnloadCounterNames
    removes the names and explain text for the driver referenced by
    hDriverPerf and updates the first and last counter values accordingly

    update process:
        - set "updating" flag under Perflib to name of driver being modified
        - FOR each language under perflib key
            -- load current counter names and explain text into array of
                pointers
            -- look at all drivers and copy their names and text into a new
                buffer adjusting for the removed counter's entries keeping
                track of the lowest entry copied.  (the names for the driver
                to be removed will not be copied, of course)
            -- update each driver's "first" and "last" index values
            -- copy all other entries from 0 to the lowest copied (i.e. the
                system counters)
            -- build a new MULIT_SZ string of help text and counter names
            -- load new strings into registry
        - update perflibl "last" counters
        - delete updating flag

     ******************************************************
     *                                                    *
     *  NOTE: FUNDAMENTAL ASSUMPTION.....                 *
     *                                                    *
     *  this routine assumes that:                        *
     *                                                    *
     *      ALL COUNTER NAMES are even numbered and       *
     *      ALL HELP TEXT STRINGS are odd numbered        *
     *                                                    *
     ******************************************************

Arguments
    hKeyMachine
        handle to HKEY_LOCAL_MACHINE node of registry on system to
        remove counters from
    hDrivefPerf
        handle to registry key of driver to be de-installed
    lpDriverName
        name of driver being de-installed

Return Value
    DOS Error code.
        ERROR_SUCCESS if all went OK
        error value if not.
--*/
{
    HKEY      hPerflib  = NULL;
    HKEY      hPerfData = NULL;
    LONG      lStatus   = ERROR_SUCCESS;
    DWORD     dwLangIndex;
    DWORD     dwSize;
    DWORD     dwType;
    DWORD     dwCounterItems;
    DWORD     dwHelpItems;
    DWORD     dwLastItem;
    DWORD     dwLastCounter;
    DWORD     dwLastHelp;
    DWORD     dwRemLastDriverCounter;
    DWORD     dwRemFirstDriverCounter;
    DWORD     dwRemLastDriverHelp;
    DWORD     dwRemFirstDriverHelp;
    DWORD     dwFirstNameToRemove;
    DWORD     dwLastNameToRemove;
    DWORD     dwLastNameInTable;
    LPWSTR  * lpOldNameTable;
    BOOL      bPerflibUpdated = FALSE;
    DWORD     dwBufferSize;       // size of total buffer in bytes
    LPWSTR    szServiceDisplayName = NULL;
    LONG_PTR  TempFileHandle = -1;
    HRESULT   hr;

    if (LoadPerfGrabMutex() == FALSE) {
        return (GetLastError());
    }

    szServiceDisplayName = MemoryAllocate(SMALL_BUFFER_SIZE * sizeof(WCHAR));
    if (szServiceDisplayName == NULL) {
        lStatus = ERROR_OUTOFMEMORY;
        goto UCN_ExitPoint;
    }
    if (hKeyDriver != NULL) {
        dwBufferSize = SMALL_BUFFER_SIZE * sizeof(WCHAR);
        lStatus      = RegQueryValueExW(hKeyDriver,
                                        szDisplayName,
                                        RESERVED,
                                        & dwType,
                                        (LPBYTE) szServiceDisplayName,
                                        & dwBufferSize);
        if (lStatus != ERROR_SUCCESS) {
            hr = StringCchCopyW(szServiceDisplayName, SMALL_BUFFER_SIZE, lpDriverName);
        }
    }
    else {
        hr = StringCchCopyW(szServiceDisplayName, SMALL_BUFFER_SIZE, lpDriverName);
    }

    // open registry handle to perflib key
    __try {
        lStatus = RegOpenKeyExW(hKeyMachine, NamesKey, RESERVED, KEY_READ | KEY_WRITE, & hPerflib);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLEOPENKEY), NamesKey, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(NamesKey),
                NULL));
        goto UCN_ExitPoint;
    }

    dwBufferSize = lstrlenW(lpDriverName) * sizeof(WCHAR);
    __try {
        lStatus = RegSetValueExW( hPerflib, Busy, RESERVED, REG_SZ, (LPBYTE) lpDriverName, dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLESETVALUE), Busy, NamesKey, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Busy),
                NULL));
        goto UCN_ExitPoint;
    }

    // query registry to get number of Explain text items

    dwBufferSize = sizeof(dwHelpItems);
    __try {
        lStatus = RegQueryValueExW(hPerflib,
                                   LastHelp,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwHelpItems,
                                   & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(LastHelp),
                NULL));
        goto UCN_ExitPoint;
    }

    // query registry to get number of counter and object name items

    dwBufferSize = sizeof(dwCounterItems);
    __try {
        lStatus = RegQueryValueExW(hPerflib,
                                   LastCounter,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwCounterItems,
                                   & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(LastCounter),
                NULL));
        goto UCN_ExitPoint;
    }

    dwLastNameInTable = dwHelpItems;
    if (dwLastNameInTable < dwCounterItems) dwLastNameInTable = dwCounterItems;

    // set the hPerfData to HKEY_PERFORMANCE_DATA for new version
    hPerfData = HKEY_PERFORMANCE_DATA;

    // Get the values that are in use by the driver to be removed

    dwSize = sizeof(dwRemLastDriverCounter);
    __try {
        lStatus = RegQueryValueExW(hDriverPerf,
                                   LastCounter,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwRemLastDriverCounter,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLEREADVALUE), lpDriverName, LastCounter, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastCounter),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof(dwRemFirstDriverCounter);
    __try {
        lStatus = RegQueryValueExW(hDriverPerf,
                                   FirstCounter,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwRemFirstDriverCounter,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) FirstCounter, NULL, NULL);
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLEREADVALUE), lpDriverName, FirstCounter, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(FirstCounter),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof(dwRemLastDriverHelp);
    __try {
        lStatus = RegQueryValueExW(hDriverPerf,
                                   LastHelp,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwRemLastDriverHelp,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLEREADVALUE), lpDriverName, LastHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastHelp),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof(dwRemFirstDriverHelp);
    __try {
        lStatus = RegQueryValueExW(hDriverPerf,
                                   FirstHelp,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwRemFirstDriverHelp,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) FirstHelp, NULL, NULL);
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLEREADVALUE), lpDriverName, FirstHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(FirstHelp),
                NULL));
        goto UCN_ExitPoint;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UNLOADCOUNTERNAMES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwLastNameInTable),
            TRACE_DWORD(dwCounterItems),
            TRACE_DWORD(dwHelpItems),
            TRACE_DWORD(dwRemFirstDriverCounter),
            TRACE_DWORD(dwRemLastDriverCounter),
            TRACE_DWORD(dwRemFirstDriverHelp),
            TRACE_DWORD(dwRemLastDriverHelp),
            NULL));

    //  get the first and last counters to define block of names used
    //  by this device

    dwFirstNameToRemove = (dwRemFirstDriverCounter <= dwRemFirstDriverHelp ?
                          dwRemFirstDriverCounter : dwRemFirstDriverHelp);

    dwLastNameToRemove = (dwRemLastDriverCounter >= dwRemLastDriverHelp ?
                          dwRemLastDriverCounter : dwRemLastDriverHelp);
    dwLastCounter = dwLastHelp = 0;

    if (lStatus != ERROR_SUCCESS) {
        if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_UNABLEREADVALUE), lpDriverName, FirstHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                NULL));
        goto UCN_ExitPoint;
    }
    {
        LPWSTR mszLangList = NULL;
        LPWSTR LangId;
        BOOL   bStatus     = GetInstalledLanguageList(hPerflib, & mszLangList);

        if (! bStatus) {
            lStatus = GetLastError();
        }
        else {
            for (LangId = mszLangList; * LangId != L'\0'; LangId += (lstrlenW(LangId) + 1)) {
                if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_DOINGLANG), LangId);
                lpOldNameTable = UnlodctrBuildNameTable(hPerflib,
                                                        hPerfData,
                                                        LangId,
                                                        dwCounterItems,
                                                        dwHelpItems,
                                                        & dwLastItem);
                if (lpOldNameTable != NULL) {
                    if (dwLastItem <= dwLastNameInTable) {
                        // registry is OK so continue
                        if ((lStatus = FixNames(hPerfData,
                                                lpOldNameTable,
                                                LangId,
                                                dwLastItem,
                                                dwFirstNameToRemove,
                                                dwLastNameToRemove,
                                                & dwLastCounter,
                                                & dwLastHelp,
                                                bQuietMode)) == ERROR_SUCCESS) {
                            bPerflibUpdated = TRUE;
                        }
                    }
                    else {
                        lStatus = ERROR_BADDB;
                        break;
                    }
                }
                else { // unable to unload names for this language
                    lStatus = GetLastError();
                    if (lStatus == ERROR_FILE_NOT_FOUND) {
                        // somehow there is language subkey without "Counters" and "Help" values,
                        // usually this happens in MUI or LOC systems.
                        lStatus = ERROR_SUCCESS;
                    }
                }
            }
        }
        MemoryFree(mszLangList);
    } // end of NEW_VERSION

    if (bPerflibUpdated && lStatus == ERROR_SUCCESS) {
        // update perflib's "last" values

        dwSize = sizeof(dwLastCounter);
        __try {
            lStatus = RegSetValueExW(hPerflib,
                                     LastCounter,
                                     RESERVED,
                                     REG_DWORD,
                                     (LPBYTE) & dwLastCounter,
                                     dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }

        if (lStatus == ERROR_SUCCESS) {
            dwSize = sizeof(dwLastHelp);
            __try {
                lStatus = RegSetValueExW(hPerflib,
                                         LastHelp,
                                         RESERVED,
                                         REG_DWORD,
                                         (LPBYTE) & dwLastHelp,
                                         dwSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                        3, lStatus, dwLastHelp, __LINE__, 0,
                        2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UNLOADCOUNTERNAMES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        lStatus,
                        TRACE_WSTR(LastHelp),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
            }
        }
        else {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                    3, lStatus, dwLastCounter, __LINE__, 0,
                    2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLOADCOUNTERNAMES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(LastCounter),
                    TRACE_DWORD(dwLastCounter),
                    NULL));
        }

        if (lStatus == ERROR_SUCCESS) {
            ReportLoadPerfEvent(
                    EVENTLOG_INFORMATION_TYPE, // error type
                    (DWORD) LDPRFMSG_UNLOAD_SUCCESS, // event,
                    3, dwLastCounter, dwLastHelp, __LINE__, 0,
                    2, (LPWSTR) lpDriverName, (LPWSTR) szServiceDisplayName, NULL);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLOADCOUNTERNAMES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_DWORD(dwLastCounter),
                    TRACE_DWORD(dwLastHelp),
                    NULL));
            RegDeleteValueW(hDriverPerf, FirstCounter);
            RegDeleteValueW(hDriverPerf, LastCounter);
            RegDeleteValueW(hDriverPerf, FirstHelp);
            RegDeleteValueW(hDriverPerf, LastHelp);
            RegDeleteValueW(hDriverPerf, szObjectList);
            RegDeleteValueW(hDriverPerf, szLibraryValidationCode);
        }
    }

UCN_ExitPoint:
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNLOAD_FAILURE, // event,
                2, lStatus, __LINE__, 0, 0,
                2, (LPWSTR) lpDriverName, (LPWSTR) szServiceDisplayName, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                NULL));
    }
    MemoryFree(szServiceDisplayName);
    if (hPerflib != NULL) {
        RegDeleteValueW(hPerflib, Busy);
        RegCloseKey(hPerflib);
    }
    ReleaseMutex(hLoadPerfMutex);
    return lStatus;

}

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW(
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietMode
)
/*++
UnloadPerfCounterTextStringsW
    entry point to Counter Name Unloader

Arguments
    command line string in the format:
    "/?"                displays the usage help
    "driver"            driver containing the performance counters
    "\\machine driver"  removes the counters from the driver on \\machine

ReturnValue
    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.
--*/
{
    LPWSTR  lpDriverName = NULL;          // name of driver to delete from perflib
    DWORD   dwDriverName = 0;
    HKEY    hDriverPerf  = NULL;          // handle to performance sub-key of driver
    HKEY    hMachineKey  = NULL;          // handle to remote machine HKEY_LOCAL_MACHINE
    HKEY    hKeyDriver   = NULL;
    DWORD   dwStatus     = ERROR_SUCCESS; // return status of fn. calls

    WinPerfStartTrace(NULL);

    if (lpCommandLine == NULL) {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            dwDriverName = lstrlenW(lpCommandLine) + 1;
            if (dwDriverName == 1) dwStatus = ERROR_INVALID_PARAMETER;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    }
    if (dwStatus != ERROR_SUCCESS) goto Exit0;

    lpDriverName = (LPWSTR) MemoryAllocate(dwDriverName * sizeof(WCHAR));
    if (lpDriverName != NULL) {
        if (! GetDriverFromCommandLine(lpCommandLine,
                                       & hMachineKey,
                                       lpDriverName,
                                       & hDriverPerf,
                                       & hKeyDriver,
                                       bQuietMode)) {
            // error message was printed in routine if there was an error
            dwStatus = GetLastError();
            goto Exit0;
        }
    }
    else {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Exit0;
    }

    if (! bQuietMode) OUTPUT_MESSAGE(GetFormatResource(UC_REMOVINGDRIVER), lpDriverName);

    // removes names and explain text for driver in lpDriverName
    // displays error messages for errors encountered

    dwStatus = (DWORD) UnloadCounterNames(hMachineKey, hDriverPerf, hKeyDriver, lpDriverName, bQuietMode);

    if (dwStatus == ERROR_SUCCESS) {
        LoadPerfSignalWmiWithNewData (WMI_UNLODCTR_EVENT);
    }

Exit0:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UNLOADPERFCOUNTERTEXTSTRINGS,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            dwStatus,
            TRACE_WSTR(lpDriverName),
            NULL));
    MemoryFree(lpDriverName);
    if (hDriverPerf  != NULL) RegCloseKey(hDriverPerf);
    if (hMachineKey != HKEY_LOCAL_MACHINE && hMachineKey != NULL) {
        RegCloseKey (hMachineKey);
    }
    return dwStatus;
}

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA(
    IN  LPSTR  lpAnsiCommandLine,
    IN  BOOL   bQuietMode
)
{
    LPWSTR lpWideCommandLine = NULL;
    DWORD  lReturn           = ERROR_SUCCESS;

    if (lpAnsiCommandLine == NULL) {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            DWORD dwDriverName = lstrlenA(lpAnsiCommandLine);
            if (dwDriverName == 0) lReturn = ERROR_INVALID_PARAMETER;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lReturn = ERROR_INVALID_PARAMETER;
        }
    }
    if (lReturn == ERROR_SUCCESS) { // to catch bogus parameters
        lpWideCommandLine = LoadPerfMultiByteToWideChar(CP_ACP, lpAnsiCommandLine);
        if (lpWideCommandLine != NULL) {
            lReturn = UnloadPerfCounterTextStringsW(lpWideCommandLine, bQuietMode);
            MemoryFree(lpWideCommandLine);
        }
        else {
            lReturn = ERROR_OUTOFMEMORY;
        }
    }
    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\common\makefile.inc ===
!IFNDEF BUILDMSG
BUILDMSG=
!ENDIF

!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

.\ldprfmsg.h .\msg00001.bin .\ldprfmsg.rc : .\ldprfmsg.mc
	mc -v  ldprfmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\initodat\common.c ===
/*++
Copyright (c) 1993-1994 Microsoft Corporation

Module Name:
    common.c

Abstract:
    Utility routines used by IniToDat.exe

Author:
    HonWah Chan (a-honwah) October, 1993 

Revision History:
--*/
//
//  Windows Include files
//
#include <windows.h>
#include <strsafe.h>
#include <winperf.h>
//
//  local include files
//
#include "common.h"
#include "strids.h"

//  Global Buffers
//
WCHAR DisplayStringBuffer[DISP_BUFF_SIZE];
CHAR  TextFormat[DISP_BUFF_SIZE];

LPWSTR
GetStringResource(
    UINT wStringId
)
/*++
    Retrived UNICODE strings from the resource file for display 
--*/
{
    LPWSTR szReturn = (LPWSTR) L" ";
    HANDLE hMod     = (HINSTANCE) GetModuleHandle(NULL); // get instance ID of this module;

    if (hMod) {
        ZeroMemory(DisplayStringBuffer, sizeof(DisplayStringBuffer));
        if ((LoadStringW(hMod, wStringId, DisplayStringBuffer, RTL_NUMBER_OF(DisplayStringBuffer))) > 0) {
            szReturn = DisplayStringBuffer;
        }
    }
    return szReturn;
}

LPSTR
GetFormatResource(
    UINT wStringId
)
/*++
    Returns an ANSI string for use as a format string in a printf fn.
--*/
{
    LPSTR szReturn = (LPSTR) " ";
    HANDLE hMod    = (HINSTANCE) GetModuleHandle(NULL); // get instance ID of this module;
    
    if (hMod) {
        ZeroMemory(TextFormat, sizeof(TextFormat));
        if ((LoadStringA(hMod, wStringId, TextFormat, RTL_NUMBER_OF(TextFormat))) > 0) {
            szReturn = TextFormat;
        }
    }
    return szReturn;
}

VOID
DisplayCommandHelp(
    UINT iFirstLine,
    UINT iLastLine
)
/*++
DisplayCommandHelp
    displays usage of command line arguments

Arguments
    NONE

Return Value
    NONE
--*/
{
    UINT iThisLine;

    for (iThisLine = iFirstLine; iThisLine <= iLastLine; iThisLine++) {
        printf("\n%ws", GetStringResource(iThisLine));
    }
} // DisplayCommandHelp

VOID
DisplaySummary(
    LPWSTR lpLastID,
    LPWSTR lpLastText,
    UINT   NumOfID
)
{
   printf("%ws",   GetStringResource(LC_SUMMARY));
   printf("%ws",   GetStringResource(LC_NUM_OF_ID));
   printf("%ld\n", NumOfID);
   printf("%ws",   GetStringResource(LC_LAST_ID));
   printf("%ws\n", lpLastID ? lpLastID : L"");
   printf("%ws",   GetStringResource(LC_LAST_TEXT));
   printf("%ws\n", lpLastText ? lpLastText : L"");
}

VOID
DisplaySummaryError(
    LPWSTR lpLastID,
    LPWSTR lpLastText,
    UINT   NumOfID
)
{
   printf("%ws",   GetStringResource(LC_BAD_ID));
   printf("%ws\n", lpLastID ? lpLastID : L"");
   printf("%ws\n", GetStringResource(LC_MISSING_DEL));
   DisplaySummary(lpLastID, lpLastText, NumOfID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\common\lodctr.h ===
/*++

lodctr.h

    Include file for lodctr 
    
--*/
#ifndef _LODCTR_H
#define _LODCTR_H

#define TYPE_HELP   1
#define TYPE_NAME   2

#define LC_CMD_HELP_1           201
#define LC_CMD_HELP_2           202
#define LC_CMD_HELP_3           203
#define LC_CMD_HELP_4           204
#define LC_CMD_HELP_5           205
#define LC_CMD_HELP_6           206
#define LC_CMD_HELP_7           207
#define LC_CMD_HELP_8           208
#define LC_CMD_HELP_9           209 
#define LC_CMD_HELP_10          210
#define LC_CMD_HELP_11          211
#define LC_CMD_HELP_12          212
#define LC_CMD_HELP_13          213
#define LC_CMD_HELP_14          214
#define LC_CMD_HELP_15          215
#define LC_CMD_HELP_16          216
#define LC_FIRST_CMD_HELP       LC_CMD_HELP_1
#define LC_LAST_CMD_HELP        LC_CMD_HELP_16

#define LC_DEVNAME_ERR_1        107
#define LC_DEVNAME_ERR_2        108
#define LC_NO_INIFILE           109
#define LC_LANGLIST_ERR         110
#define LC_ERR_OPEN_INCLUDE     111
#define LC_ERR_OPEN_DRIVERPERF1 113
#define LC_ERR_OPEN_DRIVERPERF2 114
#define LC_ERR_OPEN_PERFLIB     115
#define LC_ERR_READLASTPERFLIB  116
#define LC_ERR_ALREADY_IN       117
#define LC_ERR_UNABLESETBUSY    118
#define LC_ERRO_READBASEINDEX   119
#define LC_BAD_KEY              120
#define LC_LANGNOTFOUND         121
#define LC_ERR_ADDENTRY         122
#define LC_ERRADDTOLANG         123
#define LC_UNABLESORTTABLES     124
#define LC_UNABLEOPENLANG       125
#define LC_UNABLESETVALUE       126
#define LC_ERR_UPDATELANG       127
#define LC_PERFLIBISBUSY        128
#define LC_CONNECT_PROBLEM      129

#endif  // _LODCTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\common\unlodctr.h ===
/*++

unlodctr.h

    Definitions that are specific to the counter unloader
   
Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#ifndef _UNLODCTR_H_
#define _UNLODCTR_H_

// resource file constants
#define UC_CMD_HELP_1       401
#define UC_CMD_HELP_2       402
#define UC_CMD_HELP_3       403
#define UC_CMD_HELP_4       404
#define UC_CMD_HELP_5       405
#define UC_CMD_HELP_6       406
#define UC_CMD_HELP_7       407
#define UC_CMD_HELP_8       408
#define UC_CMD_HELP_9       409
#define UC_CMD_HELP_10      410
#define UC_CMD_HELP_11      411
#define UC_CMD_HELP_12      412
#define UC_FIRST_CMD_HELP   UC_CMD_HELP_1
#define UC_LAST_CMD_HELP    UC_CMD_HELP_12
                           
#define UC_DRIVERNOTFOUND   311
#define UC_NOTINSTALLED     312
#define UC_REMOVINGDRIVER   313
#define UC_UNABLEOPENKEY    314
#define UC_UNABLESETVALUE   315
#define UC_UNABLEREADVALUE  316
#define UC_DOINGLANG        318
#define UC_UNABLELOADLANG   320 
#define UC_CONNECT_PROBLEM  322
#define UC_BAD_DRIVER_NAME  323

#endif // _UNLODCTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\common\lodctr.c ===
/*++
Copyright (c) 1991-1999  Microsoft Corporation

Module Name:
    lodctr.c

Abstract:
    Program to read the contents of the file specified in the command line
    and update the registry accordingly

Author:
    Bob Watson (a-robw) 10 Feb 93

Revision History:
    a-robw  25-Feb-93   revised calls to make it compile as a UNICODE or
            an ANSI app.
    Bob Watson (bobw)   10 Mar 99 added event log messages
--*/
//
//  Windows Include files
//
#include <windows.h>
#include "strsafe.h"
#include "stdlib.h"
#define __LOADPERF__
#include <loadperf.h>
#include <winperf.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  application include files
//
#include "winperfp.h"
#include "common.h"
#include "lodctr.h"
#include "ldprfmsg.h"

typedef struct _DllValidationData {
    FILETIME    CreationDate;
    LONGLONG    FileSize;
} DllValidationData, * pDllValidationData;

#define  OLD_VERSION            0x010000
#define  MAX_GUID_TABLE_SIZE          16
#define  tohexdigit(x) ((CHAR) (((x) < 10) ? ((x) + L'0') : ((x) + L'a' - 10)))

// string constants
LPCWSTR szDataFileRoot = L"%systemroot%\\system32\\Perf";
LPCSTR  szMofFileName  = "MofFile";
LPCWSTR szName         = L"_NAME";
LPCWSTR szHelp         = L"_HELP";
LPCWSTR sz_DFormat     = L" %d";
LPCWSTR szDFormat      = L"%d";
LPCSTR  szText         = "text";
LPCWSTR wszText        = L"text";
LPCSTR  szObjects      = "objects";
LPCWSTR MapFileName    = L"Perflib Busy";
LPCWSTR szPerflib      = L"Perflib";
LPCWSTR cszLibrary     = L"Library";
LPCSTR  caszOpen       = "Open";
LPCSTR  caszCollect    = "Collect";
LPCSTR  caszClose      = "Close";
LPCSTR  szTrusted      = "Trusted";

int __cdecl
My_vfwprintf(
    FILE          * str,
    const wchar_t * format,
    va_list         argptr
);

__inline
void __cdecl
OUTPUT_MESSAGE(
    BOOL          bQuietMode,
    const WCHAR * format,
    ...
)
{
    va_list args;
    va_start(args, format);

    if (! bQuietMode) {
        My_vfwprintf(stdout, format, args);
    }
    va_end(args);
}

LPWSTR
* BuildNameTable(
    HKEY    hKeyRegistry,   // handle to registry db with counter names
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
)
/*++
BuildNameTable
Arguments:
    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.
    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:
    pointer to an allocated table. (the caller must MemoryFree it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.
--*/
{

    LPWSTR * lpReturnValue   = NULL;
    LPWSTR * lpCounterId;
    LPWSTR   lpCounterNames;
    LPWSTR   lpHelpText;
    LPWSTR   lpThisName;
    LONG     lWin32Status;
    DWORD    dwLastError;
    DWORD    dwValueType;
    DWORD    dwArraySize;
    DWORD    dwBufferSize;
    DWORD    dwCounterSize;
    DWORD    dwHelpSize;
    DWORD    dwThisCounter;
    DWORD    dwLastId;
    DWORD    dwLastHelpId;
    DWORD    dwLastCounterId;
    DWORD    dwLastCounterIdUsed;
    DWORD    dwLastHelpIdUsed;
    HKEY     hKeyValue         = NULL;
    HKEY     hKeyNames         = NULL;
    LPWSTR   CounterNameBuffer = NULL;
    LPWSTR   HelpNameBuffer    = NULL;
    HRESULT  hr;

    // check for null arguments and insert defaults if necessary

    if (lpszLangId == NULL) {
        lpszLangId = (LPWSTR) DefaultLangId;
    }

    // open registry to get number of items for computing array size

    __try {
        lWin32Status = RegOpenKeyExW(hKeyRegistry, NamesKey, RESERVED, KEY_READ, & hKeyValue);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(NamesKey),
                NULL));
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof(dwLastHelpId);
    __try {
        lWin32Status = RegQueryValueExW(hKeyValue,
                                        LastHelp,
                                        RESERVED,
                                        & dwValueType,
                                        (LPBYTE) & dwLastHelpId,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(LastHelp),
                NULL));
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof(dwLastId);
    __try {
        lWin32Status = RegQueryValueExW(hKeyValue,
                                        LastCounter,
                                        RESERVED,
                                        & dwValueType,
                                        (LPBYTE) & dwLastCounterId,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(LastCounter),
                NULL));
        goto BNT_BAILOUT;
    }

    dwLastId = (dwLastCounterId < dwLastHelpId) ? (dwLastHelpId) : (dwLastCounterId);

    // compute size of pointer array
    dwArraySize = (dwLastId + 1) * sizeof(LPWSTR);

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LODCTR_BUILDNAMETABLE,
            0,
            lWin32Status,
            TRACE_DWORD(dwLastCounterId),
            TRACE_DWORD(dwLastHelpId),
            NULL));

    hKeyNames = HKEY_PERFORMANCE_DATA;

    dwBufferSize = lstrlenW(CounterNameStr) + lstrlenW(HelpNameStr) + lstrlenW(lpszLangId) + 1;
    if (dwBufferSize < MAX_PATH) dwBufferSize = MAX_PATH;
    CounterNameBuffer = MemoryAllocate(2 * dwBufferSize * sizeof(WCHAR));
    if (CounterNameBuffer == NULL) {
        lWin32Status = ERROR_OUTOFMEMORY;
        SetLastError(lWin32Status);
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                1, __LINE__, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                0,
                ERROR_OUTOFMEMORY,
                NULL));
        goto BNT_BAILOUT;
    }
    HelpNameBuffer = CounterNameBuffer + dwBufferSize;
    hr = StringCchPrintfW(CounterNameBuffer, dwBufferSize, L"%ws%ws", CounterNameStr, lpszLangId);
    hr = StringCchPrintfW(HelpNameBuffer,    dwBufferSize, L"%ws%ws", HelpNameStr,    lpszLangId);

    // get size of counter names and add that to the arrays
    dwBufferSize = 0;
    __try {
        lWin32Status = RegQueryValueExW(hKeyNames,
                                        CounterNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        NULL,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_WARNING_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Counters),
                NULL));
        goto BNT_BAILOUT;
    }
    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays
    dwBufferSize = 0;
    __try {
        lWin32Status = RegQueryValueExW(hKeyNames,
                                        HelpNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        NULL,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Help),
                NULL));
        goto BNT_BAILOUT;
    }
    dwHelpSize = dwBufferSize;

    lpReturnValue = MemoryAllocate(dwArraySize + dwCounterSize + dwHelpSize);
    if (lpReturnValue == NULL) {
        lWin32Status = ERROR_OUTOFMEMORY;
        SetLastError(lWin32Status);
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                1, __LINE__, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                0,
                ERROR_OUTOFMEMORY,
                NULL));
        goto BNT_BAILOUT;
    }
    // initialize pointers into buffer

    lpCounterId    = lpReturnValue;
    lpCounterNames = (LPWSTR) ((LPBYTE) lpCounterId + dwArraySize);
    lpHelpText     = (LPWSTR) ((LPBYTE) lpCounterNames + dwCounterSize);

    // read counters into memory
    dwBufferSize = dwCounterSize;
    __try {
        lWin32Status = RegQueryValueExW(hKeyNames,
                                        CounterNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        (LPVOID) lpCounterNames,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_WARNING_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Counters),
                NULL));
        goto BNT_BAILOUT;
    }

    dwBufferSize = dwHelpSize;
    __try {
        lWin32Status = RegQueryValueExW(hKeyNames,
                                        HelpNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        (LPVOID) lpHelpText,
                                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Help),
                NULL));
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed    = 0;

    // load counter array items
    for (lpThisName = lpCounterNames; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1) ) {

        // first string should be an integer (in decimal unicode digits)
        dwThisCounter = wcstoul(lpThisName, NULL, 10);

        if (dwThisCounter == 0 || dwThisCounter > dwLastId) {
            lWin32Status = ERROR_INVALID_DATA;
            SetLastError(lWin32Status);
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT, // event,
                    4, dwThisCounter, dwLastCounterId, dwLastId, __LINE__,
                    1, lpThisName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lWin32Status,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwLastId),
                    NULL));
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name
        lpThisName += (lstrlenW(lpThisName) + 1);

        // and load array element;
        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;
    }

    for (lpThisName = lpHelpText; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1) ) {

        // first string should be an integer (in decimal unicode digits)
        dwThisCounter = wcstoul(lpThisName, NULL, 10);

        if (dwThisCounter == 0 || dwThisCounter > dwLastId) {
            lWin32Status = ERROR_INVALID_DATA;
            SetLastError(lWin32Status);
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT, // event,
                    4, dwThisCounter, dwLastHelpId, dwLastId, __LINE__,
                    1, lpThisName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lWin32Status,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwLastId),
                    NULL));
            goto BNT_BAILOUT;  // bad entry
        }
        // point to corresponding counter name
        lpThisName += (lstrlenW(lpThisName) + 1);

        // and load array element;
        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LODCTR_BUILDNAMETABLE,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lWin32Status,
            TRACE_WSTR(lpszLangId),
            TRACE_DWORD(dwLastCounterIdUsed),
            TRACE_DWORD(dwLastHelpIdUsed),
            TRACE_DWORD(dwLastId),
            NULL));

    // check the registry for consistency
    // the last help string index should be the last ID used
    if (dwLastCounterIdUsed > dwLastId) {
        lWin32Status = ERROR_INVALID_DATA;
        SetLastError(lWin32Status);
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                3, dwLastId, dwLastCounterIdUsed, __LINE__, 0,
                0, NULL, NULL, NULL);
        goto BNT_BAILOUT;  // bad registry
    }
    if (dwLastHelpIdUsed > dwLastId) {
        lWin32Status = ERROR_INVALID_DATA;
        SetLastError(lWin32Status);
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                3, dwLastId, dwLastHelpIdUsed, __LINE__, 0,
                0, NULL, NULL, NULL);
        goto BNT_BAILOUT;  // bad registry
    }

    if (pdwLastItem) * pdwLastItem = dwLastId;

BNT_BAILOUT:
    if (hKeyValue) RegCloseKey (hKeyValue);
    if (hKeyNames && hKeyNames != HKEY_PERFORMANCE_DATA) RegCloseKey (hKeyNames);
    MemoryFree(CounterNameBuffer);
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
        MemoryFree(lpReturnValue);
        lpReturnValue = NULL;
    }
    return lpReturnValue;
}

BOOL
MakeBackupCopyOfLanguageFiles(
    LPCWSTR szLangId
)
{
    LPWSTR  szOldFileName = NULL;
    LPWSTR  szTmpFileName = NULL;
    LPWSTR  szNewFileName = NULL;
    BOOL    bStatus       = FALSE;
    DWORD   dwStatus;
    HANDLE  hOutFile;
    HRESULT hr;

    UNREFERENCED_PARAMETER(szLangId);

    szOldFileName = MemoryAllocate((MAX_PATH + 1) * sizeof(WCHAR));
    szTmpFileName = MemoryAllocate((MAX_PATH + 1) * sizeof(WCHAR));
    szNewFileName = MemoryAllocate((MAX_PATH + 1) * sizeof(WCHAR));

    if (szOldFileName == NULL || szTmpFileName == NULL || szNewFileName == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    ExpandEnvironmentStringsW(szDataFileRoot, szOldFileName, MAX_PATH);
    hr = StringCchPrintfW(szNewFileName, MAX_PATH + 1, L"%wsStringBackup.INI", szOldFileName);
    hr = StringCchPrintfW(szTmpFileName, MAX_PATH + 1, L"%wsStringBackup.TMP", szOldFileName);

    // see if the file already exists
    hOutFile = CreateFileW(szTmpFileName,
                           GENERIC_READ,
                           0,      // no sharing
                           NULL,   // default security
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
    if (hOutFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hOutFile);
        bStatus = DeleteFileW(szTmpFileName);
    }

    // create backup of file
    //
    dwStatus = BackupPerfRegistryToFileW(szTmpFileName, NULL);
    if (dwStatus == ERROR_SUCCESS) {
        bStatus = CopyFileW(szTmpFileName, szNewFileName, FALSE);
        if (bStatus) {
            DeleteFileW(szTmpFileName);
        }
    }
    else {
        bStatus = FALSE;
    }

Cleanup:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_MAKEBACKUPCOPYOFLANGUAGEFILES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            GetLastError(),
            TRACE_WSTR(szNewFileName),
            NULL));
    MemoryFree(szOldFileName);
    MemoryFree(szTmpFileName);
    MemoryFree(szNewFileName);
    if (! bStatus) SetLastError(dwStatus);
    return bStatus;
}

BOOL
GetFileFromCommandLine(
    LPWSTR      lpCommandLine,
    LPWSTR    * lpFileName,
    DWORD       dwFileName,
    DWORD_PTR * pdwFlags
)
/*++
GetFileFromCommandLine
    parses the command line to retrieve the ini filename that should be
    the first and only argument.

Arguments
    lpCommandLine   pointer to command line (returned by GetCommandLine)
    lpFileName      pointer to buffer that will recieve address of the
            validated filename entered on the command line
    pdwFlags        pointer to dword containing flag bits

Return Value
    TRUE if a valid filename was returned
    FALSE if the filename is not valid or missing
        error is returned in GetLastError
--*/
{
    INT     iNumArgs;
    LPWSTR  lpExeName     = NULL;
    LPWSTR  lpCmdLineName = NULL;
    LPWSTR  lpIniFileName = NULL;
    LPWSTR  lpMofFlag     = NULL;
    HANDLE  hFileHandle;
    DWORD   lStatus       = ERROR_SUCCESS;
    BOOL    bReturn       = FALSE;
    DWORD   NameBuffer;
    DWORD   dwCpuArg, dwIniArg;
    HRESULT hr;

    // check for valid arguments
    if (lpCommandLine == NULL || lpFileName == NULL || pdwFlags == NULL) {
        lStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // allocate memory for parsing operation
    NameBuffer = lstrlenW(lpCommandLine);
    if (NameBuffer < MAX_PATH) NameBuffer = MAX_PATH;
    lpExeName = MemoryAllocate(4 * NameBuffer * sizeof(WCHAR));
    if (lpExeName == NULL) {
        lStatus = (ERROR_OUTOFMEMORY);
        goto Cleanup;
    }

    lpCmdLineName = (LPWSTR) (lpExeName     + NameBuffer);
    lpIniFileName = (LPWSTR) (lpCmdLineName + NameBuffer);
    lpMofFlag     = (LPWSTR) (lpIniFileName + NameBuffer);

    // check for mof Flag
    hr = StringCchCopyW(lpMofFlag, NameBuffer, GetItemFromString(lpCommandLine, 2, cSpace));

    * pdwFlags |= LOADPERF_FLAGS_LOAD_REGISTRY_ONLY; // default unless a switch is found
    if (lpMofFlag[0] == cHyphen || lpMofFlag[0] == cSlash) {
        if (lpMofFlag[1] == cQuestion) {
           // ask for usage
           goto Cleanup;
        }
        else if (lpMofFlag[1] == cM || lpMofFlag[1] == cm) {
            // ignore MOF flag. LODCTR only used to update perfromance registry, no MOF.
            //
        }
        dwCpuArg = 3;
        dwIniArg = 4;
    }
    else {
        dwCpuArg = 2;
        dwIniArg = 3;
    }

    // Get INI File name
    hr = StringCchCopyW(lpCmdLineName, NameBuffer, GetItemFromString(lpCommandLine, dwIniArg, cSpace));
    if (lstrlenW(lpCmdLineName) == 0) {
        // then no computer name was specified so try to get the
        // ini file from the 2nd entry
        hr = StringCchCopyW(lpCmdLineName, NameBuffer, GetItemFromString(lpCommandLine, dwCpuArg, cSpace));
        if (lstrlenW(lpCmdLineName) == 0) {
            // no ini file found
            iNumArgs = 1;
        }
        else {
            // fill in a blank computer name
            iNumArgs = 2;
        }
    }
    else {
        // the computer name must be present so fetch it
        hr = StringCchCopyW(lpMofFlag, NameBuffer, GetItemFromString(lpCommandLine, dwCpuArg, cSpace));
        iNumArgs = 3;
    }

    if (iNumArgs != 2 && iNumArgs != 3) {
        // wrong number of arguments
        lStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (SearchPathW(NULL, lpCmdLineName, NULL, FILE_NAME_BUFFER_SIZE, lpIniFileName, NULL) > 0) {
        hFileHandle = CreateFileW(lpIniFileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);
        if (hFileHandle != NULL && hFileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(hFileHandle);

            // file exists, so return name and success
            hr = StringCchCopyW(* lpFileName, dwFileName, lpIniFileName);
            bReturn = TRUE;
        }
        else {
            // filename was on command line, but not valid so return
            // false, but send name back for error message
            hr = StringCchCopyW(* lpFileName, dwFileName, lpIniFileName);
            lStatus = GetLastError();
        }
    }
    else {
        hr = StringCchCopyW(* lpFileName, dwFileName, lpCmdLineName);
        lStatus = ERROR_OPEN_FAILED;
    }

Cleanup:
    MemoryFree(lpExeName);
    if (! bReturn) SetLastError(lStatus);
    return bReturn;
}

BOOL
LodctrSetSericeAsTrusted(
    LPCWSTR  lpIniFile,
    LPCWSTR  szMachineName,
    LPCWSTR  szServiceName
)
{
    DWORD  dwRetSize;
    DWORD  dwStatus;
    BOOL   bReturn    = FALSE;
    LPSTR  aszIniFile = LoadPerfWideCharToMultiByte(CP_ACP, (LPWSTR) lpIniFile);
    LPSTR  szParam    = NULL;

    if (aszIniFile != NULL) {
        DWORD  dwFileSize = LoadPerfGetFileSize((LPWSTR) lpIniFile, NULL, TRUE);

        if (dwFileSize < SMALL_BUFFER_SIZE) dwFileSize = SMALL_BUFFER_SIZE;
        szParam = MemoryAllocate(dwFileSize * sizeof(CHAR));
        if (szParam != NULL) {
            dwRetSize = GetPrivateProfileStringA(szInfo, szTrusted, szNotFound, szParam, dwFileSize, aszIniFile);
            if (lstrcmpiA(szParam, szNotFound) != 0) {
                // Trusted string found so set
                dwStatus = SetServiceAsTrustedW(NULL, szServiceName);
                if (dwStatus != ERROR_SUCCESS) {
                    SetLastError(dwStatus);
                }
                else {
                    bReturn = TRUE;
                }
            }
            else {
                // Service is not trusted to have a good Perf DLL
                SetLastError(ERROR_SUCCESS);
            }
            MemoryFree(szParam);
        }
        else {
            SetLastError(ERROR_OUTOFMEMORY);
        }
        MemoryFree(aszIniFile);
    }
    else {
        SetLastError(ERROR_OUTOFMEMORY);
    }
    return bReturn;
}

BOOL
BuildLanguageTables(
    DWORD                    dwMode,
    LPWSTR                   lpIniFile,
    LPWSTR                   lpDriverName,
    PLANGUAGE_LIST_ELEMENT * pFirstElem
)
/*++
BuildLanguageTables
    Creates a list of structures that will hold the text for
    each supported language

Arguments
    lpIniFile
        Filename with data
    pFirstElem
        pointer to first list entry

ReturnValue
    TRUE if all OK
    FALSE if not
--*/
{
    LPSTR                    lpEnumeratedLangs = NULL;
    LPSTR                    lpThisLang        = NULL;
    LPWSTR                   lpSrchPath        = NULL;
    LPSTR                    lpIniPath         = NULL;
    LPWSTR                   lpInfPath         = LoadPerfGetInfPath();
    HANDLE                   hFile             = NULL;
    WIN32_FIND_DATAW         FindFile;
    PLANGUAGE_LIST_ELEMENT   pThisElem;
    DWORD                    dwSize;
    BOOL                     bReturn           = FALSE;
    DWORD                    dwStatus          = ERROR_SUCCESS;
    BOOL                     bFind             = TRUE;
    DWORD                    dwPathSize        = 0;
    DWORD                    dwFileSize        = 0;
    LPSTR                    aszIniFile        = NULL;
    HRESULT                  hr;
    BOOL                     bLocalizedBuild   = (GetSystemDefaultUILanguage() != 0x0409) ? TRUE : FALSE;

    if (lpIniFile == NULL || pFirstElem == NULL || lpInfPath == NULL) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    dwPathSize = lstrlenW(lpInfPath) + lstrlenW(lpIniFile) + 6; // "0404\"
    if (dwPathSize < MAX_PATH) dwPathSize = MAX_PATH;
    lpSrchPath = MemoryAllocate(sizeof(WCHAR) * dwPathSize + sizeof(CHAR) * dwPathSize);
    if (lpSrchPath == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    lpIniPath = (LPSTR) (((LPWSTR) lpSrchPath) + dwPathSize);
    if (! (dwMode & LODCTR_UPNF_NOBACKUP)) {
        hr = StringCchPrintfW(lpSrchPath, dwPathSize, L"%ws0*", lpInfPath);
        hFile = FindFirstFileExW(lpSrchPath,
                                 FindExInfoStandard,
                                 & FindFile,
                                 FindExSearchLimitToDirectories,
                                 NULL,
                                 0);
        if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
            dwStatus = ERROR_RESOURCE_LANG_NOT_FOUND;
            goto Cleanup;
        }
    }

    bFind = TRUE;
    while (bFind) {
        ZeroMemory(lpIniPath, dwPathSize * sizeof(CHAR));
        if (dwMode & LODCTR_UPNF_NOBACKUP) {
            hr = StringCchPrintfA(lpIniPath, dwPathSize, "%ws", lpIniFile);
        }
        else {
            hr = StringCchPrintfA(lpIniPath, dwPathSize, "%ws%ws%ws%ws%ws%ws",
                    lpInfPath, FindFile.cFileName, Slash, lpDriverName, Slash, lpIniFile);
        }

        if (lpEnumeratedLangs == NULL) {
            dwFileSize = LoadPerfGetFileSize((LPWSTR) lpIniPath, NULL, FALSE);
            if (dwFileSize < SMALL_BUFFER_SIZE) dwFileSize = SMALL_BUFFER_SIZE;
            lpEnumeratedLangs = MemoryAllocate(dwFileSize * sizeof(CHAR));
            if (lpEnumeratedLangs == NULL) {
                dwStatus = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else {
            ZeroMemory(lpEnumeratedLangs, dwFileSize * sizeof(CHAR));
        }
        dwSize = GetPrivateProfileStringA(szLanguages,
                                          NULL,               // return all values in multi-sz string
                                          aszDefaultLangId,   // english as the default
                                          lpEnumeratedLangs,
                                          dwFileSize,
                                          lpIniPath);
        if (dwSize == 0) {
            dwStatus = ERROR_RESOURCE_LANG_NOT_FOUND;
            goto Cleanup;
        }
        for (lpThisLang = lpEnumeratedLangs;
                         lpThisLang != NULL && * lpThisLang != '\0';
                         lpThisLang += (lstrlenA(lpThisLang) + 1)) {
            LPWSTR wszAllocLang = LoadPerfMultiByteToWideChar(CP_ACP, lpThisLang);
            LPWSTR wszThisLang  = NULL;
            if (wszAllocLang == NULL) continue;

            if ((! bLocalizedBuild) && (LoadPerfGetLCIDFromString(wszAllocLang) == 0x0004)) {
                // Asshume that this is MUI build, so we should not use generic "004" LangId.
                // Instead, we should use "0804" or "0404" to separate CHT and CHS cases.
                //
                wszThisLang = FindFile.cFileName;
            }
            else {
                wszThisLang = wszAllocLang;
            }

            for (pThisElem  = * pFirstElem; pThisElem != NULL; pThisElem  = pThisElem->pNextLang) {
                if (lstrcmpiW(pThisElem->LangId, wszThisLang) == 0) {
                    break;
                }
            }

            if (pThisElem != NULL) {
                // already support this language in INI file
                //
                continue;
            }

            pThisElem = MemoryAllocate(sizeof(LANGUAGE_LIST_ELEMENT) + (lstrlenW(wszThisLang) + 1) * sizeof(WCHAR));
            if (pThisElem == NULL) {
                dwStatus = ERROR_OUTOFMEMORY;
                continue;
            }
            // The following code is to build pFirstElem list. pFirstElem list will be returned back
            // to LoadPerfInstallPerfDll() function (LangList), then uses in UpdateRegistry().
            // Allocated memory will be freed at the end of LoadPerfInstallPerfDll().
            //
            pThisElem->pNextLang      = * pFirstElem;
            * pFirstElem              = pThisElem;
            pThisElem->LangId         = (LPWSTR) (((LPBYTE) pThisElem) + sizeof(LANGUAGE_LIST_ELEMENT));
            hr = StringCchCopyW(pThisElem->LangId, lstrlenW(wszThisLang) + 1, wszThisLang);
            pThisElem->dwLangId       = LoadPerfGetLCIDFromString(pThisElem->LangId);
            pThisElem->pFirstName     = NULL;
            pThisElem->pThisName      = NULL;
            pThisElem->dwNumElements  = 0;
            pThisElem->NameBuffer     = NULL;
            pThisElem->HelpBuffer     = NULL;
            pThisElem->dwNameBuffSize = 0;
            pThisElem->dwHelpBuffSize = 0;

            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_BUILDLANGUAGETABLES,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    ERROR_SUCCESS,
                    TRACE_WSTR(lpIniFile),
                    TRACE_WSTR(pThisElem->LangId),
                    NULL));
            MemoryFree(wszAllocLang);
        }

        if (dwMode & LODCTR_UPNF_NOBACKUP) {
            bFind = FALSE;
        }
        else {
            bFind = FindNextFileW(hFile, & FindFile);
        }
    }

    if (* pFirstElem == NULL) {
        // then no languages were found
        dwStatus = ERROR_RESOURCE_LANG_NOT_FOUND;
    }
    else {
        bReturn = TRUE;
    }

Cleanup:
    if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) FindClose(hFile);
    MemoryFree(lpSrchPath);
    MemoryFree(lpEnumeratedLangs);
    if (! bReturn) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_BUILDLANGUAGETABLES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                dwStatus,
                TRACE_WSTR(lpIniFile),
                TRACE_WSTR(lpDriverName),
                NULL));
        SetLastError(dwStatus);
    }
    return bReturn;
}

BOOL
LoadIncludeFile(
    BOOL                  bQuietMode,
    DWORD                 dwMode,
    LPWSTR                lpIniFile,
    LPWSTR                lpDriverName,
    PSYMBOL_TABLE_ENTRY * pTable
)
/*++
LoadIncludeFile
    Reads the include file that contains symbolic name definitions and
    loads a table with the values defined

Arguments
    lpIniFile
        Ini file with include file name
    pTable
        address of pointer to table structure created

Return Value
    TRUE if table read or if no table defined
    FALSE if error encountere reading table
--*/
{
    INT                   iNumArgs;
    DWORD                 dwSize;
    DWORD                 dwFileSize;
    BOOL                  bReUse;
    PSYMBOL_TABLE_ENTRY   pThisSymbol        = NULL;
    LPWSTR                szInfPath          = LoadPerfGetInfPath();
    LPSTR                 lpIncludeFileName  = NULL;
    LPSTR                 lpIncludeFile      = NULL;
    LPSTR                 lpIniPath          = NULL;
    LPSTR                 lpLineBuffer       = NULL;
    LPSTR                 lpAnsiSymbol       = NULL;
    LPSTR                 aszIniFile         = NULL;
    FILE                * fIncludeFile       = NULL;
    DWORD                 dwLen;
    BOOL                  bReturn            = FALSE;
    DWORD                 dwStatus           = ERROR_SUCCESS;
    HRESULT               hr;

    if (pTable == NULL || szInfPath == NULL || lpIniFile == NULL) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    aszIniFile = LoadPerfWideCharToMultiByte(CP_ACP, lpIniFile);
    if (aszIniFile == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    dwFileSize = LoadPerfGetFileSize(lpIniFile, NULL, TRUE);
    if (dwFileSize < SMALL_BUFFER_SIZE) dwFileSize = SMALL_BUFFER_SIZE;
    lpIncludeFileName = MemoryAllocate(3 * dwFileSize * sizeof (CHAR));
    if (lpIncludeFileName == NULL) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                1, __LINE__, 0, 0, 0,
                0, NULL, NULL, NULL);
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    lpLineBuffer  = (LPSTR) (lpIncludeFileName + dwFileSize);
    lpAnsiSymbol  = (LPSTR) (lpLineBuffer      + dwFileSize);

    // get name of include file (if present)
    dwSize = GetPrivateProfileStringA(szInfo,
                                      szSymbolFile,
                                      szNotFound,
                                      lpIncludeFileName,
                                      dwFileSize,
                                      aszIniFile);
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LOADINCLUDEFILE,
            ARG_DEF(ARG_TYPE_STR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
            ERROR_SUCCESS,
            TRACE_STR(aszIniFile),
            TRACE_STR(lpIncludeFileName),
            NULL));
    if (lstrcmpiA(lpIncludeFileName, szNotFound) == 0) {
        // no symbol file defined
        * pTable = NULL;
        dwStatus = ERROR_INVALID_DATA;
        bReturn  = TRUE;
        goto Cleanup;
    }

    dwSize = lstrlenW(szInfPath) + lstrlenW(lpDriverName) + 10;
    if (dwSize < (DWORD) (lstrlenW(lpIniFile) + 1)) dwSize = lstrlenW(lpIniFile) + 1;
    if (dwSize < MAX_PATH)                          dwSize = MAX_PATH;

    lpIniPath = MemoryAllocate(2 * dwSize * sizeof(CHAR));
    if (lpIniPath == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    lpIncludeFile = (LPSTR) (lpIniPath + dwSize);

    // if here, then a symbol file was defined and is now stored in
    // lpIncludeFileName
    // get path for the ini file and search that first

    if (dwMode & LODCTR_UPNF_NOBACKUP) {
        DWORD dwPathSize = lstrlenW(lpIniFile) + 1;
        LPSTR szDrive    = NULL;
        LPSTR szDir      = NULL;

        if (dwPathSize < MAX_PATH) dwPathSize = MAX_PATH;
        szDrive = MemoryAllocate(2 * dwPathSize * sizeof(CHAR));
        if (szDrive == NULL) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        szDir = (LPSTR) (szDrive + dwPathSize);
        _splitpath(aszIniFile, szDrive, szDir, NULL, NULL);
        hr = StringCchPrintfA(lpIniPath, dwSize, "%s%s", szDrive, szDir);
        MemoryFree(szDrive);
    }
    else {
        hr = StringCchPrintfA(lpIniPath, dwSize, "%wsinc%ws%ws", szInfPath, Slash, lpDriverName);
    }
    dwLen = SearchPathA(lpIniPath, lpIncludeFileName, NULL, dwSize, lpIncludeFile, NULL);
    if (dwLen == 0) {
        // include file not found with the ini file so search the std. path
        dwLen = SearchPathA(NULL, lpIncludeFileName, NULL, dwSize, lpIncludeFile, NULL);
    }

    if (dwLen > 0) {
        // file name expanded and found so open
        fIncludeFile = fopen(lpIncludeFile, "rt");
        if (fIncludeFile == NULL) {
            OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_OPEN_INCLUDE), lpIncludeFileName);
            * pTable = NULL;
            dwStatus = ERROR_OPEN_FAILED;
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADINCLUDEFILE,
                    ARG_DEF(ARG_TYPE_STR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                    ERROR_OPEN_FAILED,
                    TRACE_STR(aszIniFile),
                    TRACE_STR(lpIncludeFile),
                    NULL));
            goto Cleanup;
        }
    }
    else {
        // unable to find the include filename
        // error is already in GetLastError
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_OPEN_INCLUDE), lpIncludeFileName);
        * pTable = NULL;
        dwStatus = ERROR_BAD_PATHNAME;
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADINCLUDEFILE,
                ARG_DEF(ARG_TYPE_STR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                ERROR_BAD_PATHNAME,
                TRACE_STR(aszIniFile),
                TRACE_STR(lpIncludeFileName),
                NULL));
        goto Cleanup;
    }

    //
    //  read ANSI Characters from include file
    //
    bReUse = FALSE;
    while (fgets(lpLineBuffer, dwFileSize, fIncludeFile) != NULL) {
        if (strlen(lpLineBuffer) > 8) {
            if (! bReUse) {
                // Build pTable list here. pTable list will be returned back to LoadPerfInstallPerfDll(),
                // used in UpdateRegistry(), then freed at the end of LoadPerfInstallPerfDll().
                //
                if (* pTable) {
                    // then add to list
                    pThisSymbol->pNext = MemoryAllocate(sizeof(SYMBOL_TABLE_ENTRY));
                    pThisSymbol        = pThisSymbol->pNext;
                }
                else { // allocate first element
                    * pTable    = MemoryAllocate(sizeof(SYMBOL_TABLE_ENTRY));
                    pThisSymbol = * pTable;
                }

                if (pThisSymbol == NULL) {
                    dwStatus = ERROR_OUTOFMEMORY;
                    goto Cleanup;
                }
            }

            // all the memory is allocated so load the fields

            pThisSymbol->pNext = NULL;
            iNumArgs = sscanf(lpLineBuffer, "#define %s %d", lpAnsiSymbol, & pThisSymbol->Value);
            if (iNumArgs != 2) {
                pThisSymbol->SymbolName = LoadPerfMultiByteToWideChar(CP_ACP, "");
                pThisSymbol->Value      = (DWORD) -1L;
                bReUse                  = TRUE;
            }
            else {
                pThisSymbol->SymbolName = LoadPerfMultiByteToWideChar(CP_ACP, lpAnsiSymbol);
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADINCLUDEFILE,
                        ARG_DEF(ARG_TYPE_STR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_SUCCESS,
                        TRACE_STR(lpIncludeFileName),
                        TRACE_WSTR(pThisSymbol->SymbolName),
                        TRACE_DWORD(pThisSymbol->Value),
                        NULL));
                bReUse = FALSE;
            }
        }
    }
    bReturn = TRUE;

Cleanup:
    MemoryFree(aszIniFile);
    MemoryFree(lpIncludeFileName);
    MemoryFree(lpIniPath);
    if (fIncludeFile != NULL) fclose(fIncludeFile);
    if (! bReturn) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADINCLUDEFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lpIniFile),
                NULL));
        SetLastError(dwStatus);
    }
    return bReturn;
}

BOOL
ParseTextId(
    LPWSTR                lpTextId,
    PSYMBOL_TABLE_ENTRY   pFirstSymbol,
    PDWORD                pdwOffset,
    LPWSTR              * lpLangId,
    PDWORD                pdwType
)
/*++
ParseTextId
    decodes Text Id key from .INI file
    syntax for this process is:
        {<DecimalNumber>}                {"NAME"}
        {<SymbolInTable>}_<LangIdString>_{"HELP"}
     e.g. 0_009_NAME
          OBJECT_1_009_HELP

Arguments
    lpTextId
        string to decode
    pFirstSymbol
        pointer to first entry in symbol table (NULL if no table)
    pdwOffset
        address of DWORD to recive offest value
    lpLangId
        address of pointer to Language Id string
        (NOTE: this will point into the string lpTextID which will be
        modified by this routine)
    pdwType
        pointer to dword that will recieve the type of string i.e.
        HELP or NAME

Return Value
    TRUE    text Id decoded successfully
    FALSE   unable to decode string
    NOTE: the string in lpTextID will be modified by this procedure
--*/
{
    BOOL                bReturn    = FALSE;
    DWORD               Status     = ERROR_SUCCESS;
    LPWSTR              lpThisChar;
    PSYMBOL_TABLE_ENTRY pThisSymbol;

    // check for valid return arguments

    if (pdwOffset == NULL || lpLangId == NULL || pdwType == NULL) {
        Status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // search string from right to left in order to identify the
    // components of the string.
    lpThisChar = lpTextId + lstrlenW(lpTextId); // point to end of string

    while (lpThisChar > lpTextId && * lpThisChar != cUnderscore) {
        lpThisChar --;
    }
    if (lpThisChar <= lpTextId) {
        // underscore not found in string
        Status = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    // first underscore found

    if (lstrcmpiW(lpThisChar, szName) == 0) {
        // name found, so set type
        * pdwType = TYPE_NAME;
    }
    else if (lstrcmpiW(lpThisChar, szHelp) == 0) {
        // help text found, so set type
        * pdwType = TYPE_HELP;
    }
    else {
        // bad format
        Status = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    // set the current underscore to \0 and look for language ID
    * lpThisChar-- = L'\0';

    while (lpThisChar > lpTextId && * lpThisChar != cUnderscore) {
        lpThisChar --;
    }
    if (lpThisChar <= lpTextId) {
        // underscore not found in string
        Status = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    // set lang ID string pointer to current char ('_') + 1
    * lpLangId = lpThisChar + 1;

    // set this underscore to a NULL and try to decode the remaining text

    * lpThisChar = L'\0';

    // see if the first part of the string is a decimal digit
    if (swscanf(lpTextId, sz_DFormat, pdwOffset) != 1) {
        // it's not a digit, so try to decode it as a symbol in the
        // loaded symbol table
        for (pThisSymbol=pFirstSymbol;
                        pThisSymbol != NULL && * pThisSymbol->SymbolName != L'\0';
                        pThisSymbol = pThisSymbol->pNext) {
            if (lstrcmpiW(lpTextId, pThisSymbol->SymbolName) == 0) {
            // a matching symbol was found, so insert it's value
            // and return (that's all that needs to be done
                * pdwOffset = pThisSymbol->Value;
                  bReturn    = TRUE;
                  break;
            }
        }
        if (! bReturn) {
            // if here, then no matching symbol was found, and it's not
            // a number, so return an error
            Status = ERROR_BAD_TOKEN_TYPE;
        }
    }
    else {
        // symbol was prefixed with a decimal number
        bReturn = TRUE;
    }

Cleanup:
    if (! bReturn) {
        SetLastError(Status);
    }
    return bReturn;
}

PLANGUAGE_LIST_ELEMENT
FindLanguage(
    PLANGUAGE_LIST_ELEMENT pFirstLang,
    LPCWSTR                pLangId
)
/*++
FindLanguage
    searchs the list of languages and returns a pointer to the language
    list entry that matches the pLangId string argument

Arguments
    pFirstLang
        pointer to first language list element
    pLangId
        pointer to text string with language ID to look up

Return Value
    Pointer to matching language list entry
    or NULL if no match
--*/
{
    PLANGUAGE_LIST_ELEMENT  pRtnLang = NULL;
    PLANGUAGE_LIST_ELEMENT  pThisLang;
    DWORD                   dwLang   = LoadPerfGetLCIDFromString((LPWSTR) pLangId);
    DWORD                   dwSubLang;

    for (pThisLang = pFirstLang; pThisLang; pThisLang = pThisLang->pNextLang) {
        if (pThisLang->dwLangId == dwLang) {
            // match found so return pointer
            pRtnLang = pThisLang;
            break;
        }
    }
    if (pRtnLang == NULL) {
        dwSubLang = (dwLang == PRIMARYLANGID(GetUserDefaultUILanguage()))
                  ? (GetUserDefaultUILanguage()) : (PRIMARYLANGID(dwLang));
        if (dwSubLang != dwLang) {
            for (pThisLang = pFirstLang; pThisLang; pThisLang = pThisLang->pNextLang) {
                if (pThisLang->dwLangId == dwSubLang) {
                    // match found so return pointer
                    pRtnLang = pThisLang;
                    break;
                }
            }
        }
    }
    return pRtnLang;
}

BOOL
GetValueW(
    PLANGUAGE_LIST_ELEMENT   pLang,
    LPWSTR                   lpLocalSectionBuff,
    LPWSTR                 * lpLocalStringBuff
)
{

    LPWSTR  lpPosition;
    LPWSTR  szThisLang = LoadPerfGetLanguage(pLang->LangId, FALSE);
    BOOL    bReturn    = FALSE;
    DWORD   dwSize;
    HRESULT hr;

    if (lpLocalStringBuff != NULL && szThisLang != NULL) {
        * lpLocalStringBuff = NULL;
        lpPosition = wcschr(lpLocalSectionBuff, wEquals);
        if (lpPosition) {
            lpPosition ++;
            // make sure the "=" isn't the last char
            dwSize = (* lpPosition != L'\0') ? (lstrlenW(lpPosition) + 1) : (2);
            * lpLocalStringBuff = MemoryAllocate(dwSize * sizeof(WCHAR));
            if (* lpLocalStringBuff != NULL) {
                hr      = (* lpPosition != L'\0')
                        ? StringCchCopyW(* lpLocalStringBuff, dwSize, lpPosition)
                        : StringCchCopyW(* lpLocalStringBuff, dwSize, L" ");
                bReturn = TRUE;
            }
            else {
                SetLastError(ERROR_OUTOFMEMORY);
            }
        }
        else {
            //ErrorFinfing the "="
            // bad format
            SetLastError(ERROR_INVALID_DATA);
        }
    }
    return bReturn;
}

BOOL
GetValueFromIniKeyW(
        PLANGUAGE_LIST_ELEMENT   pLang,
        LPWSTR                   lpValueKey,
        LPWSTR                   lpTextSection,
        DWORD                  * pdwLastReadOffset,
        DWORD                    dwTryCount,
        LPWSTR                 * lpLocalStringBuff
)
{
    LPWSTR lpLocalSectionBuff;
    DWORD  dwIndex;
    DWORD  dwLastReadOffset;
    BOOL   bRetVal = FALSE;

    if (lpTextSection != NULL && lpValueKey != NULL ) {
        dwLastReadOffset    = * pdwLastReadOffset;
        lpLocalSectionBuff  = lpTextSection;
        lpLocalSectionBuff += dwLastReadOffset;

        while(* lpLocalSectionBuff != L'\0') {
            dwLastReadOffset    += (lstrlenW(lpTextSection + dwLastReadOffset) + 1);
            lpLocalSectionBuff   = lpTextSection + dwLastReadOffset;
            * pdwLastReadOffset  = dwLastReadOffset;
        }

        // search next N entries in buffer for entry
        // this should usually work since the file
        // is scanned sequentially so it's tried first
        for (dwIndex = 0; dwIndex < dwTryCount; dwIndex ++) {
            //  see if this is the correct entry
            // and return it if it is
            if (wcsstr(lpLocalSectionBuff, lpValueKey)) {
                bRetVal = GetValueW(pLang, lpLocalSectionBuff, lpLocalStringBuff);
                //Set the lastReadOffset First
                dwLastReadOffset    += (lstrlenW(lpTextSection + dwLastReadOffset) + 1);
                * pdwLastReadOffset  = dwLastReadOffset;
                break; // out of the for loop
            }
            else {
                // this isn't the correct one so go to the next
                // entry in the file
                dwLastReadOffset    += (lstrlenW(lpTextSection + dwLastReadOffset) + 1);
                lpLocalSectionBuff   = lpTextSection + dwLastReadOffset;
                * pdwLastReadOffset  = dwLastReadOffset;
            }
        }
        if (! bRetVal) {
            //Cannont Find the key using lastReadOffset
            //try again from the beggining of the Array
            dwLastReadOffset    = 0;
            lpLocalSectionBuff  = lpTextSection;
            * pdwLastReadOffset = dwLastReadOffset;

            while (* lpLocalSectionBuff != L'\0') {
                if (wcsstr(lpLocalSectionBuff, lpValueKey)) {
                     bRetVal = GetValueW(pLang, lpLocalSectionBuff, lpLocalStringBuff);
                     break;
                }
                else {
                    // go to the next entry
                    dwLastReadOffset   += (lstrlenW(lpTextSection + dwLastReadOffset) + 1);
                    lpLocalSectionBuff  = lpTextSection + dwLastReadOffset;
                    * pdwLastReadOffset = dwLastReadOffset;
                }
            }
        }
    }
    return bRetVal;
}

BOOL
GetValueA(
    PLANGUAGE_LIST_ELEMENT   pLang,
    LPSTR                    lpLocalSectionBuff,
    LPWSTR                 * lpLocalStringBuff
)
{

    LPSTR  lpPosition;
    LPWSTR szThisLang = LoadPerfGetLanguage(pLang->LangId, FALSE);
    BOOL   bReturn    = FALSE;

    if (lpLocalStringBuff != NULL && szThisLang != NULL) {
        * lpLocalStringBuff = NULL;
        lpPosition = strchr(lpLocalSectionBuff, cEquals);
        if (lpPosition) {
            lpPosition ++;
            // make sure the "=" isn't the last char
            if (* lpPosition != '\0') {
                //Found the "equals" sign
                * lpLocalStringBuff = LoadPerfMultiByteToWideChar(LoadPerfGetCodePage(szThisLang), lpPosition);
            }
            else {
                // empty string, return a pseudo blank string
                * lpLocalStringBuff = LoadPerfMultiByteToWideChar(LoadPerfGetCodePage(szThisLang), " ");
            }
            bReturn = TRUE;
        }
        else {
            //ErrorFinfing the "="
            // bad format
            SetLastError(ERROR_INVALID_DATA);
        }
    }
    return bReturn;
}

BOOL
GetValueFromIniKeyA(
        PLANGUAGE_LIST_ELEMENT   pLang,
        LPSTR                    lpValueKey,
        LPSTR                    lpTextSection,
        DWORD                  * pdwLastReadOffset,
        DWORD                    dwTryCount,
        LPWSTR                 * lpLocalStringBuff
)
{
    LPSTR  lpLocalSectionBuff;
    DWORD  dwIndex;
    DWORD  dwLastReadOffset;
    BOOL   bRetVal = FALSE;

    if (lpTextSection != NULL && lpValueKey != NULL ) {
        dwLastReadOffset    = * pdwLastReadOffset;
        lpLocalSectionBuff  = lpTextSection;
        lpLocalSectionBuff += dwLastReadOffset;

        while(! (* lpLocalSectionBuff)) {
            dwLastReadOffset    += (lstrlenA(lpTextSection + dwLastReadOffset) + 1);
            lpLocalSectionBuff   = lpTextSection + dwLastReadOffset;
            * pdwLastReadOffset  = dwLastReadOffset;
        }

        // search next N entries in buffer for entry
        // this should usually work since the file
        // is scanned sequentially so it's tried first
        for (dwIndex = 0; dwIndex < dwTryCount; dwIndex++) {
            //  see if this is the correct entry
            // and return it if it is
            if (strstr(lpLocalSectionBuff, lpValueKey)) {
                bRetVal = GetValueA(pLang, lpLocalSectionBuff, lpLocalStringBuff);
                //Set the lastReadOffset First
                dwLastReadOffset    += (lstrlenA(lpTextSection + dwLastReadOffset) + 1);
                * pdwLastReadOffset  = dwLastReadOffset;
                break; // out of the for loop
            }
            else {
                // this isn't the correct one so go to the next
                // entry in the file
                dwLastReadOffset    += (lstrlenA(lpTextSection + dwLastReadOffset) + 1);
                lpLocalSectionBuff   = lpTextSection + dwLastReadOffset;
                * pdwLastReadOffset  = dwLastReadOffset;
            }
        }

        if (! bRetVal) {
            //Cannont Find the key using lastReadOffset
            //try again from the beggining of the Array
            dwLastReadOffset    = 0;
            lpLocalSectionBuff  = lpTextSection;
            * pdwLastReadOffset = dwLastReadOffset;

            while (* lpLocalSectionBuff != '\0') {
                if (strstr(lpLocalSectionBuff, lpValueKey)) {
                     bRetVal = GetValueA(pLang, lpLocalSectionBuff, lpLocalStringBuff);
                     break;
                }
                else {
                    // go to the next entry
                    dwLastReadOffset   += (lstrlenA(lpTextSection + dwLastReadOffset) + 1);
                    lpLocalSectionBuff  = lpTextSection + dwLastReadOffset;
                    * pdwLastReadOffset = dwLastReadOffset;
                }
            }
        }
    }
    return bRetVal;
}

BOOL
AddEntryToLanguage(
    PLANGUAGE_LIST_ELEMENT   pLang,
    LPWSTR                   lpValueKey,
    LPWSTR                   lpTextSection,
    DWORD                    dwUnicode,
    DWORD                  * pdwLastReadOffset,
    DWORD                    dwTryCount,
    DWORD                    dwType,
    DWORD                    dwOffset,
    DWORD                    dwFileSize
)
/*++
AddEntryToLanguage
    Add a text entry to the list of text entries for the specified language

Arguments
    pLang
        pointer to language structure to update
    lpValueKey
        value key to look up in .ini file
    dwOffset
        numeric offset of name in registry
    lpIniFile
        ini file

Return Value
    TRUE if added successfully
    FALSE if error
    (see GetLastError for status)
--*/
{
    LPWSTR  lpLocalStringBuff = NULL;
    LPSTR   aszValueKey       = (LPSTR) lpValueKey;
    LPSTR   aszTextSection    = (LPSTR) lpTextSection;
    DWORD   dwBufferSize      = 0;
    DWORD   dwStatus          = ERROR_SUCCESS;
    BOOL    bRetVal;
    BOOL    bReturn           = FALSE;
    HRESULT hr;

    if ((dwType == TYPE_NAME && dwOffset < FIRST_EXT_COUNTER_INDEX)
                    || (dwType == TYPE_HELP && dwOffset < FIRST_EXT_HELP_INDEX)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE,
                (DWORD) LDPRFMSG_CORRUPT_INDEX,
                3, dwOffset, dwType, __LINE__, 0,
                1, lpValueKey, NULL, NULL);
        if (dwUnicode == 0) {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_ADDENTRYTOLANGUAGE,
                    ARG_DEF(ARG_TYPE_STR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                    ERROR_BADKEY,
                    TRACE_STR(aszTextSection),
                    TRACE_STR(aszValueKey),
                    TRACE_DWORD(dwType),
                    TRACE_DWORD(dwOffset),
                    NULL));
        }
        else {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_ADDENTRYTOLANGUAGE,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpTextSection),
                    TRACE_WSTR(lpValueKey),
                    TRACE_DWORD(dwType),
                    TRACE_DWORD(dwOffset),
                    NULL));
        }
        dwStatus = ERROR_BADKEY;
        goto Cleanup;
    }

    if (lpValueKey != NULL) {
        if (dwUnicode == 0) {
            bRetVal = GetValueFromIniKeyA(pLang,
                                          aszValueKey,
                                          aszTextSection,
                                          pdwLastReadOffset,
                                          dwTryCount,
                                          & lpLocalStringBuff);
        }
        else {
            bRetVal = GetValueFromIniKeyW(pLang,
                                          lpValueKey,
                                          lpTextSection,
                                          pdwLastReadOffset,
                                          dwTryCount,
                                          & lpLocalStringBuff);
        }
        if (! bRetVal || lpLocalStringBuff == NULL) {
            DWORD dwLastReadOffset = * pdwLastReadOffset;
            if (dwUnicode == 0) {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_ADDENTRYTOLANGUAGE,
                        ARG_DEF(ARG_TYPE_STR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                        ERROR_BADKEY,
                        TRACE_STR(aszTextSection),
                        TRACE_STR(aszValueKey),
                        TRACE_DWORD(dwLastReadOffset),
                        NULL));
            }
            else {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_ADDENTRYTOLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_BADKEY,
                        TRACE_WSTR(lpTextSection),
                        TRACE_WSTR(lpValueKey),
                        TRACE_DWORD(dwLastReadOffset),
                        NULL));
            }
            dwStatus = ERROR_BADKEY;
            goto Cleanup;
        }

        else if (lstrcmpiW(lpLocalStringBuff, wszNotFound) == 0) {
            if (dwUnicode == 0) {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_ADDENTRYTOLANGUAGE,
                        ARG_DEF(ARG_TYPE_STR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                        ERROR_BADKEY,
                        TRACE_STR(aszTextSection),
                        TRACE_STR(aszValueKey),
                        NULL));
            }
            else {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_ADDENTRYTOLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_BADKEY,
                        TRACE_WSTR(lpTextSection),
                        TRACE_WSTR(lpValueKey),
                        NULL));
            }
            dwStatus = ERROR_BADKEY;
            goto Cleanup;
        }
    }
    else {
        dwBufferSize      = lstrlenW(lpTextSection) + 1;
        lpLocalStringBuff = MemoryAllocate(dwBufferSize * sizeof(WCHAR));
        if (!lpLocalStringBuff) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = StringCchCopyW(lpLocalStringBuff, dwBufferSize, lpTextSection);
    }

    // key found, so load structure
    if (! pLang->pThisName) {
        // this is the first
        pLang->pThisName = MemoryAllocate(sizeof(NAME_ENTRY) +
                        (lstrlenW(lpLocalStringBuff) + 1) * sizeof (WCHAR));
        if (!pLang->pThisName) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        else {
            pLang->pFirstName = pLang->pThisName;
        }
    }
    else {
        pLang->pThisName->pNext = MemoryAllocate(sizeof(NAME_ENTRY) +
                        (lstrlenW(lpLocalStringBuff) + 1) * sizeof (WCHAR));
        if (!pLang->pThisName->pNext) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        else {
            pLang->pThisName = pLang->pThisName->pNext;
        }
    }

    // pLang->pThisName now points to an uninitialized structre

    pLang->pThisName->pNext    = NULL;
    pLang->pThisName->dwOffset = dwOffset;
    pLang->pThisName->dwType   = dwType;
    pLang->pThisName->lpText   = (LPWSTR) & (pLang->pThisName[1]);
    hr = StringCchCopyW(pLang->pThisName->lpText, lstrlenW(lpLocalStringBuff) + 1, lpLocalStringBuff);
    bReturn = TRUE;

Cleanup:
    MemoryFree(lpLocalStringBuff);
    SetLastError(dwStatus);
    return (bReturn);
}

BOOL
CreateObjectList(
    LPWSTR              lpIniFile,
    DWORD               dwFirstDriverCounter,
    PSYMBOL_TABLE_ENTRY pFirstSymbol,
    LPWSTR              lpszObjectList,
    DWORD               dwObjectList,
    LPDWORD             pdwObjectGuidTableEntries
)
{
    WCHAR    szDigits[32];
    LPWSTR   szLangId;
    LPWSTR   szTempString;
    LPSTR    szGuidStringBuffer;
    LPSTR    szThisKey;
    DWORD    dwSize;
    DWORD    dwObjectCount          = 0;
    DWORD    dwId;
    DWORD    dwType;
    DWORD    dwObjectGuidIndex      = 0;
    DWORD    dwObjects[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD    dwBufferSize           = 0;
    LPSTR    szObjectSectionEntries = NULL;
    BOOL     bResult                = FALSE;
    DWORD    dwStatus               = ERROR_SUCCESS;
    LPSTR    aszIniFile             = NULL;
    HRESULT  hr;

    if (lpIniFile == NULL) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    aszIniFile = LoadPerfWideCharToMultiByte(CP_ACP, lpIniFile);
    if (aszIniFile == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    dwBufferSize = LoadPerfGetFileSize(lpIniFile, NULL, TRUE);
    if (dwBufferSize != 0xFFFFFFFF) {
        dwBufferSize *= sizeof(WCHAR);
    }
    else {
        dwBufferSize = 0;
    }

    if (dwBufferSize < SMALL_BUFFER_SIZE) {
        dwBufferSize = SMALL_BUFFER_SIZE;
    }
    szObjectSectionEntries = MemoryAllocate(dwBufferSize * sizeof(CHAR));
    if (szObjectSectionEntries == NULL) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    dwSize = GetPrivateProfileStringA(
                    szObjects,
                    NULL,
                    szNotFound,
                    szObjectSectionEntries,
                    dwBufferSize,
                    aszIniFile);

    * lpszObjectList = L'\0';
    dwObjectCount    = 0;
    if (lstrcmpiA(szObjectSectionEntries, szNotFound) != 0) {
        // then some entries were found so read each one, compute the
        // index value and save in the string buffer passed by the caller
        for (szThisKey = szObjectSectionEntries; * szThisKey != '\0'; szThisKey += (lstrlenA(szThisKey) + 1)) {
            // ParstTextId modifies the string so we need to make a work copy
            szTempString = LoadPerfMultiByteToWideChar(CP_ACP, szThisKey);
            if(szTempString == NULL) continue;

            if (ParseTextId(szTempString, pFirstSymbol, & dwId, & szLangId, & dwType)) {
                // then dwID is the id of an object supported by this DLL
                for (dwSize = 0; dwSize < dwObjectCount; dwSize ++) {
                    if ((dwId + dwFirstDriverCounter) == dwObjects[dwSize]) {
                        break;
                    }
                }
                if (dwSize >= dwObjectCount) {
                    if (dwObjectCount < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION) {
                        if (dwObjectCount != 0) {
                            hr = StringCchCatW(lpszObjectList, dwObjectList, BlankString);
                        }
                        dwObjects[dwObjectCount] = dwId + dwFirstDriverCounter;
                        _ultow((dwId + dwFirstDriverCounter), szDigits, 10);
                        hr = StringCchCatW(lpszObjectList, dwObjectList, szDigits);
                        dwObjectCount ++;
                    }
                    else {
                        // Too manu objects defined in INI file. Ignore.
                        continue;
                    }
                }

                //
                //  now see if this object has a GUID string
                //
                szGuidStringBuffer = MemoryAllocate(dwBufferSize * sizeof(CHAR));
                if (szGuidStringBuffer == NULL) {
                    MemoryFree(szTempString);
                    continue;
                }
                MemoryFree(szGuidStringBuffer);
            }
            MemoryFree(szTempString);
        }
        // save size of Guid Table
        * pdwObjectGuidTableEntries = dwObjectGuidIndex;
    }
    else {
        // log message that object list is not used
        TRACE((WINPERF_DBG_TRACE_WARNING),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_CREATEOBJECTLIST,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_SUCCESS,
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwFirstDriverCounter),
                NULL));
    }
    bResult = TRUE;

Cleanup:
    MemoryFree(szObjectSectionEntries);
    MemoryFree(aszIniFile);
    if (! bResult) SetLastError(dwStatus);
    return bResult;
}

BOOL
LoadLanguageLists(
    BOOL                   bQuietMode,
    LPWSTR                 lpIniFile,
    LPWSTR                 lpDriverName,
    DWORD                  dwMode,
    DWORD                  dwFirstCounter,
    DWORD                  dwFirstHelp,
    PSYMBOL_TABLE_ENTRY    pFirstSymbol,
    PLANGUAGE_LIST_ELEMENT pFirstLang
)
/*++
LoadLanguageLists
    Reads in the name and explain text definitions from the ini file and
    builds a list of these items for each of the supported languages and
    then combines all the entries into a sorted MULTI_SZ string buffer.

Arguments
    lpIniFile
        file containing the definitions to add to the registry
    dwFirstCounter
        starting counter name index number
    dwFirstHelp
        starting help text index number
    pFirstLang
        pointer to first element in list of language elements

Return Value
    TRUE if all is well
    FALSE if not
    error is returned in GetLastError
--*/
{
    LPSTR                   lpTextIdArray      = NULL;
    LPWSTR                  lpLocalKey         = NULL;
    LPWSTR                  lpThisLocalKey     = NULL;
    LPSTR                   lpThisIniFile      = NULL;
    LPWSTR                  lpwThisIniFile     = NULL;
    LPSTR                   lpThisKey          = NULL;
    LPSTR                   lpTextSectionArray = NULL;
    LPWSTR                  lpInfPath          = LoadPerfGetInfPath();
    DWORD                   dwSize;
    LPWSTR                  lpLang;
    DWORD                   dwOffset;
    DWORD                   dwType;
    DWORD                   dwUnicode;
    PLANGUAGE_LIST_ELEMENT  pThisLang;
    DWORD                   dwBufferSize;
    DWORD                   dwPathSize;
    DWORD                   dwSuccessCount     = 0;
    DWORD                   dwErrorCount       = 0;
    DWORD                   dwLastReadOffset   = 0;
    DWORD                   dwTryCount         = 4; // Init this value with 4
                                                    // (at least 4 times to try maching Key and Value)
    HRESULT                 hr;

    pThisLang = pFirstLang;
    while (pThisLang != NULL) {
         // if you have more languages then increase this try limit to
         // 4 + No. of langs
         dwTryCount ++;
         pThisLang = pThisLang->pNextLang;
    }

    if (lpIniFile == NULL || lpInfPath == NULL) {
        dwErrorCount = 1;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    dwPathSize = lstrlenW(lpInfPath) + lstrlenW(lpDriverName) + lstrlenW(lpIniFile) + 10;
    if (dwPathSize < MAX_PATH) dwPathSize = MAX_PATH;

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LOADLANGUAGELISTS,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ERROR_SUCCESS,
            TRACE_WSTR(lpIniFile),
            TRACE_DWORD(dwFirstCounter),
            TRACE_DWORD(dwFirstHelp),
            NULL));

    for (pThisLang  = pFirstLang; pThisLang != NULL; pThisLang = pThisLang->pNextLang) {
        WORD wLangTable = LoadPerfGetLCIDFromString(pThisLang->LangId);
        WORD wLangId;
        BOOL bAddEntry;

        if (dwMode & LODCTR_UPNF_NOBACKUP) {
            lpThisIniFile = LoadPerfWideCharToMultiByte(CP_ACP, lpIniFile);
            if (lpThisIniFile == NULL) {
                continue;
            }
        }
        else {
            LPWSTR szThisLang = LoadPerfGetLanguage(pThisLang->LangId, FALSE);

            lpThisIniFile = MemoryAllocate(dwPathSize * sizeof(CHAR));
            if (lpThisIniFile == NULL) {
                continue;
            }
            hr = StringCchPrintfA(lpThisIniFile, dwPathSize, "%ws%ws%ws%ws%ws%ws",
                    lpInfPath, szThisLang, Slash, lpDriverName, Slash, lpIniFile);
        }
        lpwThisIniFile = LoadPerfMultiByteToWideChar(CP_ACP, lpThisIniFile);

        dwBufferSize = LoadPerfGetFileSize((LPWSTR) lpThisIniFile, & dwUnicode, FALSE);
        if (dwBufferSize == 0) {
            if (! (dwMode & LODCTR_UPNF_NOBACKUP)) {
                ZeroMemory(lpThisIniFile, dwPathSize * sizeof(CHAR));
                hr = StringCchPrintfA(lpThisIniFile, dwPathSize, "%ws%ws%ws%ws%ws%ws",
                        lpInfPath, DefaultLangId, Slash, lpDriverName, Slash, lpIniFile);
                dwBufferSize = LoadPerfGetFileSize((LPWSTR) lpThisIniFile, & dwUnicode, FALSE);
            }
        }
        if (dwBufferSize == 0xFFFFFFFF) {
            dwBufferSize = 0;
        }
        if(dwBufferSize < SMALL_BUFFER_SIZE) dwBufferSize = SMALL_BUFFER_SIZE;

        lpTextIdArray      = MemoryAllocate(dwBufferSize * sizeof(CHAR));
        lpTextSectionArray = MemoryAllocate(dwBufferSize * sizeof(WCHAR));
        if (lpTextIdArray == NULL || lpTextSectionArray == NULL) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADLANGUAGELISTS,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_OUTOFMEMORY,
                    TRACE_WSTR(lpIniFile),
                    TRACE_DWORD(dwFirstCounter),
                    TRACE_DWORD(dwFirstHelp),
                    NULL));
            dwErrorCount = 1;
            SetLastError(ERROR_OUTOFMEMORY);
            goto Cleanup;
        }

        // get list of text keys to look up
        dwSize = GetPrivateProfileStringA(szText,         // [text] section of .INI file
                                          NULL,           // return all keys
                                          szNotFound,
                                          lpTextIdArray,  // return buffer
                                          dwBufferSize,
                                          lpThisIniFile); // .INI file name
        if ((lstrcmpiA(lpTextIdArray, szNotFound)) == 0) {
            // key not found, default returned
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADLANGUAGELISTS,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_NO_SUCH_GROUP,
                    TRACE_WSTR(lpIniFile),
                    TRACE_DWORD(dwFirstCounter),
                    TRACE_DWORD(dwFirstHelp),
                    NULL));
            dwErrorCount ++;
            SetLastError(ERROR_NO_SUCH_GROUP);
            goto Cleanup;
        }

        // get the the [text] section from the ini file
        if (dwUnicode == 0) {
            dwSize = GetPrivateProfileSectionA(szText,              // [text] section of .INI file
                                               lpTextSectionArray,  // return buffer
                                               dwBufferSize * sizeof(WCHAR),
                                               lpThisIniFile);      // .INI file name
        }
        else {
            dwSize = GetPrivateProfileSectionW(wszText,                      // [text] section of .INI file
                                               (LPWSTR) lpTextSectionArray,  // return buffer
                                               dwBufferSize,
                                               lpwThisIniFile);              // .INI file name
        }

        // do each key returned
        dwLastReadOffset = 0;
        for (lpThisKey  = lpTextIdArray;
                        lpThisKey != NULL && * lpThisKey != '\0';
                        lpThisKey += (lstrlenA(lpThisKey) + 1)) {
            lpLocalKey     = LoadPerfMultiByteToWideChar(CP_ACP, lpThisKey);
            lpThisLocalKey = LoadPerfMultiByteToWideChar(CP_ACP, lpThisKey);
            if (lpLocalKey == NULL || lpThisLocalKey == NULL) {
                MemoryFree(lpLocalKey);
                MemoryFree(lpThisLocalKey);
                lpLocalKey = lpThisLocalKey = NULL;
                continue;
            }

            // parse key to see if it's in the correct format

            if (ParseTextId(lpLocalKey, pFirstSymbol, & dwOffset, & lpLang, & dwType)) {
                // so get pointer to language entry structure
                bAddEntry = FALSE;
                wLangId   = LoadPerfGetLCIDFromString(lpLang);

                if (wLangId == wLangTable) {
                    bAddEntry = TRUE;
                }
                else if (PRIMARYLANGID(wLangTable) == wLangId) {
                    bAddEntry = TRUE;
                }
                else if (PRIMARYLANGID(wLangId) == wLangTable) {
                    bAddEntry = (GetUserDefaultUILanguage() == wLangId) ? TRUE : FALSE;
                }

                if (bAddEntry) {
                    if (! AddEntryToLanguage(pThisLang,
                                             (dwUnicode == 0) ? ((LPWSTR) lpThisKey) : (lpThisLocalKey),
                                             (LPWSTR) lpTextSectionArray,
                                             dwUnicode,
                                             & dwLastReadOffset,
                                             dwTryCount,
                                             dwType,
                                             (dwOffset + ((dwType == TYPE_NAME)
                                                          ? dwFirstCounter
                                                          : dwFirstHelp)),
                                             dwBufferSize)) {
                        OUTPUT_MESSAGE(bQuietMode,
                                       GetFormatResource(LC_ERRADDTOLANG),
                                       lpLocalKey,
                                       lpLang,
                                       GetLastError());
                        dwErrorCount ++;
                    }
                    else {
                        dwSuccessCount ++;
                    }
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_LOADLANGUAGELISTS,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            ERROR_SUCCESS,
                            TRACE_WSTR(lpLocalKey),
                            TRACE_WSTR(lpLang),
                            TRACE_DWORD(dwOffset),
                            TRACE_DWORD(dwType),
                            NULL));
                }
            }
            else { // unable to parse ID string
                OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_BAD_KEY), lpLocalKey);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADLANGUAGELISTS,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_BADKEY,
                        TRACE_WSTR(lpLocalKey),
                        TRACE_WSTR(lpLang),
                        NULL));
            }
            MemoryFree(lpLocalKey);
            MemoryFree(lpThisLocalKey);
            lpLocalKey = lpThisLocalKey = NULL;
        }
        MemoryFree(lpTextIdArray);
        MemoryFree(lpTextSectionArray);
        lpTextIdArray = lpTextSectionArray = NULL;
    }

Cleanup:
    MemoryFree(lpwThisIniFile);
    MemoryFree(lpThisIniFile);
    MemoryFree(lpTextIdArray);
    MemoryFree(lpLocalKey);
    MemoryFree(lpThisLocalKey);
    MemoryFree(lpTextSectionArray);
    return (BOOL) (dwErrorCount == 0);
}

BOOL
SortLanguageTables(
    PLANGUAGE_LIST_ELEMENT pFirstLang,
    PDWORD                 pdwLastName,
    PDWORD                 pdwLastHelp
)
/*++
SortLangageTables
    walks list of languages loaded, allocates and loads a sorted multi_SZ
    buffer containing new entries to be added to current names/help text

Arguments
    pFirstLang
        pointer to first element in list of languages

ReturnValue
    TRUE    everything done as expected
    FALSE   error occurred, status in GetLastError
--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;
    BOOL                    bSorted;
    LPWSTR                  pNameBufPos, pHelpBufPos;
    PNAME_ENTRY             pThisName, pPrevName;
    DWORD                   dwHelpSize, dwNameSize, dwSize;
    DWORD                   dwCurrentLastName;
    DWORD                   dwCurrentLastHelp;
    BOOL                    bReturn  = FALSE;
    DWORD                   dwStatus = ERROR_SUCCESS;
    HRESULT                 hr;

    if (pdwLastName == NULL || pdwLastHelp == NULL) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SORTLANGUAGETABLES,
                0,
                ERROR_BAD_ARGUMENTS,
                NULL));
        dwStatus = ERROR_BAD_ARGUMENTS;
        goto Cleanup;
    }

    for (pThisLang = pFirstLang; pThisLang != NULL; pThisLang = pThisLang->pNextLang) {
        // do each language in list
        // sort elements in list by value (offset) so that lowest is first
        if (pThisLang->pFirstName == NULL) {
            // no elements in this list, continue the next one
            continue;
        }

        bSorted = FALSE;
        while (!bSorted) {
            // point to start of list
            pPrevName = pThisLang->pFirstName;
            if (pPrevName) {
                pThisName = pPrevName->pNext;
            }
            else {
                break; // no elements in this list
            }

            if (!pThisName) {
                break;      // only one element in the list
            }
            bSorted = TRUE; // assume that it's sorted

            // go until end of list

            while (pThisName->pNext) {
                if (pThisName->dwOffset > pThisName->pNext->dwOffset) {
                    // switch 'em
                    PNAME_ENTRY     pA, pB;
                    pPrevName->pNext = pThisName->pNext;
                    pA               = pThisName->pNext;
                    pB               = pThisName->pNext->pNext;
                    pThisName->pNext = pB;
                    pA->pNext        = pThisName;
                    pThisName        = pA;
                    bSorted          = FALSE;
                }
                //move to next entry
                pPrevName = pThisName;
                pThisName = pThisName->pNext;
            }
            // if bSorted = TRUE , then we walked all the way down
            // the list without changing anything so that's the end.
        }

        // with the list sorted, build the MULTI_SZ strings for the
        // help and name text strings

        // compute buffer size

        dwNameSize = dwHelpSize = 0;
        dwCurrentLastName = 0;
        dwCurrentLastHelp = 0;

        for (pThisName = pThisLang->pFirstName; pThisName != NULL; pThisName = pThisName->pNext) {
            // compute buffer requirements for this entry
            dwSize = SIZE_OF_OFFSET_STRING;
            dwSize += lstrlenW(pThisName->lpText);
            dwSize += 1;   // null
            dwSize *= sizeof(WCHAR);   // adjust for character size
            // add to appropriate size register
            if (pThisName->dwType == TYPE_NAME) {
                dwNameSize += dwSize;
                if (pThisName->dwOffset > dwCurrentLastName) {
                    dwCurrentLastName = pThisName->dwOffset;
                }
            }
            else if (pThisName->dwType == TYPE_HELP) {
                dwHelpSize += dwSize;
                if (pThisName->dwOffset > dwCurrentLastHelp) {
                    dwCurrentLastHelp = pThisName->dwOffset;
                }
            }
        }

        // allocate buffers for the Multi_SZ strings

        pThisLang->NameBuffer = MemoryAllocate(dwNameSize);
        pThisLang->HelpBuffer = MemoryAllocate(dwHelpSize);

        if (!pThisLang->NameBuffer || !pThisLang->HelpBuffer) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_SORTLANGUAGETABLES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_OUTOFMEMORY,
                    TRACE_WSTR(pThisLang->LangId),
                    TRACE_DWORD(pThisLang->dwNumElements),
                    TRACE_DWORD(dwCurrentLastName),
                    TRACE_DWORD(dwCurrentLastHelp),
                    NULL));
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        // fill in buffers with sorted strings
        pNameBufPos = (LPWSTR) pThisLang->NameBuffer;
        pHelpBufPos = (LPWSTR) pThisLang->HelpBuffer;

        for (pThisName = pThisLang->pFirstName; pThisName != NULL; pThisName = pThisName->pNext) {
            if (pThisName->dwType == TYPE_NAME) {
                // load number as first 0-term. string
                hr = StringCchPrintfW(pNameBufPos, dwNameSize, szDFormat, pThisName->dwOffset);
                dwSize       = lstrlenW(pNameBufPos) + 1;
                dwNameSize  -= dwSize;
                pNameBufPos += dwSize;  // save NULL term.
                // load the text to match
                hr = StringCchCopyW(pNameBufPos, dwNameSize, pThisName->lpText);
                dwSize       = lstrlenW(pNameBufPos) + 1;
                dwNameSize  -= dwSize;
                pNameBufPos += dwSize;
            }
            else if (pThisName->dwType == TYPE_HELP) {
                // load number as first 0-term. string
                hr = StringCchPrintfW(pHelpBufPos, dwHelpSize, szDFormat, pThisName->dwOffset);
                dwSize       = lstrlenW(pHelpBufPos) + 1;
                dwHelpSize  -= dwSize;
                pHelpBufPos += dwSize;  // save NULL term.
                // load the text to match
                hr = StringCchCopyW(pHelpBufPos, dwHelpSize, pThisName->lpText);
                dwSize       = lstrlenW(pHelpBufPos) + 1;
                dwHelpSize  -= dwSize;
                pHelpBufPos += dwSize;
            }
        }

        // add additional NULL at end of string to terminate MULTI_SZ

        * pHelpBufPos = L'\0';
        * pNameBufPos = L'\0';

        // compute size of MULTI_SZ strings
        pThisLang->dwNameBuffSize = (DWORD) ((PBYTE) pNameBufPos - (PBYTE) pThisLang->NameBuffer) + sizeof(WCHAR);
        pThisLang->dwHelpBuffSize = (DWORD) ((PBYTE) pHelpBufPos - (PBYTE) pThisLang->HelpBuffer) + sizeof(WCHAR);

        if (* pdwLastName < dwCurrentLastName) {
            * pdwLastName = dwCurrentLastName;
        }
        if (* pdwLastHelp < dwCurrentLastHelp) {
            * pdwLastHelp = dwCurrentLastHelp;
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SORTLANGUAGETABLES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_SUCCESS,
                TRACE_WSTR(pThisLang->LangId),
                TRACE_DWORD(pThisLang->dwNumElements),
                TRACE_DWORD(dwCurrentLastName),
                TRACE_DWORD(dwCurrentLastHelp),
                NULL));
    }

    dwCurrentLastName = * pdwLastName;
    dwCurrentLastHelp = * pdwLastHelp;
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_SORTLANGUAGETABLES,
            0,
            ERROR_SUCCESS,
            TRACE_DWORD(dwCurrentLastName),
            TRACE_DWORD(dwCurrentLastHelp),
            NULL));
    if (dwCurrentLastHelp != dwCurrentLastName + 1) {
        TRACE((WINPERF_DBG_TRACE_WARNING),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SORTLANGUAGETABLES,
                0,
                ERROR_SUCCESS,
                TRACE_DWORD(dwCurrentLastName),
                TRACE_DWORD(dwCurrentLastHelp),
                NULL));
        dwCurrentLastHelp = dwCurrentLastName + 1;
        * pdwLastHelp     = dwCurrentLastHelp;
    }
    bReturn = TRUE;

Cleanup:
    if (! bReturn) {
        SetLastError(dwStatus);
    }
    return bReturn;
}

BOOL
GetInstalledLanguageList(
    HKEY     hPerflibRoot,
    LPWSTR * mszLangList
)
/*++
    returns a list of language sub keys found under the perflib key

    GetInstalledLanguageList() build mszLandList MULTI_SZ string from performance registry setting.
    Caller UpdateRegistry() should free the memory.
--*/
{
    BOOL    bReturn       = TRUE;
    LONG    lStatus;
    DWORD   dwIndex       = 0;
    LPWSTR  szBuffer;
    DWORD   dwBufSize     = MAX_PATH;
    LPWSTR  szRetBuffer   = NULL;
    LPWSTR  szTmpBuffer;
    DWORD   dwAllocSize   = MAX_PATH;
    DWORD   dwRetBufSize  = 0;
    DWORD   dwLastBufSize = 0;
    LPWSTR  szNextString;
    HRESULT hr;

    dwBufSize   = MAX_PATH;
    szBuffer    = MemoryAllocate(dwBufSize   * sizeof(WCHAR));
    dwAllocSize = MAX_PATH;
    szRetBuffer = MemoryAllocate(dwAllocSize * sizeof(WCHAR));
    if (szBuffer == NULL || szRetBuffer == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        bReturn = FALSE;
    }

    if (bReturn) {
        while ((lStatus = RegEnumKeyExW(hPerflibRoot, dwIndex, szBuffer, & dwBufSize, NULL, NULL, NULL, NULL))
                                == ERROR_SUCCESS) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_GETINSTALLEDLANGUAGELIST,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_SUCCESS,
                    TRACE_WSTR(szBuffer),
                    TRACE_DWORD(dwIndex),
                    TRACE_DWORD(dwLastBufSize),
                    TRACE_DWORD(dwRetBufSize),
                    NULL));

            dwRetBufSize += (lstrlenW(szBuffer) + 1);
            if (dwRetBufSize >= dwAllocSize) {
                szTmpBuffer = szRetBuffer;
                dwAllocSize = dwRetBufSize + MAX_PATH;
                szRetBuffer = MemoryResize(szTmpBuffer, dwAllocSize * sizeof(WCHAR));
            }
            if (szRetBuffer == NULL) {
                MemoryFree(szTmpBuffer);
                bReturn = FALSE;
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_GETINSTALLEDLANGUAGELIST,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_OUTOFMEMORY,
                        TRACE_WSTR(szBuffer),
                        TRACE_DWORD(dwIndex),
                        TRACE_DWORD(dwLastBufSize),
                        TRACE_DWORD(dwRetBufSize),
                        NULL));
                SetLastError(ERROR_OUTOFMEMORY);
                break;
            }

            szNextString  = (LPWSTR) (szRetBuffer + dwLastBufSize);
            hr = StringCchCopyW(szNextString, dwAllocSize - dwLastBufSize, szBuffer);
            dwLastBufSize = dwRetBufSize;
            dwIndex ++;
            dwBufSize = MAX_PATH;
            RtlZeroMemory(szBuffer, dwBufSize * sizeof(WCHAR));
        }
    }

    if (bReturn) {
        WCHAR szLangId[8];
        DWORD dwSubLangId = GetUserDefaultUILanguage();
        DWORD dwLangId    = PRIMARYLANGID(dwSubLangId);
        BOOL  bFound      = FALSE;

        bFound = FALSE;
        for (szNextString = szRetBuffer; * szNextString != L'\0'; szNextString += (lstrlenW(szNextString) + 1)) {
            if (lstrcmpiW(szNextString, DefaultLangId) == 0) {
                bFound = TRUE;
                break;
            }
        }
        if (! bFound) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_GETINSTALLEDLANGUAGELIST,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_SUCCESS,
                    TRACE_WSTR(DefaultLangId),
                    TRACE_DWORD(dwIndex),
                    TRACE_DWORD(dwLastBufSize),
                    TRACE_DWORD(dwRetBufSize),
                    NULL));

            dwRetBufSize += (lstrlenW(DefaultLangId) + 1);
            if (dwRetBufSize >= dwAllocSize) {
                szTmpBuffer = szRetBuffer;
                dwAllocSize = dwRetBufSize + MAX_PATH;
                szRetBuffer = MemoryResize(szTmpBuffer, dwAllocSize * sizeof(WCHAR));
            }
            if (szRetBuffer == NULL) {
                MemoryFree(szTmpBuffer);
                bReturn = FALSE;
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_GETINSTALLEDLANGUAGELIST,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_OUTOFMEMORY,
                        TRACE_WSTR(DefaultLangId),
                        TRACE_DWORD(dwIndex),
                        TRACE_DWORD(dwLastBufSize),
                        TRACE_DWORD(dwRetBufSize),
                        NULL));
                SetLastError(ERROR_OUTOFMEMORY);
            }
            else {
                szNextString  = (LPWSTR) (szRetBuffer + dwLastBufSize);
                hr = StringCchCopyW(szNextString, dwAllocSize - dwLastBufSize, DefaultLangId);
                dwLastBufSize = dwRetBufSize;
                dwIndex ++;
            }
        }

        if (dwLangId != 0x009) {
            WCHAR nDigit;
            DWORD dwThisLang;

            ZeroMemory(szLangId, 8 * sizeof(WCHAR));
            nDigit      = (WCHAR) (dwLangId >> 8);
            szLangId[0] = tohexdigit(nDigit);
            nDigit      = (WCHAR) (dwLangId & 0XF0) >> 4;
            szLangId[1] = tohexdigit(nDigit);
            nDigit      = (WCHAR) (dwLangId & 0xF);
            szLangId[2] = tohexdigit(nDigit);

            bFound = FALSE;
            for (szNextString = szRetBuffer; * szNextString != L'\0'; szNextString += (lstrlenW(szNextString) + 1)) {
                dwThisLang = LoadPerfGetLCIDFromString(szNextString);
                if (dwThisLang == dwSubLangId || PRIMARYLANGID(dwThisLang) == dwLangId) {
                    bFound = TRUE;
                    break;
                }
            }
            if (! bFound) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_GETINSTALLEDLANGUAGELIST,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_SUCCESS,
                        TRACE_WSTR(szLangId),
                        TRACE_DWORD(dwIndex),
                        TRACE_DWORD(dwLastBufSize),
                        TRACE_DWORD(dwRetBufSize),
                        NULL));
                dwRetBufSize += (lstrlenW(szLangId) + 1);
                if (dwRetBufSize >= dwAllocSize) {
                    szTmpBuffer = szRetBuffer;
                    dwAllocSize = dwRetBufSize + MAX_PATH;
                    szRetBuffer = MemoryResize(szTmpBuffer, dwAllocSize * sizeof(WCHAR));
                }
                if (szRetBuffer == NULL) {
                    MemoryFree(szTmpBuffer);
                    bReturn = FALSE;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_GETINSTALLEDLANGUAGELIST,
                            ARG_DEF(ARG_TYPE_WSTR, 1),
                            ERROR_OUTOFMEMORY,
                            TRACE_WSTR(szLangId),
                            TRACE_DWORD(dwIndex),
                            TRACE_DWORD(dwLastBufSize),
                            TRACE_DWORD(dwRetBufSize),
                            NULL));
                    SetLastError(ERROR_OUTOFMEMORY);
                }
                else {
                    szNextString  = (LPWSTR) (szRetBuffer + dwLastBufSize);
                    hr = StringCchCopyW(szNextString, dwAllocSize - dwLastBufSize, szLangId);
                    dwLastBufSize = dwRetBufSize;
                    dwIndex ++;
                }
            }
        }
    }

    if (bReturn) {
        // add terminating null char
        dwRetBufSize ++;
        if (dwRetBufSize > dwAllocSize) {
            szTmpBuffer = szRetBuffer;
            dwAllocSize = dwRetBufSize;
            szRetBuffer = MemoryResize(szTmpBuffer, dwRetBufSize * sizeof(WCHAR));
            if (szRetBuffer == NULL) {
                MemoryFree(szTmpBuffer);
                SetLastError(ERROR_OUTOFMEMORY);
                bReturn = FALSE;
            }
        }
        if (szRetBuffer != NULL) {
            szNextString   = (LPWSTR) (szRetBuffer + dwLastBufSize);
            * szNextString = L'\0';
        }
    }

    if (bReturn) {
        * mszLangList = szRetBuffer;
    }
    else {
        * mszLangList = NULL;
        MemoryFree(szRetBuffer);
    }

    MemoryFree(szBuffer);
    return bReturn;
}

BOOL
CheckNameTable(
    LPWSTR   lpNameStr,
    LPWSTR   lpHelpStr,
    LPDWORD  pdwLastCounter,
    LPDWORD  pdwLastHelp,
    BOOL     bUpdate
)
{
    BOOL   bResult          = TRUE;
    BOOL   bChanged         = FALSE;
    LPWSTR lpThisId;
    DWORD  dwThisId;
    DWORD  dwLastCounter    = * pdwLastCounter;
    DWORD  dwLastHelp       = * pdwLastHelp;
    DWORD  dwLastId         = (dwLastCounter > dwLastHelp)
                            ? (dwLastCounter) : (dwLastHelp);

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
             __LINE__,
             LOADPERF_CHECKNAMETABLE,
             0,
             ERROR_SUCCESS,
             TRACE_DWORD(dwLastCounter),
             TRACE_DWORD(dwLastHelp),
             NULL));
    for (lpThisId = lpNameStr; * lpThisId != L'\0'; lpThisId += (lstrlenW(lpThisId) + 1)) {
        dwThisId = wcstoul(lpThisId, NULL, 10);
        if ((dwThisId == 0) || (dwThisId != 1 && dwThisId % 2 != 0)) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT,
                    4, dwThisId, dwLastCounter, dwLastId, __LINE__,
                    1, lpThisId, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_CHECKNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisId),
                    TRACE_DWORD(dwThisId),
                    TRACE_DWORD(dwLastCounter),
                    TRACE_DWORD(dwLastHelp),
                    NULL));
            SetLastError(ERROR_BADKEY);
            bResult = FALSE;
            break;
        }
        else if (dwThisId > dwLastId || dwThisId > dwLastCounter) {
            if (bUpdate) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT,
                        4, dwThisId, dwLastCounter, dwLastId, __LINE__,
                        1, lpThisId, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_CHECKNAMETABLE,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_BADKEY,
                        TRACE_WSTR(lpThisId),
                        TRACE_DWORD(dwThisId),
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
                SetLastError(ERROR_BADKEY);
                bResult = FALSE;
                break;
            }
            else {
                bChanged = TRUE;
                if (dwThisId > dwLastCounter) dwLastCounter = dwThisId;
                if (dwLastCounter > dwLastId) dwLastId      = dwLastCounter;
            }
        }

        lpThisId += (lstrlenW(lpThisId) + 1);
    }

    if (! bResult) goto Cleanup;

    for (lpThisId = lpHelpStr; * lpThisId != L'\0'; lpThisId += (lstrlenW(lpThisId) + 1)) {

        dwThisId = wcstoul(lpThisId, NULL, 10);
        if ((dwThisId == 0) || (dwThisId != 1 && dwThisId % 2 == 0)) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT,
                    4, dwThisId, dwLastHelp, dwLastId, __LINE__,
                    1, lpThisId, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_CHECKNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisId),
                    TRACE_DWORD(dwThisId),
                    TRACE_DWORD(dwLastCounter),
                    TRACE_DWORD(dwLastHelp),
                    NULL));
            SetLastError(ERROR_BADKEY);
            bResult = FALSE;
            break;
        }
        else if (dwThisId > dwLastId || dwThisId > dwLastHelp) {
            if (bUpdate) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT,
                        4, dwThisId, dwLastHelp, dwLastId, __LINE__,
                        1, lpThisId, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_CHECKNAMETABLE,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_BADKEY,
                        TRACE_WSTR(lpThisId),
                        TRACE_DWORD(dwThisId),
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
                SetLastError(ERROR_BADKEY);
                bResult = FALSE;
                break;
            }
            else {
                bChanged = TRUE;
                if (dwThisId > dwLastHelp) dwLastHelp = dwThisId;
                if (dwLastHelp > dwLastId) dwLastId   = dwLastHelp;
            }
        }
        lpThisId += (lstrlenW(lpThisId) + 1);
    }

Cleanup:
    if (bResult) {
        if (bChanged) {
            ReportLoadPerfEvent(
                EVENTLOG_WARNING_TYPE,
                (DWORD) LDPRFMSG_CORRUPT_PERFLIB_INDEX,
                4, * pdwLastCounter, * pdwLastHelp, dwLastCounter, dwLastHelp,
                0, NULL, NULL, NULL);
            * pdwLastCounter = dwLastCounter;
            * pdwLastHelp    = dwLastHelp;
        }
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
             __LINE__,
             LOADPERF_CHECKNAMETABLE,
             0,
             GetLastError(),
             TRACE_DWORD(dwLastCounter),
             TRACE_DWORD(dwLastHelp),
             NULL));

    return bResult;
}

BOOL
UpdateEachLanguage(
    BOOL                    bQuietMode,
    HKEY                    hPerflibRoot,
    LPWSTR                  mszInstalledLangList,
    LPDWORD                 pdwLastCounter,
    LPDWORD                 pdwLastHelp,
    PLANGUAGE_LIST_ELEMENT  pFirstLang,
    DWORD                   dwMode,
    BOOL                    bUpdate
)
/*++
UpdateEachLanguage
    Goes through list of languages and adds the sorted MULTI_SZ strings
    to the existing counter and explain text in the registry.
    Also updates the "Last Counter and Last Help" values

Arguments
    hPerflibRoot    handle to Perflib key in the registry
    mszInstalledLangList
                    MSZ string of installed language keys
    pFirstLanguage  pointer to first language entry

Return Value
    TRUE    all went as planned
    FALSE   an error occured, use GetLastError to find out what it was.
--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;
    LPWSTR                  pHelpBuffer          = NULL;
    LPWSTR                  pNameBuffer          = NULL;
    LPWSTR                  pNewName             = NULL;
    LPWSTR                  pNewHelp             = NULL;
    DWORD                   dwLastCounter        = * pdwLastCounter;
    DWORD                   dwLastHelp           = * pdwLastHelp;
    DWORD                   dwBufferSize;
    DWORD                   dwValueType;
    DWORD                   dwCounterSize;
    DWORD                   dwHelpSize;
    HKEY                    hKeyThisLang         = NULL;
    LONG                    lStatus;
    LPWSTR                  CounterNameBuffer    = NULL;
    LPWSTR                  HelpNameBuffer       = NULL;
    LPWSTR                  AddCounterNameBuffer = NULL;
    LPWSTR                  AddHelpNameBuffer    = NULL;
    LPWSTR                  szThisLang;
    BOOL                    bResult              = TRUE;
    HRESULT                 hr;

    if (bUpdate && ((dwMode & LODCTR_UPNF_REPAIR) == 0)) {
        //  this isn't possible on 3.1
        MakeBackupCopyOfLanguageFiles(NULL);
    }
    CounterNameBuffer = MemoryAllocate(4 * MAX_PATH * sizeof(WCHAR));
    if (CounterNameBuffer == NULL) {
        lStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    HelpNameBuffer       = CounterNameBuffer    + MAX_PATH;
    AddCounterNameBuffer = HelpNameBuffer       + MAX_PATH;
    AddHelpNameBuffer    = AddCounterNameBuffer + MAX_PATH;

    for (szThisLang = mszInstalledLangList; *szThisLang != L'\0'; szThisLang += (lstrlenW(szThisLang) + 1)) {

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                 __LINE__,
                 LOADPERF_UPDATEEACHLANGUAGE,
                 ARG_DEF(ARG_TYPE_WSTR, 1),
                 ERROR_SUCCESS,
                 TRACE_WSTR(szThisLang),
                 NULL));
        hr = StringCchPrintfW(CounterNameBuffer,    MAX_PATH, L"%ws%ws", CounterNameStr,    szThisLang);
        hr = StringCchPrintfW(HelpNameBuffer,       MAX_PATH, L"%ws%ws", HelpNameStr,       szThisLang);
        hr = StringCchPrintfW(AddCounterNameBuffer, MAX_PATH, L"%ws%ws", AddCounterNameStr, szThisLang);
        hr = StringCchPrintfW(AddHelpNameBuffer,    MAX_PATH, L"%ws%ws", AddHelpNameStr,    szThisLang);

        // make sure this language is loaded
        __try {
            lStatus = RegOpenKeyExW(hPerflibRoot, szThisLang, RESERVED, KEY_READ, & hKeyThisLang);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                     __LINE__,
                     LOADPERF_UPDATEEACHLANGUAGE,
                     ARG_DEF(ARG_TYPE_WSTR, 1),
                     lStatus,
                     TRACE_WSTR(szThisLang),
                     NULL));
        }

        // we just need the open status, not the key handle so
        // close this handle and set the one we need.

        if (lStatus == ERROR_SUCCESS) {
            RegCloseKey(hKeyThisLang);
        }
        else if (lStatus == ERROR_FILE_NOT_FOUND) {
            // Somehow language subkey is not there under
            //     "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\PERFLIB".
            // This should be a rare case, but seems like a common scenario during upgrade
            //     from NT4 to XP and .NET server.
            // We should still treat this as success and try update it.
            //
            lStatus = ERROR_SUCCESS;
        }
        hKeyThisLang = HKEY_PERFORMANCE_DATA;

        if (bUpdate) {
            // look up the new strings to add
            pThisLang = FindLanguage(pFirstLang, szThisLang);
            if (pThisLang == NULL) {
                // try default language if available
                pThisLang = FindLanguage(pFirstLang, DefaultLangTag);
            }
            else if (pThisLang->NameBuffer == NULL || pThisLang->HelpBuffer == NULL) {
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        LDPRFMSG_CORRUPT_INCLUDE_FILE,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(szThisLang),
                        NULL));
                pThisLang = FindLanguage(pFirstLang, DefaultLangTag);
            }
            if (pThisLang == NULL) {
                // try english language if available
                pThisLang = FindLanguage(pFirstLang, DefaultLangId);
            }
            else if (pThisLang->NameBuffer == NULL || pThisLang->HelpBuffer == NULL) {
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        LDPRFMSG_CORRUPT_INCLUDE_FILE,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(szThisLang),
                        NULL));
                pThisLang = FindLanguage(pFirstLang, DefaultLangId);
            }

            if (pThisLang == NULL) {
                // unable to add this language so continue
                lStatus = ERROR_NO_MATCH;
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_WSTR, 3),
                        lStatus,
                        TRACE_WSTR(szThisLang),
                        TRACE_WSTR(DefaultLangTag),
                        TRACE_WSTR(DefaultLangId),
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
            }
            else {
                if (pThisLang->NameBuffer == NULL || pThisLang->HelpBuffer == NULL) {
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_CORRUPT_INCLUDE_FILE, // event,
                            1, __LINE__, 0, 0, 0,
                            1, pThisLang->LangId, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_WARNING),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_UPDATEEACHLANGUAGE,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            LDPRFMSG_CORRUPT_INCLUDE_FILE,
                            TRACE_WSTR(pThisLang->LangId),
                            TRACE_WSTR(szThisLang),
                            NULL));
                    lStatus = LDPRFMSG_CORRUPT_INCLUDE_FILE;
                }
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(szThisLang),
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
            }
        }

        if (lStatus == ERROR_SUCCESS) {
            // get size of counter names
            dwBufferSize = 0;
            __try {
                lStatus = RegQueryValueExW(hKeyThisLang,
                                           CounterNameBuffer,
                                           RESERVED,
                                           & dwValueType,
                                           NULL,
                                           & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                // this means the language is not installed in the system.
                continue;
            }
            dwCounterSize = dwBufferSize;

            // get size of help text
            dwBufferSize = 0;
            __try {
                lStatus = RegQueryValueExW(hKeyThisLang,
                                           HelpNameBuffer,
                                           RESERVED,
                                           & dwValueType,
                                           NULL,
                                           & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                // this means the language is not installed in the system.
                continue;
            }
            dwHelpSize = dwBufferSize;

            // allocate new buffers

            if (bUpdate) {
                dwCounterSize += pThisLang->dwNameBuffSize;
                dwHelpSize    += pThisLang->dwHelpBuffSize;
            }

            pNameBuffer = MemoryAllocate(dwCounterSize);
            pHelpBuffer = MemoryAllocate(dwHelpSize);
            if (pNameBuffer == NULL || pHelpBuffer== NULL) {
                lStatus = ERROR_OUTOFMEMORY;
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        0,
                        ERROR_OUTOFMEMORY,
                        NULL));
                bResult = FALSE;
                goto Cleanup;
            }

            // load current buffers into memory

            // read counter names into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Name"
            dwBufferSize = dwCounterSize;
            __try {
                lStatus = RegQueryValueExW(hKeyThisLang,
                                           CounterNameBuffer,
                                           RESERVED,
                                           & dwValueType,
                                           (LPVOID) pNameBuffer,
                                           & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                // this means the language is not installed in the system.
                continue;
            }

            if (bUpdate) {
                // set pointer to location in buffer where new string should be
                // appended: end of buffer - 1 (second null at end of MULTI_SZ
                pNewName = (LPWSTR) ((PBYTE) pNameBuffer + dwBufferSize - sizeof(WCHAR));

                // adjust buffer length to take into account 2nd null from 1st
                // buffer that has been overwritten
                dwCounterSize -= sizeof(WCHAR);
            }

            // read explain text into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Text..."
            dwBufferSize = dwHelpSize;
            __try {
                lStatus = RegQueryValueExW(hKeyThisLang,
                                           HelpNameBuffer,
                                           RESERVED,
                                           & dwValueType,
                                           (LPVOID) pHelpBuffer,
                                           & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                        2, lStatus, __LINE__, 0, 0,
                        1, szThisLang, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(szThisLang),
                        TRACE_WSTR(Help),
                        NULL));
                bResult = FALSE;
                goto Cleanup;
            }

            if (bUpdate) {
                // set pointer to location in buffer where new string should be
                // appended: end of buffer - 1 (second null at end of MULTI_SZ
                pNewHelp = (LPWSTR) ((PBYTE)pHelpBuffer + dwBufferSize - sizeof(WCHAR));

                // adjust buffer length to take into account 2nd null from 1st
                // buffer that has been overwritten
                dwHelpSize -= sizeof(WCHAR);
            }

            if (bUpdate) {
                // append new strings to end of current strings
                memcpy(pNewHelp, pThisLang->HelpBuffer, pThisLang->dwHelpBuffSize);
                memcpy(pNewName, pThisLang->NameBuffer, pThisLang->dwNameBuffSize);
            }

            if (! CheckNameTable(pNameBuffer, pHelpBuffer, & dwLastCounter, & dwLastHelp, bUpdate)) {
                bResult = FALSE;
                goto Cleanup;
            }

            if (bUpdate) {
                // write to the file thru PerfLib
                dwBufferSize = dwCounterSize;
                __try {
                    lStatus = RegQueryValueExW(hKeyThisLang,
                                               AddCounterNameBuffer,
                                               RESERVED,
                                               & dwValueType,
                                               (LPVOID) pNameBuffer,
                                               & dwBufferSize);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    lStatus = GetExceptionCode();
                }
                if (lStatus != ERROR_SUCCESS) {
                    ReportLoadPerfEvent(
                            EVENTLOG_ERROR_TYPE, // error type
                            (DWORD) LDPRFMSG_UNABLE_UPDATE_COUNTER_STRINGS, // event,
                            2, lStatus, __LINE__, 0, 0,
                            1, pThisLang->LangId, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(AddCounterNameBuffer),
                        NULL));
                    bResult = FALSE;
                    goto Cleanup;
                }
                dwBufferSize = dwHelpSize;
                __try {
                    lStatus = RegQueryValueExW(hKeyThisLang,
                                               AddHelpNameBuffer,
                                               RESERVED,
                                               & dwValueType,
                                               (LPVOID) pHelpBuffer,
                                               & dwBufferSize);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    lStatus = GetExceptionCode();
                }
                if (lStatus != ERROR_SUCCESS) {
                    ReportLoadPerfEvent(
                            EVENTLOG_ERROR_TYPE, // error type
                            (DWORD) LDPRFMSG_UNABLE_UPDATE_HELP_STRINGS, // event,
                            2, lStatus, __LINE__, 0, 0,
                            1, pThisLang->LangId, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(AddHelpNameBuffer),
                        NULL));
                    bResult = FALSE;
                    goto Cleanup;
                }
            }
            MemoryFree(pNameBuffer);
            MemoryFree(pHelpBuffer);
            pNameBuffer = NULL;
            pHelpBuffer = NULL;
        }
        else {
            OUTPUT_MESSAGE(bQuietMode, GetFormatResource (LC_UNABLEOPENLANG), szThisLang);
        }
    }

Cleanup:
    MemoryFree(pNameBuffer);
    MemoryFree(pHelpBuffer);
    MemoryFree(CounterNameBuffer);
    if (! bResult) {
        SetLastError(lStatus);
    }
    else if (! bUpdate) {
        * pdwLastCounter = dwLastCounter;
        * pdwLastHelp    = dwLastHelp;
    }
    return bResult;
}

BOOL
UpdateRegistry(
    BOOL                    bQuietMode,
    DWORD                   dwMode,
    LPWSTR                  lpDriverName,
    LPWSTR                  lpIniFile,
    LPWSTR                  lp009IniFile,
    PLANG_ENTRY             pLanguages,
    PSERVICE_ENTRY          pService,
    PLANGUAGE_LIST_ELEMENT  pFirstLang,
    PSYMBOL_TABLE_ENTRY     pFirstSymbol,
    LPDWORD                 pdwObjectGuidTableSize,
    LPDWORD                 pdwIndexValues
)
/*++
UpdateRegistry
    - checks, and if not busy, sets the "busy" key in the registry
    - Reads in the text and help definitions from the .ini file
    - Reads in the current contents of the HELP and COUNTER names
    - Builds a sorted MULTI_SZ struct containing the new definitions
    - Appends the new MULTI_SZ to the current as read from the registry
    - loads the new MULTI_SZ string into the registry
    - updates the keys in the driver's entry and Perflib's entry in the
        registry (e.g. first, last, etc)
    - deletes the DisablePerformanceCounters value if it's present in 
        order to re-enable the perf counter DLL
    - clears the "busy" key

Arguments
    lpIniFile
        pathname to .ini file conatining definitions
    hKeyMachine
        handle to HKEY_LOCAL_MACHINE in registry on system to
        update counters for.
    lpDriverName
        Name of device driver to load counters for
    pFirstLang
        pointer to first element in language structure list
    pFirstSymbol
        pointer to first element in symbol definition list

Return Value
    TRUE if registry updated successfully
    FALSE if registry not updated
    (This routine will print an error message to stdout if an error
    is encountered).
--*/
{
    HKEY    hDriverPerf    = NULL;
    HKEY    hPerflib       = NULL;
    LPWSTR  lpDriverKeyPath;
    HKEY    hKeyMachine    = NULL;
    DWORD   dwType;
    DWORD   dwSize;
    DWORD   dwFirstDriverCounter;
    DWORD   dwFirstDriverHelp;
    DWORD   dwLastDriverCounter;
    DWORD   dwLastPerflibCounter;
    DWORD   dwLastPerflibHelp;
    DWORD   dwPerflibBaseIndex;
    DWORD   dwLastCounter;
    DWORD   dwLastHelp;
    BOOL    bStatus        = FALSE;
    LONG    lStatus        = ERROR_SUCCESS;
    LPWSTR  lpszObjectList = NULL;
    DWORD   dwObjectList   = 0;
    LPWSTR  mszLangList    = NULL;
    DWORD   dwWaitStatus;
    HANDLE  hLocalMutex    = NULL;
    HRESULT hr;

    SetLastError(ERROR_SUCCESS);
    if (! (dwMode & LODCTR_UPNF_NOINI)) {
        dwObjectList = LoadPerfGetFileSize(lp009IniFile, NULL, TRUE);
        if (dwObjectList == 0xFFFFFFFF) {
            dwObjectList = 0;
        }
    }
    if (dwObjectList < SMALL_BUFFER_SIZE) {
        dwObjectList = SMALL_BUFFER_SIZE;
    }

    // allocate temporary buffers
    dwSize = lstrlenW(DriverPathRoot) + lstrlenW(Slash) + lstrlenW(lpDriverName)
                                      + lstrlenW(Slash) + lstrlenW(Performance) + 1;
    if (dwSize < MAX_PATH) dwSize = MAX_PATH;
    lpDriverKeyPath = MemoryAllocate(dwSize * sizeof(WCHAR));
    lpszObjectList  = MemoryAllocate(dwObjectList * sizeof(WCHAR));
    if (lpDriverKeyPath == NULL || lpszObjectList == NULL) {
        lStatus = ERROR_OUTOFMEMORY;
        goto UpdateRegExit;
    }

    // build driver key path string
    hr = StringCchPrintfW(lpDriverKeyPath, dwSize, L"%ws%ws%ws%ws%ws",
            DriverPathRoot, Slash, lpDriverName, Slash, Performance);

    // check if we need to connect to remote machine
    hKeyMachine = HKEY_LOCAL_MACHINE;

    // open keys to registry
    // open key to driver's performance key
    __try {
        lStatus = RegOpenKeyExW(hKeyMachine, lpDriverKeyPath, RESERVED, KEY_WRITE | KEY_READ, & hDriverPerf);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) lpDriverKeyPath, NULL, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_OPEN_DRIVERPERF1), lpDriverKeyPath);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_OPEN_DRIVERPERF2), lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpIniFile),
                TRACE_WSTR(lpDriverName),
                NULL));
        goto UpdateRegExit;
    }

    // open key to perflib's "root" key
    __try {
        lStatus = RegOpenKeyExW(hKeyMachine, NamesKey, RESERVED, KEY_WRITE | KEY_READ, & hPerflib);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_OPEN_PERFLIB), lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(NamesKey),
                NULL));
        goto UpdateRegExit;
    }

    // get "LastCounter" values from PERFLIB

    dwType               = 0;
    dwLastPerflibCounter = 0;
    dwSize               = sizeof(dwLastPerflibCounter);
    __try {
        lStatus = RegQueryValueExW(hPerflib,
                                   LastCounter,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwLastPerflibCounter,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_READLASTPERFLIB), lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastCounter),
                NULL));
        goto UpdateRegExit;
    }

    // get "LastHelp" value now
    dwType            = 0;
    dwLastPerflibHelp = 0;
    dwSize            = sizeof(dwLastPerflibHelp);
    __try {
       lStatus = RegQueryValueExW(hPerflib,
                                  LastHelp,
                                  RESERVED,
                                  & dwType,
                                  (LPBYTE) & dwLastPerflibHelp,
                                  & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_READLASTPERFLIB), lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastHelp),
                NULL));
        goto UpdateRegExit;
    }

    // get "Base Index" value now
    dwType             = 0;
    dwPerflibBaseIndex = 0;
    dwSize             = sizeof(dwPerflibBaseIndex);
    __try {
        lStatus = RegQueryValueExW(hPerflib,
                                   BaseIndex,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwPerflibBaseIndex,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                2, (LPWSTR) BaseIndex, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource (LC_ERR_READLASTPERFLIB), lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(BaseIndex),
                NULL));
        goto UpdateRegExit;
    }

    // see if this driver's counter names have already been installed
    // by checking to see if LastCounter's value is less than Perflib's
    // Last Counter
    dwType              = 0;
    dwLastDriverCounter = 0;
    dwSize              = sizeof(dwLastDriverCounter);
    __try {
        lStatus = RegQueryValueExW(hDriverPerf,
                                   LastCounter,
                                   RESERVED,
                                   & dwType,
                                   (LPBYTE) & dwLastDriverCounter,
                                   & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus == ERROR_SUCCESS) {
        // if key found, then compare with perflib value and exit this
        // procedure if the driver's last counter is <= to perflib's last
        //
        // if key not found, then continue with installation
        // on the assumption that the counters have not been installed

        if (dwLastDriverCounter <= dwLastPerflibCounter) {
            OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_ALREADY_IN), lpDriverName);
            lStatus = ERROR_ALREADY_EXISTS;
            goto UpdateRegExit;
        }
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UPDATEREGISTRY,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwLastPerflibCounter),
            TRACE_DWORD(dwLastPerflibHelp),
            TRACE_DWORD(dwPerflibBaseIndex),
            NULL));

    // set the "busy" indicator under the PERFLIB key
    dwSize = (lstrlenW(lpDriverName) + 1) * sizeof(WCHAR);
    __try {
        lStatus = RegSetValueExW(hPerflib,
                                 Busy,
                                 RESERVED,
                                 REG_SZ,
                                 (LPBYTE) lpDriverName,
                                 dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource (LC_ERR_UNABLESETBUSY), lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(Busy),
                NULL));
        goto UpdateRegExit;
    }

    dwLastCounter = dwLastPerflibCounter;
    dwLastHelp    = dwLastPerflibHelp;

    // get the list of installed languages on this machine
    bStatus = GetInstalledLanguageList(hPerflib, & mszLangList);
    if (! bStatus) {
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_UPDATELANG), GetLastError());
        lStatus = GetLastError();
        goto UpdateRegExit;
    }
    bStatus = UpdateEachLanguage(bQuietMode,
                                 hPerflib,
                                 mszLangList,
                                 & dwLastCounter,
                                 & dwLastHelp,
                                 pFirstLang,
                                 dwMode,
                                 FALSE);
    if (! bStatus) {
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_UPDATELANG), GetLastError());
        lStatus = GetLastError();
        goto UpdateRegExit;
    }

    // increment (by 2) the last counters so they point to the first
    // unused index after the existing names and then
    // set the first driver counters

    bStatus              = FALSE;
    dwFirstDriverCounter = dwLastCounter + 2;
    dwFirstDriverHelp    = dwLastHelp    + 2;
    if (dwFirstDriverHelp != dwFirstDriverCounter + 1) {
        TRACE((WINPERF_DBG_TRACE_WARNING),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_DWORD(dwPerflibBaseIndex),
                TRACE_DWORD(dwFirstDriverCounter),
                TRACE_DWORD(dwFirstDriverHelp),
                NULL));
        dwFirstDriverHelp = dwFirstDriverCounter + 1;
    }

    if ((dwPerflibBaseIndex < PERFLIB_BASE_INDEX)
                    || (dwFirstDriverCounter < dwPerflibBaseIndex)
                    || (dwFirstDriverHelp < dwPerflibBaseIndex)) {
        // potential CounterIndex/HelpIndex overlap with Base counters,
        //
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                4, dwPerflibBaseIndex, dwFirstDriverCounter, dwFirstDriverHelp, __LINE__,
                1, lpDriverName, NULL, NULL);
        lStatus = ERROR_BADKEY;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_DWORD(dwPerflibBaseIndex),
                TRACE_DWORD(dwFirstDriverCounter),
                TRACE_DWORD(dwFirstDriverHelp),
                NULL));
        goto UpdateRegExit;
    }

    // load .INI file definitions into language tables
    if (dwMode & LODCTR_UPNF_NOINI) {
        PLANGUAGE_LIST_ELEMENT pThisLang     = NULL;
        PLANG_ENTRY            pLangEntry    = NULL;
        PLANG_ENTRY            p009LangEntry = NULL;
        DWORD                  dwErrorCount  = 0;
        DWORD                  dwIndex;
        DWORD                  dwNewIndex;

        for (pThisLang  = pFirstLang; pThisLang != NULL; pThisLang  = pThisLang->pNextLang) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADLANGUAGELISTS,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    ERROR_SUCCESS,
                    TRACE_WSTR(lpDriverName),
                    TRACE_WSTR(pThisLang->LangId),
                    TRACE_DWORD(dwFirstDriverCounter),
                    TRACE_DWORD(dwFirstDriverHelp),
                    NULL));
            for (pLangEntry  = pLanguages; pLangEntry != NULL; pLangEntry  = pLangEntry->pNext) {
                if (lstrcmpiW(pThisLang->LangId, pLangEntry->szLang) == 0) {
                    break;
                }
                else if (lstrcmpiW(pLangEntry->szLang, DefaultLangId) == 0) {
                    p009LangEntry = pLangEntry;
                }
            }
            if (pLangEntry == NULL) {
                pLangEntry = p009LangEntry;
            }
            else if (pLangEntry->lpText == NULL) {
                // no text for selected language, use 009 ones.
                //
                pLangEntry = p009LangEntry;
            }
            if (pLangEntry == NULL) {
                dwErrorCount ++;
                continue;
            }
            else if (pLangEntry->lpText == NULL) {
                dwErrorCount ++;
                continue;
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADLANGUAGELISTS,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    ERROR_SUCCESS,
                    TRACE_WSTR(lpDriverName),
                    TRACE_WSTR(pLangEntry->szLang),
                    TRACE_DWORD(pService->dwFirstCounter),
                    TRACE_DWORD(pService->dwFirstHelp),
                    TRACE_DWORD(pService->dwLastCounter),
                    TRACE_DWORD(pService->dwLastHelp),
                    TRACE_DWORD(pLangEntry->dwLastCounter),
                    TRACE_DWORD(pLangEntry->dwLastHelp),
                    NULL));
            for (dwIndex  = pService->dwFirstCounter; dwIndex <= pService->dwLastHelp; dwIndex ++) {
                if (dwIndex > pLangEntry->dwLastHelp) {
                    dwErrorCount ++;
                    break;
                }
                dwNewIndex = dwIndex + dwFirstDriverCounter
                           - pService->dwFirstCounter;
                dwType     = (((dwIndex - pService->dwFirstCounter) % 2) == 0)
                           ? (TYPE_NAME) : (TYPE_HELP);
                if (pLangEntry->lpText[dwIndex] != NULL) {
                    __try {
                        TRACE((WINPERF_DBG_TRACE_INFO),
                              (& LoadPerfGuid,
                                __LINE__,
                                LOADPERF_LOADLANGUAGELISTS,
                                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_WSTR, 3),
                                ERROR_SUCCESS,
                                TRACE_WSTR(lpDriverName),
                                TRACE_WSTR(pThisLang->LangId),
                                TRACE_WSTR(pLangEntry->lpText[dwIndex]),
                                TRACE_DWORD(dwIndex),
                                TRACE_DWORD(dwNewIndex),
                                TRACE_DWORD(dwType),
                                NULL));
                        bStatus = AddEntryToLanguage(pThisLang,
                                                     NULL,
                                                     pLangEntry->lpText[dwIndex],
                                                     0,
                                                     NULL,
                                                     0,
                                                     dwType,
                                                     dwNewIndex,
                                                     0);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                        TRACE((WINPERF_DBG_TRACE_ERROR),
                              (& LoadPerfGuid,
                                __LINE__,
                                LOADPERF_UPDATEREGISTRY,
                                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                                lStatus,
                                TRACE_WSTR(lpDriverName),
                                TRACE_WSTR(pThisLang->LangId),
                                TRACE_DWORD(dwType),
                                TRACE_DWORD(dwIndex),
                                TRACE_DWORD(dwNewIndex),
                                NULL));
                        bStatus = FALSE;
                        SetLastError(lStatus);
                    }
                    if (! bStatus) {
                        OUTPUT_MESSAGE(bQuietMode,
                                       GetFormatResource(LC_ERRADDTOLANG),
                                       pLangEntry->lpText[dwIndex],
                                       pThisLang->LangId,
                                       GetLastError());
                        lStatus = GetLastError();
                        dwErrorCount ++;
                    }
                }
                else {
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_LOADLANGUAGELISTS,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            ERROR_SUCCESS,
                            TRACE_WSTR(lpDriverName),
                            TRACE_WSTR(pThisLang->LangId),
                            TRACE_DWORD(dwIndex),
                            TRACE_DWORD(dwNewIndex),
                            TRACE_DWORD(dwType),
                            NULL));
                }
            }
        }

        bStatus = (dwErrorCount == 0) ? (TRUE) : (FALSE);
        if (! bStatus) {
            goto UpdateRegExit;
        }
    }
    else {
        bStatus = LoadLanguageLists(bQuietMode,
                                    lpIniFile,
                                    lpDriverName,
                                    dwMode,
                                    dwFirstDriverCounter,
                                    dwFirstDriverHelp,
                                    pFirstSymbol,
                                    pFirstLang);
        if (! bStatus) {
            // error message is displayed by LoadLanguageLists so just abort
            // error is in GetLastError already
            lStatus = GetLastError();
            goto UpdateRegExit;
        }
    }

    if (dwMode & LODCTR_UPNF_NOINI) {
        WCHAR szDigits[32];
        DWORD dwObjectId;

        for (dwObjectId = 0; dwObjectId < pService->dwNumObjects; dwObjectId ++) {
            ZeroMemory(szDigits, sizeof(WCHAR) * 32);
            _ultow((dwFirstDriverCounter + pService->dwObjects[dwObjectId]), szDigits,
                   10);
            if (dwObjectId > 0) {
                hr = StringCchCatW(lpszObjectList, dwObjectList, BlankString);
                hr = StringCchCatW(lpszObjectList, dwObjectList, szDigits);
            }
            else {
                hr = StringCchCopyW(lpszObjectList, dwObjectList, szDigits);
            }
        }
    }
    else {
        bStatus = CreateObjectList(lp009IniFile,
                                   dwFirstDriverCounter,
                                   pFirstSymbol,
                                   lpszObjectList,
                                   dwObjectList,
                                   pdwObjectGuidTableSize);
        if (! bStatus) {
            // error message is displayed by CreateObjectList so just abort
            // error is in GetLastError already
            lStatus = GetLastError();
            goto UpdateRegExit;
        }
    }

    // all the symbols and definitions have been loaded into internal
    // tables. so now they need to be sorted and merged into a multiSZ string
    // this routine also updates the "last" counters

    bStatus = SortLanguageTables(pFirstLang, & dwLastCounter, & dwLastHelp);
    if (! bStatus) {
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_UNABLESORTTABLES), GetLastError());
        lStatus = GetLastError();
        goto UpdateRegExit;
    }

    if (dwLastCounter < dwLastPerflibCounter || dwLastHelp < dwLastPerflibHelp) {
        // potential CounterIndex/HelpIndex overlap with Base counters,
        //
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                4, dwLastPerflibCounter, dwLastCounter, dwLastHelp, __LINE__,
                1 , lpDriverName, NULL, NULL);
        bStatus = FALSE;
        lStatus = ERROR_BADKEY;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_DWORD(dwLastPerflibCounter),
                TRACE_DWORD(dwLastPerflibHelp),
                TRACE_DWORD(dwLastCounter),
                TRACE_DWORD(dwLastHelp),
                NULL));
        goto UpdateRegExit;
    }

    bStatus = UpdateEachLanguage(bQuietMode,
                                 hPerflib,
                                 mszLangList,
                                 & dwLastCounter,
                                 & dwLastHelp,
                                 pFirstLang,
                                 dwMode,
                                 TRUE);
    if (! bStatus) {
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_ERR_UPDATELANG), GetLastError());
        lStatus = GetLastError();
        goto UpdateRegExit;
    }

    bStatus              = FALSE;
    dwLastPerflibCounter = dwLastCounter;
    dwLastPerflibHelp    = dwLastHelp;

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UPDATEREGISTRY,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwFirstDriverCounter),
            TRACE_DWORD(dwFirstDriverHelp),
            TRACE_DWORD(dwLastPerflibCounter),
            TRACE_DWORD(dwLastPerflibHelp),
            NULL));

    if (dwLastCounter < dwFirstDriverCounter) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_CORRUPT_INDEX_RANGE, // event,
                3, dwFirstDriverCounter, dwLastCounter, __LINE__, 0,
                2, (LPWSTR) Counters, (LPWSTR) lpDriverKeyPath, NULL);
        lStatus = ERROR_BADKEY;
        goto UpdateRegExit;
    }
    if (dwLastHelp < dwFirstDriverHelp) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_CORRUPT_INDEX_RANGE, // event,
                3, dwFirstDriverHelp, dwLastHelp, __LINE__, 0,
                2, (LPWSTR) Help, (LPWSTR) lpDriverKeyPath, NULL);
        lStatus = ERROR_BADKEY;
        goto UpdateRegExit;
    }

    // update last counters for driver and perflib
    // perflib...
    __try {
        lStatus = RegSetValueExW(hPerflib,
                                 LastCounter,
                                 RESERVED,
                                 REG_DWORD,
                                 (LPBYTE) & dwLastPerflibCounter,
                                 sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwLastPerflibCounter, __LINE__, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource (LC_UNABLESETVALUE), LastCounter, szPerflib);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastCounter),
                TRACE_DWORD(dwLastPerflibCounter),
                NULL));
    }

    __try {
        lStatus = RegSetValueExW(hPerflib,
                                 LastHelp,
                                 RESERVED,
                                 REG_DWORD,
                                 (LPBYTE) & dwLastPerflibHelp,
                                 sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwLastPerflibHelp, __LINE__, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource (LC_UNABLESETVALUE), LastHelp, szPerflib);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastHelp),
                TRACE_DWORD(dwLastPerflibHelp),
                NULL));
    }

    // and the driver
    __try {
        lStatus = RegSetValueExW(hDriverPerf,
                                 LastCounter,
                                 RESERVED,
                                 REG_DWORD,
                                 (LPBYTE) & dwLastPerflibCounter,
                                 sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwLastPerflibCounter, __LINE__, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_UNABLESETVALUE), LastCounter, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastCounter),
                TRACE_DWORD(dwLastPerflibCounter),
                NULL));
    }

    __try {
        lStatus = RegSetValueExW(hDriverPerf,
                                 LastHelp,
                                 RESERVED,
                                 REG_DWORD,
                                 (LPBYTE) & dwLastPerflibHelp,
                                 sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwLastPerflibHelp, __LINE__, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_UNABLESETVALUE), LastHelp, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastHelp),
                TRACE_DWORD(dwLastPerflibHelp),
                NULL));
    }

    __try {
        lStatus = RegSetValueExW(hDriverPerf,
                                 FirstCounter,
                                 RESERVED,
                                 REG_DWORD,
                                 (LPBYTE) & dwFirstDriverCounter,
                                 sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwFirstDriverCounter, __LINE__, 0,
                2, (LPWSTR) FirstCounter, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_UNABLESETVALUE), FirstCounter, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(FirstCounter),
                TRACE_DWORD(dwFirstDriverCounter),
                NULL));
    }

    __try {
        lStatus = RegSetValueExW(hDriverPerf,
                                 FirstHelp,
                                 RESERVED,
                                 REG_DWORD,
                                 (LPBYTE) & dwFirstDriverHelp,
                                 sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwFirstDriverHelp, __LINE__, 0,
                2, (LPWSTR) FirstHelp, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_UNABLESETVALUE), FirstHelp, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(FirstHelp),
                TRACE_DWORD(dwFirstDriverHelp),
                NULL));
    }

    if (*lpszObjectList != L'\0') {
        __try {
            lStatus = RegSetValueExW(hDriverPerf,
                                     szObjectList,
                                     RESERVED,
                                     REG_SZ,
                                     (LPBYTE) lpszObjectList,
                                     (lstrlenW(lpszObjectList) + 1) * sizeof (WCHAR));
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
        if (lStatus != ERROR_SUCCESS) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                    2, lStatus, __LINE__, 0, 0,
                    2, (LPWSTR) szObjectList, (LPWSTR) lpDriverKeyPath, NULL);
            OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_UNABLESETVALUE), szObjectList, lpDriverName);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEREGISTRY,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    lStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_WSTR(szObjectList),
                    NULL));
        }
    }

    bStatus           = TRUE;
    pdwIndexValues[0] = dwFirstDriverCounter;   // first Counter
    pdwIndexValues[1] = dwLastPerflibCounter;   // last Counter
    pdwIndexValues[2] = dwFirstDriverHelp;      // first Help
    pdwIndexValues[3] = dwLastPerflibHelp;      // last Help

    // remove "DisablePerformanceCounter" value so perf counters are re-enabled.
    lStatus = RegDeleteValueW(hDriverPerf, DisablePerformanceCounters);

UpdateRegExit:
    if (hPerflib != NULL && hPerflib != INVALID_HANDLE_VALUE) {
        DWORD lTmpStatus = ERROR_SUCCESS;

        __try {
            lTmpStatus = RegDeleteValueW(hPerflib, Busy);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lTmpStatus = GetExceptionCode();
        }
        if (lTmpStatus != ERROR_SUCCESS) {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEREGISTRY,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    lTmpStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_WSTR(Busy),
                    NULL));
        }
    }

    // MemoryFree temporary buffers
    // free any guid string buffers here
    // TODO: add this code
    MemoryFree(lpDriverKeyPath);
    MemoryFree(lpszObjectList);
    MemoryFree(mszLangList);
    if (hDriverPerf != NULL && hDriverPerf != INVALID_HANDLE_VALUE) RegCloseKey(hDriverPerf);
    if (hPerflib    != NULL && hPerflib    != INVALID_HANDLE_VALUE) RegCloseKey(hPerflib);
    if (hKeyMachine != NULL && hKeyMachine != HKEY_LOCAL_MACHINE)   RegCloseKey(hKeyMachine);
    if (! bStatus) SetLastError(lStatus);

    return bStatus;
}

DWORD
LoadPerfInstallPerfDll(
    DWORD          dwMode,
    LPCWSTR        szComputerName,
    LPWSTR         lpDriverName,
    LPCWSTR        lpIniFile,
    PLANG_ENTRY    pLanguages,
    PSERVICE_ENTRY pService,
    ULONG_PTR      dwFlags
)
{
    LPWSTR                 lp009IniFile          = NULL;
    LPWSTR                 lpInfPath             = NULL;
    DWORD                  dwObjectGuidTableSize = 0;
    DWORD                  dwObjectIndex;
    PLANGUAGE_LIST_ELEMENT LangList              = NULL;
    PLANGUAGE_LIST_ELEMENT pThisElem             = NULL;
    PSYMBOL_TABLE_ENTRY    SymbolTable           = NULL;
    DWORD                  ErrorCode             = ERROR_SUCCESS;
    DWORD                  dwIndexValues[4]      = {0,0,0,0};
    HKEY                   hKeyMachine           = HKEY_LOCAL_MACHINE;
    HKEY                   hKeyDriver            = NULL;
    BOOL                   bResult               = TRUE;
    BOOL                   bQuietMode            = (BOOL) ((dwFlags & LOADPERF_FLAGS_DISPLAY_USER_MSGS) == 0);
    LPWSTR                 szServiceName         = NULL;
    LPWSTR                 szServiceDisplayName  = NULL;
    DWORD                  dwSize;
    HRESULT                hr;

    if (lpDriverName == NULL) {
        ErrorCode = ERROR_BAD_DRIVER;
        goto EndOfMain;
    }
    else if (* lpDriverName == L'\0') {
        ErrorCode = ERROR_BAD_DRIVER;
        goto EndOfMain;
    }
    else if (dwMode & LODCTR_UPNF_NOINI) {
        if (pLanguages == NULL || pService == NULL) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto EndOfMain;
        }
    }
    else if (dwMode & LODCTR_UPNF_NOBACKUP) {
        if (lpIniFile == NULL) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto EndOfMain;
        }
        else if (* lpIniFile == L'\0') {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto EndOfMain;
        }
        else {
            lp009IniFile = MemoryAllocate((lstrlenW(lpIniFile) + 1) * sizeof(WCHAR));
            if (lp009IniFile == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto EndOfMain;
            }
            hr = StringCchCopyW(lp009IniFile, lstrlenW(lpIniFile) + 1, lpIniFile);
        }
    }
    else if (lpIniFile != NULL && lpIniFile[0] != L'\0') {
        lpInfPath = LoadPerfGetInfPath();
        if (lpInfPath == NULL) {
            ErrorCode = GetLastError();
            goto EndOfMain;
        }
        dwSize       = lstrlenW(lpInfPath) + lstrlenW(DefaultLangId) + lstrlenW(Slash)
                     + lstrlenW(lpDriverName) + lstrlenW(Slash) + lstrlenW(lpIniFile) + 1;
        if (dwSize < MAX_PATH) dwSize = MAX_PATH;
        lp009IniFile = MemoryAllocate(dwSize * sizeof(WCHAR));
        if (lp009IniFile == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto EndOfMain;
        }
        hr = StringCchPrintfW(lp009IniFile, dwSize, L"%ws%ws%ws%ws%ws%ws",
                lpInfPath, DefaultLangId, Slash, lpDriverName, Slash, lpIniFile);
    }
    else { // lpIniFile == NULL
        OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_NO_INIFILE), lpIniFile);
        ErrorCode = ERROR_OPEN_FAILED;
        goto EndOfMain;
    }

    //
    // Set the table size to the max first after we have passed the above
    //
    dwObjectGuidTableSize = MAX_GUID_TABLE_SIZE;

    hKeyMachine = HKEY_LOCAL_MACHINE;
    dwSize = lstrlenW(DriverPathRoot) + lstrlenW(Slash) + lstrlenW(lpDriverName) + 1;
    if (dwSize < MAX_PATH) dwSize = MAX_PATH;
    szServiceName = MemoryAllocate(2 * dwSize * sizeof(WCHAR));
    if (szServiceName == NULL) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto EndOfMain;
    }
    szServiceDisplayName = szServiceName + dwSize;
    hr = StringCchPrintfW(szServiceName, dwSize, L"%ws%ws%ws", DriverPathRoot, Slash, lpDriverName);
    ErrorCode = RegOpenKeyExW(hKeyMachine, szServiceName, RESERVED, KEY_READ | KEY_WRITE, & hKeyDriver);
    if (ErrorCode == ERROR_SUCCESS) {
        DWORD dwType       = 0;
        DWORD dwBufferSize = dwSize * sizeof(WCHAR);
        __try {
            ErrorCode = RegQueryValueExW(hKeyDriver,
                                         szDisplayName,
                                         RESERVED,
                                         & dwType,
                                         (LPBYTE) szServiceDisplayName,
                                         & dwBufferSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            ErrorCode = GetExceptionCode();
        }
    }
    if (ErrorCode != ERROR_SUCCESS) {
        hr = StringCchCopyW(szServiceDisplayName, dwSize, lpDriverName);
    }

    if ((! (dwMode & LODCTR_UPNF_REPAIR)) && (hKeyDriver != NULL)) {
        HKEY hKeyDriverPerf = NULL;

        __try {
            ErrorCode = RegOpenKeyExW(hKeyDriver, Performance, RESERVED, KEY_READ | KEY_WRITE, & hKeyDriverPerf);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            ErrorCode = GetExceptionCode();
        }
        if (ErrorCode == ERROR_SUCCESS) {
            LPWSTR szIniName = (LPWSTR) lpIniFile;

            if (dwMode & LODCTR_UPNF_NOBACKUP) {
                for (szIniName = (LPWSTR) lpIniFile + lstrlenW(lpIniFile) - 1;
                         szIniName != NULL && szIniName != lpIniFile
                                           && (* szIniName) != cNull
                                           && (* szIniName) != cBackslash;
                         szIniName --);
                if (szIniName != NULL && (* szIniName) == cBackslash) {
                    szIniName ++;
                }
                else {
                    szIniName = (LPWSTR) lpIniFile;
                }
            }
            __try {
                ErrorCode = RegSetValueExW(hKeyDriverPerf,
                                           szPerfIniPath,
                                           RESERVED,
                                           REG_SZ,
                                           (LPBYTE) szIniName,
                                           sizeof(WCHAR) * lstrlenW(lpIniFile));
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                ErrorCode = GetExceptionCode();
            }
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_INSTALLPERFDLL,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                              | ARG_DEF(ARG_TYPE_WSTR, 3),
                    ErrorCode,
                    TRACE_WSTR(lpIniFile),
                    TRACE_WSTR(lp009IniFile),
                    TRACE_WSTR(szIniName),
                    NULL));
            RegCloseKey(hKeyDriverPerf);
        }
    }
    if (hKeyDriver != NULL && hKeyDriver != HKEY_LOCAL_MACHINE) {
        RegCloseKey(hKeyDriver);
    }
    if (hKeyMachine != NULL && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey(hKeyMachine);
    }
    ErrorCode = ERROR_SUCCESS;

    if (dwMode & LODCTR_UPNF_NOINI) {
        PLANG_ENTRY pThisLang = pLanguages;

        while (pThisLang != NULL) {
            // This is to build LangList. UpdateRegistry() takes LangList as a parameter and uses it.
            // Memory will be freed at the end of LoadPerfInstallPerfDll().
            //
            pThisElem = MemoryAllocate(sizeof(LANGUAGE_LIST_ELEMENT)
                                       + sizeof(WCHAR) * (lstrlenW(pThisLang->szLang) + 1));
            if (pThisElem == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto EndOfMain;
            }
            pThisElem->pNextLang      = LangList;
            LangList                  = pThisElem;
            pThisElem->LangId         = (LPWSTR)
                    (((LPBYTE) pThisElem) + sizeof(LANGUAGE_LIST_ELEMENT));
            hr = StringCchCopyW(pThisElem->LangId, lstrlenW(pThisLang->szLang) + 1, pThisLang->szLang);
            pThisElem->dwLangId       = LoadPerfGetLCIDFromString(pThisElem->LangId);
            pThisElem->pFirstName     = NULL;
            pThisElem->pThisName      = NULL;
            pThisElem->dwNumElements  = 0;
            pThisElem->NameBuffer     = NULL;
            pThisElem->HelpBuffer     = NULL;
            pThisElem->dwNameBuffSize = 0;
            pThisElem->dwHelpBuffSize = 0;
            pThisLang                 = pThisLang->pNext;
        }
    }
    else {
        bResult = BuildLanguageTables(dwMode, (LPWSTR) lpIniFile, lpDriverName, & LangList);
        dwSize  = bResult ? 1 : 0;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_INSTALLPERFDLL,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwSize),
                NULL));
        if (! bResult) {
            OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_LANGLIST_ERR), lpIniFile);
            ErrorCode = GetLastError();
            goto EndOfMain;
        }

        bResult = LoadIncludeFile(bQuietMode, dwMode, (LPWSTR) lp009IniFile, lpDriverName, & SymbolTable);
        dwSize  = bResult ? 1 : 0;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_INSTALLPERFDLL,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lp009IniFile),
                TRACE_DWORD(dwSize),
                NULL));
        if (! bResult) {
            // open errors displayed in routine
            ErrorCode = GetLastError();
            goto EndOfMain;
        }
    }

    if (LangList != NULL) {
        bResult = UpdateRegistry(bQuietMode,
                                 dwMode,
                                 lpDriverName,
                                 (LPWSTR) lpIniFile,
                                 lp009IniFile,
                                 pLanguages,
                                 pService,
                                 LangList,
                                 SymbolTable,
                                 & dwObjectGuidTableSize,
                                 (LPDWORD) dwIndexValues);
        dwSize  = bResult ? 1 : 0;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADINCLUDEFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwSize),
                NULL));
        if (! bResult) {
            ErrorCode = GetLastError();
            goto EndOfMain;
        }
    }
    else {
        bResult   = FALSE;
        ErrorCode = ERROR_INVALID_DATA;
        goto EndOfMain;
    }

    LodctrSetSericeAsTrusted(lp009IniFile, NULL, lpDriverName);

    // signal WMI with this change, ignore WMI return error.
    LoadPerfSignalWmiWithNewData (WMI_LODCTR_EVENT);

EndOfMain:
    if ((dwMode & LODCTR_UPNF_REPAIR) == 0) {
        if (ErrorCode != ERROR_SUCCESS) {
            if (ErrorCode == ERROR_ALREADY_EXISTS) {
                ReportLoadPerfEvent(
                        EVENTLOG_INFORMATION_TYPE, // error type
                        (DWORD) LDPRFMSG_ALREADY_EXIST, // event,
                        1, __LINE__, 0, 0, 0,
                        2, (LPWSTR) lpDriverName, (LPWSTR) szServiceDisplayName, NULL);
                ErrorCode = ERROR_SUCCESS;
            }
            else if (lpDriverName != NULL) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_LOAD_FAILURE, // event,
                        2, ErrorCode, __LINE__, 0, 0,
                        2, (LPWSTR) lpDriverName, (szServiceDisplayName != NULL) ? (szServiceDisplayName) : (lpDriverName), NULL);
            }
            else if (lpIniFile != NULL) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_LOAD_FAILURE, // event,
                        2, ErrorCode, __LINE__, 0, 0,
                        2, (LPWSTR) lpIniFile, (LPWSTR) lpIniFile, NULL);
            }
            else {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_LOAD_FAILURE, // event,
                        2, ErrorCode, __LINE__, 0, 0,
                        0, NULL, NULL, NULL);
            }
        }
        else {
            // log success message
            ReportLoadPerfEvent(
                    EVENTLOG_INFORMATION_TYPE,  // error type
                    (DWORD) LDPRFMSG_LOAD_SUCCESS, // event,
                    4, dwIndexValues[0], dwIndexValues[1], dwIndexValues[2], dwIndexValues[3],
                    2, (LPWSTR) lpDriverName, (LPWSTR) szServiceDisplayName, NULL);
        }
    }
    else if (ErrorCode != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_LOAD_FAILURE, // event,
                2, ErrorCode, __LINE__, 0, 0,
                1, (LPWSTR) lpDriverName, (szServiceDisplayName != NULL) ? (szServiceDisplayName) : (lpDriverName), NULL);
    }
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_INSTALLPERFDLL,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ErrorCode,
            TRACE_WSTR(lpDriverName),
            NULL));
    while (LangList != NULL) {
        PLANGUAGE_LIST_ELEMENT pTmpLang  = LangList;
        PNAME_ENTRY            pThisName = pTmpLang->pFirstName;

        while (pThisName != NULL) {
            PNAME_ENTRY pTmpName = pThisName;
            pThisName = pTmpName->pNext;
            MemoryFree(pTmpName);
        }
        MemoryFree(pTmpLang->NameBuffer);
        MemoryFree(pTmpLang->HelpBuffer);

        LangList = LangList->pNextLang;
        MemoryFree(pTmpLang);
    }
    while (SymbolTable != NULL) {
        PSYMBOL_TABLE_ENTRY pThisSym = SymbolTable;
        SymbolTable = pThisSym->pNext;
        MemoryFree(pThisSym->SymbolName);
        MemoryFree(pThisSym);
    }

    MemoryFree(lp009IniFile);
    MemoryFree(szServiceName);
    return (ErrorCode);
}

LOADPERF_FUNCTION
InstallPerfDllW(
    IN  LPCWSTR   szComputerName,
    IN  LPCWSTR   lpIniFile,
    IN  ULONG_PTR dwFlags
)
{
    DWORD  lStatus      = ERROR_SUCCESS;
    LPWSTR szIniName    = NULL;
    LPWSTR szDriverName = NULL;
    DWORD  dwMode       = 0;

    DBG_UNREFERENCED_PARAMETER(szComputerName);

    WinPerfStartTrace(NULL);

    if (LoadPerfGrabMutex() == FALSE) {
        return GetLastError();
    }

    if (lpIniFile == NULL) {
        lStatus = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            DWORD dwName = lstrlenW(lpIniFile);
            if (dwName == 0) lStatus = ERROR_INVALID_PARAMETER;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            lStatus = ERROR_INVALID_PARAMETER;
        }
    }

    if (lStatus == ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_INSTALLPERFDLL,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_SUCCESS,
                TRACE_WSTR(lpIniFile),
                NULL));
#if 0
        if (LoadPerfBackupIniFile(lpIniFile, NULL, & szIniName, & szDriverName, TRUE) == FALSE) {
            dwMode |= LODCTR_UPNF_NOBACKUP;
            MemoryFree(szIniName);
            szIniName = (LPWSTR) lpIniFile;
        }
#else
        // ignore LoadPerfBackupIniFile return code and use input .INI and .H files instead.
        //
        LoadPerfBackupIniFile(lpIniFile, NULL, & szIniName, & szDriverName, TRUE);
        dwMode |= LODCTR_UPNF_NOBACKUP;
        MemoryFree(szIniName);
        szIniName = (LPWSTR) lpIniFile;
#endif

        // Ignore szComputerName parameter. LOADPERF can only update local performance registry.
        // No remote installation support.
        //
        lStatus = LoadPerfInstallPerfDll(dwMode, NULL, szDriverName, szIniName, NULL, NULL, dwFlags);

        if (szIniName != lpIniFile) MemoryFree(szIniName);
        MemoryFree(szDriverName);
    }
    ReleaseMutex(hLoadPerfMutex);
    return lStatus;
}

LOADPERF_FUNCTION
InstallPerfDllA(
    IN  LPCSTR    szComputerName,
    IN  LPCSTR    szIniFile,
    IN  ULONG_PTR dwFlags
)
{
    LPWSTR  lpWideFileName     = NULL;
    DWORD   lReturn            = ERROR_SUCCESS;

    DBG_UNREFERENCED_PARAMETER(szComputerName);

    if (szIniFile != NULL) {
        __try {
            lpWideFileName = LoadPerfMultiByteToWideChar(CP_ACP, (LPSTR) szIniFile);
            if (lpWideFileName == NULL) {
                lReturn = ERROR_OUTOFMEMORY;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            lReturn = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    if (lReturn == ERROR_SUCCESS) {
        // Ignore szComputerName parameter. LOADPERF can only update local performance registry.
        // No remote installation support.
        //
        lReturn = InstallPerfDllW(NULL, lpWideFileName, dwFlags);
    }
    MemoryFree(lpWideFileName);
    return lReturn;
}

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW(
    IN  LPWSTR lpCommandLine,
    IN  BOOL   bQuietMode
)
/*++
LoadPerfCounterTexStringsW
    loads the perf counter strings into the registry and updates
    the perf counter text registry values

Arguments
    command line string in the following format:

    "/?"                    displays the usage text
    "file.ini"              loads the perf strings found in file.ini
    "\\machine file.ini"    loads the perf strings found onto machine

ReturnValue
    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.
--*/
{
    LPWSTR     lpIniFile = NULL;
    DWORD      ErrorCode = ERROR_SUCCESS;
    ULONG_PTR  dwFlags   = 0;

    WinPerfStartTrace(NULL);

    if (lpCommandLine == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            DWORD dwSize = lstrlenW(lpCommandLine);
            if (dwSize == 0) ErrorCode = ERROR_INVALID_PARAMETER;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            ErrorCode = ERROR_INVALID_PARAMETER;
        }
    }
    if (ErrorCode != ERROR_SUCCESS) goto Cleanup;

    dwFlags   |= (bQuietMode ? 0 : LOADPERF_FLAGS_DISPLAY_USER_MSGS);
    lpIniFile  = MemoryAllocate(MAX_PATH * sizeof(WCHAR));
    if (lpIniFile == NULL) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    // init last error value
    SetLastError(ERROR_SUCCESS);

    // read command line to determine what to do
    if (GetFileFromCommandLine(lpCommandLine, & lpIniFile, MAX_PATH, & dwFlags)) {
        dwFlags |= LOADPERF_FLAGS_LOAD_REGISTRY_ONLY; // don't do mof's even if they want

        // call installation function
        // LOADPERF can only update local performance registry. No remote installation support.
        //
        ErrorCode = InstallPerfDllW(NULL, lpIniFile, dwFlags);
    }
    else {
        DWORD dwError = GetLastError();

        if (dwError == ERROR_OPEN_FAILED) {
            OUTPUT_MESSAGE(bQuietMode, GetFormatResource(LC_NO_INIFILE), lpIniFile);
        }
        else {
            //Incorrect Command Format
            // display command line usage
            if (! bQuietMode) {
                DisplayCommandHelp(LC_FIRST_CMD_HELP, LC_LAST_CMD_HELP);
            }
        }
        ErrorCode = ERROR_INVALID_PARAMETER;
    }

Cleanup:
    MemoryFree(lpIniFile);
    return (ErrorCode);
}

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA(
    IN  LPSTR lpAnsiCommandLine,
    IN  BOOL  bQuietMode
)
{
    LPWSTR  lpWideCommandLine = NULL;
    DWORD   lReturn           = ERROR_SUCCESS;

    if (lpAnsiCommandLine == NULL) {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            DWORD dwSize = lstrlenA(lpAnsiCommandLine);
            if (dwSize == 0) {
                lReturn = ERROR_INVALID_PARAMETER;
            }
            else {
                lpWideCommandLine = LoadPerfMultiByteToWideChar(CP_ACP, lpAnsiCommandLine);
                if (lpWideCommandLine == NULL) lReturn = ERROR_OUTOFMEMORY;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            lReturn = ERROR_INVALID_PARAMETER;
        }
    }
    if (lReturn == ERROR_SUCCESS) {
        lReturn = LoadPerfCounterTextStringsW(lpWideCommandLine, bQuietMode);
    }
    MemoryFree(lpWideCommandLine);
    return lReturn;
}

LOADPERF_FUNCTION
UpdatePerfNameFilesX(
    LPCWSTR     szNewCtrFilePath,   // data file with new base counter strings
    LPCWSTR     szNewHlpFilePath,   // data file with new base counter strings
    LPWSTR      szLanguageID,       // Lang ID to update
    ULONG_PTR   dwFlags             // flags
)
{
    DWORD     dwReturn        = ERROR_SUCCESS;
    LPWSTR    szCtrNameIn     = NULL;
    LPWSTR    szHlpNameIn     = NULL;
    BOOL      bAllocCtrString = FALSE;
    LPWSTR    szNewCtrStrings = NULL;
    LPWSTR    szNewHlpStrings = NULL;
    LPWSTR    szNewCtrMSZ     = NULL;
    LPWSTR    szNewHlpMSZ     = NULL;
    DWORD     dwLength        = 0;
    LPWSTR  * pszNewNameTable = NULL;
    LPWSTR  * pszOldNameTable = NULL;
    LPWSTR    lpThisName;
    LPWSTR    szThisCtrString = NULL;
    LPWSTR    szThisHlpString = NULL;
    LPWSTR    szLangSection   = NULL;
    DWORD     dwOldLastEntry  = 0;
    DWORD     dwNewLastEntry  = 0;
    DWORD     dwStringSize;
    DWORD     dwHlpFileSize   = 0;
    DWORD     dwCtrFileSize   = 0;
    DWORD     dwThisCounter;
    DWORD     dwSize;
    DWORD     dwLastBaseValue = 0;
    DWORD     dwType;
    DWORD     dwIndex;
    HANDLE    hCtrFileIn      = INVALID_HANDLE_VALUE;
    HANDLE    hCtrFileMap     = NULL;
    HANDLE    hHlpFileIn      = INVALID_HANDLE_VALUE;
    HANDLE    hHlpFileMap     = NULL;
    HKEY      hKeyPerflib;
    HRESULT   hr;

    WinPerfStartTrace(NULL);
    if (LoadPerfGrabMutex() == FALSE) {
        return GetLastError();
    }
    if ((! (dwFlags & LODCTR_UPNF_RESTORE)) && (! (dwFlags & LODCTR_UPNF_REPAIR))) {
        if (LoadPerfBackupIniFile(szNewCtrFilePath, szLanguageID, NULL, NULL, FALSE) == FALSE) {
            dwReturn = ERROR_INVALID_PARAMETER;
        }
        if (LoadPerfBackupIniFile(szNewHlpFilePath, szLanguageID, NULL, NULL, FALSE) == FALSE) {
            dwReturn = ERROR_INVALID_PARAMETER;
        }
    }

    if (szNewCtrFilePath == NULL) dwReturn = ERROR_INVALID_PARAMETER;
    if ((szNewHlpFilePath == NULL) && !(dwFlags & LODCTR_UPNF_RESTORE)) dwReturn = ERROR_INVALID_PARAMETER;
    if (szLanguageID == NULL) dwReturn = ERROR_INVALID_PARAMETER;

    if (dwReturn == ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_SUCCESS,
                TRACE_WSTR(szNewCtrFilePath),
                TRACE_WSTR(szLanguageID),
                NULL));
    }

    if ((dwReturn == ERROR_SUCCESS) && ! (dwFlags & LODCTR_UPNF_RESTORE)) {
        if (dwFlags & LODCTR_UPNF_REPAIR) {
            dwLength = lstrlenW(szNewCtrFilePath);
        }
        else {
            // save the original files, unless it's a restoration
            MakeBackupCopyOfLanguageFiles(szLanguageID);
            dwLength = lstrlenW(szNewCtrFilePath);
            if (dwLength > 0) dwLength = lstrlenW(szNewHlpFilePath);
        }
    }
    else {
        dwLength = 0;
        SetLastError(dwReturn);
    }

    if (dwLength > 0) {
        // create input filenames
        dwSize      = lstrlenW(szNewCtrFilePath) + lstrlenW(szNewHlpFilePath) + 1;
        if (dwSize < MAX_PATH) dwSize = MAX_PATH;

        szCtrNameIn = MemoryAllocate(dwSize * sizeof(WCHAR));
        szHlpNameIn = MemoryAllocate(dwSize * sizeof(WCHAR));
        if (szCtrNameIn != NULL && szHlpNameIn != NULL) {
            if (! (dwFlags & LODCTR_UPNF_REPAIR)) {
                DWORD dwTmp = dwSize;
                dwReturn    = ERROR_SUCCESS;
                dwLength    = ExpandEnvironmentStringsW(szNewCtrFilePath, szCtrNameIn, dwSize);
                while (dwReturn == ERROR_SUCCESS && dwLength > dwSize) {
                    dwSize = dwLength;
                    MemoryFree(szCtrNameIn);
                    szCtrNameIn = MemoryAllocate(dwLength * sizeof(WCHAR));
                    if (szCtrNameIn == NULL) {
                        dwReturn = ERROR_OUTOFMEMORY;
                    }
                    else {
                        dwLength = ExpandEnvironmentStringsW(szNewCtrFilePath, szCtrNameIn, dwSize);
                    }
                }
                if (dwReturn == ERROR_SUCCESS) {
                    dwSize   = dwTmp;
                    dwLength = ExpandEnvironmentStringsW(szNewHlpFilePath, szHlpNameIn, dwSize);
                    while (dwReturn == ERROR_SUCCESS && dwLength > dwSize) {
                        dwSize = dwLength;
                        MemoryFree(szHlpNameIn);
                        szHlpNameIn = MemoryAllocate(dwLength * sizeof(WCHAR));
                        if (szHlpNameIn == NULL) {
                            dwReturn = ERROR_OUTOFMEMORY;
                        }
                        else {
                            dwLength = ExpandEnvironmentStringsW(szNewHlpFilePath, szHlpNameIn, dwSize);
                        }
                    }
                }
            }
            else {
                hr = StringCchCopyW(szCtrNameIn, dwSize, szNewCtrFilePath);
                hr = StringCchCopyW(szHlpNameIn, dwSize, szNewHlpFilePath);
            }
        }
        else {
            dwReturn = ERROR_OUTOFMEMORY;
        }

        if (dwReturn == ERROR_SUCCESS) {
            // open and map new files
            hCtrFileIn = CreateFileW(szCtrNameIn,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);
            if (hCtrFileIn != INVALID_HANDLE_VALUE) {
                // map file
                dwCtrFileSize = GetFileSize(hCtrFileIn, NULL);
                if (dwCtrFileSize == 0xFFFFFFFF){
                    dwReturn =GetLastError();
                }
                else {
                    hCtrFileMap = CreateFileMappingW(hCtrFileIn, NULL, PAGE_READONLY, 0, 0, NULL);
                    if (hCtrFileMap != NULL) {
                        szNewCtrStrings = (LPWSTR) MapViewOfFileEx(hCtrFileMap, FILE_MAP_READ, 0, 0, 0, NULL);
                        if (szNewCtrStrings == NULL) {
                            dwReturn = GetLastError();
                        }
                    }
                    else {
                        dwReturn = GetLastError();
                    }
                }
            }
            else {
                dwReturn = GetLastError();
            }
        }
        if (dwReturn == ERROR_SUCCESS) {
            // open and map new files
            hHlpFileIn = CreateFileW(szHlpNameIn,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);
            if (hHlpFileIn != INVALID_HANDLE_VALUE) {
                // map file
                dwHlpFileSize = GetFileSize(hHlpFileIn, NULL);
                if (dwHlpFileSize == 0xFFFFFFFF){
                    dwReturn = GetLastError();
                }
                else {
                    hHlpFileMap = CreateFileMappingW(hHlpFileIn, NULL, PAGE_READONLY, 0, 0, NULL);
                    if (hHlpFileMap != NULL) {
                        szNewHlpStrings = (LPWSTR)MapViewOfFileEx(hHlpFileMap, FILE_MAP_READ, 0, 0, 0, NULL);
                        if (szNewHlpStrings == NULL) {
                            dwReturn = GetLastError();
                        }
                    }
                    else {
                        dwReturn = GetLastError();
                    }
                }
            }
            else {
                dwReturn = GetLastError();
            }
        }
    }
    else if (dwFlags & LODCTR_UPNF_RESTORE) {
        dwSize = lstrlenW(szNewCtrFilePath) + 1;
        if (dwSize < MAX_PATH) dwSize = MAX_PATH;
        szCtrNameIn = MemoryAllocate(dwSize * sizeof (WCHAR));
        if (szCtrNameIn != NULL) {
            dwReturn = ERROR_SUCCESS;
            dwLength = ExpandEnvironmentStringsW(szNewCtrFilePath, szCtrNameIn, dwSize);
            while (dwReturn == ERROR_SUCCESS && dwLength > dwSize) {
                dwSize = dwLength;
                MemoryFree(szCtrNameIn);
                szCtrNameIn = MemoryAllocate(dwLength * sizeof(WCHAR));
                if (szCtrNameIn == NULL) {
                    dwReturn = ERROR_OUTOFMEMORY;
                }
                else {
                    dwLength = ExpandEnvironmentStringsW(szNewCtrFilePath, szCtrNameIn, dwSize);
                }
            }
        }
        if (szCtrNameIn != NULL) {
            dwNewLastEntry = GetPrivateProfileIntW((LPCWSTR) L"Perflib", (LPCWSTR) L"Last Help", -1, szCtrNameIn);
            if (dwNewLastEntry != (DWORD) -1) {
                // get the input file size
                hCtrFileIn = CreateFileW(szCtrNameIn,
                                         GENERIC_READ,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL);
                if (hCtrFileIn != INVALID_HANDLE_VALUE) {
                    // map file
                    dwCtrFileSize = GetFileSize(hCtrFileIn, NULL);
                }
                else {
                    dwCtrFileSize = 64 * LOADPERF_BUFF_SIZE;  // assign 64k if unable to read it
                }
                // load new values from ini file
                bAllocCtrString = TRUE;
                szNewCtrStrings = (LPWSTR) MemoryAllocate(dwCtrFileSize * sizeof(WCHAR));
                if (szNewCtrStrings) {
                    dwLength      = lstrlenW(szLanguageID) + 16;
                    szLangSection = MemoryAllocate(dwLength * sizeof(WCHAR));
                    if (szLangSection == NULL) {
                        dwReturn = ERROR_OUTOFMEMORY;
                    }
                    else {
                        hr = StringCchPrintfW(szLangSection, dwLength, L"Perfstrings_%ws", szLanguageID);
                        dwSize = GetPrivateProfileSectionW(szLangSection,
                                                           szNewCtrStrings,
                                                           dwCtrFileSize,
                                                           szCtrNameIn);
                        if (dwSize == 0) {
                            hr = StringCchCopyW(szLangSection, dwLength, (LPCWSTR) L"Perfstrings_009");
                            dwSize = GetPrivateProfileSectionW(szLangSection,
                                                               szNewCtrStrings,
                                                               dwCtrFileSize,
                                                               szCtrNameIn);
                        }
                        if (dwSize == 0) {
                            dwReturn = ERROR_FILE_INVALID;
                        }
                        else {
                            // set file sizes
                            dwHlpFileSize = 0;
                            dwCtrFileSize = (dwSize + 2) * sizeof(WCHAR);
                        }
                   }
                }
                else {
                    dwReturn = ERROR_OUTOFMEMORY;
                }
            }
            else {
                // unable to open input file or file is invalid
                dwReturn = ERROR_FILE_INVALID;
            }
        }
        else if (dwReturn == ERROR_SUCCESS) {
            dwReturn = ERROR_OUTOFMEMORY;
        }
    }
    if ((dwReturn == ERROR_SUCCESS) && (! (dwFlags & LODCTR_UPNF_RESTORE))) {
        if (! (dwFlags & LODCTR_UPNF_REPAIR)) {
            // build name table of current strings
            pszOldNameTable = BuildNameTable(HKEY_LOCAL_MACHINE, szLanguageID, & dwOldLastEntry);
            if (pszOldNameTable == NULL) {
                dwReturn = GetLastError();
            }
        }
        else {
            dwOldLastEntry = 0;
        }
        dwNewLastEntry = (dwOldLastEntry == 0) ? (PERFLIB_BASE_INDEX) : (dwOldLastEntry);
    }
    else if (dwFlags & LODCTR_UPNF_RESTORE) {
        dwOldLastEntry = dwNewLastEntry;
    }

    if (dwReturn == ERROR_SUCCESS) {
        // build name table of new strings
        pszNewNameTable = (LPWSTR *) MemoryAllocate((dwNewLastEntry + 2) * sizeof(LPWSTR));// allow for index offset
        if (pszNewNameTable != NULL) {
            for (lpThisName = szNewCtrStrings; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
                // first string should be an integer (in decimal unicode digits)
                dwThisCounter = wcstoul(lpThisName, NULL, 10);
                if (dwThisCounter == 0 || dwThisCounter > dwNewLastEntry) {
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT, // event,
                            4, dwThisCounter, dwNewLastEntry, dwNewLastEntry, __LINE__,
                            1, lpThisName, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_UPDATEPERFNAMEFILES,
                            ARG_DEF(ARG_TYPE_WSTR, 1),
                            ERROR_INVALID_DATA,
                            TRACE_WSTR(lpThisName),
                            TRACE_DWORD(dwThisCounter),
                            TRACE_DWORD(dwNewLastEntry),
                            NULL));
                    continue;  // bad entry, try next
                }

                // point to corresponding counter name
                if (dwFlags & LODCTR_UPNF_RESTORE) {
                    // point to string that follows the "=" char
                    lpThisName = wcschr(lpThisName, L'=');
                    if (lpThisName != NULL) {
                        lpThisName ++;
                    }
                    else {
                        continue;
                    }
                }
                else {
                    // string is next in MSZ
                    lpThisName += (lstrlenW(lpThisName) + 1);
                }

                // and load array element;
                pszNewNameTable[dwThisCounter] = lpThisName;
            }
            if (dwReturn == ERROR_SUCCESS && (! (dwFlags & LODCTR_UPNF_RESTORE))) {
                for (lpThisName = szNewHlpStrings; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
                    // first string should be an integer (in decimal unicode digits)
                    dwThisCounter = wcstoul(lpThisName, NULL, 10);
                    if (dwThisCounter == 0 || dwThisCounter > dwNewLastEntry) {
                        ReportLoadPerfEvent(
                                EVENTLOG_WARNING_TYPE, // error type
                                (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT, // event,
                                4, dwThisCounter, dwNewLastEntry, dwNewLastEntry, __LINE__,
                                1, lpThisName, NULL, NULL);
                        TRACE((WINPERF_DBG_TRACE_ERROR),
                              (& LoadPerfGuid,
                                __LINE__,
                                LOADPERF_UPDATEPERFNAMEFILES,
                                ARG_DEF(ARG_TYPE_WSTR, 1),
                                ERROR_INVALID_DATA,
                                TRACE_WSTR(lpThisName),
                                TRACE_DWORD(dwThisCounter),
                                TRACE_DWORD(dwNewLastEntry),
                                NULL));
                        continue;  // bad entry, try next
                    }

                    // point to corresponding counter name
                    lpThisName += (lstrlenW(lpThisName) + 1);

                    // and load array element;
                    pszNewNameTable[dwThisCounter] = lpThisName;
                }
            }

            if (dwReturn == ERROR_SUCCESS) {
                // allocate string buffers for the resulting string
                // we want to make sure there's plenty of room so we'll make it
                // the size of the input file + the current buffer

                dwStringSize  = dwHlpFileSize;
                dwStringSize += dwCtrFileSize;
                if (pszOldNameTable != NULL) {
                    dwStringSize += MemorySize(pszOldNameTable);
                }

                szNewCtrMSZ = MemoryAllocate(dwStringSize * sizeof(WCHAR));
                szNewHlpMSZ = MemoryAllocate(dwStringSize * sizeof(WCHAR));
                if (szNewCtrMSZ == NULL || szNewHlpMSZ == NULL) {
                    dwReturn = ERROR_OUTOFMEMORY;
                }
            }
        }
        else {
            dwReturn = ERROR_OUTOFMEMORY;
        }
    }

    if (dwReturn == ERROR_SUCCESS) {
        // write new strings into registry
        __try {
            dwReturn = RegOpenKeyExW(HKEY_LOCAL_MACHINE, NamesKey, RESERVED, KEY_READ, & hKeyPerflib);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = GetExceptionCode();
        }
        dwSize          = sizeof(dwLastBaseValue);
        dwLastBaseValue = 0;
        if (dwReturn == ERROR_SUCCESS) {
            __try {
                dwReturn = RegQueryValueExW(hKeyPerflib,
                                            BaseIndex,
                                            RESERVED,
                                            & dwType,
                                            (LPBYTE) & dwLastBaseValue,
                                            & dwSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                dwReturn = GetExceptionCode();
            }
            if (dwLastBaseValue == 0) {
                dwReturn = ERROR_BADDB;
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEPERFNAMEFILES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    dwReturn,
                    TRACE_WSTR(BaseIndex),
                    TRACE_DWORD(dwLastBaseValue),
                    NULL));
            RegCloseKey(hKeyPerflib);
        }
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                dwReturn,
                TRACE_WSTR(NamesKey),
                NULL));
    }

    if (dwReturn == ERROR_SUCCESS) {
        DWORD   dwLoopLimit;
        // the strings should be mapped by now
        // pszNewNameTable contains the new strings from the
        // source path and pszOldNameTable contains the strings
        // from the original system. The merge will consist of
        // taking all base values from the new table and the
        // extended values from the old table.
        dwIndex         = 1;
        szThisCtrString = szNewCtrMSZ;
        szThisHlpString = szNewHlpMSZ;
        dwCtrFileSize   = dwStringSize;
        dwHlpFileSize   = dwStringSize;

        // index 1 is a special case and belongs in the counter string
        // after that even numbers (starting w/ #2) go into the counter string
        // and odd numbers (starting w/ #3) go into the help string
        hr = StringCchPrintfW(szThisCtrString, dwCtrFileSize, L"%d", dwIndex);
        dwCtrFileSize   -= (lstrlenW(szThisCtrString) + 1);
        szThisCtrString += (lstrlenW(szThisCtrString) + 1);
        hr = StringCchPrintfW(szThisCtrString, dwCtrFileSize, L"%ws", pszNewNameTable[dwIndex]);
        dwCtrFileSize   -= (lstrlenW(szThisCtrString) + 1);
        szThisCtrString += (lstrlenW(szThisCtrString) + 1);

        dwIndex ++;

        if (dwFlags & LODCTR_UPNF_RESTORE) {
            // restore ALL strings from the input file only if this
            // is a restoration
            dwLoopLimit = dwOldLastEntry;
        }
        else {
            // only update the system counters from the input file
            dwLoopLimit = dwLastBaseValue;
        }

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                0,
                ERROR_SUCCESS,
                TRACE_DWORD(dwOldLastEntry),
                TRACE_DWORD(dwLastBaseValue),
                NULL));

        for (/*dwIndex from above*/; dwIndex <= dwLoopLimit; dwIndex++) {
            if (pszNewNameTable[dwIndex] != NULL) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEPERFNAMEFILES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_SUCCESS,
                        TRACE_WSTR(pszNewNameTable[dwIndex]),
                        TRACE_DWORD(dwIndex),
                        NULL));
                if (dwIndex & 0x01) {
                    // then it's a help string
                    hr = StringCchPrintfW(szThisHlpString, dwHlpFileSize, L"%d", dwIndex);
                    dwHlpFileSize   -= (lstrlenW(szThisHlpString) + 1);
                    szThisHlpString += (lstrlenW(szThisHlpString) + 1);
                    hr = StringCchPrintfW(szThisHlpString, dwHlpFileSize, L"%ws", pszNewNameTable[dwIndex]);
                    dwHlpFileSize   -= (lstrlenW(szThisHlpString) + 1);
                    szThisHlpString += (lstrlenW(szThisHlpString) + 1);
                }
                else {
                    // it's a counter string
                    hr = StringCchPrintfW(szThisCtrString, dwCtrFileSize, L"%d", dwIndex);
                    dwCtrFileSize   -= (lstrlenW(szThisCtrString) + 1);
                    szThisCtrString += (lstrlenW(szThisCtrString) + 1);
                    hr = StringCchPrintfW(szThisCtrString, dwCtrFileSize, L"%ws", pszNewNameTable[dwIndex]);
                    dwCtrFileSize   -= (lstrlenW(szThisCtrString) + 1);
                    szThisCtrString += (lstrlenW(szThisCtrString) + 1);
                }
            } // else just skip it
        }
        for (/*dwIndex from last run */;dwIndex <= dwOldLastEntry; dwIndex++) {
            if (pszOldNameTable[dwIndex] != NULL) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEPERFNAMEFILES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_SUCCESS,
                        TRACE_WSTR(pszOldNameTable[dwIndex]),
                        TRACE_DWORD(dwIndex),
                        NULL));
               if (dwIndex & 0x01) {
                    // then it's a help string
                    hr = StringCchPrintfW(szThisHlpString, dwHlpFileSize, L"%d", dwIndex);
                    dwHlpFileSize   -= (lstrlenW(szThisHlpString) + 1);
                    szThisHlpString += (lstrlenW(szThisHlpString) + 1);
                    hr = StringCchPrintfW(szThisHlpString, dwHlpFileSize, L"%ws", pszOldNameTable[dwIndex]);
                    dwHlpFileSize   -= (lstrlenW(szThisHlpString) + 1);
                    szThisHlpString += (lstrlenW(szThisHlpString) + 1);
                } else {
                    // it's a counter string
                    hr = StringCchPrintfW(szThisCtrString, dwCtrFileSize, L"%d", dwIndex);
                    dwCtrFileSize   -= (lstrlenW(szThisCtrString) + 1);
                    szThisCtrString += (lstrlenW(szThisCtrString) + 1);
                    hr = StringCchPrintfW(szThisCtrString, dwCtrFileSize, L"%ws", pszOldNameTable[dwIndex]);
                    dwCtrFileSize   -= (lstrlenW(szThisCtrString) + 1);
                    szThisCtrString += (lstrlenW(szThisCtrString) + 1);
                }
            } // else just skip it
        }
        // terminate the MSZ
        * szThisCtrString ++ = L'\0';
        * szThisHlpString ++ = L'\0';
    }

    // close mapped memory sections:
    if (bAllocCtrString) {
        MemoryFree(szNewCtrStrings);
        MemoryFree(szNewHlpStrings);
    }
    else {
        if (szNewCtrStrings != NULL) UnmapViewOfFile(szNewCtrStrings);
        if (szNewHlpStrings != NULL) UnmapViewOfFile(szNewHlpStrings);
    }
    if (hCtrFileMap     != NULL) CloseHandle(hCtrFileMap);
    if (hCtrFileIn      != NULL) CloseHandle(hCtrFileIn);
    if (hHlpFileMap     != NULL) CloseHandle(hHlpFileMap);
    if (hHlpFileIn      != NULL) CloseHandle(hHlpFileIn);

    if (dwReturn == ERROR_SUCCESS) {
        // write new values to registry
        LPWSTR   AddCounterNameBuffer = NULL;
        LPWSTR   AddHelpNameBuffer    = NULL;

        dwLength = lstrlenW(AddCounterNameStr) + lstrlenW(AddHelpNameStr) + lstrlenW(szLanguageID) + 1;
        AddCounterNameBuffer = MemoryAllocate(2 * dwLength * sizeof(WCHAR));
        if (AddCounterNameBuffer != NULL) {
            AddHelpNameBuffer = AddCounterNameBuffer + dwLength;
            hr = StringCchPrintfW(AddCounterNameBuffer, dwLength, L"%ws%ws", AddCounterNameStr, szLanguageID);
            hr = StringCchPrintfW(AddHelpNameBuffer,    dwLength, L"%ws%ws", AddHelpNameStr,    szLanguageID);

            // because these are perf counter strings, RegQueryValueEx
            // is used instead of RegSetValueEx as one might expect.
            dwSize = (DWORD)((DWORD_PTR)szThisCtrString - (DWORD_PTR)szNewCtrMSZ);
            __try {
                dwReturn = RegQueryValueExW(HKEY_PERFORMANCE_DATA,
                                            AddCounterNameBuffer,
                                            RESERVED,
                                            & dwType,
                                            (LPVOID) szNewCtrMSZ,
                                            & dwSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                dwReturn = GetExceptionCode();
            }
            if (dwReturn != ERROR_SUCCESS) {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEPERFNAMEFILES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        dwReturn,
                        TRACE_WSTR(AddCounterNameBuffer),
                        TRACE_DWORD(dwSize),
                        NULL));
            }

            dwSize = (DWORD) ((DWORD_PTR) szThisHlpString - (DWORD_PTR) szNewHlpMSZ);
            __try {
                dwReturn = RegQueryValueExW(HKEY_PERFORMANCE_DATA,
                                            AddHelpNameBuffer,
                                            RESERVED,
                                            & dwType,
                                            (LPVOID) szNewHlpMSZ,
                                            & dwSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                dwReturn = GetExceptionCode();
            }
            if (dwReturn != ERROR_SUCCESS) {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEPERFNAMEFILES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        dwReturn,
                        TRACE_WSTR(AddHelpNameBuffer),
                        TRACE_DWORD(dwSize),
                        NULL));
            }
            MemoryFree(AddCounterNameBuffer);
        }
        else {
            dwReturn = ERROR_OUTOFMEMORY;
        }
    }

    MemoryFree(szCtrNameIn);
    MemoryFree(szHlpNameIn);
    MemoryFree(pszNewNameTable);
    MemoryFree(pszOldNameTable);
    MemoryFree(szNewCtrMSZ);
    MemoryFree(szNewHlpMSZ);
    MemoryFree(szLangSection);

    ReleaseMutex(hLoadPerfMutex);
    return dwReturn;
}

// exported version of the above function
LOADPERF_FUNCTION
UpdatePerfNameFilesW(
    IN  LPCWSTR   szNewCtrFilePath,   // data file with new base counter strings
    IN  LPCWSTR   szNewHlpFilePath,   // data file with new base counter strings
    IN  LPWSTR    szLanguageID,       // Lang ID to update
    IN  ULONG_PTR dwFlags             // flags
)
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSize;

    if (szNewCtrFilePath != NULL) {
        __try {
            dwSize = lstrlenW(szNewCtrFilePath);
            if (dwSize == 0) dwStatus = ERROR_INVALID_PARAMETER;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if (szNewHlpFilePath != NULL) {
        __try {
            dwSize = lstrlenW(szNewHlpFilePath);
            if (dwSize == 0) dwStatus = ERROR_INVALID_PARAMETER;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    }
    else if (! (dwFlags & LODCTR_UPNF_RESTORE)) {
        // this parameter can only be NULL if this flag bit is set.
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if (szLanguageID != NULL) {
        __try {
            dwSize = lstrlenW(szLanguageID);
            if (dwSize == 0) dwStatus = ERROR_INVALID_PARAMETER;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    if (dwStatus == ERROR_SUCCESS) {
        dwStatus = UpdatePerfNameFilesX(szNewCtrFilePath,   // data file with new base counter strings
                                        szNewHlpFilePath,   // data file with new base counter strings
                                        szLanguageID,       // Lang ID to update
                                        dwFlags);           // flags
    }
    return dwStatus;
}

LOADPERF_FUNCTION
UpdatePerfNameFilesA(
    IN  LPCSTR    szNewCtrFilePath, // data file with new base counter strings
    IN  LPCSTR    szNewHlpFilePath, // data file with new base counter strings
    IN  LPSTR     szLanguageID,     // Lang ID to update
    IN  ULONG_PTR dwFlags           // flags
)
{
    DWORD   dwError           = ERROR_SUCCESS;
    LPWSTR  wszNewCtrFilePath = NULL;
    LPWSTR  wszNewHlpFilePath = NULL;
    LPWSTR  wszLanguageID     = NULL;
    DWORD   dwLength;

    if (szNewCtrFilePath != NULL) {
        __try {
            dwLength = lstrlenA(szNewCtrFilePath);
            if (dwLength == 0) {
                dwError = ERROR_INVALID_PARAMETER;
            }
            else {
                wszNewCtrFilePath = LoadPerfMultiByteToWideChar(CP_ACP, (LPSTR) szNewCtrFilePath);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (szNewHlpFilePath != NULL) {
        __try {
            dwLength = lstrlenA(szNewHlpFilePath);
            if (dwLength == 0) {
                dwError = ERROR_INVALID_PARAMETER;
            }
            else {
                wszNewHlpFilePath = LoadPerfMultiByteToWideChar(CP_ACP, (LPSTR) szNewHlpFilePath);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = ERROR_INVALID_PARAMETER;
        }
    }
    else if (! (dwFlags & LODCTR_UPNF_RESTORE)) {
        // this parameter can only be NULL if this flag bit is set.
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (szLanguageID != NULL) {
        __try {
            dwLength = lstrlenA(szLanguageID);
            if (dwLength == 0) {
                dwError = ERROR_INVALID_PARAMETER;
            }
            else {
                wszLanguageID = LoadPerfMultiByteToWideChar(CP_ACP, (LPSTR) szLanguageID);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (dwError == ERROR_SUCCESS) {
        if (wszNewCtrFilePath == NULL || wszLanguageID == NULL) {
            dwError = ERROR_OUTOFMEMORY;
        }
        else if (szNewHlpFilePath != NULL && wszNewHlpFilePath == NULL) {
            dwError = ERROR_OUTOFMEMORY;
        }
        if (dwError == ERROR_SUCCESS) {
            dwError = UpdatePerfNameFilesX(wszNewCtrFilePath, wszNewHlpFilePath, wszLanguageID, dwFlags);
        }
    }
    MemoryFree(wszNewCtrFilePath);
    MemoryFree(wszNewHlpFilePath);
    MemoryFree(wszLanguageID);
    return dwError;
}

LOADPERF_FUNCTION
SetServiceAsTrustedW(
    IN  LPCWSTR szMachineName,  // reserved, MBZ
    IN  LPCWSTR szServiceName
)
{
    HKEY              hKeyService_Perf = NULL;
    DWORD             dwReturn         = ERROR_SUCCESS;
    HKEY              hKeyLM           = HKEY_LOCAL_MACHINE;    // until remote machine access is supported
    LPWSTR            szPerfKeyString  = NULL;
    LPWSTR            szLibName        = NULL;
    LPWSTR            szExpLibName     = NULL;
    LPWSTR            szFullPathName   = NULL;
    DWORD             dwSize, dwType;
    HANDLE            hFile;
    DllValidationData dvdLibrary;
    LARGE_INTEGER     liSize;
    BOOL              bStatus;
    HRESULT           hr;

    WinPerfStartTrace(NULL);
    if (szMachineName != NULL) {
        // reserved for future use
        dwReturn = ERROR_INVALID_PARAMETER;
    }
    else if (szServiceName == NULL) {
        dwReturn = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            dwSize = lstrlenW(szServiceName);
            if (dwSize == 0) dwReturn = ERROR_INVALID_PARAMETER;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = ERROR_INVALID_PARAMETER;
        }
    }
    if (dwReturn != ERROR_SUCCESS) goto Cleanup;

    szPerfKeyString = MemoryAllocate(sizeof(WCHAR) * SMALL_BUFFER_SIZE * 4);
    if (szPerfKeyString == NULL) {
        dwReturn = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    szLibName      = (LPWSTR) (szPerfKeyString + SMALL_BUFFER_SIZE);
    szExpLibName   = (LPWSTR) (szLibName       + SMALL_BUFFER_SIZE);
    szFullPathName = (LPWSTR) (szExpLibName    + SMALL_BUFFER_SIZE);

    // build path to performance subkey
    hr = StringCchPrintfW(szPerfKeyString,
                     SMALL_BUFFER_SIZE,
                     L"%ws%ws%ws%ws%ws",
                     DriverPathRoot,
                     Slash,
                     szServiceName,
                     Slash,
                     Performance);
    // open performance key under the service key
    __try {
        dwReturn = RegOpenKeyExW(hKeyLM, szPerfKeyString, 0L, KEY_READ | KEY_WRITE, & hKeyService_Perf);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwReturn = GetExceptionCode();
    }
    if (dwReturn == ERROR_SUCCESS) {
        // get library name
        dwType = 0;
        dwSize = SMALL_BUFFER_SIZE * sizeof(WCHAR);
        __try {
            dwReturn = RegQueryValueExW(hKeyService_Perf, cszLibrary, NULL, & dwType, (LPBYTE) szLibName, & dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = GetExceptionCode();
        }
        if (dwReturn == ERROR_SUCCESS) {
            // expand path name if necessary
            if (dwType == REG_EXPAND_SZ) {
               dwSize = ExpandEnvironmentStringsW(szLibName, szExpLibName, SMALL_BUFFER_SIZE);
            }
            else {
                hr = StringCchCopyW(szExpLibName, SMALL_BUFFER_SIZE, szLibName);
                // dwSize is same as returned from Fn Call.
            }

            if (dwSize != 0) {
                // find DLL file
                dwSize = SearchPathW(NULL, szExpLibName, NULL, SMALL_BUFFER_SIZE, szFullPathName, NULL);
                if (dwSize > 0) {
                    hFile = CreateFileW(szFullPathName,
                                        GENERIC_READ,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
                    if (hFile != INVALID_HANDLE_VALUE) {
                         // read file date/time & size
                        bStatus = GetFileTime(hFile, & dvdLibrary.CreationDate, NULL, NULL);
                        if (bStatus) {
                            WORD dateCreate;
                            WORD timeCreate;

                            FileTimeToDosDateTime(& dvdLibrary.CreationDate, & dateCreate, & timeCreate);
                            DosDateTimeToFileTime(dateCreate, timeCreate, & dvdLibrary.CreationDate);
                            liSize.LowPart      = GetFileSize( hFile, (DWORD *) & liSize.HighPart);
                            dvdLibrary.FileSize = liSize.QuadPart;
                            // set registry value
                            __try {
                                dwReturn = RegSetValueExW(hKeyService_Perf,
                                                          szLibraryValidationCode,
                                                          0L,
                                                          REG_BINARY,
                                                          (LPBYTE) & dvdLibrary,
                                                          sizeof(dvdLibrary));
                            }
                            __except (EXCEPTION_EXECUTE_HANDLER) {
                                dwReturn = GetExceptionCode();
                            }
                            TRACE((WINPERF_DBG_TRACE_INFO),
                                  (& LoadPerfGuid,
                                    __LINE__,
                                    LOADPERF_SETSERVICEASTRUSTED,
                                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_WSTR, 3),
                                    dwReturn,
                                    TRACE_WSTR(szServiceName),
                                    TRACE_WSTR(szExpLibName),
                                    TRACE_WSTR(szLibraryValidationCode),
                                    NULL));
                        }
                        else {
                            dwReturn = GetLastError();
                        }
                        CloseHandle (hFile);
                    }
                    else {
                        dwReturn = GetLastError();
                    }
                }
                else {
                    dwReturn = ERROR_FILE_NOT_FOUND;
                }
            }
            else {
                // unable to expand environment strings
                dwReturn = GetLastError();
            }
        }
        else {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_SETSERVICEASTRUSTED,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    dwReturn,
                    TRACE_WSTR(szServiceName),
                    TRACE_WSTR(cszLibrary),
                    NULL));
        }
        // close key
        RegCloseKey (hKeyService_Perf);
    }
    if (dwReturn == ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SETSERVICEASTRUSTED,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_SUCCESS,
                TRACE_WSTR(szServiceName),
                TRACE_WSTR(Performance),
                NULL));
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SETSERVICEASTRUSTED,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                dwReturn,
                TRACE_WSTR(szServiceName),
                TRACE_WSTR(Performance),
                NULL));
    }

Cleanup:
    MemoryFree(szPerfKeyString);
    return dwReturn;
}

LOADPERF_FUNCTION
SetServiceAsTrustedA(
    IN  LPCSTR szMachineName,  // reserved, MBZ
    IN  LPCSTR szServiceName
)
{
    LPWSTR lpWideServiceName = NULL;
    DWORD  lReturn           = ERROR_SUCCESS;

    if (szMachineName != NULL) {
        // reserved for future use
        lReturn = ERROR_INVALID_PARAMETER;
    }
    else if (szServiceName == NULL) {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            DWORD dwStrLen = lstrlenA(szServiceName);
            if (dwStrLen == 0) lReturn = ERROR_INVALID_PARAMETER;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            lReturn = ERROR_INVALID_PARAMETER;
        }
    }
    if (lReturn == ERROR_SUCCESS) {
        //length of string including terminator
        lpWideServiceName = LoadPerfMultiByteToWideChar(CP_ACP, (LPSTR) szServiceName);
        if (lpWideServiceName != NULL) {
            lReturn = SetServiceAsTrustedW(NULL, lpWideServiceName);
        }
        else {
            lReturn = ERROR_OUTOFMEMORY;
        }
    }
    MemoryFree(lpWideServiceName);
    return lReturn;
}

int __cdecl
My_vfwprintf(
    FILE          * str,
    const wchar_t * format,
    va_list         argptr
    )
{
    HANDLE        hOut;
    int           iReturn = 0;
    HRESULT       hr;
    static WCHAR  szBufferMessage[LOADPERF_BUFF_SIZE];

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }
    if ((GetFileType(hOut) & ~ FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        hr = StringCchVPrintfW(szBufferMessage, LOADPERF_BUFF_SIZE, format, argptr);
        if (SUCCEEDED(hr)) {
            iReturn = lstrlenW(szBufferMessage);
            WriteConsoleW(hOut, szBufferMessage, iReturn, & iReturn, NULL);
        }
        else {
            iReturn = -1;
        }
    }
    else {
        iReturn = vfwprintf(str, format, argptr);
    }
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\initodat\common.h ===
/*++
Copyright (c) 1993-1994 Microsoft Corporation

Module Name:
    common.h

Abstract:
    Utility routines used by IniToDat.exe

Author:
    HonWah Chan (a-honwah) October, 1993 

Revision History:
--*/

#ifndef _COMMON_H_
#define _COMMON_H_
//
//  Local constants
//
#define RESERVED                0L
#define LARGE_BUFFER_SIZE       0x10000         // 64K
#define MEDIUM_BUFFER_SIZE      0x8000          // 32K
#define SMALL_BUFFER_SIZE       0x1000          //  4K
#define FILE_NAME_BUFFER_SIZE   MAX_PATH
#define DISP_BUFF_SIZE          1024
#define SIZE_OF_OFFSET_STRING   15

LPWSTR
GetStringResource(
    UINT wStringId
);

LPSTR
GetFormatResource(
    UINT wStringId
);

VOID
DisplayCommandHelp(
    UINT iFirstLine,
    UINT iLastLine
);

VOID
DisplaySummary(
    LPWSTR lpLastID,
    LPWSTR lpLastText,
    UINT   NumOfID
);

VOID
DisplaySummaryError(
    LPWSTR lpLastID,
    LPWSTR lpLastText,
    UINT   NumOfID
);
#endif  // _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\initodat\fileutl.c ===
/*++
Copyright (c) 1993-1994  Microsoft Corporation

Module Name:
    fileutl.c

Abstract:
    Routines for getting data from ini file

Author:
    HonWah Chan (a-honwah)  October, 1993

Revision History:
--*/

#include "initodat.h"
#include "strids.h"
#include "common.h"
#include "winerror.h"

NTSTATUS
DatReadMultiSzFile(
#ifdef FE_SB
    UINT              uCodePage,
#endif
    PUNICODE_STRING   FileName,
    PVOID           * ValueBuffer,
    PULONG            ValueLength
)
{
    NTSTATUS         Status = STATUS_SUCCESS;
    UNICODE_STRING   NtFileName;
    LPWSTR           s;
    UNICODE_STRING   MultiSource;
    UNICODE_STRING   MultiValue;
    REG_UNICODE_FILE MultiSzFile;
    ULONG            MultiSzFileSize;

    ZeroMemory(& NtFileName, sizeof(UNICODE_STRING));
    if (ValueBuffer == NULL || ValueLength == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    FileName->Buffer[FileName->Length / sizeof(WCHAR)] = UNICODE_NULL;
    RtlDosPathNameToNtPathName_U(FileName->Buffer, & NtFileName, NULL, NULL);

#ifdef FE_SB
    Status = DatLoadAsciiFileAsUnicode(uCodePage, & NtFileName, & MultiSzFile);
#else
    Status = DatLoadAsciiFileAsUnicode(& NtFileName, & MultiSzFile);
#endif
    if (! NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    MultiSzFileSize = (ULONG) (MultiSzFile.EndOfFile - MultiSzFile.NextLine + 1);
    * ValueLength   = 0;
    * ValueBuffer   = ALLOCMEM((MultiSzFileSize + 2) * sizeof(WCHAR));
    if (* ValueBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    MultiSource.Buffer = MultiSzFile.NextLine;
    if (MultiSzFileSize * sizeof(WCHAR) <= MAXUSHORT) {
        MultiSource.Length = MultiSource.MaximumLength = (USHORT) MultiSzFileSize * sizeof(WCHAR);
    }
    else {
        MultiSource.Length = MultiSource.MaximumLength = MAXUSHORT;
    }

    while (DatGetMultiString(& MultiSource, & MultiValue)) {
        RtlMoveMemory((PUCHAR) * ValueBuffer + * ValueLength, MultiValue.Buffer, MultiValue.Length);
        * ValueLength += MultiValue.Length;

        s = MultiSource.Buffer;
        while (* s != L'"' && * s != L',' && ((s - MultiSource.Buffer) * sizeof(WCHAR)) < MultiSource.Length) s ++;
        if (((s - MultiSource.Buffer) * sizeof(WCHAR)) == MultiSource.Length || * s == L',' || * s == L';') {
            ((PWSTR) * ValueBuffer)[* ValueLength / sizeof(WCHAR)] = UNICODE_NULL;
            * ValueLength += sizeof(UNICODE_NULL);
            if (* s ==  L';') {
                break;
            }
        }
        if ((MultiSzFile.EndOfFile - MultiSource.Buffer) * sizeof(WCHAR) >= MAXUSHORT) {
            MultiSource.Length = MultiSource.MaximumLength = MAXUSHORT;
        }
        else {
            MultiSource.Length = MultiSource.MaximumLength =
                            (USHORT)((MultiSzFile.EndOfFile - MultiSource.Buffer) * sizeof(WCHAR));
        }
    }

    ((PWSTR) * ValueBuffer)[ * ValueLength / sizeof(WCHAR)] = UNICODE_NULL;
    * ValueLength += sizeof(UNICODE_NULL);

    // Virtual memory for reading of MultiSzFile freed at process
    // death?

Cleanup:
    if (NtFileName.Buffer != NULL) FREEMEM(NtFileName.Buffer);
    if (MultiSzFile.FileContents != NULL) FREEMEM(MultiSzFile.FileContents);
    return Status;
}

NTSTATUS
DatLoadAsciiFileAsUnicode(
#ifdef FE_SB
    UINT              uCodePage,
#endif
    PUNICODE_STRING   FileName,
    PREG_UNICODE_FILE UnicodeFile
)
{
    NTSTATUS                  Status     = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES         ObjectAttributes;
    IO_STATUS_BLOCK           IoStatus;
    HANDLE                    File       = NULL;
    FILE_BASIC_INFORMATION    FileDateTimeInfo;
    FILE_STANDARD_INFORMATION FileInformation;
    SIZE_T                    BufferSize;
    ULONG                     i, i1, LineCount;
    PVOID                     BufferBase = NULL;
    LPSTR                     szSource   = NULL;
    LPSTR                     Src        = NULL;
    LPSTR                     Src1;
    LPWSTR                    Dst        = NULL;

    ZeroMemory(& FileDateTimeInfo, sizeof(FILE_BASIC_INFORMATION));
    InitializeObjectAttributes(& ObjectAttributes, FileName, OBJ_CASE_INSENSITIVE, (HANDLE) NULL, NULL);
    Status = NtOpenFile(& File,
                        SYNCHRONIZE | GENERIC_READ,
                        & ObjectAttributes,
                        & IoStatus,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);
    if (! NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = NtQueryInformationFile(File,
                                    & IoStatus,
                                    (PVOID) & FileInformation,
                                    sizeof(FileInformation),
                                    FileStandardInformation);
    if (NT_SUCCESS(Status)) {
        if (FileInformation.EndOfFile.HighPart) {
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }
    if (! NT_SUCCESS(Status)) {
        goto Cleanup;
    }

#ifdef FE_SB
    BufferSize = FileInformation.EndOfFile.LowPart + 1;
#else
    BufferSize = FileInformation.EndOfFile.LowPart + 1;
#endif

    szSource    = ALLOCMEM(BufferSize + 2);
    BufferBase  = ALLOCMEM((BufferSize + 2) * sizeof(WCHAR));
    if (BufferBase != NULL && szSource != NULL) {
        Src = (LPSTR) szSource;
        Dst = (PWSTR) BufferBase;
        Status = NtReadFile(File,
                            NULL,
                            NULL,
                            NULL,
                            & IoStatus,
                            Src,
                            FileInformation.EndOfFile.LowPart,
                            NULL,
                            NULL);
        if (NT_SUCCESS(Status)) {
            Status = IoStatus.Status;
            if (NT_SUCCESS(Status)) {
                if (IoStatus.Information != FileInformation.EndOfFile.LowPart) {
                    Status = STATUS_END_OF_FILE;
                }
                else {
                    Status = NtQueryInformationFile(File,
                                                    & IoStatus,
                                                    (PVOID) & FileDateTimeInfo,
                                                    sizeof(FileDateTimeInfo),
                                                    FileBasicInformation);
                }
            }
        }
    }
    else {
        Status = STATUS_NO_MEMORY;
    }
    if (! NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    i = 0;
    while (i < FileInformation.EndOfFile.LowPart) {
        if (i > 1 && (Src[-2] == ' ' || Src[-2] == '\t') && Src[-1] == '\\' && (*Src == '\r' || *Src == '\n')) {
            if (Dst[-1] == L'\\') {
                -- Dst;
            }
            while (Dst > (PWSTR) BufferBase) {
                if (Dst[-1] > L' ') {
                    break;
                }
                Dst --;
            }
            LineCount = 0;
            while (i < FileInformation.EndOfFile.LowPart) {
                if (*Src == '\n') {
                    i ++;
                    Src ++;
                    LineCount ++;
                }
                else if (*Src == '\r' && (i+1) < FileInformation.EndOfFile.LowPart && Src[ 1 ] == '\n') {
                    i   += 2;
                    Src += 2;
                    LineCount++;
                }
                else {
                    break;
                }
            }

            if (LineCount > 1) {
                * Dst ++ = L'\n';
            }
            else {
                * Dst ++ = L' ';
                while (i < FileInformation.EndOfFile.LowPart && (* Src == ' ' || * Src == '\t')) {
                    i ++;
                    Src ++;
                }
            }
            if (i >= FileInformation.EndOfFile.LowPart) {
                break;
            }
        }
        else if ((* Src == '\r' && Src[1] == '\n') || * Src == '\n') {
            while (TRUE) {
                while (i < FileInformation.EndOfFile.LowPart && (* Src == '\r' || * Src == '\n')) {
                    i ++;
                    Src ++;
                }
                Src1 = Src;
                i1   = i;
                while (i1 < FileInformation.EndOfFile.LowPart && (* Src1 == ' ' || * Src1 == '\t')) {
                    i1 ++;
                    Src1 ++;
                }
                if (i1 < FileInformation.EndOfFile.LowPart && (* Src1 == '\r' && Src1[1] == '\n') || * Src1 == '\n') {
                    Src = Src1;
                    i   = i1;
                }
                else {
                    break;
                }
            }
            * Dst ++ = L'\n';
        }
        else {
#ifdef FE_SB
            WCHAR UnicodeCharacter;
            LONG  cbCharSize = IsDBCSLeadByteEx(uCodePage, * Src) ? 2 : 1;

            if (MultiByteToWideChar(uCodePage, 0, Src, cbCharSize, & UnicodeCharacter, 1) == 0) {
                //
                // Check for error - The only time this will happen is if there is
                // a leadbyte without a trail byte.
                //
                UnicodeCharacter = 0x0020;
            }
            i       += cbCharSize;
            Src     += cbCharSize;
            * Dst ++ = UnicodeCharacter;
#else
            i ++;
            * Dst ++ = RtlAnsiCharToUnicodeChar(& Src);
#endif
        }
    }

    if (NT_SUCCESS(Status)) {
        * Dst                      = UNICODE_NULL;
        UnicodeFile->FileContents  = BufferBase;
        UnicodeFile->EndOfFile     = Dst;
        UnicodeFile->BeginLine     = NULL;
        UnicodeFile->EndOfLine     = NULL;
        UnicodeFile->NextLine      = BufferBase;
        UnicodeFile->LastWriteTime = FileDateTimeInfo.LastWriteTime;
    }

Cleanup:
    if (! NT_SUCCESS(Status)) {
        if (BufferBase != NULL) FREEMEM(BufferBase);
    }
    if (szSource != NULL) FREEMEM(szSource);
    if (File     != NULL) NtClose(File);
    return(Status);
}

//
//  Define an upcase macro for temporary use by the upcase routines
//
#define upcase(C) (WCHAR )(((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C)))

BOOLEAN
DatGetMultiString(
    PUNICODE_STRING ValueString,
    PUNICODE_STRING MultiString
)
/*++
Routine Description:
    This routine parses multi-strings of the form
        "foo" "bar" "bletch"

    Each time it is called, it strips the first string in quotes from
    the input string, and returns it as the multi-string.
        INPUT ValueString: "foo" "bar" "bletch"
        OUTPUT ValueString: "bar" "bletch"
               MultiString: foo

Arguments:
    ValueString - Supplies the string from which the multi-string will be
                  parsed
                - Returns the remaining string after the multi-string is
                  removed
    MultiString - Returns the multi-string removed from ValueString

Return Value:
    TRUE - multi-string found and removed.
    FALSE - no more multi-strings remaining.
--*/

{
    BOOLEAN bReturn  = FALSE;
    DWORD   dwLength = ValueString->Length / sizeof(WCHAR);

    if (ValueString->Length != dwLength * sizeof(WCHAR)) {
        // ValueString->Length should not be odd number, bail out.
        goto Cleanup;
    }
    //
    // Find the first quote mark.
    //
    while ((ValueString->Length > 0) && (* (ValueString->Buffer) != L'"')) {
        ++ ValueString->Buffer;
        ValueString->Length        -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        goto Cleanup;
    }

    //
    // We have found the start of the multi-string.  Now find the end,
    // building up our return MultiString as we go.
    //
    ++ ValueString->Buffer;
    ValueString->Length        -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);
    MultiString->Buffer         = ValueString->Buffer;
    MultiString->Length         = 0;
    MultiString->MaximumLength  = 0;
    while ((ValueString->Length > 0) && (* (ValueString->Buffer) != L'"')) {
        ++ ValueString->Buffer;
        ValueString->Length        -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);
        MultiString->Length        += sizeof(WCHAR);
        MultiString->MaximumLength += sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        goto Cleanup;
    }

    ++ ValueString->Buffer;
    ValueString->Length        -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);
    bReturn = TRUE;

Cleanup:
    return bReturn;
}

#define EXTENSION_DELIMITER  L'.'
BOOL
OutputIniData(
    PUNICODE_STRING FileName,
    LPWSTR          OutFileCandidate,
    DWORD           dwOutFile,
    PVOID           pValueBuffer,
    ULONG           ValueLength
)
{
    HANDLE   hOutFile    = NULL;
    LPWSTR   lpExtension = NULL;
    DWORD    nAmtWritten;
    BOOL     bSuccess    = FALSE;
    DWORD    ErrorCode;
    HRESULT  hError;

    // If output file not specified, derive from input file name
    if (OutFileCandidate[0] == L'\0') {
        if ((DWORD) (lstrlenW(FileName->Buffer) + 5) <= dwOutFile) {
            LPWSTR lpDelimiter;

            hError = StringCchCopyW(OutFileCandidate, dwOutFile, FileName->Buffer);
            if (FAILED(hError)) goto Cleanup;

            lpDelimiter = wcschr(OutFileCandidate, EXTENSION_DELIMITER);
            if (lpDelimiter != NULL) {
                nAmtWritten = dwOutFile - ((DWORD) (lpDelimiter - OutFileCandidate));
                hError = StringCchCopyW(lpDelimiter, nAmtWritten, L".dat");
                if (FAILED(hError)) goto Cleanup;
            }
            else {
                hError = StringCchCatW(OutFileCandidate, dwOutFile, L".dat");
                if (FAILED(hError)) goto Cleanup;
            }
        }
        else {
            goto Cleanup;
        }
    }
    hOutFile = (HANDLE) CreateFileW(OutFileCandidate,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
    if (hOutFile == NULL || hOutFile == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        printf(GetFormatResource(LC_CANT_CREATE), ErrorCode);
        if (ErrorCode == ERROR_ACCESS_DENIED) printf("%ws\n", GetStringResource(LC_ACCESS_DENIED));
        goto Cleanup;
    }
    bSuccess = WriteFile(hOutFile, pValueBuffer, ValueLength, & nAmtWritten, NULL);
    bSuccess = bSuccess && (nAmtWritten == ValueLength);
    CloseHandle(hOutFile);
    if (! bSuccess) {
        ErrorCode = GetLastError();
        printf(GetFormatResource(LC_CANT_WRITE), ErrorCode);
        if (ErrorCode == ERROR_DISK_FULL) printf("%ws\n", GetStringResource(LC_DISK_FULL));
    }

Cleanup:
   return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\initodat\initodat.h ===
/*++
Copyright (c) 1993-1994  Microsoft Corporation

Module Name:
    initodat.h

Abstract:
    This is the include file for the ini to data file conversion functions.

Author:
    HonWah Chan (a-honwah)  October, 1993

Revision History:
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <windows.h>
#include <strsafe.h>
#include <errno.h>
#include <ctype.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>

#define VALUE_BUFFER_SIZE (4096 * 100)
#define ALLOCMEM(x) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (DWORD)(x))
#define FREEMEM(x)  HeapFree(GetProcessHeap(), 0, (LPVOID)(x))

typedef struct _REG_UNICODE_FILE {
    LARGE_INTEGER LastWriteTime;
    PWSTR         FileContents;
    PWSTR         EndOfFile;
    PWSTR         BeginLine;
    PWSTR         EndOfLine;
    PWSTR         NextLine;
} REG_UNICODE_FILE, * PREG_UNICODE_FILE;

NTSTATUS
DatReadMultiSzFile(
#ifdef FE_SB
    UINT              uCodePage,
#endif
    PUNICODE_STRING   FileName,
    PVOID           * ValueBuffer,
    PULONG            ValueLength
);

NTSTATUS
DatLoadAsciiFileAsUnicode(
#ifdef FE_SB
    UINT              uCodePage,
#endif
    PUNICODE_STRING   FileName,
    PREG_UNICODE_FILE UnicodeFile
);

BOOLEAN
DatGetMultiString(
    PUNICODE_STRING ValueString,
    PUNICODE_STRING MultiString
);

BOOL
OutputIniData(
    PUNICODE_STRING FileName,
    LPWSTR          OutFileCandidate,
    DWORD           dwOutFile,
    PVOID           pValueBuffer,
    ULONG           ValueLength
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\initodat\initodat.c ===
/*++
Copyright (c) 1993-1994  Microsoft Corporation

Module Name:
    initodat.c

Abstract:
    Routines for converting Perf???.ini to Perf???.dat files.
    Source INI files are localed under ..\perfini\<country> directories. Generated DAT files will
    be put under %SystemRoot%\System32 directory.

Author:
    HonWah Chan (a-honwah)  October, 1993

Revision History:
--*/

#include "initodat.h"
#include "strids.h"
#include "common.h"

BOOL
MakeUpgradeFilename(
    LPCWSTR szDataFileName,
    LPWSTR  szUpgradeFileName
)
{
    BOOL   bReturn = FALSE;
    // note: assumes szUpgradeFileName buffer is large enough for result
    WCHAR  szDrive[_MAX_DRIVE];
    WCHAR  szDir[_MAX_DIR];
    WCHAR  szFileName[_MAX_FNAME];
    WCHAR  szExt[_MAX_EXT];

    _wsplitpath(szDataFileName, (LPWSTR) szDrive, (LPWSTR) szDir, (LPWSTR) szFileName, (LPWSTR) szExt);

    // see if the filename fits the "PERF[C|H]XXX" format
    if (szFileName[4] == L'C' || szFileName[4] == L'H' || szFileName[4] == L'c' || szFileName[4] == L'h') {
        // then it's the correct format so change the 4th letter up 1 letter
        szFileName[4] += 1;
        // and make a new path
        _wmakepath(szUpgradeFileName, (LPCWSTR) szDrive, (LPCWSTR) szDir, (LPCWSTR) szFileName, (LPCWSTR) szExt);
        bReturn = TRUE;
    }
    return bReturn;
}

BOOL
GetFilesFromCommandLine(
    LPWSTR    lpCommandLine,
#ifdef FE_SB
    UINT    * puCodePage,
#endif
    LPWSTR    lpFileNameI,
    DWORD     dwFileNameI,
    LPWSTR    lpFileNameD,
    DWORD     dwFileNameD
)
/*++
GetFilesFromCommandLine
    parses the command line to retrieve the ini filename that should be
    the first and only argument.

Arguments
    lpCommandLine   pointer to command line (returned by GetCommandLine)
    lpFileNameI     pointer to buffer that will receive address of the
                        validated input filename entered on the command line
    lpFileNameD     pointer to buffer that will receive address of the
                        optional output filename entered on the command line

Return Value
    TRUE if a valid filename was returned
    FALSE if the filename is not valid or missing
            error is returned in GetLastError
--*/
{
    INT      iNumArgs;
    HFILE    hIniFile;
    OFSTRUCT ofIniFile;
    CHAR     lpIniFileName[FILE_NAME_BUFFER_SIZE];
    WCHAR    lpExeName[FILE_NAME_BUFFER_SIZE];
    WCHAR    lpIniName[FILE_NAME_BUFFER_SIZE];
    BOOL     bReturn       = FALSE;

    // check for valid arguments
    if (lpCommandLine == NULL || lpFileNameI == NULL || lpFileNameD == NULL) {
        goto Cleanup;
    }

    // get strings from command line
#ifdef FE_SB
    iNumArgs = swscanf(lpCommandLine, L" %s %d %s %s ", lpExeName, puCodePage, lpIniName, lpFileNameD);
#else
    iNumArgs = swscanf(lpCommandLine, L" %s %s %s ", lpExeName, lpIniName, lpFileNameD);
#endif

#ifdef FE_SB
    if (iNumArgs < 3 || iNumArgs > 4) {
#else
    if (iNumArgs < 2 || iNumArgs > 3) {
#endif
        // wrong number of arguments
        goto Cleanup;
    }

    // see if file specified exists
    // file name is always an ANSI buffer
    WideCharToMultiByte(CP_ACP, 0, lpIniName, -1, lpIniFileName, FILE_NAME_BUFFER_SIZE, NULL, NULL);
    hIniFile = OpenFile(lpIniFileName, & ofIniFile, OF_PARSE);
    if (hIniFile != HFILE_ERROR) {
        _lclose(hIniFile);
        hIniFile = OpenFile(lpIniFileName, & ofIniFile, OF_EXIST);
        if ((hIniFile && hIniFile != HFILE_ERROR) || GetLastError() == ERROR_FILE_EXISTS) {
            // file exists, so return name and success
            // return full pathname if found
            MultiByteToWideChar(CP_ACP, 0, ofIniFile.szPathName, -1, lpFileNameI, dwFileNameI); 
            bReturn = TRUE;
            _lclose(hIniFile);
        }
        else {
            // filename was on command line, but not valid so return
            // false, but send name back for error message
            MultiByteToWideChar(CP_ACP, 0, lpIniFileName, -1, lpFileNameI, dwFileNameI); 
            if (hIniFile && hIniFile != HFILE_ERROR) _lclose(hIniFile);
        }
    }

Cleanup:
    return bReturn;
}

BOOL
VerifyIniData(
    PVOID  pValueBuffer,
    ULONG  ValueLength
)
/*++
VerifyIniData
   This routine does some simple check to see if the ini file is good.
   Basically, it is looking for (ID, Text) and checking that ID is an
   integer.   Mostly in case of missing comma or quote, the ID will be
   an invalid integer.
--*/
{
    INT     iNumArg;
    INT     TextID;
    LPWSTR  lpID          = NULL;
    LPWSTR  lpText        = NULL;
    LPWSTR  lpLastID;
    LPWSTR  lpLastText;
    LPWSTR  lpInputBuffer = (LPWSTR) pValueBuffer;
    LPWSTR  lpBeginBuffer = (LPWSTR) pValueBuffer;
    BOOL    returnCode    = TRUE;
    UINT    NumOfID       = 0;
    ULONG   CurrentLength;

    while (TRUE) {
        // save up the last items for summary display later
        lpLastID      = lpID;
        lpLastText    = lpText;

        // increment to next ID and text location
        lpID          = lpInputBuffer;
        CurrentLength = (ULONG) ((PBYTE) lpID - (PBYTE) lpBeginBuffer + sizeof(WCHAR));
        if (CurrentLength >= ValueLength) break;

        CurrentLength += lstrlenW(lpID) + 1;
        if (CurrentLength >= ValueLength) break;
        lpText        = lpID + lstrlenW(lpID) + 1;

        CurrentLength += lstrlenW(lpText) + 1;
        if (CurrentLength >= ValueLength) break;
        lpInputBuffer = lpText + lstrlenW(lpText) + 1;
        iNumArg       = swscanf(lpID, L"%d", & TextID);

        if (iNumArg != 1) {
            // bad ID
            returnCode = FALSE;
            break;
        }
        NumOfID ++;
    }

    if (returnCode == FALSE) {
       DisplaySummaryError(lpLastID, lpLastText, NumOfID);
    }
    else {
       DisplaySummary(lpLastID, lpLastText, NumOfID);
    }
    return (returnCode);
}

__cdecl main(
)
/*++
main

Arguments

ReturnValue
    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.
--*/
{
    LPWSTR         lpCommandLine;
    WCHAR          lpIniFile[MAX_PATH];
    WCHAR          lpDatFile[MAX_PATH];
    UNICODE_STRING IniFileName;
    PVOID          pValueBuffer = NULL;
    ULONG          ValueLength;
    BOOL           bStatus;
    NTSTATUS       NtStatus     = ERROR_SUCCESS;
#ifdef FE_SB
    UINT           uCodePage    = CP_ACP;
#endif

    lpCommandLine = GetCommandLineW(); // get command line
    if (lpCommandLine == NULL) {
        NtStatus = GetLastError();
        goto Cleanup;
    }

    // read command line to determine what to do
    lpIniFile[0] = lpDatFile[0] = L'\0';
#ifdef FE_SB  // FE_SB
    if (GetFilesFromCommandLine(lpCommandLine, & uCodePage,
                    lpIniFile, RTL_NUMBER_OF(lpIniFile), lpDatFile, RTL_NUMBER_OF(lpDatFile))) {
        if (! IsValidCodePage(uCodePage)) {
            uCodePage = CP_ACP;
        }
#else
    if (GetFilesFromCommandLine(lpCommandLine,
                    lpIniFile, RTL_NUMBER_OF(lpIniFile), lpDatFile, RTL_NUMBER_OF(lpDatFile))) {
#endif // FE_SB
        // valid filename (i.e. ini file exists)
        RtlInitUnicodeString(& IniFileName, lpIniFile);
#ifdef FE_SB
        NtStatus = DatReadMultiSzFile(uCodePage, & IniFileName, & pValueBuffer, & ValueLength);
#else
        NtStatus = DatReadMultiSzFile(& IniFileName, & pValueBuffer, & ValueLength);
#endif
        bStatus = NT_SUCCESS(NtStatus);
        if (bStatus) {
            bStatus = VerifyIniData(pValueBuffer, ValueLength);
            if (bStatus) {
                bStatus = OutputIniData(
                        & IniFileName, lpDatFile, RTL_NUMBER_OF(lpDatFile), pValueBuffer, ValueLength);
                bStatus = MakeUpgradeFilename(lpDatFile, lpDatFile);
                if (bStatus) {
                    bStatus = OutputIniData(
                            & IniFileName, lpDatFile, RTL_NUMBER_OF(lpDatFile), pValueBuffer, ValueLength);
                }
            }
        }
    }
    else {
        if (* lpIniFile) {
            printf(GetFormatResource(LC_NO_INIFILE), lpIniFile);
        }
        else {
            //Incorrect Command Format
            // display command line usage
            DisplayCommandHelp(LC_FIRST_CMD_HELP, LC_LAST_CMD_HELP);
        }
    }

Cleanup:
    if (pValueBuffer != NULL) FREEMEM(pValueBuffer);
    return (NtStatus); // success
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETPATH=obj
TARGETNAME=NOTARGET
TARGETTYPE=NOTARGET
SOURCES=
SOURCES_USED=..\sources.inc

#
#   define _LANGCODE to be the primary language id in hex
#
#   usa = 009
#

!if "$(ALT_PROJECT)"=="."
_LANGCODE=009
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="ARA"
_LANGCODE=001
CODEPAGE=1256
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="CHS"
_LANGCODE=0804
CODEPAGE=936
_PERFNAME=prf
!elseif "$(ALT_PROJECT)"=="CHT"
_LANGCODE=0404
CODEPAGE=950
_PERFNAME=prf
!elseif "$(ALT_PROJECT)"=="GER"
_LANGCODE=007
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="HEB"
_LANGCODE=00D
CODEPAGE=1255
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="JPN"
_LANGCODE=011
CODEPAGE=932
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="KOR"
_LANGCODE=012
CODEPAGE=949
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="br"
_LANGCODE=016
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="cs"
_LANGCODE=005
CODEPAGE=1250
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="da"
_LANGCODE=006
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="el"
_LANGCODE=008
CODEPAGE=1253
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="es"
_LANGCODE=00a
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="fi"
_LANGCODE=00b
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="fr"
_LANGCODE=00c
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="hu"
_LANGCODE=00e
CODEPAGE=1250
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="it"
_LANGCODE=010
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="nl"
_LANGCODE=013
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="no"
_LANGCODE=014
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="pl"
_LANGCODE=015
CODEPAGE=1250
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="psu"
_LANGCODE=01f
CODEPAGE=1253
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="pt"
_LANGCODE=016
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="ru"
_LANGCODE=019
CODEPAGE=1251
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="sv"
_LANGCODE=01d
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="tr"
_LANGCODE=01f
CODEPAGE=1254
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="TST"
_LANGCODE=009
CODEPAGE=1252
_PERFNAME=perf
!endif

PERFCINI=$(_PERFNAME)c$(_LANGCODE).ini
PERFHINI=$(_PERFNAME)h$(_LANGCODE).ini

NTTARGETFILES=

MISCFILES= \
        $(O)\$(_PERFNAME)c$(_LANGCODE).dat \
        $(O)\$(_PERFNAME)d$(_LANGCODE).dat \
        $(O)\$(_PERFNAME)h$(_LANGCODE).dat \
        $(O)\$(_PERFNAME)i$(_LANGCODE).dat
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\initodat\strids.h ===
/*++
Copyright (c) 1993-1994  Microsoft Corporation

Module Name:
    strids.h

Abstract:
    This is the include file for the strings ids use in initodat.exe

Author:
    HonWah Chan (a-honwah)  October, 1993

Revision History:
--*/

// strings defines for Help
#define  LC_CMD_HELP_1     100
#define  LC_CMD_HELP_2     101
#define  LC_CMD_HELP_3     102
#define  LC_CMD_HELP_4     103
#define  LC_CMD_HELP_5     104
#define  LC_CMD_HELP_6     105
#define  LC_CMD_HELP_7     106
#define  LC_CMD_HELP_8     107
#define  LC_CMD_HELP_9     108
#define  LC_CMD_HELP_10    109
#define  LC_CMD_HELP_11    110
#define  LC_CMD_HELP_12    111
#define  LC_CMD_HELP_13    112

#define  LC_FIRST_CMD_HELP 100
#define  LC_LAST_CMD_HELP  112

// strings defines for error

#define  LC_NO_INIFILE     202
#define  LC_SUMMARY        203
#define  LC_NUM_OF_ID      204
#define  LC_LAST_ID        205
#define  LC_LAST_TEXT      206
#define  LC_BAD_ID         207
#define  LC_MISSING_DEL    208
#define  LC_CANT_CREATE    209
#define  LC_CANT_WRITE     210
#define  LC_ACCESS_DENIED  211
#define  LC_DISK_FULL      212
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\ara\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\lodctr\lodctr.c ===
/*++
Copyright (c) 1991  Microsoft Corporation

Module Name:
    lodctr.c

Abstract:
    Program to read the contents of the file specified in the command line
        and update the registry accordingly

Author:
    Bob Watson (a-robw) 10 Feb 93

Revision History:
    a-robw  25-Feb-93   revised calls to make it compile as a UNICODE or
                        an ANSI app.

    a-robw  10-Nov-95   revised to use DLL functions for all the dirty work

    // command line arguments supported:

    /C:<filename>   upgrade counter text strings using <filename>
    /H:<filename>   upgrade help text strings using <filename>
    /L:<LangID>     /C and /H params are for language <LangID>

    /S:<filename>   save current perf registry strings & info to <filname>
    /R:<filename>   restore perf registry strings & info using <filname>

    /T:<service>    set <service> to be Trusted using current DLL 
--*/

//  Windows Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <locale.h>
#include "mbctype.h"
#include "strsafe.h"
#include <winperf.h>
#include <loadperf.h>

static CHAR szFileNameBuffer[MAX_PATH * 2];

LPWSTR
LodctrMultiByteToWideChar(LPSTR  aszString)
{
    LPWSTR wszString = NULL;
    int    dwValue   = MultiByteToWideChar(_getmbcp(), 0, aszString, -1, NULL, 0);
    if (dwValue != 0) {
        wszString = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (dwValue + 1) * sizeof(WCHAR));
        if (wszString != NULL) {
            MultiByteToWideChar(_getmbcp(), 0, aszString, -1, wszString, dwValue + 1);
        }
    }
    return wszString;
}

LPCSTR GetTrustedServiceName(LPCSTR szArg1)
{
    LPSTR   szReturn = NULL;

    if (lstrlenA(szArg1) >= 4) {
        if ((szArg1[0] == '-' || szArg1[0] == '/') && (szArg1[1] == 't' || szArg1[1] == 'T') && (szArg1[2] == ':')) {
            szReturn = (LPSTR) & szArg1[3];
        }
    }
    return (LPCSTR) szReturn;
}

BOOL
GetUpgradeFileNames(LPCSTR * szArgs, LPSTR * szCounterFile, LPSTR * szHelpFile, LPSTR * szLangId)
{
    DWORD dwArgIdx = 1;
    DWORD dwMask   = 0;

    * szCounterFile = NULL;
    * szHelpFile    = NULL;
    * szLangId      = NULL;

    do {
        if (lstrlenA(szArgs[dwArgIdx]) >= 4) {
            if ((szArgs[dwArgIdx][0] == '-') || (szArgs[dwArgIdx][0] == '/')) {
                if ((szArgs[dwArgIdx][1] == 'c' || szArgs[dwArgIdx ][1] == 'C') && (szArgs[dwArgIdx][2] == ':')) {
                    * szCounterFile = (LPSTR) & szArgs[dwArgIdx][3];
                    dwMask |= 1;
                }
                else if ((szArgs[dwArgIdx][1] == 'h' || szArgs[dwArgIdx][1] == 'H') && (szArgs[dwArgIdx][2] == ':')) {
                    * szHelpFile = (LPSTR) & szArgs[dwArgIdx][3];
                    dwMask |= 2;
                }
                else if ((szArgs[dwArgIdx][1] == 'l' || szArgs[dwArgIdx][1] == 'L') && (szArgs[dwArgIdx][2] == ':')) {
                    * szLangId = (LPSTR) & szArgs[dwArgIdx][3];
                    dwMask |= 4;
                }
            }
        }
        dwArgIdx ++;
    }
    while (dwArgIdx <= 3);

    return (dwMask == 7) ? (TRUE) : (FALSE);
}

BOOL GetSaveFileName(LPCSTR szArg1, LPCSTR * szSaveFile)
{
    BOOL  bReturn = FALSE;
    DWORD dwSize  = 0;

    * szSaveFile = NULL;
    if (lstrlenA(szArg1) >= 4) {
        if ((szArg1[0] == '-' || szArg1[0] == '/') && (szArg1[1] == 's' || szArg1[1] == 'S') && (szArg1[2] == ':')) {
            bReturn = TRUE;
            ZeroMemory(szFileNameBuffer, sizeof(szFileNameBuffer));
            dwSize = SearchPathA(NULL,
                                 (LPSTR) & szArg1[3],
                                 NULL, 
                                 RTL_NUMBER_OF(szFileNameBuffer),
                                 szFileNameBuffer,
                                 NULL);
            if (dwSize == 0) {
                * szSaveFile = (LPSTR) & szArg1[3];
            }
            else {
                * szSaveFile = szFileNameBuffer;
            }
        }
    }
    return bReturn;
}

BOOL GetRestoreFileName(LPCSTR szArg1, LPCSTR * szRestoreFile)
{
    BOOL  bReturn  = FALSE;
    DWORD dwSize   = 0;

    * szRestoreFile = NULL;
    if (lstrlenA(szArg1) >= 2) {
        if ((szArg1[0] == '-' || szArg1[0] == '/') && (szArg1[1] == 'r' || szArg1[1] == 'R')) {
            if (lstrlenA(szArg1) >= 4 && szArg1[2] == ':') {
                ZeroMemory(szFileNameBuffer, sizeof(szFileNameBuffer));
                dwSize = SearchPathA(NULL,
                                    (LPSTR) & szArg1[3],
                                    NULL, 
                                    RTL_NUMBER_OF(szFileNameBuffer),
                                    szFileNameBuffer,
                                    NULL);
                if (dwSize == 0) {
                    * szRestoreFile = (LPSTR) & szArg1[3];
                }
                else {
                    * szRestoreFile = szFileNameBuffer;
                }
            }
            bReturn = TRUE;
        }
    }
    return bReturn;
}

////////////////////////////////////////////////////////////////////////////
//
//  MySetThreadUILanguage
//
//  This routine sets the thread UI language based on the console codepage.
//
//  9-29-00    WeiWu    Created.
//  Copied from Base\Win32\Winnls so that it works in W2K as well
////////////////////////////////////////////////////////////////////////////
LANGID WINAPI MySetThreadUILanguage(WORD wReserved)
{
    //
    //  Cache system locale and CP info
    // 
    static LCID    s_lidSystem  = 0;
    static UINT    s_uiSysCp    = 0;
    static UINT    s_uiSysOEMCp = 0;
    ULONG          uiUserUICp;
    ULONG          uiUserUIOEMCp;
    WCHAR          szData[16];
    UNICODE_STRING ucStr;
    LANGID         lidUserUI     = GetUserDefaultUILanguage();
    LCID           lcidThreadOld = GetThreadLocale();
    //
    //  Set default thread locale to EN-US
    //
    //  This allow us to fall back to English UI to avoid trashed characters 
    //  when console doesn't meet the criteria of rendering native UI.
    //
    LCID lcidThread = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
    UINT uiConsoleCp = GetConsoleOutputCP();
    //
    //  Make sure nobody uses it yet
    //
    ASSERT(wReserved == 0);
    //
    //  Get cached system locale and CP info.
    //
    if (!s_uiSysCp) {
        LCID lcidSystem = GetSystemDefaultLCID();

        if (lcidSystem) {
            //
            // Get ANSI CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            RtlInitUnicodeString(&ucStr, szData);
            RtlUnicodeStringToInteger(&ucStr, 10, &uiUserUICp);
            //
            // Get OEM CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            RtlInitUnicodeString(&ucStr, szData);
            RtlUnicodeStringToInteger(&ucStr, 10, &s_uiSysOEMCp);
            //
            // Cache system primary langauge
            //
            s_lidSystem = PRIMARYLANGID(LANGIDFROMLCID(lcidSystem));
        }
    }
    //
    //  Don't cache user UI language and CP info, UI language can be changed without system reboot.
    //
    if (lidUserUI) {
        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        RtlInitUnicodeString(& ucStr, szData);
        RtlUnicodeStringToInteger(& ucStr, 10, &uiUserUICp);

        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        RtlInitUnicodeString(& ucStr, szData);
        RtlUnicodeStringToInteger(& ucStr, 10, &uiUserUIOEMCp);
    }
    //
    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
    //
    if (uiConsoleCp &&  s_lidSystem != LANG_ARABIC &&  s_lidSystem != LANG_HEBREW &&
                    s_lidSystem != LANG_VIETNAMESE &&  s_lidSystem != LANG_THAI) {
        //
        //  Use UI language for console only when console CP, system CP and UI language CP match.
        //
        if ((uiConsoleCp == s_uiSysCp || uiConsoleCp == s_uiSysOEMCp) && 
                        (uiConsoleCp == uiUserUICp || uiConsoleCp == uiUserUIOEMCp)) {
            lcidThread = MAKELCID(lidUserUI, SORT_DEFAULT);
        }
    }
    //
    //  Set the thread locale if it's different from the currently set
    //  thread locale.
    //
    if ((lcidThread != lcidThreadOld) && (!SetThreadLocale(lcidThread))) {
        lcidThread = lcidThreadOld;
    }
    //
    //  Return the thread locale that was set.
    //
    return (LANGIDFROMLCID(lcidThread));
}

int __cdecl main(int argc, char * argv[])
{
    LPSTR  szCmdArgFileName = NULL;
    LPWSTR wszFileName      = NULL;
    int    nReturn          = 0;
    BOOL   bSuccess         = FALSE;

    setlocale(LC_ALL, ".OCP");
    MySetThreadUILanguage(0);
    // check for a service name in the command line

    if (argc >= 4) {
        LPSTR szCounterFile = NULL;
        LPSTR szHelpFile    = NULL;
        LPSTR szLanguageID  = NULL;

        bSuccess = GetUpgradeFileNames(argv, & szCounterFile, & szHelpFile, & szLanguageID);
        if (bSuccess) {
            nReturn = (int) UpdatePerfNameFilesA(szCounterFile, szHelpFile, szLanguageID, 0);
        }
    }
    else if (argc >= 2) {
        // then there's a param to check

        bSuccess = GetSaveFileName(argv[1], & szCmdArgFileName);
        if (bSuccess && szCmdArgFileName != NULL) {
            wszFileName = LodctrMultiByteToWideChar(szCmdArgFileName);
            if (wszFileName != NULL) {
                nReturn = (int) BackupPerfRegistryToFileW((LPCWSTR) wszFileName, (LPCWSTR) L"");
                HeapFree(GetProcessHeap(), 0, wszFileName);
            }
        }
        if (! bSuccess) {
            bSuccess = GetRestoreFileName(argv[1], & szCmdArgFileName);
            if (bSuccess) {
                wszFileName = NULL;
                if (szCmdArgFileName != NULL) {
                    wszFileName = LodctrMultiByteToWideChar(szCmdArgFileName);
                }
                nReturn = (int) RestorePerfRegistryFromFileW((LPCWSTR) wszFileName, NULL);
                if (wszFileName != NULL) {
                    HeapFree(GetProcessHeap(), 0, wszFileName);
                }
            }
        }
        if (! bSuccess) {
            szCmdArgFileName = (LPSTR) GetTrustedServiceName(argv[1]);
            if (szCmdArgFileName != NULL) {
                wszFileName = LodctrMultiByteToWideChar(szCmdArgFileName);
                if (wszFileName != NULL) {
                    nReturn  = (int) SetServiceAsTrustedW(NULL, (LPCWSTR) wszFileName);
                    bSuccess = TRUE;
                    HeapFree(GetProcessHeap(), 0, wszFileName);
                }
            }
        }
    }
    if (! bSuccess) {
        // if here then load the registry from an ini file

        LPWSTR  lpCommandLine = GetCommandLineW();
        nReturn = (int) LoadPerfCounterTextStringsW(lpCommandLine, FALSE);
    }

    return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\chs\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\br\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\cht\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\cs\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\da\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\el\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\es\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\fi\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\fr\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\ger\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\heb\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\hu\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\it\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\jpn\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\kor\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\nl\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\no\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\pl\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\psu\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\pt\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\ru\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\sv\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\tr\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\tst\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\usa\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\showperf\perfdata.c ===
#include <windows.h>
#include <winperf.h>
#include <stdlib.h>
#include <strsafe.h>
#include "showperf.h"
#include "perfdata.h"

LPCWSTR NamesKey      = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR DefaultLangId = L"009";
LPCWSTR Counters      = L"Counters";
LPCWSTR Help          = L"Help";
LPCWSTR LastHelp      = L"Last Help";
LPCWSTR LastCounter   = L"Last Counter";
LPCWSTR Slash         = L"\\";

// the following strings are for getting texts from perflib
#define  OLD_VERSION  0x010000
LPCWSTR VersionName   = L"Version";
LPCWSTR CounterName   = L"Counter ";
LPCWSTR HelpName      = L"Explain ";

LPWSTR
* BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
)
/*++
BuildNameTable

Arguments:
    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.
    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:
    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.
--*/
{

    LPWSTR  * lpReturnValue     = NULL;
    LPWSTR  * lpCounterId;
    LPWSTR    lpCounterNames;
    LPWSTR    lpHelpText;
    LPWSTR    lpThisName;
    LONG      lWin32Status;
    DWORD     dwLastError;
    DWORD     dwValueType;
    DWORD     dwArraySize;
    DWORD     dwBufferSize;
    DWORD     dwCounterSize;
    DWORD     dwHelpSize;
    DWORD     dwThisCounter;
    DWORD     dwSystemVersion;
    DWORD     dwLastId;
    DWORD     dwLastHelpId;
    HKEY      hKeyRegistry      = NULL;
    HKEY      hKeyValue         = NULL;
    HKEY      hKeyNames         = NULL;
    LPWSTR    lpValueNameString = NULL; //initialize to NULL
    WCHAR     CounterNameBuffer[50];
    WCHAR     HelpNameBuffer[50];
    HRESULT   hError;

    if (szComputerName == NULL) {
        // use local machine
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    }
    else {
        lWin32Status = RegConnectRegistryW(szComputerName, HKEY_LOCAL_MACHINE, & hKeyRegistry);
        if (lWin32Status != ERROR_SUCCESS) {
            // unable to connect to registry
            goto BNT_BAILOUT;
        }
    }

    // check for null arguments and insert defaults if necessary
    if (lpszLangId == NULL) {
        lpszLangId = (LPWSTR) DefaultLangId;
    }

    // open registry to get number of items for computing array size
    lWin32Status = RegOpenKeyExW(hKeyRegistry, NamesKey, RESERVED, KEY_READ, & hKeyValue);
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items
    dwBufferSize = sizeof(dwLastHelpId);
    lWin32Status = RegQueryValueExW(
            hKeyValue, LastHelp, RESERVED, & dwValueType, (LPBYTE) & dwLastHelpId, & dwBufferSize);
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        if (lWin32Status == ERROR_SUCCESS) lWin32Status = ERROR_INVALID_DATA;
        goto BNT_BAILOUT;
    }

    // get number of items
    dwBufferSize = sizeof(dwLastId);
    lWin32Status = RegQueryValueExW(
            hKeyValue, LastCounter, RESERVED, & dwValueType, (LPBYTE) & dwLastId, & dwBufferSize);
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        if (lWin32Status == ERROR_SUCCESS) lWin32Status = ERROR_INVALID_DATA;
        goto BNT_BAILOUT;
    }

    if (dwLastId < dwLastHelpId) dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof(dwSystemVersion);
    lWin32Status = RegQueryValueExW(
            hKeyValue, VersionName, RESERVED, & dwValueType, (LPBYTE) & dwSystemVersion, & dwBufferSize);
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = MemoryAllocate(
                        (lstrlenW(NamesKey) + lstrlenW(Slash) + lstrlenW(lpszLangId) + 1) * sizeof (WCHAR));
        if (lpValueNameString == NULL) {
            lWin32Status = ERROR_OUTOFMEMORY;
            goto BNT_BAILOUT;
        }
        hError = StringCbPrintfW(lpValueNameString, MemorySize(lpValueNameString), L"%ws%ws%ws",
                        NamesKey, Slash, lpszLangId);
        if (SUCCEEDED(hError)) {
            lWin32Status = RegOpenKeyExW(hKeyRegistry, lpValueNameString, RESERVED, KEY_READ, & hKeyNames);
        }
        else {
            lWin32Status = HRESULT_CODE(hError);
        }
        MemoryFree(lpValueNameString);
    }
    else {
        if (szComputerName == NULL) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        }
        else {
            lWin32Status = RegConnectRegistryW(szComputerName, HKEY_PERFORMANCE_DATA, & hKeyNames);
            if (lWin32Status != ERROR_SUCCESS) {
                goto BNT_BAILOUT;
            }
        }
        hError = StringCchPrintfW(CounterNameBuffer, RTL_NUMBER_OF(CounterNameBuffer), L"%ws%ws",
                        CounterName, lpszLangId);
        if (SUCCEEDED(hError)) {
            hError = StringCchPrintfW(HelpNameBuffer, RTL_NUMBER_OF(HelpNameBuffer), L"%ws%ws", HelpName, lpszLangId);
            if (FAILED(hError)) lWin32Status = HRESULT_CODE(hError);
        }
        else {
            lWin32Status = HRESULT_CODE(hError);
        }
    }
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // get size of counter names and add that to the arrays
    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW(hKeyNames,
                                    dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    NULL,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW(hKeyNames,
                                    dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    NULL,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwHelpSize = dwBufferSize;

    lpReturnValue = MemoryAllocate(dwArraySize + dwCounterSize + dwHelpSize);

    if (lpReturnValue == NULL) {
        lWin32Status = ERROR_OUTOFMEMORY;
        goto BNT_BAILOUT;
    }

    // initialize pointers into buffer

    lpCounterId    = lpReturnValue;
    lpCounterNames = (LPWSTR) ((LPBYTE) lpCounterId    + dwArraySize);
    lpHelpText     = (LPWSTR) ((LPBYTE) lpCounterNames + dwCounterSize);

    // read counters into memory
    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueExW(hKeyNames,
                                    dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID) lpCounterNames,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueExW(hKeyNames,
                                    dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID) lpHelpText,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // load counter array items
    for (lpThisName = lpCounterNames; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
        // first string should be an integer (in decimal unicode digits)
        dwThisCounter = wcstoul(lpThisName, NULL, 10);
        if (dwThisCounter > 0 && dwThisCounter < dwLastId) {
            // point to corresponding counter name
            lpThisName += (lstrlenW(lpThisName) + 1);
            // and load array element;
            lpCounterId[dwThisCounter] = lpThisName;
        }
    }

    for (lpThisName = lpHelpText; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
        // first string should be an integer (in decimal unicode digits)
        dwThisCounter = wcstoul(lpThisName, NULL, 10);
        if (dwThisCounter > 0 && dwThisCounter < dwLastId) {
            // point to corresponding counter name
            lpThisName += (lstrlenW(lpThisName) + 1);
            // and load array element;
            lpCounterId[dwThisCounter] = lpThisName;
        }
    }

    if (pdwLastItem) * pdwLastItem = dwLastId;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        MemoryFree(lpReturnValue);
        dwLastError   = GetLastError();
        lpReturnValue = NULL;
    }
    if (hKeyValue    != NULL) RegCloseKey(hKeyValue);
    if (hKeyNames    != NULL && hKeyNames != HKEY_PERFORMANCE_DATA) RegCloseKey(hKeyNames);
    if (hKeyRegistry != NULL) RegCloseKey(hKeyRegistry);
    return lpReturnValue;
}

PPERF_OBJECT_TYPE
FirstObject(
    PPERF_DATA_BLOCK pPerfData
)
{
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pPerfData + pPerfData->HeaderLength));
}

PPERF_OBJECT_TYPE
NextObject(
    PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    DWORD   dwOffset = pObject->TotalByteLength;
    return (dwOffset != 0) ? ((PPERF_OBJECT_TYPE) (((LPBYTE) pObject) + dwOffset)) : (NULL);
}  // NextObject

PPERF_OBJECT_TYPE
GetObjectDefByTitleIndex(
    PPERF_DATA_BLOCK pDataBlock,
    DWORD            ObjectTypeTitleIndex
)
{
    DWORD             NumTypeDef;
    PPERF_OBJECT_TYPE pObjectDef;
    PPERF_OBJECT_TYPE pRtnObject = NULL;

    if (pDataBlock != NULL) {
        pObjectDef = FirstObject(pDataBlock);
        for (NumTypeDef = 0; pRtnObject == NULL && NumTypeDef < pDataBlock->NumObjectTypes; NumTypeDef ++) {
            if (pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex ) {
                pRtnObject = pObjectDef;
                break;
            }
            else {
                pObjectDef = NextObject(pObjectDef);
            }
        }
    }
    return pRtnObject;
}

PPERF_INSTANCE_DEFINITION
FirstInstance(
    PPERF_OBJECT_TYPE pObjectDef
)
{
    return (PPERF_INSTANCE_DEFINITION) ((LPBYTE) pObjectDef + pObjectDef->DefinitionLength);
}

PPERF_INSTANCE_DEFINITION
NextInstance(
    PPERF_INSTANCE_DEFINITION pInstDef
)
{
    PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK) ((LPBYTE) pInstDef + pInstDef->ByteLength);
    return (PPERF_INSTANCE_DEFINITION) ((LPBYTE) pCounterBlock + pCounterBlock->ByteLength);
}

PPERF_INSTANCE_DEFINITION
GetInstance(
    PPERF_OBJECT_TYPE pObjectDef,
    LONG              InstanceNumber
)
{
    PPERF_INSTANCE_DEFINITION pRtnInstance = NULL;
    PPERF_INSTANCE_DEFINITION pInstanceDef;
    LONG                      NumInstance;

    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance(pObjectDef);
        for (NumInstance = 0; pRtnInstance == NULL && NumInstance < pObjectDef->NumInstances; NumInstance ++) {
            if (InstanceNumber == NumInstance) {
                pRtnInstance = pInstanceDef;
                break;
            }
            else {
                pInstanceDef = NextInstance(pInstanceDef);
            }
        }
    }
    return pRtnInstance;
}

PPERF_COUNTER_DEFINITION
FirstCounter(
    PPERF_OBJECT_TYPE pObjectDef
)
{
    return (PPERF_COUNTER_DEFINITION) ((LPBYTE) pObjectDef + pObjectDef->HeaderLength);
}

PPERF_COUNTER_DEFINITION
NextCounter(
    PPERF_COUNTER_DEFINITION pCounterDef
)
{
    DWORD dwOffset = pCounterDef->ByteLength;
    return (dwOffset != 0) ? ((PPERF_COUNTER_DEFINITION) (((LPBYTE) pCounterDef) + dwOffset)) : (NULL);
}

LONG
GetSystemPerfData(
    HKEY               hKeySystem,
    PPERF_DATA_BLOCK * pPerfData,
    DWORD              dwIndex       // 0 = Global, 1 = Costly
)
{  // GetSystemPerfData
    LONG  lError = ERROR_SUCCESS;
    BOOL  bAlloc = FALSE;
    DWORD Size;
    DWORD Type;

    if (dwIndex >= 2) {
        lError = ! ERROR_SUCCESS;
    }
    else {
        if (* pPerfData == NULL) {
            * pPerfData = MemoryAllocate(INITIAL_SIZE);
            bAlloc      = TRUE;
            if (* pPerfData == NULL) {
                lError = ERROR_OUTOFMEMORY;
            }
        }

        if (lError == ERROR_SUCCESS) {
            lError = ERROR_MORE_DATA;
            while (lError == ERROR_MORE_DATA) {
                Size = MemorySize(* pPerfData);
                lError = RegQueryValueExW(hKeySystem,
                                          dwIndex == 0 ? L"Global" : L"Costly",
                                          RESERVED,
                                          & Type,
                                          (LPBYTE) * pPerfData,
                                          & Size);
                if (lError == ERROR_MORE_DATA) {
                    PPERF_DATA_BLOCK pTmpBlock = * pPerfData;
                    * pPerfData = MemoryResize(* pPerfData, MemorySize(* pPerfData) + INITIAL_SIZE);
                    bAlloc      = TRUE;
                    if (* pPerfData == NULL) {
                        MemoryFree(pTmpBlock);
                        lError = ERROR_OUTOFMEMORY;
                    }
                }
                else if ((lError == ERROR_SUCCESS) && (Size > 0)
                                                   && ((* pPerfData)->Signature[0] == L'P')
                                                   && ((* pPerfData)->Signature[1] == L'E')
                                                   && ((* pPerfData)->Signature[2] == L'R')
                                                   && ((* pPerfData)->Signature[3] == L'F')) {
                    // does nothing, will break out while loop and return;
                }
                else if (lError == ERROR_SUCCESS) {
                    // RegQueryValueEx() return bogus counter datablock, bail out.
                    lError = ERROR_INVALID_DATA;
                }
            }
        }
    }
    if (lError != ERROR_SUCCESS) {
        if (bAlloc = TRUE && * pPerfData != NULL) {
            MemoryFree(* pPerfData);
            * pPerfData = NULL;
        }
    }
    return (lError);
}  // GetSystemPerfData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\showperf\maindlg.c ===
/*++
Copyright (c) 1994  Microsoft Corporation

Module Name:
    maindlg.c

Abstract:
    Main Dialog procedure for ShowPerf app

Author:
    Bob Watson (a-robw)

Revision History:
    23 Nov 94
--*/
#include <windows.h>
#include <winperf.h>
#include <strsafe.h>
#include "showperf.h"
#include "perfdata.h"
#include "resource.h"

PPERF_DATA_BLOCK   pMainPerfData   = NULL; // pointer to perfdata block
LPWSTR           * szNameTable     = NULL;   // pointer to perf name table
DWORD              dwLastName      = 0;
WCHAR              szComputerName[MAX_COMPUTERNAME_LENGTH + 3];
WCHAR              szThisComputerName[MAX_COMPUTERNAME_LENGTH + 3];
HKEY               hKeyMachine     = NULL;
HKEY               hKeyPerformance = NULL;

#define NUM_TAB_STOPS       3
INT nDataListTabs[NUM_TAB_STOPS] = { 26, 160, 235 };

LPCWSTR cszEmptyString = L"";

BOOL
LoadObjectList(
    HWND    hDlg,
    LPCWSTR szMatchItem
)
{
    PPERF_OBJECT_TYPE  pObject;
    HWND               hWndObjectCB;
    UINT               nInitial     = 0;
    UINT               nIndex;
    WCHAR              szNameBuffer[MAX_PATH];
    DWORD              dwThisObject = 0;
    DWORD              dwCounterType;
    BOOL               bReturn      = TRUE;
    HRESULT            hError;

    hWndObjectCB  = GetDlgItem(hDlg, IDC_OBJECT);
    dwCounterType = (IsDlgButtonChecked(hDlg, IDC_INCLUDE_COSTLY) == CHECKED) ? (1) : (0);

    // get current data block
    if (GetSystemPerfData(hKeyPerformance, & pMainPerfData, dwCounterType) == ERROR_SUCCESS) {
        // data acquired so clear combo and display
        SendMessageW(hWndObjectCB, CB_RESETCONTENT, 0, 0);
        __try {
            pObject = FirstObject(pMainPerfData);
            for (dwThisObject = 0; dwThisObject < pMainPerfData->NumObjectTypes; dwThisObject ++) {
                // get counter object name here...
                hError = StringCchPrintfW(szNameBuffer, RTL_NUMBER_OF(szNameBuffer), L"(%d) %ws",
                                pObject->ObjectNameTitleIndex,
                                pObject->ObjectNameTitleIndex <= dwLastName ?
                                        szNameTable[pObject->ObjectNameTitleIndex] : L"Name not loaded");
                if (SUCCEEDED(hError)) {
                    nIndex = (UINT) SendMessageW(hWndObjectCB, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) szNameBuffer);
                    if (nIndex != CB_ERR) {
                        // save object pointer
                        SendMessageW(hWndObjectCB, CB_SETITEMDATA, (WPARAM) nIndex, (LPARAM) pObject);
                        if (pObject->ObjectNameTitleIndex == (DWORD) pMainPerfData->DefaultObject) {
                            // remember this index to set the default object
                            nInitial = nIndex;
                        }
                    }
                }
                pObject = NextObject(pObject);
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            hError = StringCchPrintfW(szNameBuffer, RTL_NUMBER_OF(szNameBuffer),
                            L"An exception (0x%8.8x) occured in object block # %d returned by the system.",
                            GetExceptionCode (), dwThisObject + 1);
            if (SUCCEEDED(hError)) {
                MessageBoxW(hDlg, szNameBuffer, L"Data Error", MB_OK);
            }
            // update the data buffer so that only the valid objects
            // are accessed in the future.
            pMainPerfData->NumObjectTypes = dwThisObject - 1;
        }
        if (szMatchItem == NULL) {
            SendMessageW(hWndObjectCB, CB_SETCURSEL, (WPARAM) nInitial, 0);
        }
        else {
            // match to arg string as best as possible
            if (SendMessageW(hWndObjectCB, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) szMatchItem) == CB_ERR) {
                    // no match found so use default
                SendMessageW(hWndObjectCB, CB_SETCURSEL, (WPARAM) nInitial, 0);
            }
        }
    }
    else {
        DisplayMessageBox(hDlg, IDS_UNABLE_GET_DATA, IDS_APP_ERROR, MB_OK);
        bReturn = FALSE;
    }
    return bReturn;
}

BOOL
LoadInstanceList(
    HWND    hDlg,
    LPCWSTR szMatchItem
)
{
    PPERF_OBJECT_TYPE         pObject;
    PPERF_OBJECT_TYPE         pParentObject;
    PPERF_COUNTER_BLOCK       pCounterBlock;
    PPERF_INSTANCE_DEFINITION pInstance;
    PPERF_INSTANCE_DEFINITION pParentInstance;
    UINT                      nCbSel;
    LONG                      lThisInstance;
    WCHAR                     szNameBuffer[SMALL_BUFFER_SIZE];
    WCHAR                     szParentName[SMALL_BUFFER_SIZE];
    UINT                      nIndex;
    HRESULT                   hError;

    nCbSel = (UINT) SendDlgItemMessageW(hDlg, IDC_OBJECT, CB_GETCURSEL, 0, 0);
    if (nCbSel != CB_ERR) {
        pObject = (PPERF_OBJECT_TYPE) SendDlgItemMessageW(hDlg, IDC_OBJECT, CB_GETITEMDATA, (WPARAM) nCbSel, 0);
        if (pObject->NumInstances == PERF_NO_INSTANCES) {
            // no instances so...
            // clear old contents
            SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
            // add display text
            SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_INSERTSTRING, (WPARAM)-1, (LPARAM) L"<No Instances>");
            // select this (and only) string
            SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
            // get pointer to counter data
            pCounterBlock = (PPERF_COUNTER_BLOCK) ((LPBYTE) pObject + pObject->DefinitionLength);
            // and save it as item data
            SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_SETITEMDATA, 0, (LPARAM) pCounterBlock);
            // finally grey the window to prevent selections
            EnableWindow(GetDlgItem(hDlg, IDC_INSTANCE), FALSE);
        }
        else {
            //enable window
            EnableWindow(GetDlgItem(hDlg, IDC_INSTANCE), TRUE);
            SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
            pInstance = FirstInstance(pObject);
            for (lThisInstance = 0; lThisInstance < pObject->NumInstances; lThisInstance ++) {
                pParentObject = GetObjectDefByTitleIndex(pMainPerfData, pInstance->ParentObjectTitleIndex);
                if (pParentObject != NULL) {
                    pParentInstance = GetInstance(pParentObject, pInstance->ParentObjectInstance);
                }
                else {
                    pParentInstance = NULL;
                }
                if (pParentInstance != NULL) {
                    if (pParentInstance->UniqueID < 0) {
                        // use the instance name
                        hError = StringCchPrintfW(szParentName, RTL_NUMBER_OF(szParentName), L"%ws==>",
                                         (LPWSTR) ((LPBYTE) pParentInstance+pParentInstance->NameOffset));
                    }
                    else {
                        // use the instance number
                        hError = StringCchPrintfW(szParentName, RTL_NUMBER_OF(szParentName), L"[%d]==>",
                                         pParentInstance->UniqueID);
                    }
                }
                else {
                    // unknown parent
                    * szParentName = L'\0';
                }
                ZeroMemory(szNameBuffer, sizeof(szNameBuffer));
                if (pInstance->UniqueID < 0) {
                    // use the instance name
                    hError = StringCchCopyW(szNameBuffer,
                                            RTL_NUMBER_OF(szNameBuffer),
                                            (LPWSTR) ((LPBYTE)pInstance+pInstance->NameOffset));
                }
                else {
                    // use the instance number
                    hError = StringCchPrintfW(szNameBuffer, RTL_NUMBER_OF(szNameBuffer), L"(%d)", pInstance->UniqueID);
                }
                hError = StringCchCatW(szParentName, RTL_NUMBER_OF(szNameBuffer), szNameBuffer);
                nIndex = (UINT) SendDlgItemMessageW(
                                hDlg, IDC_INSTANCE, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) szParentName);
                if (nIndex != CB_ERR) {
                    // save pointer to counter block
                    pCounterBlock = (PPERF_COUNTER_BLOCK) ((LPBYTE) pInstance + pInstance->ByteLength);
                    SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_SETITEMDATA, (WPARAM) nIndex, (LPARAM) pCounterBlock);
                }
                pInstance = NextInstance(pInstance);
            }
            if (szMatchItem == NULL) {
                SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
            }
            else {
                if (SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) szMatchItem)
                                == CB_ERR) {
                    SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
                }
            }
        }
    }
    else {
        // no object selected
        // clear old contents
        SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
        // add display text
        SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) L"<No object selected>");
        // select this (and only) string
        SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
        // and save null pointer as item data
        SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_SETITEMDATA, 0, (LPARAM) 0);
        // finally grey the window to prevent selections
        EnableWindow(GetDlgItem(hDlg, IDC_INSTANCE), FALSE);
    }
    return TRUE;
}

LPCWSTR
GetCounterTypeName(
    DWORD dwCounterType
)
{
    UINT    nTypeString = 0;
    LPCWSTR szReturn    = NULL;

    switch (dwCounterType) {
    case PERF_COUNTER_COUNTER:
        nTypeString = IDS_TYPE_COUNTER_COUNTER;
        break;

    case PERF_COUNTER_TIMER:
        nTypeString = IDS_TYPE_COUNTER_TIMER;
        break;

    case PERF_COUNTER_QUEUELEN_TYPE:
        nTypeString = IDS_TYPE_COUNTER_QUEUELEN;
        break;

    case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
        nTypeString = IDS_TYPE_COUNTER_LARGE_QUEUELEN;
        break;

    case PERF_COUNTER_100NS_QUEUELEN_TYPE:
        nTypeString = IDS_TYPE_COUNTER_100NS_QUEUELEN;
        break;

    case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
        nTypeString = IDS_TYPE_COUNTER_OBJ_TIME_QUEUELEN;
        break;

    case PERF_COUNTER_BULK_COUNT:
        nTypeString = IDS_TYPE_COUNTER_BULK_COUNT;
        break;

    case PERF_COUNTER_TEXT:
        nTypeString = IDS_TYPE_COUNTER_TEXT;
        break;

    case PERF_COUNTER_RAWCOUNT:
        nTypeString = IDS_TYPE_COUNTER_RAWCOUNT;
        break;

    case PERF_COUNTER_LARGE_RAWCOUNT:
        nTypeString = IDS_TYPE_COUNTER_LARGE_RAW;
        break;

    case PERF_COUNTER_RAWCOUNT_HEX:
        nTypeString = IDS_TYPE_COUNTER_RAW_HEX;
        break;

    case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
        nTypeString = IDS_TYPE_COUNTER_LARGE_RAW_HEX;
        break;

    case PERF_SAMPLE_FRACTION:
        nTypeString = IDS_TYPE_SAMPLE_FRACTION;
        break;

    case PERF_SAMPLE_COUNTER:
        nTypeString = IDS_TYPE_SAMPLE_COUNTER;
        break;

    case PERF_COUNTER_NODATA:
        nTypeString = IDS_TYPE_COUNTER_NODATA;
        break;

    case PERF_COUNTER_TIMER_INV:
        nTypeString = IDS_TYPE_COUNTER_TIMER_INV;
        break;

    case PERF_SAMPLE_BASE:
        nTypeString = IDS_TYPE_SAMPLE_BASE;
        break;

    case PERF_AVERAGE_TIMER:
        nTypeString = IDS_TYPE_AVERAGE_TIMER;
        break;

    case PERF_AVERAGE_BASE:
        nTypeString = IDS_TYPE_AVERAGE_BASE;
        break;

    case PERF_AVERAGE_BULK:
        nTypeString = IDS_TYPE_AVERAGE_BULK;
        break;

    case PERF_OBJ_TIME_TIMER:
        nTypeString = IDS_TYPE_OBJ_TIME_TIMER;
        break;

    case PERF_100NSEC_TIMER:
        nTypeString = IDS_TYPE_100NS_TIMER;
        break;

    case PERF_100NSEC_TIMER_INV:
        nTypeString = IDS_TYPE_100NS_TIMER_INV;
        break;

    case PERF_COUNTER_MULTI_TIMER:
        nTypeString = IDS_TYPE_MULTI_TIMER;
        break;

    case PERF_COUNTER_MULTI_TIMER_INV:
        nTypeString = IDS_TYPE_MULTI_TIMER_INV;
        break;

    case PERF_COUNTER_MULTI_BASE:
        nTypeString = IDS_TYPE_MULTI_BASE;
        break;

    case PERF_100NSEC_MULTI_TIMER:
        nTypeString = IDS_TYPE_100NS_MULTI_TIMER;
        break;

    case PERF_100NSEC_MULTI_TIMER_INV:
        nTypeString = IDS_TYPE_100NS_MULTI_TIMER_INV;
        break;

    case PERF_RAW_FRACTION:
        nTypeString = IDS_TYPE_RAW_FRACTION;
        break;

    case PERF_LARGE_RAW_FRACTION:
        nTypeString = IDS_TYPE_LARGE_RAW_FRACTION;
        break;

    case PERF_RAW_BASE:
        nTypeString = IDS_TYPE_RAW_BASE;
        break;

    case PERF_LARGE_RAW_BASE:
        nTypeString = IDS_TYPE_LARGE_RAW_BASE;
        break;

    case PERF_ELAPSED_TIME:
        nTypeString = IDS_TYPE_ELAPSED_TIME;
        break;

    case PERF_COUNTER_HISTOGRAM_TYPE:
        nTypeString = IDS_TYPE_HISTOGRAM;
        break;

    case PERF_COUNTER_DELTA:
        nTypeString = IDS_TYPE_COUNTER_DELTA;
        break;

    case PERF_COUNTER_LARGE_DELTA:
        nTypeString = IDS_TYPE_COUNTER_LARGE_DELTA;
        break;

    case PERF_PRECISION_SYSTEM_TIMER:
        nTypeString = IDS_TYPE_PRECISION_SYSTEM_TIMER;
        break;

    case PERF_PRECISION_100NS_TIMER:
        nTypeString = IDS_TYPE_PRECISION_100NS_TIMER;
        break;

    case PERF_PRECISION_OBJECT_TIMER:
        nTypeString = IDS_TYPE_PRECISION_OBJECT_TIMER;
        break;

    default:
        nTypeString = 0;
        break;
    }

    if (nTypeString != 0) {
        szReturn = GetStringResource(NULL, nTypeString);
    }
    if (szReturn == NULL) {
        szReturn = cszEmptyString;
    }
    return szReturn;
}

BOOL
ShowCounterData(
    HWND hDlg,
    LONG lDisplayIndex
)
{
    PPERF_OBJECT_TYPE        pObject;
    PPERF_COUNTER_DEFINITION pCounterDef;
    PPERF_COUNTER_BLOCK      pCounterBlock;
    UINT                     nSelObject, nSelInstance;
    WCHAR                    szTypeNameBuffer[MAX_PATH];
    WCHAR                    szDisplayBuffer[SMALL_BUFFER_SIZE];
    DWORD                    * pdwLoDword, * pdwHiDword;
    DWORD                    dwThisCounter;
    HRESULT                  hError;

    SendDlgItemMessageW(hDlg, IDC_DATA_LIST, LB_RESETCONTENT, 0, 0);
    nSelObject   = (UINT) SendDlgItemMessageW(hDlg, IDC_OBJECT,   CB_GETCURSEL, 0, 0);
    nSelInstance = (UINT) SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_GETCURSEL, 0, 0);
    if ((nSelObject != CB_ERR) && (nSelInstance != CB_ERR)) {
        pObject       = (PPERF_OBJECT_TYPE)
                        SendDlgItemMessageW(hDlg, IDC_OBJECT, CB_GETITEMDATA, (WPARAM) nSelObject, 0);
        pCounterBlock = (PPERF_COUNTER_BLOCK)
                        SendDlgItemMessageW(hDlg, IDC_INSTANCE, CB_GETITEMDATA, (WPARAM) nSelInstance, 0);

        pCounterDef   = FirstCounter(pObject);

        for (dwThisCounter = 0; dwThisCounter < pObject->NumCounters; dwThisCounter ++) {
            // get pointer to this counter's data (in this instance if applicable
            pdwLoDword = (PDWORD) ((LPBYTE) pCounterBlock + pCounterDef->CounterOffset);
            pdwHiDword = pdwLoDword + 1;

            hError = StringCchCopyW(szTypeNameBuffer,
                                    RTL_NUMBER_OF(szTypeNameBuffer),
                                    GetCounterTypeName(pCounterDef->CounterType));
            if (* szTypeNameBuffer == L'\0') {
                // no string returned so format data as HEX DWORD
                hError = StringCchPrintfW(szTypeNameBuffer, RTL_NUMBER_OF(szTypeNameBuffer), L"Undefined Type: 0x%8.8x",
                                pCounterDef->CounterType);
            }
            if (pCounterDef->CounterSize <= sizeof(DWORD)) {
                hError = StringCchPrintfW(szDisplayBuffer, RTL_NUMBER_OF(szDisplayBuffer),
                        L"%d\t%ws\t%ws\t0x%8.8x (%d)",
                        pCounterDef->CounterNameTitleIndex,
                        pCounterDef->CounterNameTitleIndex <= dwLastName ?
                                szNameTable[pCounterDef->CounterNameTitleIndex] : L"Name not loaded",
                        szTypeNameBuffer,
                        * pdwLoDword, * pdwLoDword);
            }
            else {
                hError = StringCchPrintfW(szDisplayBuffer, RTL_NUMBER_OF(szDisplayBuffer),
                        L"%d\t%ws\t%ws\t0x%8.8x%8.8x",
                        pCounterDef->CounterNameTitleIndex,
                        pCounterDef->CounterNameTitleIndex <= dwLastName ?
                                szNameTable[pCounterDef->CounterNameTitleIndex] : L"Name not loaded",
                        szTypeNameBuffer,
                        * pdwHiDword, * pdwLoDword);
            }
            SendDlgItemMessageW(hDlg, IDC_DATA_LIST, LB_INSERTSTRING, (WPARAM) -1, (LPARAM) szDisplayBuffer);
            pCounterDef = NextCounter(pCounterDef);
        }
        if (lDisplayIndex < 0) {
            if (pObject->DefaultCounter >= 0) {
                SendDlgItemMessageW(hDlg, IDC_DATA_LIST, LB_SETCURSEL, (WPARAM) pObject->DefaultCounter, 0);
            }
            else {
                SendDlgItemMessageW(hDlg, IDC_DATA_LIST, LB_SETCURSEL, (WPARAM) 0, 0);
            }
        }
        else {
            SendDlgItemMessageW(hDlg, IDC_DATA_LIST, LB_SETCURSEL, (WPARAM) lDisplayIndex, (LPARAM) 0);
        }
    }
    else {
        // no object and/or instsance selected so nothing else to do
    }
    return TRUE;
}

BOOL
OnComputerChange(
    HWND hDlg
)
{
    WCHAR   szLocalComputerName[MAX_COMPUTERNAME_LENGTH + 3];
    HKEY    hLocalMachineKey  = NULL;
    HKEY    hLocalPerfKey     = NULL;
    LPWSTR  *szLocalNameTable = NULL;
    BOOL    bResult           = FALSE;
    HWND    hWndComputerName;
    HRESULT hError;

    SET_WAIT_CURSOR;

    // get name from edit control
    hWndComputerName = GetDlgItem(hDlg, IDC_COMPUTERNAME);

    GetWindowTextW(hWndComputerName, szLocalComputerName, MAX_COMPUTERNAME_LENGTH + 2);
    if (lstrcmpiW(szComputerName, szLocalComputerName) != 0) {
        // a new name has been entered so try to connect to it
        if (lstrcmpiW(szLocalComputerName, szThisComputerName) == 0) {
            // then this is the local machine which is a special case
            hLocalMachineKey = HKEY_LOCAL_MACHINE;
            hLocalPerfKey    = HKEY_PERFORMANCE_DATA;
            szLocalComputerName[0] = L'\0';
        }
        else {
            // try to connect to remote computer
            if (RegConnectRegistryW(szLocalComputerName, HKEY_LOCAL_MACHINE, & hLocalMachineKey)
                            == ERROR_SUCCESS) {
                // connected to the new machine, so Try to connect to
                // the performance data, too
                if (RegConnectRegistryW(szLocalComputerName, HKEY_PERFORMANCE_DATA, & hLocalPerfKey)
                                != ERROR_SUCCESS) {
                    DisplayMessageBox(hDlg, IDS_UNABLE_CONNECT_PERF, IDS_APP_ERROR, MB_OK);
                }
            }
            else {
                DisplayMessageBox(hDlg, IDS_UNABLE_CONNECT_MACH, IDS_APP_ERROR, MB_OK);
            }
        }
        if ((hLocalMachineKey != NULL) && (hLocalPerfKey != NULL)) {
            // try to get a new name table
            szLocalNameTable = BuildNameTable(
                    (szLocalComputerName == NULL ? NULL : szLocalComputerName), NULL, & dwLastName);
            if (szLocalNameTable != NULL) {
                bResult = TRUE;
            }
            else {
                DisplayMessageBox(hDlg, IDS_UNABLE_GET_NAMES, IDS_APP_ERROR, MB_OK);
            }
        }

        if (bResult) {
            // made it so close the old connections
            if (hKeyMachine != NULL && hKeyMachine != HKEY_LOCAL_MACHINE) {
                RegCloseKey(hKeyMachine);
            }
            hKeyMachine = hLocalMachineKey;

            if (hKeyPerformance != NULL && hKeyPerformance != HKEY_PERFORMANCE_DATA) {
                RegCloseKey(hKeyPerformance);
            }
            hKeyPerformance = hLocalPerfKey;

            MemoryFree(szNameTable);
            szNameTable = szLocalNameTable;

            if (szLocalComputerName[0] == L'\0') {
                hError = StringCchCopyW(szComputerName, MAX_COMPUTERNAME_LENGTH + 3, szThisComputerName);
            }

            // then update the fields
            bResult = LoadObjectList(hDlg, NULL);
            if (bResult) {
                LoadInstanceList(hDlg, NULL);
                ShowCounterData(hDlg, -1);
            }
        }
        else {
            // unable to get info from machine so clean up
            if (hLocalPerfKey    != NULL && hLocalPerfKey    != HKEY_PERFORMANCE_DATA) RegCloseKey(hLocalPerfKey);
            if (hLocalMachineKey != NULL && hLocalMachineKey != HKEY_LOCAL_MACHINE)    RegCloseKey(hLocalMachineKey);
            MemoryFree(szLocalNameTable);
            // reset computer name to the one that works.
            SetWindowTextW(hWndComputerName, szComputerName);
        }
    }
    else {
        // the name hasn't changed
    }

    return TRUE;
}

BOOL
MainDlg_WM_INITDIALOG(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    DWORD   dwComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    HRESULT hError;

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);

    SET_WAIT_CURSOR;

    hError = StringCchCopyW(szThisComputerName, MAX_COMPUTERNAME_LENGTH + 3, L"\\\\");
    GetComputerNameW(szThisComputerName + 2, & dwComputerNameLength);
    szComputerName[0] = L'\0';  // reset the computer name
    // load the local machine name into the edit box
    SetWindowTextW(GetDlgItem(hDlg, IDC_COMPUTERNAME), szThisComputerName);

    SendDlgItemMessageW(hDlg, IDC_DATA_LIST, LB_SETTABSTOPS, (WPARAM) NUM_TAB_STOPS, (LPARAM) & nDataListTabs);
    CheckDlgButton(hDlg, IDC_INCLUDE_COSTLY, UNCHECKED);
    OnComputerChange(hDlg);
    SetFocus(GetDlgItem(hDlg, IDC_OBJECT));

    SET_ARROW_CURSOR;
    return FALSE;
}

BOOL
MainDlg_IDC_COMPUTERNAME(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
{
    BOOL bReturn = FALSE;
    UNREFERENCED_PARAMETER(hWndControl);

    switch (wNotifyMsg) {
    case EN_KILLFOCUS:
        OnComputerChange(hDlg);
        bReturn = TRUE;
        break;

    default:
        bReturn = FALSE;
        break;
    }
    return bReturn;
}

BOOL
MainDlg_IDC_OBJECT(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
{
    BOOL bReturn = FALSE;
    UNREFERENCED_PARAMETER(hWndControl);

    switch (wNotifyMsg) {
    case CBN_SELCHANGE:
        SET_WAIT_CURSOR;
        if (pMainPerfData) {
            LoadInstanceList(hDlg, NULL);
            ShowCounterData(hDlg, -1);
        }
        SET_ARROW_CURSOR;
        bReturn = TRUE;
        break;

    default:
        bReturn = FALSE;
        break;
    }
    return bReturn;
}

BOOL
MainDlg_IDC_INSTANCE(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
{
    BOOL bReturn = FALSE;
    UNREFERENCED_PARAMETER(hWndControl);

    switch (wNotifyMsg) {
    case CBN_SELCHANGE:
        SET_WAIT_CURSOR;
        ShowCounterData(hDlg, -1);
        SET_ARROW_CURSOR;
        bReturn = TRUE;
        break;

    default:
        bReturn = FALSE;
        break;
    }
    return bReturn;
}

BOOL
MainDlg_IDC_DATA_LIST(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
{
    UNREFERENCED_PARAMETER(hDlg);
    UNREFERENCED_PARAMETER(wNotifyMsg);
    UNREFERENCED_PARAMETER(hWndControl);
    return (FALSE);
}

BOOL
MainDlg_IDC_REFRESH(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
{
    WCHAR szSelObject[MAX_PATH + 1];
    WCHAR szSelInstance[MAX_PATH + 1];
    BOOL  bResult;
    LONG  lCounterIdx;
    BOOL  bReturn = FALSE;

    UNREFERENCED_PARAMETER(hWndControl);

    switch (wNotifyMsg) {
    case BN_CLICKED:
        SET_WAIT_CURSOR;
        GetDlgItemTextW(hDlg, IDC_OBJECT,   szSelObject,   RTL_NUMBER_OF(szSelObject));
        GetDlgItemTextW(hDlg, IDC_INSTANCE, szSelInstance, RTL_NUMBER_OF(szSelInstance));
        lCounterIdx = (ULONG) SendDlgItemMessageW(hDlg, IDC_DATA_LIST, LB_GETCURSEL, 0, 0);

        bResult = LoadObjectList(hDlg, szSelObject);
        if (bResult) {
            LoadInstanceList(hDlg, szSelInstance);
            ShowCounterData(hDlg, lCounterIdx);
        }
        SET_ARROW_CURSOR;
        bReturn = TRUE;
        break;

    default:
        bReturn = FALSE;
        break;
    }
    return bReturn;
}

BOOL
MainDlg_IDC_ABOUT()
{
    WCHAR   buffer[SMALL_BUFFER_SIZE];
    WCHAR   strProgram[SMALL_BUFFER_SIZE];
    DWORD   dw;
    LPBYTE  pVersionInfo = NULL;
    LPWSTR  pVersion     = NULL;
    LPWSTR  pProduct     = NULL;
    LPWSTR  pCopyRight   = NULL;
    HRESULT hError;

    ZeroMemory(buffer, sizeof(buffer));
    ZeroMemory(strProgram, sizeof(strProgram));
    dw = GetModuleFileNameW(NULL, strProgram, RTL_NUMBER_OF(strProgram) - 1);
    if(dw > 0) {
        dw = GetFileVersionInfoSizeW(strProgram, & dw);
        if (dw > 0) {
            pVersionInfo = (LPBYTE) MemoryAllocate(dw);
            if(NULL != pVersionInfo) {
                if (GetFileVersionInfoW(strProgram, 0, dw, pVersionInfo)) {
                    LPDWORD lptr = NULL;
                    VerQueryValueW(pVersionInfo, L"\\VarFileInfo\\Translation", (void **) & lptr, (UINT *) & dw);
                    if (lptr != NULL) {
                        hError = StringCchPrintfW(buffer, RTL_NUMBER_OF(buffer),
                                        L"\\StringFileInfo\\%04x%04x\\ProductVersion",
                                        LOWORD(* lptr), HIWORD(* lptr));
                        VerQueryValueW(pVersionInfo, buffer, (void **) & pVersion, (UINT *) & dw);

                        hError = StringCchPrintfW(buffer, RTL_NUMBER_OF(buffer),
                                        L"\\StringFileInfo\\%04x%04x\\OriginalFilename",
                                        LOWORD(* lptr), HIWORD(* lptr));
                        VerQueryValueW(pVersionInfo, buffer, (void **) & pProduct, (UINT *) & dw);

                        hError = StringCchPrintfW(buffer, RTL_NUMBER_OF(buffer),
                                        L"\\StringFileInfo\\%04x%04x\\LegalCopyright",
                                        LOWORD(* lptr), HIWORD(* lptr));
                        VerQueryValueW(pVersionInfo, buffer, (void **) & pCopyRight, (UINT *) & dw);
                    }
                
                    if(pProduct != NULL && pVersion != NULL && pCopyRight != NULL) {
                        hError = StringCchPrintfW(buffer, RTL_NUMBER_OF(buffer),
                                        L"\nMicrosoft (R) %ws\nVersion: %ws\n%ws",
                                        pProduct, pVersion, pCopyRight);
                    }
                }
                MemoryFree(pVersionInfo);
            }
        }
    }
    MessageBoxW(NULL, buffer, L"About ShowPerf", MB_OK);
    return TRUE;
}

BOOL
MainDlg_WM_COMMAND(
    HWND   hDlg,
    WPARAM wParam,
    LPARAM lParam
)
{
    WORD wCtrlId     = GET_CONTROL_ID(wParam);
    WORD wNotifyMsg  = GET_NOTIFY_MSG(wParam, lParam);
    HWND hWndControl = GET_COMMAND_WND(lParam);
    BOOL bReturn     = FALSE;


    switch (wCtrlId) {
    case IDC_COMPUTERNAME:
        bReturn = MainDlg_IDC_COMPUTERNAME(hDlg, wNotifyMsg, hWndControl);
        break;

    case IDC_OBJECT:
        bReturn = MainDlg_IDC_OBJECT(hDlg, wNotifyMsg, hWndControl);
        break;

    case IDC_INSTANCE:
        bReturn = MainDlg_IDC_INSTANCE(hDlg, wNotifyMsg, hWndControl);
        break;

    case IDC_DATA_LIST:
        bReturn = MainDlg_IDC_DATA_LIST(hDlg, wNotifyMsg, hWndControl);
        break;

    case IDC_REFRESH:
        bReturn = MainDlg_IDC_REFRESH(hDlg, wNotifyMsg, hWndControl);
        break;

    case IDC_ABOUT:
        bReturn = MainDlg_IDC_ABOUT();
        break;

    case IDOK:
        EndDialog(hDlg, IDOK);
        bReturn = TRUE;
        break;

    default:
        bReturn = FALSE;
        break;
    }
    return bReturn;
}

BOOL
MainDlg_WM_SYSCOMMAND(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL bReturn = FALSE;
    UNREFERENCED_PARAMETER(lParam);

    switch (wParam) {
    case SC_CLOSE:
        EndDialog(hDlg, IDOK);
        bReturn = TRUE;
        break;

    default:
        bReturn = FALSE;
        break;
    }
    return bReturn;
}

BOOL
MainDlg_WM_CLOSE(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hDlg);

    MemoryFree(pMainPerfData);
    pMainPerfData = NULL;
    MemoryFree(szNameTable);
    szNameTable = NULL;
    return TRUE;
}

INT_PTR
MainDlgProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
)
{
    BOOL bReturn = FALSE;
    switch (message) {
    case WM_INITDIALOG:
        bReturn = MainDlg_WM_INITDIALOG(hDlg, wParam, lParam);
        break;

    case WM_COMMAND:
        bReturn = MainDlg_WM_COMMAND(hDlg, wParam, lParam);
        break;

    case WM_SYSCOMMAND:
        bReturn = MainDlg_WM_SYSCOMMAND(hDlg, wParam, lParam);
        break;

    case WM_CLOSE:
        bReturn = MainDlg_WM_CLOSE(hDlg, wParam, lParam);
        break;

    default:
        bReturn = FALSE;
        break;
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\showperf\mainwnd.c ===
/*++
Copyright (c) 1994  Microsoft Corporation

Module Name:
    mainwnd.c

Abstract:
    Main Window procedure for ShowPerf app

Author:
    Bob Watson (a-robw)

Revision History:
    23 Nov 94
--*/
#include <windows.h>
#include "resource.h"
#include "SHOWPERF.h"
//
//  GLOBAL functions
//
LRESULT CALLBACK
MainWndProc(
    HWND   hWnd,       // window handle
    UINT   message,    // type of message
    WPARAM wParam,     // additional information
    LPARAM lParam      // additional information
)
/*++
Routine Description:
    Windows Message processing routine for restkeys application.

Arguments:
    Standard WNDPROC api arguments

ReturnValue:
    0   or
    value returned by DefWindowProc
--*/
{
    LRESULT lResult = ERROR_SUCCESS;
    switch (message) {
    case WM_CLOSE:
        DestroyWindow(hWnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(ERROR_SUCCESS);
        break;

    default:
        lResult = DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }
    return lResult;
}

BOOL
RegisterMainWindowClass(
    HINSTANCE   hInstance
)
/*++
Routine Description:
    Registers the main window class for this application

Arguments:
    hInstance   application instance handle

Return Value:
    Return value of RegisterClass function
--*/
{
    WNDCLASSW wc;

    // Fill in window class structure with parameters that describe the
    // main window.
    wc.style         = CS_HREDRAW | CS_VREDRAW;     // Class style(s).
    wc.lpfnWndProc   = MainWndProc;                 // Window Procedure
    wc.cbClsExtra    = 0;                           // No per-class extra data.
    wc.cbWndExtra    = 0;                           // no extra data bytes.
    wc.hInstance     = hInstance;                   // Owner of this class
    wc.hIcon         = NULL;                        // No Icon
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); // Cursor
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1); // Default color
    wc.lpszMenuName  = NULL;                        // No Menu
    wc.lpszClassName = GetStringResource(hInstance, IDS_APP_WINDOW_CLASS); // Name to register as

    // Register the window class and return success/failure code.
    return (BOOL) RegisterClassW(& wc);
}

HWND
CreateMainWindow(
    HINSTANCE hInstance
)
{
    HWND hWnd;      // return value
    RECT rDesktop;  // desktop window
    
    GetWindowRect(GetDesktopWindow(), & rDesktop);

    // Create a main window for this application instance.
    hWnd = CreateWindowExW(
            0L,                                                 // make this window normal so debugger isn't covered
            GetStringResource(hInstance, IDS_APP_WINDOW_CLASS), // See RegisterClass() call.
            GetStringResource(hInstance, IDS_APP_TITLE),        // Text for window title bar.
            (DWORD) (WS_OVERLAPPEDWINDOW),                      // Window style.
            rDesktop.right + 1,                                 // position window off desktop
            rDesktop.bottom + 1,
            1,
            1,
            (HWND) NULL,                                        // Overlapped windows have no parent.
            (HMENU) NULL,                                       // use class menu
            hInstance,                                          // This instance owns this window.
            NULL                                                // not used
    );

    // If window could not be created, return "failure"
    if (hWnd != NULL) {
        DialogBox(hInstance, MAKEINTRESOURCE(IDD_MAIN), hWnd, MainDlgProc);
        PostMessage(hWnd, WM_CLOSE, 0, 0); // pack up and leave
    }
    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\showperf\perfdata.h ===
/*++
Copyright (c) 1993  Microsoft Corporation

Module Name:
    PerfData.H

Abstract:

Author:
    Bob Watson (a-robw)

Revision History:
    23 NOV 94
--*/

#ifndef _PERFDATA_H_
#define _PERFDATA_H_

#define INITIAL_SIZE 32768L
#define RESERVED         0L

typedef LPVOID  LPMEMORY;
typedef HGLOBAL HMEMORY;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;
//#define UNICODE_NULL ((WCHAR) 0) // winnt

LPWSTR
* BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from 
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
);

PPERF_OBJECT_TYPE
FirstObject(
    PPERF_DATA_BLOCK pPerfData
);

PPERF_OBJECT_TYPE
NextObject(
    PPERF_OBJECT_TYPE pObject
);

PPERF_OBJECT_TYPE
GetObjectDefByTitleIndex(
    PPERF_DATA_BLOCK pDataBlock,
    DWORD            ObjectTypeTitleIndex
);

PPERF_INSTANCE_DEFINITION
FirstInstance(
    PPERF_OBJECT_TYPE pObjectDef
);

PPERF_INSTANCE_DEFINITION
NextInstance(
    PPERF_INSTANCE_DEFINITION pInstDef
);

PPERF_INSTANCE_DEFINITION
GetInstance(
    PPERF_OBJECT_TYPE pObjectDef,
    LONG              InstanceNumber
);

PPERF_COUNTER_DEFINITION
FirstCounter(
    PPERF_OBJECT_TYPE pObjectDef
);

PPERF_COUNTER_DEFINITION
NextCounter(
    PPERF_COUNTER_DEFINITION pCounterDef
);

LONG
GetSystemPerfData(
    HKEY               hKeySystem,
    PPERF_DATA_BLOCK * pPerfData,
    DWORD              dwIndex       // 0 = Global, 1 = Costly
);
#endif //_PERFDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\idl\makefile.inc ===
$(O)\imports.h: ..\imports.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\showperf\resource.h ===
#define IDC_STATIC                            -1
#define IDD_MAIN                             100
#define IDC_OBJECT                          1001
#define IDC_INSTANCE                        1002
#define IDC_DATA_LIST                       1003
#define IDC_REFRESH                         1004
#define IDC_INCLUDE_COSTLY                  1005
#define IDC_ABOUT                           1111
#define IDH_CONTENTS                       10000
#define IDI_APP_ICON                       11000
#define IDS_APP_TITLE                      20001
#define IDS_APP_ERROR                      20003
#define IDS_APP_WINDOW_CLASS               20006
#define IDS_HELP_FILENAME                  20007
#define IDS_UNABLE_GET_DATA                20009
#define IDS_UNABLE_CONNECT_PERF            20010
#define IDS_UNABLE_CONNECT_MACH            20011
#define IDS_UNABLE_GET_NAMES               20012
#define IDS_TYPE_COUNTER_COUNTER           20101
#define IDS_TYPE_COUNTER_TIMER             20102
#define IDS_TYPE_COUNTER_QUEUELEN          20103
#define IDS_TYPE_COUNTER_BULK_COUNT        20104
#define IDS_TYPE_COUNTER_TEXT              20105
#define IDS_TYPE_COUNTER_RAWCOUNT          20106
#define IDS_TYPE_COUNTER_LARGE_RAW         20107
#define IDS_TYPE_SAMPLE_FRACTION           20108
#define IDS_TYPE_SAMPLE_COUNTER            20109
#define IDS_TYPE_COUNTER_NODATA            20110
#define IDS_TYPE_COUNTER_TIMER_INV         20111
#define IDS_TYPE_SAMPLE_BASE               20112
#define IDS_TYPE_AVERAGE_TIMER             20113
#define IDS_TYPE_AVERAGE_BASE              20114
#define IDS_TYPE_AVERAGE_BULK              20115
#define IDS_TYPE_100NS_TIMER               20116
#define IDS_TYPE_100NS_TIMER_INV           20117
#define IDS_TYPE_MULTI_TIMER               20118
#define IDS_TYPE_MULTI_TIMER_INV           20119
#define IDS_TYPE_MULTI_BASE                20120
#define IDS_TYPE_100NS_MULTI_TIMER         20121
#define IDS_TYPE_100NS_MULTI_TIMER_INV     20122
#define IDS_TYPE_RAW_FRACTION              20123
#define IDS_TYPE_RAW_BASE                  20124
#define IDS_TYPE_ELAPSED_TIME              20125
#define IDS_TYPE_HISTOGRAM                 20126
#define IDS_TYPE_COUNTER_LARGE_QUEUELEN    20127
#define IDS_TYPE_COUNTER_DELTA             20128
#define IDS_TYPE_COUNTER_LARGE_DELTA       20129
#define IDS_TYPE_COUNTER_100NS_QUEUELEN    20130
#define IDS_TYPE_COUNTER_OBJ_TIME_QUEUELEN 20131
#define IDS_TYPE_COUNTER_RAW_HEX           20132
#define IDS_TYPE_COUNTER_LARGE_RAW_HEX     20133
#define IDS_TYPE_OBJ_TIME_TIMER            20134
#define IDS_TYPE_LARGE_RAW_FRACTION        20135
#define IDS_TYPE_LARGE_RAW_BASE            20136
#define IDS_TYPE_PRECISION_SYSTEM_TIMER    20137
#define IDS_TYPE_PRECISION_100NS_TIMER     20138
#define IDS_TYPE_PRECISION_OBJECT_TIMER    20139
#define IDD_COUNTER_DETAILS                  200
#define IDC_COUNTER                          202
#define IDC_COUNTER_NAME_TITLE_INDEX        1006
#define IDC_COUNTER_NAME_TEXT               1007
#define IDC_COUNTER_HELP_TITLE_INDEX        1009
#define IDC_EXPLAIN_TEXT                    1010
#define IDC_DEFAULT_SCALE                   1011
#define IDC_DEFAULT_SCALE_FACTOR            1012
#define IDC_COUNTER_DETAIL_LEVEL            1013
#define IDC_COUNTER_SIZE                    1014
#define IDC_COUNTER_VALUE                   1015
#define IDC_COMPUTERNAME                    1016
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\unlodctr\unlodctr.c ===
/*++
Copyright (c) 1991-1993  Microsoft Corporation

Module Name:
    unlodctr.c

Abstract:
    Program to remove the counter names belonging to the driver specified
        in the command line and update the registry accordingly

Author:
    Bob Watson (a-robw) 12 Feb 93

Revision History:
--*/

//  Windows Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <locale.h>
#include "strsafe.h"
#include <loadperf.h>

////////////////////////////////////////////////////////////////////////////
//
//  MySetThreadUILanguage
//
//  This routine sets the thread UI language based on the console codepage.
//
//  9-29-00    WeiWu    Created.
//  Copied from Base\Win32\Winnls so that it works in W2K as well
////////////////////////////////////////////////////////////////////////////
LANGID WINAPI MySetThreadUILanguage(WORD wReserved)
{
    //  Cache system locale and CP info
    // 
    static LCID    s_lidSystem  = 0;
    static UINT    s_uiSysCp    = 0;
    static UINT    s_uiSysOEMCp = 0;
    ULONG          uiUserUICp;
    ULONG          uiUserUIOEMCp;
    WCHAR          szData[16];
    UNICODE_STRING ucStr;
    LANGID         lidUserUI     = GetUserDefaultUILanguage();
    LCID           lcidThreadOld = GetThreadLocale();

    //
    //  Set default thread locale to EN-US
    //
    //  This allow us to fall back to English UI to avoid trashed characters 
    //  when console doesn't meet the criteria of rendering native UI.
    //
    LCID lcidThread = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
    UINT uiConsoleCp = GetConsoleOutputCP();

    //
    //  Make sure nobody uses it yet
    //
    ASSERT(wReserved == 0);

    //
    //  Get cached system locale and CP info.
    //
    if (!s_uiSysCp) {
        LCID lcidSystem = GetSystemDefaultLCID();
        if (lcidSystem) {
            //
            // Get ANSI CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            RtlInitUnicodeString(& ucStr, szData);
            RtlUnicodeStringToInteger(& ucStr, 10, &uiUserUICp);

            //
            // Get OEM CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            RtlInitUnicodeString(& ucStr, szData);
            RtlUnicodeStringToInteger(& ucStr, 10, &s_uiSysOEMCp);
            
            //
            // Cache system primary langauge
            //
            s_lidSystem = PRIMARYLANGID(LANGIDFROMLCID(lcidSystem));
        }
    }
    //
    //  Don't cache user UI language and CP info, UI language can be changed without system reboot.
    //
    if (lidUserUI) {
        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        RtlInitUnicodeString(& ucStr, szData);
        RtlUnicodeStringToInteger(& ucStr, 10, & uiUserUICp);
        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        RtlInitUnicodeString(& ucStr, szData);
        RtlUnicodeStringToInteger(& ucStr, 10, &uiUserUIOEMCp);
    }
    //
    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
    //
    if (uiConsoleCp &&  s_lidSystem != LANG_ARABIC &&  s_lidSystem != LANG_HEBREW &&
                        s_lidSystem != LANG_VIETNAMESE &&  s_lidSystem != LANG_THAI) {
        //
        //  Use UI language for console only when console CP, system CP and UI language CP match.
        //
        if ((uiConsoleCp == s_uiSysCp || uiConsoleCp == s_uiSysOEMCp) && 
                (uiConsoleCp == uiUserUICp || uiConsoleCp == uiUserUIOEMCp)) {
            lcidThread = MAKELCID(lidUserUI, SORT_DEFAULT);
        }
    }
    //
    //  Set the thread locale if it's different from the currently set
    //  thread locale.
    //
    if ((lcidThread != lcidThreadOld) && (!SetThreadLocale(lcidThread))) {
        lcidThread = lcidThreadOld;
    }
    //
    //  Return the thread locale that was set.
    //
    return (LANGIDFROMLCID(lcidThread));
}


int __cdecl main(int argc, char * argv[])
/*++
main
    entry point to Counter Name Unloader

Arguments
    argc
        # of command line arguments present
    argv
        array of pointers to command line strings
    (note that these are obtained from the GetCommandLine function in
    order to work with both UNICODE and ANSI strings.)

ReturnValue
    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.
--*/
{
    LPWSTR lpCommandLine;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
    setlocale(LC_ALL, ".OCP");
    MySetThreadUILanguage(0);
    lpCommandLine = GetCommandLineW();
    return (int) UnloadPerfCounterTextStringsW(lpCommandLine, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\exts\regexts.cxx ===
/*++

Module Name:

    regleaks.cxx

Abstract:

        Debugger extensions for class store.

Author:

        UShaji (Adapted from  extensions, MarioGo, MazharM, JRoberts)

--*/
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include "windows.h"

// #include "stkwalk.h"
#include <imagehlp.h>
#include "wdbgexts.h"
#include "regexts.hxx"


//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion = 0;
USHORT                  SavedMinorVersion = 0;
HANDLE                  ProcessHandle = 0;
BOOL                    fKernelDebug = FALSE;
UEnvReadMemory          ReadMemoryExt = ReadMemoryUserMode;
UEnvReadMemory          WriteMemoryExt = ReadMemoryUserMode;

//
// macros
//

/*
#define ExtensionRoutinePrologue()  if (!fKernelDebug) \
                                    { \
                                        ExtensionApis = *lpExtensionApis; \
                                        ReadMemoryExt = ReadMemoryUserMode; \
                                        WriteMemoryExt = WriteMemoryUserMode; \
                                    } \
                                    ULONG_PTR dwAddr = GetExpression(lpArgumentString); \

*/

#define ALLOC_SIZE 500
#define MAX_ARGS 4


// define our own operators new and delete, so that we do not have to include the crt

void * __cdecl
::operator new(unsigned int dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void __cdecl
::operator delete (void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}


BOOL
ReadMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return ReadProcessMemory( hProcess, pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
ReadMemoryKernelMode( HANDLE, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return ReadMemory( (ULONG) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
WriteMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return WriteProcessMemory( hProcess, (void*) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
WriteMemoryKernelMode( HANDLE, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return WriteMemory( (ULONG) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
GetData(IN DWORD dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    if (!fKernelDebug)
        {
        return ReadMemoryExt(ProcessHandle, (LPVOID) dwAddress, ptr, size, 0);
        }
        else {
        }

    while( size > 0 )
        {
        count = MIN( size, 3000 );

        b = ReadMemoryExt(ProcessHandle, (LPVOID)  dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count )
            {
            if (NULL == type)
                {
                type = "unspecified" ;
                }
            dprintf("Couldn't read memory with error %d\n", GetLastError());
             
            return FALSE;
            }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
        }

    return TRUE;
}

#define MAX_MESSAGE_BLOCK_SIZE 1024
#define BLOCK_SIZE 2
// could have been bigger but hit the boundary case once.

WCHAR *ReadProcessChar(
    unsigned short * Address
    )
{
    DWORD dwAddr = (DWORD) Address;

    char       block[BLOCK_SIZE];
    WCHAR     *Block  = (WCHAR *)&block;
    char      *string_block = new char[MAX_MESSAGE_BLOCK_SIZE];
    WCHAR     *String = (WCHAR *)string_block;
    int        length = 0;
    int        i      = 0;
    BOOL       b;
    BOOL       end    = FALSE;

    if (dwAddr == NULL) {
        return (L'\0');
    }

    for (length = 0; length < MAX_MESSAGE_BLOCK_SIZE/2; ) {
        b = GetData( dwAddr, &block, BLOCK_SIZE, NULL);
        if (b == FALSE) {
            dprintf("couldn't read address %x\n", dwAddr);
            return (L'\0');
        }
        for (i = 0; i < BLOCK_SIZE/2; i++) {
            if (Block[i] == L'\0') {
                end = TRUE;
            }
            String[length] = Block[i];
            length++;
        }
        if (end == TRUE) {
            break;
        }
        dwAddr += BLOCK_SIZE;
    }

    return (String);
}

PCHAR
MapSymbol(DWORD dwAddr)
{
    static CHAR Name[256];
    DWORD Displacement;

    GetSymbol((LPVOID)dwAddr, (UCHAR *)Name, &Displacement);
    strcat(Name, "+");
    PCHAR p = strchr(Name, '\0');
    _ltoa(Displacement, p, 16);
    return(Name);
}


DECLARE_API( help )
{
    INIT_DPRINTF();

    if (lpArgumentString[0] == '\0') {
        dprintf("\n"
                "regexts help:\n\n"
                "\n"
                "!keys    - Dumps stack for all open reg handles \n"
                "!version  - Dumps the version numbers \n"
                );
    }
}



BOOL   ChkTarget;            // is debuggee a CHK build?
#define VER_PRODUCTBUILD 10
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    fKernelDebug = TRUE;
    ReadMemoryExt = ReadMemoryKernelMode;
    WriteMemoryExt = WriteMemoryKernelMode;

    ExtensionApis = *lpExtensionApis ;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s SMB Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( keys )
{
    RegLeakTable* pLeakTable;

    INIT_DPRINTF();


    if (*lpArgumentString) {
        dprintf("Dump keys for table at %s\n", lpArgumentString);
        sscanf(lpArgumentString, "%lx", &pLeakTable);
    } else {
        dprintf("Dump keys for advapi32!gLeakTable\n");
        pLeakTable = (RegLeakTable*) GetExpression( "advapi32!gLeakTable" );

        if (!pLeakTable) {
            dprintf("Unable to resolve advapi32!gLeakTable\n"
                    "Please fix symbols or specify the address of a leak table"
                    "to !keys\n");
            return;
        } 
        
        dprintf("Dump keys for table at 0x%x\n", pLeakTable);
    }

    RegLeakTableDump(pLeakTable);
}

void RegLeakTableDump(RegLeakTable* pLeakTable)
{
    TrackObjectData* pData;
    DWORD            ListHead;
    DWORD            cKeys;
    DWORD            KeysAddress;
    DWORD            dwFlags;
    DWORD            FlagsAddress;

    KeysAddress = ((DWORD) pLeakTable) + 4;
    FlagsAddress = ((DWORD) pLeakTable) + 8;

    if (!GetData(KeysAddress,
                 &cKeys,
                 sizeof(pLeakTable->cKeys),
                 NULL)) {
        dprintf("Error reading key count at 0x%x\n", KeysAddress);
        return;
    }

    dprintf("\tKeys = 0x%x\n", cKeys);

    if (!GetData(FlagsAddress,
                 &dwFlags,
                 sizeof(pLeakTable->pHead),
                 NULL)) {
        dprintf("Error reading list head at 0x%x\n", pLeakTable);
        return;
    }

    dprintf("\tFlags = 0x%x", dwFlags);

    switch (dwFlags) 
    {
    case LEAK_TRACK_FLAG_NONE:
        dprintf("\tNo tracking\n");
        return;

    case LEAK_TRACK_FLAG_USER:
        dprintf("\tOnly subkeys of HKEY_USERS\n");
        break;

    case LEAK_TRACK_FLAG_ALL:
        dprintf("\tAll keys\n");
        break;

    default:
        dprintf("\tInvalid flag -- table corrupt\n");
        return;
    }

    if (!GetData((DWORD)pLeakTable,
                 &ListHead,
                 sizeof(pLeakTable->pHead),
                 NULL)) {
        dprintf("Error reading list head at 0x%x\n", pLeakTable);
        return;
    }

    dprintf("\tList starts at 0x%x\n", ListHead);

    TrackObjectData* NextData;

    int ikey = 0;

    for (pData = (TrackObjectData*) ListHead;
         pData != NULL;
         pData = NextData)
    {
        dprintf("\tObject at 0x%x", pData);

        TrackObjectDataPrint(pData);

        if (!GetData((DWORD) pData, &NextData, sizeof(NextData), NULL)) {
            dprintf("Error reading next link for object at 0x%x\n", pData);
            return;
        }
    }
}


void TrackObjectDataPrint(TrackObjectData* pKeyData)
{
    NTSTATUS           Status;
    DWORD              dwStackDepth;
    DWORD              StackAddress;
    HKEY               hKey;
    DWORD              hKeyAddress;
    DWORD              StackDepthAddress;
    PVOID*             rgStack;
    DWORD              pStack;

    hKeyAddress = ((DWORD) pKeyData) + 8;
    StackDepthAddress = ((DWORD) pKeyData) + 12;

    rgStack = NULL;

    if (!GetData(hKeyAddress, &hKey, sizeof(hKey), NULL)) {
        dprintf("Error reading hkey for object at 0x%x\n", pKeyData);
        return;
    }

    dprintf("Tracked key data for object 0x%x\n", hKey);

    if (!fKernelDebug) 
        (void) PrintObjectInfo(hKey);
    else
        dprintf("!!!!!!Broken into kd. do '!handle 0x%x f' for details of the handle\n", hKey);

    if (!GetData(StackDepthAddress, &dwStackDepth, sizeof(dwStackDepth), NULL)) {
        dprintf("Error reading key object at 0x%x\n", pKeyData);
        return;
    }

    if (!dwStackDepth) {
        dprintf("\t\tNo stack data\n");
        return;
    }

    dprintf("\t\tStack depth 0x%x\n", dwStackDepth);

    StackAddress = ((DWORD) (pKeyData)) + 16;

    if (!GetData(StackAddress,
                 &pStack,
                 sizeof(PVOID),
                 NULL)) {
        dprintf("Error reading stack frames at 0x%x\n", StackAddress);
        return;
    } 
    dprintf("\t\tStack frames at 0x%x\n", pStack);

    rgStack = (PVOID*) RtlAllocateHeap(
        RtlProcessHeap(),
        0,
        sizeof(*rgStack) * dwStackDepth);

    if (!rgStack) {
        return;
    }

    if (!GetData(pStack,
                 rgStack,
                 sizeof(*rgStack) * dwStackDepth,
                 NULL)) {
        dprintf("Error reading stack frames at 0x%x\n", StackAddress);
        RtlFreeHeap(RtlProcessHeap(), 0, rgStack);
        return;
    } 

    for (int iFrame = 0; iFrame < dwStackDepth; iFrame++)
    {
        UCHAR Symbol[MAX_SYMBOL_LENGTH];
        DWORD_PTR Displacement;

        *Symbol = L'\0';

        GetSymbol(
            rgStack[iFrame],
            Symbol,
            &Displacement);

        dprintf("\t\t0x%x", rgStack[iFrame]);

        if (*Symbol) {
            dprintf("\t %s", Symbol);
            
            if (Displacement) {
                dprintf("+0x%x", Displacement);
            }
        } else {
            dprintf("\t ????????");
        }

        dprintf("\n");
    }

    if (rgStack) {
        RtlFreeHeap(RtlProcessHeap(), 0, rgStack);
    }

    dprintf("\n");
}


NTSTATUS PrintObjectInfo(HANDLE Handle)
{

    POBJECT_NAME_INFORMATION pNameInfo;
    BYTE     rgNameInfoBuf[512];
    NTSTATUS Status;
    HKEY     hkDup;
    DWORD    dwRequired;

    Status = NtDuplicateObject(
        ProcessHandle,
        Handle,
        NtCurrentProcess(),
        (PHANDLE) &hkDup,
        0,
        FALSE,
        DUPLICATE_SAME_ACCESS);

    if (!NT_SUCCESS(Status)) {
        dprintf("Unable to duplicate handle 0x%x from process handle 0x%x, error 0x%x\n", 
                Handle,
                ProcessHandle,
                Status);
        return Status;
    }
        
    pNameInfo = (POBJECT_NAME_INFORMATION) rgNameInfoBuf;

    Status = NtQueryObject(
        hkDup,
        ObjectNameInformation,
        pNameInfo,
        sizeof(pNameInfo),
        &dwRequired);

    if (!NT_SUCCESS(Status)) {

        if (STATUS_INFO_LENGTH_MISMATCH == Status) {

            Status = STATUS_NO_MEMORY;

            pNameInfo = (POBJECT_NAME_INFORMATION) RtlAllocateHeap(
                RtlProcessHeap(),
                0,
                dwRequired);
            
            if (pNameInfo) {

                Status = NtQueryObject(
                    hkDup,
                    ObjectNameInformation,
                    pNameInfo,
                    dwRequired,
                    &dwRequired);
            }

        }
    }


    if (!NT_SUCCESS(Status)) {
        dprintf("Unable to query object information for object error 0x%x\n",
                Status);
    } else {
        dprintf("Object 0x%x\n\tName: %S\n", Handle, pNameInfo->Name.Buffer);
    }

    NtClose(hkDup);

    if ((PBYTE) pNameInfo != rgNameInfoBuf) {
        RtlFreeHeap(RtlProcessHeap(), 0, pNameInfo);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\lib\support.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    Support.c

Abstract:

    This module contains support routines for the Win32 Registry API.

Author:

    David J. Gilman (davegi) 15-Nov-1991

--*/

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains a routine for converting NT status codes
    to DOS/OS|2 error codes.

Author:

    David Treadwell (davidtr)   04-Apr-1991

Revision History:

--*/

#include <rpc.h>
#include "regrpc.h"
#include <stdio.h>



LONG
MapSAToRpcSA (
    IN LPSECURITY_ATTRIBUTES lpSA,
    OUT PRPC_SECURITY_ATTRIBUTES lpRpcSA
    )

/*++

Routine Description:

    Maps a SECURITY_ATTRIBUTES structure to a RPC_SECURITY_ATTRIBUTES
    structure by converting the SECURITY_DESCRIPTOR to a form where it can
    be marshalled/unmarshalled.

Arguments:

    lpSA - Supplies a pointer to the SECURITY_ATTRIBUTES structure to be
        converted.

    lpRpcSA - Supplies a pointer to the converted RPC_SECURITY_ATTRIBUTES
        structure.  The caller should free (using RtlFreeHeap) the field
        lpSecurityDescriptor when its finished using it.

Return Value:

    LONG - Returns ERROR_SUCCESS if the SECURITY_ATTRIBUTES is
        succesfully mapped.

--*/

{
    LONG    Error;

    ASSERT( lpSA != NULL );
    ASSERT( lpRpcSA != NULL );

    //
    // Map the SECURITY_DESCRIPTOR to a RPC_SECURITY_DESCRIPTOR.
    //
    lpRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor = NULL;

    if( lpSA->lpSecurityDescriptor != NULL ) {
        Error = MapSDToRpcSD(
                    lpSA->lpSecurityDescriptor,
                    &lpRpcSA->RpcSecurityDescriptor
                    );
    } else {
        lpRpcSA->RpcSecurityDescriptor.cbInSecurityDescriptor = 0;
        lpRpcSA->RpcSecurityDescriptor.cbOutSecurityDescriptor = 0;
        Error = ERROR_SUCCESS;
    }

    if( Error == ERROR_SUCCESS ) {

        //
        //
        // The supplied SECURITY_DESCRIPTOR was successfully converted
        // to self relative format so assign the remaining fields.
        //

        lpRpcSA->nLength = lpSA->nLength;

        lpRpcSA->bInheritHandle = ( BOOLEAN ) lpSA->bInheritHandle;
    }

    return Error;
}

LONG
MapSDToRpcSD (
    IN  PSECURITY_DESCRIPTOR lpSD,
    IN OUT PRPC_SECURITY_DESCRIPTOR lpRpcSD
    )

/*++

Routine Description:

    Maps a SECURITY_DESCRIPTOR to a RPC_SECURITY_DESCRIPTOR by converting
    it to a form where it can be marshalled/unmarshalled.

Arguments:

    lpSD - Supplies a pointer to the SECURITY_DESCRIPTOR
        structure to be converted.

    lpRpcSD - Supplies a pointer to the converted RPC_SECURITY_DESCRIPTOR
        structure. Memory for the security descriptor is allocated if
        not provided. The caller must take care of freeing up the memory
        if necessary.

Return Value:

    LONG - Returns ERROR_SUCCESS if the SECURITY_DESCRIPTOR is
        succesfully mapped.

--*/

{
    DWORD   cbLen;


    ASSERT( lpSD != NULL );
    ASSERT( lpRpcSD != NULL );

    if( RtlValidSecurityDescriptor( lpSD )) {

        cbLen = RtlLengthSecurityDescriptor( lpSD );
        ASSERT( cbLen > 0 );

        //
        //  If we're not provided a buffer for the security descriptor,
        //  allocate it.
        //
        if ( !lpRpcSD->lpSecurityDescriptor ) {

            //
            // Allocate space for the converted SECURITY_DESCRIPTOR.
            //
            lpRpcSD->lpSecurityDescriptor =
                 ( PBYTE ) RtlAllocateHeap(
                                RtlProcessHeap( ), 0,
                                cbLen
                                );

            //
            // If the memory allocation failed, return.
            //
            if( lpRpcSD->lpSecurityDescriptor == NULL ) {
                return ERROR_OUTOFMEMORY;
            }

            lpRpcSD->cbInSecurityDescriptor = cbLen;

        } else {

            //
            //  Make sure that the buffer provided is big enough
            //
            if ( lpRpcSD->cbInSecurityDescriptor < cbLen ) {
                return ERROR_OUTOFMEMORY;
            }
        }

        //
        //  Set the size of the transmittable buffer
        //
        lpRpcSD->cbOutSecurityDescriptor = cbLen;

        //
        // Convert the supplied SECURITY_DESCRIPTOR to self relative form.
        //

        return RtlNtStatusToDosError(
            RtlMakeSelfRelativeSD(
                        lpSD,
                        lpRpcSD->lpSecurityDescriptor,
                        &lpRpcSD->cbInSecurityDescriptor
                        )
                    );
    } else {

        //
        // The supplied SECURITY_DESCRIPTOR is invalid.
        //

        return ERROR_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\showperf\showperf.h ===
/*++
Copyright (c) 1993  Microsoft Corporation

Module Name:
    SHOWPERF.H

Abstract:

Author:
    Bob Watson (a-robw)

Revision History:
    23 NOV 94
--*/
#ifndef _SHOWPERF_H_
#define _SHOWPERF_H_

//  WIN32 Constant Definitions
//
#define BEEP_EXCLAMATION    MB_ICONEXCLAMATION
#define OF_SEARCH               0
#define SMALL_BUFFER_SIZE    1024
#define MEDIUM_BUFFER_SIZE   4096
#define LARGE_BUFFER_SIZE   65536

// define dialog box button states
#define ENABLED              TRUE
#define DISABLED            FALSE
#define CHECKED                 1
#define UNCHECKED               0

// define Mailbox buttons
#define MBOK_EXCLAIM            (MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MBOK_INFO               (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL)
#define MBOKCANCEL_EXCLAIM      (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MBOKCANCEL_INFO         (MB_OKCANCEL | MB_ICONINFORMATION | MB_TASKMODAL)
#define MBOKCANCEL_QUESTION     (MB_OKCANCEL | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNO_QUESTION        (MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNOCANCEL_QUESTION  (MB_YESNOCANCEL | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNOCANCEL_EXCLAIM   (MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)

// other constants
#define MAX_USERNAME             15
#define MAX_DOMAINNAME           15
#define MAX_ORGNAME             255
#define MAX_PRODUCT_NAME_LENGTH  32

//
//  WIN32 Version of common macros
//
#define GET_CONTROL_ID(w)             LOWORD(w)
#define GET_NOTIFY_MSG(w, l)          HIWORD(w)
#define GET_COMMAND_WND(l)            ((HWND) (l))
#define GET_INSTANCE(h)               ((HINSTANCE) GetWindowLongPtr(h, GWLP_HINSTANCE))
#define SAVE_HWND(w, o, v)            SetWindowLong(w, o, (LONG) v)
#define GET_HWND(w, o)                (HWND) GetWindowLong(w, o)
#define SET_HWND(w, o, v)             SetWindowLong(w, o, (DWORD) v)
#define SET_INFO(w, o, p)             (LPVOID) SetWindowLong(w, o, (LONG) p)
#define GET_INFO(w, o)                (LPVOID) GetWindowLong(w, o)
#define SEND_WM_COMMAND(w, c, n, cw)  SendMessageW(w, WM_COMMAND, MAKEWPARAM(c, n), (LPARAM) cw)
#define POST_WM_COMMAND(w, c, n, cw)  PostMessageW(w, WM_COMMAND, MAKEWPARAM(c, n), (LPARAM) cw)
#define GetMyLastError                GetLastError
#define CLEAR_FIRST_FOUR_BYTES(x)     * (DWORD *)(x) = 0L
#define SET_WAIT_CURSOR               SetCursor(LoadCursor(NULL, IDC_WAIT))
#define SET_ARROW_CURSOR              SetCursor(LoadCursor(NULL, IDC_ARROW))

// Memory Allocation
#define MemoryAllocate(x) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x)
#define MemoryFree(x)     if (x != NULL) HeapFree(GetProcessHeap(), 0, x)
#define MemoryResize(x,y) (x != NULL ? HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x, y) \
                                     : HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, y))
#define MemorySize(x)     (x != NULL ? (DWORD) HeapSize(GetProcessHeap(), 0, x) : (DWORD) 0)

//
//  Global Functions
//
LPCWSTR
GetStringResource(
    HANDLE hInstance,
    UINT   nId
);

BOOL
ShowAppHelp(
    HWND hWnd
);

int
DisplayMessageBox(
    HWND hWnd,
    UINT nMessageId,
    UINT nTitleId,
    UINT nStyle
);

VOID
SetHelpContextId(
    WORD wId
);

WORD
GetHelpContextId(
);

// Main Dialog function
//
INT_PTR
MainDlgProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
);

// Main Window functions
//
LRESULT CALLBACK
MainWndProc(
    HWND   hWnd,    // window handle
    UINT   message, // type of message
    WPARAM wParam,  // additional information
    LPARAM lParam   // additional information
);

BOOL
RegisterMainWindowClass(
    HINSTANCE hInstance
);

HWND
CreateMainWindow(
    HINSTANCE hInstance
);

#endif // _SHOWPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\showperf\showperf.c ===
/*++
Copyright (c) 1994  Microsoft Corporation

Module Name:
    ShowPerf.c

Abstract:
    Provides a GUI interface to display the contents of a perf data
    block

Author:
    Bob Watson (a-robw)

Revision History:
    23 Nov 94
--*/
#include <windows.h>
#include "showperf.h"
#include "resource.h"

#define NUM_BUFS    4

// variable definition

static  WORD wHelpContextId = IDH_CONTENTS;

LPCWSTR
GetStringResource(
    HANDLE  hInstance,
    UINT    nId
)
/*++
Routine Description:
    look up string resource and return string

Arguments:
    IN  UINT    nId
        Resource ID of string to look up

Return Value:
    pointer to string referenced by ID in arg list
--*/
{
    static WCHAR   szBufArray[NUM_BUFS][SMALL_BUFFER_SIZE];
    static DWORD   dwIndex;
    LPWSTR         szBuffer;
    DWORD          dwLength;
    HANDLE         hMod;

    hMod     = (hInstance != NULL) ? (hInstance) : (GetModuleHandle(NULL));
    dwIndex ++;
    dwIndex %= NUM_BUFS;
    szBuffer = & szBufArray[dwIndex][0];

    // clear previous contents
    ZeroMemory(szBuffer, SMALL_BUFFER_SIZE * sizeof(WCHAR));

    dwLength = LoadStringW(hMod, nId, szBuffer, SMALL_BUFFER_SIZE);
    return (LPCWSTR) szBuffer;
}

VOID
SetHelpContextId(
    WORD wId
)
{
    wHelpContextId = wId;
    return;
}

WORD
GetHelpContextId(
)
{
    return wHelpContextId;
}

int
DisplayMessageBox(
    HWND hWnd,
    UINT nMessageId,
    UINT nTitleId,
    UINT nStyle
)
/*++
Routine Description:
    Displays a message box displaying text from the resource file, as
        opposed to literal strings.

Arguments:
    IN  HWND    hWnd            window handle to parent window
    IN  UINT    nMessageId      String Resource ID of message text to display
    IN  UINT    nTitleId        String Resource ID of title text to display
    IN  UINT    nStyle          MB style bits (see MessageBox function)

Return Value:
    ID of button pressed to exit message box
--*/
{
    LPWSTR    szMessageText = NULL;
    LPWSTR    szTitleText   = NULL;
    HINSTANCE hInst         = GET_INSTANCE(hWnd);
    int       nReturn;

    szMessageText = MemoryAllocate(sizeof(WCHAR) * (SMALL_BUFFER_SIZE + 1));
    szTitleText   = MemoryAllocate(sizeof(WCHAR) * (SMALL_BUFFER_SIZE + 1));

    if ((szMessageText != NULL) && (szTitleText != NULL)) {
        LoadStringW(hInst, ((nTitleId != 0) ? nTitleId : IDS_APP_TITLE), szTitleText, SMALL_BUFFER_SIZE - 1);
        LoadStringW(hInst, nMessageId, szMessageText, SMALL_BUFFER_SIZE - 1);
        nReturn = MessageBoxW(hWnd, szMessageText, szTitleText, nStyle);
    }
    else {
        nReturn = IDCANCEL;
    }
    MemoryFree(szMessageText);
    MemoryFree(szTitleText);
    return nReturn;
}

BOOL
UpdateSystemMenu(
    HWND hWnd   // window handle
)
/*++
Routine Description:
    modifies the system menu by:
        Removing the "Restore", "Size", "Minimize" and "Maximize" entries

Arguments:
    IN  HWND    hWnd
        window handle of window containing the system menu to modify

Return Value:
    TRUE if successfully made changes, otherwise
    FALSE if error occurred
--*/
{
    UNREFERENCED_PARAMETER(hWnd);
    return TRUE;
}

BOOL
ShowAppHelp(
    HWND hWnd
)
/*++
Routine Description:
    Generic routine to call WinHelp engine for displaying application
        help. wContext parameter is used for context.

Arguments:
    IN  HWND    hWnd
        window handle of calling window

Return Value:
    TRUE if help called successfully
--*/
{
    return WinHelpW(hWnd,
                    GetStringResource(GET_INSTANCE(hWnd), IDS_HELP_FILENAME),
                    HELP_CONTEXT,
                    (DWORD) GetHelpContextId());
}

int APIENTRY
WinMain(
    IN  HINSTANCE hInstance,
    IN  HINSTANCE hPrevInstance,
    IN  LPSTR     szCmdLine,
    IN  int       nCmdShow
)
/*++
Routine Description:
    Program entry point for LoadAccount application. Initializes Windows
        data structures and begins windows message processing loop.

Arguments:
    Standard WinMain arguments

ReturnValue:
    0 if unable to initialize correctly, or
    wParam from WM_QUIT message if messages processed
--*/
{
    HWND        hWnd; // Main window handle.
    MSG         msg;
    int         iReturn = ERROR_CAN_NOT_COMPLETE;

    UNREFERENCED_PARAMETER(nCmdShow);
    UNREFERENCED_PARAMETER(szCmdLine);
    UNREFERENCED_PARAMETER(hPrevInstance);

    if (RegisterMainWindowClass(hInstance)) {
        hWnd = CreateMainWindow(hInstance);
        if (hWnd != NULL) {
            // Acquire and dispatch messages until a
            //  WM_QUIT message is received.

            while (GetMessage(& msg, // message structure
                              NULL,  // handle of window receiving the message
                              0,     // lowest message to examine
                              0)) {  // highest message to examine
                // process this message
                TranslateMessage(& msg);// Translates virtual key codes
                DispatchMessage(& msg); // Dispatches message to window
            }
            iReturn = (int)(msg.wParam); // Returns the value from PostQuitMessage
        }
    }
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\local\makefile.inc ===
#
# Copy files from server to make local version of base functions.
#

$(O)\predefh.c    : ..\server\predefh.c
    copy $? $@

$(O)\regdkey.c    : ..\server\regdkey.c
    copy $? $@

$(O)\regdval.c    : ..\server\regdval.c
    copy $? $@

$(O)\regekey.c    : ..\server\regekey.c
    copy $? $@

$(O)\regeval.c    : ..\server\regeval.c
    copy $? $@

$(O)\regkey.c     : ..\server\regkey.c
    copy $? $@

$(O)\reglukey.c   : ..\server\reglukey.c
    copy $? $@

$(O)\regqkey.c    : ..\server\regqkey.c
    copy $? $@

$(O)\regqval.c    : ..\server\regqval.c
    copy $? $@

$(O)\regsckey.c   : ..\server\regsckey.c
    copy $? $@

$(O)\regsrkey.c   : ..\server\regsrkey.c
    copy $? $@

$(O)\regsval.c    : ..\server\regsval.c
    copy $? $@

$(O)\regclass.c   : ..\server\regclass.c
    copy $? $@

$(O)\regecls.c    : ..\server\regecls.c
    copy $? $@

$(O)\regvcls.c    : ..\server\regvcls.c
    copy $? $@

$(O)\regstate.c   : ..\server\regstate.c
    copy $? $@

$(O)\regnccls.c   : ..\server\regnccls.c
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\common\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME    (TEXT("Perflib"))

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_NONE

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\local\stkwalk.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    stkwalk.h

Abstract:

    This module contains memory debug function prototypes and macros.

Author:

    Stolen from dbgmem.h
    Jim Stewart/Ramesh Pabbati    January 8, 1996

    Fixed up for regleaks
    UShaji                        Dev 11th,  1998

Revision History:

--*/

#ifdef LOCAL
#ifdef LEAK_TRACK

//
// define the amount of symbol info to keep per function in the stack trace.
//
#define MAX_FUNCTION_INFO_SIZE  40
typedef struct {

    DWORD   Displacement;                   // displacement into the function
    UCHAR   Buff[MAX_FUNCTION_INFO_SIZE];   // name of function on call stack
    PVOID   Addr;
    

} CALLER_SYM, *PCALLER_SYM;

BOOL
InitDebug(
    );

BOOL 
StopDebug();


VOID
GetCallStack(
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind,
    IN int           fResolveSymbols
    );

#define MY_DBG_EXCEPTION 3

extern BOOL fDebugInitialised;

#endif // LEAK_TRACK
#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\local\regleak.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regleak.h

Abstract:

    This file contains declarations for data structures
    needed for tracking win32 registry leaks

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

--*/

#ifdef LOCAL

#include "winver.h"

#if !defined(_REGLEAK_H_)
#define _REGLEAK_H_

#ifdef LEAK_TRACK

#include "imagehlp.h"

#define MAX_LEAK_STACK_DEPTH 40
#define SYM_PATH_MAX_SIZE    1000

typedef struct _TrackObjectData 
{
    LIST_ENTRY Links;
    HKEY       hKey;
    DWORD      dwStackDepth;
    PVOID*     rgStack;
} TrackObjectData;

void     TrackObjectDataPrint(TrackObjectData* pKeyData);
NTSTATUS TrackObjectDataInit(TrackObjectData* pKeyData, PVOID* rgStack, DWORD dwMaxStackDepth, HKEY hKey);
NTSTATUS TrackObjectDataClear(TrackObjectData* pKeyData);

NTSTATUS GetLeakStack(PVOID** prgStack, DWORD* pdwMaxDepth, DWORD dwMaxDepth);

enum
{
    LEAK_TRACK_FLAG_NONE = 0,
    LEAK_TRACK_FLAG_USER = 1,
    LEAK_TRACK_FLAG_ALL = 0xFFFFFFFF
};

typedef struct _RegLeakTable
{
    TrackObjectData*       pHead;
    DWORD                  cKeys;
    DWORD                  dwFlags;
    BOOL                   bCriticalSectionInitialized;
    RTL_CRITICAL_SECTION   CriticalSection;

} RegLeakTable;


typedef struct _RegLeakTraceInfo {
    DWORD   dwMaxStackDepth;
    LPTSTR  szSymPath;
    BOOL    bEnableLeakTrack;    
    RTL_CRITICAL_SECTION   StackInitCriticalSection;
} RegLeakTraceInfo;

extern RegLeakTraceInfo g_RegLeakTraceInfo;


NTSTATUS RegLeakTableInit(RegLeakTable* pLeakTable, DWORD dwFlags);
NTSTATUS RegLeakTableClear(RegLeakTable* pLeakTable);
NTSTATUS RegLeakTableAddKey(RegLeakTable* pLeakTable, HKEY hKey);
NTSTATUS RegLeakTableRemoveKey(RegLeakTable* pLeakTable, HKEY hKey);

BOOL RegLeakTableIsEmpty(RegLeakTable* pLeakTable);
BOOL RegLeakTableIsTrackedObject(RegLeakTable* pLeakTable, HKEY hKey);

NTSTATUS TrackObject(HKEY hKey);
BOOL     InitializeLeakTrackTable();
BOOL     CleanupLeakTrackTable();
NTSTATUS UnTrackObject(HKEY hKey);

extern RegLeakTable gLeakTable;


#endif // LEAK_TRACK
#endif // _REGLEAK_H_
#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\local\regleak.c ===
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegLeak.h

Abstract:

    This module contains helper functions for tracking
n    win32 registry leaks

Author:

    Adam Edwards (adamed) 06-May-1998

--*/


#ifdef LOCAL
#ifdef LEAK_TRACK

#include "ntverp.h"
#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "stkwalk.h"
#include "regleak.h"
#include <malloc.h>

RegLeakTable gLeakTable;
RegLeakTraceInfo g_RegLeakTraceInfo;


void     TrackObjectDataPrint(TrackObjectData* pKeyData)
{
    NTSTATUS       Status;
    SKeySemantics  keyinfo;
    UNICODE_STRING EmptyString = {0, 0, 0};
    BYTE           rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(KEY_NAME_INFORMATION)];

    DbgPrint("WINREG: Tracked key data for object 0x%x\n", pKeyData->hKey);

    //
    // Set buffer to store info about this key
    //
    keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
    keyinfo._cbFullPath = sizeof(rgNameBuf);

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(pKeyData->hKey, &EmptyString, &keyinfo);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("WINREG: Unable to retrieve object name error 0x%x\n", Status);
    } else {
        DbgPrint("WINREG: Name: %S\n", keyinfo._pFullPath->Name);
    }

    BaseRegReleaseKeySemantics(&keyinfo);

    DbgPrint("Frames %d", pKeyData->dwStackDepth);

    {
        DWORD iFrame;

        for (iFrame = 0; iFrame < pKeyData->dwStackDepth; iFrame++) 
        {
            DbgPrint("WINREG: Frame %d = 0x%x\n", iFrame, pKeyData->rgStack[iFrame]);
        }
    }
    DbgPrint("\n");

}

NTSTATUS TrackObjectDataInit(TrackObjectData* pKeyData, PVOID* rgStack, DWORD dwMaxStackDepth, HKEY hKey)
{
    RtlZeroMemory(pKeyData, sizeof(*pKeyData));
    
    pKeyData->hKey = REG_CLASS_RESET_SPECIAL_KEY(hKey);
  
    pKeyData->dwStackDepth = dwMaxStackDepth;
    pKeyData->rgStack = rgStack;

    return STATUS_SUCCESS;
}

NTSTATUS TrackObjectDataClear(TrackObjectData* pKeyData)
{
    if (pKeyData->rgStack) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyData->rgStack);
        pKeyData->rgStack = NULL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS RegLeakTableInit(RegLeakTable* pLeakTable, DWORD dwFlags)
{
    NTSTATUS Status;

    RtlZeroMemory(pLeakTable, sizeof(*pLeakTable));
    
    pLeakTable->dwFlags = dwFlags;

    Status = RtlInitializeCriticalSection(
                    &(pLeakTable->CriticalSection));

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Remember that we have initialized this critical section
    // so we can remember to delete it.
    //

    pLeakTable->bCriticalSectionInitialized = TRUE;

    Status = RtlInitializeCriticalSection(
                    &(g_RegLeakTraceInfo.StackInitCriticalSection));

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS RegLeakTableClear(RegLeakTable* pLeakTable)
{
    NTSTATUS Status;

#if defined(DBG) // LEAK_TRACK
    DbgPrint("WINREG: Leak data for process id 0x%x\n", NtCurrentTeb()->ClientId.UniqueProcess);
    DbgPrint("WINREG: Keys Leaked 0x%x\n", pLeakTable->cKeys);
#endif // LEAK_TRACK

    Status = RtlDeleteCriticalSection(
        &(pLeakTable->CriticalSection));

    ASSERT(NT_SUCCESS(Status));

    Status = RtlDeleteCriticalSection(
        &(g_RegLeakTraceInfo.StackInitCriticalSection));

        
    ASSERT(NT_SUCCESS(Status));
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlDeleteCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
    }
#endif

    {
        DWORD cKeys;

        cKeys = 0;

        for (;;) 
        {
            if (!(pLeakTable->pHead)) {
                break;
            }
            TrackObjectDataPrint(pLeakTable->pHead);

            cKeys++;

            (void) RegLeakTableRemoveKey(pLeakTable, pLeakTable->pHead->hKey);
        }

#if defined(DBG) // LEAK_TRACK
        DbgPrint("WINREG: 0x%x total keys leaked\n", cKeys);
#endif // LEAK_TRACK
    }

    return STATUS_SUCCESS;
}

NTSTATUS RegLeakTableAddKey(RegLeakTable* pLeakTable, HKEY hKey)
{
    NTSTATUS           Status;
    TrackObjectData*   pNewData;
    PVOID*             rgStack;
    DWORD              dwMaxStackDepth;

    rgStack = NULL;
    dwMaxStackDepth = 0;

    hKey = REG_CLASS_RESET_SPECIAL_KEY(hKey);

    if (!RegLeakTableIsTrackedObject(pLeakTable, hKey)) {
        return STATUS_SUCCESS;
    }

    (void) GetLeakStack(
        &rgStack,
        &dwMaxStackDepth,
        g_RegLeakTraceInfo.dwMaxStackDepth);

    Status = RtlEnterCriticalSection(&(pLeakTable->CriticalSection));
    
    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
#endif
        return Status;
    }
    
    pNewData = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(*pNewData));

    if (!pNewData) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    Status = TrackObjectDataInit(pNewData, rgStack, dwMaxStackDepth, hKey);

    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (!RegLeakTableIsEmpty(pLeakTable)) {
        
        pNewData->Links.Flink = (PLIST_ENTRY) pLeakTable->pHead;
        pLeakTable->pHead->Links.Blink = (PLIST_ENTRY) pNewData;

    }

    pLeakTable->pHead = pNewData;

    pLeakTable->cKeys++;

cleanup:    
    {
        NTSTATUS Status;

        Status = RtlLeaveCriticalSection(&(pLeakTable->CriticalSection));

        ASSERT( NT_SUCCESS( Status ) );
#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
        }
#endif
    }

    return Status;
}

NTSTATUS RegLeakTableRemoveKey(RegLeakTable* pLeakTable, HKEY hKey)
{
    NTSTATUS         Status;
    TrackObjectData* pData;

    Status = RtlEnterCriticalSection(&(pLeakTable->CriticalSection));
    
    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
#endif
        return Status;
    }
    

    hKey = REG_CLASS_RESET_SPECIAL_KEY(hKey);

    for (pData = pLeakTable->pHead; 
         pData != NULL;
         pData = (TrackObjectData*) pData->Links.Flink)
    {
        if (hKey == pData->hKey) {
            
            PLIST_ENTRY pFlink;
            PLIST_ENTRY pBlink;
            
            pBlink = pData->Links.Blink;
            pFlink = pData->Links.Flink;

            if (pBlink) {
                pBlink->Flink = pFlink;
            }

            if (pFlink) {
                pFlink->Blink = pBlink;
            }

            if (pData == pLeakTable->pHead) {
                pLeakTable->pHead = (TrackObjectData*) pFlink;
            }

            (void) TrackObjectDataClear(pData);

            RtlFreeHeap(RtlProcessHeap(), 0, pData);

            pLeakTable->cKeys--;

            goto cleanup;
        }
    }

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

cleanup:    

    {
        NTSTATUS Status;

        Status = RtlLeaveCriticalSection(&(pLeakTable->CriticalSection));

        ASSERT( NT_SUCCESS( Status ) );
#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
        }
#endif
    }

    return Status;
}

BOOL RegLeakTableIsEmpty(RegLeakTable* pLeakTable)
{
    return pLeakTable->pHead == NULL;
}

BOOL RegLeakTableIsTrackedObject(RegLeakTable* pLeakTable, HKEY hKey)
{
    NTSTATUS       Status;
    SKeySemantics  keyinfo;
    UNICODE_STRING EmptyString = {0, 0, 0};
    BYTE           rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(KEY_NAME_INFORMATION)];
    BOOL           fTrackObject;

    fTrackObject = FALSE;

    if (LEAK_TRACK_FLAG_ALL == pLeakTable->dwFlags) {
        return TRUE;
    }

    if (LEAK_TRACK_FLAG_NONE == pLeakTable->dwFlags) {
        return FALSE;
    }
    
    //
    // Set buffer to store info about this key
    //
    keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
    keyinfo._cbFullPath = sizeof(rgNameBuf);

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(hKey, &EmptyString, &keyinfo);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (LEAK_TRACK_FLAG_USER & pLeakTable->dwFlags) {

        WCHAR UserChar;

        UserChar = keyinfo._pFullPath->Name[REG_CLASSES_FIRST_DISTINCT_ICH];

        if ((L'U' == UserChar) || (L'u' == UserChar)) {
            fTrackObject = TRUE;
        }
    }

    BaseRegReleaseKeySemantics(&keyinfo);

    return fTrackObject;

}

NTSTATUS TrackObject(HKEY hKey)
{
    return RegLeakTableAddKey(&gLeakTable, hKey);
}

#define WINLOGON_KEY            L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define LEAKTRACK_VALUE         L"LeakTrack"
#define DEFAULT_VALUE_SIZE          128

void ReadRegLeakTrackInfo()
{
    LPTSTR                          lpWinlogonKey;
    LONG                            error;
    OBJECT_ATTRIBUTES               Attributes;
    NTSTATUS                        Status;
    HKEY                            hKey;
    UNICODE_STRING                  uWinlogonPath;
    UNICODE_STRING                  uValueName;

    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;
    PVOID                           KeyValueInformation;

    BYTE                            PrivateKeyValueInformation[ sizeof( KEY_VALUE_PARTIAL_INFORMATION) +
                                        DEFAULT_VALUE_SIZE ];
    ULONG                           BufferLength;
    ULONG                           ResultLength;

    //
    // Look in the registry whether tracking is enabled uder
    // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion\Winlogon
    //

    memset(&g_RegLeakTraceInfo, 0, sizeof(g_RegLeakTraceInfo));

    g_RegLeakTraceInfo.bEnableLeakTrack = 0;
 
    RtlInitUnicodeString(&uWinlogonPath, WINLOGON_KEY);
 
    InitializeObjectAttributes(&Attributes,
                              &uWinlogonPath,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);


    Status = NtOpenKey( &hKey,
                      KEY_READ,
                      &Attributes );


    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&uValueName, LEAKTRACK_VALUE);

        KeyValueInformationClass = KeyValuePartialInformation;

        KeyValueInformation = PrivateKeyValueInformation;
        BufferLength = sizeof( PrivateKeyValueInformation );

        Status = NtQueryValueKey( hKey,
                                  &uValueName,
                                  KeyValueInformationClass,
                                  KeyValueInformation,
                                  BufferLength,
                                  &ResultLength );


       //
       // if it succeeded and the datalength is greater than zero
       // check whether it is non-zero
       //

       if ((NT_SUCCESS(Status)) && 
           (((PKEY_VALUE_PARTIAL_INFORMATION )KeyValueInformation )->DataLength)) {

            if (((( PKEY_VALUE_PARTIAL_INFORMATION )KeyValueInformation)->Data) && 
            (*((( PKEY_VALUE_PARTIAL_INFORMATION )KeyValueInformation)->Data)))
                g_RegLeakTraceInfo.bEnableLeakTrack = 1;
       }

       NtClose(hKey);

    }
//    g_RegLeakTraceInfo.bEnableLeakTrack = GetProfileInt(TEXT("RegistryLeak"), TEXT("Enable"), 0);
}


BOOL InitializeLeakTrackTable()
{
    ReadRegLeakTrackInfo();
    
    if (g_RegLeakTraceInfo.bEnableLeakTrack)
        return NT_SUCCESS(RegLeakTableInit(&gLeakTable, LEAK_TRACK_FLAG_USER));
    else
        return TRUE;
}

BOOL CleanupLeakTrackTable()
{
    BOOL fSuccess;

    if (!g_RegLeakTraceInfo.bEnableLeakTrack)
        return TRUE;

    //
    // if leak_tracking is not enabled, quit quickly.
    //
    
    fSuccess = NT_SUCCESS(RegLeakTableClear(&gLeakTable));

    (void) StopDebug();

    return fSuccess;
}

NTSTATUS UnTrackObject(HKEY hKey)
{
    return RegLeakTableRemoveKey(&gLeakTable, hKey);
}

NTSTATUS GetLeakStack(PVOID** prgStack, DWORD* pdwMaxDepth, DWORD dwMaxDepth)
{

    PCALLER_SYM pStack;
    DWORD       dwDepth;

    pStack = (PCALLER_SYM) RtlAllocateHeap(
        RtlProcessHeap(),
        0,
        dwMaxDepth * sizeof(*pStack));

    if (!pStack) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(pStack, sizeof(*pStack) * dwMaxDepth);

   *prgStack = RtlAllocateHeap(
        RtlProcessHeap(),
        0,
        dwMaxDepth * sizeof(*(*prgStack)));

    if (!*prgStack) {
        RtlFreeHeap(RtlProcessHeap(),
                    0,
                    pStack);

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(*prgStack, sizeof(*(*prgStack)) * dwMaxDepth);

    GetCallStack(
        pStack,
        4,
        dwMaxDepth,
        FALSE);

    for (dwDepth = 0; dwDepth < dwMaxDepth; dwDepth++) 
    {
        if (!(pStack[dwDepth].Addr)) {
            break;
        }

        (*prgStack)[dwDepth] = pStack[dwDepth].Addr;

    }

    *pdwMaxDepth = dwDepth;

    RtlFreeHeap(
        RtlProcessHeap(),
        0,
        pStack);

    return STATUS_SUCCESS;
}


#endif // DBG
#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\local\stkwalk.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    stkwalk.c

Abstract:

    This module contains memory debug routines for catching memory leaks and memory
    overwrites.

Author:
    Stolen from dbgmem.c
    Jim Stewart/Ramesh Pabbati    January 8, 1996

    Fixed up for regleaks
    UShaji                        Dec 11th,  1998

Revision History:

--*/

#ifdef LOCAL
#ifdef LEAK_TRACK

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include<imagehlp.h>
#include "regleak.h"
#include "stkwalk.h"
DWORD   MachineType;            // the architecutre we are on
HANDLE  OurProcess;             // the process that we are running as a part of



// typedefs from imagehlp.dll

typedef BOOL (WINAPI * PFNSYMINITIALIZE)(HANDLE hProcess,
                                         PSTR UserSearchPath,
                                         BOOL fInvadeProcess);

typedef BOOL (WINAPI * PFNSYMCLEANUP)(HANDLE hProcess);

typedef BOOL (WINAPI * PFNSTACKWALK)(DWORD MachineType,
                                  HANDLE hProcess,
                                  HANDLE hThread,
                                  LPSTACKFRAME StackFrame,
                                  PVOID ContextRecord,
                                  PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
                                  PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
                                  PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
                                  PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);

typedef BOOL (WINAPI * PFNSYMGETSYMFROMADDR)(HANDLE hProcess,
                                             DWORD_PTR Address,
                                             PDWORD_PTR Displacement,
                                             PIMAGEHLP_SYMBOL Symbol);


typedef DWORD_PTR (WINAPI * PFNSYMGETMODULEBASE)(HANDLE hProcess,
                                          DWORD_PTR dwAddr);


typedef PVOID (WINAPI * PFNSYMFUNCTIONTABLEACCESS)(HANDLE hProcess,
                                                DWORD_PTR AddrBase);


// imagehlp function pointers

PFNSYMINITIALIZE            g_pfnSymInitialize=NULL;
PFNSYMCLEANUP               g_pfnSymCleanup=NULL;
PFNSTACKWALK                g_pfnStackWalk=NULL;
PFNSYMGETSYMFROMADDR        g_pfnSymGetSymFromAddr=NULL;
PFNSYMFUNCTIONTABLEACCESS   g_pfnSymFunctionTableAccess=NULL;
PFNSYMGETMODULEBASE         g_pfnSymGetModuleBase=NULL;

HINSTANCE                   g_hImagehlpInstance=NULL;


BOOL fDebugInitialised = FALSE;


BOOL
InitDebug(
    );


DWORD GetStack(
    IN EXCEPTION_POINTERS *exp,
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind,
    IN int           fResolveSymbols
    );

BOOL LoadImageHLP()
{

   g_hImagehlpInstance = LoadLibrary ("imagehlp.dll");

   if (!g_hImagehlpInstance) {
        return FALSE;
   }


   g_pfnSymInitialize = (PFNSYMINITIALIZE) GetProcAddress (g_hImagehlpInstance,
                                                           "SymInitialize");
   if (!g_pfnSymInitialize) {
        return FALSE;
   }

   g_pfnSymCleanup = (PFNSYMCLEANUP) GetProcAddress (g_hImagehlpInstance,
                                                           "SymCleanup");
   if (!g_pfnSymCleanup) {
        return FALSE;
   }


   g_pfnStackWalk = (PFNSTACKWALK) GetProcAddress (g_hImagehlpInstance,
                                                           "StackWalk");
   if (!g_pfnStackWalk) {
        return FALSE;
   }


   g_pfnSymGetSymFromAddr = (PFNSYMGETSYMFROMADDR) GetProcAddress (g_hImagehlpInstance,
                                                           "SymGetSymFromAddr");
   if (!g_pfnSymGetSymFromAddr) {
        return FALSE;
   }


   g_pfnSymFunctionTableAccess = (PFNSYMFUNCTIONTABLEACCESS) GetProcAddress (g_hImagehlpInstance,
                                                           "SymFunctionTableAccess");
   if (!g_pfnSymFunctionTableAccess) {
        return FALSE;
   }


   g_pfnSymGetModuleBase = (PFNSYMGETMODULEBASE) GetProcAddress (g_hImagehlpInstance,
                                                           "SymGetModuleBase");
   if (!g_pfnSymGetModuleBase) {
        return FALSE;
   }

   return TRUE;
}


BOOL
InitDebug(
    )
/*++

Description:

    This routine initializes the debug memory functionality.

Arguments:

    none

Return Value:

    BOOL - pass or fail

--*/
{
    BOOL        status;
    SYSTEM_INFO SysInfo;

    if (fDebugInitialised)
        return TRUE;

    status = RtlEnterCriticalSection(&(g_RegLeakTraceInfo.StackInitCriticalSection));
    ASSERT( NT_SUCCESS( status ) );

    if (fDebugInitialised)
        return TRUE;

    OurProcess = GetCurrentProcess();



    g_RegLeakTraceInfo.szSymPath = (LPTSTR) RtlAllocateHeap(
                                                            RtlProcessHeap(),
                                                            0,
                                                            SYM_PATH_MAX_SIZE*sizeof(TCHAR));


    if (!g_RegLeakTraceInfo.szSymPath) {
        // looks like machine already doesn't have enough memory
        // disable leak tracking
        g_RegLeakTraceInfo.bEnableLeakTrack = 0;
        return FALSE;
    }

    g_RegLeakTraceInfo.dwMaxStackDepth = GetProfileInt(TEXT("RegistryLeak"), TEXT("StackDepth"), MAX_LEAK_STACK_DEPTH);
    GetProfileString(TEXT("RegistryLeak"), TEXT("SymbolPath"), TEXT(""), g_RegLeakTraceInfo.szSymPath, SYM_PATH_MAX_SIZE);


    if (!(*g_RegLeakTraceInfo.szSymPath)) {

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            g_RegLeakTraceInfo.szSymPath);

            g_RegLeakTraceInfo.szSymPath = NULL;
    }


    if (!LoadImageHLP()) {
        g_RegLeakTraceInfo.bEnableLeakTrack = FALSE;
        status = RtlLeaveCriticalSection(&(g_RegLeakTraceInfo.StackInitCriticalSection));
        return FALSE;
    }

    GetSystemInfo( &SysInfo );
    switch (SysInfo.wProcessorArchitecture) {

    default:
    case PROCESSOR_ARCHITECTURE_INTEL:
        MachineType = IMAGE_FILE_MACHINE_I386;
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        //
        // note this may not detect R10000 machines correctly
        //
        MachineType = IMAGE_FILE_MACHINE_R4000;
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        MachineType = IMAGE_FILE_MACHINE_ALPHA;
        break;

    case PROCESSOR_ARCHITECTURE_PPC:
        MachineType = IMAGE_FILE_MACHINE_POWERPC;
        break;

    }


    // symbols from Current directory/Environment variable _NT_SYMBOL_PATH
    // Environment variable _NT_ALTERNATE_SYMBOL_PATH or Environment variable SYSTEMROOT

    status = g_pfnSymInitialize ( OurProcess, g_RegLeakTraceInfo.szSymPath, FALSE );

    fDebugInitialised = TRUE;

    status = RtlLeaveCriticalSection(&(g_RegLeakTraceInfo.StackInitCriticalSection));
    return( TRUE );
}

BOOL
StopDebug()
{
    if (fDebugInitialised) {

        BOOL fSuccess;

        fSuccess = g_pfnSymCleanup(OurProcess);

        fDebugInitialised = FALSE;

        FreeLibrary(g_hImagehlpInstance);

        if (g_RegLeakTraceInfo.szSymPath) {
            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                g_RegLeakTraceInfo.szSymPath);
        }

        return fSuccess;
    }
    return TRUE;
}

BOOL
ReadMem(
    IN HANDLE   hProcess,
    IN LPCVOID  BaseAddr,
    IN LPVOID   Buffer,
    IN DWORD    Size,
    IN LPDWORD  NumBytes )
/*++

Description:

    This is a callback routine that StackWalk uses - it just calls teh system ReadProcessMemory
    routine with this process's handle

Arguments:


Return Value:

    none

--*/

{
    BOOL    status;
    SIZE_T  RealNumberBytesRead;

    status = ReadProcessMemory( GetCurrentProcess(),BaseAddr,Buffer,Size,&RealNumberBytesRead );
    *NumBytes = (DWORD)RealNumberBytesRead;

    return( status );
}


VOID
GetCallStack(
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind,
    IN int           fResolveSymbols
    )
/*++

Description:

    This routine walks te stack to find the return address of caller. The number of callers
    and the number of callers on top to be skipped can be specified.

Arguments:

    pdwCaller       array of DWORD to return callers
                    return addresses
    Skip            no. of callers to skip
    cFInd           no. of callers to find

Return Value:

    none

--*/
{

    if (!g_RegLeakTraceInfo.bEnableLeakTrack) {
        return;
    }

    if (!InitDebug()) {
        return;
    }

    __try {
        memset(Caller, 0, cFind * sizeof(CALLER_SYM));
        RaiseException(MY_DBG_EXCEPTION, 0, 0, NULL);
        // raise an exception to get the exception record to start the stack walk
        //
    }
    __except(GetStack(GetExceptionInformation(), Caller, Skip, cFind, fResolveSymbols)) {
    }
}

DWORD GetStack(
    IN EXCEPTION_POINTERS *exp,
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind,
    IN int           fResolveSymbols
    )
{
    BOOL             status;
    CONTEXT          ContextRecord;
    PUCHAR           Buffer[sizeof(IMAGEHLP_SYMBOL)-1 + MAX_FUNCTION_INFO_SIZE]; // symbol info
    PIMAGEHLP_SYMBOL Symbol = (PIMAGEHLP_SYMBOL)Buffer;
    STACKFRAME       StackFrame;
    INT              i;
    DWORD            Count;

    memcpy(&ContextRecord, exp->ContextRecord, sizeof(CONTEXT));

    ZeroMemory( &StackFrame,sizeof(STACKFRAME) );
    StackFrame.AddrPC.Segment = 0;
    StackFrame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
    StackFrame.AddrFrame.Offset = ContextRecord.Ebp;
    StackFrame.AddrFrame.Mode = AddrModeFlat;

    StackFrame.AddrStack.Offset = ContextRecord.Esp;
    StackFrame.AddrStack.Mode = AddrModeFlat;

    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Eip;
#elif defined(_M_MRX000)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Fir;
#elif defined(_M_ALPHA)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Fir;
#elif defined(_M_PPC)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Iar;
#endif

    Count = 0;
    for (i=0;i<cFind+Skip ;i++ ) {
        status = g_pfnStackWalk( MachineType,
            OurProcess,
            GetCurrentThread(),
            &StackFrame,
            (PVOID)&ContextRecord,
            (PREAD_PROCESS_MEMORY_ROUTINE)ReadMem,
            g_pfnSymFunctionTableAccess,
            g_pfnSymGetModuleBase,
            NULL );


        if (status) {
            if ( i >= Skip) {
                DWORD   Displacement;

                ZeroMemory( Symbol,sizeof(IMAGEHLP_SYMBOL)-1 + MAX_FUNCTION_INFO_SIZE );
                Symbol->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
                Symbol->Address = StackFrame.AddrPC.Offset;
                Symbol->MaxNameLength = MAX_FUNCTION_INFO_SIZE-1;
                Symbol->Flags = SYMF_OMAP_GENERATED;

                if (fResolveSymbols)
                    status = g_pfnSymGetSymFromAddr( OurProcess,StackFrame.AddrPC.Offset,(DWORD_PTR*)&Displacement,Symbol );

                //
                // save the name of the function and the displacement into it for later printing
                //

                Caller[Count].Addr = (PVOID)StackFrame.AddrPC.Offset;

                if (status) {
                    strcpy( Caller[Count].Buff,Symbol->Name );
                    Caller[Count].Displacement = Displacement;
                }
                Count++;
            }

        } else {
            break;
        }
    }

    return EXCEPTION_CONTINUE_EXECUTION;
    // done with exceptions
}

#endif // LEAK_TRACK
#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\datalogi.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datalogi.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Physical Disk Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datalogi.h"

// dummy variable for field sizing.
static LDISK_COUNTER_DATA   lcd;

//
//  Constant structure initializations 
//      defined in datalogi.h
//
LDISK_DATA_DEFINITION LogicalDiskDataDefinition = {

    {   0,
        sizeof(LDISK_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        LOGICAL_DISK_OBJECT_TITLE_INDEX,
        0,
        237,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(LDISK_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        5,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        408,
        0,
        409,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof (lcd.DiskFreeMbytes1),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskFreeMbytes1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        408,
        0,
        409,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_BASE,
        sizeof (lcd.DiskTotalMbytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTotalMbytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        410,
        0,
        411,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (lcd.DiskFreeMbytes2),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskFreeMbytes2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        198,
        0,
        199,
        0,
        1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (lcd.DiskCurrentQueueLength),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskCurrentQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        200,
        0,
        201,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (lcd.DiskTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        200,
        0,
        201,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (lcd.DiskTimeTimestamp),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTimeTimestamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1400,
        0,
        1401,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (lcd.DiskAvgQueueLength),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        202,
        0,
        203,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (lcd.DiskReadTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        202,
        0,
        203,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (lcd.DiskTimeTimestamp),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTimeTimestamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1402,
        0,
        1403,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (lcd.DiskReadQueueLength),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        204,
        0,
        205,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (lcd.DiskWriteTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWriteTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        204,
        0,
        205,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (lcd.DiskTimeTimestamp),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTimeTimestamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1404,
        0,
        1405,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (lcd.DiskWriteQueueLength),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWriteQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        206,
        0,
        207,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (lcd.DiskAvgTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        206,
        0,
        207,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskTransfersBase1),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTransfersBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        208,
        0,
        209,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (lcd.DiskAvgReadTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgReadTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        208,
        0,
        209,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskReadsBase1),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadsBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        210,
        0,
        211,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (lcd.DiskAvgWriteTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgWriteTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        210,
        0,
        211,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskWritesBase1),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWritesBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        212,
        0,
        213,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (lcd.DiskTransfers),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTransfers
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        214,
        0,
        215,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (lcd.DiskReads),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        216,
        0,
        217,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (lcd.DiskWrites),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWrites
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        218,
        0,
        219,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (lcd.DiskBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        220,
        0,
        221,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (lcd.DiskReadBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        222,
        0,
        223,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (lcd.DiskWriteBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        224,
        0,
        225,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (lcd.DiskAvgBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        224,
        0,
        225,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskTransfersBase2),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTransfersBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        226,
        0,
        227,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (lcd.DiskAvgReadBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        226,
        0,
        227,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskReadsBase2),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadsBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        228,
        0,
        229,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (lcd.DiskAvgWriteBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgWriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        228,
        0,
        229,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskWritesBase2),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWritesBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1482,
        0,
        1483,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_PRECISION_100NS_TIMER,
        sizeof (lcd.IdleTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->IdleTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1482,
        0,
        1483,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (lcd.DiskTimeTimestamp),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTimeTimestamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1484,
        0,
        1485,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (lcd.SplitCount),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->SplitCount
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\common\perfutil.c ===
/*++

Copyright (c) 1995-6  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
    common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Bob Watson  28-Jul-1995

Revision History:

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "perfutil.h"
#include "perfmsg.h"

//
// Global data definitions.
//

ULONG ulInfoBufferSize = 0;

extern HANDLE hEventLog;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

const WCHAR GLOBAL_STRING[] = L"Global";
const WCHAR FOREIGN_STRING[] = L"Foreign";
const WCHAR COSTLY_STRING[] = L"Costly";

const WCHAR NULL_STRING[] = L"\0";    // pointer to null string

const WCHAR  szTotalValue[] = L"TotalInstanceName";
const WCHAR  szDefaultTotalString[] = L"_Total";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
)
/*++

    read and return the current value of the specified value
    under the Perflib registry key. If unable to read the value
    return the default value from the argument list.

    the value is returned in the pReturnBuffer.

--*/
{

    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          PerflibSubKeyString;
    UNICODE_STRING          ValueNameString;
    LONG                    lReturn = ERROR_SUCCESS;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation;
    DWORD                   ValueBufferLength;
    DWORD                   ResultLength;
    BOOL                    bUseDefault = TRUE;

    // initialize UNICODE_STRING structures used in this function

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        (LPCWSTR)L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    RtlInitUnicodeString (
        &ValueNameString,
        (LPWSTR)szItem);

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //
    InitializeObjectAttributes(
            &Obja,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                KEY_READ,
                &Obja
                );

    if (NT_SUCCESS( Status )) {
        // read value of desired entry

        ValueBufferLength = ResultLength = 1024;
        pValueInformation = ALLOCMEM(ResultLength);

        if (pValueInformation != NULL) {
            while ( (Status = NtQueryValueKey(hPerflibKey,
                                            &ValueNameString,
                                            KeyValuePartialInformation,
                                            pValueInformation,
                                            ValueBufferLength,
                                            &ResultLength))
                    == STATUS_BUFFER_OVERFLOW ) {

                FREEMEM(pValueInformation);
                pValueInformation = ALLOCMEM(ResultLength);
                if ( pValueInformation == NULL) {
                    ValueBufferLength = 0;
                    break;
                } else {
                    ValueBufferLength = ResultLength;
                }
            }

            if (NT_SUCCESS(Status)) {
                // check to see if it's the desired type
                if (pValueInformation->Type == dwRegType) {
                    // see if it will fit
                    if (pValueInformation->DataLength <= dwMaxSize) {
                        memcpy (pReturnBuffer, &pValueInformation->Data[0],
                            pValueInformation->DataLength);
                        bUseDefault = FALSE;
                        lReturn = STATUS_SUCCESS;
                    }
                }
            } else {
                // return the default value
                lReturn = Status;
            }
            // release temp buffer
            FREEMEM (pValueInformation);
        } else {
            // unable to allocate memory for this operation so
            // just return the default value
        }
        // close the registry key
        NtClose(hPerflibKey);
    } else {
        // return default value
    }

    if (bUseDefault) {
        memcpy (pReturnBuffer, pDefault, dwDefaultSize);
        lReturn = STATUS_SUCCESS;
    }

    return lReturn;
}

HANDLE
MonOpenEventLog (
    IN  LPWSTR  szAppName
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
    TCHAR LogLevelValueName[] = TEXT("EventLogLevel");

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSourceW (
            (LPTSTR)NULL,            // Use Local Machine
            szAppName);               // event log app name to find in registry
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible
    BOOL    bNotDone;
    BOOL    bReturnValue = FALSE;

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    bNotDone = TRUE;

    while ( bNotDone ) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) {
                        bNotDone = FALSE;
                        bReturnValue = TRUE;
                    } else {
                        bValidNumber = FALSE;
                    }
                }
                if (*pwcThisChar == 0) {
                    bNotDone = FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }
    return bReturnValue;
}   // IsNumberInUnicodeList


BOOL
MonBuildInstanceDefinitionByUnicodeString(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    WCHAR *pName;

    //
    //  Include trailing null in name size
    //

    //ASSERT( (((ULONG_PTR) pBuffer) & 0x07) == 0 );
    NameLength = Name->Length;
    if ( !NameLength ||
         Name->Buffer[(NameLength/sizeof(WCHAR))-1] != UNICODE_NULL ) {
        NameLength += sizeof(WCHAR);
    }

    pBuffer->ByteLength = QWORD_MULTIPLE(sizeof(PERF_INSTANCE_DEFINITION) + NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    pName = (PWCHAR)&pBuffer[1];
    RtlMoveMemory(pName,Name->Buffer,Name->Length);

    //  Always null terminated.  Space for this reserved above.

    pName[(NameLength/sizeof(WCHAR))-1] = UNICODE_NULL;

    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
    return 0;
}


BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    UNICODE_STRING uName;
    //
    //  Include trailing null in name size
    //

    NameLength = lstrlenW(Name) * sizeof(WCHAR);
    uName.Buffer = Name;
    uName.Length = (USHORT) NameLength;
    uName.MaximumLength = uName.Length + sizeof(WCHAR);

    return 
        MonBuildInstanceDefinitionByUnicodeString(
            pBuffer,
            pBufferNext,
            ParentObjectTitleIndex,
            ParentObjectInstance,
            UniqueID,
            &uName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\common\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

#include <windows.h>
#include <winperf.h>

#define MAX_INSTANCE_NAME   32
#ifdef _WIN64
#define SMALL_BUFFER_SIZE   ((DWORD)8192)
#else
#define SMALL_BUFFER_SIZE   ((DWORD)4096)
#endif
#define MEDIUM_BUFFER_SIZE  ((DWORD)(4096*8))
#define LARGE_BUFFER_SIZE   ((DWORD)(4096*16))
#define INCREMENT_BUFFER_SIZE ((DWORD)(4096*2))

#define MAX_VALUE_NAME_LENGTH 256*sizeof(WCHAR)
#define MAX_VALUE_DATA_LENGTH 256*sizeof(WCHAR)
//
//  Until USER supports Unicode, we have to work in ASCII:
//

#define DEFAULT_NT_CODE_PAGE 437
#define UNICODE_CODE_PAGE      0

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
//  Assumes x is DWORD, and returns a DWORD
//
#define DWORD_MULTIPLE(x) (((ULONG)(x) + ((sizeof(DWORD))-1)) & ~((ULONG)(sizeof(DWORD))-1))
#define QWORD_MULTIPLE(x) (((ULONG)(x) + ((sizeof(ULONG64))-1)) & ~((ULONG)(sizeof(ULONG64))-1))
#define PAGESIZE_MULTIPLE(x) \
     (((ULONG)(x) + ((SMALL_BUFFER_SIZE)-1)) & ~((ULONG)(SMALL_BUFFER_SIZE)-1))

//
//  Returns a PVOID
//
#define ALIGN_ON_DWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((sizeof(DWORD))-1)) & ~((ULONG_PTR)(sizeof(DWORD))-1)))
#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((sizeof(ULONG64))-1)) & ~((ULONG_PTR)(sizeof(ULONG64))-1)))

extern const    WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern const    WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern const    WCHAR  COSTLY_STRING[];      
extern const    WCHAR  NULL_STRING[];

extern const    WCHAR  szTotalValue[];
extern const    WCHAR  szDefaultTotalString[];
#define DEFAULT_TOTAL_STRING_LEN    14

extern DWORD  MESSAGE_LEVEL;

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// function prototypes for data collection routines
typedef DWORD (APIENTRY PM_LOCAL_COLLECT_PROC) (LPVOID *, LPDWORD, LPDWORD);

typedef struct _POS_FUNCTION_INFO {
    DWORD   dwObjectId;
    DWORD   dwCollectFunctionBit;
    DWORD   dwDataFunctionBit;
    PM_LOCAL_COLLECT_PROC *pCollectFunction;
} POS_FUNCTION_INFO, * PPOS_FUNCTION_INFO;

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog (IN LPWSTR);
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name
    );

LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
);

//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#ifdef DBG
#define PERF_HEAP_FLAGS    HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS
#else
#define PERF_HEAP_FLAGS    HEAP_ZERO_MEMORY
#endif

#ifndef PERF_HEAP
#define PERF_HEAP RtlProcessHeap()
#endif

#define ALLOCMEM(size)     HeapAlloc (PERF_HEAP, PERF_HEAP_FLAGS, size)
#define REALLOCMEM(pointer, newsize) \
                  HeapReAlloc (PERF_HEAP, 0, pointer, newsize)
#define FREEMEM(pointer)   HeapFree (PERF_HEAP, 0, pointer)

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\datalogi.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATALOGI.h

Abstract:

    Header file for the Windows NT Processor Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATALOGI_H_
#define _DATALOGI_H_

//
//  logical disk performance definition structure
//

typedef struct _LDISK_DATA_DEFINITION {
    PERF_OBJECT_TYPE            DiskObjectType;
    PERF_COUNTER_DEFINITION     cdDiskFreeMbytes1;
    PERF_COUNTER_DEFINITION     cdDiskTotalMbytes;
    PERF_COUNTER_DEFINITION     cdDiskFreeMbytes2;
    PERF_COUNTER_DEFINITION     cdDiskCurrentQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskTime;
    PERF_COUNTER_DEFINITION     cdDiskTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskAvgQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskReadTime;
    PERF_COUNTER_DEFINITION     cdDiskReadTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskReadQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskWriteTime;
    PERF_COUNTER_DEFINITION     cdDiskWriteTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskWriteQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskAvgTime;
    PERF_COUNTER_DEFINITION     cdDiskTransfersBase1;
    PERF_COUNTER_DEFINITION     cdDiskAvgReadTime;
    PERF_COUNTER_DEFINITION     cdDiskReadsBase1;
    PERF_COUNTER_DEFINITION     cdDiskAvgWriteTime;
    PERF_COUNTER_DEFINITION     cdDiskWritesBase1;
    PERF_COUNTER_DEFINITION     cdDiskTransfers;
    PERF_COUNTER_DEFINITION     cdDiskReads;
    PERF_COUNTER_DEFINITION     cdDiskWrites;
    PERF_COUNTER_DEFINITION     cdDiskBytes;
    PERF_COUNTER_DEFINITION     cdDiskReadBytes;
    PERF_COUNTER_DEFINITION     cdDiskWriteBytes;
    PERF_COUNTER_DEFINITION     cdDiskAvgBytes;
    PERF_COUNTER_DEFINITION     cdDiskTransfersBase2;
    PERF_COUNTER_DEFINITION     cdDiskAvgReadBytes;
    PERF_COUNTER_DEFINITION     cdDiskReadsBase2;
    PERF_COUNTER_DEFINITION     cdDiskAvgWriteBytes;
    PERF_COUNTER_DEFINITION     cdDiskWritesBase2;
    PERF_COUNTER_DEFINITION     cdIdleTime;
    PERF_COUNTER_DEFINITION     cdIdleTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdSplitCount;
} LDISK_DATA_DEFINITION, *PLDISK_DATA_DEFINITION;

typedef struct _LDISK_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   DiskFreeMbytes1;
    DWORD                   DiskTotalMbytes;
    DWORD                   DiskFreeMbytes2;
    DWORD                   DiskCurrentQueueLength;
    DWORD                   DiskTransfersBase1;
    LONGLONG                DiskTime;
    LONGLONG                DiskAvgQueueLength;
    LONGLONG                DiskReadTime;
    LONGLONG                DiskReadQueueLength;
    LONGLONG                DiskWriteTime;
    LONGLONG                DiskWriteQueueLength;
    LONGLONG                DiskAvgTime;
    LONGLONG                DiskAvgReadTime;
    LONGLONG                DiskAvgWriteTime;
    DWORD                   DiskReadsBase1;
    DWORD                   DiskWritesBase1;
    DWORD                   DiskTransfers;
    DWORD                   DiskReads;
    DWORD                   DiskWrites;
    DWORD                   DiskTransfersBase2;
    LONGLONG                DiskBytes;
    LONGLONG                DiskReadBytes;
    LONGLONG                DiskWriteBytes;
    LONGLONG                DiskAvgBytes;
    LONGLONG                DiskAvgReadBytes;
    LONGLONG                DiskAvgWriteBytes;
    DWORD                   DiskReadsBase2;
    DWORD                   DiskWritesBase2;
    LONGLONG                IdleTime;
    LONGLONG                DiskTimeTimestamp;
    DWORD                   SplitCount;
} LDISK_COUNTER_DATA, * PLDISK_COUNTER_DATA;

extern LDISK_DATA_DEFINITION LogicalDiskDataDefinition;

#endif // _DATALOGI_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\dataphys.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAPHYS.h

Abstract:

    Header file for the Windows NT Processor Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAPHYS_H_
#define _DATAPHYS_H_

//
//  physical disk performance definition structure
//

typedef struct _PDISK_DATA_DEFINITION {
    PERF_OBJECT_TYPE            DiskObjectType;
    PERF_COUNTER_DEFINITION     cdDiskCurrentQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskTime;
    PERF_COUNTER_DEFINITION     cdDiskTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskAvgQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskReadTime;
    PERF_COUNTER_DEFINITION     cdDiskReadTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskReadQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskWriteTime;
    PERF_COUNTER_DEFINITION     cdDiskWriteTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskWriteQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskAvgTime;
    PERF_COUNTER_DEFINITION     cdDiskTransfersBase1;
    PERF_COUNTER_DEFINITION     cdDiskAvgReadTime;
    PERF_COUNTER_DEFINITION     cdDiskReadsBase1;
    PERF_COUNTER_DEFINITION     cdDiskAvgWriteTime;
    PERF_COUNTER_DEFINITION     cdDiskWritesBase1;
    PERF_COUNTER_DEFINITION     cdDiskTransfers;
    PERF_COUNTER_DEFINITION     cdDiskReads;
    PERF_COUNTER_DEFINITION     cdDiskWrites;
    PERF_COUNTER_DEFINITION     cdDiskBytes;
    PERF_COUNTER_DEFINITION     cdDiskReadBytes;
    PERF_COUNTER_DEFINITION     cdDiskWriteBytes;
    PERF_COUNTER_DEFINITION     cdDiskAvgBytes;
    PERF_COUNTER_DEFINITION     cdDiskTransfersBase2;
    PERF_COUNTER_DEFINITION     cdDiskAvgReadBytes;
    PERF_COUNTER_DEFINITION     cdDiskReadsBase2;
    PERF_COUNTER_DEFINITION     cdDiskAvgWriteBytes;
    PERF_COUNTER_DEFINITION     cdDiskWritesBase2;
    PERF_COUNTER_DEFINITION     cdIdleTime;
    PERF_COUNTER_DEFINITION     cdIdleTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdSplitCount;
} PDISK_DATA_DEFINITION, * PPDISK_DATA_DEFINITION;



typedef struct _PDISK_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   DiskCurrentQueueLength;
    LONGLONG                DiskTime;
    LONGLONG                DiskAvgQueueLength;
    LONGLONG                DiskReadTime;
    LONGLONG                DiskReadQueueLength;
    LONGLONG                DiskWriteTime;
    LONGLONG                DiskWriteQueueLength;
    LONGLONG                DiskAvgTime;
    LONGLONG                DiskAvgReadTime;
    DWORD                   DiskTransfersBase1;
    DWORD                   DiskReadsBase1;
    LONGLONG                DiskAvgWriteTime;
    DWORD                   DiskWritesBase1;
    DWORD                   DiskTransfers;
    DWORD                   DiskReads;
    DWORD                   DiskWrites;
    LONGLONG                DiskBytes;
    LONGLONG                DiskReadBytes;
    LONGLONG                DiskWriteBytes;
    LONGLONG                DiskAvgBytes;
    LONGLONG                DiskAvgReadBytes;
    DWORD                   DiskTransfersBase2;
    DWORD                   DiskReadsBase2;
    LONGLONG                DiskAvgWriteBytes;
    LONGLONG                IdleTime;
    LONGLONG                DiskTimeTimeStamp;
    DWORD                   DiskWritesBase2;
    DWORD                   SplitCount;
} PDISK_COUNTER_DATA, * PPDISK_COUNTER_DATA;

extern PDISK_DATA_DEFINITION PhysicalDiskDataDefinition;

#endif // _DATAPHYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\dataphys.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataphys.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Physical Disk Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataphys.h"

// dummy variable for field sizing.
static PDISK_COUNTER_DATA   pcd;

//
//  Constant structure initializations 
//      defined in dataphys.h
//

PDISK_DATA_DEFINITION PhysicalDiskDataDefinition = {

    {   0,
        sizeof(PDISK_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        PHYSICAL_DISK_OBJECT_TITLE_INDEX,
        0,
        235,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(PDISK_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        2,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        198,
        0,
        199,
        0,
        1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (pcd.DiskCurrentQueueLength),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskCurrentQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        200,
        0,
        201,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (pcd.DiskTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        200,
        0,
        201,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (pcd.DiskTimeTimeStamp),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTimeTimeStamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1400,
        0,
        1401,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (pcd.DiskAvgQueueLength),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        202,
        0,
        203,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (pcd.DiskReadTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        202,
        0,
        203,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (pcd.DiskTimeTimeStamp),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTimeTimeStamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1402,
        0,
        1403,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (pcd.DiskReadQueueLength),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        204,
        0,
        205,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (pcd.DiskWriteTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWriteTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        204,
        0,
        205,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (pcd.DiskTimeTimeStamp),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTimeTimeStamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1404,
        0,
        1405,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (pcd.DiskWriteQueueLength),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWriteQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        206,
        0,
        207,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (pcd.DiskAvgTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        206,
        0,
        207,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskTransfersBase1),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTransfersBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        208,
        0,
        209,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (pcd.DiskAvgReadTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgReadTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        208,
        0,
        209,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskReadsBase1),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadsBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        210,
        0,
        211,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (pcd.DiskAvgWriteTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgWriteTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        210,
        0,
        211,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskWritesBase1),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWritesBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        212,
        0,
        213,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (pcd.DiskTransfers),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTransfers
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        214,
        0,
        215,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (pcd.DiskReads),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        216,
        0,
        217,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (pcd.DiskWrites),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWrites
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        218,
        0,
        219,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (pcd.DiskBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        220,
        0,
        221,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (pcd.DiskReadBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        222,
        0,
        223,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (pcd.DiskWriteBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        224,
        0,
        225,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (pcd.DiskAvgBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        224,
        0,
        225,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskTransfersBase2),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTransfersBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        226,
        0,
        227,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (pcd.DiskAvgReadBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        226,
        0,
        227,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskReadsBase2),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadsBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        228,
        0,
        229,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (pcd.DiskAvgWriteBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgWriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        228,
        0,
        229,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskWritesBase2),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWritesBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1482,
        0,
        1483,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_PRECISION_100NS_TIMER,
        sizeof (pcd.IdleTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->IdleTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1482,
        0,
        1483,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (pcd.DiskTimeTimeStamp),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTimeTimeStamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1484,
        0,
        1485,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (pcd.SplitCount),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->SplitCount
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\diskutil.h ===
#ifndef __DISKUTIL_H_
#define __DISKUTIL_H_

#ifndef _DBG_PRINT_INSTANCES
#define _DBG_PRINT_INSTANCES 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning ( disable : 4201 ) 

#include <ntdddisk.h>
#include <ntddvol.h>
#include <strsafe.h>

extern BOOL                 bUseNT4InstanceNames;
extern HANDLE               hLibHeap;       // Handle to DLL Heap
extern LONG                 g_lRefreshInterval_OnLine;

#define DU_MAX_VOLUMES      ((WORD)0xFFFF)
#define DU_MAX_DRIVES       ((WORD)0xFFFF)
#define DU_MAX_PARTITIONS   ((WORD)0xFFFF)

#define INITIAL_NUM_VOL_LIST_ENTRIES    ((DWORD)0x0000001A)

#define DVE_DEV_NAME_LEN    ((DWORD)368)

typedef struct _DRIVE_VOLUME_ENTRY {
    union {
        DWORD   dwDriveId;      // 00-03
        struct {
            WORD    wPartNo;
            WORD    wDriveNo;
        };
    };                  
    WORD    wcDriveLetter;      // 04-05
    WORD    wReserved;          // 06-07
    union {
        WCHAR   szVolumeManager[8];
        ULONG64 llVolMgr[2];
    };                          // 08-17
    DWORD   dwVolumeNumber;     // 18-1B
    HANDLE  hVolume;            // 1C-17
    WCHAR   wszInstanceName[DVE_DEV_NAME_LEN];  // 20-1FF
    UNICODE_STRING DeviceName;
    ULONGLONG TotalBytes;
    ULONGLONG FreeBytes;
    LONGLONG  LastRefreshTime;
    WCHAR     VolumePath[MAX_PATH+1];
    BOOL      bOffLine;
} DRIVE_VOLUME_ENTRY, *PDRIVE_VOLUME_ENTRY;

typedef struct _DRIVE_LIST {
    LIST_ENTRY          Entry;
    DRIVE_VOLUME_ENTRY  DiskEntry;
} DRIVE_LIST, *PDRIVE_LIST;

#define LL_PARTMGR_0    ((LONGLONG)0x0074007200610050) //"Part"
#define LL_PARTMGR_1    ((LONGLONG)0x002000720067006D) //"mgr "

#define LL_PHYSDISK_0   ((LONGLONG)0x0073007900680050) //"Phys"
#define LL_PHYSDISK_1   ((LONGLONG)0x006B007300690044) //"Disk"

#define LL_LOGIDISK_0   ((LONGLONG)0x00690067006F004C) //"Logi"
#define LL_LOGIDISK_1   ((LONGLONG)0x006B007300690044) //"Disk"

#pragma warning ( default : 4201 )

__inline
BOOL
IsPhysicalDrive (PDISK_PERFORMANCE pPerfInf) {
    LPWSTR szName = &pPerfInf->StorageManagerName[0];
    PLONGLONG pllName = (PLONGLONG) ((PVOID) &pPerfInf->StorageManagerName[0]);

    if ( ((ULONG_PTR) szName & 0x07) != 0) {
        if (!wcsncmp(szName, L"Partmgr ", sizeof(LONG64)))
            return TRUE;
        if (!wcsncmp(szName, L"PhysDisk", sizeof(LONG64)))
            return TRUE;
        return FALSE;
    }
    else
    if (((pllName[0] == LL_PARTMGR_0) &&
         (pllName[1] == LL_PARTMGR_1)) ||
        ((pllName[0] == LL_PHYSDISK_0) &&
         (pllName[1] == LL_PHYSDISK_1))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

DWORD
BuildPhysDiskList (
    HANDLE  hDiskPerf,
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries
);

DWORD
MakePhysDiskInstanceNames (
    PDRIVE_VOLUME_ENTRY pPhysDiskList,
    DWORD               dwNumPhysDiskListItems,
    LPDWORD             pdwMaxDriveNo,
    PDRIVE_VOLUME_ENTRY pVolumeList,
    DWORD               dwNumVolumeListItems
);

DWORD
BuildVolumeList (
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries
);

DWORD
MapLoadedDisks (
    HANDLE  hDiskPerf,
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries,
    LPDWORD             pdwMaxVolumeNo,
    LPDWORD             pdwWmiItemCount
);

DWORD
GetDriveNameString (
    LPCWSTR             szDevicePath,
    DWORD               cchDevicePathSize,
    PDRIVE_VOLUME_ENTRY pList,
    DWORD               dwNumEntries,
    LPWSTR              szNameBuffer,
    LPDWORD             pcchNameBufferSize,
    LPCWSTR             szVolumeManagerName,
    DWORD               dwVolumeNumber,
    PDRIVE_VOLUME_ENTRY *ppVolume
);

DWORD
CompressPhysDiskTable (
    PDRIVE_VOLUME_ENTRY     pOrigTable,
    DWORD                   dwOrigCount,
    PDRIVE_VOLUME_ENTRY     pNewTable,
    DWORD                   dwNewCount
);

BOOL
GetPhysicalDriveNameString (
    DWORD                   dwDriveNumber,    
    PDRIVE_VOLUME_ENTRY     pList,
    DWORD                   dwNumEntries,
    LPWSTR                  szNameBuffer
);

DWORD
FindNewVolumes (
    PDRIVE_VOLUME_ENTRY *ppPhysDiskList,
    LPDWORD             pdwNumPhysDiskListEntries,
    PDRIVE_VOLUME_ENTRY pVolumeList,
    DWORD               dwNumVolumeListItems
);

#if DBG

extern ULONG_PTR HeapUsed;

VOID
PerfDiskDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x)   PerfDiskDebugPrint x

#else

#define DebugPrint(x)
#endif // DBG

#ifdef __cplusplus
}
#endif
#endif // __DISKUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\diskutil.cpp ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#pragma warning ( disable : 4201 ) 
#include <ntdddisk.h>
#pragma warning ( default : 4201 ) 
#include <wtypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <ftapi.h>
#include <mountmgr.h>
#pragma warning ( disable : 4201 ) 
#include <wmium.h>
#pragma warning ( default : 4201 ) 
#include <wmiguid.h>
#include <assert.h>
#define  PERF_HEAP hLibHeap
#include "diskutil.h"
#include "perfutil.h"

#define INITIAL_MOUNTMGR_BUFFER_SIZE    8192

// sizes are in characters (not bytes)
#define SIZE_OF_DOSDEVICES  12L     // size of "\DosDevices\" string
#define SIZE_OF_DEVICE       8L     // size of "\Device\" string
#define SIZE_OF_HARDDISK     8L     // size of "Harddisk" string

static const LONGLONG   llDosDevicesId  = 0x0073006f0044005c; // "\Dos"
static const LONGLONG   llFloppyName    = 0x0070006f006c0046; // "Flop"
static const LONGLONG   llCdRomName     = 0x006f005200640043; // "CdRo"

LONG g_lRefreshInterval_OnLine  = 300; // default to 5 minutes if the volume is on-line
LONG g_lRefreshInterval_OffLine = 5;   // default to 5 seconds if the folume is off-line

BOOL                bUseNT4InstanceNames = FALSE;
DWORD   dwMaxWmiBufSize = 0;

NTSTATUS
OpenDevice(
    IN PUNICODE_STRING DeviceName,
    OUT PHANDLE Handle
    );

NTSTATUS
GetDeviceName(
    PMOUNTMGR_MOUNT_POINTS  pMountPoints,
    IN PMOUNTMGR_MOUNT_POINT Point,
    OUT PUNICODE_STRING DeviceName
    );

VOID
RefreshVolume(
    PDRIVE_VOLUME_ENTRY pVolume
    );

ULONG
GetDiskExtent(
    IN HANDLE hVol,
    IN OUT PVOLUME_DISK_EXTENTS *pVolExtents,
    IN OUT PULONG ReturnedSize
    );

#if DBG
VOID
DumpDiskList(
    IN PDRIVE_VOLUME_ENTRY pList,
    IN ULONG nCount
    );
#endif

DWORD
GetDriveNumberFromDevicePath (
    LPCWSTR szDevicePath,
    DWORD   dwLength,
    LPDWORD pdwDriveId
)
/*
    evaluates the device path and returns the Drive Number 
    if the string is in the following format

        \Device\HarddiskX

    where X is a decimal number (consisting of 1 or more decimal
    digits representing a value between 0 and 65535 inclusive)

    Arguments:
        szDevicePath    Device name
        dwLength        Length of szDevicePath, in characters
        pdwDriveId      Returned Drive Number - assumes pointer is non NULL

    The function returns a value of:
        ERROR_SUCCESS           if successful
        ERROR_INVALID_PARAMETER if the input string is incorrectly formatted
        ERROR_INVALID_DATA      if the volume number is too big
        
*/
{
    PWCHAR  pNumberChar;
    LONG    lValue;
    DWORD   dwDriveAndPartition;
    DWORD   dwReturn, dwFormatLength;

    // validate the input arguments
    assert (szDevicePath != NULL);
    assert (*szDevicePath != 0);
    assert (pdwDriveId != NULL);

    // start at the beginning of the string
    pNumberChar = (PWCHAR)szDevicePath;

    // Locate the beginning of a backslash.

    while ((*pNumberChar != L'\\') && (*pNumberChar != UNICODE_NULL) &&
           (dwLength > 0)) {
        --dwLength;
        pNumberChar++;
    }

    dwFormatLength = SIZE_OF_DEVICE + SIZE_OF_HARDDISK;
    if ((dwLength <= dwFormatLength) || (*pNumberChar == UNICODE_NULL)) {
        // String must be at least 17 chars
        return ERROR_INVALID_PARAMETER;
    }

    if (_wcsnicmp(pNumberChar, L"\\Device\\Harddisk", dwFormatLength)) {
        return ERROR_INVALID_PARAMETER;
    }

    pNumberChar += dwFormatLength;
    if ((*pNumberChar < L'0' ) || (*pNumberChar > L'9')) {
        return ERROR_INVALID_PARAMETER;
    }
    //
    // else skip to drive number
    //
    lValue = _wtol(pNumberChar);
    if (lValue <= (LONG)0x0000FFFF) {
        // load the drive number into the DWORD
        dwDriveAndPartition = (DWORD)lValue;
        *pdwDriveId = dwDriveAndPartition;
        dwReturn = ERROR_SUCCESS;
    } else {
        // drive ID Is out of range
        dwReturn = ERROR_INVALID_DATA;
    }

    return dwReturn;
}

DWORD
GetSymbolicLink (
    LPCWSTR szDeviceString,
    LPWSTR  szLinkString,
    LPDWORD pcchLength
)
/*
    this functions opens the device string as a symbolic link
    and returns the corresponding link string
*/
{
    OBJECT_ATTRIBUTES   Attributes;
    UNICODE_STRING      ObjectName;
    UNICODE_STRING      LinkName;
    WORD                wDevStrLen;
    NTSTATUS            ntStatus;
    DWORD               dwRetSize = 0;
    DWORD               dwReturnStatus;
    HANDLE              hObject = NULL;

    // validate arguments
    assert (szDeviceString != NULL);
    assert (*szDeviceString != 0);
    assert (szLinkString != NULL);
    assert (pcchLength != NULL);
    assert (*pcchLength > 0);

    // get the length of the input string
    wDevStrLen = (WORD)lstrlenW(szDeviceString);

    // create the object name UNICODE string structure
    ObjectName.Length = (WORD)(wDevStrLen * sizeof (WCHAR));
    ObjectName.MaximumLength = (WORD)((wDevStrLen + 1) * sizeof (WCHAR));
    ObjectName.Buffer = (LPWSTR)szDeviceString;

    // initialize the object attributes for the open call
    InitializeObjectAttributes( &Attributes,
                            &ObjectName,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL );

    // open the name as a symbolic link, if this fails, the input
    // name is probably not a link

    ntStatus = NtOpenSymbolicLinkObject(
                            &hObject,
                            SYMBOLIC_LINK_QUERY,
                            &Attributes);

    if (NT_SUCCESS(ntStatus)) {
        // init a Unicode String for the return buffer using the caller's
        // buffer
        LinkName.Length = 0;
        LinkName.MaximumLength = (WORD)(*pcchLength * sizeof (WCHAR));
        LinkName.Buffer = szLinkString;
        RtlZeroMemory(LinkName.Buffer, LinkName.MaximumLength);

        // and look up the link
        ntStatus = NtQuerySymbolicLinkObject(
            hObject, &LinkName, &dwRetSize);

        if (NT_SUCCESS(ntStatus)) {
            // buffer is loaded so set the return status and length
            *pcchLength = LinkName.Length / sizeof (WCHAR);
            // make sure the string is 0 terminated
            szLinkString[*pcchLength] = 0;
            dwReturnStatus = ERROR_SUCCESS;
        } else {
            // unable to look up the link so return the error
            dwReturnStatus = RtlNtStatusToDosError(ntStatus);
        }
        
        // close the handle to the link
        NtClose (hObject);
    } else {
        dwReturnStatus = RtlNtStatusToDosError(ntStatus);
    }
    
    return dwReturnStatus;  
}

LONG
LookupInstanceName(
    LPCWSTR                 szName,
    PDRIVE_VOLUME_ENTRY     pList,
    DWORD                   dwNumEntries,
    DWORD                   dwRetry
)
{
    LONG i, j;

    j = (LONG) dwRetry;
    if (pList == NULL || dwNumEntries == 0) {
        return -1;
    }

    for (i = ((LONG) dwNumEntries) - 1; i >= 0 && j >= 0; i --, j --) {
        if (! lstrcmp(pList[i].wszInstanceName, szName))
            return (DWORD) i;
    }
    return -1;

}

DWORD
BuildPhysDiskList (
    HANDLE  hDiskPerf,
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries
)
{
    DWORD   status = ERROR_SUCCESS; // return value of the function
    HANDLE  hWmiDiskPerf = NULL;    // local handle value 
    DWORD   dwLocalWmiItemCount = 0;

    // WMI Buffer variables
    DWORD   WmiBufSize = 0;
    DWORD   WmiAllocSize = 0x8000;     
    LPBYTE  WmiBuffer = NULL;

    // WMI buffer processing variables
    PWNODE_ALL_DATA     WmiDiskInfo;
    DISK_PERFORMANCE    *pDiskPerformance;    //  Disk driver returns counters here
    DWORD               dwInstanceNameOffset;
    WORD                wNameLen;   // string length is first word in buffer
    LPWSTR              wszInstanceName; // pointer to string in WMI buffer
    
    WCHAR   wszInstName[DVE_DEV_NAME_LEN];
    DWORD   dwBytesToCopy;

    DWORD   dwListEntry;

    BOOL    bNotDone = TRUE;

    DWORD   dwLocalStatus;
    DWORD   dwLocalDriveId;
    DWORD   dwLocalPartition;
    WCHAR   szDrivePartString[DVE_DEV_NAME_LEN];
    DWORD   dwSymbLinkLen;
    WCHAR   szSymbLinkString[DVE_DEV_NAME_LEN];

    if (hDiskPerf == NULL) {
        // open handle to disk perf device driver
        status = WmiOpenBlock (
            (GUID *)&DiskPerfGuid,
            GENERIC_READ,
            &hWmiDiskPerf);
    } else {
        // use caller's handle
        hWmiDiskPerf = hDiskPerf;
    }

    assert (pList != NULL);
    assert (pdwNumEntries != NULL);

    DebugPrint((3, "BuildPhysDisk: dwEntries is %d\n", *pdwNumEntries));
    dwListEntry = 0;

    if (status == ERROR_SUCCESS) {
        // allocate a buffer to send to WMI to get the diskperf data
        WmiBufSize = (dwMaxWmiBufSize > WmiAllocSize) ?
                      dwMaxWmiBufSize : WmiAllocSize;
        WmiAllocSize = WmiBufSize;

        do {
            WmiBuffer = (LPBYTE) ALLOCMEM(WmiBufSize);
            if (WmiBuffer == NULL) {
                status = ERROR_OUTOFMEMORY;
                WmiBufSize = 0;
            }
            else {
#if DBG
                HeapUsed += WmiBufSize;
#endif
                WmiAllocSize = WmiBufSize;  // remember old size
                status = WmiQueryAllDataW(hWmiDiskPerf, &WmiBufSize, WmiBuffer);
                if (status == ERROR_INSUFFICIENT_BUFFER) {
                    FREEMEM(WmiBuffer);
#if DBG
                    HeapUsed -= WmiAllocSize;
#endif
                    WmiBuffer = NULL;
                }
            }
        } while ((status == ERROR_INSUFFICIENT_BUFFER) &&
                 (WmiBufSize > WmiAllocSize));

        if ((status == ERROR_SUCCESS) && (WmiBuffer != NULL)) {
            WmiDiskInfo = (PWNODE_ALL_DATA)WmiBuffer;
            if (WmiBufSize > dwMaxWmiBufSize) {
                dwMaxWmiBufSize = WmiBufSize;
            }
            // go through returned names and add to the buffer
            while (bNotDone) {
#if DBG
                if ((PCHAR) WmiDiskInfo > (PCHAR) WmiBuffer + WmiAllocSize) {
                    DebugPrint((2,
                        "BuildPhysDisk: WmiDiskInfo %d exceeded %d + %d\n",
                        WmiDiskInfo, WmiBuffer, WmiAllocSize));
                }
#endif
                pDiskPerformance = (PDISK_PERFORMANCE)(
                    (PUCHAR)WmiDiskInfo +  WmiDiskInfo->DataBlockOffset);

#if DBG
                if ((PCHAR) pDiskPerformance > (PCHAR) WmiBuffer + WmiAllocSize) {
                    DebugPrint((2,
                        "BuildPhysDisk: pDiskPerformance %d exceeded %d + %d\n",
                        pDiskPerformance, WmiBuffer, WmiAllocSize));
                }
#endif
        
                dwInstanceNameOffset = WmiDiskInfo->DataBlockOffset + 
                                      ((sizeof(DISK_PERFORMANCE) + 1) & ~1) ;

#if DBG
                if ((dwInstanceNameOffset+(PCHAR)WmiDiskInfo) > (PCHAR) WmiBuffer + WmiAllocSize) {
                    DebugPrint((2,
                        "BuildPhysDisk: dwInstanceNameOffset %d exceeded %d + %d\n",
                        dwInstanceNameOffset, WmiBuffer, WmiAllocSize));
                }
#endif
                // get length of string (it's a counted string) length is in chars
                wNameLen = *(LPWORD)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset);

#if DBG
                if ((wNameLen + (PCHAR)WmiDiskInfo + dwInstanceNameOffset) >
                         (PCHAR) WmiBuffer + WmiAllocSize) {
                    DebugPrint((2,
                        "BuildPhysDisk: wNameLen %d exceeded %d + %d\n",
                        wNameLen, WmiBuffer, WmiAllocSize));
                }
#endif
                if (wNameLen > 0) {
                    // just a sanity check here
                    assert (wNameLen < MAX_PATH);
                    // get pointer to string text
                    wszInstanceName = (LPWSTR)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset + sizeof(WORD));

                    // truncate to last characters if name is larger than the buffer in the table
                    if (wNameLen >= DVE_DEV_NAME_LEN) {
                        // copy the last DVE_DEV_NAME_LEN chars
                        wszInstanceName += (wNameLen  - DVE_DEV_NAME_LEN) + 1;
                        dwBytesToCopy = (DVE_DEV_NAME_LEN - 1) * sizeof(WCHAR);
                        wNameLen = DVE_DEV_NAME_LEN - 1;
                    } else {
                        dwBytesToCopy = wNameLen;
                    }
                    // copy it to the buffer to make it a SZ string
                    memcpy (wszInstName, wszInstanceName, dwBytesToCopy);
                    // zero terminate it
                    wszInstName[wNameLen/sizeof(WCHAR)] = UNICODE_NULL;

                    DebugPrint((2, "Checking PhysDisk: '%ws'\n",
                        wszInstName));

                    if (IsPhysicalDrive(pDiskPerformance)) {
                        // enum partitions
                        dwLocalDriveId = 0;
                        dwLocalStatus = GetDriveNumberFromDevicePath (wszInstName, wNameLen, &dwLocalDriveId);
                        if (dwLocalStatus == ERROR_SUCCESS) {
                            // then take the drive ID and find all the matching partitions with logical
                            // drives
                            for (dwLocalPartition = 0; 
                                dwLocalPartition <= 0xFFFF;
                                dwLocalPartition++) {
                                dwLocalStatus = HRESULT_CODE(
                                    StringCchPrintfW(szDrivePartString, DVE_DEV_NAME_LEN,
                                            L"\\Device\\Harddisk%d\\Partition%d",
                                            dwLocalDriveId, dwLocalPartition));
                                DebugPrint((2, "BuildPhysDisk!%d: dwLocalStatus %d szDrivePartString '%ws'\n",
                                        __LINE__, dwLocalStatus, szDrivePartString));
                                if (dwLocalStatus == ERROR_SUCCESS) {
                                    dwSymbLinkLen = sizeof (szSymbLinkString) / sizeof(szSymbLinkString[0]);
                                    dwLocalStatus = GetSymbolicLink (szDrivePartString, 
                                        szSymbLinkString, &dwSymbLinkLen);
                                    DebugPrint((2, "BuildPhysDisk!%d: dwLocalStatus %d szSymbLinkString '%ws' dwSymbLinkLen %d\n",
                                            __LINE__, dwLocalStatus, szSymbLinkString, dwSymbLinkLen));

                                }
                                if (dwLocalStatus == ERROR_SUCCESS) {
                                    if (dwListEntry < *pdwNumEntries) {
                                        if (LookupInstanceName(
                                                szSymbLinkString,
                                                pList,
                                                dwListEntry,
                                                dwLocalPartition) >= 0) {
                                            dwListEntry++;
                                            continue;
                                        }
                                        DebugPrint((2,
                                            "Adding Partition: '%ws' as '%ws'\n",
                                            szDrivePartString, szSymbLinkString));
                                        pList[dwListEntry].wPartNo = (WORD)dwLocalPartition;
                                        pList[dwListEntry].wDriveNo = (WORD)dwLocalDriveId;
                                        pList[dwListEntry].wcDriveLetter = 0;
                                        pList[dwListEntry].wReserved = 0;
                                        memcpy (&pList[dwListEntry].szVolumeManager, 
                                            pDiskPerformance->StorageManagerName,
                                            sizeof(pDiskPerformance->StorageManagerName));
                                        pList[dwListEntry].dwVolumeNumber = pDiskPerformance->StorageDeviceNumber;
                                        pList[dwListEntry].hVolume = NULL;
                                        memset (&pList[dwListEntry].wszInstanceName[0],
                                            0, (DVE_DEV_NAME_LEN * sizeof(WCHAR)));
                                        if (FAILED(
                                                StringCchCopy(&pList[dwListEntry].wszInstanceName[0],
                                                    DVE_DEV_NAME_LEN, szSymbLinkString))) {
                                            //
                                            // If the source is too long, truncate
                                            //
                                            memcpy (&pList[dwListEntry].wszInstanceName[0],
                                                szSymbLinkString, DVE_DEV_NAME_LEN * sizeof(WCHAR));
                                            pList[dwListEntry].wszInstanceName[DVE_DEV_NAME_LEN-1] = 0;
                                        }
                                        DebugPrint((2, "BuildPhysDisk!%d: pList[%d].wszInstanceName '%ws'\n",
                                                __LINE__, dwListEntry, pList[dwListEntry].wszInstanceName));
                                    } else {
                                        status = ERROR_INSUFFICIENT_BUFFER;
                                    }
                                    dwListEntry++;
                                } else {
                                    // that's it for this disk
                                    break;
                                }
                            }  // end of partition search
                        } // else unable to get the harddisk number from the path
                    } else {
                        // not a physical drive so ignore
                    }
                    // count the number of entries
                    dwLocalWmiItemCount++;
                } else {
                    // no string to examine (length == 0)
                }

                // bump pointers inside WMI data block
                if (WmiDiskInfo->WnodeHeader.Linkage != 0) {
                    // continue
                    WmiDiskInfo = (PWNODE_ALL_DATA) (
                        (LPBYTE)WmiDiskInfo + WmiDiskInfo->WnodeHeader.Linkage);
                } else {
                    bNotDone = FALSE;
                }
            } // end while looking through the WMI data block
        }  // if WmiQueryAllDataW succeeded

        if (hDiskPerf == NULL) {
            // then the disk perf handle is local so close it
            status = WmiCloseBlock (hWmiDiskPerf);
        }
    } // if WmiOpenBlock succeeded

    if (WmiBuffer != NULL) {
        FREEMEM(WmiBuffer);
#if DBG
        HeapUsed -= WmiBufSize;
        DebugPrint((4, "\tFreed WmiBuffer %d to %d\n", WmiBufSize, HeapUsed));
#endif
    }

#if DBG
    DumpDiskList(pList, *pdwNumEntries);
#endif

    *pdwNumEntries = dwListEntry;
    DebugPrint((3,"BuildPhysDisk: Returning dwNumEntries=%d\n",*pdwNumEntries));

    return status;
}

DWORD
BuildVolumeList (
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries
)
/*

  Using the Mount manager, this function builds a list of all mounted 
  hard drive volumes (CD, Floppy & other types of disks are ignored).

  The calling function must pass in a buffer and indicate the maximum
  number of entries in the buffer. If successful, the buffer contains 
  one entry for each disk volume found and the number of entries used
  is returned

    pList           IN: pointer to a buffer that will receive the entries
                    OUT: buffer containing disk entries

    pdwNumEntries   IN: pointer to DWORD that specifies the max # of entries 
                        in the buffer referenced by pList
                    OUT: pointer to DWORD that contains the number of entries
                        written into the buffer referenced by pList
    pdwMaxVolume    IN: ignored
                    OUT: the max volume ID returned by the mount manager

  The function can return one of the following return values:

    ERROR_SUCCESS   if successful

    If unsuccessful:
        an error returned by 
*/
{
    DWORD       dwReturnValue = ERROR_SUCCESS;  // return value of function

    HANDLE      hMountMgr;      // handle to mount manger service
 
    // mount manager function variables
    PMOUNTMGR_MOUNT_POINTS  pMountPoints = NULL;
    MOUNTMGR_MOUNT_POINT    mountPoint;
    DWORD                   dwBufferSize = 0;
    DWORD                   dwReturnSize;
    BOOL                    bStatus;

    // processing loop functions
    LONG                    nListEntry;     // entry in caller's buffer
    DWORD                   dwBufEntry;     // entry in mount manager buffer
    PMOUNTMGR_MOUNT_POINT   point;          // the current entry 
    PWCHAR                  pDriveLetter;
    DWORD                   dwDone;

    NTSTATUS          status;
    LPWSTR            pThisChar;
    LPWSTR            szDeviceName;
    DWORD             dwBytesToCopy;
    BOOL              bNeedMoreData = TRUE;
    DWORD             dwRetryCount = 100;

    UINT              dwOrigErrorMode;


    BOOL              bIsHardDisk;
    LONG              nExistingEntry = -1;
    LONG              nOldListEntry  = -1;
    BOOL              b;
    PMOUNTMGR_VOLUME_PATHS volumePaths;
    PWCHAR            VolumeBuffer = NULL;
    DWORD             VolumeBufLen = sizeof(MOUNTMGR_VOLUME_PATHS) + (MAX_PATH * sizeof(WCHAR));
    PMOUNTMGR_TARGET_NAME targetName = NULL;
    
    // pList can be NULL for size queries
    assert (pdwNumEntries != NULL);

    DebugPrint((3, "BuildVolumeList: Building %d entries\n", *pdwNumEntries));

    hMountMgr = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);

    if (hMountMgr == INVALID_HANDLE_VALUE) {
        dwReturnValue = GetLastError();
        DebugPrint((2,
            "VolumeList: Mount Manager connection returned %d\n",
            dwReturnValue));
        goto BVL_ERROR_EXIT;
    }

    while ((bNeedMoreData) && (dwRetryCount)) {
        dwBufferSize += INITIAL_MOUNTMGR_BUFFER_SIZE;
        if (pMountPoints != NULL) {
            FREEMEM(pMountPoints);
            pMountPoints = NULL;
#if DBG
            HeapUsed -= dwBufferSize;
            DebugPrint((4,
                "\tFreed MountPoints %d to %d\n", dwBufferSize, HeapUsed));
#endif
        }
        pMountPoints = (PMOUNTMGR_MOUNT_POINTS) ALLOCMEM (dwBufferSize);
        if (pMountPoints == NULL) {
            dwReturnValue = ERROR_OUTOFMEMORY;
            DebugPrint((2, "VolumeList: Buffer Alloc failed\n"));
            goto BVL_ERROR_EXIT;
        }

#if DBG
        HeapUsed += dwBufferSize;
        DebugPrint((4,
            "\tAdded MountPoints %d to %d\n", dwBufferSize, HeapUsed));
#endif
        dwReturnSize = 0;
        memset(&mountPoint, 0, sizeof(MOUNTMGR_MOUNT_POINT));
        bStatus = DeviceIoControl(hMountMgr,
                    IOCTL_MOUNTMGR_QUERY_POINTS,
                    &mountPoint, sizeof(MOUNTMGR_MOUNT_POINT),
                    pMountPoints, dwBufferSize,
                    &dwReturnSize, NULL); 
        if (!bStatus) {
            dwReturnValue = GetLastError();
            if (dwReturnValue != ERROR_MORE_DATA) {
                DebugPrint((2,
                    "VolumeList: Mount Manager IOCTL returned %d\n",
                    dwReturnValue));
                goto BVL_ERROR_EXIT;
            } else {
                // we need a bigger buffer so try again
                dwReturnValue = ERROR_SUCCESS;
            }
            dwRetryCount--;
        } else {
            // everything worked so leave the loop
            bNeedMoreData = FALSE;
        }
    }

    targetName = (PMOUNTMGR_TARGET_NAME) ALLOCMEM(MAX_PATH*sizeof(WCHAR));
    if (targetName == NULL) {
        dwReturnValue = GetLastError();
        goto BVL_ERROR_EXIT;
    }

    if (!dwRetryCount)  {
        // then we gave up trying to get a big enough buffer so return an error
        dwReturnValue = ERROR_MORE_DATA;
    } else {
        // see if there's room in the caller's buffer for this data
        // **note that even though not all mounted drives will be returned
        // this is an easy and fast, if overstated, check
        // load size for caller to know required buffer size
        DebugPrint((2,
           "VolumeList: Mount Manager returned %d Volume entries\n",
           pMountPoints->NumberOfMountPoints));

        if (pMountPoints->NumberOfMountPoints > *pdwNumEntries) {
            *pdwNumEntries = (DWORD)pMountPoints->NumberOfMountPoints;
            if (pList != NULL) {
                // they passed in a buffer that wasn't big enough
                dwReturnValue = ERROR_INSUFFICIENT_BUFFER;
            } else {
                // they just wanted to know the size
                dwReturnValue = ERROR_SUCCESS;
            }
            goto BVL_ERROR_EXIT;
        }

        // assume there's room in the buffer now
        // load the caller's buffer
        
        dwOrigErrorMode = SetErrorMode (
            SEM_FAILCRITICALERRORS      |
            SEM_NOALIGNMENTFAULTEXCEPT  |
            SEM_NOGPFAULTERRORBOX       |
            SEM_NOOPENFILEERRORBOX);

        for (dwBufEntry=0, nListEntry = 0; 
                dwBufEntry < pMountPoints->NumberOfMountPoints; 
                dwBufEntry++) {
            point = &pMountPoints->MountPoints[dwBufEntry];
            // there are 2 steps to complete to know this is a good
            // entry for the caller. so set the count to 2 and decrement
            // it as the steps are successful.
            dwDone = 2; 
            bIsHardDisk = TRUE;
            pList[nListEntry].hVolume = NULL;
            pList[nListEntry].dwVolumeNumber = 0;
            memset(&pList[nListEntry].DeviceName, 0, sizeof(UNICODE_STRING));
            pList[nListEntry].TotalBytes = 0;
            pList[nListEntry].FreeBytes = 0;
            nExistingEntry = -1;
            nOldListEntry  = -1;
            if (point->DeviceNameLength) {
                UNALIGNED LONGLONG    *pSig;
                WCHAR wszInstanceName[DVE_DEV_NAME_LEN];

                // device name is in bytes
                pList[nListEntry].dwVolumeNumber = 0;
                szDeviceName = (LPWSTR)((PCHAR) pMountPoints + point->DeviceNameOffset);
                if ((DWORD)point->DeviceNameLength >= (DVE_DEV_NAME_LEN * sizeof(WCHAR))) {
                    // copy the last DVE_DEV_NAME_LEN chars
                    szDeviceName += ((DWORD)point->DeviceNameLength - DVE_DEV_NAME_LEN) + 1;
                    dwBytesToCopy = (DVE_DEV_NAME_LEN - 1) * sizeof(WCHAR);
                } else {
                    dwBytesToCopy = (DWORD)point->DeviceNameLength;
                }
                memcpy(wszInstanceName, szDeviceName, dwBytesToCopy);
                // null terminate
                assert ((dwBytesToCopy / sizeof(WCHAR)) < DVE_DEV_NAME_LEN);
                wszInstanceName[dwBytesToCopy / sizeof(WCHAR)] = 0;

                // Lookup an existing instance in the list and reset nListEntry accordingly.
                // Save the current value of nListEntry so that we can restore the indexing through the pList.
                if (nListEntry > 0)
                {
                    nExistingEntry = LookupInstanceName(wszInstanceName,
                        pList, nListEntry, nListEntry);

                    // Found it!
                    if (nExistingEntry != -1)
                    {
                        // If a drive letter has already been added for the volume, skip any further processing here.
                        // We've already processed this volume and we don't need to process it again.  This is done
                        // because mount manager returns the same volume twice:  once for the drive letter, once for
                        // the unique volume name.  Skip ahead but don't increment nListEntry.
                        if ((pList[nExistingEntry].wcDriveLetter >= L'A') && (pList[nExistingEntry].wcDriveLetter <= L'Z')) {
                            continue;
                        }

                        // If the drive letter field has not already been set, then close the volume handle which will
                        // be reset to a value later on in the loop.
                        nOldListEntry = nListEntry;
                        nListEntry = nExistingEntry;

                        CloseHandle(pList[nListEntry].hVolume);
                        pList[nListEntry].hVolume = NULL;
                    }
                }

                memcpy (pList[nListEntry].wszInstanceName, wszInstanceName, dwBytesToCopy + 1);

                DebugPrint((4, "MNT_PT %d: Device %d %ws\n",
                  dwBufEntry, nListEntry, pList[nListEntry].wszInstanceName));

                pSig = (UNALIGNED LONGLONG *)&(pList[nListEntry].wszInstanceName[SIZE_OF_DEVICE]);
                if ((*pSig == llFloppyName) || (*pSig == llCdRomName)) {
                    // this to avoid opening drives that we won't be collecting data from
                    bIsHardDisk = FALSE;
                }

                dwDone--;
            }

            if (point->SymbolicLinkNameLength) {
                pDriveLetter = (PWCHAR)((PCHAR)pMountPoints + point->SymbolicLinkNameOffset);
                RtlZeroMemory(targetName, MAX_PATH*sizeof(WCHAR));
                RtlCopyMemory(targetName->DeviceName, pDriveLetter, point->SymbolicLinkNameLength);
                targetName->DeviceNameLength = point->SymbolicLinkNameLength;

                // make sure this is a \DosDevices path
                DebugPrint((4, "BuildVolumeList: From Symbolic %d %ws\n", nListEntry, pDriveLetter));
                if (*(UNALIGNED LONGLONG *)pDriveLetter == llDosDevicesId) {
                    pDriveLetter += SIZE_OF_DOSDEVICES;
                    if (((*pDriveLetter >= L'A') && (*pDriveLetter <= L'Z')) ||
                        ((*pDriveLetter >= L'a') && (*pDriveLetter <= L'z'))) {
                        pList[nListEntry].wcDriveLetter = towupper(*pDriveLetter);

                        if (bIsHardDisk) {
                            status =  GetDeviceName(
                                        pMountPoints, point,
                                        &pList[nListEntry].DeviceName);
                            if (!NT_SUCCESS(status)) {
                                dwReturnValue = RtlNtStatusToDosError(status);
                            }
                        }

                        dwDone--;
                    }
                } else if (bIsHardDisk) {


                    pThisChar = &targetName->DeviceName[point->SymbolicLinkNameLength / sizeof(WCHAR)];
                    if (*pThisChar != L'\\') {
                       *pThisChar++ = L'\\';
                        targetName->DeviceNameLength += sizeof(WCHAR);
                    }
                    *pThisChar = 0;

                    DebugPrint((4, "BuildVolumeList: From HardDisk %d %ws\n", nListEntry, pThisChar));
                    if (wcsstr(targetName->DeviceName, L"DosDevices") == NULL)
                    {
                        pList[nListEntry].wcDriveLetter = L'\0';

                        status =  GetDeviceName(
                                    pMountPoints, point,
                                    &pList[nListEntry].DeviceName);
                        if (!NT_SUCCESS(status)) {
                            dwReturnValue = RtlNtStatusToDosError(status);
                        }
                        dwDone--;
                    }
                    //
                    // Will get here if there is not a drive letter
                    // so try to see if there is a mount path
                    //

#if 0
                    // Test code to use Win32 API for comparison purposes
                    targetName->DeviceName[1] = L'\\';

                    b =  GetVolumePathNamesForVolumeNameW(
                            targetName->DeviceName,
                            &pList[nListEntry].VolumePath[0],
                            MAX_PATH,
                            &VolumeBufLen);

                    DbgPrint("Trying device '%ws' len %d DeviceNameLength %d VolumeBufLen %d\n",
                        targetName->DeviceName, wcslen(targetName->DeviceName),
                        targetName->DeviceNameLength, VolumeBufLen);
#endif

                    targetName->DeviceNameLength -= sizeof(WCHAR);
                    b = FALSE;

                    while (!b) {
                        targetName->DeviceName[1] = L'?';
                        //
                        // By now, we have always a trailing slash
                        //
                        if (VolumeBuffer == NULL) {
                            VolumeBuffer = (PWCHAR) ALLOCMEM(VolumeBufLen);
                        }
                        if (VolumeBuffer == NULL) {
                            break;
                        }
                        volumePaths = (PMOUNTMGR_VOLUME_PATHS) VolumeBuffer;
                        b = DeviceIoControl(hMountMgr, IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS,
                                 targetName, MAX_PATH*sizeof(WCHAR), volumePaths,
                                 VolumeBufLen, &dwReturnSize, NULL);
                        if (b) {
                            HRESULT hr;
                            hr = StringCchCopy(&pList[nListEntry].VolumePath[0],
                                               MAX_PATH, volumePaths->MultiSz);
                            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                                pList[nListEntry].VolumePath[0] = UNICODE_NULL;
                            }
                        }
                        else if (GetLastError() != ERROR_MORE_DATA) {
                            b = TRUE;
                        }
                        else {
                            VolumeBufLen = sizeof(MOUNTMGR_VOLUME_PATHS) + volumePaths->MultiSzLength;
                            FREEMEM(VolumeBuffer);
                            VolumeBuffer = NULL;
                        }
                    }
                }
            }

            if (nOldListEntry != -1)
            {
                nListEntry = nOldListEntry;
            }

            if (dwDone == 0) {
                DebugPrint((4,
                    "Perfdisk!BuildVolumeList - Added %ws as drive %c\n",
                    pList[nListEntry].wszInstanceName,
                    pList[nListEntry].wcDriveLetter));

                // then the data fields have been satisfied so 
                // this entry is done and we can now go 
                // to the next entry in the caller's buffer
                if (nOldListEntry == -1) {
                    nListEntry++;
                }
            }
        }

        SetErrorMode (dwOrigErrorMode);

        // return the number of entries actually used here
        *pdwNumEntries = nListEntry;
    }

BVL_ERROR_EXIT:
    if (hMountMgr != INVALID_HANDLE_VALUE) {
        CloseHandle(hMountMgr);
    }

    if (pMountPoints != NULL) {
        FREEMEM (pMountPoints);
#if DBG
        DebugPrint((4,
            "\tFreed mountpoints %d to %d\n", dwBufferSize, HeapUsed));
        dwBufferSize = 0;
#endif
    }

    if (VolumeBuffer != NULL) {
        FREEMEM(VolumeBuffer);
    }
    if (targetName != NULL) {
        FREEMEM(targetName);
    }
    DebugPrint((3, "BuildVolumeList: returning with %d entries\n", *pdwNumEntries));
    return dwReturnValue;
}

DWORD
MapLoadedDisks (
    HANDLE  hDiskPerf,
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries,
    LPDWORD             pdwMaxVolNo,
    LPDWORD             pdwWmiItemCount
)
/*
    This function maps the hard disk partitions to the corresponding 
    volume and drive letter found in the list of volume entries 
    passed in by the caller.

    This function can use a handle to WMI if the caller has one, or if 
    not, it will try to open it's own.

*/
{
    DWORD   status = ERROR_SUCCESS; // return value of the function
    HANDLE  hWmiDiskPerf = NULL;    // local handle value 
    DWORD   dwLocalMaxVolNo = 0;
    DWORD   dwLocalWmiItemCount = 0;

    // WMI Buffer variables
    DWORD   WmiBufSize = 0;
    DWORD   WmiAllocSize = 0x8000;     
    LPBYTE  WmiBuffer = NULL;

    // WMI buffer processing variables
    PWNODE_ALL_DATA     WmiDiskInfo;
    DISK_PERFORMANCE    *pDiskPerformance;    //  Disk driver returns counters here
    DWORD               dwInstanceNameOffset;
    WORD                wNameLen;   // string length is first word in buffer
    LPWSTR              wszInstanceName; // pointer to string in WMI buffer
    
    WCHAR   wszInstName[DVE_DEV_NAME_LEN];
    DWORD   dwBytesToCopy;

    DWORD   dwListEntry;

    BOOL    bNotDone = TRUE;

    if (hDiskPerf == NULL) {
        // open handle to disk perf device driver
        status = WmiOpenBlock (
            (GUID *)&DiskPerfGuid,
            GENERIC_READ,
            &hWmiDiskPerf);
    } else {
        // use caller's handle
        hWmiDiskPerf = hDiskPerf;
    }

    assert (pList != NULL);
    assert (pdwNumEntries != NULL);
    assert (pdwMaxVolNo != NULL);

    DebugPrint((3, "MapLoadedDisks with %d entries %d volumes",
        *pdwNumEntries, *pdwMaxVolNo));
    if (status == ERROR_SUCCESS) {
        // allocate a buffer to send to WMI to get the diskperf data
        WmiBufSize = (dwMaxWmiBufSize > WmiAllocSize) ?
                      dwMaxWmiBufSize : WmiAllocSize;

        WmiAllocSize = WmiBufSize;
        do {

            WmiBuffer = (LPBYTE)ALLOCMEM (WmiBufSize);
            if (WmiBuffer  == NULL) {
                WmiBufSize = 0;
                status = ERROR_OUTOFMEMORY;
            } else {
#if DBG
                HeapUsed += WmiBufSize;
#endif
                WmiAllocSize = WmiBufSize;  // remember old size
                status = WmiQueryAllDataW(hWmiDiskPerf, &WmiBufSize, WmiBuffer);
                if (status == ERROR_INSUFFICIENT_BUFFER) {
                    FREEMEM(WmiBuffer);
#if DBG
                    HeapUsed -= WmiAllocSize;
#endif
                    WmiBuffer = NULL;
                }
            }
        } while ((status == ERROR_INSUFFICIENT_BUFFER) &&
                 (WmiBufSize > WmiAllocSize));

        if ((status == ERROR_SUCCESS) && (WmiBuffer != NULL)) {
            WmiDiskInfo = (PWNODE_ALL_DATA)WmiBuffer;
            if (WmiBufSize > dwMaxWmiBufSize) {
                dwMaxWmiBufSize = WmiBufSize;
            }
            // go through returned names and add to the buffer
            while (bNotDone) {
                pDiskPerformance = (PDISK_PERFORMANCE)(
                    (PUCHAR)WmiDiskInfo +  WmiDiskInfo->DataBlockOffset);
        
                dwInstanceNameOffset = WmiDiskInfo->DataBlockOffset + 
                                      ((sizeof(DISK_PERFORMANCE) + 1) & ~1) ;

                // get length of string (it's a counted string) length is in chars
                wNameLen = *(LPWORD)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset);

                if (wNameLen > 0) {
                    // just a sanity check here
                    assert (wNameLen < MAX_PATH);
                    // get pointer to string text
                    wszInstanceName = (LPWSTR)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset + sizeof(WORD));

                    // truncate to last characters if name is larger than the buffer in the table
                    if (wNameLen >= DVE_DEV_NAME_LEN) {
                        // copy the last DVE_DEV_NAME_LEN chars
                        wszInstanceName += (wNameLen  - DVE_DEV_NAME_LEN) + 1;
                        dwBytesToCopy = (DVE_DEV_NAME_LEN - 1) * sizeof(WCHAR);
                        wNameLen = DVE_DEV_NAME_LEN - 1;
                    } else {
                        dwBytesToCopy = wNameLen;
                    }
                    // copy it to the buffer to make it a SZ string
                    memcpy (wszInstName, &wszInstanceName[0], dwBytesToCopy);
                    // zero terminate it
                    wszInstName[wNameLen/sizeof(WCHAR)] = 0;

                    // find matching entry in list
                    // sent by caller and update
                    // the drive & partition info
                    for (dwListEntry = 0; 
                        dwListEntry < *pdwNumEntries;
                        dwListEntry++) {

                        DebugPrint((6,
                            "MapDrive: Comparing '%ws' to '%ws'(pList)\n",
                            wszInstName,
                            pList[dwListEntry].wszInstanceName));

                        if (lstrcmpW(wszInstName, pList[dwListEntry].wszInstanceName) == 0) {
                            // update entry and...
                            pList[dwListEntry].dwVolumeNumber = pDiskPerformance->StorageDeviceNumber;
                            memcpy (&pList[dwListEntry].szVolumeManager, 
                                pDiskPerformance->StorageManagerName,
                                sizeof(pDiskPerformance->StorageManagerName));
                            if (dwLocalMaxVolNo < pList[dwListEntry].dwVolumeNumber) {
                                dwLocalMaxVolNo = pList[dwListEntry].dwVolumeNumber;
                            }
                            DebugPrint ((2,
                                "MapDrive: Mapped %8.8s, %d to drive %c\n",
                                pList[dwListEntry].szVolumeManager,
                                pList[dwListEntry].dwVolumeNumber,
                                pList[dwListEntry].wcDriveLetter));

                            // break out of loop
                            dwListEntry = *pdwNumEntries; 
                        }
                    }
                    // count the number of entries
                    dwLocalWmiItemCount++;
                } else {
                    // no string to examine (length == 0)
                }

                // bump pointers inside WMI data block
                if (WmiDiskInfo->WnodeHeader.Linkage != 0) {
                    // continue
                    WmiDiskInfo = (PWNODE_ALL_DATA) (
                        (LPBYTE)WmiDiskInfo + WmiDiskInfo->WnodeHeader.Linkage);
                } else {
                    bNotDone = FALSE;
                }
            } // end while looking through the WMI data block
        }

        if (hDiskPerf == NULL) {
            // then the disk perf handle is local so close it
            status = WmiCloseBlock (hWmiDiskPerf);
        }

        *pdwMaxVolNo = dwLocalMaxVolNo;
        *pdwWmiItemCount = dwLocalWmiItemCount;
    }

    if (WmiBuffer != NULL) {
        FREEMEM (WmiBuffer);
#if DBG
        HeapUsed -= WmiBufSize;
        DebugPrint((4, "\tFreed WmiBuffer %d to %d\n", WmiBufSize, HeapUsed));
#endif
    }

    DebugPrint((3, "MapLoadedDisks returning status %d with %d entries %d volumes",
        status, *pdwNumEntries, *pdwMaxVolNo));
    return status;

}

DWORD
GetDriveNameString(
    LPCWSTR             szDevicePath,
    DWORD               cchDevicePathSize,
    PDRIVE_VOLUME_ENTRY pList,
    DWORD               dwNumEntries,
    LPWSTR              szNameBuffer,
    LPDWORD             pcchNameBufferSize,
    LPCWSTR             szVolumeManagerName,
    DWORD               dwVolumeNumber,
    PDRIVE_VOLUME_ENTRY *ppVolume
)
/*
    This function will try to look up a disk device referenced by 
    it's Volume Manager Name and ID and return
    either the drive letter that corresponds to this disk as found in 
    the pList buffer or the generic name \HarddiskX\PartitionY if no 
    drive letter can be found.

    szDevicePath    IN: a partition or volume name in the format of
                            \Device\HarddiskX\PartitionY  or
                            \Device\VolumeX

    cchDevicePathSize   IN: length of the device Path in chars.

    pList           IN: pointer to an initialized list of drives, 
                            volumes and partitions

    dwNumEntries    IN: the number of drive letter entries in the pList buffer

    szNameBuffer    IN: pointer to buffer to receive the name of the
                            drive letter or name that corresponds to the
                            device specified by the szDevicePath buffer
                    OUT: pointer to buffer containing the name or drive 
                            letter of disk partition

    pcchNameBufferSize  IN: pointer to DWORD containing the size of the
                            szNameBuffer in characters
                    OUT: pointer to DWORD that contains the size of the
                        string returned in szNameBuffer

  The return value of this function can be one of the following values
    ERROR_SUCCESS   the function succeded and a string was returned in 
                    the buffer referenced by szNameBuffer

    
*/
{
    DWORD   dwReturnStatus = ERROR_SUCCESS;

    WCHAR   szLocalDevicePath[DVE_DEV_NAME_LEN];
    LPWSTR  szSrcPtr;
    DWORD   dwBytesToCopy;
    DWORD   dwThisEntry;
    DWORD   dwDestSize;

    ULONG64 *pllVolMgrName;
    PDRIVE_VOLUME_ENTRY pVolume = NULL;

    // validate the input arguments
    assert (szDevicePath != NULL);
    assert (*szDevicePath != 0);
    assert (cchDevicePathSize > 0);
    assert (cchDevicePathSize <= MAX_PATH);
    assert (pList != NULL);
    assert (dwNumEntries > 0);
    assert (szNameBuffer != NULL);
    assert (pcchNameBufferSize != NULL);
    assert (*pcchNameBufferSize > 0);

    pllVolMgrName = (ULONG64 *)szVolumeManagerName;

    DebugPrint((4, "GetDriveNameString: VolMgrName %ws\n", pllVolMgrName));
    if ((pllVolMgrName[0] == LL_LOGIDISK_0) && 
        (pllVolMgrName[1] == LL_LOGIDISK_1) &&
        ((dwVolumeNumber == 0) || (dwVolumeNumber == (ULONG)-1))) {
        // no short cut exists so look up by matching
        // the szDevicePath param to the wszInstanceName field

            assert (DVE_DEV_NAME_LEN < (sizeof(szLocalDevicePath)/sizeof(szLocalDevicePath[0])));
            szSrcPtr = (LPWSTR)szDevicePath;
            dwBytesToCopy = lstrlenW (szSrcPtr); // length is really in chars
            if (dwBytesToCopy >= DVE_DEV_NAME_LEN) {
                // copy the last DVE_DEV_NAME_LEN chars
                szSrcPtr += (dwBytesToCopy - DVE_DEV_NAME_LEN) + 1;
                dwBytesToCopy = (DVE_DEV_NAME_LEN - 1) * sizeof(WCHAR);
            } else {
                dwBytesToCopy *= sizeof(WCHAR);
            }
            // now dwBytesToCopy is in bytes
            memcpy (szLocalDevicePath, szSrcPtr, dwBytesToCopy);
            // null terminate
            assert ((dwBytesToCopy / sizeof(WCHAR)) < DVE_DEV_NAME_LEN);
            szLocalDevicePath[dwBytesToCopy / sizeof(WCHAR)] = 0;

        for (dwThisEntry = 0; dwThisEntry < dwNumEntries; dwThisEntry++) {
            if (lstrcmpW(szLocalDevicePath, pList[dwThisEntry].wszInstanceName) == 0) {
                break;
            }
        }
        // continue to assign letter
    } else {
        // use the faster look up

        for (dwThisEntry = 0; dwThisEntry < dwNumEntries; dwThisEntry++) {
            if (((pList[dwThisEntry].llVolMgr[0] == pllVolMgrName[0]) &&
                 (pList[dwThisEntry].llVolMgr[1] == pllVolMgrName[1])) &&
                 (pList[dwThisEntry].dwVolumeNumber == dwVolumeNumber)) {
                break;
            }
        }
    }

    DebugPrint((4, "GetDriveNameString: Trying long route %d %d\n", dwThisEntry, dwNumEntries));
    if (dwThisEntry < dwNumEntries) {
        // then a matching entry was found so copy the drive letter
        //then this is the matching entry
        szNameBuffer[0] = UNICODE_NULL;

        if (pList[dwThisEntry].wcDriveLetter != 0) {
            DebugPrint((4,
                "GetDriveNameString: Found drive %c\n", pList[dwThisEntry].wcDriveLetter));
            if (*pcchNameBufferSize > 3) {
                szNameBuffer[0] = pList[dwThisEntry].wcDriveLetter;
                szNameBuffer[1] = L':';
                szNameBuffer[2] = 0;
                pVolume = &pList[dwThisEntry];
            } else {
                dwReturnStatus = ERROR_INSUFFICIENT_BUFFER;
            }
            *pcchNameBufferSize = 3;
        }
        else if (pList[dwThisEntry].VolumePath[0] != UNICODE_NULL) {
            HRESULT hr;
            hr = StringCchCopy(szNameBuffer, MAX_PATH, &pList[dwThisEntry].VolumePath[0]);
            if (FAILED(hr) &&  (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                szNameBuffer[0] = UNICODE_NULL;
            }
            else {
                pVolume = & pList[dwThisEntry];
            }
        }

        if (szNameBuffer[0] == UNICODE_NULL) {
            DebugPrint((4,
                "GetDriveNameString: Missing drive->%ws\n", szDevicePath));
            // then this is a valid path, but doesn't match 
            // any assigned drive letters, so remove "\device\"
            // and copy the remainder of the string
            dwDestSize = cchDevicePathSize;
            dwDestSize -= SIZE_OF_DEVICE;   // subtract front of string not copied
            if (dwDestSize < *pcchNameBufferSize) {
                memcpy (szNameBuffer, &szDevicePath[SIZE_OF_DEVICE],
                (dwDestSize * sizeof (WCHAR)));
                szNameBuffer[dwDestSize] = 0;

                pVolume = &pList[dwThisEntry];
             } else {
                 dwReturnStatus = ERROR_INSUFFICIENT_BUFFER;
             }
             *pcchNameBufferSize = dwDestSize + 1;                
        }
    } else {
        DebugPrint((4,
            "GetDriveNameString: New drive->%ws\n", szDevicePath));
        // then this is a valid path, but doesn't match 
        // any assigned drive letters, so remove "\device\"
        // and copy the remainder of the string
        dwDestSize = cchDevicePathSize;
        dwDestSize -= SIZE_OF_DEVICE;   // subtract front of string not copied
        if (dwDestSize < *pcchNameBufferSize) {
            memcpy (szNameBuffer, &szDevicePath[SIZE_OF_DEVICE],
                (dwDestSize * sizeof (WCHAR)));
            szNameBuffer[dwDestSize] = 0;
        } else {
            dwReturnStatus = ERROR_INSUFFICIENT_BUFFER;
        }
        *pcchNameBufferSize = dwDestSize + 1;
    }
    DebugPrint((4, "GetDriveNameString: NameBufSize %d Entries %d\n",
        *pcchNameBufferSize, dwNumEntries));

    if (pVolume != NULL) {
        RefreshVolume(pVolume);
        * ppVolume = pVolume;
    }
    else {
        * ppVolume = NULL;
    }
    return dwReturnStatus;
}

DWORD
MakePhysDiskInstanceNames (
    PDRIVE_VOLUME_ENTRY pPhysDiskList,
    DWORD               dwNumPhysDiskListItems,
    LPDWORD             pdwMaxDriveNo,
    PDRIVE_VOLUME_ENTRY pVolumeList,
    DWORD               dwNumVolumeListItems
)
{
    DWORD   dwPDItem;
    DWORD   dwVLItem;
    WCHAR   szLocalInstanceName[DVE_DEV_NAME_LEN];
    WCHAR   *pszNextChar;
    DWORD   dwMaxDriveNo = 0;

    // for each HD in the PhysDisk List, 
    // find matching Volumes in the Volume list

    DebugPrint((3, "MakePhysDiskInstanceNames: maxdriveno %d\n",
        *pdwMaxDriveNo));

    DebugPrint((3, "Dumping final physical disk list\n"));
#if DBG
    DumpDiskList(pPhysDiskList, dwNumPhysDiskListItems);
#endif

    for (dwPDItem = 0; dwPDItem < dwNumPhysDiskListItems; dwPDItem++) {
        if (pPhysDiskList[dwPDItem].wPartNo != 0) {
            //only do partitions that might have logical volumes first
            // initialize the instance name for this HD
            for (dwVLItem = 0; dwVLItem < dwNumVolumeListItems; dwVLItem++) {

                DebugPrint((6,
                    "Phys Disk -- Comparing '%ws' to '%ws'\n",
                pPhysDiskList[dwPDItem].wszInstanceName,
                pVolumeList[dwVLItem].wszInstanceName));

                if (lstrcmpiW(pPhysDiskList[dwPDItem].wszInstanceName, 
                    pVolumeList[dwVLItem].wszInstanceName) == 0) {

                   DebugPrint ((4,
                       "Phys Disk: Drive/Part %d/%d (%s) is Logical Drive %c\n",
                       pPhysDiskList[dwPDItem].wDriveNo, 
                       pPhysDiskList[dwPDItem].wPartNo,
                       pPhysDiskList[dwPDItem].wszInstanceName,
                       pVolumeList[dwVLItem].wcDriveLetter));

                    // then this partition matches so copy the volume information
                    pPhysDiskList[dwPDItem].wcDriveLetter = 
                        pVolumeList[dwVLItem].wcDriveLetter;
                    pPhysDiskList[dwPDItem].llVolMgr[0] =
                        pVolumeList[dwVLItem].llVolMgr[0];
                    pPhysDiskList[dwPDItem].llVolMgr[1] =
                        pVolumeList[dwVLItem].llVolMgr[1];
                    pPhysDiskList[dwPDItem].dwVolumeNumber =
                        pVolumeList[dwVLItem].dwVolumeNumber;
                    // there should only one match so bail out and go to the next item
                    break;
                }
            }
        }
    }

    // all the partitions with volumes now have drive letters so build the physical 
    // drive instance strings

    for (dwPDItem = 0; dwPDItem < dwNumPhysDiskListItems; dwPDItem++) {
        if (pPhysDiskList[dwPDItem].wPartNo == 0) {
            // only do the physical partitions
            // save the \Device\HarddiskVolume path here
            if (FAILED(StringCchCopyW(szLocalInstanceName,
                            DVE_DEV_NAME_LEN,
                            pPhysDiskList[dwPDItem].wszInstanceName))) {
                DebugPrint((2, "MakePhysDiskInstanceNames!%d: Failed '%ws'\n", __LINE__, szLocalInstanceName));
                continue;
            }
            // initialize the instance name for this HD
            memset(&pPhysDiskList[dwPDItem].wszInstanceName[0], 0, (DVE_DEV_NAME_LEN * sizeof(WCHAR)));
            _ltow ((LONG)pPhysDiskList[dwPDItem].wDriveNo, pPhysDiskList[dwPDItem].wszInstanceName, 10);
            pPhysDiskList[dwPDItem].wReserved = (WORD)(lstrlenW (pPhysDiskList[dwPDItem].wszInstanceName));
            // search the entries that are logical partitions of this drive
            for (dwVLItem = 0; dwVLItem < dwNumPhysDiskListItems; dwVLItem++) {
                if (pPhysDiskList[dwVLItem].wPartNo != 0) {

                        DebugPrint ((6, "Phys Disk: Comparing %d/%d (%s) to %d/%d\n",
                            pPhysDiskList[dwPDItem].wDriveNo,
                            pPhysDiskList[dwPDItem].wPartNo,
                            szLocalInstanceName,
                            pPhysDiskList[dwVLItem].wDriveNo,
                            pPhysDiskList[dwVLItem].wPartNo));

                    if ((pPhysDiskList[dwVLItem].wDriveNo == pPhysDiskList[dwPDItem].wDriveNo) &&
                        (pPhysDiskList[dwVLItem].wcDriveLetter >= L'A')) {  // only allow letters to be added
                        // then this logical drive is on the physical disk
                        pszNextChar = &pPhysDiskList[dwPDItem].wszInstanceName[0];
                        pszNextChar += pPhysDiskList[dwPDItem].wReserved;
                        *pszNextChar++ = L' ';
                        *pszNextChar++ = (WCHAR)(pPhysDiskList[dwVLItem].wcDriveLetter); 
                        *pszNextChar++ = L':';
                        *pszNextChar = L'\0';
                        pPhysDiskList[dwPDItem].wReserved += 3;

                        DebugPrint ((4, " -- Drive %c added.\n",
                            pPhysDiskList[dwVLItem].wcDriveLetter));

                        if ((DWORD)pPhysDiskList[dwPDItem].wDriveNo > dwMaxDriveNo) {
                            dwMaxDriveNo = (DWORD)pPhysDiskList[dwPDItem].wDriveNo;

                            DebugPrint((2,
                                "Phys Disk: Drive count now = %d\n",
                                dwMaxDriveNo));

                        }
                    }
                }
            }

            DebugPrint((2,
                "Mapped Phys Disk: '%ws'\n",
                pPhysDiskList[dwPDItem].wszInstanceName));
        } // else not a physical partition
    } //end of loop    

    // return max drive number
    *pdwMaxDriveNo = dwMaxDriveNo;

    DebugPrint((3, "MakePhysDiskInstanceNames: return maxdriveno %d\n",
        *pdwMaxDriveNo));
    return ERROR_SUCCESS;
}

DWORD
CompressPhysDiskTable (
    PDRIVE_VOLUME_ENTRY     pOrigTable,
    DWORD                   dwOrigCount,
    PDRIVE_VOLUME_ENTRY     pNewTable,
    DWORD                   dwNewCount
)
{
    DWORD   dwPDItem;
    DWORD   dwVLItem;
    DWORD   dwDriveId;

    for (dwPDItem = 0; dwPDItem < dwNewCount; dwPDItem++) {
        // for each drive entry in the new table find the matching 
        // harddisk entry in the original table
        dwDriveId = (WORD)dwPDItem;
        dwDriveId <<= 16;
        dwDriveId &= 0xFFFF0000;

        for (dwVLItem = 0; dwVLItem < dwOrigCount; dwVLItem++) {
            if (pOrigTable[dwVLItem].dwDriveId == dwDriveId) {

               DebugPrint((2,
                   "CompressPhysDiskTable:Phys Disk: phys drive %d is mapped as %s\n",
                   dwPDItem, pOrigTable[dwVLItem].wszInstanceName));

                // copy this entry
                memcpy (&pNewTable[dwPDItem], &pOrigTable[dwVLItem],
                    sizeof(DRIVE_VOLUME_ENTRY));
                break;
            }
        }
    }

    return ERROR_SUCCESS;
}


BOOL
GetPhysicalDriveNameString (
    DWORD                   dwDriveNumber,    
    PDRIVE_VOLUME_ENTRY     pList,
    DWORD                   dwNumEntries,
    LPWSTR                  szNameBuffer
)
{
    //
    // Assumes that szNameBuffer is of size MAX_PATH
    //
    LPWSTR  szNewString = NULL;

    // see if the indexed entry matches
    if (dwNumEntries > 0) {
        if ((dwDriveNumber < dwNumEntries) && (!bUseNT4InstanceNames)) {
            if ((DWORD)(pList[dwDriveNumber].wDriveNo) == dwDriveNumber) {
                // this matches so we'll get the address of the instance string
                szNewString = &pList[dwDriveNumber].wszInstanceName[0];
            } else {
                // this drive number doesn't match the one in the table
            }
        } else {
            // this is an unknown drive no or we don't want to use
            // the fancy ones
        }
    } else {
        // no entries to look up
    }
    if (szNewString != NULL) {
        if (FAILED(StringCchCopyW(szNameBuffer, MAX_PATH-1, szNewString))) {
            szNewString = NULL;
            DebugPrint((2, "GetPhysicalDriveNameString!%d: FAILED szNameBuffer '%ws'\n", __LINE__, szNameBuffer));
        }
    }
    if (szNewString == NULL) {
        // then we have to make one 
        _ltow ((LONG)dwDriveNumber, szNameBuffer, 10);
    }

    return TRUE;
}

NTSTATUS
OpenDevice(
    IN PUNICODE_STRING DeviceName,
    OUT PHANDLE Handle
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK status_block;
    
    InitializeObjectAttributes(&objectAttributes,
        DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtOpenFile(Handle,
//                 (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                 (ACCESS_MASK) FILE_GENERIC_READ,
                 &objectAttributes,
                 &status_block,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_NONALERT // | FILE_DIRECTORY_FILE
                 );

    return status;
}

NTSTATUS
GetDeviceName(
    PMOUNTMGR_MOUNT_POINTS  pMountPoints,
    IN PMOUNTMGR_MOUNT_POINT Point,
    OUT PUNICODE_STRING DeviceName
    )
{
    PWCHAR pThisChar;
    DeviceName->Length = (WORD)(Point->SymbolicLinkNameLength + (WORD)sizeof(WCHAR));
    DeviceName->MaximumLength = (WORD)(DeviceName->Length + (WORD)sizeof(WCHAR));
    DeviceName->Buffer = (PWCHAR) ALLOCMEM(DeviceName->MaximumLength);
    if (DeviceName->Buffer == NULL)
        return STATUS_NO_MEMORY;
    memcpy(DeviceName->Buffer,
           (LPVOID)((PCHAR) pMountPoints + Point->SymbolicLinkNameOffset),
           Point->SymbolicLinkNameLength);

    DebugPrint((4, "GetDeviceName: %ws\n", DeviceName->Buffer));
    pThisChar = &DeviceName->Buffer[Point->SymbolicLinkNameLength / sizeof(WCHAR)];
    *pThisChar++ = L'\\';
    *pThisChar = 0;

    return STATUS_SUCCESS;
}

VOID
RefreshVolume(
    PDRIVE_VOLUME_ENTRY pVolume
    )
{
    LONGLONG CurrentTime, Interval;
    HANDLE hVolume;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK status_block;
    FILE_FS_SIZE_INFORMATION FsSizeInformation;
    ULONG AllocationUnitBytes;
    LONG  lRefreshInterval;

    GetSystemTimeAsFileTime((LPFILETIME) &CurrentTime);
    RtlZeroMemory(&FsSizeInformation, sizeof(FsSizeInformation));
    Interval = (CurrentTime - pVolume->LastRefreshTime) / 10000000;
    lRefreshInterval = (pVolume->bOffLine) ? (g_lRefreshInterval_OffLine) : (g_lRefreshInterval_OnLine);
    if (Interval > lRefreshInterval) {
        pVolume->LastRefreshTime = CurrentTime;
        hVolume = pVolume->hVolume;
        if (hVolume == NULL) {
            NtStatus = OpenDevice(&pVolume->DeviceName, &hVolume);
            if (!NT_SUCCESS(NtStatus)) {
                hVolume = NULL;
            }
            else {
                pVolume->hVolume = hVolume;
            }
        }
        if (hVolume != NULL) {
            NtStatus = NtQueryVolumeInformationFile(hVolume,
                          &status_block,
                          &FsSizeInformation,
                          sizeof(FILE_FS_SIZE_INFORMATION),
                          FileFsSizeInformation);
        }

        if (hVolume && NT_SUCCESS(NtStatus) ) {
            AllocationUnitBytes =
                FsSizeInformation.BytesPerSector *
                FsSizeInformation.SectorsPerAllocationUnit;
            pVolume->TotalBytes =  FsSizeInformation.TotalAllocationUnits.QuadPart *
                                    AllocationUnitBytes;

            pVolume->FreeBytes = FsSizeInformation.AvailableAllocationUnits.QuadPart *
                                    AllocationUnitBytes;

            //  Express in megabytes, truncated

            pVolume->TotalBytes /= (1024 * 1024);
            pVolume->FreeBytes  /= (1024 * 1024);
            pVolume->bOffLine    = FALSE;
        }
        else {
            pVolume->TotalBytes = pVolume->FreeBytes = 0;
            pVolume->bOffLine   = TRUE;
        }
        if (lRefreshInterval > 0) {
            if (pVolume->hVolume != NULL) {
                NtClose(pVolume->hVolume);
            }
            pVolume->hVolume = NULL;
        }
    }
}

ULONG
GetDiskExtent(
    IN HANDLE hVol,
    IN OUT PVOLUME_DISK_EXTENTS *pVolExtents,
    IN OUT PULONG ReturnedSize
    )
{
    ULONG Size, nDisks = 10;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PVOLUME_DISK_EXTENTS Buffer;

    Size = *ReturnedSize;
    Buffer = *pVolExtents;

    *ReturnedSize = Size;
    Status = STATUS_BUFFER_OVERFLOW;
    while (Status == STATUS_BUFFER_OVERFLOW) {
        if (Buffer == NULL) {
            Size = sizeof(VOLUME_DISK_EXTENTS) + (nDisks * sizeof(DISK_EXTENT));
            Buffer = (PVOLUME_DISK_EXTENTS)
                     ALLOCMEM(Size);
            if (Buffer == NULL) {
                *pVolExtents = NULL;
                *ReturnedSize = 0;
                return 0;
            }
        }
        IoStatus.Status = 0;
        IoStatus.Information = 0;
        Status = NtDeviceIoControlFile(hVol,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                    NULL,
                    0,
                    (PVOID) Buffer,
                    Size);
        if (Status == STATUS_BUFFER_OVERFLOW) {
            nDisks = Buffer->NumberOfDiskExtents;
            FREEMEM(Buffer);
            Buffer = NULL;
        }
    }
    *pVolExtents = Buffer;
    *ReturnedSize = Size;

    if (!NT_SUCCESS(Status)) {
        DebugPrint((2, "GetDiskExtent: IOCTL Failure %X\n", Status));
        return 0;
    }
    return Buffer->NumberOfDiskExtents;
}

DWORD
FindNewVolumes (
    PDRIVE_VOLUME_ENTRY *ppPhysDiskList,
    LPDWORD             pdwNumPhysDiskListEntries,
    PDRIVE_VOLUME_ENTRY pVolumeList,
    DWORD               dwNumVolumeListItems
)
{
    DWORD dwVLItem;
    PVOLUME_DISK_EXTENTS      pVolExtents = NULL;
    ULONG             ReturnedSize = 0;
    PDRIVE_VOLUME_ENTRY pPhysDiskList, pDisk, pVolume;
    LIST_ENTRY NewVolumes, *pEntry;
    PDRIVE_LIST pNewDisk;
    DWORD dwNumPhysDiskListItems = *pdwNumPhysDiskListEntries;
    DWORD dwNewDisks = 0;
    UNICODE_STRING VolumeName;

    // for each HD in the PhysDisk List,
    // find matching Volumes in the Volume list

    DebugPrint((3, "FindNewVolumes: NumPhysDisk %d NumVol %d\n",
        *pdwNumPhysDiskListEntries, dwNumVolumeListItems));

    pPhysDiskList = *ppPhysDiskList;
    InitializeListHead(&NewVolumes);

    for (dwVLItem=0; dwVLItem < dwNumVolumeListItems; dwVLItem++) {
        ULONG nCount;
        HANDLE hVol;
        PWCHAR wszVolume;
        NTSTATUS status;

        pVolume = &pVolumeList[dwVLItem];
        if (LookupInstanceName(
                pVolume->wszInstanceName,
                pPhysDiskList,
                dwNumPhysDiskListItems,
                dwNumPhysDiskListItems) >= 0) {
            continue;
        }
        pEntry = NewVolumes.Flink;
        while (pEntry != &NewVolumes) {
            pDisk = &((PDRIVE_LIST)pEntry)->DiskEntry;
            if (!wcscmp(pDisk->wszInstanceName,
                        pVolume->wszInstanceName)) {
                    continue;
            }
            pEntry = pEntry->Flink;
        }
        wszVolume = &pVolume->wszInstanceName[0];
        RtlInitUnicodeString(&VolumeName, pVolume->wszInstanceName);
        nCount = VolumeName.Length / sizeof(WCHAR);
        if (nCount > 0) {
            if (wszVolume[nCount-1] == L'\\') {
                wszVolume[nCount-1] = 0;
                nCount--;
                VolumeName.Length -= sizeof(WCHAR);
            }
        }

        if (wszVolume != NULL && nCount > 0) {
            status = OpenDevice(&VolumeName, &hVol);
            DebugPrint((3, "Opening '%ws' with status %x\n", wszVolume, status));
            if (NT_SUCCESS(status) && (hVol != NULL)) {
                PDISK_EXTENT pExtent;
                nCount = GetDiskExtent(hVol, &pVolExtents, &ReturnedSize);
                DebugPrint((3, "nDisks = %d\n", nCount));
                if (nCount > 0) {
                    pExtent = &pVolExtents->Extents[0];
                    while (nCount-- > 0) {
                        if (dwNumPhysDiskListItems < INITIAL_NUM_VOL_LIST_ENTRIES) {
                            pDisk = NULL;
                            if (pPhysDiskList != NULL) {
                                pDisk = &pPhysDiskList[dwNumPhysDiskListItems];
                                dwNumPhysDiskListItems++;
                            }
                        }
                        else {
                            pNewDisk = (PDRIVE_LIST)
                                       ALLOCMEM(sizeof(DRIVE_LIST));
                            if (pNewDisk != NULL) {
                                dwNewDisks++;
                                pDisk = &pNewDisk->DiskEntry;
                                InsertTailList(&NewVolumes, &pNewDisk->Entry);
                            }
                            else {
                                pDisk = NULL;
                            }
                        }
                        if (pDisk == NULL) {
                            continue;
                        }
                        pDisk->wDriveNo = (WORD) pExtent->DiskNumber;
                        pDisk->wPartNo = 0xFF;
                        memcpy(pDisk->szVolumeManager, L"Partmgr ", sizeof(WCHAR) * 8);
                        if (FAILED(
                                StringCchCopyW(pDisk->wszInstanceName,
                                    DVE_DEV_NAME_LEN,
                                    pVolume->wszInstanceName))) {
                            DebugPrint((3, "Volume name '%ws' truncated to '%ws'\n",
                                pVolume->wszInstanceName, pDisk->wszInstanceName));
                        }
                        DebugPrint((3, "Extent %d Disk %d Start %I64u Size %I64u\n",
                            nCount, pExtent->DiskNumber,
                            pExtent->StartingOffset, pExtent->ExtentLength));
                        pExtent++;
                    }
                }
                NtClose(hVol);
            }
        }
    }
    if (pVolExtents != NULL) {
        FREEMEM(pVolExtents);
    }

    if ((!IsListEmpty(&NewVolumes)) && (dwNewDisks > 0)) {
        PDRIVE_LIST pOldDisk;

        FREEMEM(pPhysDiskList);
        pPhysDiskList = (PDRIVE_VOLUME_ENTRY) ALLOCMEM(
                        (dwNumPhysDiskListItems + dwNewDisks) * sizeof (DRIVE_VOLUME_ENTRY));
        if (pPhysDiskList == NULL) {
            DebugPrint((3, "MakePhysDiskInstance realloc failure"));
            *ppPhysDiskList = NULL;
            return ERROR_OUTOFMEMORY;
        }
        //
        // NOTE: Below assumes Entry is the first thing in DRIVE_LIST!!
        //
        pEntry = NewVolumes.Flink;
        while (pEntry != &NewVolumes) {
            pNewDisk = (PDRIVE_LIST) pEntry;
            RtlCopyMemory(
                &pPhysDiskList[dwNumPhysDiskListItems],
                &pNewDisk->DiskEntry,
                sizeof(DRIVE_VOLUME_ENTRY));
            dwNumPhysDiskListItems++;
            pOldDisk = pNewDisk;
            pEntry = pEntry->Flink;
            FREEMEM(pOldDisk);
        }
    }
    *ppPhysDiskList = pPhysDiskList;
    *pdwNumPhysDiskListEntries = dwNumPhysDiskListItems;
    return ERROR_SUCCESS;
}

#if DBG
VOID
DumpDiskList(
    IN PDRIVE_VOLUME_ENTRY pList,
    IN ULONG nCount
    )
{
    ULONG i;

    for (i=0; i<nCount; i++) {
        DebugPrint((4, "\nEntry count       = %d\n", i));
        DebugPrint((4, "dwDriveId         = %X\n", pList[i].dwDriveId));
        DebugPrint((4, "DriveLetter       = %c\n",
            pList[i].wcDriveLetter == 0 ? ' ' : pList[i].wcDriveLetter));
        DebugPrint((4, "VolMgr            = %c%c%c%c%c%c%c%c\n",
            pList[i].szVolumeManager[0],
            pList[i].szVolumeManager[1],
            pList[i].szVolumeManager[2],
            pList[i].szVolumeManager[3],
            pList[i].szVolumeManager[4],
            pList[i].szVolumeManager[5],
            pList[i].szVolumeManager[6],
            pList[i].szVolumeManager[7]));
        DebugPrint((4, "VolumeNumber      = %d\n", pList[i].dwVolumeNumber));
        DebugPrint((4, "Handle            = %X\n", pList[i].hVolume));
        DebugPrint((4, "InstanceName      = %ws\n",
            pList[i].wszInstanceName));
        DebugPrint((4, "DeviceName        = %ws\n",
            pList[i].DeviceName.Buffer ? pList[i].DeviceName.Buffer : L""));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\logidisk.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    logidisk.c

Abstract:

    This file implements a Performance Object that presents
    Logical Disk Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#pragma warning ( disable : 4201 ) 
#include <ntdddisk.h>
#include <windows.h>
#include <ole2.h>
#include <wmium.h>
#pragma warning ( default : 4201 )
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>

#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfdisk.h"
#include "diskmsg.h"
#include "datalogi.h"

DWORD APIENTRY
CollectLDiskObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the logical disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    PLDISK_DATA_DEFINITION      pLogicalDiskDataDefinition;
    DWORD  TotalLen;            //  Length of the total return block
    LDISK_COUNTER_DATA          lcdTotal;

    DWORD   dwStatus    = ERROR_SUCCESS;
    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition;

    PWNODE_ALL_DATA WmiDiskInfo;
    DISK_PERFORMANCE            *pDiskPerformance;    //  Disk driver returns counters here

    PWCHAR  wszInstanceName;
    DWORD   dwInstanceNameOffset;

    DWORD   dwNumLogicalDisks;

    WCHAR   wszTempName[MAX_PATH];
    WORD    wNameLength;
    WCHAR   wszDriveName[MAX_PATH];
    DWORD   dwDriveNameSize;

    PLDISK_COUNTER_DATA         pLCD;

    BOOL    bMoreEntries;

    DWORD   dwReturn = ERROR_SUCCESS;

    LONGLONG    llTemp;
    DWORD       dwTemp;
    PDRIVE_VOLUME_ENTRY pVolume;

    LONGLONG    TotalBytes;
    LONGLONG    FreeBytes;

    DWORD       dwCurrentWmiObjCount = 0;
    DWORD       dwRemapCount = 10;

    DOUBLE      dReadTime, dWriteTime, dTransferTime;

    //
    //  Check for sufficient space for Logical Disk object
    //  type definition
    //

    do {
        dwNumLogicalDisks = 0;
        // make sure the drive letter map is up-to-date
        if (bRemapDriveLetters) {
            dwStatus = MapDriveLetters();
            // MapDriveLetters clears the remap flag when successful
            if (dwStatus != ERROR_SUCCESS) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return dwStatus;
            }
        }

        pLogicalDiskDataDefinition = (LDISK_DATA_DEFINITION *) *lppData;

        // clear the accumulator structure

        memset (&lcdTotal, 0, sizeof(lcdTotal));
        //
        //  Define Logical Disk data block
        //

        TotalLen = sizeof (LDISK_DATA_DEFINITION);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        memmove(pLogicalDiskDataDefinition,
               &LogicalDiskDataDefinition,
               sizeof(LDISK_DATA_DEFINITION));


        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pLogicalDiskDataDefinition[1];

        WmiDiskInfo = (PWNODE_ALL_DATA)WmiBuffer;

        // make sure the structure is valid
        if (WmiDiskInfo->WnodeHeader.BufferSize < sizeof(WNODE_ALL_DATA)) {
            bMoreEntries = FALSE;
            // just to make sure someone notices on a checked build
            assert (WmiDiskInfo->WnodeHeader.BufferSize >= sizeof(WNODE_ALL_DATA));
        } else {
            // make sure there are some entries to return
            bMoreEntries =
                (WmiDiskInfo->InstanceCount > 0) ? TRUE : FALSE;
        }

        while (bMoreEntries) {
            ULONG64 StorageManagerName[2];

            pDiskPerformance = (PDISK_PERFORMANCE)(
                        (PUCHAR)WmiDiskInfo +  WmiDiskInfo->DataBlockOffset);
            dwInstanceNameOffset = (sizeof(DISK_PERFORMANCE)+1) & ~1;
            wNameLength = *(WORD *)((LPBYTE)pDiskPerformance +
                                            dwInstanceNameOffset);
            if (wNameLength > 0) {
                wszInstanceName = (LPWSTR)((LPBYTE)pDiskPerformance +
                                           dwInstanceNameOffset + sizeof(WORD));

                // copy to local buffer for processing
                if (wNameLength >= MAX_PATH)
                    wNameLength = MAX_PATH-1; // truncate if necessary
                // copy text
                memcpy (wszTempName, wszInstanceName, wNameLength);
                // then null terminate
                wNameLength /= 2;
                wszTempName[wNameLength] = 0;
                memcpy(&StorageManagerName[0],
                    &pDiskPerformance->StorageManagerName[0],
                    2*sizeof(ULONG64));

                DebugPrint((4,
                    "PERFDISK: Logical Disk Instance: %ws\n", wszTempName));
                // see if this is a Physical Drive
                if (!IsPhysicalDrive(pDiskPerformance)) {
                    // it's not so get the name of it for this instance
                    dwDriveNameSize = sizeof (wszDriveName)
                                        / sizeof(wszDriveName[0]);
                    dwStatus = GetDriveNameString (
                        wszTempName, 
                        (DWORD)wNameLength,
                        pVolumeList,
                        dwNumVolumeListEntries,
                        wszDriveName,
                        &dwDriveNameSize,
                        (LPCWSTR) &StorageManagerName[0],
                        pDiskPerformance->StorageDeviceNumber,
                        &pVolume);
                    if (dwStatus != ERROR_SUCCESS) {
                        // just so we have a name
                        if (SUCCEEDED(StringCchCopyW(&wszDriveName[0],
                                        MAX_PATH, &wszTempName[0]))) {
                            dwDriveNameSize = lstrlenW(wszDriveName);
                        }
                        else {
                            dwDriveNameSize = MAX_PATH-1;
                        }
                    }
                    if (pVolume != NULL && pVolume->bOffLine) {
                        DebugPrint((1,"\t loaded as %ws, offline\n", wszDriveName));
                    }
                    else {
                        DebugPrint((4, "\t loaded as %ws\n", wszDriveName));

                        TotalLen =
                                // space already used
                                (DWORD)((PCHAR) pPerfInstanceDefinition -
                                    (PCHAR) pLogicalDiskDataDefinition)
                                // + estimate of this instance
                                +   sizeof(PERF_INSTANCE_DEFINITION)
                                +   (dwDriveNameSize + 1) * sizeof(WCHAR) ;
                        TotalLen = QWORD_MULTIPLE (TotalLen);
                        TotalLen += sizeof(LDISK_COUNTER_DATA);
                        TotalLen = QWORD_MULTIPLE (TotalLen);

                        if ( *lpcbTotalBytes < TotalLen ) {
                            *lpcbTotalBytes = (DWORD) 0;
                            *lpNumObjectTypes = (DWORD) 0;
                            dwReturn = ERROR_MORE_DATA;
                            break;
                        }

                        MonBuildInstanceDefinition(
                                pPerfInstanceDefinition,
                                (PVOID *) &pLCD,
                                0, 0,   // no parent
                                (DWORD)-1,// no unique ID
                                &wszDriveName[0]);

                        // insure quadword alignment of the data structure
                        assert (((DWORD)(pLCD) & 0x00000007) == 0);

                        //  Set up pointer for data collection

                        // the QueueDepth counter is only a byte so clear the unused bytes
                        pDiskPerformance->QueueDepth &= 0x000000FF;

                        //
                        //  Format and collect Physical data
                        //
                        lcdTotal.DiskCurrentQueueLength += pDiskPerformance->QueueDepth;
                        pLCD->DiskCurrentQueueLength = pDiskPerformance->QueueDepth;

                        llTemp = pDiskPerformance->ReadTime.QuadPart +
                                 pDiskPerformance->WriteTime.QuadPart;

                        // these values are read in 100 NS units but are expected
                        // to be in sys perf freq (tick) units for the Sec/op ctrs 
                        // so convert them here

                        dReadTime = (DOUBLE)(pDiskPerformance->ReadTime.QuadPart);
                        dWriteTime = (DOUBLE)(pDiskPerformance->WriteTime.QuadPart);
                        dTransferTime = (DOUBLE)(llTemp);

                        dReadTime *= dSysTickTo100Ns;
                        dWriteTime *= dSysTickTo100Ns;
                        dTransferTime *= dSysTickTo100Ns;

                        pLCD->DiskTime = llTemp;
                        pLCD->DiskAvgQueueLength = llTemp;
                        lcdTotal.DiskAvgQueueLength += llTemp;
                        lcdTotal.DiskTime += llTemp;

                        pLCD->DiskReadTime = pDiskPerformance->ReadTime.QuadPart;
                        pLCD->DiskReadQueueLength = pDiskPerformance->ReadTime.QuadPart;
                        lcdTotal.DiskReadTime +=  pDiskPerformance->ReadTime.QuadPart;
                        lcdTotal.DiskReadQueueLength += pDiskPerformance->ReadTime.QuadPart;

                        pLCD->DiskWriteTime = pDiskPerformance->WriteTime.QuadPart;
                        pLCD->DiskWriteQueueLength = pDiskPerformance->WriteTime.QuadPart;

                        lcdTotal.DiskWriteTime += pDiskPerformance->WriteTime.QuadPart;
                        lcdTotal.DiskWriteQueueLength += pDiskPerformance->WriteTime.QuadPart;

                        pLCD->DiskAvgTime = (LONGLONG)dTransferTime;
                        lcdTotal.DiskAvgTime += (LONGLONG)dTransferTime;

                        dwTemp = pDiskPerformance->ReadCount +
                                 pDiskPerformance->WriteCount;

                        lcdTotal.DiskTransfersBase1 += dwTemp;
                        pLCD->DiskTransfersBase1 = dwTemp;

                        lcdTotal.DiskAvgReadTime += (LONGLONG)dReadTime;
                        pLCD->DiskAvgReadTime = (LONGLONG)dReadTime;
                        lcdTotal.DiskReadsBase1 += pDiskPerformance->ReadCount;
                        pLCD->DiskReadsBase1 = pDiskPerformance->ReadCount;

                        lcdTotal.DiskAvgWriteTime += (LONGLONG)dWriteTime;
                        pLCD->DiskAvgWriteTime = (LONGLONG)dWriteTime;
                        lcdTotal.DiskWritesBase1 += pDiskPerformance->WriteCount;
                        pLCD->DiskWritesBase1 = pDiskPerformance->WriteCount;

                        lcdTotal.DiskTransfers += dwTemp;
                        pLCD->DiskTransfers = dwTemp;

                        lcdTotal.DiskReads += pDiskPerformance->ReadCount;
                        pLCD->DiskReads = pDiskPerformance->ReadCount;
                        lcdTotal.DiskWrites += pDiskPerformance->WriteCount;
                        pLCD->DiskWrites = pDiskPerformance->WriteCount;

                        llTemp = pDiskPerformance->BytesRead.QuadPart +
                                 pDiskPerformance->BytesWritten.QuadPart;
                        lcdTotal.DiskBytes += llTemp;
                        pLCD->DiskBytes = llTemp;

                        lcdTotal.DiskReadBytes += pDiskPerformance->BytesRead.QuadPart;
                        pLCD->DiskReadBytes = pDiskPerformance->BytesRead.QuadPart;
                        lcdTotal.DiskWriteBytes += pDiskPerformance->BytesWritten.QuadPart;
                        pLCD->DiskWriteBytes = pDiskPerformance->BytesWritten.QuadPart;

                        lcdTotal.DiskAvgBytes += llTemp;
                        pLCD->DiskAvgBytes = llTemp;
                        lcdTotal.DiskTransfersBase2 += dwTemp;
                        pLCD->DiskTransfersBase2 = dwTemp;

                        lcdTotal.DiskAvgReadBytes += pDiskPerformance->BytesRead.QuadPart;
                        pLCD->DiskAvgReadBytes = pDiskPerformance->BytesRead.QuadPart;
                        lcdTotal.DiskReadsBase2 += pDiskPerformance->ReadCount;
                        pLCD->DiskReadsBase2 = pDiskPerformance->ReadCount;

                        lcdTotal.DiskAvgWriteBytes += pDiskPerformance->BytesWritten.QuadPart;
                        pLCD->DiskAvgWriteBytes = pDiskPerformance->BytesWritten.QuadPart;
                        lcdTotal.DiskWritesBase2 += pDiskPerformance->WriteCount;
                        pLCD->DiskWritesBase2 = pDiskPerformance->WriteCount;

                        pLCD->IdleTime = pDiskPerformance->IdleTime.QuadPart;
                        lcdTotal.IdleTime += pDiskPerformance->IdleTime.QuadPart;
                        pLCD->SplitCount = pDiskPerformance->SplitCount;
                        lcdTotal.SplitCount += pDiskPerformance->SplitCount;

                        pLCD->DiskTimeTimestamp = pDiskPerformance->QueryTime.QuadPart;
                        lcdTotal.DiskTimeTimestamp += pDiskPerformance->QueryTime.QuadPart;

                        if (pVolume != NULL) {
                            TotalBytes = pVolume->TotalBytes;
                            FreeBytes = pVolume->FreeBytes;

                            //  First two yield percentage of free space;
                            //  last is for raw count of free space in megabytes

                            lcdTotal.DiskFreeMbytes1 +=
                                    pLCD->DiskFreeMbytes1 = (DWORD)FreeBytes;

                            lcdTotal.DiskTotalMbytes +=
                                    pLCD->DiskTotalMbytes = (DWORD)TotalBytes;
                            lcdTotal.DiskFreeMbytes2 +=
                                    pLCD->DiskFreeMbytes2 = (DWORD)FreeBytes;
                        } else {
                            if (dwStatus != ERROR_SUCCESS) {
                                if (!bShownDiskVolumeMessage) {
                                    bShownDiskVolumeMessage = ReportEvent (hEventLog,
                                        EVENTLOG_WARNING_TYPE,
                                        0,
                                        PERFDISK_UNABLE_QUERY_VOLUME_INFO,
                                        NULL,
                                        0,
                                        sizeof(DWORD),
                                        NULL,
                                        (LPVOID)&dwStatus);
                                }
                            }
                            // Cannot get space information
                            pLCD->DiskFreeMbytes1 = 0;
                            pLCD->DiskTotalMbytes = 0;
                            pLCD->DiskFreeMbytes2 = 0;
                        }

                        // bump pointers in Perf Data Block
                        dwNumLogicalDisks ++;
                        pLCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (LDISK_COUNTER_DATA));
                        pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)&pLCD[1];
                    }
                } else {
                    // this is a physical drive entry so skip it
#if _DBG_PRINT_INSTANCES
                    OutputDebugStringW ((LPCWSTR)L" (skipped)");
#endif
                }
                // count the number of items returned
                dwCurrentWmiObjCount++;
            } else {
                // 0 length name string so skip
            }
            // bump pointers inside WMI data block
            if (WmiDiskInfo->WnodeHeader.Linkage != 0) {
                // continue
                WmiDiskInfo = (PWNODE_ALL_DATA) (
                    (LPBYTE)WmiDiskInfo + WmiDiskInfo->WnodeHeader.Linkage);
            } else {
                // this is the end of the line
                bMoreEntries = FALSE;
            }

        } // end for each volume

        // see if number of WMI objects returned is different from
        // the last time the instance table was built, if so then 
        // remap the letters and redo the instances
        if (dwCurrentWmiObjCount != dwWmiDriveCount) {
            DebugPrint((1, "CollectLDisk: Remap Current %d Drive %d\n",
                dwCurrentWmiObjCount, dwWmiDriveCount));
            bRemapDriveLetters = TRUE;
            dwRemapCount--;
        }
    } while (bRemapDriveLetters && dwRemapCount);

    if (dwNumLogicalDisks > 0) {
        // see if there's room for the TOTAL entry....

        TotalLen =
            // space already used
            (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pLogicalDiskDataDefinition)
            // + estimate of this instance
            +   sizeof(PERF_INSTANCE_DEFINITION)
            +   (lstrlenW(wszTotal) + 1) * sizeof(WCHAR) ;
        TotalLen = QWORD_MULTIPLE (TotalLen);
        TotalLen += sizeof(LDISK_COUNTER_DATA);
        TotalLen = QWORD_MULTIPLE (TotalLen);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            dwReturn = ERROR_MORE_DATA;
        } else {
            // normalize the total times
            lcdTotal.DiskTime /= dwNumLogicalDisks;
            lcdTotal.DiskReadTime /= dwNumLogicalDisks;
            lcdTotal.DiskWriteTime /= dwNumLogicalDisks;
            lcdTotal.IdleTime /= dwNumLogicalDisks;
            lcdTotal.DiskTimeTimestamp /= dwNumLogicalDisks;

            MonBuildInstanceDefinition(
                pPerfInstanceDefinition,
                (PVOID *) &pLCD,
                0,
                0,
                (DWORD)-1,
                wszTotal);

            // update the total counters

            // insure quadword alignment of the data structure
            assert (((DWORD)(pLCD) & 0x00000007) == 0);
            memcpy (pLCD, &lcdTotal, sizeof (lcdTotal));
            pLCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(LDISK_COUNTER_DATA));

            // and update the "next byte" pointer
            pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)&pLCD[1];

            // update pointer to next available buffer...
            pLogicalDiskDataDefinition->DiskObjectType.NumInstances =
                dwNumLogicalDisks + 1; // add 1 for "Total" disk
        }
    } else {
        // there are  no instances so adjust the pointer for the 
        // rest of the code 
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pLogicalDiskDataDefinition[1];
    }

    if (dwReturn == ERROR_SUCCESS) {
        *lpcbTotalBytes =
            pLogicalDiskDataDefinition->DiskObjectType.TotalByteLength =
                QWORD_MULTIPLE(
                (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pLogicalDiskDataDefinition));

#if DBG
        // sanity check on buffer size estimates
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFDISK: Logical Disk Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFDISK:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) (((LPBYTE) pLogicalDiskDataDefinition) + (* lpcbTotalBytes));

        *lpNumObjectTypes = 1;

    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\perfdisk.h ===
#ifndef _PERFDISK_H_
#define _PERFDISK_H_
#include "diskutil.h"

//
//  Definition of handle table for disks
//

//  Information for collecting disk driver statistics

extern  HANDLE  hEventLog;       // handle to event log
extern  LPWSTR  wszTotal;

extern  BOOL    bShownDiskPerfMessage;  // flag to reduce eventlog noise
extern  BOOL    bShownDiskVolumeMessage;

extern  const   WCHAR  szTotalValue[];
extern  const   WCHAR  szDefaultTotalString[];

extern  WMIHANDLE   hWmiDiskPerf;
extern  LPBYTE  WmiBuffer;

extern PDRIVE_VOLUME_ENTRY  pPhysDiskList;
extern DWORD                dwNumPhysDiskListEntries;
extern PDRIVE_VOLUME_ENTRY  pVolumeList;
extern DWORD                dwNumVolumeListEntries;
extern BOOL                 bRemapDriveLetters;
extern DWORD                dwMaxVolumeNumber;
extern DWORD                dwWmiDriveCount;

extern DOUBLE               dSysTickTo100Ns;

DWORD APIENTRY MapDriveLetters();   // function to map drive letters to volume  or device name

//  logidisk.c
PM_LOCAL_COLLECT_PROC CollectLDiskObjectData;

//  Physdisk.c
PM_LOCAL_COLLECT_PROC CollectPDiskObjectData;

#endif // _PERFDISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\perfdisk.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfdisk.c

Abstract:


Author:

    Bob Watson (a-robw) Aug 95

Revision History:

--*/

// define the WMI Guids for this program
#ifndef INITGUID
#define INITGUID 1
#endif  

//
// Force everything to be UNICODE
//
#ifndef UNICODE
#define UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>
#include <ole2.h>
#pragma warning ( disable : 4201 ) 
#include <wmium.h>
#pragma warning ( default : 4201 )
#include <wmiguid.h>
#include <winperf.h>
#if DBG
#include <stdio.h>
#include <stdlib.h>
#endif
#include <ntprfctr.h>

// Use local heap - define this before including perfutil.h
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include <assert.h>
#include "perfdisk.h"
#include "diskmsg.h"

// define this symbol to test if diskperf has installed itself
//  as an upper filter
// if this symbol is undefined, then check for diskperf before
//  returning any logical disk counters
#define _DONT_CHECK_FOR_VOLUME_FILTER

#ifndef _DONT_CHECK_FOR_VOLUME_FILTER
#include <regstr.h>     // for REGSTR_VAL_UPPERFILTERS
#endif

// bit field definitions for collect function flags

#define POS_COLLECT_PDISK_DATA      ((DWORD)0x00000001)
#define POS_COLLECT_LDISK_DATA      ((DWORD)0x00000003)
#define POS_COLLECT_IGNORE          ((DWORD)0x80000000)

#define POS_COLLECT_GLOBAL_DATA     ((DWORD)0x00000003)
#define POS_COLLECT_FOREIGN_DATA    ((DWORD)0)
#define POS_COLLECT_COSTLY_DATA     ((DWORD)0)

// global variables to this DLL

HANDLE  ThisDLLHandle = NULL;
HANDLE  hEventLog     = NULL;
HANDLE  hLibHeap      = NULL;

BOOL    bShownDiskPerfMessage = FALSE;
BOOL    bShownDiskVolumeMessage = FALSE;

LPWSTR  wszTotal = NULL;

const WCHAR cszNT4InstanceNames[] = {L"NT4 Instance Names"};
const WCHAR cszRegKeyPath[] = {L"System\\CurrentControlSet\\Services\\PerfDisk\\Performance"};

const WCHAR cszVolumeKey[] = {L"SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"};
const WCHAR cszRefreshInterval[] = {L"VolumeSpaceRefreshInterval"};

#define DISKPERF_SERVICE_NAME L"DiskPerf"
ULONG CheckVolumeFilter();

PDRIVE_VOLUME_ENTRY pPhysDiskList = NULL;
DWORD               dwNumPhysDiskListEntries = 0;
PDRIVE_VOLUME_ENTRY pVolumeList = NULL;
DWORD               dwNumVolumeListEntries = 0;
DWORD               dwWmiDriveCount = 0;
BOOL                bRemapDriveLetters = TRUE;
DWORD               dwMaxVolumeNumber = 0;

// start off with a big buffer then size according to return values
DWORD   WmiBufSize  = 0x10000;   // this can be smaller when the Diskperf.sys 
DWORD   WmiAllocSize = 0x10000;  // function is fixed to return the right status
LPBYTE  WmiBuffer   = NULL;

// variables local to this module

static POS_FUNCTION_INFO    posDataFuncInfo[] = {
    {LOGICAL_DISK_OBJECT_TITLE_INDEX,   POS_COLLECT_LDISK_DATA,     0, CollectLDiskObjectData},
    {PHYSICAL_DISK_OBJECT_TITLE_INDEX,  POS_COLLECT_PDISK_DATA,     0, CollectPDiskObjectData}
};

#define POS_NUM_FUNCS   (sizeof(posDataFuncInfo) / sizeof(posDataFuncInfo[1]))

static  bInitOk  = FALSE;
static  DWORD   dwOpenCount = 0;

WMIHANDLE   hWmiDiskPerf = NULL;

PM_OPEN_PROC    OpenDiskObject;
PM_COLLECT_PROC CollecDiskObjectData;
PM_CLOSE_PROC   CloseDiskObject;

DOUBLE      dSysTickTo100Ns;

#if DBG
const WCHAR cszDebugPrintLevel[] = {L"DebugPrintLevel"};

#define DEBUG_BUFFER_LENGTH MAX_PATH*2

ULONG_PTR HeapUsed = 0;
ULONG oldPLSize = 0;
ULONG oldVLSize = 0;
ULONG wszSize = 0;

ULONG PerfDiskDebug = 0;
UCHAR PerfDiskDebugBuffer[DEBUG_BUFFER_LENGTH];

#endif

VOID
FreeDiskList(
    IN PDRIVE_VOLUME_ENTRY pList,
    IN DWORD dwEntries
    );


BOOL
WriteNewBootTimeEntry (
    LONGLONG *pBootTime
)
{
    LONG    lStatus;
    HKEY    hKeyPerfDiskPerf;
    DWORD   dwType, dwSize;
    BOOL    bReturn = FALSE;

    // try to read the registry value of the last time
    // this error was reported 
    lStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        cszRegKeyPath,
        (DWORD)0,
        KEY_WRITE,
        &hKeyPerfDiskPerf);
    if (lStatus == ERROR_SUCCESS) {
        // read the key value
        dwType = REG_BINARY;
        dwSize = sizeof (*pBootTime);
        lStatus = RegSetValueExW (
            hKeyPerfDiskPerf,
            (LPCWSTR)L"SystemStartTimeOfLastErrorMsg",
            0L,  // reserved 
            dwType,
            (LPBYTE)pBootTime,
            dwSize);
        if (lStatus == ERROR_SUCCESS) {
            bReturn = TRUE;
        } else {
            // the value hasn't been written and 
            SetLastError (lStatus);
        } // else assume the value hasn't been written and 
          // return FALSE
        RegCloseKey (hKeyPerfDiskPerf);
    } else {
        // assume the value hasn't been written and 
        SetLastError (lStatus);
    }

    return bReturn;
}
BOOL
NT4NamesAreDefault ()
{
    LONG    lStatus;
    HKEY    hKeyPerfDiskPerf;
    DWORD   dwType, dwSize;
    DWORD   dwValue;
    BOOL    bReturn = FALSE;

    // try to read the registry value of the last time
    // this error was reported 
    lStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        cszRegKeyPath,
        (DWORD)0,
        KEY_READ,
        &hKeyPerfDiskPerf);
    if (lStatus == ERROR_SUCCESS) {
        // read the key value
        dwType = 0;
        dwSize = sizeof (dwValue);
        lStatus = RegQueryValueExW (
            hKeyPerfDiskPerf,
            cszNT4InstanceNames,
            0L,  // reserved 
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);
        if ((lStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            if (dwValue != 0) {
                bReturn = TRUE;
            } 
        } else {
            // the key is not present or not accessible so
            // leave default as is and 
            // return FALSE
        }
        RegCloseKey (hKeyPerfDiskPerf);
    } else {
        // the key could not be opened.
        SetLastError (lStatus);
    }

    return bReturn;
}

BOOL
SystemHasBeenRestartedSinceLastEntry (
    DWORD   dwReserved, // just in case we want to have multiple tests in the future
    LONGLONG *pBootTime // a buffer to receive the current boot time
)
{
    BOOL        bReturn = TRUE;
    NTSTATUS    ntStatus = ERROR_SUCCESS;
    SYSTEM_TIMEOFDAY_INFORMATION    SysTimeInfo;
    DWORD       dwReturnedBufferSize = 0;
    HKEY        hKeyPerfDiskPerf;
    LONG        lStatus;
    DWORD       dwType;
    DWORD       dwSize;
    LONGLONG    llLastErrorStartTime;

    DBG_UNREFERENCED_PARAMETER(dwReserved);

    // get the current system boot time (as a filetime)
    memset ((LPVOID)&SysTimeInfo, 0, sizeof(SysTimeInfo));

    ntStatus = NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &SysTimeInfo,
        sizeof(SysTimeInfo),
        &dwReturnedBufferSize
        );

    if (NT_SUCCESS(ntStatus)) {
        // try to read the registry value of the last time
        // this error was reported 
        lStatus = RegOpenKeyExW (
            HKEY_LOCAL_MACHINE,
            cszRegKeyPath,
            (DWORD)0,
            KEY_READ,
            &hKeyPerfDiskPerf);
        if (lStatus == ERROR_SUCCESS) {
            // read the key value
            dwType = 0;
            dwSize = sizeof (llLastErrorStartTime);
            lStatus = RegQueryValueExW (
                hKeyPerfDiskPerf,
                (LPCWSTR)L"SystemStartTimeOfLastErrorMsg",
                0L,  // reserved 
                &dwType,
                (LPBYTE)&llLastErrorStartTime,
                &dwSize);
            if (lStatus == ERROR_SUCCESS) {
                assert (dwType == REG_BINARY);  // this should be a binary type
                assert (dwSize == sizeof (LONGLONG)); // and it should be 8 bytes long
                // compare times
                // if the times are the same, then this message has already been
                // written since the last boot so we don't need to do it again.
                if (SysTimeInfo.BootTime.QuadPart ==
                    llLastErrorStartTime) {
                    bReturn = FALSE;
                } // else they are the different times so return FALSE
            } // else assume the value hasn't been written and 
              // return TRUE
            RegCloseKey (hKeyPerfDiskPerf);
        } // else assume the value hasn't been written and 
          // return TRUE

        // return the boot time if a buffer was passed in
        if (pBootTime != NULL) {
            // save the time
            *pBootTime = SysTimeInfo.BootTime.QuadPart;
        }
    } // else assume that it has been rebooted and return TRUE

    return bReturn;
}

static
BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    perform any initialization function that apply to all object
    modules
   
--*/
{
    BOOL    bReturn = TRUE;
    WCHAR   wszTempBuffer[MAX_PATH];
    LONG    lStatus;
    DWORD   dwBufferSize;
    HKEY    hKeyPerfDiskPerf;

    LARGE_INTEGER   liSysTick;

    UNREFERENCED_PARAMETER(DllHandle);

    // create heap for this library
    if (hLibHeap == NULL) {
        hLibHeap = HeapCreate (0, 1, 0);
    }
    assert (hLibHeap != NULL);

    if (hLibHeap == NULL) {
        return FALSE;
    }
    // open handle to the event log
    if (hEventLog == NULL) hEventLog = MonOpenEventLog((LPWSTR)L"PerfDisk");
    assert (hEventLog != NULL);

    wszTempBuffer[0] = UNICODE_NULL;
    wszTempBuffer[MAX_PATH-1] = UNICODE_NULL;

    lStatus = GetPerflibKeyValue (
        szTotalValue,
        REG_SZ,
        sizeof(wszTempBuffer) - sizeof(WCHAR),
        (LPVOID)&wszTempBuffer[0],
        DEFAULT_TOTAL_STRING_LEN,
        (LPVOID)&szDefaultTotalString[0]);

    if (lStatus == ERROR_SUCCESS) {
        // then a string was returned in the temp buffer
        dwBufferSize = lstrlenW (wszTempBuffer) + 1;
        dwBufferSize *= sizeof (WCHAR);
        wszTotal = ALLOCMEM (dwBufferSize);
        if (wszTotal == NULL) {
            // unable to allocate buffer so use static buffer
            wszTotal = (LPWSTR)&szDefaultTotalString[0];
        } else {
            memcpy (wszTotal, wszTempBuffer, dwBufferSize);
#if DBG
            HeapUsed += dwBufferSize;
            wszSize = dwBufferSize;
            DebugPrint((4,
                "DllAttach: wszTotal add %d to %d\n",
                dwBufferSize, HeapUsed));
#endif
        }
    } else {
        // unable to get string from registry so just use static buffer
        wszTotal = (LPWSTR)&szDefaultTotalString[0];
    }

    QueryPerformanceFrequency (&liSysTick);
    dSysTickTo100Ns = (DOUBLE)liSysTick.QuadPart;
    dSysTickTo100Ns /= 10000000.0;

    lStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        cszRegKeyPath,
        (DWORD)0,
        KEY_READ,
        &hKeyPerfDiskPerf);
    if (lStatus == ERROR_SUCCESS) {
        DWORD dwType = REG_DWORD;
        DWORD dwSize = sizeof(DWORD);
        ULONG interval;
        lStatus = RegQueryValueExW (
                    hKeyPerfDiskPerf,
                    cszRefreshInterval,
                    0L,  // reserved
                    &dwType,
                    (LPBYTE)&interval,
                    &dwSize);
        if ((lStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            g_lRefreshInterval_OnLine = interval;
        }
#if DBG
        dwSize = sizeof(DWORD);
        dwType = REG_DWORD;
        lStatus = RegQueryValueExW (
                    hKeyPerfDiskPerf,
                    cszDebugPrintLevel,
                    0L,
                    &dwType,
                    (LPBYTE) &interval,
                    &dwSize);
        if ((lStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            PerfDiskDebug = interval;
        }
#endif
        RegCloseKey (hKeyPerfDiskPerf);
    }

    return bReturn;
}

static
BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    UNREFERENCED_PARAMETER(DllHandle);

    if (dwOpenCount > 0) {
        // then close the object now, since the DLL's being discarded
        // prematurely, this is our last chance.
        // this is to insure the object is closed.
        dwOpenCount = 1;
        CloseDiskObject();
    }

    if ((wszTotal != NULL) && (wszTotal != &szDefaultTotalString[0])) {
        FREEMEM (wszTotal);
#if DBG
        HeapUsed -= wszSize;
        DebugPrint((4,
            "DllDetach: wsz freed %d to %d\n",
            wszSize, HeapUsed));
        wszSize = 0;
#endif
        wszTotal = NULL;
    }

    if (HeapDestroy (hLibHeap)) {
        hLibHeap = NULL;
        pVolumeList = NULL;
        pPhysDiskList = NULL;
        dwNumVolumeListEntries = 0;
        dwNumPhysDiskListEntries = 0;
    }

    if (hEventLog != NULL) {
        MonCloseEventLog ();
    }
    return TRUE;
}

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    ReservedAndUnused;

    // this will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach (DLLHandle);

        case DLL_PROCESS_DETACH:
            return DllProcessDetach (DLLHandle);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            return TRUE;
    }
}

DWORD APIENTRY
MapDriveLetters()
{
    DWORD   status = ERROR_SUCCESS;
    DWORD   dwLoopCount;   
    PDRIVE_VOLUME_ENTRY pTempPtr;
    DWORD   dwDriveCount;
    DWORD   dwOldEntries;
#if DBG
    LONG64 startTime, endTime;
    LONG elapsed;
#endif

    if (pPhysDiskList != NULL) {
        FreeDiskList(pPhysDiskList, dwNumPhysDiskListEntries);
#if DBG
        HeapUsed -= oldPLSize;
        DebugPrint((4,"MapDriveLetters: PL Freed %d to %d\n",
            oldPLSize, HeapUsed));
        oldPLSize = 0;
#endif
        pPhysDiskList = NULL;
    }
#ifdef DBG
    GetSystemTimeAsFileTime((LPFILETIME) &startTime);
    DebugPrint((1, "BEGIN MapDriveLetters:\n",
                   status));
#endif
    dwNumPhysDiskListEntries = INITIAL_NUM_VOL_LIST_ENTRIES;

    // Initially allocate enough entries for drives A through Z
    pPhysDiskList = (PDRIVE_VOLUME_ENTRY)ALLOCMEM (
        (dwNumPhysDiskListEntries * sizeof (DRIVE_VOLUME_ENTRY)));

#if DBG
    if (pPhysDiskList == NULL) {
        DebugPrint((2,
            "MapDriveLetters: pPhysDiskList alloc failure\n"));
    }
#endif

    if (pPhysDiskList != NULL) {
        // try until we get a big enough buffer
#if DBG
        ULONG oldsize = dwNumPhysDiskListEntries * sizeof(DRIVE_VOLUME_ENTRY);
        HeapUsed += oldsize;
        oldPLSize = oldsize;
        DebugPrint((4, "MapDriveLetter: Alloc %d to %d\n",
            oldsize, HeapUsed));
#endif
        dwLoopCount = 10;   // no more than 10 retries to get the right size
        dwOldEntries = dwNumPhysDiskListEntries;
        while ((status = BuildPhysDiskList (
                hWmiDiskPerf,
                pPhysDiskList,
                &dwNumPhysDiskListEntries)) == ERROR_INSUFFICIENT_BUFFER) {

            DebugPrint ((3,
                "MapDriveLetters: BuildPhysDiskList returns: %d, requesting %d entries\n",
                status, dwNumPhysDiskListEntries));
#if DBG
            if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
                DebugPrint((2,
                    "\tERROR! pPhysDiskList %X corrupted BuildPhysDiskList\n",
                    pPhysDiskList));
                DbgBreakPoint();
            }
#endif

            // if ERROR_INSUFFICIENT_BUFFER, then 
            // dwNumPhysDiskListEntries should contain the required size
            FreeDiskList(pPhysDiskList, dwOldEntries);
            if (dwNumPhysDiskListEntries == 0) {
                pPhysDiskList = NULL;
            }
            else {
                pPhysDiskList = (PDRIVE_VOLUME_ENTRY)ALLOCMEM (
                    (dwNumPhysDiskListEntries * sizeof (DRIVE_VOLUME_ENTRY)));
            }

            if (pPhysDiskList == NULL) {
                // bail if the allocation failed
                DebugPrint((2,
                    "MapDriveLetters: pPhysDiskList realloc failure\n"));
                status = ERROR_OUTOFMEMORY;
                break;
            }
#if DBG
            else {
                HeapUsed -= oldsize; // subtract the old size and add new size
                oldPLSize = dwNumPhysDiskListEntries*sizeof(DRIVE_VOLUME_ENTRY);
                HeapUsed += oldPLSize;
                DebugPrint((4,
                    "MapDriveLetter: Realloc old %d new %d to %d\n",
                    oldsize, oldPLSize, HeapUsed));
            }
#endif
            dwLoopCount--;
            if (!dwLoopCount) {
                status = ERROR_OUTOFMEMORY;
                break;
            }
            DebugPrint ((3,
                "MapDriveLetters: %d retrying BuildPhysDiskList with %d entries\n",
                status, dwNumPhysDiskListEntries));
        }
    }

    else {      // do not bother going any further if no memory
        return ERROR_OUTOFMEMORY;
    }

    DebugPrint ((4,
        "MapDriveLetters: BuildPhysDiskList returns: %d\n", status));
#if DBG
    if (pPhysDiskList != NULL) {
        if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
            DebugPrint((2, "\tERROR! pPhysDiskList %X corrupted after Builds\n",
                pPhysDiskList));
            DbgBreakPoint();
        }
    }
#endif

    if (pVolumeList != NULL) {
#if DBG
        HeapUsed -= oldVLSize;
        DebugPrint((4,"MapDriveLetters: VL Freed %d to %d\n",
            oldVLSize, HeapUsed));
        oldVLSize = 0;
        if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
            DebugPrint((2, "\tERROR! pVolumeList %X is corrupted before free\n",
                pVolumeList));
            DbgBreakPoint();
        }
#endif
        FreeDiskList(pVolumeList, dwNumVolumeListEntries);
        // close any open handles
    }
    dwNumVolumeListEntries = INITIAL_NUM_VOL_LIST_ENTRIES;

    // Initially allocate enough entries for letters C through Z
    pVolumeList = (PDRIVE_VOLUME_ENTRY)ALLOCMEM (
        (dwNumVolumeListEntries * sizeof (DRIVE_VOLUME_ENTRY)));

#if DBG
    if (pVolumeList == NULL) {
        DebugPrint((2,
            "MapDriveLetters: pPhysVolumeList alloc failure\n"));
    }
#endif

    if (pVolumeList != NULL) {
        // try until we get a big enough buffer
#if DBG
        ULONG oldsize = dwNumVolumeListEntries * sizeof (DRIVE_VOLUME_ENTRY);
        HeapUsed += oldsize;
        oldVLSize = oldsize;
        DebugPrint((4,
            "MapDriveLetter: Add %d HeapUsed %d\n", oldsize, HeapUsed));
#endif
        dwLoopCount = 10;   // no more than 10 retries to get the right size
        dwOldEntries = dwNumVolumeListEntries;
        while ((status = BuildVolumeList (
                pVolumeList,
                &dwNumVolumeListEntries)) == ERROR_INSUFFICIENT_BUFFER) {
            // if ERROR_INSUFFICIENT_BUFFER, then 

            DebugPrint ((3,
                "MapDriveLetters: BuildVolumeList returns: %d, requesting %d entries\n",
                status, dwNumVolumeListEntries));

#if DBG
            if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
                DebugPrint((2, "\tERROR! pVolumeList %X corrupted in while\n",
                    pVolumeList));
                DbgBreakPoint();
            }
#endif
            // dwNumVolumeListEntries should contain the required size
            FreeDiskList(pVolumeList, dwOldEntries);

            if (dwNumVolumeListEntries == 0) {
                pVolumeList = NULL;
            }
            else {
                pVolumeList = (PDRIVE_VOLUME_ENTRY)ALLOCMEM (
                    (dwNumVolumeListEntries * sizeof (DRIVE_VOLUME_ENTRY)));
            }

            if (pVolumeList == NULL) {
                // bail if the allocation failed
                DebugPrint((2,
                    "MapDriveLetters: pPhysVolumeList realloc failure\n"));
                status = ERROR_OUTOFMEMORY;
                break;
            }
#if DBG
            else {
                if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
                    DebugPrint((2, "\tpVolumeList %X corrupted - realloc\n",
                        pVolumeList));
                    DbgBreakPoint();
                }
                HeapUsed -= oldsize; // subtract the old size and add new size
                oldVLSize = dwNumVolumeListEntries*sizeof(DRIVE_VOLUME_ENTRY);
                HeapUsed += oldVLSize;
                DebugPrint((4,
                    "MapDriveLetter: Realloc old %d new %d to %d\n",
                    oldsize, oldVLSize, HeapUsed));
            }
#endif
            dwLoopCount--;
            if (!dwLoopCount) {
                status = ERROR_OUTOFMEMORY;
                break;
            }
            dwOldEntries = dwNumVolumeListEntries;
            DebugPrint ((3,
                "MapDriveLetters: retrying BuildVolumeList with %d entries\n",
                status, dwNumVolumeListEntries));
        }

        DebugPrint ((4, "MapDriveLetters: BuildVolumeList returns %d\n", status));

#if DBG
        if (pVolumeList != NULL) {
            if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
                DebugPrint((2, "\tpVolumeList %X corrupted after build\n",
                    pVolumeList));
                DbgBreakPoint();
            }
        }
#endif

        if (status == ERROR_SUCCESS) {
            status = FindNewVolumes(
                        &pPhysDiskList,
                        &dwNumPhysDiskListEntries,
                        pVolumeList,
                        dwNumVolumeListEntries);
        }

        // now map the disks to their drive letters 
        if (status == ERROR_SUCCESS) {
            status = MapLoadedDisks (
                hWmiDiskPerf,
                pVolumeList,
                &dwNumVolumeListEntries,
                &dwMaxVolumeNumber,
                &dwWmiDriveCount
                );

            DebugPrint ((4,
                "MapDriveLetters: MapLoadedDisks returns status %d %d MaxVol %d WmiDrive\n",
                status, dwNumVolumeListEntries,
                dwMaxVolumeNumber, dwWmiDriveCount));
        }
        
#if DBG
        if (pVolumeList != NULL) {
            if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
                DebugPrint((2, "\tpVolumeList %X corrupted by MapLoadedDisks\n",
                    pVolumeList));
                DbgBreakPoint();
            }
        }
#endif

        if (status == ERROR_SUCCESS) {
            // now assign drive letters to the phys disk list
            dwDriveCount = 0;
            status = MakePhysDiskInstanceNames (
                    pPhysDiskList,
                    dwNumPhysDiskListEntries,
                    &dwDriveCount,
                    pVolumeList,
                    dwNumVolumeListEntries);
        
#if DBG
        if (pPhysDiskList != NULL) {
            if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
                DebugPrint((2, "\tpPhysList %X corrupted by MakePhysDiskInst\n",
                    pPhysDiskList));
                DbgBreakPoint();
            }
        }
#endif
            if (status == ERROR_SUCCESS) {
                // then compress this into an indexed table
                // save original pointer
                pTempPtr = pPhysDiskList;

                // the function returns the last Drive ID
                // so we need to add 1 here to the count to include
                // the "0" drive
                dwDriveCount += 1;

                DebugPrint ((4, "\tDrive count now = %d\n",
                    dwDriveCount));

                // and allocate just enough for the actual physical drives
                pPhysDiskList = (PDRIVE_VOLUME_ENTRY)ALLOCMEM (
                    (dwDriveCount * sizeof (DRIVE_VOLUME_ENTRY)));

                if (pPhysDiskList != NULL) {
                    status = CompressPhysDiskTable (
                        pTempPtr,
                        dwNumPhysDiskListEntries,
                        pPhysDiskList,
                        dwDriveCount);
        
#if DBG
        if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
            DebugPrint((2, "\tpPhysList %X corrupted by CompressPhys\n",
                pPhysDiskList));
            DbgBreakPoint();
        }
#endif
                    if (status == ERROR_SUCCESS) {
                        dwNumPhysDiskListEntries = dwDriveCount;
                    }
                    else {  // free if cannot compress
                        FreeDiskList(pPhysDiskList, dwNumPhysDiskListEntries);
#if DBG
                        HeapUsed -= dwDriveCount * sizeof(DRIVE_VOLUME_ENTRY);
                        DebugPrint((4,
                            "MapDriveLetters: Compress freed %d to %d\n",
                            dwDriveCount*sizeof(DRIVE_VOLUME_ENTRY), HeapUsed));
#endif
                        pPhysDiskList = NULL;
                    }
                } else {
                    DebugPrint((2,"MapDriveLetters: pPhysDiskList alloc fail for compress\n"));
                    status = ERROR_OUTOFMEMORY;
                }
                if (pTempPtr) {     // Free the previous list
                    FREEMEM(pTempPtr);
#if DBG
                    HeapUsed -= oldPLSize;
                    DebugPrint((4,
                        "MapDriveLetters: tempPtr freed %d to %d\n",
                        oldPLSize, HeapUsed));
                    oldPLSize = 0;
#endif
                }
#if DBG
                if (status == ERROR_SUCCESS) {
                    oldPLSize = dwDriveCount * sizeof(DRIVE_VOLUME_ENTRY);
                    HeapUsed += oldPLSize;
                    DebugPrint((4,
                        "MapDriveLetters: Compress add %d to %d\n",
                        oldPLSize, HeapUsed));
                }
#endif
            }
        }
        if (status == ERROR_SUCCESS) {
            // clear the remap flag
            bRemapDriveLetters = FALSE;
        }
    } else {
        status = ERROR_OUTOFMEMORY;
    }
#if DBG
    GetSystemTimeAsFileTime((LPFILETIME) &endTime);
    elapsed = (LONG) ((endTime - startTime) / 10000);
    DebugPrint((1, "END MapDriveLetters: %d msec\n\n", elapsed));
#endif

    // TODO: Need to keep track of different status for PhysDisk & Volumes
    //       If Physdisk succeeds whereas Volume fails, need to log event
    //       and try and continue with Physdisk counters
    // TODO Post W2K: Free stuff if status != ERROR_SUCCESS
    if (status != ERROR_SUCCESS) {
        if (pPhysDiskList != NULL) {
            FreeDiskList(pPhysDiskList, dwNumPhysDiskListEntries);
            pPhysDiskList = NULL;
            DebugPrint((3, "MapDriveLetters: Freeing pPhysDiskList due to status %d\n", status));

        }
        if (pVolumeList != NULL) {
            FreeDiskList(pVolumeList, dwNumVolumeListEntries);
            pVolumeList = NULL;
            DebugPrint((3, "MapDriveLetters: Freeing pVolumeList due to status %d\n", status));
        }
    }
    return status;
}

DWORD APIENTRY
OpenDiskObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    LONGLONG    llLastBootTime;
    BOOL        bWriteMessage;
#if DBG
    LONG64 startTime, endTime;
    LONG elapsed;
#endif

    UNREFERENCED_PARAMETER (lpDeviceNames);

#ifdef DBG
    GetSystemTimeAsFileTime((LPFILETIME) &startTime);
    DebugPrint((1, "BEGIN OpenDiskObject:\n",
                   status));
#endif

    if (dwOpenCount == 0) {
        status = WmiOpenBlock (
            (GUID *)&DiskPerfGuid,
            GENERIC_READ,
            &hWmiDiskPerf);

#if DBG
        GetSystemTimeAsFileTime((LPFILETIME) &endTime);
        elapsed = (LONG) ((endTime - startTime) / 10000);
        DebugPrint((3, "WmiOpenBlock returns: %d in %d msec after BEGIN\n",
                   status, elapsed));
#endif

        if (status == ERROR_SUCCESS) {
            // build drive map
            status = MapDriveLetters();

            DebugPrint((3,
                "OpenDiskObject: MapDriveLetters returns: %d\n", status));
        }
        // determine instance name format
        bUseNT4InstanceNames = NT4NamesAreDefault();
#if DBG
        GetSystemTimeAsFileTime((LPFILETIME) &endTime);
        elapsed = (LONG) ((endTime - startTime) / 10000);
        DebugPrint((3,
            "OpenDiskObject: NT4Names - %d msec after BEGIN\n", status));
#endif

        if (status == ERROR_SUCCESS) {
            bInitOk = TRUE;
        }
    }

    if (status != ERROR_SUCCESS) {
        // check to see if this is a WMI error and if so only 
        // write the error once per boot cycle

        if (status == ERROR_WMI_GUID_NOT_FOUND) {
            bWriteMessage = SystemHasBeenRestartedSinceLastEntry (
                0, &llLastBootTime);
    
            if (bWriteMessage) {
                // update registry time
                WriteNewBootTimeEntry (&llLastBootTime);
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    PERFDISK_UNABLE_QUERY_DISKPERF_INFO,
                    NULL,
                    0,
                    sizeof(DWORD),
                    NULL,
                    (LPVOID)&status);
            } // else it's already been written
        } else {
            // always write other messages
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFDISK_UNABLE_OPEN,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }
#if DBG
        if (pPhysDiskList) {
            DebugPrint((4, "\t Validating pPhysDiskList %X at end Open\n",
                pPhysDiskList));
            if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
                DebugPrint((2, "OpenDiskObject: PhysDiskList heap corrupt!\n"));
                DbgBreakPoint();
            }
        }
        if (pVolumeList) {
            DebugPrint((4, "\t Validating pVolumeList %X at end Open\n",
                pVolumeList));
            if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
                DebugPrint((2, "OpenDiskObject: VolumeList heap corrupt!\n"));
                DbgBreakPoint();
            }
        }
        if (WmiBuffer) {
            DebugPrint((4, "\t Validating WmiBuffer %X at end Open\n",
                WmiBuffer));
            if (!HeapValidate(hLibHeap, 0, WmiBuffer)) {
                DebugPrint((2, "OpenDiskObject: WmiBuffer heap corrupt!\n"));
                DbgBreakPoint();
            }
        }
#endif
    } else {
        dwOpenCount++;
#ifndef _DONT_CHECK_FOR_VOLUME_FILTER
        if (!CheckVolumeFilter()) {
            posDataFuncInfo[0].dwCollectFunctionBit |= POS_COLLECT_IGNORE;
        }
#endif
    }
#if DBG
    GetSystemTimeAsFileTime((LPFILETIME) &endTime);
    elapsed = (LONG) ((endTime - startTime) / 10000);
    DebugPrint((1, "END OpenDiskObject: %d msec\n\n", elapsed));
#endif

    return  status;
}

DWORD APIENTRY
CollectDiskObjectData (
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN       LPWSTR   lpValueName
            pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    NTSTATUS    Status;

    // build bit mask of functions to call

    DWORD       dwQueryType;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;

    DWORD       dwNumObjectsFromFunction;
    DWORD       dwOrigBuffSize;
    DWORD       dwByteSize;
#if DBG
    LONG64 startTime, endTime;
    LONG elapsed;

    GetSystemTimeAsFileTime((LPFILETIME) &startTime);
    DebugPrint((1, "BEGIN CollectDiskObject:\n"));
#endif

    if (!bInitOk) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        bShownDiskPerfMessage = TRUE;
        goto COLLECT_BAIL_OUT;
    }

    dwQueryType = GetQueryType (lpValueName);

    switch (dwQueryType) {
        case QUERY_ITEMS:
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (IsNumberInUnicodeList (
                    posDataFuncInfo[FunctionIndex].dwObjectId, lpValueName)) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                }
            }
            break;

        case QUERY_GLOBAL:
            FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
            break;

        case QUERY_FOREIGN:
            FunctionCallMask = POS_COLLECT_FOREIGN_DATA;
            break;

        case QUERY_COSTLY:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;

        default:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;
    }

    // collect data 

	// if either bit is set, collect data
	if (FunctionCallMask & POS_COLLECT_GLOBAL_DATA) {
		// read the data from the diskperf driver
		// only one call at a time is permitted. This should be 
		// throttled by the perflib, but just in case we'll test it

		assert (WmiBuffer == NULL);

		if (WmiBuffer != NULL) {
			ReportEvent (hEventLog,
				EVENTLOG_ERROR_TYPE,
				0,
				PERFDISK_BUSY,
				NULL,
				0,
				0,
				NULL,
				NULL);
			*lpcbTotalBytes = (DWORD) 0;
			*lpNumObjectTypes = (DWORD) 0;
			lReturn = ERROR_SUCCESS;
			goto COLLECT_BAIL_OUT;
		} else {
			WmiBuffer = ALLOCMEM (WmiAllocSize);
#if DBG
            if (WmiBuffer != NULL) {
                HeapUsed += WmiAllocSize;
                DebugPrint((4,
                    "CollecDiskObjectData: WmiBuffer added %d to %d\n",
                    WmiAllocSize, HeapUsed));
            }
#endif
		}

		// the buffer pointer should NOT be null if here

		if ( WmiBuffer == NULL ) {
			ReportEvent (hEventLog,
				EVENTLOG_WARNING_TYPE,
				0,
				PERFDISK_UNABLE_ALLOC_BUFFER,
				NULL,
				0,
				0,
				NULL,
				NULL);

			*lpcbTotalBytes = (DWORD) 0;
			*lpNumObjectTypes = (DWORD) 0;
			lReturn = ERROR_SUCCESS;
			goto COLLECT_BAIL_OUT;
		}

		WmiBufSize = WmiAllocSize;
		Status = WmiQueryAllDataW (
			hWmiDiskPerf,
			&WmiBufSize,
			WmiBuffer);

		// if buffer size attempted is too big or too small, resize
		if ((WmiBufSize > 0) && (WmiBufSize != WmiAllocSize)) {
            LPBYTE WmiTmpBuffer = WmiBuffer;
			WmiBuffer           = REALLOCMEM(WmiTmpBuffer, WmiBufSize);

			if (WmiBuffer == NULL) {
				// reallocation failed so bail out
                FREEMEM(WmiTmpBuffer);
				Status = ERROR_OUTOFMEMORY;
			} else {
				// if the required buffer is larger than 
				// originally planned, bump it up some
#if DBG
                HeapUsed += (WmiBufSize - WmiAllocSize);
                DebugPrint((4,
                    "CollectDiskObjectData: Realloc old %d new %d to %d\n",
                    WmiAllocSize, WmiBufSize, HeapUsed));
#endif
				if (WmiBufSize > WmiAllocSize) {                    
					WmiAllocSize = WmiBufSize;
				}
			}
		}

		if (Status == ERROR_INSUFFICIENT_BUFFER) {
			// if it didn't work because it was too small the first time
			// try one more time
			Status = WmiQueryAllDataW (
				hWmiDiskPerf,
				&WmiBufSize,
				WmiBuffer);
            
		} else {
			// it either worked the fisrt time or it failed because of 
			// something other than a buffer size problem
		}

        DebugPrint((3,
            "WmiQueryAllData status return: %x Buffer %d bytes\n",
            Status, WmiBufSize));

    } else {
        // no data required so these counter objects must not be in 
        // the query list
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto COLLECT_BAIL_OUT;
    }

    if (Status == ERROR_SUCCESS) {
        *lpNumObjectTypes = 0;
        dwOrigBuffSize = dwByteSize = *lpcbTotalBytes;
        *lpcbTotalBytes = 0;

        for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
            if (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit &
                POS_COLLECT_IGNORE)
                continue;

            if (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit &
                FunctionCallMask) {
                dwNumObjectsFromFunction = 0;
                lReturn = (*posDataFuncInfo[FunctionIndex].pCollectFunction) (
                    lppData,
                    &dwByteSize,
                    &dwNumObjectsFromFunction);

                if (lReturn == ERROR_SUCCESS) {
                    *lpNumObjectTypes += dwNumObjectsFromFunction;
                    *lpcbTotalBytes += dwByteSize;
                    dwOrigBuffSize -= dwByteSize;
                    dwByteSize = dwOrigBuffSize;
                } else {
                    break;
                }
            }
#if DBG
            dwQueryType = HeapValidate(hLibHeap, 0, WmiBuffer);
            DebugPrint((4,
                "CollectDiskObjectData: Index %d HeapValid %d lReturn %d\n",
                FunctionIndex, dwQueryType, lReturn));
            if (!dwQueryType)
                DbgBreakPoint();
#endif
        }
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFDISK_UNABLE_QUERY_DISKPERF_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&Status);

        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
    }

    // *lppData is updated by each function
    // *lpcbTotalBytes is updated after each successful function
    // *lpNumObjects is updated after each successful function

COLLECT_BAIL_OUT:
    if (WmiBuffer != NULL) {
        FREEMEM (WmiBuffer);
#if DBG
        HeapUsed -= WmiBufSize;
        DebugPrint((4, "CollectDiskObjectData: Freed %d to %d\n",
            WmiBufSize, HeapUsed));
#endif
        WmiBuffer = NULL;
    }
    
#if DBG
    GetSystemTimeAsFileTime((LPFILETIME) &endTime);
    elapsed = (LONG) ((endTime - startTime) / 10000);
    DebugPrint((1, "END CollectDiskObject: %d msec\n\n", elapsed));
#endif
    return lReturn;
}

DWORD APIENTRY
CloseDiskObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD   status = ERROR_SUCCESS;
//    DWORD   dwThisEntry;
#if DBG
    LONG64 startTime, endTime;
    LONG elapsed;

    GetSystemTimeAsFileTime((LPFILETIME) &startTime);
    DebugPrint((1, "BEGIN CloseDiskObject:\n"));
#endif

    if (--dwOpenCount == 0) {
        FreeDiskList(pVolumeList, dwNumVolumeListEntries);
/*        if (pVolumeList != NULL) {
            // close handles in volume list
            dwThisEntry = dwNumVolumeListEntries;
            while (dwThisEntry != 0) {
                dwThisEntry--;
                if (pVolumeList[dwThisEntry].hVolume != NULL) {
                    NtClose (pVolumeList[dwThisEntry].hVolume);
                }
                if (pVolumeList[dwThisEntry].DeviceName.Buffer) {
                    FREEMEM(pVolumeList[dwThisEntry].DeviceName.Buffer);
                }
            } 
            FREEMEM (pVolumeList);
#if DBG
            HeapUsed -= oldVLSize;
            DebugPrint((4, "CloseDiskObject: Freed VL %d to %d\n",
                oldVLSize, HeapUsed));
            oldVLSize = 0;
#endif
            pVolumeList = NULL;
            dwNumVolumeListEntries = 0;
        }
*/
        FreeDiskList(pPhysDiskList, dwNumPhysDiskListEntries);
/*        if (pPhysDiskList != NULL) {
            FREEMEM (pPhysDiskList);
#if DBG
            HeapUsed -= oldPLSize;
            DebugPrint((4, "CloseDiskObject: Freed PL %d to %d\n",
                oldVLSize, HeapUsed));
            oldPLSize = 0;
#endif
            pPhysDiskList = NULL;
            dwNumPhysDiskListEntries = 0;
        }
*/
        // close PDisk object
        if (hWmiDiskPerf != NULL) {
            status = WmiCloseBlock (hWmiDiskPerf);
            hWmiDiskPerf = NULL;
        }
    }
#if DBG
    GetSystemTimeAsFileTime((LPFILETIME) &endTime);
    elapsed = (LONG) ((endTime - startTime) / 10000);
    DebugPrint((1, "END CloseDiskObject %d msec\n\n", elapsed));
#endif
    return  status;

}

VOID
FreeDiskList(
    IN PDRIVE_VOLUME_ENTRY pList,
    IN DWORD dwEntries
    )
{
    while (dwEntries != 0) {
        dwEntries--;
        if (pList[dwEntries].hVolume != NULL) {
            NtClose(pList[dwEntries].hVolume);
        }
        if (pList[dwEntries].DeviceName.Buffer) {
            FREEMEM(pList[dwEntries].DeviceName.Buffer);
        }
    }
    FREEMEM(pList);
}


#ifndef _DONT_CHECK_FOR_VOLUME_FILTER
ULONG
CheckVolumeFilter(
    )
/*++

Routine Description:

    This routine checks to see if diskperf is set to be an upper filter
    for Storage Volumes

Arguments:

    None.


Return Value:

    TRUE if there is a filter

--*/
{
    WCHAR Buffer[MAX_PATH+2];
    WCHAR *string = Buffer;
    DWORD dwSize = MAX_PATH * sizeof(WCHAR);
    ULONG stringLength, diskperfLen, result, status;
    HKEY hKey;

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                cszVolumeKey,
                (DWORD) 0,
                KEY_QUERY_VALUE,
                &hKey
                );
    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    status = RegQueryValueExW(
                hKey,
                (LPCWSTR)REGSTR_VAL_UPPERFILTERS,
                NULL,
                NULL,
                (LPBYTE) Buffer,
                &dwSize);

    if (status != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return FALSE;
    }

    Buffer[MAX_PATH] = UNICODE_NULL;   // always terminate just in case
    Buffer[MAX_PATH+1] = UNICODE_NULL; // REG_MULTI_SZ needs 2 NULLs

    stringLength = wcslen(string);

    diskperfLen = wcslen((LPCWSTR)DISKPERF_SERVICE_NAME);

    result = FALSE;
    while(stringLength != 0) {

        if (diskperfLen == stringLength) {
            if(_wcsicmp(string, (LPCWSTR)DISKPERF_SERVICE_NAME) == 0) {
                result = TRUE;
                break;
            }
        }
        string += stringLength + 1;
        stringLength = wcslen(string);
    }
    RegCloseKey(hKey);
    return result;
}
#endif

#if DBG
VOID
PerfDiskDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all PerfDisk

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    if ((DebugPrintLevel <= (PerfDiskDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & PerfDiskDebug)) {
        DbgPrint("%d:Perfdisk!", GetCurrentThreadId());
    }
    else
        return;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (PerfDiskDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & PerfDiskDebug)) {

        if (SUCCEEDED(
                StringCchVPrintfA((LPSTR)PerfDiskDebugBuffer,
                    DEBUG_BUFFER_LENGTH, DebugMessage, ap))) {
            DbgPrint((LPSTR)PerfDiskDebugBuffer);
        }
    }

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\disk\physdisk.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    physdisk.c

Abstract:

    This file implements a Performance Object that presents
    Physical Disk Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#pragma warning ( disable : 4201 ) 
#include <ntdddisk.h>
#include <windows.h>
#include <ole2.h>
#include <wmium.h>
#pragma warning ( default : 4201 )
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>

#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfdisk.h"
#if _DBG_PRINT_INSTANCES
#include <wtypes.h>
#include <stdio.h>
#include <stdlib.h>
#endif
#include "diskmsg.h"
#include "dataphys.h"

DWORD APIENTRY
CollectPDiskObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the logical disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    PPDISK_DATA_DEFINITION      pPhysicalDiskDataDefinition;
    DWORD  TotalLen;            //  Length of the total return block
    PDISK_COUNTER_DATA          pcdTotal;

    DWORD   dwStatus    = ERROR_SUCCESS;
    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition = NULL;

    PWNODE_ALL_DATA WmiDiskInfo;
    DISK_PERFORMANCE            *pDiskPerformance;    //  Disk driver returns counters here

    PWCHAR  wszWmiInstanceName;
    WCHAR   wszInstanceName[MAX_PATH]; // the numbers shouldn't ever get this big
    DWORD   dwInstanceNameOffset;

    DWORD   dwNumPhysicalDisks = 0;

    PPDISK_COUNTER_DATA         pPCD;

    BOOL    bMoreEntries;

    LONGLONG    llTemp;
    DWORD       dwTemp;

    DWORD   dwReturn = ERROR_SUCCESS;
    WORD    wNameLength;

    BOOL    bSkip;

    DWORD       dwCurrentWmiObjCount = 0;
    DWORD       dwRemapCount = 10;

    DOUBLE      dReadTime, dWriteTime, dTransferTime;

    //
    //  Check for sufficient space for Physical Disk object
    //  type definition
    //

    do {
        dwNumPhysicalDisks = 0;
        // make sure the drive letter map is up-to-date
        if (bRemapDriveLetters) {
            dwStatus = MapDriveLetters();
            // MapDriveLetters clears the remap flag when successful
            if (dwStatus != ERROR_SUCCESS) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return dwStatus;
            }
        }

        pPhysicalDiskDataDefinition = (PDISK_DATA_DEFINITION *) *lppData;

        // clear the accumulator structure

        memset (&pcdTotal, 0, sizeof(pcdTotal));
        //
        //  Define Logical Disk data block
        //

        TotalLen = sizeof (PDISK_DATA_DEFINITION);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        memmove(pPhysicalDiskDataDefinition,
               &PhysicalDiskDataDefinition,
               sizeof(PDISK_DATA_DEFINITION));

        // read the data from the diskperf driver


        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pPhysicalDiskDataDefinition[1];

        WmiDiskInfo = (PWNODE_ALL_DATA)WmiBuffer;

        // make sure the structure is valid
        if (WmiDiskInfo->WnodeHeader.BufferSize < sizeof(WNODE_ALL_DATA)) {
            bMoreEntries = FALSE;
            // just to make sure someone notices on a checked build
            assert (WmiDiskInfo->WnodeHeader.BufferSize >= sizeof(WNODE_ALL_DATA));
        } else {
            // make sure there are some entries to return
            bMoreEntries =
                (WmiDiskInfo->InstanceCount > 0) ? TRUE : FALSE;
        }

        while (bMoreEntries) {

            pDiskPerformance = (PDISK_PERFORMANCE)(
                            (PUCHAR)WmiDiskInfo +  WmiDiskInfo->DataBlockOffset);
            dwInstanceNameOffset = *((LPDWORD)(
                            (LPBYTE)WmiDiskInfo +  WmiDiskInfo->OffsetInstanceNameOffsets));
            wNameLength = *(WORD *)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset);
            if (wNameLength > 0) {
                wszWmiInstanceName = (LPWSTR)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset + sizeof(WORD));

                if (IsPhysicalDrive(pDiskPerformance)) {
#if _DBG_PRINT_INSTANCES
                    WCHAR szOutputBuffer[512];
#endif  
                    // then the format is correct AND this is a physical
                    // partition so set the name string pointer and
                    // length for use in creating the instance.
                    memset (wszInstanceName, 0, sizeof(wszInstanceName));
                    GetPhysicalDriveNameString (
                        pDiskPerformance->StorageDeviceNumber,
                        pPhysDiskList,
                        dwNumPhysDiskListEntries,
                        wszInstanceName);
#if _DBG_PRINT_INSTANCES
                    swprintf (szOutputBuffer, (LPCWSTR)L"\nPERFDISK: [%d] PhysDrive [%8.8s,%d] is mapped as: ",
                        dwNumPhysDiskListEntries,
                        pDiskPerformance->StorageManagerName,
                        pDiskPerformance->StorageDeviceNumber);
                    OutputDebugStringW (szOutputBuffer);
                    OutputDebugStringW (wszInstanceName);
#endif  
                    bSkip = FALSE;
                } else {
                    bSkip = TRUE;
                }           
                
                if (!bSkip) {
                    // first see if there's room for this entry....

                    TotalLen =
                        // space already used
                        (DWORD)((PCHAR) pPerfInstanceDefinition -
                        (PCHAR) pPhysicalDiskDataDefinition)
                        // + estimate of this instance
                        +   sizeof(PERF_INSTANCE_DEFINITION)
                        +   (lstrlenW(wszInstanceName) + 1) * sizeof(WCHAR) ;
                    TotalLen = QWORD_MULTIPLE (TotalLen);
                    TotalLen += sizeof(PDISK_COUNTER_DATA);
                    TotalLen = QWORD_MULTIPLE (TotalLen);

                    if ( *lpcbTotalBytes < TotalLen ) {
                        *lpcbTotalBytes = (DWORD) 0;
                        *lpNumObjectTypes = (DWORD) 0;
                        dwReturn = ERROR_MORE_DATA;
                        break;
                    }

                    MonBuildInstanceDefinition(
                        pPerfInstanceDefinition,
                        (PVOID *) &pPCD,
                        0, 0,   // no parent
                        (DWORD)-1,// no unique ID
                        wszInstanceName);

                    // clear counter data block
                    pPCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(PDISK_COUNTER_DATA));

//                  KdPrint (("PERFDISK: (P)   Entry %8.8x for: %ws\n", (DWORD)pPCD, wszWmiInstanceName));

                    // insure quadword alignment of the data structure
                    assert (((DWORD)(pPCD) & 0x00000007) == 0);

                    //  Set up pointer for data collection

                    // the QueueDepth counter is only a byte so clear the unused bytes
                    pDiskPerformance->QueueDepth &= 0x000000FF;

                    //
                    //  Format and collect Physical data
                    //
                    pcdTotal.DiskCurrentQueueLength += pDiskPerformance->QueueDepth;
                    pPCD->DiskCurrentQueueLength = pDiskPerformance->QueueDepth;

                    llTemp = pDiskPerformance->ReadTime.QuadPart +
                             pDiskPerformance->WriteTime.QuadPart;

                    // these values are read in 100 NS units but are expected
                    // to be in sys perf freq (tick) units for the Sec/op ctrs 
                    // so convert them here

                    dReadTime = (DOUBLE)(pDiskPerformance->ReadTime.QuadPart);
                    dWriteTime = (DOUBLE)(pDiskPerformance->WriteTime.QuadPart);
                    dTransferTime = (DOUBLE)(llTemp);

                    dReadTime *= dSysTickTo100Ns;
                    dWriteTime *= dSysTickTo100Ns;
                    dTransferTime *= dSysTickTo100Ns;

                    pPCD->DiskTime = llTemp;
                    pPCD->DiskAvgQueueLength = llTemp;
                    pcdTotal.DiskAvgQueueLength += llTemp;
                    pcdTotal.DiskTime += llTemp;

                    pPCD->DiskReadTime = pDiskPerformance->ReadTime.QuadPart;
                    pPCD->DiskReadQueueLength = pDiskPerformance->ReadTime.QuadPart;
                    pcdTotal.DiskReadTime +=  pDiskPerformance->ReadTime.QuadPart;
                    pcdTotal.DiskReadQueueLength += pDiskPerformance->ReadTime.QuadPart;

                    pPCD->DiskWriteTime = pDiskPerformance->WriteTime.QuadPart;
                    pPCD->DiskWriteQueueLength = pDiskPerformance->WriteTime.QuadPart;

                    pcdTotal.DiskWriteTime += pDiskPerformance->WriteTime.QuadPart;
                    pcdTotal.DiskWriteQueueLength += pDiskPerformance->WriteTime.QuadPart;

                    pPCD->DiskAvgTime = (LONGLONG)dTransferTime;
                    pcdTotal.DiskAvgTime += (LONGLONG)dTransferTime;

                    dwTemp = pDiskPerformance->ReadCount +
                             pDiskPerformance->WriteCount;

                    pcdTotal.DiskTransfersBase1 += dwTemp;
                    pPCD->DiskTransfersBase1 = dwTemp;

                    pcdTotal.DiskAvgReadTime += (LONGLONG)dReadTime;
                    pPCD->DiskAvgReadTime = (LONGLONG)dReadTime;
                    pcdTotal.DiskReadsBase1 += pDiskPerformance->ReadCount;
                    pPCD->DiskReadsBase1 = pDiskPerformance->ReadCount;

                    pcdTotal.DiskAvgWriteTime += (LONGLONG)dWriteTime;
                    pPCD->DiskAvgWriteTime = (LONGLONG)dWriteTime;
                    pcdTotal.DiskWritesBase1 += pDiskPerformance->WriteCount;
                    pPCD->DiskWritesBase1 = pDiskPerformance->WriteCount;

                    pcdTotal.DiskTransfers += dwTemp;
                    pPCD->DiskTransfers = dwTemp;

                    pcdTotal.DiskReads += pDiskPerformance->ReadCount;
                    pPCD->DiskReads = pDiskPerformance->ReadCount;
                    pcdTotal.DiskWrites += pDiskPerformance->WriteCount;
                    pPCD->DiskWrites = pDiskPerformance->WriteCount;

                    llTemp = pDiskPerformance->BytesRead.QuadPart +
                             pDiskPerformance->BytesWritten.QuadPart;
                    pcdTotal.DiskBytes += llTemp;
                    pPCD->DiskBytes = llTemp;

                    pcdTotal.DiskReadBytes += pDiskPerformance->BytesRead.QuadPart;
                    pPCD->DiskReadBytes = pDiskPerformance->BytesRead.QuadPart;
                    pcdTotal.DiskWriteBytes += pDiskPerformance->BytesWritten.QuadPart;
                    pPCD->DiskWriteBytes = pDiskPerformance->BytesWritten.QuadPart;

                    pcdTotal.DiskAvgBytes += llTemp;
                    pPCD->DiskAvgBytes = llTemp;
                    pcdTotal.DiskTransfersBase2 += dwTemp;
                    pPCD->DiskTransfersBase2 = dwTemp;

                    pcdTotal.DiskAvgReadBytes += pDiskPerformance->BytesRead.QuadPart;
                    pPCD->DiskAvgReadBytes = pDiskPerformance->BytesRead.QuadPart;
                    pcdTotal.DiskReadsBase2 += pDiskPerformance->ReadCount;
                    pPCD->DiskReadsBase2 = pDiskPerformance->ReadCount;

                    pcdTotal.DiskAvgWriteBytes += pDiskPerformance->BytesWritten.QuadPart;
                    pPCD->DiskAvgWriteBytes = pDiskPerformance->BytesWritten.QuadPart;
                    pcdTotal.DiskWritesBase2 += pDiskPerformance->WriteCount;
                    pPCD->DiskWritesBase2 = pDiskPerformance->WriteCount;

                    pPCD->IdleTime = pDiskPerformance->IdleTime.QuadPart;
                    pcdTotal.IdleTime += pDiskPerformance->IdleTime.QuadPart;
                    pPCD->SplitCount = pDiskPerformance->SplitCount;
                    pcdTotal.SplitCount += pDiskPerformance->SplitCount;

                    pPCD->DiskTimeTimeStamp = pDiskPerformance->QueryTime.QuadPart;
                    pcdTotal.DiskTimeTimeStamp += pDiskPerformance->QueryTime.QuadPart;

                    // move to the end of the buffer for the next instance
                    pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)&pPCD[1];
                    dwNumPhysicalDisks++;

                } else {
//                  KdPrint (("PERFDISK: (P) Skipping Instance: %ws\n", wszWmiInstanceName));
                }
                // count the number of items returned by WMI
                dwCurrentWmiObjCount++;
            } else {
                // the name has 0 length so skip
            }
               
            // bump pointers inside WMI data block
            if (WmiDiskInfo->WnodeHeader.Linkage != 0) {
                // continue
                WmiDiskInfo = (PWNODE_ALL_DATA) (
                    (LPBYTE)WmiDiskInfo + WmiDiskInfo->WnodeHeader.Linkage);
            } else {
                // this is the end of the line
                bMoreEntries = FALSE;
            }
        } // end for each volume
        // see if number of WMI objects returned is different from
        // the last time the instance table was built, if so then 
        // remap the letters and redo the instances
        if (dwCurrentWmiObjCount != dwWmiDriveCount) {
            DebugPrint((1, "CollectPDisk: Remap Current %d Drive %d\n",
                dwCurrentWmiObjCount, dwWmiDriveCount));
            bRemapDriveLetters = TRUE;
            dwRemapCount--;
        }
    } while (bRemapDriveLetters && dwRemapCount);


    if (dwNumPhysicalDisks > 0) {
        // see if there's room for this entry....

        TotalLen =
            // space already used
            (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pPhysicalDiskDataDefinition)
            // + estimate of this instance
            +   sizeof(PERF_INSTANCE_DEFINITION)
            +   (lstrlenW(wszTotal) + 1) * sizeof(WCHAR) ;
        TotalLen = QWORD_MULTIPLE (TotalLen);
        TotalLen += sizeof(PDISK_COUNTER_DATA);
        TotalLen = QWORD_MULTIPLE (TotalLen);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            dwReturn = ERROR_MORE_DATA;
        } else {
            // normalize the total times
            pcdTotal.DiskTime /= dwNumPhysicalDisks;
            pcdTotal.DiskReadTime /= dwNumPhysicalDisks;
            pcdTotal.DiskWriteTime /= dwNumPhysicalDisks;
            pcdTotal.IdleTime /= dwNumPhysicalDisks;
            pcdTotal.DiskTimeTimeStamp /= dwNumPhysicalDisks;

            MonBuildInstanceDefinition(
                pPerfInstanceDefinition,
                (PVOID *) &pPCD,
                0,
                0,
                (DWORD)-1,
                wszTotal);

            // update the total counters

            // insure quadword alignment of the data structure
            assert (((DWORD)(pPCD) & 0x00000007) == 0);
            memcpy (pPCD, &pcdTotal, sizeof (pcdTotal));
            pPCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(PDISK_COUNTER_DATA));

            // and update the "next byte" pointer
            pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)&pPCD[1];

            // update pointer to next available buffer...
            pPhysicalDiskDataDefinition->DiskObjectType.NumInstances =
                dwNumPhysicalDisks + 1; // add 1 for "Total" disk
        }
    } else {
        //  If we are diskless, then return no instances
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pPhysicalDiskDataDefinition[1];
        pPhysicalDiskDataDefinition->DiskObjectType.NumInstances = 0;
    }

    if (dwReturn == ERROR_SUCCESS) {
        *lpcbTotalBytes =
            pPhysicalDiskDataDefinition->DiskObjectType.TotalByteLength =
                QWORD_MULTIPLE(
                (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pPhysicalDiskDataDefinition));

#if DBG
        // sanity check on buffer size estimates
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFDISK: Physical Disk Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFDISK:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) (((LPBYTE) pPhysicalDiskDataDefinition) + (* lpcbTotalBytes));

        *lpNumObjectTypes = 1;
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\databrws.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATABRWS.h

Abstract:

    Header file for the Windows NT Browser Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATABRWS_H_
#define _DATABRWS_H_

//
//    This is the Browser counter structure presently returned by NT.
//

typedef struct _BROWSER_DATA_DEFINITION {
    PERF_OBJECT_TYPE            BrowserObjectType;
    PERF_COUNTER_DEFINITION     ServerAnnounce;
    PERF_COUNTER_DEFINITION     DomainAnnounce;
    PERF_COUNTER_DEFINITION     TotalAnnounce;
    PERF_COUNTER_DEFINITION     ElectionPacket;
    PERF_COUNTER_DEFINITION     MailslotWrite;
    PERF_COUNTER_DEFINITION     ServerList;
    PERF_COUNTER_DEFINITION     ServerEnum;
    PERF_COUNTER_DEFINITION     DomainEnum;
    PERF_COUNTER_DEFINITION     OtherEnum;
    PERF_COUNTER_DEFINITION     TotalEnum;
    PERF_COUNTER_DEFINITION     ServerAnnounceMiss;
    PERF_COUNTER_DEFINITION     MailslotDatagramMiss;
    PERF_COUNTER_DEFINITION     ServerListMiss;
    PERF_COUNTER_DEFINITION     ServerAnnounceAllocMiss;
    PERF_COUNTER_DEFINITION     MailslotAllocFail;
    PERF_COUNTER_DEFINITION     MailslotReceiveFail;
    PERF_COUNTER_DEFINITION     MailslotWriteFail;
    PERF_COUNTER_DEFINITION     MailslotOpenFail;
    PERF_COUNTER_DEFINITION     MasterAnnounceDup;
    PERF_COUNTER_DEFINITION     DatagramIllegal;
}  BROWSER_DATA_DEFINITION, *PBROWSER_DATA_DEFINITION;

typedef struct _BROWSER_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG                ServerAnnounce;
    LONGLONG                DomainAnnounce;
    LONGLONG                TotalAnnounce;
    DWORD                   ElectionPacket;
    DWORD                   MailslotWrite;
    DWORD                   ServerList;
    DWORD                   ServerEnum;
    DWORD                   DomainEnum;
    DWORD                   OtherEnum;
    DWORD                   TotalEnum;
    DWORD                   ServerAnnounceMiss;
    DWORD                   MailslotDatagramMiss;
    DWORD                   ServerListMiss;
    DWORD                   ServerAnnounceAllocMiss;
    DWORD                   MailslotAllocFail;
    DWORD                   MailslotReceiveFail;
    DWORD                   MailslotWriteFail;
    DWORD                   MailslotOpenFail;
    DWORD                   MasterAnnounceDup;
    LONGLONG                DatagramIllegal;
} BROWSER_COUNTER_DATA, * PBROWSER_COUNTER_DATA;

extern BROWSER_DATA_DEFINITION BrowserDataDefinition;

#endif // _DATABRWS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\datardr.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATARDR.h

Abstract:

    Header file for the Windows NT Redirector Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATARDR_H_
#define _DATARDR_H_

//
//  This is the Rdr counter structure presently returned by NT.
//

typedef struct _RDR_DATA_DEFINITION {
    PERF_OBJECT_TYPE            RdrObjectType;
    PERF_COUNTER_DEFINITION     Bytes;
    PERF_COUNTER_DEFINITION     IoOperations;
    PERF_COUNTER_DEFINITION     Smbs;
    PERF_COUNTER_DEFINITION     BytesReceived;
    PERF_COUNTER_DEFINITION     SmbsReceived;
    PERF_COUNTER_DEFINITION     PagingReadBytesRequested;
    PERF_COUNTER_DEFINITION     NonPagingReadBytesRequested;
    PERF_COUNTER_DEFINITION     CacheReadBytesRequested;
    PERF_COUNTER_DEFINITION     NetworkReadBytesRequested;
    PERF_COUNTER_DEFINITION     BytesTransmitted;
    PERF_COUNTER_DEFINITION     SmbsTransmitted;
    PERF_COUNTER_DEFINITION     PagingWriteBytesRequested;
    PERF_COUNTER_DEFINITION     NonPagingWriteBytesRequested;
    PERF_COUNTER_DEFINITION     CacheWriteBytesRequested;
    PERF_COUNTER_DEFINITION     NetworkWriteBytesRequested;
    PERF_COUNTER_DEFINITION     ReadOperations;
    PERF_COUNTER_DEFINITION     RandomReadOperations;
    PERF_COUNTER_DEFINITION     ReadSmbs;
    PERF_COUNTER_DEFINITION     LargeReadSmbs;
    PERF_COUNTER_DEFINITION     SmallReadSmbs;
    PERF_COUNTER_DEFINITION     WriteOperations;
    PERF_COUNTER_DEFINITION     RandomWriteOperations;
    PERF_COUNTER_DEFINITION     WriteSmbs;
    PERF_COUNTER_DEFINITION     LargeWriteSmbs;
    PERF_COUNTER_DEFINITION     SmallWriteSmbs;
    PERF_COUNTER_DEFINITION     RawReadsDenied;
    PERF_COUNTER_DEFINITION     RawWritesDenied;
    PERF_COUNTER_DEFINITION     NetworkErrors;
    PERF_COUNTER_DEFINITION     Sessions;
    PERF_COUNTER_DEFINITION     Reconnects;
    PERF_COUNTER_DEFINITION     CoreConnects;
    PERF_COUNTER_DEFINITION     Lanman20Connects;
    PERF_COUNTER_DEFINITION     Lanman21Connects;
    PERF_COUNTER_DEFINITION     LanmanNtConnects;
    PERF_COUNTER_DEFINITION     ServerDisconnects;
    PERF_COUNTER_DEFINITION     HungSessions;
    PERF_COUNTER_DEFINITION     CurrentCommands;
} RDR_DATA_DEFINITION, *PRDR_DATA_DEFINITION;

typedef struct _RDR_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG                Bytes;
    DWORD                   IoOperations;
    LONGLONG                Smbs;
    LONGLONG                BytesReceived;
    LONGLONG                SmbsReceived;
    LONGLONG                PagingReadBytesRequested;
    LONGLONG                NonPagingReadBytesRequested;
    LONGLONG                CacheReadBytesRequested;
    LONGLONG                NetworkReadBytesRequested;
    LONGLONG                BytesTransmitted;
    LONGLONG                SmbsTransmitted;
    LONGLONG                PagingWriteBytesRequested;
    LONGLONG                NonPagingWriteBytesRequested;
    LONGLONG                CacheWriteBytesRequested;
    LONGLONG                NetworkWriteBytesRequested;
    DWORD                   ReadOperations;
    DWORD                   RandomReadOperations;
    DWORD                   ReadSmbs;
    DWORD                   LargeReadSmbs;
    DWORD                   SmallReadSmbs;
    DWORD                   WriteOperations;
    DWORD                   RandomWriteOperations;
    DWORD                   WriteSmbs;
    DWORD                   LargeWriteSmbs;
    DWORD                   SmallWriteSmbs;
    DWORD                   RawReadsDenied;
    DWORD                   RawWritesDenied;
    DWORD                   NetworkErrors;
    DWORD                   Sessions;
    DWORD                   Reconnects;
    DWORD                   CoreConnects;
    DWORD                   Lanman20Connects;
    DWORD                   Lanman21Connects;
    DWORD                   LanmanNtConnects;
    DWORD                   ServerDisconnects;
    DWORD                   HungSessions;
    DWORD                   CurrentCommands;
} RDR_COUNTER_DATA, * PRDR_COUNTER_DATA;

extern RDR_DATA_DEFINITION RdrDataDefinition;

#endif // _DATARDR_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\datardr.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datardr.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Redirector Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datardr.h"

// dummy variable for field sizing.
static RDR_COUNTER_DATA   rcd;

//
//  Constant structure initializations 
//      defined in datardr.h
//

RDR_DATA_DEFINITION RdrDataDefinition = {
    {   sizeof(RDR_DATA_DEFINITION) + sizeof(RDR_COUNTER_DATA),
        sizeof(RDR_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        REDIRECTOR_OBJECT_TITLE_INDEX,
        0,
        263,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(RDR_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        389,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.Bytes),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Bytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        406,
        0,
        391,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.IoOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->IoOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        400,
        0,
        401,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.Smbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Smbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        265,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.BytesReceived),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->BytesReceived
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        266,
        0,
        267,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.SmbsReceived),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->SmbsReceived
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        268,
        0,
        269,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.PagingReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->PagingReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        270,
        0,
        271,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.NonPagingReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NonPagingReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        272,
        0,
        273,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.CacheReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->CacheReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        274,
        0,
        275,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.NetworkReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NetworkReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        276,
        0,
        277,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.BytesTransmitted),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->BytesTransmitted
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        278,
        0,
        279,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.SmbsTransmitted),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->SmbsTransmitted
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        280,
        0,
        281,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.PagingReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->PagingReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        282,
        0,
        283,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.NonPagingWriteBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NonPagingWriteBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        284,
        0,
        285,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.CacheWriteBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->CacheWriteBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        286,
        0,
        287,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.NetworkWriteBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NetworkWriteBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        10,
        0,
        289,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.ReadOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->ReadOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        290,
        0,
        291,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.RandomReadOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->RandomReadOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        292,
        0,
        293,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.ReadSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->ReadSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        294,
        0,
        295,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.LargeReadSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->LargeReadSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        296,
        0,
        297,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.SmallReadSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->SmallReadSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        12,
        0,
        299,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.WriteOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->WriteOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        300,
        0,
        301,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.RandomWriteOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->RandomWriteOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        302,
        0,
        303,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.WriteSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->WriteSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        304,
        0,
        305,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.LargeWriteSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->LargeWriteSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        306,
        0,
        307,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.SmallWriteSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->SmallWriteSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        308,
        0,
        309,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.RawReadsDenied),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->RawReadsDenied
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        310,
        0,
        311,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.RawWritesDenied),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->RawWritesDenied
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        312,
        0,
        313,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.NetworkErrors),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NetworkErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        314,
        0,
        315,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.Sessions),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Sessions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        316,
        0,
        317,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.Reconnects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Reconnects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        318,
        0,
        319,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.CoreConnects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->CoreConnects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        320,
        0,
        321,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.Lanman20Connects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Lanman20Connects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        322,
        0,
        323,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.Lanman21Connects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Lanman21Connects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        324,
        0,
        325,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.LanmanNtConnects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->LanmanNtConnects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        326,
        0,
        327,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.ServerDisconnects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->ServerDisconnects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        328,
        0,
        329,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.HungSessions),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->HungSessions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        392,
        0,
        393,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.CurrentCommands),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->CurrentCommands
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\databrws.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    databrws.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Browser Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "databrws.h"

// dummy variable for field sizing.
static BROWSER_COUNTER_DATA   bcd;

BROWSER_DATA_DEFINITION BrowserDataDefinition =
{
    {   sizeof (BROWSER_DATA_DEFINITION) + sizeof (BROWSER_COUNTER_DATA),
        sizeof (BROWSER_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        BROWSER_OBJECT_TITLE_INDEX,
        0,
        53,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(BROWSER_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) /
            sizeof (PERF_COUNTER_DEFINITION),
        0,
        -1,
        UNICODE_CODE_PAGE,
        {0L, 0L},
        {0L, 0L}
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        54,
        0,
        55,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (bcd.ServerAnnounce),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerAnnounce
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        78,
        0,
        79,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (bcd.DomainAnnounce),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->DomainAnnounce
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        188,
        0,
        813,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (bcd.TotalAnnounce),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->TotalAnnounce
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        80,
        0,
        81,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.ElectionPacket),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ElectionPacket
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        82,
        0,
        83,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.MailslotWrite),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotWrite
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        84,
        0,
        85,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.ServerList),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerList
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        156,
        0,
        161,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.ServerEnum),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerEnum
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        158,
        0,
        163,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.DomainEnum),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->DomainEnum
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        160,
        0,
        165,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.OtherEnum),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->OtherEnum
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        190,
        0,
        815,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.TotalEnum),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->TotalEnum
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        162,
        0,
        167,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.ServerAnnounceMiss),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerAnnounceMiss
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        164,
        0,
        169,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MailslotDatagramMiss),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotDatagramMiss
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        166,
        0,
        171,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.ServerListMiss),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerListMiss
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        168,
        0,
        381,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.ServerAnnounceAllocMiss),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerAnnounceAllocMiss
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        170,
        0,
        383,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MailslotAllocFail),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotAllocFail
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        806,
        0,
        385,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MailslotReceiveFail),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotReceiveFail
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        808,
        0,
        387,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MailslotWriteFail),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotWriteFail
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        810,
        0,
        807,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.MailslotOpenFail),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotOpenFail
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        812,
        0,
        809,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MasterAnnounceDup),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MasterAnnounceDup
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        814,
        0,
        811,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (bcd.DatagramIllegal),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->DatagramIllegal
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\datasrv.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datasrv.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Server Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datasrv.h"

// dummy variable for field sizing.
static SRV_COUNTER_DATA   scd;

//
//  Constant structure initializations 
//      defined in datasrv.h
//

SRV_DATA_DEFINITION SrvDataDefinition = {
    {   sizeof(SRV_DATA_DEFINITION) + sizeof(SRV_COUNTER_DATA),
        sizeof(SRV_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        SERVER_OBJECT_TITLE_INDEX,
        0,
        331,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(SRV_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        395,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (scd.TotalBytes),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->TotalBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        333,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (scd.TotalBytesReceived),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->TotalBytesReceived
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        276,
        0,
        335,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (scd.TotalBytesSent),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->TotalBytesSent
    },               
    {   sizeof(PERF_COUNTER_DEFINITION),
        340,
        0,
        341,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SessionsTimedOut),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SessionsTimedOut
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        342,
        0,
        343,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SessionsErroredOut),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SessionsErroredOut
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        344,
        0,
        345,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SessionsLoggedOff),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SessionsLoggedOff
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        346,
        0,
        347,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SessionsForcedLogOff),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SessionsForcedLogOff
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        348,
        0,
        349,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.LogonErrors),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->LogonErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        350,
        0,
        351,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.AccessPermissionErrors),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->AccessPermissionErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        352,
        0,
        353,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.GrantedAccessErrors),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->GrantedAccessErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        354,
        0,
        355,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SystemErrors),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SystemErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        356,
        0,
        357,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (scd.BlockingSmbsRejected),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->BlockingSmbsRejected
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        358,
        0,
        359,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (scd.WorkItemShortages),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->WorkItemShortages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        360,
        0,
        361,
        0,
        -3,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.TotalFilesOpened),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->TotalFilesOpened
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        362,
        0,
        363,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentOpenFiles),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentOpenFiles
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        314,
        0,
        365,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentSessions),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentSessions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        366,
        0,
        367,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentOpenSearches),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentOpenSearches
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        369,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentNonPagedPoolUsage),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentNonPagedPoolUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        370,
        0,
        371,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (scd.NonPagedPoolFailures),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->NonPagedPoolFailures
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        372,
        0,
        373,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.PeakNonPagedPoolUsage),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->PeakNonPagedPoolUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        375,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentPagedPoolUsage),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentPagedPoolUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        376,
        0,
        377,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.PagedPoolFailures),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->PagedPoolFailures
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        378,
        0,
        379,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.PeakPagedPoolUsage),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->PeakPagedPoolUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        404,
        0,
        405,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (scd.ContextBlockQueueRate),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->ContextBlockQueueRate
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        692,
        0,
        693,
        0,
        1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (scd.NetLogon),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->NetLogon
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1260,
        0,
        1261,
        0,
        1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.NetLogonTotal),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->NetLogonTotal
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\datasrv.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATASRV.h

Abstract:

    Header file for the Windows NT Server Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATASRV_H_
#define _DATASRV_H_

//
//  logical disk performance definition structure
//

//
//  This is the Srv counter structure presently returned by NT.
//

typedef struct _SRV_DATA_DEFINITION {
    PERF_OBJECT_TYPE        SrvObjectType;
    PERF_COUNTER_DEFINITION cdTotalBytes;
    PERF_COUNTER_DEFINITION cdTotalBytesReceived;
    PERF_COUNTER_DEFINITION cdTotalBytesSent;
    PERF_COUNTER_DEFINITION cdSessionsTimedOut;
    PERF_COUNTER_DEFINITION cdSessionsErroredOut;
    PERF_COUNTER_DEFINITION cdSessionsLoggedOff;
    PERF_COUNTER_DEFINITION cdSessionsForcedLogOff;
    PERF_COUNTER_DEFINITION cdLogonErrors;
    PERF_COUNTER_DEFINITION cdAccessPermissionErrors;
    PERF_COUNTER_DEFINITION cdGrantedAccessErrors;
    PERF_COUNTER_DEFINITION cdSystemErrors;
    PERF_COUNTER_DEFINITION cdBlockingSmbsRejected;
    PERF_COUNTER_DEFINITION cdWorkItemShortages;
    PERF_COUNTER_DEFINITION cdTotalFilesOpened;
    PERF_COUNTER_DEFINITION cdCurrentOpenFiles;
    PERF_COUNTER_DEFINITION cdCurrentSessions;
    PERF_COUNTER_DEFINITION cdCurrentOpenSearches;
    PERF_COUNTER_DEFINITION cdCurrentNonPagedPoolUsage;
    PERF_COUNTER_DEFINITION cdNonPagedPoolFailures;
    PERF_COUNTER_DEFINITION cdPeakNonPagedPoolUsage;
    PERF_COUNTER_DEFINITION cdCurrentPagedPoolUsage;
    PERF_COUNTER_DEFINITION cdPagedPoolFailures;
    PERF_COUNTER_DEFINITION cdPeakPagedPoolUsage;
    PERF_COUNTER_DEFINITION cdContextBlockQueueRate;
    PERF_COUNTER_DEFINITION cdNetLogon;
    PERF_COUNTER_DEFINITION cdNetLogonTotal;
} SRV_DATA_DEFINITION, *PSRV_DATA_DEFINITION;

typedef struct _SRV_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG                TotalBytes;
    LONGLONG                TotalBytesReceived;
    LONGLONG                TotalBytesSent;
    DWORD                   SessionsTimedOut;
    DWORD                   SessionsErroredOut;
    DWORD                   SessionsLoggedOff;
    DWORD                   SessionsForcedLogOff;
    DWORD                   LogonErrors;
    DWORD                   AccessPermissionErrors;
    DWORD                   GrantedAccessErrors;
    DWORD                   SystemErrors;
    DWORD                   BlockingSmbsRejected;
    DWORD                   WorkItemShortages;
    DWORD                   TotalFilesOpened;
    DWORD                   CurrentOpenFiles;
    DWORD                   CurrentSessions;
    DWORD                   CurrentOpenSearches;
    DWORD                   CurrentNonPagedPoolUsage;
    DWORD                   NonPagedPoolFailures;
    DWORD                   PeakNonPagedPoolUsage;
    DWORD                   CurrentPagedPoolUsage;
    DWORD                   PagedPoolFailures;
    DWORD                   PeakPagedPoolUsage;
    DWORD                   ContextBlockQueueRate;
    DWORD                   NetLogon;
    DWORD                   NetLogonTotal;
} SRV_COUNTER_DATA, * PSRV_COUNTER_DATA;

extern SRV_DATA_DEFINITION SrvDataDefinition;


#endif // _DATASRV_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\datasrvq.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datasrvq.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Physical Disk Server Queue data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datasrvq.h"

// dummy variable for field sizing.
static SRVQ_COUNTER_DATA   sqcd;

SRVQ_DATA_DEFINITION SrvQDataDefinition = {
    {
        sizeof(SRVQ_DATA_DEFINITION) + sizeof(SRVQ_COUNTER_DATA),
        sizeof(SRVQ_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        SERVER_QUEUE_OBJECT_TITLE_INDEX,
        0,
        1301,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(SRVQ_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
          sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1302,
        0,
        1303,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.QueueLength),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->QueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1304,
        0,
        1305,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.ActiveThreads),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->ActiveThreads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1306,
        0,
        1307,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.AvailableThreads),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->AvailableThreads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1308,
        0,
        1309,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.AvailableWorkItems),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->AvailableWorkItems
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1310,
        0,
        1311,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.BorrowedWorkItems),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BorrowedWorkItems
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1312,
        0,
        1313,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.WorkItemShortages),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->WorkItemShortages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1314,
        0,
        1315,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.CurrentClients),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->CurrentClients
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        1317,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.BytesReceived),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BytesReceived
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        506,
        0,
        1319,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.BytesSent),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BytesSent
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1320,
        0,
        1321,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.TotalBytesTransfered),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->TotalBytesTransfered
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        288,
        0,
        1323,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.ReadOperations),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->ReadOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1324,
        0,
        1325,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.BytesRead),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BytesRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        298,
        0,
        1327,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.WriteOperations),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->WriteOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1328,
        0,
        1329,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.BytesWritten),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BytesWritten
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        508,
        0,
        1331,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.TotalBytes),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->TotalBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1332,
        0,
        1333,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.TotalOperations),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->TotalOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        404,
        0,
        405,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(sqcd.TotalContextBlocksQueued),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->TotalContextBlocksQueued
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\datasrvq.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATASRVQ.h

Abstract:

    Header file for the Windows NT Processor Server Queue counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATASRVQ_H_
#define _DATASRVQ_H_

//
//  define for Server Queue Statistics
//

typedef struct _SRVQ_DATA_DEFINITION {
    PERF_OBJECT_TYPE        SrvQueueObjectType;
    PERF_COUNTER_DEFINITION cdQueueLength;
    PERF_COUNTER_DEFINITION cdActiveThreads;
    PERF_COUNTER_DEFINITION cdAvailableThreads;
    PERF_COUNTER_DEFINITION cdAvailableWorkItems;
    PERF_COUNTER_DEFINITION cdBorrowedWorkItems;
    PERF_COUNTER_DEFINITION cdWorkItemShortages;
    PERF_COUNTER_DEFINITION cdCurrentClients;
    PERF_COUNTER_DEFINITION cdBytesReceived;
    PERF_COUNTER_DEFINITION cdBytesSent;
    PERF_COUNTER_DEFINITION cdTotalBytesTransfered;
    PERF_COUNTER_DEFINITION cdReadOperations;
    PERF_COUNTER_DEFINITION cdBytesRead;
    PERF_COUNTER_DEFINITION cdWriteOperations;
    PERF_COUNTER_DEFINITION cdBytesWritten;
    PERF_COUNTER_DEFINITION cdTotalBytes;
    PERF_COUNTER_DEFINITION cdTotalOperations;
    PERF_COUNTER_DEFINITION cdTotalContextBlocksQueued;
} SRVQ_DATA_DEFINITION, * PSRVQ_DATA_DEFINITION;


typedef struct _SRVQ_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   QueueLength;
    DWORD                   ActiveThreads;
    DWORD                   AvailableThreads;
    DWORD                   AvailableWorkItems;
    DWORD                   BorrowedWorkItems;
    DWORD                   WorkItemShortages;
    DWORD                   CurrentClients;
    LONGLONG                BytesReceived;
    LONGLONG                BytesSent;
    LONGLONG                TotalBytesTransfered;
    LONGLONG                ReadOperations;
    LONGLONG                BytesRead;
    LONGLONG                WriteOperations;
    LONGLONG                BytesWritten;
    LONGLONG                TotalBytes;
    LONGLONG                TotalOperations;
    DWORD                   TotalContextBlocksQueued;
} SRVQ_COUNTER_DATA, * PSRVQ_COUNTER_DATA;

extern SRVQ_DATA_DEFINITION SrvQDataDefinition;

#endif // _DATASRVQ_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\perfnet.h ===
extern  HANDLE  hEventLog;       // handle to event log
extern  HANDLE  hLibHeap;       // handle to DLL heap            
extern  LPWSTR  wszTotal;

PM_OPEN_PROC    OpenServerObject;
PM_LOCAL_COLLECT_PROC CollectServerObjectData;
PM_CLOSE_PROC   CloseServerObject;

PM_OPEN_PROC    OpenServerQueueObject;
PM_LOCAL_COLLECT_PROC CollectServerQueueObjectData;
PM_CLOSE_PROC   CloseServerQueueObject;

PM_OPEN_PROC    OpenRedirObject;
PM_LOCAL_COLLECT_PROC CollectRedirObjectData;
PM_CLOSE_PROC   CloseRedirObject;

PM_OPEN_PROC    OpenBrowserObject;
PM_LOCAL_COLLECT_PROC CollectBrowserObjectData;
PM_CLOSE_PROC   CloseBrowserObject;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\perfbrws.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfbrws.c

Abstract:

    This file implements a Performance Object that presents
    Browser Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History

--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmwksta.h>
#include <lmbrowsr.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfnet.h"
#include "netsvcmc.h"
#include "databrws.h"

//  BrowserStatFunction is used for collecting Browser Statistic Data
typedef NET_API_STATUS (*PBROWSERQUERYSTATISTIC) (
    IN  LPTSTR      servername OPTIONAL,
    OUT LPBROWSER_STATISTICS *statistics
    );

PBROWSERQUERYSTATISTIC BrowserStatFunction = NULL;
HANDLE dllHandle  = NULL;
BOOL   bInitBrwsOk = FALSE;

DWORD APIENTRY
OpenBrowserObject (
    IN  LPWSTR  lpValueName
)
/*++
    GetBrowserStatistic   -   Get the I_BrowserQueryStatistics entry point

--*/
{
    UINT    dwOldMode;
    LONG    status = ERROR_SUCCESS;
    HANDLE  hDll = dllHandle;

    UNREFERENCED_PARAMETER (lpValueName);

    bInitBrwsOk = TRUE;

    if (hDll != NULL) { // Open already called once
        return status;
    }
    dwOldMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    //
    // Dynamically link to netapi32.dll.  If it's not there just return.
    //

    hDll = LoadLibraryW((LPCWSTR)L"NetApi32.Dll") ;
    if ( !hDll || hDll == INVALID_HANDLE_VALUE ) {
        status = GetLastError();
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFNET_UNABLE_OPEN_NETAPI32_DLL,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);
        BrowserStatFunction = NULL;
        bInitBrwsOk = FALSE;
    } else {
        //
        // Replace the global handle atomically
        //
        if (InterlockedCompareExchangePointer(
                &dllHandle,
                hDll,
                NULL) != NULL) {
            FreeLibrary(hDll);  // close the duplicate handle
        }
        //
        // Get the address of the service's main entry point.  This
        // entry point has a well-known name.
        //
        BrowserStatFunction = (PBROWSERQUERYSTATISTIC)GetProcAddress (
            dllHandle, "I_BrowserQueryStatistics") ;

        if (BrowserStatFunction == NULL) {
            status = GetLastError();
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_LOCATE_BROWSER_PERF_FN,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
            bInitBrwsOk = FALSE;
        }
    }

    SetErrorMode( dwOldMode );

    return status;
}

DWORD APIENTRY
CollectBrowserObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Physical Disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD                   TotalLen;  //  Length of the total return block
    NTSTATUS                Status = ERROR_SUCCESS;

    BROWSER_DATA_DEFINITION *pBrowserDataDefinition;
    BROWSER_COUNTER_DATA    *pBCD;

    BROWSER_STATISTICS      BrowserStatistics;
    LPBROWSER_STATISTICS    pBrowserStatistics = &BrowserStatistics;

    //
    //  Check for sufficient space for browser data
    //

    if (!bInitBrwsOk) {
        // function didn't initialize so bail out here
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    TotalLen = sizeof(BROWSER_DATA_DEFINITION) +
               sizeof(BROWSER_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        // not enough room in the buffer for 1 instance
        // so bail
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define objects data block
    //

    pBrowserDataDefinition = (BROWSER_DATA_DEFINITION *) *lppData;

    memcpy (pBrowserDataDefinition,
            &BrowserDataDefinition,
            sizeof(BROWSER_DATA_DEFINITION));
    //
    //  Format and collect browser data
    //

    pBCD = (PBROWSER_COUNTER_DATA)&pBrowserDataDefinition[1];

    // test for quadword alignment of the structure
    assert  (((DWORD)(pBCD) & 0x00000007) == 0);

    memset (pBrowserStatistics, 0, sizeof (BrowserStatistics));

    if ( BrowserStatFunction != NULL ) {
        Status = (*BrowserStatFunction) (NULL,
                                         &pBrowserStatistics
                                        );
    } else {
        Status =  STATUS_INVALID_ADDRESS;
    }

    if (NT_SUCCESS(Status)) {
        pBCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(BROWSER_COUNTER_DATA));
        pBCD->TotalAnnounce  =
            pBCD->ServerAnnounce = BrowserStatistics.NumberOfServerAnnouncements.QuadPart;
        pBCD->TotalAnnounce  +=
            pBCD->DomainAnnounce = BrowserStatistics.NumberOfDomainAnnouncements.QuadPart;

        pBCD->ElectionPacket = BrowserStatistics.NumberOfElectionPackets;
        pBCD->MailslotWrite = BrowserStatistics.NumberOfMailslotWrites;
        pBCD->ServerList    = BrowserStatistics.NumberOfGetBrowserServerListRequests;
        pBCD->ServerEnum    = BrowserStatistics.NumberOfServerEnumerations;
        pBCD->DomainEnum    = BrowserStatistics.NumberOfDomainEnumerations;
        pBCD->OtherEnum     = BrowserStatistics.NumberOfOtherEnumerations;
        pBCD->TotalEnum     = BrowserStatistics.NumberOfServerEnumerations
                              + BrowserStatistics.NumberOfDomainEnumerations
                              + BrowserStatistics.NumberOfOtherEnumerations;
        pBCD->ServerAnnounceMiss    = BrowserStatistics.NumberOfMissedServerAnnouncements;
        pBCD->MailslotDatagramMiss  = BrowserStatistics.NumberOfMissedMailslotDatagrams;
        pBCD->ServerListMiss        = BrowserStatistics.NumberOfMissedGetBrowserServerListRequests;
        pBCD->ServerAnnounceAllocMiss = BrowserStatistics.NumberOfFailedServerAnnounceAllocations;
        pBCD->MailslotAllocFail     = BrowserStatistics.NumberOfFailedMailslotAllocations;
        pBCD->MailslotReceiveFail   = BrowserStatistics.NumberOfFailedMailslotReceives;
        pBCD->MailslotWriteFail     = BrowserStatistics.NumberOfFailedMailslotWrites;
        pBCD->MailslotOpenFail      = BrowserStatistics.NumberOfFailedMailslotOpens;
        pBCD->MasterAnnounceDup     = BrowserStatistics.NumberOfDuplicateMasterAnnouncements;
        pBCD->DatagramIllegal       = BrowserStatistics.NumberOfIllegalDatagrams.QuadPart;

    } else {
        if (BrowserStatFunction != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_LOCATE_BROWSER_PERF_FN,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&Status);
        }

        //
        // Failure to access Browser: clear counters to 0
        //
        memset(pBCD, 0, sizeof(BROWSER_COUNTER_DATA));
        pBCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(BROWSER_COUNTER_DATA));

    }
    *lpcbTotalBytes = pBrowserDataDefinition->BrowserObjectType.TotalByteLength
                    = (DWORD) QWORD_MULTIPLE((LPBYTE) &pBCD[1] - (LPBYTE) pBrowserDataDefinition);
    *lppData = (LPVOID) (((LPBYTE) pBrowserDataDefinition) + *lpcbTotalBytes);
    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseBrowserObject ()
{
    HANDLE hDll = dllHandle;

    bInitBrwsOk = FALSE;
    if (hDll != NULL) {
        if (InterlockedCompareExchangePointer(
                &dllHandle,
                NULL,
                hDll) == hDll) {
            FreeLibrary (hDll);
        }
        BrowserStatFunction = NULL;
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\perfrdr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfrdr.c

Abstract:

    This file implements a Performance Object that presents
    Redirector Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnfs.h>
#include <ntioapi.h>
#include <windows.h>
#include <assert.h>
#include <srvfsctl.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfnet.h"
#include "netsvcmc.h"
#include "datardr.h"

HANDLE  hRdr = NULL;
BOOL    bRdrError = FALSE;      // Log only one event per process


DWORD APIENTRY
OpenRedirObject (
    IN  LPWSTR  lpValueName
)
{
    UNICODE_STRING      DeviceNameU;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            status;
    HANDLE              hLocalRdr = NULL;

    UNREFERENCED_PARAMETER (lpValueName);

    // open the handle to the server for data collection
    //
    //  Now get access to the Redirector for its data
    //

    RtlInitUnicodeString(&DeviceNameU, DD_NFS_DEVICE_NAME_U);

    InitializeObjectAttributes(&ObjectAttributes,
                                &DeviceNameU,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

    status = NtCreateFile(&hLocalRdr,
                            SYNCHRONIZE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_OPEN_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );

    if (!NT_SUCCESS(status)) {
        if (!bRdrError) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_OPEN_REDIR,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
            bRdrError = TRUE;
        }
    }
    else {
        if (InterlockedCompareExchangePointer(
                &hRdr,
                hLocalRdr,
                NULL) != NULL) {
            //
            // Replace only if the global handle is NULL
            //
            NtClose(hLocalRdr);     // close duplicate handle
        }
    }

    return (DWORD)RtlNtStatusToDosError(status);

}

DWORD APIENTRY
CollectRedirObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Physical Disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{

    DWORD           TotalLen;          //  Length of the total return block
    NTSTATUS        Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    RDR_DATA_DEFINITION *pRdrDataDefinition;
    RDR_COUNTER_DATA    *pRCD;

    REDIR_STATISTICS RdrStatistics;

    if ( hRdr == NULL ) {
        // redir didn't get opened and it has already been logged
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }
    //
    //  Check for sufficient space for redirector data
    //

    TotalLen = sizeof(RDR_DATA_DEFINITION) +
               sizeof(RDR_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define objects data block
    //

    pRdrDataDefinition = (RDR_DATA_DEFINITION *) *lppData;

    memcpy (pRdrDataDefinition,
            &RdrDataDefinition,
            sizeof(RDR_DATA_DEFINITION));

    //
    //  Format and collect redirector data
    //

    pRCD = (PRDR_COUNTER_DATA)&pRdrDataDefinition[1];

    // test for quadword alignment of the structure
    assert  (((DWORD)(pRCD) & 0x00000007) == 0);

    pRCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (RDR_COUNTER_DATA));

    Status = NtFsControlFile(hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_LMR_GET_STATISTICS,
                                NULL,
                                0,
                                &RdrStatistics,
                                sizeof(RdrStatistics)
                                );
    if (NT_SUCCESS(Status)) {
        // transfer Redir data
        pRCD->Bytes             = RdrStatistics.BytesReceived.QuadPart +
                                  RdrStatistics.BytesTransmitted.QuadPart;
        pRCD->IoOperations      = RdrStatistics.ReadOperations +
                                  RdrStatistics.WriteOperations;
        pRCD->Smbs              = RdrStatistics.SmbsReceived.QuadPart +
                                  RdrStatistics.SmbsTransmitted.QuadPart;
        pRCD->BytesReceived     = RdrStatistics.BytesReceived.QuadPart;
        pRCD->SmbsReceived      = RdrStatistics.SmbsReceived.QuadPart;
        pRCD->PagingReadBytesRequested  = RdrStatistics.PagingReadBytesRequested.QuadPart;
        pRCD->NonPagingReadBytesRequested   = RdrStatistics.NonPagingReadBytesRequested.QuadPart;
        pRCD->CacheReadBytesRequested   = RdrStatistics.CacheReadBytesRequested.QuadPart;
        pRCD->NetworkReadBytesRequested = RdrStatistics.NetworkReadBytesRequested.QuadPart;
        pRCD->BytesTransmitted  = RdrStatistics.BytesTransmitted.QuadPart;
        pRCD->SmbsTransmitted   = RdrStatistics.SmbsTransmitted.QuadPart;
        pRCD->PagingWriteBytesRequested = RdrStatistics.PagingWriteBytesRequested.QuadPart;
        pRCD->NonPagingWriteBytesRequested  = RdrStatistics.NonPagingWriteBytesRequested.QuadPart;
        pRCD->CacheWriteBytesRequested  = RdrStatistics.CacheWriteBytesRequested.QuadPart;
        pRCD->NetworkWriteBytesRequested    = RdrStatistics.NetworkWriteBytesRequested.QuadPart;
        pRCD->ReadOperations    = RdrStatistics.ReadOperations;
        pRCD->RandomReadOperations  = RdrStatistics.RandomReadOperations;
        pRCD->ReadSmbs          = RdrStatistics.ReadSmbs;
        pRCD->LargeReadSmbs     = RdrStatistics.LargeReadSmbs;
        pRCD->SmallReadSmbs     = RdrStatistics.SmallReadSmbs;
        pRCD->WriteOperations   = RdrStatistics.WriteOperations;
        pRCD->RandomWriteOperations = RdrStatistics.RandomWriteOperations;
        pRCD->WriteSmbs         = RdrStatistics.WriteSmbs;
        pRCD->LargeWriteSmbs    = RdrStatistics.LargeWriteSmbs;
        pRCD->SmallWriteSmbs    = RdrStatistics.SmallWriteSmbs;
        pRCD->RawReadsDenied    = RdrStatistics.RawReadsDenied;
        pRCD->RawWritesDenied   = RdrStatistics.RawWritesDenied;
        pRCD->NetworkErrors     = RdrStatistics.NetworkErrors;
        pRCD->Sessions          = RdrStatistics.Sessions;
        pRCD->Reconnects        = RdrStatistics.Reconnects;
        pRCD->CoreConnects      = RdrStatistics.CoreConnects;
        pRCD->Lanman20Connects  = RdrStatistics.Lanman20Connects;
        pRCD->Lanman21Connects  = RdrStatistics.Lanman21Connects;
        pRCD->LanmanNtConnects  = RdrStatistics.LanmanNtConnects;
        pRCD->ServerDisconnects = RdrStatistics.ServerDisconnects;
        pRCD->HungSessions      = RdrStatistics.HungSessions;
        pRCD->CurrentCommands   = RdrStatistics.CurrentCommands;

    } else {

        //
        // Failure to access Redirector: clear counters to 0
        //

        if (!bRdrError) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_READ_REDIR,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&Status);
            bRdrError = TRUE;
        }

        memset(pRCD, 0, sizeof(RDR_COUNTER_DATA));
        pRCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (RDR_COUNTER_DATA));

    }
    *lpcbTotalBytes = pRdrDataDefinition->RdrObjectType.TotalByteLength
                    = (DWORD) QWORD_MULTIPLE((LPBYTE) &pRCD[1] - (LPBYTE) pRdrDataDefinition);
    * lppData       = (LPVOID) (((LPBYTE) pRdrDataDefinition) + *lpcbTotalBytes);
    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseRedirObject ()
{
    HANDLE hLocalRdr = hRdr;

    if (hLocalRdr != NULL) {
        if (InterlockedCompareExchangePointer(
                &hRdr,
                NULL,
                hLocalRdr) == hLocalRdr) {
            NtClose(hLocalRdr);
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\perfnet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfnet.c

Abstract:


Author:

    Bob Watson (a-robw) Aug 95

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <assert.h>

#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfnet.h"
#include "netsvcmc.h"

// bit field definitions for collect function flags

#define POS_COLLECT_SERVER_DATA         ((DWORD)0x00000001)
#define POS_COLLECT_SERVER_QUEUE_DATA   ((DWORD)0x00000002)
#define POS_COLLECT_REDIR_DATA          ((DWORD)0x00000004)
#define POS_COLLECT_BROWSER_DATA        ((DWORD)0x00000008)

#define POS_COLLECT_GLOBAL_DATA         ((DWORD)0x0000000F)
#define POS_COLLECT_FOREIGN_DATA        ((DWORD)0)
#define POS_COLLECT_COSTLY_DATA         ((DWORD)0)

// global variables to this DLL

HANDLE  ThisDLLHandle = NULL;
HANDLE  hEventLog     = NULL;
HANDLE  hLibHeap      = NULL;

// variables local to this module

static POS_FUNCTION_INFO    posDataFuncInfo[] = {
    {SERVER_OBJECT_TITLE_INDEX,         POS_COLLECT_SERVER_DATA,    0, CollectServerObjectData},
    {SERVER_QUEUE_OBJECT_TITLE_INDEX,   POS_COLLECT_SERVER_QUEUE_DATA,     0, CollectServerQueueObjectData},
    {REDIRECTOR_OBJECT_TITLE_INDEX,     POS_COLLECT_REDIR_DATA,     0, CollectRedirObjectData},
    {BROWSER_OBJECT_TITLE_INDEX,        POS_COLLECT_BROWSER_DATA,   0, CollectBrowserObjectData}
};

#define POS_NUM_FUNCS   (sizeof(posDataFuncInfo) / sizeof(posDataFuncInfo[1]))

BOOL bInitOk  = FALSE;
DWORD   dwOpenCount = 0;

BOOL    bReportedNotOpen = FALSE;

PM_OPEN_PROC    OpenNetSvcsObject;
PM_COLLECT_PROC CollecNetSvcsObjectData;
PM_CLOSE_PROC   CloseNetSvcsObject;

static
BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    perform any initialization function that apply to all object
    modules
   
--*/
{
    BOOL    bReturn = TRUE;

    UNREFERENCED_PARAMETER (DllHandle);

    // create heap for this library
    if (hLibHeap == NULL) hLibHeap = HeapCreate (0, 1, 0);

    assert (hLibHeap != NULL);

    if (hLibHeap == NULL) {
        return FALSE;
    }
    // open handle to the event log
    if (hEventLog == NULL) hEventLog = MonOpenEventLog((LPWSTR)L"PerfNet");
    assert (hEventLog != NULL);

    return bReturn;
}

static
BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    UNREFERENCED_PARAMETER (DllHandle);

    if (dwOpenCount != 0) {
        // make sure the object has been closed before the
        // library is deleted.
        // setting dwOpenCount to 1 insures that all
        // the objects will be closed on this call
        if (dwOpenCount > 1) dwOpenCount = 1;
        CloseNetSvcsObject();
        dwOpenCount = 0;
    }

    if (hLibHeap != NULL) {
        HeapDestroy (hLibHeap); 
        hLibHeap = NULL;
    }

    if (hEventLog != NULL) {
        MonCloseEventLog ();
        hEventLog = NULL;
    }
    return TRUE;
}

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    ReservedAndUnused;

    // this will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach (DLLHandle);

        case DLL_PROCESS_DETACH:
            return DllProcessDetach (DLLHandle);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            return TRUE;
    }
}

DWORD APIENTRY
OpenNetSvcsObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry
    NOTE: This routine assumes it is being called in a MUTEX by the caller
    and will not collide with Close & Collect call.

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    DWORD   dwErrorCount = 0;

    if (dwOpenCount == 0) {

        status = OpenServerObject (lpDeviceNames);
        // if this didn't open, it's not fatal, just no 
        // server stats will be returned
        if (status != ERROR_SUCCESS) {
            dwErrorCount++;
            status = ERROR_SUCCESS;
        }

        status = OpenServerQueueObject (lpDeviceNames);
        // if this didn't open, it's not fatal, just no 
        // server queue stats will be returned
        if (status != ERROR_SUCCESS) {
            dwErrorCount++;
            status = ERROR_SUCCESS;
        }

        status = OpenRedirObject (lpDeviceNames);
        // if this didn't open, it's not fatal, just no 
        // Redir stats will be returned
        if (status != ERROR_SUCCESS) {
            dwErrorCount++;
            status = ERROR_SUCCESS;
        }

        status = OpenBrowserObject (lpDeviceNames);
        // if this didn't open, it's not fatal, just no 
        // Browser stats will be returned
        if (status != ERROR_SUCCESS) {
            dwErrorCount++;
            status = ERROR_SUCCESS;
        }

        if (dwErrorCount < POS_NUM_FUNCS) {
            // then at least one object opened OK so continue
            bInitOk = TRUE;
            dwOpenCount++;
        } else {
            // none of the objects opened, so give up.
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_OPEN,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }
    } else {
        // already opened so bump the refcount
        dwOpenCount++;
    }

    return  status;
}

DWORD APIENTRY
CollectNetSvcsObjectData (
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object
    NOTE: This routine assumes it is being called in a MUTEX by the caller
    and will not collide with Open & Close call.

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    // build bit mask of functions to call

    DWORD       dwQueryType;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;

    DWORD       dwNumObjectsFromFunction;
    DWORD       dwOrigBuffSize;
    DWORD       dwByteSize;

    if (!bInitOk) {
        if (!bReportedNotOpen) {
            bReportedNotOpen = ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_NOT_OPEN,
                NULL,
                0,
                0,
                NULL,
                NULL);
        }
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto COLLECT_BAIL_OUT;
    }

    dwQueryType = GetQueryType (lpValueName);

    switch (dwQueryType) {
        case QUERY_ITEMS:
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (IsNumberInUnicodeList (
                    posDataFuncInfo[FunctionIndex].dwObjectId, lpValueName)) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                }
            }
            break;

        case QUERY_GLOBAL:
            FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
            break;

        case QUERY_FOREIGN:
            FunctionCallMask = POS_COLLECT_FOREIGN_DATA;
            break;

        case QUERY_COSTLY:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;

        default:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;
    }

    // collect data 
    *lpNumObjectTypes = 0;
    dwOrigBuffSize = dwByteSize = *lpcbTotalBytes;
    *lpcbTotalBytes = 0;

    for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
        if (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit &
            FunctionCallMask) {
            dwNumObjectsFromFunction = 0;
            lReturn = (*posDataFuncInfo[FunctionIndex].pCollectFunction) (
                lppData,
                &dwByteSize,
                &dwNumObjectsFromFunction);

            if (lReturn == ERROR_SUCCESS) {
                *lpNumObjectTypes += dwNumObjectsFromFunction;
                *lpcbTotalBytes += dwByteSize;
                dwOrigBuffSize -= dwByteSize;
                dwByteSize = dwOrigBuffSize;
            } else {
                break;
            }
        }
    }

    // *lppData is updated by each function
    // *lpcbTotalBytes is updated after each successful function
    // *lpNumObjects is updated after each successful function

COLLECT_BAIL_OUT:
    
    return lReturn;
}

DWORD APIENTRY
CloseNetSvcsObject (
)
/*++

Routine Description:

    This routine closes the open objects for the net services counters.
    NOTE: This routine assumes it is being called in a MUTEX by the caller
    and will not collide with Open & Collect call.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (dwOpenCount > 0) {
        dwOpenCount--;
    }
    if (dwOpenCount == 0) {
        // close stuff here
        CloseServerQueueObject();
        CloseServerObject();
        CloseRedirObject();
        CloseBrowserObject();
    }
    return  ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datacach.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATACACH.h

Abstract:

    Header file for the Windows NT Cache Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATACACH_H_
#define _DATACACH_H_

//
// Cache Performance Object
//

typedef struct _CACHE_DATA_DEFINITION {
    PERF_OBJECT_TYPE		CacheObjectType;
    PERF_COUNTER_DEFINITION	cdDataMaps;
    PERF_COUNTER_DEFINITION	cdSyncDataMaps;
    PERF_COUNTER_DEFINITION	cdAsyncDataMaps;
    PERF_COUNTER_DEFINITION	cdDataMapHits;
    PERF_COUNTER_DEFINITION	cdDataMapHitsBase;
    PERF_COUNTER_DEFINITION	cdDataMapPins;
    PERF_COUNTER_DEFINITION	cdDataMapPinsBase;
    PERF_COUNTER_DEFINITION	cdPinReads;
    PERF_COUNTER_DEFINITION	cdSyncPinReads;
    PERF_COUNTER_DEFINITION	cdAsyncPinReads;
    PERF_COUNTER_DEFINITION	cdPinReadHits;
    PERF_COUNTER_DEFINITION	cdPinReadHitsBase;
    PERF_COUNTER_DEFINITION	cdCopyReads;
    PERF_COUNTER_DEFINITION	cdSyncCopyReads;
    PERF_COUNTER_DEFINITION	cdAsyncCopyReads;
    PERF_COUNTER_DEFINITION	cdCopyReadHits;
    PERF_COUNTER_DEFINITION	cdCopyReadHitsBase;
    PERF_COUNTER_DEFINITION	cdMdlReads;
    PERF_COUNTER_DEFINITION	cdSyncMdlReads;
    PERF_COUNTER_DEFINITION	cdAsyncMdlReads;
    PERF_COUNTER_DEFINITION	cdMdlReadHits;
    PERF_COUNTER_DEFINITION	cdMdlReadHitsBase;
    PERF_COUNTER_DEFINITION	cdReadAheads;
    PERF_COUNTER_DEFINITION	cdFastReads;
    PERF_COUNTER_DEFINITION	cdSyncFastReads;
    PERF_COUNTER_DEFINITION	cdAsyncFastReads;
    PERF_COUNTER_DEFINITION	cdFastReadResourceMiss;
    PERF_COUNTER_DEFINITION	cdFastReadNotPossibles;
    PERF_COUNTER_DEFINITION	cdLazyWriteFlushes;
    PERF_COUNTER_DEFINITION	cdLazyWritePages;
    PERF_COUNTER_DEFINITION	cdDataFlushes;
    PERF_COUNTER_DEFINITION	cdDataPages;
} CACHE_DATA_DEFINITION, * PCACHE_DATA_DEFINITION;

typedef struct _CACHE_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   DataMaps;
    DWORD                   SyncDataMaps;
    DWORD                   AsyncDataMaps;
    DWORD                   DataMapHits;
    DWORD                   DataMapHitsBase;
    DWORD                   DataMapPins;
    DWORD                   DataMapPinsBase;
    DWORD                   PinReads;
    DWORD                   SyncPinReads;
    DWORD                   AsyncPinReads;
    DWORD                   PinReadHits;
    DWORD                   PinReadHitsBase;
    DWORD                   CopyReads;
    DWORD                   SyncCopyReads;
    DWORD                   AsyncCopyReads;
    DWORD                   CopyReadHits;
    DWORD                   CopyReadHitsBase;
    DWORD                   MdlReads;
    DWORD                   SyncMdlReads;
    DWORD                   AsyncMdlReads;
    DWORD                   MdlReadHits;
    DWORD                   MdlReadHitsBase;
    DWORD                   ReadAheads;
    DWORD                   FastReads;
    DWORD                   SyncFastReads;
    DWORD                   AsyncFastReads;
    DWORD                   FastReadResourceMiss;
    DWORD                   FastReadNotPossibles;
    DWORD                   LazyWriteFlushes;
    DWORD                   LazyWritePages;
    DWORD                   DataFlushes;
    DWORD                   DataPages;
} CACHE_COUNTER_DATA, * PCACHE_COUNTER_DATA;

extern CACHE_DATA_DEFINITION CacheDataDefinition;

#endif _DATACACH_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\netsvcs\perfsrv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfsrv.c

Abstract:

    This file implements a Performance Object that presents
    Server Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnfs.h>
#include <windows.h>
#include <assert.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmwksta.h>
#include <srvfsctl.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <assert.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfnet.h"
#include "netsvcmc.h"
#include "datasrv.h"
#include "datasrvq.h"

#define MAX_SRVQ_NAME_LENGTH    16

HANDLE  hSrv = NULL;

SRV_QUEUE_STATISTICS *pSrvQueueStatistics = NULL;
DWORD  dwDataBufferLength = 0L;
SYSTEM_BASIC_INFORMATION BasicInfo;

BOOL bFsCtlError = FALSE;       // print error only once per process

BOOL bSrvQOk = TRUE;

DWORD APIENTRY
OpenServerObject (
    IN  LPWSTR  lpValueName
)
{
    STRING              DeviceName;
    UNICODE_STRING      DeviceNameU;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            status;
    HANDLE              hLocalSrv = NULL;

    UNREFERENCED_PARAMETER (lpValueName);

    // open the handle to the server for data collection
    //
    // Get access to the Server for it's data
    //

    RtlInitString(&DeviceName, SERVER_DEVICE_NAME);
    DeviceNameU.Buffer = NULL;
    status = RtlAnsiStringToUnicodeString(&DeviceNameU, &DeviceName, TRUE);
    if (NT_SUCCESS(status)) {
        InitializeObjectAttributes(&ObjectAttributes,
                                   &DeviceNameU,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );

        status = NtOpenFile(&hLocalSrv,
                            SYNCHRONIZE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            0,
                            FILE_SYNCHRONOUS_IO_NONALERT
                            );
    }

    if (!NT_SUCCESS(status)) {
        hSrv = NULL;
        bSrvQOk = FALSE;
        if (!bFsCtlError) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_OPEN_SERVER,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
            bFsCtlError = TRUE;
        }
    }
    else {
        if (InterlockedCompareExchangePointer(
                &hSrv,
                hLocalSrv,
                NULL) != NULL) {
            NtClose(hLocalSrv);     // Close duplicate handle
        }
    }

    if (DeviceNameU.Buffer) {
        RtlFreeUnicodeString(&DeviceNameU);
    }

    return (DWORD)RtlNtStatusToDosError(status);

}

DWORD APIENTRY
OpenServerQueueObject (
    IN  LPWSTR  szValueName
)
{
    NTSTATUS    status;

    UNREFERENCED_PARAMETER (szValueName);
    //
    //  collect basic and static processor data
    //

    status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &BasicInfo,
                    sizeof(SYSTEM_BASIC_INFORMATION),
                    NULL
                    );

    assert (NT_SUCCESS(status));
    if (!NT_SUCCESS(status)) {
        // all we really want is the number of processors so
        // if we can't get that from the system, then we'll
        // substitute 32 for the number
        BasicInfo.NumberOfProcessors = 32;
        status = ERROR_SUCCESS;
    }
    // compute the various buffer sizes required

    dwDataBufferLength = sizeof(SRV_QUEUE_STATISTICS) *
        (BasicInfo.NumberOfProcessors + 1);

    pSrvQueueStatistics = (SRV_QUEUE_STATISTICS *)ALLOCMEM (dwDataBufferLength);

    // if memory allocation failed, then no server queue stats will
    // be returned.

    assert (pSrvQueueStatistics != NULL);

    if (pSrvQueueStatistics == NULL) {
        bSrvQOk = FALSE;
    }

    return ERROR_SUCCESS;

}

DWORD APIENTRY
CollectServerObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Physical Disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block
    NTSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    SRV_DATA_DEFINITION *pSrvDataDefinition;
    SRV_COUNTER_DATA    *pSCD;

    SRV_STATISTICS SrvStatistics;

    if (hSrv == NULL) {
        // bail out if the server didn't get opened.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    //
    //  Check for sufficient space for server data
    //

    TotalLen = sizeof(SRV_DATA_DEFINITION) +
               sizeof(SRV_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        // bail out if the data won't fit in the caller's buffer
        // or the server didn't get opened.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define objects data block
    //

    pSrvDataDefinition = (SRV_DATA_DEFINITION *) *lppData;

    memcpy (pSrvDataDefinition,
           &SrvDataDefinition,
           sizeof(SRV_DATA_DEFINITION));

    //
    //  Format and collect server data
    //

    pSCD = (PSRV_COUNTER_DATA)&pSrvDataDefinition[1];

    // test for quadword alignment of the structure
    assert  (((DWORD)(pSCD) & 0x00000007) == 0);

    pSCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(SRV_COUNTER_DATA));

    Status = NtFsControlFile(hSrv,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SRV_GET_STATISTICS,
                                NULL,
                                0,
                                &SrvStatistics,
                                sizeof(SrvStatistics)
                                );

    if ( NT_SUCCESS(Status) ) {
        pSCD->TotalBytes            = SrvStatistics.TotalBytesSent.QuadPart +
                                        SrvStatistics.TotalBytesReceived.QuadPart;

        pSCD->TotalBytesReceived    = SrvStatistics.TotalBytesReceived.QuadPart;
        pSCD->TotalBytesSent        = SrvStatistics.TotalBytesSent.QuadPart;
        pSCD->SessionsTimedOut      = SrvStatistics.SessionsTimedOut;
        pSCD->SessionsErroredOut    = SrvStatistics.SessionsErroredOut;
        pSCD->SessionsLoggedOff     = SrvStatistics.SessionsLoggedOff;
        pSCD->SessionsForcedLogOff  = SrvStatistics.SessionsForcedLogOff;
        pSCD->LogonErrors           = SrvStatistics.LogonErrors;
        pSCD->AccessPermissionErrors = SrvStatistics.AccessPermissionErrors;
        pSCD->GrantedAccessErrors   = SrvStatistics.GrantedAccessErrors;
        pSCD->SystemErrors          = SrvStatistics.SystemErrors;
        pSCD->BlockingSmbsRejected  = SrvStatistics.BlockingSmbsRejected;
        pSCD->WorkItemShortages     = SrvStatistics.WorkItemShortages;
        pSCD->TotalFilesOpened      = SrvStatistics.TotalFilesOpened;
        pSCD->CurrentOpenFiles      = SrvStatistics.CurrentNumberOfOpenFiles;
        pSCD->CurrentSessions       = SrvStatistics.CurrentNumberOfSessions;
        pSCD->CurrentOpenSearches   = SrvStatistics.CurrentNumberOfOpenSearches;
        pSCD->CurrentNonPagedPoolUsage = SrvStatistics.CurrentNonPagedPoolUsage;
        pSCD->NonPagedPoolFailures  = SrvStatistics.NonPagedPoolFailures;
        pSCD->PeakNonPagedPoolUsage = SrvStatistics.PeakNonPagedPoolUsage;
        pSCD->CurrentPagedPoolUsage = SrvStatistics.CurrentPagedPoolUsage;
        pSCD->PagedPoolFailures     = SrvStatistics.PagedPoolFailures;
        pSCD->PeakPagedPoolUsage    = SrvStatistics.PeakPagedPoolUsage;
        pSCD->ContextBlockQueueRate = SrvStatistics.TotalWorkContextBlocksQueued.Count;
        pSCD->NetLogon =
            pSCD->NetLogonTotal     = SrvStatistics.SessionLogonAttempts;

    } else {
        if (!bFsCtlError) {

            // log an event describing the error
            DWORD   dwData[4];
            DWORD   dwDataIndex = 0;

            dwData[dwDataIndex++] = Status;
            dwData[dwDataIndex++] = IoStatusBlock.Status;
            dwData[dwDataIndex++] = (DWORD)IoStatusBlock.Information;

            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,        // error type
                0,                          // category (not used)
                PERFNET_UNABLE_READ_SERVER, // error code
                NULL,                       // SID (not used),
                0,                          // number of strings
                dwDataIndex * sizeof(DWORD),  // sizeof raw data
                NULL,                       // message text array
                (LPVOID)&dwData[0]);        // raw data
            bFsCtlError = TRUE;
        }
        //
        // Failure to access Server: clear counters to 0
        //

        memset(pSCD, 0, sizeof(SRV_COUNTER_DATA));
        pSCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(SRV_COUNTER_DATA));
    }

    *lpcbTotalBytes = pSrvDataDefinition->SrvObjectType.TotalByteLength
                    = (DWORD) QWORD_MULTIPLE(((LPBYTE) (& pSCD[1])) - (LPBYTE) pSrvDataDefinition);
    * lppData       = (LPVOID) (((LPBYTE) pSrvDataDefinition) + * lpcbTotalBytes);
    *lpNumObjectTypes = 1;
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CollectServerQueueObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Physical Disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block
    LONG  nQueue;

    NTSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    SRVQ_DATA_DEFINITION        *pSrvQDataDefinition;
    PERF_INSTANCE_DEFINITION    *pPerfInstanceDefinition;
    SRVQ_COUNTER_DATA           *pSQCD;


    SRV_QUEUE_STATISTICS *pThisQueueStatistics;

    UNICODE_STRING      QueueName;
    WCHAR               QueueNameBuffer[MAX_SRVQ_NAME_LENGTH];

    if (!bSrvQOk) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    //
    //  Check for sufficient space for server data
    //

    TotalLen = sizeof(SRVQ_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               sizeof(SRVQ_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    // assign local pointer to current position in buffer
    pSrvQDataDefinition = (SRVQ_DATA_DEFINITION *) *lppData;

    //
    //  Define perf object data block
    //

    memcpy (pSrvQDataDefinition,
            &SrvQDataDefinition,
            sizeof(SRVQ_DATA_DEFINITION));

    //
    //  Format and collect server Queue data
    //

    QueueName.Length = 0;
    QueueName.MaximumLength = sizeof(QueueNameBuffer);
    QueueName.Buffer = QueueNameBuffer;

    Status = NtFsControlFile(hSrv,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SRV_GET_QUEUE_STATISTICS,
                                NULL,
                                0,
                                pSrvQueueStatistics,
                                dwDataBufferLength
                                );

    if (NT_SUCCESS(Status)) {
        // server data was collected successfully so...
        // process each processor queue instance.

        nQueue = 0;
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                            &pSrvQDataDefinition[1];

        TotalLen = sizeof(SRVQ_DATA_DEFINITION);

        for (nQueue = 0; nQueue < BasicInfo.NumberOfProcessors; nQueue++) {
            // see if this instance will fit
            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                        8 +     // size of 3 (unicode) digit queuelength name
                        sizeof(SRVQ_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_MORE_DATA;
            }

            RtlIntegerToUnicodeString(nQueue,
                                      10,
                                      &QueueName);

            // there should be enough room for this instance so initialize it

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pSQCD,
                0,
                0,
                (DWORD)-1,
                QueueName.Buffer);

            pSQCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (SRVQ_COUNTER_DATA));

            // initialize pointers for this instance
            pThisQueueStatistics = &pSrvQueueStatistics[nQueue];

            pSQCD->QueueLength = pThisQueueStatistics->QueueLength;
            pSQCD->ActiveThreads = pThisQueueStatistics->ActiveThreads;
            pSQCD->AvailableThreads = pThisQueueStatistics->AvailableThreads;
            pSQCD->AvailableWorkItems = pThisQueueStatistics->FreeWorkItems;
            pSQCD->BorrowedWorkItems = pThisQueueStatistics->StolenWorkItems;
            pSQCD->WorkItemShortages = pThisQueueStatistics->NeedWorkItem;
            pSQCD->CurrentClients = pThisQueueStatistics->CurrentClients;
            pSQCD->TotalBytesTransfered =
                pSQCD->BytesReceived = pThisQueueStatistics->BytesReceived.QuadPart;
            pSQCD->TotalBytesTransfered +=
                pSQCD->BytesSent = pThisQueueStatistics->BytesSent.QuadPart;
            pSQCD->TotalOperations =
                pSQCD->ReadOperations = pThisQueueStatistics->ReadOperations.QuadPart;
            pSQCD->TotalBytes =
                pSQCD->BytesRead = pThisQueueStatistics->BytesRead.QuadPart;
            pSQCD->TotalOperations +=
                pSQCD->WriteOperations = pThisQueueStatistics->WriteOperations.QuadPart;
            pSQCD->TotalBytes +=
                pSQCD->BytesWritten = pThisQueueStatistics->BytesWritten.QuadPart;
            pSQCD->TotalContextBlocksQueued = pThisQueueStatistics->TotalWorkContextBlocksQueued.Count;

            // update the current pointer
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pSQCD[1];
        }

        RtlInitUnicodeString (&QueueName, (LPCWSTR)L"Blocking Queue");

        // now load the "blocking" queue data
        // see if this instance will fit
        TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                QWORD_MULTIPLE(QueueName.Length + sizeof(WCHAR)) +
                sizeof (SRVQ_COUNTER_DATA);

        if ( *lpcbTotalBytes < TotalLen ) {
            // this instance won't fit so bail out
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        // there should be enough room for this instance so initialize it

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *) &pSQCD,
            0,
            0,
            (DWORD)-1,
            QueueName.Buffer);

        pSQCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(SRVQ_COUNTER_DATA));

        // initialize pointers for this instance
        pThisQueueStatistics = &pSrvQueueStatistics[nQueue];

        pSQCD->QueueLength = pThisQueueStatistics->QueueLength;
        pSQCD->ActiveThreads = pThisQueueStatistics->ActiveThreads;
        pSQCD->AvailableThreads = pThisQueueStatistics->AvailableThreads;
        pSQCD->AvailableWorkItems = 0;
        pSQCD->BorrowedWorkItems = 0;
        pSQCD->WorkItemShortages = 0;
        pSQCD->CurrentClients = 0;
        pSQCD->TotalBytesTransfered =
            pSQCD->BytesReceived = pThisQueueStatistics->BytesReceived.QuadPart;
        pSQCD->TotalBytesTransfered +=
            pSQCD->BytesSent = pThisQueueStatistics->BytesSent.QuadPart;
        pSQCD->ReadOperations = 0;
        pSQCD->TotalBytes =
            pSQCD->BytesRead = pThisQueueStatistics->BytesRead.QuadPart;
        pSQCD->WriteOperations = 0;
        pSQCD->TotalBytes +=
            pSQCD->BytesWritten = pThisQueueStatistics->BytesWritten.QuadPart;
        pSQCD->TotalOperations = 0;
        pSQCD->TotalContextBlocksQueued = pThisQueueStatistics->TotalWorkContextBlocksQueued.Count;

        nQueue++; // to include the Blocking Queue statistics entry

        // update the current pointer
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pSQCD[1];

        // update queue (instance) count in object data block
        pSrvQDataDefinition->SrvQueueObjectType.NumInstances = nQueue;

        // update available length
        *lpcbTotalBytes =
            pSrvQDataDefinition->SrvQueueObjectType.TotalByteLength =
                QWORD_MULTIPLE(
                (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pSrvQDataDefinition));

#if DBG
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFNET: Server Queue Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFNET:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) ((PCHAR) pSrvQDataDefinition + *lpcbTotalBytes);

        *lpNumObjectTypes = 1;
    } else {
        if (!bFsCtlError) {
            // unable to read server queue data for some reason so don't return this
            // object

            // log an event describing the error
            DWORD   dwData[4];
            DWORD   dwDataIndex = 0;

            dwData[dwDataIndex++] = Status;
            dwData[dwDataIndex++] = IoStatusBlock.Status;
            dwData[dwDataIndex++] = (DWORD)IoStatusBlock.Information;

            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,        // error type
                0,                          // category (not used)
                PERFNET_UNABLE_READ_SERVER_QUEUE, // error code
                NULL,                       // SID (not used),
                0,                          // number of strings
                dwDataIndex * sizeof(DWORD),  // sizeof raw data
                NULL,                       // message text array
                (LPVOID)&dwData[0]);        // raw data
            bFsCtlError = TRUE;
        }

        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
    }
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseServerObject ()
{
    HANDLE hLocalSrv = hSrv;
    if (hLocalSrv != NULL) {
        if (InterlockedCompareExchangePointer(
                &hSrv,
                NULL,
                hLocalSrv) == hLocalSrv) {
            NtClose(hLocalSrv);
        }
    }

    return ERROR_SUCCESS;
}
DWORD APIENTRY
CloseServerQueueObject ()
{
    if (hLibHeap != NULL) {
        if (pSrvQueueStatistics != NULL) {
            FREEMEM (pSrvQueueStatistics);
            pSrvQueueStatistics = NULL;
        }
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datacpu.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATACPU.h

Abstract:

    Header file for the Windows NT Processor Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATACPU_H_
#define _DATACPU_H_

//
//  Processor data object
//

typedef struct _PROCESSOR_DATA_DEFINITION {
    PERF_OBJECT_TYPE		ProcessorObjectType;
    PERF_COUNTER_DEFINITION	cdProcessorTime;
    PERF_COUNTER_DEFINITION	cdUserTime;
    PERF_COUNTER_DEFINITION	cdKernelTime;
    PERF_COUNTER_DEFINITION	cdInterrupts;
    PERF_COUNTER_DEFINITION	cdDpcTime;
    PERF_COUNTER_DEFINITION	cdInterruptTime;
    PERF_COUNTER_DEFINITION cdDpcCountRate;
    PERF_COUNTER_DEFINITION cdDpcRate;
} PROCESSOR_DATA_DEFINITION, *PPROCESSOR_DATA_DEFINITION;

typedef struct _PROCESSOR_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   dwPad1;
    LONGLONG                ProcessorTime;
    LONGLONG                UserTime;
    LONGLONG                KernelTime;
    DWORD                   Interrupts;
    DWORD                   dwPad2;
    LONGLONG                DpcTime;
    LONGLONG                InterruptTime;
    DWORD                   DpcCountRate;
    DWORD                   DpcRate;
} PROCESSOR_COUNTER_DATA, *PPROCESSOR_COUNTER_DATA;

extern PROCESSOR_DATA_DEFINITION ProcessorDataDefinition;

typedef struct _EX_PROCESSOR_DATA_DEFINITION {
    PERF_OBJECT_TYPE		ProcessorObjectType;
    PERF_COUNTER_DEFINITION	cdProcessorTime;
    PERF_COUNTER_DEFINITION	cdUserTime;
    PERF_COUNTER_DEFINITION	cdKernelTime;
    PERF_COUNTER_DEFINITION	cdInterrupts;
    PERF_COUNTER_DEFINITION	cdDpcTime;
    PERF_COUNTER_DEFINITION	cdInterruptTime;
    PERF_COUNTER_DEFINITION cdDpcCountRate;
    PERF_COUNTER_DEFINITION cdDpcRate;
// Whistler counters
    PERF_COUNTER_DEFINITION cdIdleTime;
    PERF_COUNTER_DEFINITION cdC1Time;
    PERF_COUNTER_DEFINITION cdC2Time;
    PERF_COUNTER_DEFINITION cdC3Time;
    PERF_COUNTER_DEFINITION cdC1Transitions;
    PERF_COUNTER_DEFINITION cdC2Transitions;
    PERF_COUNTER_DEFINITION cdC3Transitions;
} EX_PROCESSOR_DATA_DEFINITION, *PEX_PROCESSOR_DATA_DEFINITION;

typedef struct _EX_PROCESSOR_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   dwPad1;
    LONGLONG                ProcessorTime;
    LONGLONG                UserTime;
    LONGLONG                KernelTime;
    DWORD                   Interrupts;
    DWORD                   dwPad2;
    LONGLONG                DpcTime;
    LONGLONG                InterruptTime;
    DWORD                   DpcCountRate;
    DWORD                   DpcRate;
// Whistler counters
    LONGLONG                IdleTime;
    LONGLONG                C1Time;
    LONGLONG                C2Time;
    LONGLONG                C3Time;
    LONGLONG                C1Transitions;
    LONGLONG                C2Transitions;
    LONGLONG                C3Transitions;
} EX_PROCESSOR_COUNTER_DATA, *PEX_PROCESSOR_COUNTER_DATA;

extern EX_PROCESSOR_DATA_DEFINITION ExProcessorDataDefinition;
#endif // _DATACPU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datacach.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datacach.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Cache performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datacach.h"

//
//  Constant structure initializations 
//      defined in datacach.h
//

CACHE_DATA_DEFINITION CacheDataDefinition = {

    {   sizeof(CACHE_DATA_DEFINITION) + sizeof (CACHE_COUNTER_DATA),
        sizeof(CACHE_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        CACHE_OBJECT_TITLE_INDEX,
        0,
        87,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(CACHE_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        3,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        88,
        0,
        89,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, DataMaps),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMaps
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        90,
        0,
        91,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, SyncDataMaps),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncDataMaps
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        92,
        0,
        93,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, AsyncDataMaps),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncDataMaps
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        94,
        0,
        95,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_FRACTION,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, DataMapHits),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMapHits
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        94,
        0,
        95,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_BASE,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, DataMapHitsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMapHitsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        96,
        0,
        97,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_FRACTION,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, DataMapPins),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMapPins
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        96,
        0,
        97,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_BASE,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, DataMapPinsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMapPinsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        98,
        0,
        99,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, PinReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->PinReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        100,
        0,
        101,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, SyncPinReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncPinReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        102,
        0,
        103,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, AsyncPinReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncPinReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        104,
        0,
        105,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_FRACTION,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, PinReadHits),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->PinReadHits
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        104,
        0,
        105,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_BASE,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, PinReadHitsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->PinReadHitsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        106,
        0,
        107,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, CopyReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->CopyReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        108,
        0,
        109,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, SyncCopyReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncCopyReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        110,
        0,
        111,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, AsyncCopyReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncCopyReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        112,
        0,
        113,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_FRACTION,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, CopyReadHits),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->CopyReadHits
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        112,
        0,
        113,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_BASE,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, CopyReadHitsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->CopyReadHitsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        114,
        0,
        115,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, MdlReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->MdlReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        116,
        0,
        117,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, SyncMdlReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncMdlReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        118,
        0,
        119,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, AsyncMdlReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncMdlReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        120,
        0,
        121,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_FRACTION,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, MdlReadHits),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->MdlReadHits
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        120,
        0,
        121,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_BASE,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, MdlReadHitsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->MdlReadHitsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        122,
        0,
        123,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, ReadAheads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->ReadAheads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        124,
        0,
        125,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, FastReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->FastReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        126,
        0,
        127,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, SyncFastReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncFastReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        128,
        0,
        129,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, AsyncFastReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncFastReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        130,
        0,
        131,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, FastReadResourceMiss),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->FastReadResourceMiss
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        132,
        0,
        133,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, FastReadNotPossibles),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->FastReadNotPossibles
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        134,
        0,
        135,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, LazyWriteFlushes),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->LazyWriteFlushes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        136,
        0,
        137,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, LazyWritePages),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->LazyWritePages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        138,
        0,
        139,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, DataFlushes),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataFlushes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        140,
        0,
        141,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(CACHE_COUNTER_DATA, DataPages),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataPages
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datamem.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

      DATAMEM.h

Abstract:

    Header file for the Windows NT Memory Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAMEM_H_
#define _DATAMEM_H_

//
//  Memory Performance Counter
//

typedef struct _MEMORY_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    MemoryObjectType;
    PERF_COUNTER_DEFINITION	    cdPageFaults;
    PERF_COUNTER_DEFINITION     cdAvailablePages;
    PERF_COUNTER_DEFINITION	    cdCommittedPages;
    PERF_COUNTER_DEFINITION     cdCommitList;
    PERF_COUNTER_DEFINITION	    cdWriteCopies;
    PERF_COUNTER_DEFINITION	    cdTransitionFaults;
    PERF_COUNTER_DEFINITION     cdCacheFaults;
    PERF_COUNTER_DEFINITION	    cdDemandZeroFaults;
    PERF_COUNTER_DEFINITION     cdPages;
    PERF_COUNTER_DEFINITION	    cdPagesInput;
    PERF_COUNTER_DEFINITION     cdPageReads;
    PERF_COUNTER_DEFINITION	    cdDirtyPages;
    PERF_COUNTER_DEFINITION     cdPagedPool;
    PERF_COUNTER_DEFINITION	    cdNonPagedPool;
    PERF_COUNTER_DEFINITION	    cdDirtyWrites;
    PERF_COUNTER_DEFINITION	    cdPagedPoolAllocs;
    PERF_COUNTER_DEFINITION	    cdNonPagedPoolAllocs;
    PERF_COUNTER_DEFINITION     cdFreeSystemPtes;
    PERF_COUNTER_DEFINITION     cdCacheBytes;
    PERF_COUNTER_DEFINITION     cdPeakCacheBytes;
    PERF_COUNTER_DEFINITION     cdResidentPagedPoolBytes;
    PERF_COUNTER_DEFINITION     cdTotalSysCodeBytes;
    PERF_COUNTER_DEFINITION     cdResidentSysCodeBytes;
    PERF_COUNTER_DEFINITION     cdTotalSsysDriverBytes;
    PERF_COUNTER_DEFINITION     cdResidentSysDriverBytes;
    PERF_COUNTER_DEFINITION     cdResidentSysCacheBytes;
    PERF_COUNTER_DEFINITION     cdCommitBytesInUse;
    PERF_COUNTER_DEFINITION     cdCommitBytesLimit;
    PERF_COUNTER_DEFINITION     cdAvailableKBytes;
    PERF_COUNTER_DEFINITION     cdAvailableMBytes;
    PERF_COUNTER_DEFINITION     cdTransitionRePurpose;
//    PERF_COUNTER_DEFINITION	    cdSystemVlmCommitCharge;
//    PERF_COUNTER_DEFINITION	    cdSystemVlmPeakCommitCharge;
//    PERF_COUNTER_DEFINITION	    cdSystemVlmSharedCommitCharge;
} MEMORY_DATA_DEFINITION, * PMEMORY_DATA_DEFINITION;

typedef struct _MEMORY_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                       PageFaults;
    LONGLONG                    AvailablePages;
    LONGLONG                    CommittedPages;
    LONGLONG                    CommitList;
    DWORD                       WriteCopies;
    DWORD                       TransitionFaults;
    DWORD                       CacheFaults;
    DWORD                       DemandZeroFaults;
    DWORD                       Pages;
    DWORD                       PagesInput;
    DWORD                       PageReads;
    DWORD                       DirtyPages;
    LONGLONG                    PagedPool;
    LONGLONG                    NonPagedPool;
    DWORD                       DirtyWrites;
    DWORD                       PagedPoolAllocs;
    DWORD                       NonPagedPoolAllocs;
    DWORD                       FreeSystemPtes;
    LONGLONG                    CacheBytes;
    LONGLONG                    PeakCacheBytes;
    LONGLONG                    ResidentPagedPoolBytes;
    LONGLONG                    TotalSysCodeBytes;
    LONGLONG                    ResidentSysCodeBytes;
    LONGLONG                    TotalSysDriverBytes;
    LONGLONG                    ResidentSysDriverBytes;
    LONGLONG                    ResidentSysCacheBytes;
    DWORD                       CommitBytesInUse;
    DWORD                       CommitBytesLimit;
    LONGLONG                    AvailableKBytes;
    LONGLONG                    AvailableMBytes;
    DWORD                       TransitionRePurpose;
    DWORD                       Reserved1;      // padding
//    LONGLONG                    SystemVlmCommitCharge;
//    LONGLONG                    SystemVlmPeakCommitCharge;
//    LONGLONG                    SystemVlmSharedCommitCharge;
} MEMORY_COUNTER_DATA, *PMEMORY_COUNTER_DATA;

extern MEMORY_DATA_DEFINITION MemoryDataDefinition;

#endif //_DATAMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datacpu.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datacpu.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Processor Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datacpu.h"

//
//  Constant structure initializations 
//      defined in datacpu.h
//

PROCESSOR_DATA_DEFINITION ProcessorDataDefinition = {
    {   0,
        sizeof(PROCESSOR_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        PROCESSOR_OBJECT_TITLE_INDEX,
        0,
        239,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(PROCESSOR_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        7,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER_INV,
        RTL_FIELD_SIZE(PROCESSOR_COUNTER_DATA, ProcessorTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        143,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(PROCESSOR_COUNTER_DATA, UserTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        145,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(PROCESSOR_COUNTER_DATA, KernelTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        148,
        0,
        149,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(PROCESSOR_COUNTER_DATA, Interrupts),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->Interrupts
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        696,
        0,
        339,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(PROCESSOR_COUNTER_DATA, DpcTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->DpcTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        698,
        0,
        397,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(PROCESSOR_COUNTER_DATA, InterruptTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->InterruptTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1334,
        0,
        1335,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(PROCESSOR_COUNTER_DATA, DpcCountRate),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->DpcCountRate
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1336,
        0,
        1337,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(PROCESSOR_COUNTER_DATA, DpcRate),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->DpcRate
    },
};

//
//  Constant structure initializations 
//      defined in datacpu.h
//

EX_PROCESSOR_DATA_DEFINITION ExProcessorDataDefinition = {
    {   0,
        sizeof(EX_PROCESSOR_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        PROCESSOR_OBJECT_TITLE_INDEX,
        0,
        239,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(EX_PROCESSOR_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        7,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER_INV,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, ProcessorTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        143,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, UserTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        145,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, KernelTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        148,
        0,
        149,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, Interrupts),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->Interrupts
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        696,
        0,
        339,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, DpcTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->DpcTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        698,
        0,
        397,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, InterruptTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->InterruptTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1334,
        0,
        1335,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, DpcCountRate),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->DpcCountRate
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1336,
        0,
        1337,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, DpcRate),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->DpcRate
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1746,
        0,
        1747,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, IdleTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->IdleTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1748,
        0,
        1749,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, C1Time),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C1Time
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1750,
        0,
        1751,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, C2Time),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C2Time
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1752,
        0,
        1753,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_100NSEC_TIMER,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, C3Time),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C3Time
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1754,
        0,
        1755,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, C1Transitions),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C1Transitions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1756,
        0,
        1757,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, C2Transitions),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C2Transitions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1758,
        0,
        1759,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        RTL_FIELD_SIZE(EX_PROCESSOR_COUNTER_DATA, C3Transitions),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C3Transitions
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datamem.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datamem.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Memory performance data objects

Created:

    Bob Watson  20-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datamem.h"

//
//  Constant structure initializations 
//      defined in datagen.h
//
MEMORY_DATA_DEFINITION MemoryDataDefinition = {
    {   sizeof(MEMORY_DATA_DEFINITION) + sizeof(MEMORY_COUNTER_DATA),
        sizeof(MEMORY_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        MEMORY_OBJECT_TITLE_INDEX,
        0,
        5,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(MEMORY_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        8,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        28,
        0,
        29,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, PageFaults),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PageFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        24,
        0,
        25,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, AvailablePages),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->AvailablePages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        26,
        0,
        27,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, CommittedPages),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CommittedPages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        30,
        0,
        31,
        0,
        -6,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, CommitList),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CommitList
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        32,
        0,
        33,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, WriteCopies),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->WriteCopies
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        34,
        0,
        35,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, TransitionFaults),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->TransitionFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        36,
        0,
        37,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, CacheFaults),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CacheFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        38,
        0,
        39,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, DemandZeroFaults),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->DemandZeroFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        40,
        0,
        41,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, Pages),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->Pages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
	822,
        0,
        823,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, PagesInput),
	(DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PagesInput
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        42,
        0,
        43,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, PageReads),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PageReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        48,
        0,
        49,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, DirtyPages),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->DirtyPages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        57,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, PagedPool),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        59,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, NonPagedPool),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->NonPagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        50,
        0,
        51,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, DirtyWrites),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->DirtyWrites
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        60,
        0,
        61,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, PagedPoolAllocs),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PagedPoolAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        64,
        0,
        65,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, NonPagedPoolAllocs),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->NonPagedPoolAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        678,
        0,
        679,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, FreeSystemPtes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->FreeSystemPtes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        818,
        0,
        819,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, CacheBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CacheBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        820,
        0,
        821,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, PeakCacheBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PeakCacheBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        66,
        0,
        63,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, ResidentPagedPoolBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->ResidentPagedPoolBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        68,
        0,
        69,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, TotalSysCodeBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->TotalSysCodeBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        70,
        0,
        71,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, ResidentSysCodeBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->ResidentSysCodeBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        72,
        0,
        73,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, TotalSysDriverBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->TotalSysDriverBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        74,
        0,
        75,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, ResidentSysDriverBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->ResidentSysDriverBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        76,
        0,
        77,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, ResidentSysCacheBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->ResidentSysCacheBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1406,
        0,
        1407,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_RAW_FRACTION,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, CommitBytesInUse),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CommitBytesInUse
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1406,
        0,
        1407,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_RAW_BASE,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, CommitBytesLimit),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CommitBytesLimit
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1380,
        0,
        1381,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, AvailableKBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->AvailableKBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1382,
        0,
        1383,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, AvailableMBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->AvailableMBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        824,
        0,
        825,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, TransitionRePurpose),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->TransitionRePurpose
#if 0 	// these are no longer supported
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1374,
        0,
        1375,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, SystemVlmCommitCharge),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->SystemVlmCommitCharge
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1376,
        0,
        1377,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, SystemVlmPeakCommitCharge),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->SystemVlmPeakCommitCharge
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1378,
        0,
        1379,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        RTL_FIELD_SIZE(MEMORY_COUNTER_DATA, SystemVlmSharedCommitCharge),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->SystemVlmSharedCommitCharge
#endif
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\dataobj.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataobj.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the OS Object performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataobj.h"

//
//  Constant structure initializations 
//      defined in dataobj.h
//
OBJECTS_DATA_DEFINITION ObjectsDataDefinition = {

    {   sizeof(OBJECTS_DATA_DEFINITION) + sizeof(OBJECTS_COUNTER_DATA),
        sizeof(OBJECTS_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        OBJECT_OBJECT_TITLE_INDEX,
        0,
        261,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(OBJECTS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        248,
        0,
        249,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(OBJECTS_COUNTER_DATA, Processes),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Processes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        250,
        0,
        251,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(OBJECTS_COUNTER_DATA, Threads),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Threads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        252,
        0,
        253,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(OBJECTS_COUNTER_DATA, Events),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Events
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        254,
        0,
        255,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(OBJECTS_COUNTER_DATA, Semaphores),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Semaphores
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        256,
        0,
        257,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(OBJECTS_COUNTER_DATA, Mutexes),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Mutexes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        258,
        0,
        259,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(OBJECTS_COUNTER_DATA, Sections),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Sections
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\dataos.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAOS.h

Abstract:

    Header file for the Windows NT Operating System Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAOS_H_
#define _DATAOS_H_

#include "datasys.h"
#include "datacpu.h"
#include "datamem.h"
#include "datacach.h"
#include "dataobj.h"
#include "datapage.h"
#endif //_DATAOS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\dataobj.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAOBJ.h

Abstract:

    Header file for the Windows NT OS Objects Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
//  Objects Performance Data Object
//

typedef struct _OBJECTS_DATA_DEFINITION {
    PERF_OBJECT_TYPE            ObjectsObjectType;
    PERF_COUNTER_DEFINITION     cdProcesses;
    PERF_COUNTER_DEFINITION     cdThreads;
    PERF_COUNTER_DEFINITION     cdEvents;
    PERF_COUNTER_DEFINITION     cdSemaphores;
    PERF_COUNTER_DEFINITION     cdMutexes;
    PERF_COUNTER_DEFINITION     cdSections;
} OBJECTS_DATA_DEFINITION, * POBJECTS_DATA_DEFINITION;

typedef struct _OBJECTS_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                       Processes;
    DWORD                       Threads;
    DWORD                       Events;
    DWORD                       Semaphores;
    DWORD                       Mutexes;
    DWORD                       Sections;
    DWORD                       Reserved1;
} OBJECTS_COUNTER_DATA, * POBJECTS_COUNTER_DATA;


extern OBJECTS_DATA_DEFINITION ObjectsDataDefinition;

#endif // _DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datapage.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datapage.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Page file performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datapage.h"

// dummy variable for field sizing.
static PAGEFILE_COUNTER_DATA    pcd;

//
//  Constant structure initializations 
//      defined in datapage.h
//

PAGEFILE_DATA_DEFINITION  PagefileDataDefinition = {
    {   sizeof (PAGEFILE_DATA_DEFINITION) +  sizeof(PAGEFILE_COUNTER_DATA),
        sizeof (PAGEFILE_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        PAGEFILE_OBJECT_TITLE_INDEX,
        0,
        701,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(PAGEFILE_DATA_DEFINITION) - sizeof (PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof (PERF_COUNTER_DEFINITION),
        702,
        0,
        703,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        RTL_FIELD_SIZE (PAGEFILE_COUNTER_DATA, PercentInUse),
        (DWORD)(ULONG_PTR)&((PPAGEFILE_COUNTER_DATA)0)->PercentInUse
    },
    {   sizeof (PERF_COUNTER_DEFINITION),
        702,
        0,
        703,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        RTL_FIELD_SIZE (PAGEFILE_COUNTER_DATA, PercentInUseBase),
        (DWORD)(ULONG_PTR)&((PPAGEFILE_COUNTER_DATA)0)->PercentInUseBase
    },
    {   sizeof (PERF_COUNTER_DEFINITION),
        704,
        0,
        705,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        RTL_FIELD_SIZE (PAGEFILE_COUNTER_DATA, PeakUsage),
        (DWORD)(ULONG_PTR)&((PPAGEFILE_COUNTER_DATA)0)->PeakUsage
    },
    {   sizeof (PERF_COUNTER_DEFINITION),
        704,
        0,
        705,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        RTL_FIELD_SIZE (PAGEFILE_COUNTER_DATA, PeakUsageBase),
        (DWORD)(ULONG_PTR)&((PPAGEFILE_COUNTER_DATA)0)->PeakUsageBase
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datapage.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAPAGE.h

Abstract:

    Header file for the Windows NT Operating System Pagefile
    Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAPAGE_H_
#define _DATAPAGE_H_

//
//  Pagefile performance object
//

typedef struct _PAGEFILE_DATA_DEFINITION {
    PERF_OBJECT_TYPE        PagefileObjectType;
    PERF_COUNTER_DEFINITION cdPercentInUse;
    PERF_COUNTER_DEFINITION cdPercentInUseBase;
    PERF_COUNTER_DEFINITION cdPeakUsage;
    PERF_COUNTER_DEFINITION cdPeakUsageBase;
} PAGEFILE_DATA_DEFINITION, * PPAGEFILE_DATA_DEFINITION;

typedef struct _PAGEFILE_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                       PercentInUse;
    DWORD                       PercentInUseBase;
    DWORD                       PeakUsage;
    DWORD                       PeakUsageBase;
    DWORD                       Reserved1;
} PAGEFILE_COUNTER_DATA, *PPAGEFILE_COUNTER_DATA;

extern PAGEFILE_DATA_DEFINITION  PagefileDataDefinition;

#endif //_DATAPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datasys.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datasys.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Operating System performance data objects

    This file contains a set of constant data structures which are
    currently defined for the Signal Generator Perf DLL.

Created:

    Bob Watson  20-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datasys.h"

//
//  Constant structure initializations 
//      defined in datasys.h
//

SYSTEM_DATA_DEFINITION SystemDataDefinition = {
    {   sizeof(SYSTEM_DATA_DEFINITION) + sizeof(SYSTEM_COUNTER_DATA),
        sizeof(SYSTEM_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        SYSTEM_OBJECT_TITLE_INDEX,
        0,
        3,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(SYSTEM_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
         sizeof(PERF_COUNTER_DEFINITION),
        8,       // Default: TOTAL_PROCESSOR_TIME
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        10,
        0,
        11,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, ReadOperations),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ReadOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        12,
        0,
        13,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, WriteOperations),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->WriteOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        14,
        0,
        15,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, OtherIOOperations),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->OtherIOOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        16,
        0,
        17,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, ReadBytes),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        18,
        0,
        19,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, WriteBytes),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->WriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        20,
        0,
        21,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, OtherIOBytes),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->OtherIOBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        146,
        0,
        147,
        0,
        -2,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, ContextSwitches),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ContextSwitches
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        150,
        0,
        151,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, SystemCalls),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->SystemCalls
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        406,
        0,
        407,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, TotalReadWrites),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->TotalReadWrites
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        674,
        0,
        675,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_ELAPSED_TIME,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, SystemElapsedTime),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->SystemElapsedTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        44,
        0,
        45,
        0,
        1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, ProcessorQueueLength),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ProcessorQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        248,
        0,
        249,
        0,
        1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, ProcessCount),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ProcessCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        250,
        0,
        251,
        0,
        1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, ThreadCount),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ThreadCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        686,
        0,
        687,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, AlignmentFixups),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->AlignmentFixups
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        688,
        0,
        689,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, ExceptionDispatches),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ExceptionDispatches
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        690,
        0,
        691,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, FloatingPointEmulations),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->FloatingPointEmulations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1350,
        0,
        1351,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, RegistryQuotaUsed),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->RegistryQuotaUsed
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1350,
        0,
        1351,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        RTL_FIELD_SIZE(SYSTEM_COUNTER_DATA, RegistryQuotaAllowed),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->RegistryQuotaAllowed
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\perfcach.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfcach.c

Abstract:

    This file implements an Performance Object that presents
    File System Cache data

Created:    

    Bob Watson  22-Oct-1996

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include <assert.h>
#include "perfos.h"
#include "datacach.h"

//
//  The following special defines are used to produce numbers for
//  cache measurement counters
//

#define SYNC_ASYNC(FLD) ((SysPerfInfo.FLD##Wait) + (SysPerfInfo.FLD##NoWait))

//
// Hit Rate Macro
//
#define HITRATE(FLD) (((Changes = SysPerfInfo.FLD) == 0) ? 0 :                                         \
                      ((Changes < (Misses = SysPerfInfo.FLD##Miss)) ? 0 :                              \
                      (Changes - Misses) ))

//
// Hit Rate Macro combining Sync and Async cases
//

#define SYNC_ASYNC_HITRATE(FLD) (((Changes = SYNC_ASYNC(FLD)) == 0) ? 0 : \
                                   ((Changes < \
                                    (Misses = SysPerfInfo.FLD##WaitMiss + \
                                              SysPerfInfo.FLD##NoWaitMiss) \
                                   ) ? 0 : \
                                  (Changes - Misses) ))


DWORD APIENTRY
CollectCacheObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the XXX object

Arguments:

        IN OUT   LPVOID   *lppData
                IN: pointer to the address of the buffer to receive the completed
                    PerfDataBlock and subordinate structures. This routine will
                    append its data to the buffer starting at the point referenced
                    by *lppData.
                OUT: points to the first byte after the data structure added by this
                    routine. This routine updated the value at lppdata after appending
                    its data.

        IN OUT   LPDWORD  lpcbTotalBytes
                IN: the address of the DWORD that tells the size in bytes of the
                    buffer referenced by the lppData argument
                OUT: the number of bytes added by this routine is writted to the
                    DWORD pointed to by this argument

        IN OUT   LPDWORD  NumObjectTypes
                IN: the address of the DWORD to receive the number of objects added
                    by this routine
                OUT: the number of objects added by this routine is writted to the
                    DWORD pointed to by this argument

         Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block
    DWORD  Changes;             //  Used by macros to compute cache
    DWORD  Misses;              //  ...statistics

    PCACHE_DATA_DEFINITION  pCacheDataDefinition;
    PCACHE_COUNTER_DATA     pCCD;

    //
    //  Check for enough space for cache data block
    //

    pCacheDataDefinition = (CACHE_DATA_DEFINITION *) *lppData;

    TotalLen = sizeof(CACHE_DATA_DEFINITION) +
                sizeof(CACHE_COUNTER_DATA);

    TotalLen = QWORD_MULTIPLE(TotalLen);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define cache data block
    //


    memcpy (pCacheDataDefinition,
        &CacheDataDefinition,
        sizeof(CACHE_DATA_DEFINITION));

    //
    //  Format and collect memory data
    //

    pCCD = (PCACHE_COUNTER_DATA)&pCacheDataDefinition[1];

    // No need to align this since it is the only counter block
    // and the total byte will be aligned.
    pCCD->CounterBlock.ByteLength = sizeof(CACHE_COUNTER_DATA);

    //
    //  The Data Map counter is the sum of the Wait/NoWait cases
    //

    pCCD->DataMaps = SYNC_ASYNC(CcMapData);

    pCCD->SyncDataMaps = SysPerfInfo.CcMapDataWait;
    pCCD->AsyncDataMaps = SysPerfInfo.CcMapDataNoWait;

    //
    //  The Data Map Hits is a percentage of Data Maps that hit
    //  the cache; second counter is the base (divisor)
    //

    pCCD->DataMapHits = SYNC_ASYNC_HITRATE(CcMapData);
    pCCD->DataMapHitsBase = SYNC_ASYNC(CcMapData);

    //
    //  The next pair of counters forms a percentage of
    //  Pins as a portion of Data Maps
    //

    pCCD->DataMapPins = SysPerfInfo.CcPinMappedDataCount;
    pCCD->DataMapPinsBase = SYNC_ASYNC(CcMapData);

    pCCD->PinReads = SYNC_ASYNC(CcPinRead);
    pCCD->SyncPinReads = SysPerfInfo.CcPinReadWait;
    pCCD->AsyncPinReads = SysPerfInfo.CcPinReadNoWait;

    //
    //  The Pin Read Hits is a percentage of Pin Reads that hit
    //  the cache; second counter is the base (divisor)
    //

    pCCD->PinReadHits = SYNC_ASYNC_HITRATE(CcPinRead);
    pCCD->PinReadHitsBase = SYNC_ASYNC(CcPinRead);


    pCCD->CopyReads = SYNC_ASYNC(CcCopyRead);
    pCCD->SyncCopyReads = SysPerfInfo.CcCopyReadWait;
    pCCD->AsyncCopyReads = SysPerfInfo.CcCopyReadNoWait;

    //
    //  The Copy Read Hits is a percentage of Copy Reads that hit
    //  the cache; second counter is the base (divisor)
    //

    pCCD->CopyReadHits = SYNC_ASYNC_HITRATE(CcCopyRead);
    pCCD->CopyReadHitsBase = SYNC_ASYNC(CcCopyRead);


    pCCD->MdlReads = SYNC_ASYNC(CcMdlRead);
    pCCD->SyncMdlReads = SysPerfInfo.CcMdlReadWait;
    pCCD->AsyncMdlReads = SysPerfInfo.CcMdlReadNoWait;

    //
    //  The Mdl Read Hits is a percentage of Mdl Reads that hit
    //  the cache; second counter is the base (divisor)
    //

    pCCD->MdlReadHits = SYNC_ASYNC_HITRATE(CcMdlRead);
    pCCD->MdlReadHitsBase = SYNC_ASYNC(CcMdlRead);

    pCCD->ReadAheads = SysPerfInfo.CcReadAheadIos;

    pCCD->FastReads = SYNC_ASYNC(CcFastRead);
    pCCD->SyncFastReads = SysPerfInfo.CcFastReadWait;
    pCCD->AsyncFastReads = SysPerfInfo.CcFastReadNoWait;

    pCCD->FastReadResourceMiss = SysPerfInfo.CcFastReadResourceMiss;
    pCCD->FastReadNotPossibles = SysPerfInfo.CcFastReadNotPossible;
    pCCD->LazyWriteFlushes = SysPerfInfo.CcLazyWriteIos;
    pCCD->LazyWritePages = SysPerfInfo.CcLazyWritePages;
    pCCD->DataFlushes = SysPerfInfo.CcDataFlushes;
    pCCD->DataPages = SysPerfInfo.CcDataPages;

    *lpcbTotalBytes =
        pCacheDataDefinition->CacheObjectType.TotalByteLength =
            (DWORD) QWORD_MULTIPLE(((LPBYTE) (& pCCD[1])) - (LPBYTE) pCacheDataDefinition);
    * lppData = (LPVOID) (((LPBYTE) pCacheDataDefinition) + * lpcbTotalBytes);
    assert(*lpcbTotalBytes == TotalLen);

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\datasys.h ===
/*++ 

Copyright (c) 1995-6 Microsoft Corporation

Module Name:

      DATASYS.h

Abstract:

    Header file for the Windows NT Operating System Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATASYS_H_
#define _DATASYS_H_

//
//  System data object
//

typedef struct _SYSTEM_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    SystemObjectType;
    PERF_COUNTER_DEFINITION     cdReadOperations;
    PERF_COUNTER_DEFINITION     cdWriteOperations;
    PERF_COUNTER_DEFINITION     cdOtherIOOperations;
    PERF_COUNTER_DEFINITION     cdReadBytes;
    PERF_COUNTER_DEFINITION     cdWriteBytes;
    PERF_COUNTER_DEFINITION     cdOtherIOBytes;
    PERF_COUNTER_DEFINITION     cdContextSwitches;
    PERF_COUNTER_DEFINITION     cdSystemCalls;
    PERF_COUNTER_DEFINITION     cdTotalReadWrites;
    PERF_COUNTER_DEFINITION     cdSystemElapsedTime;
    PERF_COUNTER_DEFINITION     cdProcessorQueueLength;
    PERF_COUNTER_DEFINITION     cdProcessCount;
    PERF_COUNTER_DEFINITION     cdThreadCount;
    PERF_COUNTER_DEFINITION     cdAlignmentFixups;
    PERF_COUNTER_DEFINITION     cdExceptionDispatches;
    PERF_COUNTER_DEFINITION     cdFloatingPointEmulations;
    PERF_COUNTER_DEFINITION     cdRegistryQuotaUsed;
    PERF_COUNTER_DEFINITION     cdRegistryQuotaAllowed;
} SYSTEM_DATA_DEFINITION, * PSYSTEM_DATA_DEFINITION;

typedef struct _SYSTEM_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                       ReadOperations;
    DWORD                       WriteOperations; 
    DWORD                       OtherIOOperations;
    LONGLONG                    ReadBytes;
    LONGLONG                    WriteBytes;
    LONGLONG                    OtherIOBytes;
    DWORD                       ContextSwitches;
    DWORD                       SystemCalls;
    DWORD                       TotalReadWrites;
    DWORD                       Reserved1;
    LONGLONG                    SystemElapsedTime;
    DWORD                       ProcessorQueueLength;
    DWORD                       ProcessCount;
    DWORD                       ThreadCount;
    DWORD                       AlignmentFixups;
    DWORD                       ExceptionDispatches;
    DWORD                       FloatingPointEmulations;
    DWORD                       RegistryQuotaUsed;
    DWORD                       RegistryQuotaAllowed;
} SYSTEM_COUNTER_DATA, * PSYSTEM_COUNTER_DATA;

extern SYSTEM_DATA_DEFINITION SystemDataDefinition;

#endif // _DATASYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\perfobj.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfobj.c

Abstract:

    This file implements an Performance Object that presents
    System Object Performance Counters

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include <stdio.h>
#include "perfos.h"
#include "perfosmc.h"
#include "dataobj.h"

DWORD   dwObjOpenCount = 0;        // count of "Open" threads

// variables local to this module.

HANDLE hEvent = NULL;
HANDLE hMutex = NULL;
HANDLE hSemaphore = NULL;
HANDLE hSection = NULL;


DWORD APIENTRY
OpenObjectsObject (
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/

{
    DWORD   status = ERROR_SUCCESS;
	LONG_PTR	TempHandle = -1;
    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    UNREFERENCED_PARAMETER (lpDeviceNames);

    if (dwObjOpenCount == 0) {
        // open Eventlog interface

        hEvent = CreateEvent(NULL,TRUE,TRUE,NULL);
        hSemaphore = CreateSemaphore(NULL,1,256,NULL);
        hMutex = CreateMutex(NULL,FALSE,NULL);
        hSection = CreateFileMapping((HANDLE)TempHandle,NULL,PAGE_READWRITE,0,8192,NULL);
    }

    dwObjOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

    return status;
}


DWORD APIENTRY
CollectObjectsObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the system objects object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block

    NTSTATUS    status;

    POBJECTS_DATA_DEFINITION    pObjectsDataDefinition;
    POBJECTS_COUNTER_DATA       pOCD;

    POBJECT_TYPE_INFORMATION ObjectInfo;
    WCHAR Buffer[ 256 ];

#ifdef DBG
    STARTTIMING;
#endif

    //
    //  Check for sufficient space for objects data
    //

    pObjectsDataDefinition = (OBJECTS_DATA_DEFINITION *) *lppData;

    TotalLen = sizeof(OBJECTS_DATA_DEFINITION) +
                sizeof (OBJECTS_COUNTER_DATA);

    TotalLen = QWORD_MULTIPLE (TotalLen);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define objects data block
    //

    memcpy (pObjectsDataDefinition,
        &ObjectsDataDefinition,
        sizeof(OBJECTS_DATA_DEFINITION));

    //
    //  Format and collect objects data
    //

    pOCD = (POBJECTS_COUNTER_DATA)&pObjectsDataDefinition[1];

    pOCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (OBJECTS_COUNTER_DATA));

    ObjectInfo = (POBJECT_TYPE_INFORMATION)Buffer;
    status = NtQueryObject( NtCurrentProcess(),
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Processes = ObjectInfo->TotalNumberOfObjects;
    } else {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_PROCESS_OBJECT_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }

        pOCD->Processes = 0;
    }

#ifdef DBG
    ENDTIMING (("PERFOBJ: %d takes %I64u ms\n", __LINE__, diff));
#endif

    status = NtQueryObject( NtCurrentThread(),
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Threads = ObjectInfo->TotalNumberOfObjects;
    } else {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_THREAD_OBJECT_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }

        pOCD->Threads = 0;
    }

#ifdef DBG
    ENDTIMING (("PERFOBJ: %d takes %I64u ms\n", __LINE__, diff));
#endif

    status = NtQueryObject( hEvent,
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Events = ObjectInfo->TotalNumberOfObjects;
    } else {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_EVENT_OBJECT_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }

        pOCD->Events = 0;
    }

#ifdef DBG
    ENDTIMING (("PERFOBJ: %d takes %I64u ms\n", __LINE__, diff));
#endif

    status = NtQueryObject( hSemaphore,
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Semaphores = ObjectInfo->TotalNumberOfObjects;
    } else {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_SEMAPHORE_OBJECT_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }

        pOCD->Semaphores = 0;
    }

#ifdef DBG
    ENDTIMING (("PERFOBJ: %d takes %I64u ms\n", __LINE__, diff));
#endif

    status = NtQueryObject( hMutex,
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Mutexes = ObjectInfo->TotalNumberOfObjects;
    } else {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_MUTEX_OBJECT_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }

        pOCD->Mutexes = 0;
    }

#ifdef DBG
    ENDTIMING (("PERFOBJ: %d takes %I64u ms\n", __LINE__, diff));
#endif

    status = NtQueryObject( hSection,
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Sections = ObjectInfo->TotalNumberOfObjects;
    } else {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_SECTION_OBJECT_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }

        pOCD->Sections = 0;
    }

    *lpcbTotalBytes =
        pObjectsDataDefinition->ObjectsObjectType.TotalByteLength =
            (DWORD) QWORD_MULTIPLE(((LPBYTE) (& pOCD[1])) -
                                   (LPBYTE) pObjectsDataDefinition);
    * lppData = (LPVOID) (((LPBYTE) pObjectsDataDefinition) + * lpcbTotalBytes);

    *lpNumObjectTypes = 1;

#ifdef DBG
    ENDTIMING (("PERFOBJ: %d takes %I64u ms\n", __LINE__, diff));
#endif
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseObjectsObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (dwObjOpenCount > 0) {
        dwObjOpenCount--;
        if (dwObjOpenCount == 0) { // when this is the last thread...
            // close stuff here
            if (hEvent != NULL) {
                CloseHandle(hEvent);
                hEvent = NULL;
            }

            if (hMutex != NULL) {
                CloseHandle(hMutex);
                hMutex = NULL;
            }

            if (hSemaphore != NULL) {
                CloseHandle(hSemaphore);
                hSemaphore = NULL;
            }
            
            if (hSection != NULL) {
                CloseHandle(hSection);
                hSection = NULL;
            }
        }
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\perfos.h ===
extern  HANDLE                          hEventLog;       // handle to event log
extern  HANDLE                          hLibHeap;       // dll heap
extern  SYSTEM_BASIC_INFORMATION        BasicInfo;
extern  SYSTEM_PERFORMANCE_INFORMATION  SysPerfInfo;

extern  LPWSTR  wszTotal;

extern  DWORD   dwObjOpenCount;
extern  DWORD   dwCpuOpenCount;
extern  DWORD   dwPageOpenCount;

// perfos.c
PM_QUERY_PROC   QueryOsObjectData;

//  perfcach.c
PM_LOCAL_COLLECT_PROC CollectCacheObjectData;

//  perfcpu.c
PM_OPEN_PROC    OpenProcessorObject;
PM_LOCAL_COLLECT_PROC CollectProcessorObjectData;
PM_CLOSE_PROC   CloseProcessorObject;

//  perfmem.c
PM_LOCAL_COLLECT_PROC CollectMemoryObjectData;

//  perfobj.c
PM_OPEN_PROC    OpenObjectsObject;
PM_LOCAL_COLLECT_PROC CollectObjectsObjectData;
PM_CLOSE_PROC   CloseObjectsObject;

//  perfpage.c
PM_OPEN_PROC    OpenPageFileObject;
PM_LOCAL_COLLECT_PROC CollectPageFileObjectData;
PM_CLOSE_PROC   ClosePageFileObject;

//  perfsys.c
PM_OPEN_PROC OpenSystemObject;
PM_LOCAL_COLLECT_PROC CollectSystemObjectData;
PM_CLOSE_PROC CloseSystemObject;

#ifdef DBG
extern LONG64 clock0, clock1, freq, diff;
#define TIME_LIMIT    (LONG64) 250     // 250 msec
#define STARTTIMING   NtQueryPerformanceCounter((PLARGE_INTEGER) &clock0, NULL)
#define ENDTIMING(x)  NtQueryPerformanceCounter((PLARGE_INTEGER) &clock1, (PLARGE_INTEGER) &freq);\
                      diff = (clock1 - clock0) / (freq / 1000); \
                      if (diff > TIME_LIMIT) DbgPrint x ;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\perfcpu.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfcpu.c

Abstract:

    This file implements an Performance Object that presents
    System Processor performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/

//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"
#include "datacpu.h"

DWORD   dwCpuOpenCount = 0;        // count of "Open" threads

// variables local to this module.
SYSTEM_INTERRUPT_INFORMATION            *pProcessorInterruptInformation = NULL;
DWORD dwInterruptInfoBufferSize = 0;

SYSTEM_PROCESSOR_IDLE_INFORMATION       *pProcessorIdleInformation = NULL;
DWORD  dwProcessorIdleBufferSize = 0;

UCHAR *pProcessorBuffer = NULL;
ULONG ProcessorBufSize = 0;

BOOL    bPerfCpuUseIdleData = FALSE;
BOOL    bPerfCpuIdleDataTested = FALSE;


DWORD APIENTRY
OpenProcessorObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    UNREFERENCED_PARAMETER (lpDeviceNames);
    
    if (!dwCpuOpenCount) {
        dwInterruptInfoBufferSize = (ULONG)BasicInfo.NumberOfProcessors *
            sizeof (SYSTEM_INTERRUPT_INFORMATION);

        pProcessorInterruptInformation = ALLOCMEM (dwInterruptInfoBufferSize);

        if (pProcessorInterruptInformation == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto OpenExitPoint;
        }

        ProcessorBufSize = BasicInfo.NumberOfProcessors *
                 sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);

        pProcessorBuffer = ALLOCMEM(ProcessorBufSize);
        if (pProcessorBuffer == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto OpenExitPoint;
        }

        dwProcessorIdleBufferSize = BasicInfo.NumberOfProcessors *
                sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION);

        pProcessorIdleInformation = ALLOCMEM(dwProcessorIdleBufferSize);
        if (pProcessorIdleInformation == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto OpenExitPoint;
        }

    }
    dwCpuOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:
    if (status == ERROR_OUTOFMEMORY) {
        if (pProcessorInterruptInformation) {
            FREEMEM (pProcessorInterruptInformation);
            pProcessorInterruptInformation = NULL;
        }
        if (pProcessorBuffer) {
            FREEMEM (pProcessorBuffer);
            pProcessorBuffer = NULL;
        }
        dwInterruptInfoBufferSize = 0;
        ProcessorBufSize = 0;
        dwProcessorIdleBufferSize = 0;
    }

    return status;
}

DWORD APIENTRY
CollectProcessorObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;
    DWORD   TotalLen;            //  Length of the total return block

    DWORD   dwBufferSize;
    DWORD   dwReturnedBufferSize = 0;

    PPROCESSOR_DATA_DEFINITION  pProcessorDataDefinition = NULL;
    PPROCESSOR_COUNTER_DATA     pPCD;
    PEX_PROCESSOR_DATA_DEFINITION  pExProcessorDataDefinition = NULL;
    PEX_PROCESSOR_COUNTER_DATA     pExPCD;

    PROCESSOR_COUNTER_DATA      pcdTotalData;
    EX_PROCESSOR_COUNTER_DATA   pexcdTotalData;

    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;

    ULONG CurProc;

    UNICODE_STRING ProcessorName;
    WCHAR ProcessorNameBuffer[512];

    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *pProcessorInformation = NULL;
    SYSTEM_PROCESSOR_IDLE_INFORMATION        *pProcIdleInformation = NULL;
    
    SYSTEM_INTERRUPT_INFORMATION *pThisProcessorInterruptInformation = NULL;
    NTSTATUS    ntStatus;

    //
    //  Check for sufficient space for processor data
    //

#ifdef DBG
    STARTTIMING;
#endif
    // check for QUADWORD alignment of incoming pointer
    assert (((ULONG_PTR)(*lppData) & 0x00000007) == 0);

    if (!bPerfCpuIdleDataTested) {
        // call this function once to see if this info is available from the system
        //
        // get system idle information by processor
        //
        dwBufferSize = dwProcessorIdleBufferSize;

        ntStatus = NtQuerySystemInformation(
            SystemProcessorIdleInformation,
            pProcessorIdleInformation,
            dwBufferSize,
            &dwReturnedBufferSize
        );

        if (NT_SUCCESS(ntStatus)) {
            bPerfCpuUseIdleData = TRUE;
        } else {
            memset (pProcessorIdleInformation, 0, dwProcessorIdleBufferSize);
        }
        
        bPerfCpuIdleDataTested = TRUE;
    }

    if (bPerfCpuUseIdleData) {
        pExProcessorDataDefinition = (EX_PROCESSOR_DATA_DEFINITION *) *lppData;

        TotalLen =
            sizeof(EX_PROCESSOR_DATA_DEFINITION) +     // object def header
            ((sizeof (PERF_INSTANCE_DEFINITION) +   // plus an instance for
                ((MAX_INSTANCE_NAME + 1) * sizeof(WCHAR)) +
                sizeof (PROCESSOR_COUNTER_DATA)) *     // each processor and
                (BasicInfo.NumberOfProcessors + 1)); // the "total" instance
        TotalLen = QWORD_MULTIPLE(TotalLen);

        if ( *lpcbTotalBytes < TotalLen ) {
            lReturn = ERROR_MORE_DATA;
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            goto COLLECT_BAIL_OUT;
        }
    } else {
        pProcessorDataDefinition = (PROCESSOR_DATA_DEFINITION *) *lppData;

        TotalLen =
            sizeof(PROCESSOR_DATA_DEFINITION) +     // object def header
            ((sizeof (PERF_INSTANCE_DEFINITION) +   // plus an instance for
                ((MAX_INSTANCE_NAME + 1) * sizeof(WCHAR)) +
                sizeof (PROCESSOR_COUNTER_DATA)) *     // each processor and
                (BasicInfo.NumberOfProcessors + 1)); // the "total" instance

        if ( *lpcbTotalBytes < TotalLen ) {
            lReturn = ERROR_MORE_DATA;
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            goto COLLECT_BAIL_OUT;
        }
    }
    //
    // Get processor data from system
    //

    if ( ProcessorBufSize ) {
        ntStatus = NtQuerySystemInformation(
            SystemProcessorPerformanceInformation,
            pProcessorBuffer,
            ProcessorBufSize,
            &dwReturnedBufferSize
            );

        if (!NT_SUCCESS(ntStatus) && (hEventLog != NULL)) {
            // clear buffer & log error
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_PROCSSOR_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&ntStatus);

            memset (pProcessorBuffer, 0, ProcessorBufSize);
        }
#ifdef DBG
        ENDTIMING (("PERFCPU: %d takes %I64u ms\n", __LINE__, diff));
#endif
    }

    //
    // get system interrupt information by processor
    //
    dwInterruptInfoBufferSize = (ULONG)BasicInfo.NumberOfProcessors *
        sizeof (SYSTEM_INTERRUPT_INFORMATION);

    ntStatus = NtQuerySystemInformation(
        SystemInterruptInformation,
        pProcessorInterruptInformation,
        dwInterruptInfoBufferSize,
        &dwReturnedBufferSize
    );

    if (!NT_SUCCESS(ntStatus) && (hEventLog != NULL)) {
        // clear buffer & log error
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_INTERRUPT_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&ntStatus);

        memset (pProcessorInterruptInformation, 0,
                    (BasicInfo.NumberOfProcessors *
                    sizeof (SYSTEM_INTERRUPT_INFORMATION)));
    }
#ifdef DBG
    ENDTIMING (("PERFCPU: %d takes %I64u ms\n", __LINE__, diff));
#endif

    if (bPerfCpuUseIdleData) {
        //
        // get system idle information by processor
        //
        dwBufferSize = dwProcessorIdleBufferSize;

        ntStatus = NtQuerySystemInformation(
            SystemProcessorIdleInformation,
            pProcessorIdleInformation,
            dwBufferSize,
            &dwReturnedBufferSize
        );

        if (!NT_SUCCESS(ntStatus) && (hEventLog != NULL)) {
            // it worked once before or this flag wouldn't be set
            // so report the error.
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_IDLE_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&ntStatus);

            memset (pProcessorIdleInformation, 0, dwProcessorIdleBufferSize);
        }

#ifdef DBG
    ENDTIMING (("PERFCPU: %d takes %I64u ms\n", __LINE__, diff));
#endif
    } else {
        memset (pProcessorIdleInformation, 0, dwProcessorIdleBufferSize);
    }

    // clear the pointers to trap unassigned ones below
    pPCD = NULL;
    pExPCD = NULL;

    if ((!bPerfCpuUseIdleData) && (pProcessorDataDefinition != NULL)) {
        // use the original format of the structure
        // clear the "Total" instance
        memset (&pcdTotalData, 0, sizeof (pcdTotalData));

        //  Define processor data block
        //

        memcpy (pProcessorDataDefinition,
            &ProcessorDataDefinition,
            sizeof(PROCESSOR_DATA_DEFINITION));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                &pProcessorDataDefinition[1];

        pProcessorInformation = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)
                                    pProcessorBuffer;

        // point to the first processor in the returned array of interrupt
        // information. data is returned as an array of structures.

        pThisProcessorInterruptInformation = pProcessorInterruptInformation;
        pProcIdleInformation = pProcessorIdleInformation;

        for ( CurProc = 0;
            CurProc < (ULONG) BasicInfo.NumberOfProcessors;
            CurProc++ ) {

            //
            //  Define processor instance 0;
            //  More could be defined like this
            //

            ProcessorName.Length = 0;
            ProcessorName.MaximumLength = sizeof(ProcessorNameBuffer);
            ProcessorName.Buffer = ProcessorNameBuffer;
            ProcessorNameBuffer[0] = 0;

            RtlIntegerToUnicodeString(CurProc, 10, &ProcessorName);

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                    (PVOID *) &pPCD,
                                    0,
                                    0,
                                    (DWORD)-1,
                                    ProcessorNameBuffer);

            // test for Quadword Alignment
            assert (((ULONG_PTR)(pPCD) & 0x00000007) == 0);
            //
            //  Format and collect processor data.  While doing so,
            //  accumulate totals in the System Object Type data block.
            //  Pointers to these were initialized in QuerySystemData.
            //

            pPCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (PROCESSOR_COUNTER_DATA));
            pcdTotalData.ProcessorTime +=
                pPCD->ProcessorTime =
                    pProcessorInformation->IdleTime.QuadPart;
            pcdTotalData.UserTime +=
                pPCD->UserTime      =
                    pProcessorInformation->UserTime.QuadPart;
            // kernel time is total kernel time less the time spent in the
            // idle thread for that processor
            pcdTotalData.KernelTime +=
                pPCD->KernelTime    =
                    pProcessorInformation->KernelTime.QuadPart -
                                    pPCD->ProcessorTime;

            pcdTotalData.Interrupts +=
                pPCD->Interrupts    = pProcessorInformation->InterruptCount;
            pcdTotalData.DpcTime +=
                pPCD->DpcTime       = pProcessorInformation->DpcTime.QuadPart;
            pcdTotalData.InterruptTime +=
                pPCD->InterruptTime =
                    pProcessorInformation->InterruptTime.QuadPart;

            pcdTotalData.DpcCountRate +=
                pPCD->DpcCountRate  =
                    pThisProcessorInterruptInformation->DpcCount;

            pcdTotalData.DpcRate +=
                pPCD->DpcRate       =
                    pThisProcessorInterruptInformation->DpcRate;

            //
            //  Advance to next processor
            //

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pPCD[1];

            // point to next processor's data in return array(s)
            pProcessorInformation++;
            pThisProcessorInterruptInformation++;
            pProcIdleInformation++;
        }

        // do the total instance now
        ProcessorName.Length = (WORD)((lstrlenW (wszTotal) + 1) * sizeof (WCHAR));
        ProcessorName.MaximumLength = (WORD)(sizeof (ProcessorNameBuffer));
        lstrcpyW (ProcessorNameBuffer, wszTotal);
        ProcessorName.Buffer = ProcessorNameBuffer;

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                (PVOID *) &pPCD,
                                0,
                                0,
                                (DWORD)-1,
                                ProcessorNameBuffer);

        // define the size
        pcdTotalData.CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (PROCESSOR_COUNTER_DATA));

        // adjust the total values of the time fields to the number of
        // processors to "normalize" the values

        pcdTotalData.ProcessorTime /= BasicInfo.NumberOfProcessors;
        pcdTotalData.UserTime /= BasicInfo.NumberOfProcessors;
        pcdTotalData.KernelTime /= BasicInfo.NumberOfProcessors;

        pcdTotalData.DpcTime /= BasicInfo.NumberOfProcessors;
        pcdTotalData.InterruptTime /= BasicInfo.NumberOfProcessors;

        // these fields are OK as totals
        //
        //  pcdTotalData.Interrupts
        //  pcdTotalData.DpcCountRate
        //  pcdTotalData.DpcRate

        // copy total data to buffer
        memcpy (pPCD, &pcdTotalData, sizeof (pcdTotalData));

        // adjust local buffer pointer
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pPCD[1];

        //
        //  Now we know how large an area we used for the
        //  processor definition, so we can update the offset
        //  to the next object definition
        //

        pProcessorDataDefinition->ProcessorObjectType.NumInstances =
            BasicInfo.NumberOfProcessors + 1;

        *lppData = (LPVOID)pPerfInstanceDefinition;

        // round up buffer to the nearest QUAD WORD

        *lppData = ALIGN_ON_QWORD (*lppData);

        *lpcbTotalBytes =
            pProcessorDataDefinition->ProcessorObjectType.TotalByteLength =
                QWORD_MULTIPLE(
                (DWORD)((LPBYTE) pPerfInstanceDefinition -
                (LPBYTE) pProcessorDataDefinition));
    } 

    if ((bPerfCpuUseIdleData) && (pExProcessorDataDefinition != NULL)) {
        // use the new extended structure
        // clear the "Total" instance
        memset (&pexcdTotalData, 0, sizeof (pexcdTotalData));

        //  Define processor data block
        //

        memcpy (pExProcessorDataDefinition,
            &ExProcessorDataDefinition,
            sizeof(EX_PROCESSOR_DATA_DEFINITION));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                &pExProcessorDataDefinition[1];

        pProcessorInformation = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)
                                    pProcessorBuffer;

        // point to the first processor in the returned array of interrupt
        // information. data is returned as an array of structures.

        pThisProcessorInterruptInformation = pProcessorInterruptInformation;
        pProcIdleInformation = pProcessorIdleInformation;

        for ( CurProc = 0;
            CurProc < (ULONG) BasicInfo.NumberOfProcessors;
            CurProc++ ) {

            //
            //  Define processor instance 0;
            //  More could be defined like this
            //

            ProcessorName.Length = 0;
            ProcessorName.MaximumLength = sizeof(ProcessorNameBuffer);
            ProcessorName.Buffer = ProcessorNameBuffer;
            ProcessorNameBuffer[0] = 0;

            RtlIntegerToUnicodeString(CurProc, 10, &ProcessorName);

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                    (PVOID *) &pExPCD,
                                    0,
                                    0,
                                    (DWORD)-1,
                                    ProcessorNameBuffer);

            // test for Quadword Alignment
            assert (((ULONG_PTR)(pExPCD) & 0x00000007) == 0);
            //
            //  Format and collect processor data.  While doing so,
            //  accumulate totals in the System Object Type data block.
            //  Pointers to these were initialized in QuerySystemData.
            //

            pExPCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (EX_PROCESSOR_COUNTER_DATA));
            pexcdTotalData.ProcessorTime +=
                pExPCD->ProcessorTime =
                    pProcessorInformation->IdleTime.QuadPart;
            pexcdTotalData.UserTime +=
                pExPCD->UserTime      =
                    pProcessorInformation->UserTime.QuadPart;
            // kernel time is total kernel time less the time spent in the
            // idle thread for that processor
            pexcdTotalData.KernelTime +=
                pExPCD->KernelTime    =
                    pProcessorInformation->KernelTime.QuadPart -
                                    pExPCD->ProcessorTime;

            pexcdTotalData.Interrupts +=
                pExPCD->Interrupts    = pProcessorInformation->InterruptCount;
            pexcdTotalData.DpcTime +=
                pExPCD->DpcTime       = pProcessorInformation->DpcTime.QuadPart;
            pexcdTotalData.InterruptTime +=
                pExPCD->InterruptTime =
                    pProcessorInformation->InterruptTime.QuadPart;

            pexcdTotalData.DpcCountRate +=
                pExPCD->DpcCountRate  =
                    pThisProcessorInterruptInformation->DpcCount;

            pexcdTotalData.DpcRate +=
                pExPCD->DpcRate       =
                    pThisProcessorInterruptInformation->DpcRate;

            // fill in the system idle info

            pexcdTotalData.IdleTime +=
                pExPCD->IdleTime = 
                    pProcIdleInformation->IdleTime;
            pexcdTotalData.C1Time +=
                pExPCD->C1Time = 
                    pProcIdleInformation->C1Time;
            pexcdTotalData.C2Time +=
                pExPCD->C2Time = 
                    pProcIdleInformation->C2Time;
            pexcdTotalData.C3Time +=
                pExPCD->C3Time = 
                    pProcIdleInformation->C3Time;
            pexcdTotalData.C1Transitions +=
                pExPCD->C1Transitions = 
                    pProcIdleInformation->C1Transitions;
            pexcdTotalData.C2Transitions +=
                pExPCD->C2Transitions = 
                    pProcIdleInformation->C2Transitions;
            pexcdTotalData.C3Transitions +=
                pExPCD->C3Transitions = 
                    pProcIdleInformation->C3Transitions;

            //
            //  Advance to next processor
            //

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pExPCD[1];

            // point to next processor's data in return array(s)
            pProcessorInformation++;
            pThisProcessorInterruptInformation++;
            pProcIdleInformation++;
        }

        // do the total instance now
        ProcessorName.Length = (WORD)((lstrlenW (wszTotal) + 1) * sizeof (WCHAR));
        ProcessorName.MaximumLength = (WORD)(sizeof (ProcessorNameBuffer));
        lstrcpyW (ProcessorNameBuffer, wszTotal);
        ProcessorName.Buffer = ProcessorNameBuffer;

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                (PVOID *) &pExPCD,
                                0,
                                0,
                                (DWORD)-1,
                                ProcessorNameBuffer);

        // define the size
        pexcdTotalData.CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (EX_PROCESSOR_COUNTER_DATA));

        // adjust the total values of the time fields to the number of
        // processors to "normalize" the values

        pexcdTotalData.ProcessorTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.UserTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.KernelTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.IdleTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.C1Time /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.C2Time /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.C3Time /= BasicInfo.NumberOfProcessors;

        pexcdTotalData.DpcTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.InterruptTime /= BasicInfo.NumberOfProcessors;

        // these fields are OK as totals
        //
        //  pexcdTotalData.Interrupts
        //  pexcdTotalData.DpcCountRate
        //  pexcdTotalData.DpcRate

        // copy total data to buffer
        memcpy (pExPCD, &pexcdTotalData, sizeof (pexcdTotalData));

        // adjust local buffer pointer
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pExPCD[1];

        //
        //  Now we know how large an area we used for the
        //  processor definition, so we can update the offset
        //  to the next object definition
        //

        pExProcessorDataDefinition->ProcessorObjectType.NumInstances =
            BasicInfo.NumberOfProcessors + 1;

        *lpcbTotalBytes =
            pExProcessorDataDefinition->ProcessorObjectType.TotalByteLength =
                (DWORD) QWORD_MULTIPLE(((LPBYTE) pPerfInstanceDefinition) -
                                        (LPBYTE) pExProcessorDataDefinition);
        * lppData = (LPVOID) (((LPBYTE) pExProcessorDataDefinition) + * lpcbTotalBytes);
    }

    if ((pExProcessorDataDefinition == NULL) && (pProcessorDataDefinition == NULL)) {
        // then no data buffer found to use
        lReturn = ERROR_SUCCESS;
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        goto COLLECT_BAIL_OUT;
    }

#ifdef DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFOS: Processor Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFOS:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lpNumObjectTypes = 1;

#ifdef DBG
    ENDTIMING (("PERFCPU: %d takes %I64u ms total\n", __LINE__, diff));
#endif
    return ERROR_SUCCESS;

COLLECT_BAIL_OUT:
#ifdef DBG
    ENDTIMING (("PERFCPU: %d takes %I64u ms total\n", __LINE__, diff));
#endif

    return lReturn;
}

DWORD APIENTRY
CloseProcessorObject (
)
/*++

Routine Description:

    This routine closes the open handles

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (dwCpuOpenCount > 0) {
        if (!(--dwCpuOpenCount)) { // when this is the last thread...
            // close stuff here
            if (hLibHeap != NULL) {
                if (pProcessorInterruptInformation != NULL) {
                    FREEMEM (pProcessorInterruptInformation);
                    pProcessorInterruptInformation = NULL;
                }

                if (pProcessorBuffer != NULL) {
                    FREEMEM (pProcessorBuffer);
                    pProcessorBuffer = NULL;
                }
                if (pProcessorIdleInformation != NULL) {
                    FREEMEM (pProcessorIdleInformation);
                    pProcessorIdleInformation = NULL;
                }
                dwInterruptInfoBufferSize = 0;
                ProcessorBufSize = 0;
                dwProcessorIdleBufferSize = 0;
            }
        }
    } else {
        // if the open count is 0, then these should have been deleted
        assert (pProcessorBuffer == NULL);
        assert (pProcessorInterruptInformation == NULL);
        assert (pProcessorIdleInformation == NULL);
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\perfos.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfos.c

Abstract:


Author:

    Bob Watson (a-robw) Aug 95

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <assert.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"

// bit field definitions for collect function flags
#define POS_GET_SYS_PERF_INFO       ((DWORD)0x00010000)

#define POS_COLLECT_CACHE_DATA      ((DWORD)0x00010001)
#define POS_COLLECT_CPU_DATA        ((DWORD)0x00000002)
#define POS_COLLECT_MEMORY_DATA     ((DWORD)0x00010004)
#define POS_COLLECT_OBJECTS_DATA    ((DWORD)0x00000008)
#define POS_COLLECT_PAGEFILE_DATA   ((DWORD)0x00000010)
#define POS_COLLECT_SYSTEM_DATA     ((DWORD)0x00010020)

#define POS_COLLECT_FUNCTION_MASK   ((DWORD)0x0000003F)

#define POS_COLLECT_GLOBAL_DATA     ((DWORD)0x0001003F)
#define POS_COLLECT_FOREIGN_DATA    ((DWORD)0)
#define POS_COLLECT_COSTLY_DATA     ((DWORD)0)

// global variables to this DLL

HANDLE  ThisDLLHandle = NULL;
HANDLE  hEventLog     = NULL;
HANDLE  hLibHeap      = NULL;

SYSTEM_BASIC_INFORMATION BasicInfo;
SYSTEM_PERFORMANCE_INFORMATION  SysPerfInfo;

PM_OPEN_PROC    OpenOSObject;
PM_COLLECT_PROC CollectOSObjectData;
PM_CLOSE_PROC   CloseOSObject;

LPWSTR  wszTotal = NULL;

// variables local to this module

POS_FUNCTION_INFO    posDataFuncInfo[] = {
    {CACHE_OBJECT_TITLE_INDEX,      POS_COLLECT_CACHE_DATA,     0, CollectCacheObjectData},
    {PROCESSOR_OBJECT_TITLE_INDEX,  POS_COLLECT_CPU_DATA,       0, CollectProcessorObjectData},
    {MEMORY_OBJECT_TITLE_INDEX,     POS_COLLECT_MEMORY_DATA,    0, CollectMemoryObjectData},
    {OBJECT_OBJECT_TITLE_INDEX,     POS_COLLECT_OBJECTS_DATA,   0, CollectObjectsObjectData},
    {PAGEFILE_OBJECT_TITLE_INDEX,   POS_COLLECT_PAGEFILE_DATA,  0, CollectPageFileObjectData},
    {SYSTEM_OBJECT_TITLE_INDEX,     POS_COLLECT_SYSTEM_DATA,    0, CollectSystemObjectData}
};

#define POS_NUM_FUNCS   (sizeof(posDataFuncInfo) / sizeof(posDataFuncInfo[1]))

BOOL bInitOk  = FALSE;
BOOL bReportedNotOpen = FALSE;
#ifdef DBG
LONG64 clock0, clock1, freq, diff;
#endif


BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    perform any initialization function that apply to all object
    modules
   
--*/
{
    BOOL    bReturn = TRUE;
    NTSTATUS status;
    WCHAR   wszTempBuffer[MAX_PATH];
    LONG    lStatus;
    DWORD   dwBufferSize;

    UNREFERENCED_PARAMETER (DllHandle);

    if (hLibHeap == NULL) {
        hLibHeap = HeapCreate (0, 1, 0);
    }

    assert (hLibHeap != NULL);

    if (hLibHeap == NULL) {
        return FALSE;
    }

    // open handle to the event log
    if (hEventLog == NULL) {
        hEventLog = MonOpenEventLog((LPWSTR)L"PerfOS");
        //
        //  collect basic and static processor data
        //

        status = NtQuerySystemInformation(
                     SystemBasicInformation,
                     &BasicInfo,
                     sizeof(SYSTEM_BASIC_INFORMATION),
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            BasicInfo.PageSize = 0;
            status = (LONG)RtlNtStatusToDosError(status);
            if (hEventLog != NULL) {
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    PERFOS_UNABLE_QUERY_BASIC_INFO,
                    NULL,
                    0,
                    sizeof(DWORD),
                    NULL,
                    (LPVOID)&status);
            }

            bReturn = FALSE;
        }
    }

    wszTempBuffer[0] = UNICODE_NULL;
    wszTempBuffer[MAX_PATH-1] = UNICODE_NULL;
    lStatus = GetPerflibKeyValue (
        szTotalValue,
        REG_SZ,
        sizeof(wszTempBuffer) - sizeof(WCHAR),
        (LPVOID)&wszTempBuffer[0],
        DEFAULT_TOTAL_STRING_LEN,
        (LPVOID)&szDefaultTotalString[0]);

    if (lStatus == ERROR_SUCCESS) {
        // then a string was returned in the temp buffer
        dwBufferSize = lstrlenW (wszTempBuffer) + 1;
        dwBufferSize *= sizeof (WCHAR);
        wszTotal = ALLOCMEM (dwBufferSize);
        if (wszTotal == NULL) {
            // unable to allocate buffer so use static buffer
            wszTotal = (LPWSTR)&szDefaultTotalString[0];
        } else {
            memcpy (wszTotal, wszTempBuffer, dwBufferSize);
        }
    } else {
        // unable to get string from registry so just use static buffer
        wszTotal = (LPWSTR)&szDefaultTotalString[0];
    }

    return bReturn;
}

BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    UNREFERENCED_PARAMETER (DllHandle);

    if ((dwCpuOpenCount + dwPageOpenCount + dwObjOpenCount) != 0) {
        // close the objects now sinc this is the last chance
        // as the DLL is in the process of being unloaded
        // if any of the open counters are > 1, then set them to 1 
        // to insure the object is closed on this call
        if (dwCpuOpenCount > 1) dwCpuOpenCount = 1;
        if (dwPageOpenCount > 1) dwPageOpenCount = 1;
        if (dwObjOpenCount > 1) dwObjOpenCount = 1;

        CloseOSObject();
    }

    assert ((dwCpuOpenCount + dwPageOpenCount + dwObjOpenCount) == 0);

    if ((wszTotal != NULL) && (wszTotal != &szDefaultTotalString[0])) {
        FREEMEM (wszTotal);
        wszTotal = NULL;
    }

    if (HeapDestroy (hLibHeap)) hLibHeap = NULL;

    if (hEventLog != NULL) {
        MonCloseEventLog ();
	hEventLog = NULL;	 
    }
    return TRUE;
}

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    ReservedAndUnused;

    // this will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach (DLLHandle);

        case DLL_PROCESS_DETACH:
            return DllProcessDetach (DLLHandle);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            return TRUE;
    }
}

DWORD APIENTRY
OpenOSObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status;

    // cache object does not need to be opened

    // open Processor Object
    status = OpenProcessorObject (lpDeviceNames);

    // memory object does not need to be opened

    // open Objects object
    if (status == ERROR_SUCCESS) {
        status = OpenObjectsObject (lpDeviceNames);
        // open Pagefile object
        if (status == ERROR_SUCCESS) {
            status = OpenPageFileObject (lpDeviceNames);
            if (status != ERROR_SUCCESS) {
               // processor & Objects opened & page file did not
               // close the open objects
               CloseProcessorObject ();
               CloseObjectsObject();
            }
         } else {
            // processor Open and Objects did not
            // close the open objects
            CloseProcessorObject();
         }
    } else {
        // nothing opened
    }

    if (status == ERROR_SUCCESS) {
        status = OpenSystemObject(lpDeviceNames);
        if (status != ERROR_SUCCESS) {
            CloseProcessorObject();
            CloseObjectsObject();            
            CloseSystemObject();
        }
    }
    if (status == ERROR_SUCCESS) {
        bInitOk = TRUE;
    } else if (hEventLog != NULL) {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFOS_UNABLE_OPEN,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);
    }

#ifdef DBG
    DbgPrint("PERFOS: OpenOsObject() status = %d\n", status);
#endif
    return  status;
}

DWORD APIENTRY
ReadOSObjectData (
    IN      DWORD   FunctionCallMask,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the OS object

Arguments:

   IN       DWORD FunctionCallMask
            bit mask of functions to call

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            data structure. In the case of an item list, Global or Costly
            query, this will be a collection of one or more perf data objects.
            In the case of a PERF_QUERY_OBJECTS request, this will be an array
            of DWORDs listing the object ID's of the perf data objects
            supported by this DLL.

         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the number of objects listed in the array of DWORDs referenced
            by the pObjList argument
            
         OUT: the number of objects returned by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    NTSTATUS    Status;
    DWORD       lReturn = ERROR_SUCCESS;

    DWORD       FunctionIndex;

    DWORD       dwNumObjectsFromFunction;
    DWORD       dwOrigBuffSize;
    DWORD       dwByteSize;

    DWORD       dwReturnedBufferSize;

    // collect data 
    if (FunctionCallMask & POS_GET_SYS_PERF_INFO) {
#ifdef DBG
    STARTTIMING;
#endif
        Status = NtQuerySystemInformation(
            SystemPerformanceInformation,
            &SysPerfInfo,
            sizeof(SysPerfInfo),
            &dwReturnedBufferSize
            );

        if (!NT_SUCCESS(Status)) {
            if (hEventLog != NULL) {
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    PERFOS_UNABLE_QUERY_SYS_PERF_INFO,
                    NULL,
                    0,
                    sizeof(DWORD),
                    NULL,
                    (LPVOID)&Status);
            }
            memset (&SysPerfInfo, 0, sizeof(SysPerfInfo));
        }
#ifdef DBG
    ENDTIMING(("PERFOS: %d takes %I64d ms\n", __LINE__, diff));
#endif
    } else {
        memset (&SysPerfInfo, 0, sizeof(SysPerfInfo));
    }

    *lpNumObjectTypes = 0;
    dwOrigBuffSize = dwByteSize = *lpcbTotalBytes;
    *lpcbTotalBytes = 0;

    // remove query bits
    FunctionCallMask &= POS_COLLECT_FUNCTION_MASK;

    for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
        if (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit &
            FunctionCallMask) {
            dwNumObjectsFromFunction = 0;

            // check for QUADWORD alignment of data buffer
            assert (((ULONG_PTR)(*lppData) & 0x00000007) == 0);

#ifdef DBG
            STARTTIMING;
#endif
            lReturn = (*posDataFuncInfo[FunctionIndex].pCollectFunction) (
                lppData,
                &dwByteSize,
                &dwNumObjectsFromFunction);

            if (lReturn == ERROR_SUCCESS) {
                *lpNumObjectTypes += dwNumObjectsFromFunction;
                *lpcbTotalBytes += dwByteSize;
                dwOrigBuffSize -= dwByteSize;
                dwByteSize = dwOrigBuffSize;
            } else {
                break;
            }
#ifdef DBG
        ENDTIMING(("PERFOS: %d POS %d takes %I64d ms\n", __LINE__, FunctionIndex, diff));
#endif
        }
        // *lppData is updated by each function
        // *lpcbTotalBytes is updated after each successful function
        // *lpNumObjects is updated after each successful function
    }

    return lReturn;
}   
/*

DWORD APIENTRY
QueryOSObjectData (
    IN      LPDWORD pObjList,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
*/
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN       LPDWORD *pObjList
            pointer to an array of Performance Objects that are
            to be returned to the caller. Each object is referenced by its
            DWORD value. If the first element in the array is one of the
            following then only the first item is read and the following
            data is returned:

                PERF_QUERY_OBJECTS   an array of object id's supported
                                by this function is returned in the data

                PERF_QUERY_GLOBAL    all perf objects supported by this
                                function are returned (Except COSTLY objects)

                PERF_QUERY_COSTLY    all COSTLY perf objects supported
                                by this function are returned

                Foreign objects are not supported by this API

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            data structure. In the case of an item list, Global or Costly
            query, this will be a collection of one or more perf data objects.
            In the case of a PERF_QUERY_OBJECTS request, this will be an array
            of DWORDs listing the object ID's of the perf data objects
            supported by this DLL.

         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the number of objects listed in the array of DWORDs referenced
            by the pObjList argument
            
         OUT: the number of objects returned by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
/*
{
    LONG        lReturn = ERROR_SUCCESS;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;
    LPDWORD     pdwRetBuffer;

    DWORD       ObjectIndex;
    
    if (!bInitOk) {
        if (hEventLog != NULL)) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFOS_NOT_OPEN,
                NULL,
                0,
                0,
                NULL,
                NULL);
        }
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto QUERY_BAIL_OUT;
    }

    // evaluate the object list

    if (*lpNumObjectTypes == 1) {
        // then see if it's a predefined request value
        if (pObjList[0] == PERF_QUERY_GLOBAL) {
            FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
        } else if (pObjList[0] == PERF_QUERY_COSTLY) {
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
        } else if (pObjList[0] == PERF_QUERY_OBJECTS) {
            if (*lpcbTotalBytes < (POS_NUM_FUNCS * sizeof(DWORD))) {
                lReturn = ERROR_MORE_DATA;
            } else {
                pdwRetBuffer = (LPDWORD)*lppData;
                for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                    pdwRetBuffer[FunctionIndex] =
                        posDataFuncInfo[FunctionIndex].dwObjectId;
                }
                *lppData = &pdwRetBuffer[FunctionIndex];
                *lpcbTotalBytes = (POS_NUM_FUNCS * sizeof(DWORD));
                *lpNumObjectTypes = FunctionIndex;
                lReturn = ERROR_SUCCESS;
                goto QUERY_BAIL_OUT;
            }
        }
    }

    if (FunctionCallMask == 0) {
        // it's not a predfined value so run through the list
        // read the object list and build the call mask
        ObjectIndex = 0;
        while (ObjectIndex < *lpNumObjectTypes) {
            // search for this object in the list of object id's 
            // supported by this DLL
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (pObjList[ObjectIndex] ==
                    posDataFuncInfo[FunctionIndex].dwObjectId) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                    break; // out of inner loop
                }
            }
            ObjectIndex++;
        }
    }

    if (FunctionCallMask != 0) {
        lReturn = ReadOSObjectData (FunctionCallMask,
                                lppData,    
                                lpcbTotalBytes,
                                lpNumObjectTypes);
    } else {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
    }

QUERY_BAIL_OUT:
    return  lReturn;
}
*/

DWORD APIENTRY
CollectOSObjectData (
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN       LPWSTR   lpValueName
            pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    // build bit mask of functions to call

    DWORD       dwQueryType;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;

#ifdef DBG
    STARTTIMING;
#endif

    if (!bInitOk) {
        if (!bReportedNotOpen) {
            if (hEventLog != NULL) {
                bReportedNotOpen = ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    PERFOS_NOT_OPEN,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL);
            }
        }
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto COLLECT_BAIL_OUT;
    }

    dwQueryType = GetQueryType (lpValueName);

    switch (dwQueryType) {
        case QUERY_ITEMS:
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (IsNumberInUnicodeList (
                    posDataFuncInfo[FunctionIndex].dwObjectId, lpValueName)) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                }
            }
            break;

        case QUERY_GLOBAL:
            FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
            break;

        case QUERY_FOREIGN:
            FunctionCallMask = POS_COLLECT_FOREIGN_DATA;
            break;

        case QUERY_COSTLY:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;

        default:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;
    }

    if (FunctionCallMask != 0) {
        lReturn = ReadOSObjectData (FunctionCallMask,
                                lppData,    
                                lpcbTotalBytes,
                                lpNumObjectTypes);
    } else {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
    }

COLLECT_BAIL_OUT:
    
#ifdef DBG
    ENDTIMING (("PERFOS: %d Collect takes %I64d ms\n", __LINE__, diff));
#endif
    return lReturn;
}

DWORD APIENTRY
CloseOSObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD   status;
    DWORD   dwReturn = ERROR_SUCCESS;

    // cache object does not need to be closeed

    // close Processor Object
    status = CloseProcessorObject ();
    assert (status == ERROR_SUCCESS);
    if (status != ERROR_SUCCESS) dwReturn = status;

    // memory object does not need to be closeed

    // close Objects object
    status = CloseObjectsObject ();
    assert (status == ERROR_SUCCESS);
    if (status != ERROR_SUCCESS) dwReturn = status;

    // close Pagefile object
    status = ClosePageFileObject ();
    assert (status == ERROR_SUCCESS);
    if (status != ERROR_SUCCESS) dwReturn = status;

    // close System object

    status = CloseSystemObject();
    if (status != ERROR_SUCCESS) dwReturn = status;

    return  dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\perfmem.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfmem.c

Abstract:

    This file implements an Performance Object that presents
    System Memory Performance Object

Created:    

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntmmapi.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"
#include "datamem.h"


DWORD APIENTRY
CollectMemoryObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the XXX object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    Returns:

        0 if successful, else Win 32 error code of failure

--*/
{
    NTSTATUS Status;
    DWORD  TotalLen;            //  Length of the total return block

    PMEMORY_DATA_DEFINITION         pMemoryDataDefinition;
    SYSTEM_FILECACHE_INFORMATION    FileCache;
    PMEMORY_COUNTER_DATA    pMCD;
    DWORD       LocalPageSize;

    pMemoryDataDefinition = (MEMORY_DATA_DEFINITION *) *lppData;

    //
    //  Check for enough space for memory data block
    //

    TotalLen = sizeof(MEMORY_DATA_DEFINITION) +
                sizeof(MEMORY_COUNTER_DATA);

    TotalLen = QWORD_MULTIPLE (TotalLen);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

#ifdef DBG
    STARTTIMING;
#endif
    Status = NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCache,
                sizeof(FileCache),
                NULL
                );

    if (!NT_SUCCESS(Status)) {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_FILE_CACHE_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&Status);
        }
        memset (&FileCache, 0, sizeof(FileCache));
    }

#ifdef DBG
    ENDTIMING (("PERFMEM: %d takes %I64u ms\n", __LINE__, diff));
#endif
    //
    //  Define memory data block
    //

    memcpy (pMemoryDataDefinition,
        &MemoryDataDefinition,
        sizeof(MEMORY_DATA_DEFINITION));

    //
    //  Format and collect memory data
    //

    LocalPageSize = BasicInfo.PageSize;

    pMCD = (PMEMORY_COUNTER_DATA)&pMemoryDataDefinition[1];

    pMCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (MEMORY_COUNTER_DATA));

    pMCD->AvailablePages = SysPerfInfo.AvailablePages;
    pMCD->AvailablePages *= LocalPageSize; // display as bytes
    pMCD->AvailableKBytes = pMCD->AvailablePages / 1024;
    pMCD->AvailableMBytes = pMCD->AvailableKBytes / 1024;
    pMCD->CommittedPages = SysPerfInfo.CommittedPages;
    pMCD->CommittedPages *= LocalPageSize;
    pMCD->CommitList    = SysPerfInfo.CommitLimit;
    pMCD->CommitList    *= LocalPageSize;
    pMCD->PageFaults    = SysPerfInfo.PageFaultCount;
    pMCD->WriteCopies   = SysPerfInfo.CopyOnWriteCount;
    pMCD->TransitionFaults  = SysPerfInfo.TransitionCount;
    pMCD->CacheFaults   = FileCache.PageFaultCount;
    pMCD->DemandZeroFaults  = SysPerfInfo.DemandZeroCount;
    pMCD->Pages         = SysPerfInfo.PageReadCount +
                            SysPerfInfo.DirtyPagesWriteCount;
    pMCD->PagesInput    = SysPerfInfo.PageReadCount;
    pMCD->PageReads     = SysPerfInfo.PageReadIoCount;
    pMCD->DirtyPages    = SysPerfInfo.DirtyPagesWriteCount;
    pMCD->DirtyWrites   = SysPerfInfo.DirtyWriteIoCount;
    pMCD->PagedPool     = SysPerfInfo.PagedPoolPages;
    pMCD->PagedPool     *= LocalPageSize;
    pMCD->NonPagedPool  = SysPerfInfo.NonPagedPoolPages;
    pMCD->NonPagedPool  *= LocalPageSize;
    pMCD->PagedPoolAllocs   = SysPerfInfo.PagedPoolAllocs -
                                SysPerfInfo.PagedPoolFrees;
    pMCD->NonPagedPoolAllocs = SysPerfInfo.NonPagedPoolAllocs -
                                SysPerfInfo.NonPagedPoolFrees;
    pMCD->FreeSystemPtes    = SysPerfInfo.FreeSystemPtes;
    pMCD->CacheBytes    = FileCache.CurrentSize;
    pMCD->PeakCacheBytes    = FileCache.PeakSize;
    pMCD->ResidentPagedPoolBytes = SysPerfInfo.ResidentPagedPoolPage;
    pMCD->ResidentPagedPoolBytes *= LocalPageSize;
    pMCD->TotalSysCodeBytes     = SysPerfInfo.TotalSystemCodePages;
    pMCD->TotalSysCodeBytes     *= LocalPageSize;
    pMCD->ResidentSysCodeBytes  = SysPerfInfo.ResidentSystemCodePage;
    pMCD->ResidentSysCodeBytes  *= LocalPageSize;
    pMCD->TotalSysDriverBytes   = SysPerfInfo.TotalSystemDriverPages;
    pMCD->TotalSysDriverBytes   *= LocalPageSize;
    pMCD->ResidentSysDriverBytes = SysPerfInfo.ResidentSystemDriverPage;
    pMCD->ResidentSysDriverBytes *= LocalPageSize;
    pMCD->ResidentSysCacheBytes = SysPerfInfo.ResidentSystemCachePage;
    pMCD->ResidentSysCacheBytes *= LocalPageSize;
    pMCD->TransitionRePurpose   = FileCache.TransitionRePurposeCount;

    //  This is reported as a percentage of CommittedPages/CommitLimit.
    //  these value return a value in "page" units. Since this is a
    //  fraction, the page size (i.e. converting pages to bytes) will
    //  cancel out and as such can be ignored, saving some CPU cycles
    //
    pMCD->CommitBytesInUse  = (ULONG)SysPerfInfo.CommittedPages;
    pMCD->CommitBytesLimit  = (ULONG)SysPerfInfo.CommitLimit;

#if 0	// no longer supported
    // load the VLM counters - this should really be removed period.
    pMCD->SystemVlmCommitCharge = 0;
    pMCD->SystemVlmPeakCommitCharge = 0;
    pMCD->SystemVlmSharedCommitCharge = 0;
#endif

    *lpcbTotalBytes =
        pMemoryDataDefinition->MemoryObjectType.TotalByteLength =
            (DWORD) QWORD_MULTIPLE(((LPBYTE) (& pMCD[1])) - (LPBYTE) pMemoryDataDefinition);
    * lppData = (LPVOID) (((LPBYTE) pMemoryDataDefinition) + * lpcbTotalBytes);

    *lpNumObjectTypes = 1;
#ifdef DBG
    ENDTIMING (("PERFMEM: %d takes %I64u ms total\n", __LINE__, diff));
#endif

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\perfpage.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfpage.c

Abstract:

    This file implements an Performance Object that presents
    system Page file performance data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <assert.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"
#include "datapage.h"

DWORD   dwPageOpenCount = 0;        // count of "Open" threads

PSYSTEM_PAGEFILE_INFORMATION pSysPageFileInfo = NULL;
DWORD  dwSysPageFileInfoSize = 0; // size of page file info array


DWORD APIENTRY
OpenPageFileObject (
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    UNREFERENCED_PARAMETER (lpDeviceNames);

    if (!dwPageOpenCount) {
        // allocate the memory for the Page file info

        dwSysPageFileInfoSize = LARGE_BUFFER_SIZE;

        pSysPageFileInfo = ALLOCMEM (dwSysPageFileInfoSize);

        if (pSysPageFileInfo == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto OpenExitPoint;
        }
    }

    dwPageOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}


DWORD APIENTRY
CollectPageFileObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the XXX object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    DWORD   PageFileNumber;
    DWORD   NumPageFileInstances;
    DWORD   dwReturnedBufferSize;

    NTSTATUS    status;

    PSYSTEM_PAGEFILE_INFORMATION    pThisPageFile;
    PPAGEFILE_DATA_DEFINITION       pPageFileDataDefinition;
    PPERF_INSTANCE_DEFINITION       pPerfInstanceDefinition;
    PPAGEFILE_COUNTER_DATA          pPFCD;
    PAGEFILE_COUNTER_DATA           TotalPFCD;

    //
    //  Check for sufficient space for the Pagefile object
    //  and counter type definition records, + one instance and
    //  one set of counter data
    //

#ifdef DBG
    STARTTIMING;
#endif
    TotalLen = sizeof(PAGEFILE_DATA_DEFINITION) +
                sizeof(PERF_INSTANCE_DEFINITION) +
                MAX_PATH * sizeof(WCHAR) +
                sizeof(PAGEFILE_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    while ((status = NtQuerySystemInformation(
                SystemPageFileInformation,  // item id
                pSysPageFileInfo,           // address of buffer to get data
                dwSysPageFileInfoSize,      // size of buffer
                &dwReturnedBufferSize)) == STATUS_INFO_LENGTH_MISMATCH) {
        dwSysPageFileInfoSize += INCREMENT_BUFFER_SIZE;
        FREEMEM(pSysPageFileInfo);
        pSysPageFileInfo = ALLOCMEM (dwSysPageFileInfoSize);

        if (pSysPageFileInfo == NULL) {
            status = STATUS_NO_MEMORY;
            break;
        }
    }

    if ( !NT_SUCCESS(status) ) {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFOS_UNABLE_QUERY_PAGEFILE_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                &status);
        }
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return RtlNtStatusToDosError(status);
    }
#ifdef DBG
    ENDTIMING (("PERFPAGE: %d takes %I64u ms\n", __LINE__, diff));
#endif

    pPageFileDataDefinition = (PPAGEFILE_DATA_DEFINITION) *lppData;
    //
    //  Define Page File data block
    //

    memcpy (pPageFileDataDefinition,
        &PagefileDataDefinition,
        sizeof(PAGEFILE_DATA_DEFINITION));

    // Now load data for each PageFile

    // clear the total fields
    memset (&TotalPFCD, 0, sizeof(TotalPFCD));
    TotalPFCD.CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (PAGEFILE_COUNTER_DATA));

    PageFileNumber = 0;
    NumPageFileInstances = 0;

    pThisPageFile = pSysPageFileInfo;   // initialize pointer to list of pagefiles

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                            &pPageFileDataDefinition[1];

    // the check for NULL pointer is NOT the exit criteria for this loop,
    // merely a check to bail out if the first (or any subsequent) pointer
    // is NULL. Normally the loop will exit when the NextEntryOffset == 0

    while ( pThisPageFile != NULL ) {

        // compute the size required for the next instance record

        TotalLen =
            // current bytes already used
            (DWORD)((LPBYTE)pPerfInstanceDefinition -
                (LPBYTE)pPageFileDataDefinition)
            // + this instance definition
            + sizeof(PERF_INSTANCE_DEFINITION)
            // + the file (instance) name
            + QWORD_MULTIPLE(pThisPageFile->PageFileName.Length + sizeof(WCHAR))
            // + the data block
            + sizeof (PAGEFILE_COUNTER_DATA);

        TotalLen = QWORD_MULTIPLE(TotalLen+4); // round up to the next quadword

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        // Build an Instance

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *) &pPFCD,
            0,
            0,
            (DWORD)-1,
            pThisPageFile->PageFileName.Buffer);

        //
        //  Format the pagefile data
        //

        pPFCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (PAGEFILE_COUNTER_DATA));

        pPFCD->PercentInUse = pThisPageFile->TotalInUse;
        pPFCD->PeakUsageBase =
            pPFCD->PercentInUseBase = pThisPageFile->TotalSize;
        pPFCD->PeakUsage = pThisPageFile->PeakUsage;

        // update the total accumulators

        TotalPFCD.PeakUsageBase =
            TotalPFCD.PercentInUseBase += pThisPageFile->TotalSize;
        TotalPFCD.PeakUsage     += pThisPageFile->PeakUsage;
        TotalPFCD.PercentInUse  += pThisPageFile->TotalInUse;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pPFCD[1];
        NumPageFileInstances++;
        PageFileNumber++;

        if (pThisPageFile->NextEntryOffset != 0) {
            pThisPageFile = (PSYSTEM_PAGEFILE_INFORMATION)\
                        ((BYTE *)pThisPageFile + pThisPageFile->NextEntryOffset);
        } else {
            break;
        }
    }


    if (NumPageFileInstances > 0) {
        // compute the size required for the next instance record

        TotalLen =
            // current bytes already used
            (DWORD)((LPBYTE)pPerfInstanceDefinition -
                (LPBYTE)pPageFileDataDefinition)
            // + this instance definition
            + sizeof(PERF_INSTANCE_DEFINITION)
            // + the file (instance) name
            + QWORD_MULTIPLE((lstrlenW (wszTotal) + 1) * sizeof (WCHAR))
            // + the data block
            + sizeof (PAGEFILE_COUNTER_DATA);

        TotalLen = QWORD_MULTIPLE(TotalLen+4); // round up to the next quadword

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        // Build the Total Instance

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *)&pPFCD,
            0,
            0,
            (DWORD)-1,
            (LPWSTR)wszTotal);

        //
        //  copy the total data
        //

        memcpy (pPFCD, &TotalPFCD, sizeof (TotalPFCD));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pPFCD[1];
        NumPageFileInstances++;
    }
    // Note number of PageFile instances

    pPageFileDataDefinition->PagefileObjectType.NumInstances =
        NumPageFileInstances;

    //
    //  update pointers for return
    //

    *lpcbTotalBytes =
        pPageFileDataDefinition->PagefileObjectType.TotalByteLength =
            (DWORD) QWORD_MULTIPLE(((LPBYTE) pPerfInstanceDefinition) -
                                   (LPBYTE) pPageFileDataDefinition);
    * lppData = (LPVOID) (((LPBYTE) pPageFileDataDefinition) + * lpcbTotalBytes);

#ifdef DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFOS: Paging File Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFOS:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lpNumObjectTypes = 1;

#ifdef DBG
    ENDTIMING (("PERFPAGE: %d takes %I64u ms total\n", __LINE__, diff));
#endif
    return ERROR_SUCCESS;
}


DWORD APIENTRY
ClosePageFileObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (dwPageOpenCount > 0) {
        if (!(--dwPageOpenCount)) { // when this is the last thread...
            // close stuff here
            if (hLibHeap != NULL) {
                if (pSysPageFileInfo != NULL) {
                    FREEMEM (pSysPageFileInfo);
                    pSysPageFileInfo = NULL;
                }
            }
        }
    } else {
        // if open count == 0, then this should be null
        assert (pSysPageFileInfo == NULL);
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\datadhcp.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    DHCPdata.c

    Constant data structures for the FTP Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/
#define UNICODE 1
#include <windows.h>
#include <winperf.h>
#include "dhcpctrs.h"
#include "datadhcp.h"


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

//
//  DO NOT CHANGE THE ORDER HERE --- THAT WILL GIVE TROBULE TO
//  THE SERVICE (global.h struct Stats definition).
//

DHCPDATA_DATA_DEFINITION DhcpDataDataDefinition =
{
    {   // DHCPDataObjectType
        sizeof(DHCPDATA_DATA_DEFINITION) + DHCPDATA_SIZE_OF_PERFORMANCE_DATA,
        sizeof(DHCPDATA_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        DHCPCTRS_COUNTER_OBJECT,
        0,
        DHCPCTRS_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_DHCPDATA_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // PacketsReceived
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_RECEIVED,
        0,
        DHCPCTRS_PACKETS_RECEIVED,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_PACKETS_RECEIVED_OFFSET,
    },

    {   // PacketsDuplicate
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_DUPLICATE,
        0,
        DHCPCTRS_PACKETS_DUPLICATE,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_PACKETS_DUPLICATE_OFFSET,
    },

    {   // PacketsExpired
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_EXPIRED,
        0,
        DHCPCTRS_PACKETS_EXPIRED,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_PACKETS_EXPIRED_OFFSET,
    },

    {   // MilliSecondsPerPacket
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_MILLISECONDS_PER_PACKET,
        0,
        DHCPCTRS_MILLISECONDS_PER_PACKET,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL,
        sizeof(DWORD),
        DHCPDATA_MILLISECONDS_PER_PACKET_OFFSET,
    },

    {   // ActiveQueuePackets
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_IN_ACTIVE_QUEUE,
        0,
        DHCPCTRS_PACKETS_IN_ACTIVE_QUEUE,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL,
        sizeof(DWORD),
        DHCPDATA_PACKETS_IN_ACTIVE_QUEUE_OFFSET,
    },

    {   // PingQueuePackets
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_IN_PING_QUEUE,
        0,
        DHCPCTRS_PACKETS_IN_PING_QUEUE,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL,
        sizeof(DWORD),
        DHCPDATA_PACKETS_IN_PING_QUEUE_OFFSET,
    },

    {   // Discovers
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_DISCOVERS,
        0,
        DHCPCTRS_DISCOVERS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_DISCOVERS_OFFSET,
    },

    {   // Offers
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_OFFERS,
        0,
        DHCPCTRS_OFFERS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_OFFERS_OFFSET,
    },

    {   // Requests
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_REQUESTS,
        0,
        DHCPCTRS_REQUESTS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_REQUESTS_OFFSET,
    },

    {   // Informs
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_INFORMS,
        0,
        DHCPCTRS_INFORMS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_INFORMS_OFFSET,
    },

    {   // Acks
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_ACKS,
        0,
        DHCPCTRS_ACKS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_ACKS_OFFSET,
    },

    {   // Nacks
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_NACKS,
        0,
        DHCPCTRS_NACKS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_NACKS_OFFSET
    },

    {   // Declines
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_DECLINES,
        0,
        DHCPCTRS_DECLINES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_DECLINES_OFFSET
    },

    {   // Releases
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_RELEASES,
        0,
        DHCPCTRS_RELEASES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_RELEASES_OFFSET,
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\os\perfsys.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfsys.c

Abstract:

    This file implements an Performance Object that presents
    System Performance Object information

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"
#include "datasys.h"

typedef struct _PERFSYS_THREAD_DATA_BLOCK {
    DWORD   dwProcessCount;
    DWORD   dwNullProcessCount;
    DWORD   dwThreadCount;
    DWORD   dwReadyThreads;     // (1) this is the same as the queue length
    DWORD   dwTerminatedThreads;    // (4)
    DWORD   dwWaitingThreads;       // (5)
    DWORD   dwTransitionThreads;    // (6)
} PERFSYS_THREAD_DATA_BLOCK, * PPERFSYS_THREAD_DATA_BLOCK;

ULONG ProcessBufSize = LARGE_BUFFER_SIZE;
ULONG dwSysOpenCount = 0;
UCHAR *pProcessBuffer = NULL;

DWORD APIENTRY
OpenSystemObject (
    LPWSTR lpDeviceNames
    )
{
    UNREFERENCED_PARAMETER(lpDeviceNames);

    dwSysOpenCount++;
    return ERROR_SUCCESS;
}


DWORD
GetSystemThreadInfo (
    PPERFSYS_THREAD_DATA_BLOCK pTDB
)
{
    NTSTATUS    status;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;

    ULONG ProcessNumber;
    ULONG NumThreadInstances;
    ULONG ThreadNumber;
    ULONG ProcessBufferOffset;
    BOOLEAN NullProcess;

    DWORD dwReturnedBufferSize = 0;

#ifdef DBG
    DWORD trialcount = 0;

    STARTTIMING;
#endif

    // reset the caller's buffer
    memset (pTDB, 0, sizeof (PERFSYS_THREAD_DATA_BLOCK));

    if (pProcessBuffer == NULL) {
        ProcessBufSize = LARGE_BUFFER_SIZE;
        pProcessBuffer = ALLOCMEM (ProcessBufSize);
#ifdef DBG
        trialcount = 1;
#endif
    }

    if (pProcessBuffer == NULL) {
        status = STATUS_NO_MEMORY;
    } else {
        while( (status = NtQuerySystemInformation(
                            SystemProcessInformation,
                            pProcessBuffer,
                            ProcessBufSize,
                            &dwReturnedBufferSize)) ==
                                STATUS_INFO_LENGTH_MISMATCH ) {
            if (ProcessBufSize < dwReturnedBufferSize) {
                ProcessBufSize = dwReturnedBufferSize;
            }
            ProcessBufSize = PAGESIZE_MULTIPLE(ProcessBufSize + SMALL_BUFFER_SIZE);
#ifdef DBG
            trialcount++;
#endif
            FREEMEM(pProcessBuffer);
            pProcessBuffer = ALLOCMEM(ProcessBufSize);
            if (pProcessBuffer == NULL) {
                status = STATUS_NO_MEMORY;
                break;
            }
        }
    }
#ifdef DBG
    ENDTIMING (("PERFSYS: %d takes %I64u ms size=%d,%d trials=%d\n", __LINE__, diff,
            dwReturnedBufferSize, ProcessBufSize, trialcount));
#endif

    if ( NT_SUCCESS(status) ) {
        // walk processes and threads to count 'ready' threads
        ProcessNumber = 0;
        NumThreadInstances = 0;

        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;
        ProcessBufferOffset = 0;

        while ( ProcessInfo != NULL ) {
            if ( ProcessInfo->ImageName.Buffer != NULL ||
                ProcessInfo->NumberOfThreads > 0 ) {
                NullProcess = FALSE;
                pTDB->dwProcessCount++;
            } else {
                NullProcess = TRUE;
                pTDB->dwNullProcessCount++;
            }

            ThreadNumber = 0;       //  Thread number of this process

            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

            while ( !NullProcess &&
                    ThreadNumber < ProcessInfo->NumberOfThreads ) {

                //
                //  Format and collect Thread data
                //
                pTDB->dwThreadCount++;

                // update thread state counters
                if (ThreadInfo->ThreadState == 1) {
                    // then it's READY
                    pTDB->dwReadyThreads++;
                } else if (ThreadInfo->ThreadState == 4) {
                    // then it's TERMINATED
                    pTDB->dwTerminatedThreads++;
                } else if (ThreadInfo->ThreadState == 5) {
                    // then it's WAITING
                    pTDB->dwWaitingThreads++;
                } else if (ThreadInfo->ThreadState == 6) {
                    // then it's in TRANSITION
                    pTDB->dwTransitionThreads++;
                }

                ThreadNumber++;
                ThreadInfo++;
            }

            if (ProcessInfo->NextEntryOffset == 0) {
                // that was the last process
                break;
            }

            ProcessBufferOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                            &pProcessBuffer[ProcessBufferOffset];

            if ( !NullProcess ) {
                ProcessNumber++;
            }
        }

    } else if (hEventLog != NULL) {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_PROCESS_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);
    }

#ifdef DBG
    ENDTIMING (("PERFSYS: %d takes %I64u ms total\n", __LINE__, diff));
#endif
    return ERROR_SUCCESS;

}

DWORD APIENTRY
CollectSystemObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the System object

Arguments:

    QuerySystemData -    Get data about system

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

         Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    NTSTATUS    ntStatus;

    PSYSTEM_DATA_DEFINITION     pSystemDataDefinition;
    PSYSTEM_COUNTER_DATA        pSCD;

    SYSTEM_EXCEPTION_INFORMATION    ExceptionInfo;
    SYSTEM_REGISTRY_QUOTA_INFORMATION   RegistryInfo;
    SYSTEM_TIMEOFDAY_INFORMATION    SysTimeInfo;
    PERFSYS_THREAD_DATA_BLOCK       TDB;

    DWORD   dwReturnedBufferSize;

    //  Check for sufficient space for system data
    //

#ifdef DBG
    STARTTIMING;
#endif
    pSystemDataDefinition = (SYSTEM_DATA_DEFINITION *) *lppData;

    TotalLen = sizeof(SYSTEM_DATA_DEFINITION) +
            sizeof(SYSTEM_COUNTER_DATA);

    TotalLen = QWORD_MULTIPLE (TotalLen);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define system data block
    //

    memcpy (pSystemDataDefinition,
        &SystemDataDefinition,
        sizeof(SYSTEM_DATA_DEFINITION));

    //
    //  Format and collect system data
    //

    // get the exception data

    ntStatus = NtQuerySystemInformation(
        SystemExceptionInformation,
        &ExceptionInfo,
        sizeof(ExceptionInfo),
        NULL
    );

    if (!NT_SUCCESS(ntStatus)) {
        // unable to collect the data from the system so
        // clear the return data structure to prevent bogus data from
        // being returned
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_EXCEPTION_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&ntStatus);
        }
        memset (&ExceptionInfo, 0, sizeof(ExceptionInfo));
    }

    // collect registry quota info

    memset (&RegistryInfo, 0, sizeof (SYSTEM_REGISTRY_QUOTA_INFORMATION));
    ntStatus = NtQuerySystemInformation (
        SystemRegistryQuotaInformation,
        (PVOID)&RegistryInfo,
        sizeof(RegistryInfo),
        NULL);

    if (ntStatus != STATUS_SUCCESS) {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_REGISTRY_QUOTA_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&ntStatus);
        }
        // clear the data fields
        memset (&RegistryInfo, 0, sizeof (SYSTEM_REGISTRY_QUOTA_INFORMATION));
    }

    ntStatus = NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &SysTimeInfo,
        sizeof(SysTimeInfo),
        &dwReturnedBufferSize
        );

    if (!NT_SUCCESS(ntStatus)) {
        if (hEventLog != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_SYSTEM_TIME_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&ntStatus);
        }
        memset (&SysTimeInfo, 0, sizeof(SysTimeInfo));
    }

    // get thread info
    ntStatus = GetSystemThreadInfo (&TDB);
    if (!NT_SUCCESS(ntStatus)) {
        memset (&TDB, 0, sizeof(TDB));
    }

	// update the object perf time (freq is constant)
    pSystemDataDefinition->SystemObjectType.PerfTime = SysTimeInfo.CurrentTime;

    pSCD = (PSYSTEM_COUNTER_DATA)&pSystemDataDefinition[1];

    pSCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(SYSTEM_COUNTER_DATA));

    pSCD->ReadOperations    = SysPerfInfo.IoReadOperationCount;
    pSCD->WriteOperations   = SysPerfInfo.IoWriteOperationCount;
    pSCD->OtherIOOperations = SysPerfInfo.IoOtherOperationCount;

    pSCD->ReadBytes         = SysPerfInfo.IoReadTransferCount.QuadPart;
    pSCD->WriteBytes        = SysPerfInfo.IoWriteTransferCount.QuadPart;
    pSCD->OtherIOBytes      = SysPerfInfo.IoOtherTransferCount.QuadPart;

    pSCD->ContextSwitches   = SysPerfInfo.ContextSwitches;
    pSCD->SystemCalls       = SysPerfInfo.SystemCalls;

    pSCD->TotalReadWrites   = SysPerfInfo.IoReadOperationCount +
                                SysPerfInfo.IoWriteOperationCount;

    pSCD->SystemElapsedTime = SysTimeInfo.BootTime.QuadPart - SysTimeInfo.BootTimeBias;

    // leave room for the ProcessorQueueLength data
    pSCD->ProcessorQueueLength  = TDB.dwReadyThreads;
    pSCD->ProcessCount          = TDB.dwProcessCount;
    pSCD->ThreadCount           = TDB.dwThreadCount;

    pSCD->AlignmentFixups       = ExceptionInfo.AlignmentFixupCount ;
    pSCD->ExceptionDispatches   = ExceptionInfo.ExceptionDispatchCount ;
    pSCD->FloatingPointEmulations = ExceptionInfo.FloatingEmulationCount ;

    pSCD->RegistryQuotaUsed     = RegistryInfo.RegistryQuotaUsed;
    pSCD->RegistryQuotaAllowed  = RegistryInfo.RegistryQuotaAllowed;

    *lpcbTotalBytes =
        pSystemDataDefinition->SystemObjectType.TotalByteLength =
            (DWORD) QWORD_MULTIPLE(((LPBYTE) (& pSCD[1])) - (LPBYTE) pSystemDataDefinition);
    * lppData = (LPVOID) (((LPBYTE) pSystemDataDefinition) + * lpcbTotalBytes);

    *lpNumObjectTypes = 1;

#ifdef DBG
    ENDTIMING (("PERFSYS: %d takes %I64u ms total\n", __LINE__, diff));
#endif
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseSystemObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    UCHAR *pBuffer;

    if (dwSysOpenCount > 0) {
        if (!(--dwSysOpenCount)) { // when this is the last thread...
            // close stuff here
            if ((hLibHeap != NULL) && (pProcessBuffer != NULL)) {
                pBuffer = pProcessBuffer;
                pProcessBuffer = NULL;
                FREEMEM (pBuffer);
                ProcessBufSize = 0;
            }
        }
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\datadhcp.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    dhcpdata.h

    Extensible object definitions for the DHCP Server's counter
    objects & counters.


    FILE HISTORY:
        Pradeepb     20-July-1993 Created.
        RameshV      05-Aug-1998 Adapted for DHCP

*/


#ifndef _DHCPDATA_H_
#define _DHCPDATA_H_


//
//  This structure is used to ensure the first counter is properly
//  aligned.  Unfortunately, since PERF_COUNTER_BLOCK consists
//  of just a single DWORD, any LARGE_INTEGERs that immediately
//  follow will not be aligned properly.
//
//  This structure requires "natural" packing & alignment (probably
//  quad-word, especially on Alpha).  Ergo, keep it out of the
//  #pragma pack(4) scope below.
//

typedef struct _DHCPDATA_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    LARGE_INTEGER       DummyEntryForAlignmentPurposesOnly;

} DHCPDATA_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

#pragma pack(4)


//
//  Offsets within a PERF_COUNTER_BLOCK.
//


#define DHCPDATA_PACKETS_RECEIVED_OFFSET         (0*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_PACKETS_DUPLICATE_OFFSET        (1*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_PACKETS_EXPIRED_OFFSET          (2*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_MILLISECONDS_PER_PACKET_OFFSET  (3*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_PACKETS_IN_ACTIVE_QUEUE_OFFSET  (4*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_PACKETS_IN_PING_QUEUE_OFFSET    (5*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_DISCOVERS_OFFSET                (6*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_OFFERS_OFFSET                   (7*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_REQUESTS_OFFSET                 (8*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_INFORMS_OFFSET                  (9*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_ACKS_OFFSET                     (10*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_NACKS_OFFSET                    (11*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_DECLINES_OFFSET                 (12*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_RELEASES_OFFSET                 (13*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_SIZE_OF_PERFORMANCE_DATA        (14*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
//
//  The counter structure returned.
//

typedef struct _DHCPDATA_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            ObjectType;
    PERF_COUNTER_DEFINITION     PacketsReceived;
    PERF_COUNTER_DEFINITION     PacketsDuplicate;
    PERF_COUNTER_DEFINITION     PacketsExpired;
    PERF_COUNTER_DEFINITION     MilliSecondsPerPacket;
    PERF_COUNTER_DEFINITION     ActiveQueuePackets;
    PERF_COUNTER_DEFINITION     PingQueuePackets;
    PERF_COUNTER_DEFINITION     Discovers;
    PERF_COUNTER_DEFINITION     Offers;
    PERF_COUNTER_DEFINITION     Requests;
    PERF_COUNTER_DEFINITION     Informs;
    PERF_COUNTER_DEFINITION     Acks;
    PERF_COUNTER_DEFINITION     Nacks;
    PERF_COUNTER_DEFINITION     Declines;
    PERF_COUNTER_DEFINITION     Releases;
} DHCPDATA_DATA_DEFINITION;


extern  DHCPDATA_DATA_DEFINITION    DhcpDataDataDefinition;


#define NUMBER_OF_DHCPDATA_COUNTERS ((sizeof(DHCPDATA_DATA_DEFINITION) -      \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))


#define DHCPDATA_PERFORMANCE_KEY	\
	TEXT("System\\CurrentControlSet\\Services\\DHCPServer\\Performance")
//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _DHCPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\datanbf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

      datanbf.h  

Abstract:

    Header file for the Nbf Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Russ Blake  07/30/92

Revision History:


--*/

#ifndef _DATANBF_H_
#define _DATANBF_H_

/****************************************************************************\
								   18 Jan 92
								   russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.	Add a define for the offset of the counter in the
	data block for the given object type.

    b.	Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.	Add Text for the Counter Name and the Text for the Help.

    b.	Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.	The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/
 
//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define NBF_NUM_PERF_OBJECT_TYPES 2

//----------------------------------------------------------------------------

//
//  Nbf Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define MAXIMUM_USED_OFFSET         sizeof(DWORD)
#define AVERAGE_USED_OFFSET         MAXIMUM_USED_OFFSET + sizeof(DWORD)
#define NUMBER_OF_EXHAUSTIONS_OFFSET \
                                    AVERAGE_USED_OFFSET + sizeof(DWORD)
#define SIZE_OF_NBF_RESOURCE_DATA   NUMBER_OF_EXHAUSTIONS_OFFSET + \
                                        sizeof(DWORD)


//
//  This is the counter structure presently returned by Nbf for
//  each Resource.  Each Resource is an Instance, named by its number.
//

typedef struct _NBF_RESOURCE_DATA_DEFINITION {
    PERF_OBJECT_TYPE            NbfResourceObjectType;
    PERF_COUNTER_DEFINITION     MaximumUsed;
    PERF_COUNTER_DEFINITION     AverageUsed;
    PERF_COUNTER_DEFINITION     NumberOfExhaustions;
} NBF_RESOURCE_DATA_DEFINITION;


//----------------------------------------------------------------------------

//
//  Nbf object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define DATAGRAMS_OFFSET            sizeof(DWORD)
#define DATAGRAM_BYTES_OFFSET       DATAGRAMS_OFFSET + sizeof(DWORD)
#define PACKETS_OFFSET              DATAGRAM_BYTES_OFFSET + \
					sizeof(LARGE_INTEGER)
#define FRAMES_OFFSET               PACKETS_OFFSET + sizeof(DWORD)
#define FRAMES_BYTES_OFFSET         FRAMES_OFFSET + sizeof(DWORD)
#define BYTES_TOTAL_OFFSET          FRAMES_BYTES_OFFSET + \
                     					sizeof(LARGE_INTEGER)
#define OPEN_CONNECTIONS_OFFSET     BYTES_TOTAL_OFFSET + \
                     					sizeof(LARGE_INTEGER)
#define CONNECTIONS_NO_RETRY_OFFSET OPEN_CONNECTIONS_OFFSET + sizeof(DWORD)
#define CONNECTIONS_RETRY_OFFSET    CONNECTIONS_NO_RETRY_OFFSET + sizeof(DWORD)
#define LOCAL_DISCONNECTS_OFFSET    CONNECTIONS_RETRY_OFFSET + sizeof(DWORD)
#define REMOTE_DISCONNECTS_OFFSET   LOCAL_DISCONNECTS_OFFSET + sizeof(DWORD)
#define LINK_FAILURES_OFFSET        REMOTE_DISCONNECTS_OFFSET + sizeof(DWORD)
#define ADAPTER_FAILURES_OFFSET     LINK_FAILURES_OFFSET + sizeof(DWORD)
#define SESSION_TIMEOUTS_OFFSET     ADAPTER_FAILURES_OFFSET + sizeof(DWORD)
#define CANCELLED_CONNECTIONS_OFFSET \
                                    SESSION_TIMEOUTS_OFFSET + sizeof(DWORD)
#define REMOTE_RESOURCE_FAILURES_OFFSET \
                                    CANCELLED_CONNECTIONS_OFFSET + sizeof(DWORD)
#define LOCAL_RESOURCE_FAILURES_OFFSET \
                                    REMOTE_RESOURCE_FAILURES_OFFSET + \
                                        sizeof(DWORD)
#define NOT_FOUND_FAILURES_OFFSET   LOCAL_RESOURCE_FAILURES_OFFSET + \
                                        sizeof(DWORD)
#define NO_LISTEN_FAILURES_OFFSET   NOT_FOUND_FAILURES_OFFSET + sizeof(DWORD)
#define DATAGRAMS_SENT_OFFSET       NO_LISTEN_FAILURES_OFFSET + \
                                        sizeof(DWORD)
#define DATAGRAM_BYTES_SENT_OFFSET  DATAGRAMS_SENT_OFFSET + sizeof(DWORD)
#define DATAGRAMS_RECEIVED_OFFSET   DATAGRAM_BYTES_SENT_OFFSET + \
					sizeof(LARGE_INTEGER)
#define DATAGRAM_BYTES_RECEIVED_OFFSET \
                                    DATAGRAMS_RECEIVED_OFFSET + sizeof(DWORD)
#define PACKETS_SENT_OFFSET         DATAGRAM_BYTES_RECEIVED_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define PACKETS_RECEIVED_OFFSET     PACKETS_SENT_OFFSET + sizeof(DWORD)
#define FRAMES_SENT_OFFSET          PACKETS_RECEIVED_OFFSET + \
                                        sizeof(DWORD)
#define FRAME_BYTES_SENT_OFFSET \
                                    FRAMES_SENT_OFFSET + sizeof(DWORD)
#define FRAMES_RECEIVED_OFFSET      FRAME_BYTES_SENT_OFFSET + \
					sizeof(LARGE_INTEGER)
#define FRAME_BYTES_RECEIVED_OFFSET \
                                    FRAMES_RECEIVED_OFFSET + \
                                        sizeof(DWORD)
#define FRAMES_RESENT_OFFSET        FRAME_BYTES_RECEIVED_OFFSET + \
					sizeof(LARGE_INTEGER)
#define FRAME_BYTES_RESENT_OFFSET \
                                    FRAMES_RESENT_OFFSET + sizeof(DWORD)
#define FRAMES_REJECTED_OFFSET      FRAME_BYTES_RESENT_OFFSET + \
					sizeof(LARGE_INTEGER)
#define FRAME_BYTES_REJECTED_OFFSET \
                                    FRAMES_REJECTED_OFFSET + sizeof(DWORD)
#define RESPONSE_TIMER_EXPIRATIONS_OFFSET \
                                    FRAME_BYTES_REJECTED_OFFSET + \
					sizeof(LARGE_INTEGER)
#define ACK_TIMER_EXPIRATIONS_OFFSET \
                                    RESPONSE_TIMER_EXPIRATIONS_OFFSET + \
                                        sizeof(DWORD)
#define MAXIMUM_SEND_WINDOW_OFFSET \
                                    ACK_TIMER_EXPIRATIONS_OFFSET + \
                                        sizeof(DWORD)
#define AVERAGE_SEND_WINDOW_OFFSET \
                                    MAXIMUM_SEND_WINDOW_OFFSET + \
                                        sizeof(DWORD)
#define PIGGYBACK_ACK_QUEUED_OFFSET \
                                    AVERAGE_SEND_WINDOW_OFFSET + \
                                        sizeof(DWORD)
#define PIGGYBACK_ACK_TIMEOUTS_OFFSET \
                                    PIGGYBACK_ACK_QUEUED_OFFSET + \
                                        sizeof(DWORD)
#define RESERVED_DWORD_1 \
                                    PIGGYBACK_ACK_TIMEOUTS_OFFSET + \
                                        sizeof(DWORD)
#define SIZE_OF_NBF_DATA            RESERVED_DWORD_1 + sizeof(DWORD)


//
//  This is the counter structure presently returned by Nbf.
//  (The followig typedef doesn't match the data structure defined
//  in datanbf.c nor the data offsets defines above.  However, the
//  offsets do match the datanbf.c data struct.)
//

typedef struct _NBF_DATA_DEFINITION {
    PERF_OBJECT_TYPE            NbfObjectType;
    PERF_COUNTER_DEFINITION     OpenConnections;
    PERF_COUNTER_DEFINITION     ConnectionsAfterNoRetry;
    PERF_COUNTER_DEFINITION     ConnectionsAfterRetry;
    PERF_COUNTER_DEFINITION     LocalDisconnects;
    PERF_COUNTER_DEFINITION     RemoteDisconnects;
    PERF_COUNTER_DEFINITION     LinkFailures;
    PERF_COUNTER_DEFINITION     AdapterFailures;
    PERF_COUNTER_DEFINITION     SessionTimeouts;
    PERF_COUNTER_DEFINITION     CancelledConnections;
    PERF_COUNTER_DEFINITION     RemoteResourceFailures;
    PERF_COUNTER_DEFINITION     LocalResourceFailures;
    PERF_COUNTER_DEFINITION     NotFoundFailures;
    PERF_COUNTER_DEFINITION     NoListenFailures;
    PERF_COUNTER_DEFINITION     Datagrams;
    PERF_COUNTER_DEFINITION     DatagramBytes;
    PERF_COUNTER_DEFINITION     DatagramsSent;
    PERF_COUNTER_DEFINITION     DatagramBytesSent;
    PERF_COUNTER_DEFINITION     DatagramsReceived;
    PERF_COUNTER_DEFINITION     DatagramBytesReceived;
    PERF_COUNTER_DEFINITION     Packets;
    PERF_COUNTER_DEFINITION     PacketsSent;
    PERF_COUNTER_DEFINITION     PacketsReceived;
    PERF_COUNTER_DEFINITION     DataFrames;
    PERF_COUNTER_DEFINITION     DataFrameBytes;
    PERF_COUNTER_DEFINITION     DataFramesSent;
    PERF_COUNTER_DEFINITION     DataFrameBytesSent;
    PERF_COUNTER_DEFINITION     DataFramesReceived;
    PERF_COUNTER_DEFINITION     DataFrameBytesReceived;
    PERF_COUNTER_DEFINITION     DataFramesResent;
    PERF_COUNTER_DEFINITION     DataFrameBytesResent;
    PERF_COUNTER_DEFINITION     DataFramesRejected;
    PERF_COUNTER_DEFINITION     DataFrameBytesRejected;
    PERF_COUNTER_DEFINITION     TotalBytes;
    PERF_COUNTER_DEFINITION     ResponseTimerExpirations;
    PERF_COUNTER_DEFINITION     AckTimerExpirations;
    PERF_COUNTER_DEFINITION     MaximumSendWindow;
    PERF_COUNTER_DEFINITION     AverageSendWindow;
    PERF_COUNTER_DEFINITION     PiggybackAckQueued;
    PERF_COUNTER_DEFINITION     PiggybackAckTimeouts;
} NBF_DATA_DEFINITION;

#pragma pack ()

#endif //_DATANBF_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\datanbt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datanbt.c

Abstract:
       
    Header file for the Nbt Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Created:

    Christos Tsollis  08/26/92 

Revision History:

--*/

#ifndef _DATANBT_H_
#define _DATANBT_H_

/****************************************************************************\
                           18 Jan 92
                           russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.   Add a define for the offset of the counter in the
   data block for the given object type.

    b.   Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.   Add Text for the Counter Name and the Text for the Help.

    b.   Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.   The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/
 
//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define NBT_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------


//
//  Nbt Connection object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define RESERVED_DWORD_VALUE        sizeof(DWORD)
#define RECEIVED_BYTES_OFFSET       RESERVED_DWORD_VALUE + sizeof(DWORD)
#define SENT_BYTES_OFFSET           RECEIVED_BYTES_OFFSET + sizeof(LARGE_INTEGER)
#define TOTAL_BYTES_OFFSET          SENT_BYTES_OFFSET + sizeof(LARGE_INTEGER)
#define SIZE_OF_NBT_DATA            TOTAL_BYTES_OFFSET + sizeof(LARGE_INTEGER)


//
//  This is the counter structure presently returned by Nbf for
//  each Connection. Each Connection is an Instance, named by the name of
//  the remote endpoint.
//

typedef struct _NBT_DATA_DEFINITION {
    PERF_OBJECT_TYPE            NbtObjectType;
    PERF_COUNTER_DEFINITION     BytesReceived;
    PERF_COUNTER_DEFINITION     BytesSent;
    PERF_COUNTER_DEFINITION     BytesTotal;
} NBT_DATA_DEFINITION;

#pragma pack ()

#endif //_DATANBT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\datanbt.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datanbt.c

Abstract:

    The file containing the constant data structures
    for the Performance Monitor data for the Nbt 
    Extensible Objects.

   This file contains a set of constant data structures which are
   currently defined for the Nbt Extensible Objects.  This is an 
   example of how other such objects could be defined.

Created:

   Christos Tsollis  08/26/92 

Revision History:

--*/
//
//
//  Include files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "datanbt.h"

//
//  Constant structure initializations
//

NBT_DATA_DEFINITION NbtDataDefinition = {

    {   sizeof(NBT_DATA_DEFINITION),
        sizeof(NBT_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        502,
        0,
        503,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(NBT_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        2,
        0,
        0
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        505,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        RECEIVED_BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        506,
        0,
        507,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        SENT_BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        509,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        TOTAL_BYTES_OFFSET
    }
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\datanbf.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datanbf.c

Abstract:
       
    a file containing the constant data structures
    for the Performance Monitor data for the Nbf
    Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the Nbf Extensible Objects.  This is an 
    example of how other such objects could be defined.

Created:

    Russ Blake  07/31/92

Revision History:

    None.

--*/
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "datanbf.h"

//
//  Constant structure initializations
//

NBF_RESOURCE_DATA_DEFINITION NbfResourceDataDefinition = {

    {   sizeof(NBF_RESOURCE_DATA_DEFINITION) + SIZE_OF_NBF_RESOURCE_DATA,
        sizeof(NBF_RESOURCE_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        494,
        0,
        495,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(NBF_RESOURCE_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        1,
        0,
        0
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        496,
        0,
        497,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        MAXIMUM_USED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        498,
        0,
        499,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        AVERAGE_USED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        500,
        0,
        501,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUMBER_OF_EXHAUSTIONS_OFFSET
    }
};




NBF_DATA_DEFINITION NbfDataDefinition = {

    {   sizeof(NBF_DATA_DEFINITION) + SIZE_OF_NBF_DATA,
        sizeof(NBF_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        492,
        0,
        493,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(NBF_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        5,     // default is Bytes Total /sec
        0,
        0
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        438,
        0,
        439,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DATAGRAMS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        440,
        0,
        441,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        DATAGRAM_BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        400,
        0,
        451,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKETS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        456,
        0,
        457,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        458,
        0,
        459,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAMES_BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        67,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        BYTES_TOTAL_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        412,
        0,
        413,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        OPEN_CONNECTIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        414,
        0,
        415,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        CONNECTIONS_NO_RETRY_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        416,
        0,
        417,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        CONNECTIONS_RETRY_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        418,
        0,
        419,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        LOCAL_DISCONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        420,
        0,
        421,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        REMOTE_DISCONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        422,
        0,
        423,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        LINK_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        424,
        0,
        425,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ADAPTER_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        426,
        0,
        427,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SESSION_TIMEOUTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        428,
        0,
        429,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        CANCELLED_CONNECTIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        430,
        0,
        431,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        REMOTE_RESOURCE_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        432,
        0,
        433,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        LOCAL_RESOURCE_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        434,
        0,
        435,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NOT_FOUND_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        436,
        0,
        437,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NO_LISTEN_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        442,
        0,
        443,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DATAGRAMS_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        444,
        0,
        445,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        DATAGRAM_BYTES_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        446,
        0,
        447,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DATAGRAMS_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        448,
        0,
        449,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        DATAGRAM_BYTES_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        452,
        0,
        453,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKETS_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        266,
        0,
        455,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKETS_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        460,
        0,
        461,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        462,
        0,
        463,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAME_BYTES_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        464,
        0,
        465,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        466,
        0,
        467,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAME_BYTES_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        468,
        0,
        469,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_RESENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        470,
        0,
        471,
        0,
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAME_BYTES_RESENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        472,
        0,
        473,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_REJECTED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        474,
        0,
        475,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAME_BYTES_REJECTED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        476,
        0,
        477,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        RESPONSE_TIMER_EXPIRATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        478,
        0,
        479,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ACK_TIMER_EXPIRATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        480,
        0,
        481,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        MAXIMUM_SEND_WINDOW_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        482,
        0,
        483,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        AVERAGE_SEND_WINDOW_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        484,
        0,
        485,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PIGGYBACK_ACK_QUEUED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        486,
        0,
        487,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIGGYBACK_ACK_TIMEOUTS_OFFSET
    }
};



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\dhcpctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    dhcpctrs.h

    Offset definitions for the DHCP Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    OpenDhcpPerformanceData procedure, they will be added to the
    DHCP Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the DHCPCTRS.DLL DLL code as well as the
    DHCPCTRS.INI definition file.  DHCPCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.

*/


#ifndef _DHCPCTRS_H_
#define _DHCPCTRS_H_

//
//  The WINS Server counter object.
//

#define DHCPCTRS_COUNTER_OBJECT           0


//
//  The individual counters.
//

#define DHCPCTRS_PACKETS_RECEIVED         2
#define DHCPCTRS_PACKETS_DUPLICATE        4
#define DHCPCTRS_PACKETS_EXPIRED          6
#define DHCPCTRS_MILLISECONDS_PER_PACKET  8
#define DHCPCTRS_PACKETS_IN_ACTIVE_QUEUE  10
#define DHCPCTRS_PACKETS_IN_PING_QUEUE    12
#define DHCPCTRS_DISCOVERS                14
#define DHCPCTRS_OFFERS                   16
#define DHCPCTRS_REQUESTS                 18
#define DHCPCTRS_INFORMS                  20
#define DHCPCTRS_ACKS                     22
#define DHCPCTRS_NACKS                    24
#define DHCPCTRS_DECLINES                 26
#define DHCPCTRS_RELEASES                 28

#endif  // _DHCPCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\datatcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datatcp.c

Abstract:
       
    Header file for the TCP/IP (Network Interface, IP, ICMP,
    TCP, UDP) Extensible Object data definitions. 

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Created:

    Christos Tsollis   08/28/92

Revision History:

--*/
#ifndef _DATATCP_H_
#define _DATATCP_H_


/****************************************************************************\
								   18 Jan 92
								   russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.	Add a define for the offset of the counter in the
	data block for the given object type.

    b.	Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.	Add Text for the Counter Name and the Text for the Help.

    b.	Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.	The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/
 
//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define TCPIP_NUM_PERF_OBJECT_TYPES 9


//----------------------------------------------------------------------------

//
//  The Network Interface object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define IF_OCTETS_OFFSET		sizeof(DWORD)
#define IF_PACKETS_OFFSET		IF_OCTETS_OFFSET + sizeof(LONGLONG)
#define IF_INPKTS_OFFSET		IF_PACKETS_OFFSET + sizeof(DWORD)
#define IF_OUTPKTS_OFFSET		IF_INPKTS_OFFSET + sizeof(DWORD)
#define IF_SPEED_OFFSET 		IF_OUTPKTS_OFFSET + sizeof(DWORD)
#define IF_INOCTETS_OFFSET 		IF_SPEED_OFFSET + sizeof(DWORD)
#define IF_INUCASTPKTS_OFFSET		IF_INOCTETS_OFFSET + sizeof(DWORD)
#define IF_INNUCASTPKTS_OFFSET		IF_INUCASTPKTS_OFFSET + sizeof(DWORD)
#define IF_INDISCARDS_OFFSET		IF_INNUCASTPKTS_OFFSET + sizeof(DWORD)
#define IF_INERRORS_OFFSET		IF_INDISCARDS_OFFSET + sizeof(DWORD)
#define IF_INUNKNOWNPROTOS_OFFSET 	IF_INERRORS_OFFSET + sizeof(DWORD)
#define IF_OUTOCTETS_OFFSET		IF_INUNKNOWNPROTOS_OFFSET +sizeof(DWORD)
#define IF_OUTUCASTPKTS_OFFSET		IF_OUTOCTETS_OFFSET + sizeof(DWORD)
#define IF_OUTNUCASTPKTS_OFFSET		IF_OUTUCASTPKTS_OFFSET + sizeof(DWORD)
#define IF_OUTDISCARDS_OFFSET		IF_OUTNUCASTPKTS_OFFSET + sizeof(DWORD)
#define IF_OUTERRORS_OFFSET		IF_OUTDISCARDS_OFFSET + sizeof(DWORD)
#define IF_OUTQLEN_OFFSET		IF_OUTERRORS_OFFSET + sizeof(DWORD)
#define SIZE_OF_IF_DATA   		IF_OUTQLEN_OFFSET + sizeof(DWORD)


//
//  This is the counter structure presently returned for
//  each Network Interface. 
//

typedef struct _NET_INTERFACE_DATA_DEFINITION {
    PERF_OBJECT_TYPE            NetInterfaceObjectType;
    PERF_COUNTER_DEFINITION     Octets;
    PERF_COUNTER_DEFINITION     Packets;
    PERF_COUNTER_DEFINITION     InPackets;
    PERF_COUNTER_DEFINITION     OutPackets;
    PERF_COUNTER_DEFINITION     Speed;
    PERF_COUNTER_DEFINITION     InOctets;
    PERF_COUNTER_DEFINITION     InUcastPackets;
    PERF_COUNTER_DEFINITION     InNonUcastPackets;
    PERF_COUNTER_DEFINITION     InDiscards;
    PERF_COUNTER_DEFINITION     InErrors;
    PERF_COUNTER_DEFINITION     InUnknownProtos;
    PERF_COUNTER_DEFINITION     OutOctets;
    PERF_COUNTER_DEFINITION     OutUcastPackets;
    PERF_COUNTER_DEFINITION     OutNonUcastPackets;
    PERF_COUNTER_DEFINITION     OutDiscards;
    PERF_COUNTER_DEFINITION     OutErrors;
    PERF_COUNTER_DEFINITION     OutQueueLength;
} NET_INTERFACE_DATA_DEFINITION;


//----------------------------------------------------------------------------

//
//  IP object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define IP_DATAGRAMS_OFFSET			sizeof(DWORD)
#define IP_INRECEIVES_OFFSET		IP_DATAGRAMS_OFFSET + sizeof(DWORD)
#define IP_INHDRERRORS_OFFSET		IP_INRECEIVES_OFFSET + sizeof(DWORD)
#define IP_INADDRERRORS_OFFSET		IP_INHDRERRORS_OFFSET + sizeof(DWORD)
#define IP_FORWDATAGRAMS_OFFSET		IP_INADDRERRORS_OFFSET + sizeof(DWORD)
#define IP_INUNKNOWNPROTOS_OFFSET	IP_FORWDATAGRAMS_OFFSET + sizeof(DWORD)
#define IP_INDISCARDS_OFFSET		IP_INUNKNOWNPROTOS_OFFSET +sizeof(DWORD)
#define IP_INDELIVERS_OFFSET		IP_INDISCARDS_OFFSET + sizeof(DWORD)
#define IP_OUTREQUESTS_OFFSET		IP_INDELIVERS_OFFSET + sizeof(DWORD)
#define IP_OUTDISCARDS_OFFSET		IP_OUTREQUESTS_OFFSET + sizeof(DWORD)
#define IP_OUTNOROUTES_OFFSET		IP_OUTDISCARDS_OFFSET + sizeof(DWORD)
#define IP_REASMREQDS_OFFSET		IP_OUTNOROUTES_OFFSET + sizeof(DWORD)
#define IP_REASMOKS_OFFSET			IP_REASMREQDS_OFFSET + sizeof(DWORD)
#define IP_REASMFAILS_OFFSET		IP_REASMOKS_OFFSET + sizeof(DWORD)
#define IP_FRAGOKS_OFFSET			IP_REASMFAILS_OFFSET + sizeof(DWORD)
#define IP_FRAGFAILS_OFFSET			IP_FRAGOKS_OFFSET + sizeof(DWORD)
#define IP_FRAGCREATES_OFFSET		IP_FRAGFAILS_OFFSET + sizeof(DWORD)
#define SIZE_OF_IP_DATA				IP_FRAGCREATES_OFFSET + sizeof(DWORD)


//
// This is the counter structure presently returned for IP.
//


typedef struct _IP_DATA_DEFINITION {
    PERF_OBJECT_TYPE            IPObjectType;
    PERF_COUNTER_DEFINITION     Datagrams;
    PERF_COUNTER_DEFINITION     InReceives;
    PERF_COUNTER_DEFINITION     InHeaderErrors;
    PERF_COUNTER_DEFINITION     InAddrErrors;
    PERF_COUNTER_DEFINITION     ForwardDatagrams;
    PERF_COUNTER_DEFINITION     InUnknownProtos;
    PERF_COUNTER_DEFINITION     InDiscards;
    PERF_COUNTER_DEFINITION     InDelivers;
    PERF_COUNTER_DEFINITION     OutRequests;
    PERF_COUNTER_DEFINITION     OutDiscards;
    PERF_COUNTER_DEFINITION     OutNoRoutes;
    PERF_COUNTER_DEFINITION     ReassemblyRequireds;
    PERF_COUNTER_DEFINITION     ReassemblyOKs;
    PERF_COUNTER_DEFINITION     ReassemblyFails;
    PERF_COUNTER_DEFINITION     FragmentOKs;
    PERF_COUNTER_DEFINITION     FragmentFails;
    PERF_COUNTER_DEFINITION     FragmentCreates;
} IP_DATA_DEFINITION;



//----------------------------------------------------------------------------

//
//  ICMP object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define ICMP_MESSAGES_OFFSET		sizeof(DWORD)
#define ICMP_INMSGS_OFFSET			ICMP_MESSAGES_OFFSET + sizeof(DWORD)
#define ICMP_INERRORS_OFFSET		ICMP_INMSGS_OFFSET + sizeof(DWORD)
#define ICMP_INDESTUNREACHS_OFFSET	ICMP_INERRORS_OFFSET + sizeof(DWORD)
#define ICMP_INTIMEEXCDS_OFFSET		ICMP_INDESTUNREACHS_OFFSET+sizeof(DWORD)
#define ICMP_INPARMPROBS_OFFSET		ICMP_INTIMEEXCDS_OFFSET + sizeof(DWORD)
#define ICMP_INSRCQUENCHS_OFFSET	ICMP_INPARMPROBS_OFFSET + sizeof(DWORD)
#define ICMP_INREDIRECTS_OFFSET		ICMP_INSRCQUENCHS_OFFSET + sizeof(DWORD)
#define ICMP_INECHOS_OFFSET			ICMP_INREDIRECTS_OFFSET + sizeof(DWORD)
#define ICMP_INECHOREPS_OFFSET		ICMP_INECHOS_OFFSET + sizeof(DWORD)
#define ICMP_INTIMESTAMPS_OFFSET	ICMP_INECHOREPS_OFFSET + sizeof(DWORD)
#define ICMP_INTIMESTAMPREPS_OFFSET	ICMP_INTIMESTAMPS_OFFSET + sizeof(DWORD)
#define ICMP_INADDRMASKS_OFFSET		ICMP_INTIMESTAMPREPS_OFFSET + \
					sizeof(DWORD)
#define ICMP_INADDRMASKREPS_OFFSET	ICMP_INADDRMASKS_OFFSET + sizeof(DWORD)
#define ICMP_OUTMSGS_OFFSET			ICMP_INADDRMASKREPS_OFFSET+sizeof(DWORD)
#define ICMP_OUTERRORS_OFFSET		ICMP_OUTMSGS_OFFSET + sizeof(DWORD)
#define ICMP_OUTDESTUNREACHS_OFFSET	ICMP_OUTERRORS_OFFSET + sizeof(DWORD)
#define ICMP_OUTTIMEEXCDS_OFFSET	ICMP_OUTDESTUNREACHS_OFFSET + \
					sizeof(DWORD)
#define ICMP_OUTPARMPROBS_OFFSET	ICMP_OUTTIMEEXCDS_OFFSET + sizeof(DWORD)
#define ICMP_OUTSRCQUENCHS_OFFSET	ICMP_OUTPARMPROBS_OFFSET + sizeof(DWORD)
#define ICMP_OUTREDIRECTS_OFFSET	ICMP_OUTSRCQUENCHS_OFFSET+ sizeof(DWORD)
#define ICMP_OUTECHOS_OFFSET		ICMP_OUTREDIRECTS_OFFSET + sizeof(DWORD)
#define ICMP_OUTECHOREPS_OFFSET		ICMP_OUTECHOS_OFFSET + sizeof(DWORD)
#define ICMP_OUTTIMESTAMPS_OFFSET	ICMP_OUTECHOREPS_OFFSET + sizeof(DWORD)
#define ICMP_OUTTIMESTAMPREPS_OFFSET	ICMP_OUTTIMESTAMPS_OFFSET+ sizeof(DWORD)
#define ICMP_OUTADDRMASKS_OFFSET	ICMP_OUTTIMESTAMPREPS_OFFSET + \
					sizeof(DWORD)
#define ICMP_OUTADDRMASKREPS_OFFSET	ICMP_OUTADDRMASKS_OFFSET + sizeof(DWORD)
#define SIZE_OF_ICMP_DATA			ICMP_OUTADDRMASKREPS_OFFSET + \
					sizeof(DWORD)


//
// This is the counter structure presently returned for ICMP.
//


typedef struct _ICMP_DATA_DEFINITION {
    PERF_OBJECT_TYPE            ICMPObjectType;
    PERF_COUNTER_DEFINITION     Messages;
    PERF_COUNTER_DEFINITION     InMessages;
    PERF_COUNTER_DEFINITION     InErrors;
    PERF_COUNTER_DEFINITION     InDestinationUnreachables;
    PERF_COUNTER_DEFINITION     InTimeExceededs;
    PERF_COUNTER_DEFINITION     InParameterProblems;
    PERF_COUNTER_DEFINITION     InSourceQuenchs;
    PERF_COUNTER_DEFINITION     InRedirects;
    PERF_COUNTER_DEFINITION     InEchos;
    PERF_COUNTER_DEFINITION     InEchoReplys;
    PERF_COUNTER_DEFINITION     InTimestamps;
    PERF_COUNTER_DEFINITION     InTimestampReplys;
    PERF_COUNTER_DEFINITION     InAddressMasks;
    PERF_COUNTER_DEFINITION     InAddressMaskReplys;
    PERF_COUNTER_DEFINITION     OutMessages;
    PERF_COUNTER_DEFINITION     OutErrors;
    PERF_COUNTER_DEFINITION     OutDestinationUnreachables;
    PERF_COUNTER_DEFINITION     OutTimeExceededs;
    PERF_COUNTER_DEFINITION     OutParameterProblems;
    PERF_COUNTER_DEFINITION     OutSourceQuenchs;
    PERF_COUNTER_DEFINITION     OutRedirects;
    PERF_COUNTER_DEFINITION     OutEchos;
    PERF_COUNTER_DEFINITION     OutEchoReplys;
    PERF_COUNTER_DEFINITION     OutTimestamps;
    PERF_COUNTER_DEFINITION     OutTimestampReplys;
    PERF_COUNTER_DEFINITION     OutAddressMasks;
    PERF_COUNTER_DEFINITION     OutAddressMaskReplys;
} ICMP_DATA_DEFINITION;




//----------------------------------------------------------------------------

//
//  TCP object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define TCP_SEGMENTS_OFFSET			sizeof(DWORD)
#define TCP_CURRESTAB_OFFSET		TCP_SEGMENTS_OFFSET + sizeof(DWORD)
#define TCP_ACTIVEOPENS_OFFSET		TCP_CURRESTAB_OFFSET + sizeof(DWORD)
#define TCP_PASSIVEOPENS_OFFSET		TCP_ACTIVEOPENS_OFFSET + sizeof(DWORD)
#define TCP_ATTEMPTFAILS_OFFSET		TCP_PASSIVEOPENS_OFFSET + sizeof(DWORD)
#define TCP_ESTABRESETS_OFFSET		TCP_ATTEMPTFAILS_OFFSET + sizeof(DWORD)
#define TCP_INSEGS_OFFSET			TCP_ESTABRESETS_OFFSET + sizeof(DWORD)
#define TCP_OUTSEGS_OFFSET			TCP_INSEGS_OFFSET + sizeof(DWORD)
#define TCP_RETRANSSEGS_OFFSET		TCP_OUTSEGS_OFFSET + sizeof(DWORD)
#define SIZE_OF_TCP_DATA			TCP_RETRANSSEGS_OFFSET + sizeof(DWORD)


//
// This is the counter structure presently returned for TCP.
//


typedef struct _TCP_DATA_DEFINITION {
    PERF_OBJECT_TYPE            TCPObjectType;
    PERF_COUNTER_DEFINITION     Segments;
    PERF_COUNTER_DEFINITION     CurrentlyEstablished;
    PERF_COUNTER_DEFINITION     ActiveOpens;
    PERF_COUNTER_DEFINITION     PassiveOpens;
    PERF_COUNTER_DEFINITION     AttemptFailures;
    PERF_COUNTER_DEFINITION     EstabResets;
    PERF_COUNTER_DEFINITION     InSegments;
    PERF_COUNTER_DEFINITION     OutSegments;
    PERF_COUNTER_DEFINITION     RetransmittedSegments;
} TCP_DATA_DEFINITION;


//----------------------------------------------------------------------------

//
//  UDP object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define UDP_DATAGRAMS_OFFSET		sizeof(DWORD)
#define UDP_INDATAGRAMS_OFFSET		UDP_DATAGRAMS_OFFSET + sizeof(DWORD)
#define UDP_NOPORTS_OFFSET			UDP_INDATAGRAMS_OFFSET + sizeof(DWORD)
#define UDP_INERRORS_OFFSET			UDP_NOPORTS_OFFSET + sizeof(DWORD)
#define UDP_OUTDATAGRAMS_OFFSET		UDP_INERRORS_OFFSET + sizeof(DWORD)
#define SIZE_OF_UDP_DATA			UDP_OUTDATAGRAMS_OFFSET + sizeof(DWORD)



//
// This is the counter structure presently returned for UDP.
//


typedef struct _UDP_DATA_DEFINITION {
    PERF_OBJECT_TYPE            UDPObjectType;
    PERF_COUNTER_DEFINITION     Datagrams;
    PERF_COUNTER_DEFINITION     InDatagrams;
    PERF_COUNTER_DEFINITION     NoPorts;
    PERF_COUNTER_DEFINITION     InErrors;
    PERF_COUNTER_DEFINITION     OutDatagrams;
} UDP_DATA_DEFINITION;

//----------------------------------------------------------------------------

//
//  TCPv6 object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define TCP6_SEGMENTS_OFFSET		sizeof(DWORD)
#define TCP6_CURRESTAB_OFFSET		TCP6_SEGMENTS_OFFSET + sizeof(DWORD)
#define TCP6_ACTIVEOPENS_OFFSET		TCP6_CURRESTAB_OFFSET + sizeof(DWORD)
#define TCP6_PASSIVEOPENS_OFFSET	TCP6_ACTIVEOPENS_OFFSET + sizeof(DWORD)
#define TCP6_ATTEMPTFAILS_OFFSET	TCP6_PASSIVEOPENS_OFFSET + sizeof(DWORD)
#define TCP6_ESTABRESETS_OFFSET		TCP6_ATTEMPTFAILS_OFFSET + sizeof(DWORD)
#define TCP6_INSEGS_OFFSET			TCP6_ESTABRESETS_OFFSET + sizeof(DWORD)
#define TCP6_OUTSEGS_OFFSET			TCP6_INSEGS_OFFSET + sizeof(DWORD)
#define TCP6_RETRANSSEGS_OFFSET		TCP6_OUTSEGS_OFFSET + sizeof(DWORD)
#define SIZE_OF_TCP6_DATA			TCP6_RETRANSSEGS_OFFSET + sizeof(DWORD)


//
// This is the counter structure presently returned for TCPv6.
//


typedef struct _TCP6_DATA_DEFINITION {
    PERF_OBJECT_TYPE            TCP6ObjectType;
    PERF_COUNTER_DEFINITION     Segments;
    PERF_COUNTER_DEFINITION     CurrentlyEstablished;
    PERF_COUNTER_DEFINITION     ActiveOpens;
    PERF_COUNTER_DEFINITION     PassiveOpens;
    PERF_COUNTER_DEFINITION     AttemptFailures;
    PERF_COUNTER_DEFINITION     EstabResets;
    PERF_COUNTER_DEFINITION     InSegments;
    PERF_COUNTER_DEFINITION     OutSegments;
    PERF_COUNTER_DEFINITION     RetransmittedSegments;
} TCP6_DATA_DEFINITION;


//----------------------------------------------------------------------------

//
//  UDPv6 object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define UDP6_DATAGRAMS_OFFSET		sizeof(DWORD)
#define UDP6_INDATAGRAMS_OFFSET		UDP6_DATAGRAMS_OFFSET + sizeof(DWORD)
#define UDP6_NOPORTS_OFFSET			UDP6_INDATAGRAMS_OFFSET + sizeof(DWORD)
#define UDP6_INERRORS_OFFSET		UDP6_NOPORTS_OFFSET + sizeof(DWORD)
#define UDP6_OUTDATAGRAMS_OFFSET	UDP6_INERRORS_OFFSET + sizeof(DWORD)
#define SIZE_OF_UDP6_DATA			UDP6_OUTDATAGRAMS_OFFSET + sizeof(DWORD)


//
// This is the counter structure presently returned for UDPv6.
//


typedef struct _UDP6_DATA_DEFINITION {
    PERF_OBJECT_TYPE            UDP6ObjectType;
    PERF_COUNTER_DEFINITION     Datagrams;
    PERF_COUNTER_DEFINITION     InDatagrams;
    PERF_COUNTER_DEFINITION     NoPorts;
    PERF_COUNTER_DEFINITION     InErrors;
    PERF_COUNTER_DEFINITION     OutDatagrams;
} UDP6_DATA_DEFINITION;

//----------------------------------------------------------------------------

//
//  IPv6 object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define IP6_DATAGRAMS_OFFSET		sizeof(DWORD)
#define IP6_INRECEIVES_OFFSET		IP6_DATAGRAMS_OFFSET + sizeof(DWORD)
#define IP6_INHDRERRORS_OFFSET		IP6_INRECEIVES_OFFSET + sizeof(DWORD)
#define IP6_INADDRERRORS_OFFSET		IP6_INHDRERRORS_OFFSET + sizeof(DWORD)
#define IP6_FORWDATAGRAMS_OFFSET	IP6_INADDRERRORS_OFFSET + sizeof(DWORD)
#define IP6_INUNKNOWNPROTOS_OFFSET	IP6_FORWDATAGRAMS_OFFSET + sizeof(DWORD)
#define IP6_INDISCARDS_OFFSET		IP6_INUNKNOWNPROTOS_OFFSET +sizeof(DWORD)
#define IP6_INDELIVERS_OFFSET		IP6_INDISCARDS_OFFSET + sizeof(DWORD)
#define IP6_OUTREQUESTS_OFFSET		IP6_INDELIVERS_OFFSET + sizeof(DWORD)
#define IP6_OUTDISCARDS_OFFSET		IP6_OUTREQUESTS_OFFSET + sizeof(DWORD)
#define IP6_OUTNOROUTES_OFFSET		IP6_OUTDISCARDS_OFFSET + sizeof(DWORD)
#define IP6_REASMREQDS_OFFSET		IP6_OUTNOROUTES_OFFSET + sizeof(DWORD)
#define IP6_REASMOKS_OFFSET			IP6_REASMREQDS_OFFSET + sizeof(DWORD)
#define IP6_REASMFAILS_OFFSET		IP6_REASMOKS_OFFSET + sizeof(DWORD)
#define IP6_FRAGOKS_OFFSET			IP6_REASMFAILS_OFFSET + sizeof(DWORD)
#define IP6_FRAGFAILS_OFFSET		IP6_FRAGOKS_OFFSET + sizeof(DWORD)
#define IP6_FRAGCREATES_OFFSET		IP6_FRAGFAILS_OFFSET + sizeof(DWORD)
#define SIZE_OF_IP6_DATA			IP6_FRAGCREATES_OFFSET + sizeof(DWORD)


//
// This is the counter structure presently returned for IPv6.
//


typedef struct _IP6_DATA_DEFINITION {
    PERF_OBJECT_TYPE            IP6ObjectType;
    PERF_COUNTER_DEFINITION     Datagrams;
    PERF_COUNTER_DEFINITION     InReceives;
    PERF_COUNTER_DEFINITION     InHeaderErrors;
    PERF_COUNTER_DEFINITION     InAddrErrors;
    PERF_COUNTER_DEFINITION     ForwardDatagrams;
    PERF_COUNTER_DEFINITION     InUnknownProtos;
    PERF_COUNTER_DEFINITION     InDiscards;
    PERF_COUNTER_DEFINITION     InDelivers;
    PERF_COUNTER_DEFINITION     OutRequests;
    PERF_COUNTER_DEFINITION     OutDiscards;
    PERF_COUNTER_DEFINITION     OutNoRoutes;
    PERF_COUNTER_DEFINITION     ReassemblyRequireds;
    PERF_COUNTER_DEFINITION     ReassemblyOKs;
    PERF_COUNTER_DEFINITION     ReassemblyFails;
    PERF_COUNTER_DEFINITION     FragmentOKs;
    PERF_COUNTER_DEFINITION     FragmentFails;
    PERF_COUNTER_DEFINITION     FragmentCreates;
} IP6_DATA_DEFINITION;


//----------------------------------------------------------------------------

//
//  ICMPv6 object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define ICMP6_MESSAGES_OFFSET		        sizeof(DWORD)
#define ICMP6_INMSGS_OFFSET			        ICMP6_MESSAGES_OFFSET + sizeof(DWORD)
#define ICMP6_INERRORS_OFFSET		        ICMP6_INMSGS_OFFSET + sizeof(DWORD)
#define ICMP6_INDSTUNREACH_OFFSET           ICMP6_INERRORS_OFFSET + sizeof(DWORD)
#define ICMP6_INPACKETTOOBIG_OFFSET         ICMP6_INDSTUNREACH_OFFSET + sizeof(DWORD)
#define ICMP6_INTIMEEXCEEDED_OFFSET         ICMP6_INPACKETTOOBIG_OFFSET + sizeof(DWORD)
#define ICMP6_INPARAMPROB_OFFSET            ICMP6_INTIMEEXCEEDED_OFFSET + sizeof(DWORD)
#define ICMP6_INECHOREQUEST_OFFSET          ICMP6_INPARAMPROB_OFFSET + sizeof(DWORD)
#define ICMP6_INECHOREPLY_OFFSET            ICMP6_INECHOREQUEST_OFFSET + sizeof(DWORD)
#define ICMP6_INMEMBERSHIPQUERY_OFFSET      ICMP6_INECHOREPLY_OFFSET + sizeof(DWORD)
#define ICMP6_INMEMBERSHIPREPORT_OFFSET     ICMP6_INMEMBERSHIPQUERY_OFFSET + sizeof(DWORD)
#define ICMP6_INMEMBERSHIPREDUCTION_OFFSET  ICMP6_INMEMBERSHIPREPORT_OFFSET + sizeof(DWORD)
#define ND_INROUTERSOLICIT_OFFSET           ICMP6_INMEMBERSHIPREDUCTION_OFFSET + sizeof(DWORD)
#define ND_INROUTERADVERT_OFFSET            ND_INROUTERSOLICIT_OFFSET + sizeof(DWORD)
#define ND_INNEIGHBORSOLICIT_OFFSET         ND_INROUTERADVERT_OFFSET + sizeof(DWORD)
#define ND_INNEIGHBORADVERT_OFFSET          ND_INNEIGHBORSOLICIT_OFFSET + sizeof(DWORD)
#define ND_INREDIRECT_OFFSET                ND_INNEIGHBORADVERT_OFFSET + sizeof(DWORD)
#define ICMP6_OUTMSGS_OFFSET		        ND_INREDIRECT_OFFSET +sizeof(DWORD)
#define ICMP6_OUTERRORS_OFFSET		        ICMP6_OUTMSGS_OFFSET + sizeof(DWORD)
#define ICMP6_OUTDSTUNREACH_OFFSET          ICMP6_OUTERRORS_OFFSET + sizeof(DWORD)
#define ICMP6_OUTPACKETTOOBIG_OFFSET        ICMP6_OUTDSTUNREACH_OFFSET + sizeof(DWORD)
#define ICMP6_OUTTIMEEXCEEDED_OFFSET        ICMP6_OUTPACKETTOOBIG_OFFSET + sizeof(DWORD)
#define ICMP6_OUTPARAMPROB_OFFSET           ICMP6_OUTTIMEEXCEEDED_OFFSET + sizeof(DWORD)
#define ICMP6_OUTECHOREQUEST_OFFSET         ICMP6_OUTPARAMPROB_OFFSET + sizeof(DWORD)
#define ICMP6_OUTECHOREPLY_OFFSET           ICMP6_OUTECHOREQUEST_OFFSET + sizeof(DWORD)
#define ICMP6_OUTMEMBERSHIPQUERY_OFFSET     ICMP6_OUTECHOREPLY_OFFSET + sizeof(DWORD)
#define ICMP6_OUTMEMBERSHIPREPORT_OFFSET    ICMP6_OUTMEMBERSHIPQUERY_OFFSET + sizeof(DWORD)
#define ICMP6_OUTMEMBERSHIPREDUCTION_OFFSET ICMP6_OUTMEMBERSHIPREPORT_OFFSET + sizeof(DWORD)
#define ND_OUTROUTERSOLICIT_OFFSET          ICMP6_OUTMEMBERSHIPREDUCTION_OFFSET + sizeof(DWORD)
#define ND_OUTROUTERADVERT_OFFSET           ND_OUTROUTERSOLICIT_OFFSET + sizeof(DWORD)
#define ND_OUTNEIGHBORSOLICIT_OFFSET        ND_OUTROUTERADVERT_OFFSET + sizeof(DWORD)
#define ND_OUTNEIGHBORADVERT_OFFSET         ND_OUTNEIGHBORSOLICIT_OFFSET + sizeof(DWORD)
#define ND_OUTREDIRECT_OFFSET               ND_OUTNEIGHBORADVERT_OFFSET + sizeof(DWORD)
#define SIZE_OF_ICMP6_DATA			        ND_OUTREDIRECT_OFFSET + sizeof(DWORD)


//
// This is the counter structure presently returned for ICMPv6.
//


typedef struct _ICMP6_DATA_DEFINITION {
    PERF_OBJECT_TYPE            ICMP6ObjectType;
    PERF_COUNTER_DEFINITION     Messages;
    PERF_COUNTER_DEFINITION     InMessages;
    PERF_COUNTER_DEFINITION     InErrors;
    PERF_COUNTER_DEFINITION     InDestinationUnreachables;
	PERF_COUNTER_DEFINITION     InPacketSizeExceededs;
	PERF_COUNTER_DEFINITION     InTimeExceededs;
	PERF_COUNTER_DEFINITION     InParametersProblems;
	PERF_COUNTER_DEFINITION     InEchos;
	PERF_COUNTER_DEFINITION     InEchoReplys;
	PERF_COUNTER_DEFINITION     InMembershipQuerys;
	PERF_COUNTER_DEFINITION     InMembershipReports;
	PERF_COUNTER_DEFINITION     InMembershipReductions;
    PERF_COUNTER_DEFINITION     InRouterSolicits;
	PERF_COUNTER_DEFINITION     InRouterAdverts;
	PERF_COUNTER_DEFINITION     InNeighborSolicits;
	PERF_COUNTER_DEFINITION     InNeighborAdverts;
	PERF_COUNTER_DEFINITION     InRedirects;
    PERF_COUNTER_DEFINITION     OutMessages;
    PERF_COUNTER_DEFINITION     OutErrors;
	PERF_COUNTER_DEFINITION     OutDestinationUnreachables;
	PERF_COUNTER_DEFINITION     OutPacketSizeExceededs;
	PERF_COUNTER_DEFINITION     OutTimeExceededs;
	PERF_COUNTER_DEFINITION     OutParametersProblems;
	PERF_COUNTER_DEFINITION     OutEchos;
	PERF_COUNTER_DEFINITION     OutEchoReplys;
	PERF_COUNTER_DEFINITION     OutMembershipQuerys;
	PERF_COUNTER_DEFINITION     OutMembershipReports;
	PERF_COUNTER_DEFINITION     OutMembershipReductions;
	PERF_COUNTER_DEFINITION     OutRouterSolicits;
	PERF_COUNTER_DEFINITION     OutRouterAdverts;
	PERF_COUNTER_DEFINITION     OutNeighborSolicits;
	PERF_COUNTER_DEFINITION     OutNeighborAdverts;
	PERF_COUNTER_DEFINITION     OutRedirects;

} ICMP6_DATA_DEFINITION;

#pragma pack ()

#endif  //_DATATCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\oidfile.c ===
char *lpOutputFileName = "";

//
// CODEWORK - use snmpapi.dll instead of importing.
//


#include "..\..\net\snmp\tools\mibcc\oidconv.c"


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\perfdhcp.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfdhcp.c

    This file implements the Extensible Performance Objects for
    the DHCP Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.
        RameshV     05-Aug-1998 Adapted to DHCP Server service.
                                Used Shared memory instead of LPC

*/

#define UNICODE 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winperf.h>
#include <lm.h>

#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "dhcpctrs.h"
#include "perfmsg.h"
#include "perfutil.h"
#include "datadhcp.h"
#include "perfctr.h"

#pragma warning (disable : 4201)
#include <dhcpapi.h>
#pragma warning (default : 4201)

//
//  Private globals.
//

LONG    cOpens    = 0;                 // Active "opens" reference count.
BOOL    fInitOK   = FALSE;             // TRUE if DLL initialized OK.
BOOL    sfLogOpen = FALSE;             //indicates whether the log is
                                       //open or closed

BOOL    sfErrReported = FALSE;        //to prevent the same error from being
                                      //logged continuously

#define LOCAL_SERVER                  TEXT("127.0.0.1")

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenDhcpPerformanceData;
PM_COLLECT_PROC CollectDhcpPerformanceData;
PM_CLOSE_PROC   CloseDhcpPerformanceData;

//
//  Private helper functions
//
LPDHCP_PERF_STATS SharedMem;
HANDLE            ShSegment             = NULL;
BOOL              fSharedMemInitialized = FALSE;

DWORD
InitSharedMem(
    VOID
)
{
    ULONG Error = ERROR_SUCCESS;

    if( FALSE == fSharedMemInitialized ) {
        // create named temporary mapping file
        SharedMem = NULL;
        ShSegment = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(DHCP_PERF_STATS),
            (LPCWSTR)DHCPCTR_SHARED_MEM_NAME
        );

        if( NULL != ShSegment ) {
            // we have a file now map a view into it
            SharedMem = (LPVOID) MapViewOfFile(
                ShSegment,
                FILE_MAP_READ,
                0,
                0,
                sizeof(DHCP_PERF_STATS)
            );

            if( NULL != SharedMem ) {
                fSharedMemInitialized = TRUE;
            } else {
                // unable to map view
                Error = GetLastError();
                CloseHandle(ShSegment);
                ShSegment = NULL;
                // SharedMem is NULL;
            }
        } else {
            // unable to create file mapping
            Error = GetLastError();
            // ShSegment is NULL;
            // SharedMem is NULL;
        }
    } else {
        // already initialized so continue
    }

    return Error;
}

VOID
CleanupSharedMem(
    VOID
)
{
    if( FALSE == fSharedMemInitialized ) return;

    if( NULL != SharedMem ) UnmapViewOfFile( SharedMem );
    if( NULL != ShSegment ) CloseHandle( ShSegment );

    SharedMem = NULL;
    ShSegment = NULL;
    fSharedMemInitialized = FALSE;
}

//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenDhcpPPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        Pradeepb     20-July-1993 Created.`
        RameshV      05-Aug-1998 Adapted for DHCP.

********************************************************************/
DWORD OpenDhcpPerformanceData( LPWSTR lpDeviceNames )
{
    DWORD err  = NO_ERROR;
    DWORD dwFirstCounter = 0;
    DWORD dwFirstHelp = 0;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    UNREFERENCED_PARAMETER (lpDeviceNames);

    if( !fInitOK )
    {
        PERF_COUNTER_DEFINITION * pctr;
        DWORD                     i;
        HKEY                      DhcpKey;

        REPORT_INFORMATION( DHCP_OPEN_ENTERED, LOG_VERBOSE );

        //
        //  This is the *first* open.
        //

        err = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            (LPCWSTR)L"System\\CurrentControlSet\\Services\\DHCPServer\\Performance",
            0,
            KEY_READ,
            &DhcpKey
        );

        if( ERROR_SUCCESS == err ) {
            ULONG dwSize = sizeof(dwFirstCounter);
            err = RegQueryValueExW(
                DhcpKey,
                (LPCWSTR)L"First Counter",
                NULL,
                NULL,
                (LPBYTE)&dwFirstCounter,
                &dwSize
            );
            RegCloseKey(DhcpKey);
        }

        if (err == ERROR_SUCCESS) {
            // first help index is 1 more than first counter index as LODCTR installs it.
            dwFirstHelp = dwFirstCounter + 1;

            err = InitSharedMem();
            if( ERROR_SUCCESS != err ) return err;

            if (!MonOpenEventLog(APP_NAME))
            {
                sfLogOpen = TRUE;
            }

            if( ERROR_SUCCESS == err ) {
                //
                //  Update the object & counter name & help indicies.
                //

                DhcpDataDataDefinition.ObjectType.ObjectNameTitleIndex
                    += dwFirstCounter;
                DhcpDataDataDefinition.ObjectType.ObjectHelpTitleIndex
                    += dwFirstHelp;

                pctr = &DhcpDataDataDefinition.PacketsReceived;

                for( i = 0 ; i < NUMBER_OF_DHCPDATA_COUNTERS ; i++ )
                {
                    pctr->CounterNameTitleIndex += dwFirstCounter;
                    pctr->CounterHelpTitleIndex += dwFirstHelp;
                    pctr++;
                }

                //
                //  Remember that we initialized OK.
                //

                fInitOK = TRUE;
            }
        } else {
            // if here, then either the perf key or the counter strings
            // have not been installed so set the error code.
            err = DHCP_NOT_INSTALLED;
            REPORT_WARNING( DHCP_NOT_INSTALLED, LOG_DEBUG );
        }

    }


    //
    //  Bump open counter.
    //

    if( err == NO_ERROR )
    {
        InterlockedIncrement(&cOpens);
    }

    //
    // if sfLogOpen is FALSE, it means that all threads we closed the
    // event log in CloseDHCPPerformanceData
    //

    if (!sfLogOpen)
    {
       MonOpenEventLog(APP_NAME);
    }

    if( 0 == err ) {
        REPORT_INFORMATION( DHCP_OPEN_SUCCESS, LOG_DEBUG );
    } else {
        REPORT_INFORMATION( DHCP_OPEN_FAILURE, LOG_DEBUG );
    }

    if (DHCP_NOT_INSTALLED == err) {
        // sanitize the return value to avoid spamming the event log
        err = ERROR_SUCCESS;
        // this will prevent perflib from generating an error and
        // since the fInitOK flag is still FLASE, all calls to the collect
        // function will return no data.
        // however, the DLL will still be loaded and the functions called
        // even though there's no real point.
        // returning an error code, however will spam the event log with
        // error messages so this is the quitest way to go.
    }

    return err;

}   // OpenDHCPPerformanceData

/*******************************************************************

    NAME:       CollectDhcpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectDhcpPerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    DWORD                    dwQueryType;
    ULONG                    cbRequired;
    DWORD                    *pdwCounter;
    DHCPDATA_COUNTER_BLOCK   *pCounterBlock;
    DHCPDATA_DATA_DEFINITION *pDhcpDataDataDefinition;
    DWORD          	     Status;
    DHCP_PERF_STATS      PerfStats;

    //
    //  No need to even try if we failed to open...
    //

    if( NULL == lpValueName ) {
        REPORT_INFORMATION( DHCP_COLLECT_ENTERED, LOG_VERBOSE );
    } else {
        REPORT_INFORMATION_DATA(
            DHCP_COLLECT_ENTERED, LOG_VERBOSE,
            (LPVOID) lpValueName, (DWORD)(wcslen(lpValueName)*sizeof(WCHAR))
        );
    }

    if( !fInitOK )
    {
        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if( dwQueryType == QUERY_FOREIGN )
    {
        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        DhcpDataDataDefinition.ObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  See if there's enough space.
    //

    pDhcpDataDataDefinition = (DHCPDATA_DATA_DEFINITION *)*lppData;

    cbRequired = sizeof(DHCPDATA_DATA_DEFINITION) +
				DHCPDATA_SIZE_OF_PERFORMANCE_DATA;

    if( *lpcbTotalBytes < cbRequired )
    {
        DWORD Diff = (cbRequired - *lpcbTotalBytes );

        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        REPORT_INFORMATION_DATA(
            DHCP_COLLECT_NO_MEM, LOG_VERBOSE,
            (PVOID) &Diff, sizeof(Diff) );

        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pDhcpDataDataDefinition,
             &DhcpDataDataDefinition,
             sizeof(DHCPDATA_DATA_DEFINITION) );

    //
    //  Try to retrieve the data.
    //

    if( NULL == SharedMem ) {
        Status = ERROR_INVALID_HANDLE;
    } else {
        Status = ERROR_SUCCESS;
    }

    if( Status != ERROR_SUCCESS )
    {
        //
        // if we haven't logged the error yet, log it
        //
        if (!sfErrReported)
        {
            REPORT_ERROR(DHCP_COLLECT_ERR, LOG_USER);
            sfErrReported = TRUE;
        }

        //
        //  Error retrieving statistics.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    //
    // Ahaa, we got the statistics, reset flag if set
    //
    if (sfErrReported)
    {
       sfErrReported = FALSE;
    }
    //
    //  Format the DHCP Server data.
    //

    pCounterBlock = (DHCPDATA_COUNTER_BLOCK *)( pDhcpDataDataDefinition + 1 );

    pCounterBlock->PerfCounterBlock.ByteLength =
				DHCPDATA_SIZE_OF_PERFORMANCE_DATA;

    //
    //  Get the pointer to the first (DWORD) counter.  This
    //  pointer *must* be quadword aligned.
    //

    pdwCounter = (DWORD *)( pCounterBlock + 1 );

    ASSERT( ( (DWORD_PTR)pdwCounter & 3 ) == 0 );

    //
    //  Move the DWORDs into the buffer.
    //
    PerfStats = *SharedMem;
    PerfStats.dwNumMilliSecondsProcessed /= (
        1 + PerfStats.dwNumPacketsProcessed
    );
    memcpy( (LPBYTE)pdwCounter, (LPBYTE)&PerfStats, sizeof(ULONG)*NUMBER_OF_DHCPDATA_COUNTERS);
    pdwCounter += NUMBER_OF_DHCPDATA_COUNTERS;

    //
    //  Update arguments for return.
    //

    *lppData          = (PVOID)pdwCounter;
    *lpNumObjectTypes = 1;
    *lpcbTotalBytes   = (DWORD)((BYTE *)pdwCounter - (BYTE *)pDhcpDataDataDefinition);

    //
    //  Success!  Honest!!
    //

    REPORT_INFORMATION( DHCP_COLLECT_SUCCESS, LOG_VERBOSE );
    return NO_ERROR;

}   // CollectDHCPPerformanceData

/*******************************************************************

    NAME:       CloseDHCPPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseDhcpPerformanceData( VOID )
{
    LONG   lOpens;
    //
    //  No real cleanup to do here.
    //

    REPORT_INFORMATION( DHCP_CLOSE_ENTERED, LOG_VERBOSE );

    //
    // NOTE: The interlocked operations are used just as a safeguard.
    // As with all perflibs, these 3 functions should be called within
    // a data mutex.
    //
    lOpens = InterlockedDecrement(&cOpens);
    assert (lOpens >= 0);
    if (lOpens == 0)
    {
      //
      // unbind from the nameserver. There could be synch. problems since
      // sfLogOpen is changed in both Open and Close functions. This at the
      // max. will affect logging. It being unclear at this point whether or
      // not Open gets called multiple times (from all looks of it, it is only
      // called once), this flag may even not be necessary.
      //
      MonCloseEventLog();
      sfLogOpen = FALSE;
      CleanupSharedMem();
    }
    return NO_ERROR;

}   // CloseDHCPPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  L"perfctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

BOOL
MonBuildInstanceDefinitionByUnicodeString(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
    );

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\datatcp.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datatcp.c

Abstract:

    The file containing the constant data structures
    for the Performance Monitor data for the TCP/IP 
    Extensible Objects (Network Interface, IP, ICMP, TCP
    and UDP).

    This file contains a set of constant data structures which are
    currently defined for the TCP/IP Extensible Objects.  This is an 
    example of how other such objects could be defined.

Created:

    Christos Tsollis  08/28/92 

Revision History:

--*/
//
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "datatcp.h"

//
//  Constant structure initializations
//


NET_INTERFACE_DATA_DEFINITION NetInterfaceDataDefinition = {

    {   sizeof(NET_INTERFACE_DATA_DEFINITION) + SIZE_OF_IF_DATA,
        sizeof(NET_INTERFACE_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        510,
        0,
        511,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(NET_INTERFACE_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,     // default is Byte Total/sec  
        0,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        513,
        0,
        -4,
        PERF_DETAIL_ADVANCED, 
        PERF_COUNTER_BULK_COUNT, 
        sizeof(LONGLONG),
        IF_OCTETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        400,
        0,
        515,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_PACKETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        266,
        0,
        517,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_INPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        452,
        0,
        519,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_OUTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        520,
        0,
        521,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_SPEED_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        523,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_INOCTETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        524,
        0,
        525,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_INUCASTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        526,
        0,
        527,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_INNUCASTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        528,
        0,
        529,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_INDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        530,
        0,
        531,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_INERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        532,
        0,
        533,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_INUNKNOWNPROTOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        506,
        0,
        535,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_OUTOCTETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        536,
        0,
        537,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_OUTUCASTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        538,
        0,
        539,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_OUTNUCASTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        540,
        0,
        541,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_OUTDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        542,
        0,
        543,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_OUTERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        544,
        0,
        545,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_OUTQLEN_OFFSET
    }
};




IP_DATA_DEFINITION IpDataDefinition = {

    {   sizeof(IP_DATA_DEFINITION) + SIZE_OF_IP_DATA,
        sizeof(IP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        546,
        0,
        547,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(IP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        438,
        0,
        549,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_DATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        446,
        0,
        551,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_INRECEIVES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        552,
        0,
        553,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_INHDRERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        554,
        0,
        555,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_INADDRERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        556,
        0,
        557,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_FORWDATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        558,
        0,
        559,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_INUNKNOWNPROTOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        560,
        0,
        561,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_INDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        562,
        0,
        563,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_INDELIVERS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        442,
        0,
        565,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_OUTREQUESTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        566,
        0,
        567,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_OUTDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        568,
        0,
        569,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_OUTNOROUTES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        570,
        0,
        571,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_REASMREQDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        572,
        0,
        573,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_REASMOKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        574,
        0,
        575,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_REASMFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        576,
        0,
        577,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_FRAGOKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        578,
        0,
        579,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_FRAGFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        580,
        0,
        581,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_FRAGCREATES_OFFSET
    }
};



ICMP_DATA_DEFINITION IcmpDataDefinition = {

    {   sizeof(ICMP_DATA_DEFINITION) + SIZE_OF_ICMP_DATA,
        sizeof(ICMP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        582,
        0,
        583,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(ICMP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        584,
        0,
        585,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_MESSAGES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        586,
        0,
        587,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INMSGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        588,
        0,
        589,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        590,
        0,
        591,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INDESTUNREACHS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        592,
        0,
        593,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INTIMEEXCDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        594,
        0,
        595,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INPARMPROBS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        596,
        0,
        597,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INSRCQUENCHS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        598,
        0,
        599,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INREDIRECTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        600,
        0,
        601,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INECHOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        602,
        0,
        603,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INECHOREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        604,
        0,
        605,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INTIMESTAMPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        606,
        0,
        607,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INTIMESTAMPREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        608,
        0,
        609,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INADDRMASKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        610,
        0,
        611,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INADDRMASKREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        612,
        0,
        613,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTMSGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        614,
        0,
        615,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        616,
        0,
        617,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTDESTUNREACHS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        618,
        0,
        619,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTTIMEEXCDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        620,
        0,
        621,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTPARMPROBS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        622,
        0,
        623,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTSRCQUENCHS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        624,
        0,
        625,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTREDIRECTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        626,
        0,
        627,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTECHOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        628,
        0,
        629,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTECHOREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        630,
        0,
        631,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTTIMESTAMPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        632,
        0,
        633,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTTIMESTAMPREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        634,
        0,
        635,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTADDRMASKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        636,
        0,
        637,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTADDRMASKREPS_OFFSET
    }
};



TCP_DATA_DEFINITION TcpDataDefinition = {

    {   sizeof(TCP_DATA_DEFINITION) + SIZE_OF_TCP_DATA,
        sizeof(TCP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        638,
        0,
        639,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(TCP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        640,
        0,
        641,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP_SEGMENTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        642,
        0,
        643,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_CURRESTAB_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        644,
        0,
        645,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_ACTIVEOPENS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        646,
        0,
        647,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_PASSIVEOPENS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        648,
        0,
        649,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_ATTEMPTFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        650,
        0,
        651,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_ESTABRESETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        652,
        0,
        653,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP_INSEGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        654,
        0,
        655,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP_OUTSEGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        656,
        0,
        657,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP_RETRANSSEGS_OFFSET
    }
};


UDP_DATA_DEFINITION UdpDataDefinition = {

    {   sizeof(UDP_DATA_DEFINITION) + SIZE_OF_UDP_DATA,
        sizeof(UDP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        658,
        0,
        659,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(UDP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        438,
        0,
        661,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP_DATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        446,
        0,
        663,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP_INDATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        664,
        0,
        665,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP_NOPORTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        666,
        0,
        667,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        UDP_INERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        442,
        0,
        669,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP_OUTDATAGRAMS_OFFSET
    }
};

//IPv6 **********************************************************************


IP6_DATA_DEFINITION Ip6DataDefinition = {

    {   sizeof(IP_DATA_DEFINITION) + SIZE_OF_IP_DATA,
        sizeof(IP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        548,
        0,
        547,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(IP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        438,
        0,
        549,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_DATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        446,
        0,
        551,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_INRECEIVES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        552,
        0,
        553,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP6_INHDRERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        554,
        0,
        555,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP6_INADDRERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        556,
        0,
        557,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_FORWDATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        558,
        0,
        559,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP6_INUNKNOWNPROTOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        560,
        0,
        561,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP6_INDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        562,
        0,
        563,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_INDELIVERS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        442,
        0,
        565,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_OUTREQUESTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        566,
        0,
        567,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP6_OUTDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        568,
        0,
        569,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP6_OUTNOROUTES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        570,
        0,
        571,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_REASMREQDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        572,
        0,
        573,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_REASMOKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        574,
        0,
        575,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP6_REASMFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        576,
        0,
        577,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_FRAGOKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        578,
        0,
        579,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP6_FRAGFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        580,
        0,
        581,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP6_FRAGCREATES_OFFSET
    }
};


ICMP6_DATA_DEFINITION Icmp6DataDefinition = {

    {   sizeof(ICMP6_DATA_DEFINITION) + SIZE_OF_ICMP6_DATA,
        sizeof(ICMP6_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        1534,
        0,
        583,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(ICMP6_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        584,
        0,
        585,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP6_MESSAGES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        586,
        0,
        587,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP6_INMSGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        588,
        0,
        589,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP6_INERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        590,
        0,
        591,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP6_INDSTUNREACH_OFFSET
    },
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1536,
		0,
		1537,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
		ICMP6_INPACKETTOOBIG_OFFSET
	},
    {        sizeof(PERF_COUNTER_DEFINITION),
        592,
        0,
        593,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP6_INTIMEEXCEEDED_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        594,
        0,
        595,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP6_INPARAMPROB_OFFSET
    },
	{        sizeof(PERF_COUNTER_DEFINITION),
	    600,
		0,
		601,
		0,
		0,
		PERF_DETAIL_EXPERT,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_INECHOREQUEST_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    602,
		0,
		603,
		0,
		0,
		PERF_DETAIL_EXPERT,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_INECHOREPLY_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1538,
		0,
		1539,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_INMEMBERSHIPQUERY_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1540,
		0,
		1541,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_INMEMBERSHIPREPORT_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1542,
		0,
		1543,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_INMEMBERSHIPREDUCTION_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1544,
		0,
		1545,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ND_INROUTERSOLICIT_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1546,
		0,
		1547,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ND_INROUTERADVERT_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1550,
		0,
		1551,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ND_INNEIGHBORSOLICIT_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1552,
		0,
		1553,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ND_INNEIGHBORADVERT_OFFSET
	},
    {        sizeof(PERF_COUNTER_DEFINITION),
        598,
        0,
        599,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ND_INREDIRECT_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        612,
        0,
        613,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP6_OUTMSGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        614,
        0,
        615,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP6_OUTERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        616,
        0,
        617,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP6_OUTDSTUNREACH_OFFSET
    },
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1554,
		0,
		1555,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
		ICMP6_OUTPACKETTOOBIG_OFFSET
	},
    {        sizeof(PERF_COUNTER_DEFINITION),
        618,
        0,
        619,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP6_OUTTIMEEXCEEDED_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        620,
        0,
        621,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP6_OUTPARAMPROB_OFFSET
    },
	{        sizeof(PERF_COUNTER_DEFINITION),
	    626,
		0,
		627,
		0,
		0,
		PERF_DETAIL_EXPERT,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_OUTECHOREQUEST_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    628,
		0,
		629,
		0,
		0,
		PERF_DETAIL_EXPERT,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_OUTECHOREPLY_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1556,
		0,
		1557,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_OUTMEMBERSHIPQUERY_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1558,
		0,
		1559,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_OUTMEMBERSHIPREPORT_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1560,
		0,
		1561,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ICMP6_OUTMEMBERSHIPREDUCTION_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1562,
		0,
		1563,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ND_OUTROUTERSOLICIT_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1564,
		0,
		1565,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ND_OUTROUTERADVERT_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1566,
		0,
		1567,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ND_OUTNEIGHBORSOLICIT_OFFSET
	},
	{        sizeof(PERF_COUNTER_DEFINITION),
	    1568,
		0,
		1569,
		0,
		0,
		PERF_DETAIL_ADVANCED,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
		ND_OUTNEIGHBORADVERT_OFFSET
	},
    {        sizeof(PERF_COUNTER_DEFINITION),
        624,
        0,
        625,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ND_OUTREDIRECT_OFFSET
    }
};



TCP6_DATA_DEFINITION Tcp6DataDefinition = {

    {   sizeof(TCP6_DATA_DEFINITION) + SIZE_OF_TCP6_DATA,
        sizeof(TCP6_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        1530,
        0,
        639,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(TCP6_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        640,
        0,
        641,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP6_SEGMENTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        642,
        0,
        643,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP6_CURRESTAB_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        644,
        0,
        645,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP6_ACTIVEOPENS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        646,
        0,
        647,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP6_PASSIVEOPENS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        648,
        0,
        649,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP6_ATTEMPTFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        650,
        0,
        651,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP6_ESTABRESETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        652,
        0,
        653,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP6_INSEGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        654,
        0,
        655,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP6_OUTSEGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        656,
        0,
        657,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP6_RETRANSSEGS_OFFSET
    }
};




UDP6_DATA_DEFINITION Udp6DataDefinition = {

    {   sizeof(UDP6_DATA_DEFINITION) + SIZE_OF_UDP6_DATA,
        sizeof(UDP6_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        1532,
        0,
        659,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(UDP6_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        438,
        0,
        661,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP6_DATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        446,
        0,
        663,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP6_INDATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        664,
        0,
        665,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP6_NOPORTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        666,
        0,
        667,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        UDP6_INERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        442,
        0,
        669,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP6_OUTDATAGRAMS_OFFSET
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\perfnbf.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfnbf.c

Abstract:

    This file implements the Extensible Objects for
    the Nbf LAN object types

    This code originally existed for NetBEUI only.  Later, it was
    adaped to handle Netrware protocol level NWNB, SPX, and IPX.
    The code was not everywhere changed to reflect this, due to the
    lateness of the change.  Therefore, sometimes you will see NBF
    where you should see TDI.

Created:

    Russ Blake  07/30/92

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <nb30.h>
#include <tdi.h>
#include <winperf.h>
#include <perfutil.h>
#include "perfctr.h" // error message definition
#include "perfmsg.h"
#include "datanbf.h"

//
//  References to constants which initialize the Object type definitions
//

extern NBF_DATA_DEFINITION NbfDataDefinition;
extern NBF_RESOURCE_DATA_DEFINITION NbfResourceDataDefinition;



//
// TDI data structures
//

#define NBF_PROTOCOL 0
#define IPX_PROTOCOL 1
#define SPX_PROTOCOL 2
#define NWNB_PROTOCOL 3
#define NUMBER_OF_PROTOCOLS_HANDLED 4

typedef struct _TDI_DATA_DEFINITION {
   int               NumberOfResources;
   HANDLE            fileHandle;
   UNICODE_STRING    DeviceName;
} TDI_DATA_DEFINITION, *PTDI_DATA_DEFINITION;

typedef struct _TDI_PROTOCOLS_DATA {
   int                     NumOfDevices;
   int                     MaxDeviceName;
   int                     MaxNumOfResources;
   PTDI_DATA_DEFINITION    pTDIData;
} TDI_PROTOCOLS_DATA;

TDI_PROTOCOLS_DATA TDITbl[NUMBER_OF_PROTOCOLS_HANDLED];

DWORD   dwTdiProtocolRefCount[NUMBER_OF_PROTOCOLS_HANDLED] = {0,0,0,0};
DWORD   dwTdiRefCount = 0;

DWORD ObjectNameTitleIndices[NUMBER_OF_PROTOCOLS_HANDLED] = { 492,
                                                              488,
                                                              490,
                                                              398 };

//
// NBF data structures
//

ULONG ProviderStatsLength;               // Resource-dependent size
PTDI_PROVIDER_STATISTICS ProviderStats = NULL;
                                         // Provider statistics

//
// NetBUEI Resource Instance Names
//
LPCWSTR NetResourceName[] =
    {
    (LPCWSTR)L"Link(11)",
    (LPCWSTR)L"Address(12)",
    (LPCWSTR)L"Address File(13)",
    (LPCWSTR)L"Connection(14)",
    (LPCWSTR)L"Request(15)",
    (LPCWSTR)L"UI Frame(21)",
    (LPCWSTR)L"Packet(22)",
    (LPCWSTR)L"Receive Packet(23)",
    (LPCWSTR)L"Receive Buffer(24)"
    };
#define NUMBER_OF_NAMES sizeof(NetResourceName)/sizeof(NetResourceName[0])
#define MAX_NBF_RESOURCE_NAME_LENGTH    20

//
//  Function Prototypes
//

PM_OPEN_PROC    OpenNbfPerformanceData;
PM_COLLECT_PROC CollectNbfPerformanceData;
PM_CLOSE_PROC   CloseNbfPerformanceData;

PM_OPEN_PROC    OpenIPXPerformanceData;
PM_COLLECT_PROC CollectIPXPerformanceData;
PM_CLOSE_PROC   CloseIPXPerformanceData;

PM_OPEN_PROC    OpenSPXPerformanceData;
PM_COLLECT_PROC CollectSPXPerformanceData;
PM_CLOSE_PROC   CloseSPXPerformanceData;

PM_OPEN_PROC    OpenNWNBPerformanceData;
PM_COLLECT_PROC CollectNWNBPerformanceData;
PM_CLOSE_PROC   CloseNWNBPerformanceData;

DWORD OpenTDIPerformanceData(LPWSTR lpDeviceNames,
                             DWORD  CurrentProtocol);
DWORD CollectTDIPerformanceData(IN LPWSTR lpValueName,
                                IN OUT LPVOID *lppData,
                                IN OUT LPDWORD lpcbTotalBytes,
                                IN OUT LPDWORD lpNumObjectTypes,
                                IN DWORD CurrentProtocol);
DWORD CloseTDIPerformanceData(DWORD CurrentProtocol);


DWORD
OpenNbfPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    Pointer to each device to be opened


Return Value:

    None.

--*/

{
    return OpenTDIPerformanceData(lpDeviceNames, NBF_PROTOCOL);
}

DWORD
OpenIPXPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    Pointer to each device to be opened


Return Value:

    None.

--*/

{
    return OpenTDIPerformanceData(lpDeviceNames, IPX_PROTOCOL);
}

DWORD
OpenSPXPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    Pointer to each device to be opened


Return Value:

    None.

--*/
{
    DWORD   dwStatus;

    dwStatus = OpenTDIPerformanceData(lpDeviceNames, SPX_PROTOCOL);
    if (dwStatus == ERROR_FILE_NOT_FOUND) {
        // no devices is not really an error, even though no counters
        // will be collected, this presents a much less alarming
        // message to the user.
        REPORT_WARNING (SPX_NO_DEVICE, LOG_USER);
        dwStatus = ERROR_SUCCESS;
    }
    return dwStatus;

}

DWORD
OpenNWNBPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    Pointer to each device to be opened


Return Value:

    None.

--*/

{
    return OpenTDIPerformanceData(lpDeviceNames, NWNB_PROTOCOL);
}

void
CleanUpTDIData (
    DWORD  CurrentProtocol
    )
/*++

Routine Description:

    This routine will cleanup all the memory allocated for the
    CurrentProtocol

Arguments:

    IN      DWORD    CurrentProtocol
         this is the index of the protocol for which we are currently
         gathering statistics



Return Value:

    None.

--*/

{
    int     NumOfDevices;
    int     i;
    PTDI_DATA_DEFINITION pTDIData;

    pTDIData = TDITbl[CurrentProtocol].pTDIData;
    if (pTDIData == NULL)
        // nothing to cleanup
        return;

    NumOfDevices = TDITbl[CurrentProtocol].NumOfDevices;
    for (i=0; i < NumOfDevices; i++, pTDIData++) {
        if (pTDIData->DeviceName.Buffer) {
            FREEMEM(pTDIData->DeviceName.Buffer);
        }
        if (pTDIData->fileHandle) {
            NtClose (pTDIData->fileHandle);
        }
    }
    FREEMEM(TDITbl[CurrentProtocol].pTDIData);
    TDITbl[CurrentProtocol].pTDIData = NULL;

}


#pragma warning ( disable : 4127)
DWORD
OpenTDIPerformanceData(
    LPWSTR lpDeviceNames,
    DWORD  CurrentProtocol
    )
/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    IN      LPWSTR   lpDeviceNames
         pointer to each device to be opened

    IN      DWORD    CurrentProtocol
         this is the index of the protocol for which we are currently
         gathering statistics



Return Value:

    None.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING FileString;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    TDI_REQUEST_USER_QUERY_INFO QueryInfo;
    HANDLE  fileHandle;
    LPWSTR   lpLocalDeviceNames;
    int      NumOfDevices;
    LPWSTR   lpSaveDeviceName;
    PTDI_DATA_DEFINITION pTemp;
    PTDI_PROVIDER_INFO ProviderInfo=NULL;
    BOOL        bInitThisProtocol = FALSE;

    MonOpenEventLog(APP_NAME);  // this function maintains a reference count

    lpLocalDeviceNames = lpDeviceNames;

    if (dwTdiProtocolRefCount[CurrentProtocol] == 0) {
        bInitThisProtocol = TRUE;
        TDITbl[CurrentProtocol].MaxDeviceName = 0;
        NumOfDevices = TDITbl[CurrentProtocol].NumOfDevices = 0;
        TDITbl[CurrentProtocol].pTDIData = NULL;

        while (TRUE) {

            if (lpLocalDeviceNames == NULL || *lpLocalDeviceNames == L'\0') {
                break;
            }

            REPORT_INFORMATION_DATA (TDI_OPEN_ENTERED,
                LOG_VERBOSE,
                lpLocalDeviceNames,
                (lstrlenW(lpLocalDeviceNames) * sizeof(WCHAR)));

            RtlInitUnicodeString (&FileString, lpLocalDeviceNames);
            lpSaveDeviceName = ALLOCMEM(sizeof (WCHAR) * (lstrlenW(lpLocalDeviceNames) + 1));

            if (!lpSaveDeviceName) {
                REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
                if (NumOfDevices == 0)
                    return ERROR_OUTOFMEMORY;
                else
                    break;
            }


            InitializeObjectAttributes(
                &ObjectAttributes,
                &FileString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = NtOpenFile(
                         &fileHandle,
                         SYNCHRONIZE | FILE_READ_DATA,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(Status)) {
                FREEMEM(lpSaveDeviceName);
                REPORT_ERROR_DATA (TDI_OPEN_FILE_ERROR, LOG_DEBUG,
                  lpLocalDeviceNames, (lstrlenW(lpLocalDeviceNames) * sizeof(WCHAR)));
                REPORT_ERROR_DATA (TDI_OPEN_FILE_ERROR, LOG_DEBUG,
                    &IoStatusBlock, sizeof(IoStatusBlock));
                if (NumOfDevices == 0) {
                    return RtlNtStatusToDosError(Status);
                } else {
                    break;
                }
            }

            if (NumOfDevices == 0) {
                // allocate memory to hold the device data
                TDITbl[CurrentProtocol].pTDIData =
                    ALLOCMEM(sizeof(TDI_DATA_DEFINITION));

                if (TDITbl[CurrentProtocol].pTDIData == NULL) {
                    REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_DEBUG);
                    NtClose(fileHandle);
                    FREEMEM(lpSaveDeviceName);
                    return ERROR_OUTOFMEMORY;
                }
            } else {
                // resize to hold multiple devices
                // Cannot use ALLOCMEM. Requires previous devices to be copied over
                pTemp = RtlReAllocateHeap(RtlProcessHeap(), 0,
                            TDITbl[CurrentProtocol].pTDIData,
                            sizeof(TDI_DATA_DEFINITION) * (NumOfDevices + 1));
                if (pTemp == NULL) {
                    NtClose(fileHandle);
                    FREEMEM(lpSaveDeviceName);
                    CleanUpTDIData(CurrentProtocol);
                    REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
                    return ERROR_OUTOFMEMORY;
                } else {
                    TDITbl[CurrentProtocol].pTDIData = pTemp;
                }
            }

            // build the TDI Data structure for this device instance
            TDITbl[CurrentProtocol].pTDIData[NumOfDevices].fileHandle
                = fileHandle;
            TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.MaximumLength =
                (WORD)(sizeof (WCHAR) * (lstrlenW(lpLocalDeviceNames) + 1));
            TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.Length =
                (WORD)(TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.Length - sizeof(WCHAR));
            TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.Buffer =
                lpSaveDeviceName;
            RtlCopyUnicodeString (
                &(TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName),
                &FileString);

            if (TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.MaximumLength
                > TDITbl[CurrentProtocol].MaxDeviceName) {
                TDITbl[CurrentProtocol].MaxDeviceName =
                    TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.MaximumLength;
            }

            // now increment NumOfDevices
            NumOfDevices++;
            TDITbl[CurrentProtocol].NumOfDevices = NumOfDevices;


            // increment to the next device string
            lpLocalDeviceNames += lstrlenW(lpLocalDeviceNames) + 1;
        }
        REPORT_INFORMATION (TDI_OPEN_FILE_SUCCESS, LOG_VERBOSE);
    }

    dwTdiProtocolRefCount[CurrentProtocol]++;

    if (TDITbl[CurrentProtocol].NumOfDevices == 0) {
        return ERROR_SUCCESS;
    }

    //
    // The following common buffer is used by all protocols.  NBF
    // is bigger because of resource data returned.
    //

    if (ProviderStats == NULL && CurrentProtocol != NBF_PROTOCOL) {
        ProviderStatsLength = sizeof(TDI_PROVIDER_STATISTICS);

        ProviderStats = ALLOCMEM(ProviderStatsLength);

        if (ProviderStats == NULL) {
            REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
            CleanUpTDIData(CurrentProtocol);
            return ERROR_OUTOFMEMORY;
        }
    }

    if ((CurrentProtocol == NBF_PROTOCOL) && bInitThisProtocol) {

        //
        // Query provider info to get resource count.
        //

        ProviderInfo = ALLOCMEM(sizeof(TDI_PROVIDER_INFO));
        if ( ProviderInfo == NULL ) {
            REPORT_ERROR (TDI_PROVIDER_INFO_MEMORY, LOG_USER);
            CleanUpTDIData(CurrentProtocol);
            return ERROR_OUTOFMEMORY;
        }

        QueryInfo.QueryType = TDI_QUERY_PROVIDER_INFO;

        pTemp = TDITbl[CurrentProtocol].pTDIData;
        TDITbl[CurrentProtocol].MaxNumOfResources = 0;

        for (NumOfDevices = 0;
             NumOfDevices < TDITbl[CurrentProtocol].NumOfDevices;
             NumOfDevices++, pTemp++) {

            // loop thru all the devices to see if they can be opened
            // if one of them fails, then stop the whole thing.
            // we should probably save the good ones but...
            Status = NtDeviceIoControlFile(
                         pTemp->fileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         IOCTL_TDI_QUERY_INFORMATION,
                         (PVOID)&QueryInfo,
                         sizeof(TDI_REQUEST_USER_QUERY_INFO),
                         (PVOID)ProviderInfo,
                         sizeof(TDI_PROVIDER_INFO));

            pTemp->NumberOfResources = ProviderInfo->NumberOfResources;
            if ((int)ProviderInfo->NumberOfResources >
                TDITbl[CurrentProtocol].MaxNumOfResources) {
                TDITbl[CurrentProtocol].MaxNumOfResources =
                    ProviderInfo->NumberOfResources;
            }

            if (!NT_SUCCESS(Status)) {
                FREEMEM(ProviderInfo);
                REPORT_ERROR (TDI_UNABLE_READ_DEVICE, LOG_DEBUG);
                REPORT_ERROR_DATA (TDI_IOCTL_FILE_ERROR, LOG_DEBUG,
                       &IoStatusBlock, sizeof(IoStatusBlock));
                CleanUpTDIData(CurrentProtocol);
                return RtlNtStatusToDosError(Status);
            }
        }

        REPORT_INFORMATION (TDI_IOCTL_FILE, LOG_VERBOSE);

        ProviderStatsLength = sizeof(TDI_PROVIDER_STATISTICS) +
                                  (TDITbl[CurrentProtocol].MaxNumOfResources *
                                   sizeof(TDI_PROVIDER_RESOURCE_STATS));

        //
        // Buffer may have been allocated smaller by other protocol.
        //

        if (ProviderStats != NULL) {
            FREEMEM(ProviderStats);
        }
        ProviderStats = ALLOCMEM(ProviderStatsLength);

        if (ProviderStats == NULL) {
            REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
            FREEMEM(ProviderInfo);
            CleanUpTDIData(CurrentProtocol);
            return ERROR_OUTOFMEMORY;
        }

        if (ProviderInfo) {
            FREEMEM(ProviderInfo);
        }
    }
    
    dwTdiRefCount++;

    REPORT_INFORMATION (TDI_OPEN_PERFORMANCE_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
}
#pragma warning ( default : 4127)

DWORD
CollectNbfPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the Nbf counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    return CollectTDIPerformanceData(lpValueName,
                                     lppData,
                                     lpcbTotalBytes,
                                     lpNumObjectTypes,
                                     NBF_PROTOCOL);
}

DWORD
CollectIPXPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the IPX counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    return CollectTDIPerformanceData(lpValueName,
                                     lppData,
                                     lpcbTotalBytes,
                                     lpNumObjectTypes,
                                     IPX_PROTOCOL);
}

DWORD
CollectSPXPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the SPX counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    return CollectTDIPerformanceData(lpValueName,
                                     lppData,
                                     lpcbTotalBytes,
                                     lpNumObjectTypes,
                                     SPX_PROTOCOL);
}

DWORD
CollectNWNBPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the NWNB counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    return CollectTDIPerformanceData(lpValueName,
                                     lppData,
                                     lpcbTotalBytes,
                                     lpNumObjectTypes,
                                     NWNB_PROTOCOL);
}

DWORD
CollectTDIPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes,
    IN      DWORD   CurrentProtocol
)


/*++

Routine Description:

    This routine will return the data for the TDI counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    IN      DWORD    CurrentProtocol
         this is the index of the protocol for which we are currently
         gathering statistics


Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    ULONG SpaceNeeded;
    PDWORD pdwCounter = NULL;
    LARGE_INTEGER UNALIGNED *pliCounter;
    LARGE_INTEGER UNALIGNED *pliFrameBytes;
    LARGE_INTEGER UNALIGNED *pliDatagramBytes;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    NBF_DATA_DEFINITION *pNbfDataDefinition;
    NBF_RESOURCE_DATA_DEFINITION *pNbfResourceDataDefinition;

    // Variables for collecting the data from Nbf

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
    TDI_REQUEST_USER_QUERY_INFO QueryInfo;

    //  Variables for collecting data about Nbf Resouces

    int   NumResource;
    ULONG ResourceSpace;
    UNICODE_STRING ResourceName;
    WCHAR ResourceNameBuffer[MAX_NBF_RESOURCE_NAME_LENGTH + 1];

    INT                                 NumOfDevices;
    PTDI_DATA_DEFINITION                pTDIData;
    INT                                 i;
    INT                                 TotalNumberOfResources;

    // variables used for error logging

    DWORD                               dwDataReturn[2];
    DWORD                               dwQueryType;

    if (lpValueName == NULL) {
        REPORT_INFORMATION (TDI_COLLECT_ENTERED, LOG_VERBOSE);
    } else {
        REPORT_INFORMATION_DATA (TDI_COLLECT_ENTERED,
                                 LOG_VERBOSE,
                                 lpValueName,
                                 (DWORD)(lstrlenW(lpValueName)*sizeof(WCHAR)));
    }
    //
    // before doing anything else,
    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if ((dwQueryType == QUERY_COSTLY) || (dwQueryType == QUERY_FOREIGN)) {
        // NBF foriegn data requests are not supported so bail out
        REPORT_INFORMATION (TDI_FOREIGN_DATA_REQUEST, LOG_VERBOSE);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        if (CurrentProtocol == NBF_PROTOCOL) {
            if ( !(IsNumberInUnicodeList (ObjectNameTitleIndices[CurrentProtocol],
                                      lpValueName)) &&
                 !(IsNumberInUnicodeList (NBF_RESOURCE_OBJECT_TITLE_INDEX,
                                      lpValueName))) {

                // request received for objects not provided by NBF

                REPORT_INFORMATION (TDI_UNSUPPORTED_ITEM_REQUEST, LOG_VERBOSE);

                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_SUCCESS;
            }
        } // NBF_PROTOCOL
        else if ( !(IsNumberInUnicodeList (ObjectNameTitleIndices[CurrentProtocol],
                                      lpValueName))) {
            // request received for objects not provided by this protocol
            REPORT_INFORMATION (TDI_UNSUPPORTED_ITEM_REQUEST, LOG_VERBOSE);
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        } // other protocol
    }   // dwQueryType == QUERY_ITEMS

    // if no NBF devices were opened, in the OPEN routine, then
    // leave now.

    if (TDITbl[CurrentProtocol].pTDIData == NULL) {
        REPORT_WARNING (TDI_NULL_HANDLE, LOG_DEBUG);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    pNbfDataDefinition = (NBF_DATA_DEFINITION *) *lppData;

    pTDIData = TDITbl[CurrentProtocol].pTDIData;
    NumOfDevices = TDITbl[CurrentProtocol].NumOfDevices;

    // Compute space needed to hold Nbf Resource Data

    if (CurrentProtocol != NBF_PROTOCOL) {
        ResourceSpace = 0;
    } else {
        ResourceSpace = sizeof(NBF_RESOURCE_DATA_DEFINITION) +
                        (TDITbl[CurrentProtocol].MaxNumOfResources *
                            (sizeof(PERF_INSTANCE_DEFINITION) +
                        QWORD_MULTIPLE(
                            (MAX_NBF_RESOURCE_NAME_LENGTH * sizeof(WCHAR)) +
                             sizeof(UNICODE_NULL)) +
                        SIZE_OF_NBF_RESOURCE_DATA));
        ResourceSpace *= NumOfDevices;
    }

    SpaceNeeded = sizeof(NBF_DATA_DEFINITION) +
                  SIZE_OF_NBF_DATA +
                  ResourceSpace;

    // now add in the per instance NBF data
    SpaceNeeded += NumOfDevices *
        (SIZE_OF_NBF_DATA +
         sizeof(PERF_INSTANCE_DEFINITION) +
         QWORD_MULTIPLE(
             (TDITbl[CurrentProtocol].MaxDeviceName * sizeof(WCHAR))
             + sizeof(UNICODE_NULL)));

    if ( *lpcbTotalBytes < SpaceNeeded ) {
        dwDataReturn[0] = *lpcbTotalBytes;
        dwDataReturn[1] = SpaceNeeded;
        REPORT_WARNING_DATA (TDI_DATA_BUFFER_SIZE_ERROR,
                             LOG_DEBUG,
                             &dwDataReturn[0],
                             sizeof(dwDataReturn));
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    REPORT_INFORMATION (TDI_DATA_BUFFER_SIZE_SUCCESS, LOG_VERBOSE);

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //

    RtlMoveMemory(pNbfDataDefinition,
           &NbfDataDefinition,
           sizeof(NBF_DATA_DEFINITION));

    pNbfDataDefinition->NbfObjectType.ObjectNameTitleIndex =
        ObjectNameTitleIndices[CurrentProtocol];

    pNbfDataDefinition->NbfObjectType.ObjectHelpTitleIndex =
        ObjectNameTitleIndices[CurrentProtocol] + 1;

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
        &pNbfDataDefinition[1];

    if (NumOfDevices > 0) {
        for (i=0; i < NumOfDevices; i++, pTDIData++) {
            //
            //  Format and collect Nbf data
            //

            QueryInfo.QueryType = TDI_QUERY_PROVIDER_STATISTICS;

            Status = NtDeviceIoControlFile(
                         pTDIData->fileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         IOCTL_TDI_QUERY_INFORMATION,
                         (PVOID)&QueryInfo,
                         sizeof(TDI_REQUEST_USER_QUERY_INFO),
                         (PVOID)ProviderStats,
                         ProviderStatsLength);

            if (Status != STATUS_SUCCESS) {
                REPORT_ERROR (TDI_UNABLE_READ_DEVICE, LOG_DEBUG);
                REPORT_ERROR_DATA (TDI_QUERY_INFO_ERROR,
                                   LOG_DEBUG,
                                   &IoStatusBlock,
                                   sizeof (IoStatusBlock));
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_SUCCESS;
            }

            REPORT_INFORMATION (TDI_QUERY_INFO_SUCCESS, LOG_DEBUG);


            MonBuildInstanceDefinitionByUnicodeString(
                pPerfInstanceDefinition,
                (PVOID *)&pPerfCounterBlock,
                0,
                0,
                (DWORD)PERF_NO_UNIQUE_ID,
                &(pTDIData->DeviceName));


            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_NBF_DATA);

            pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

            *pdwCounter = ProviderStats->DatagramsSent +
                          ProviderStats->DatagramsReceived;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            pliDatagramBytes = pliCounter;
            pliCounter->QuadPart = ProviderStats->DatagramBytesSent.QuadPart +
                                   ProviderStats->DatagramBytesReceived.QuadPart;
            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->PacketsSent + ProviderStats->PacketsReceived;
            *++pdwCounter = ProviderStats->DataFramesSent +
                            ProviderStats->DataFramesReceived;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            pliFrameBytes = pliCounter;
            pliCounter->QuadPart = ProviderStats->DataFrameBytesSent.QuadPart +
                                   ProviderStats->DataFrameBytesReceived.QuadPart;

            //  Get the Bytes Total/sec which is the sum of Frame Byte /sec
            //  and Datagram byte/sec
            ++pliCounter;
            pliCounter->QuadPart = pliDatagramBytes->QuadPart +
                                   pliFrameBytes->QuadPart;
            //
            //  Get the TDI raw data.
            //
            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->OpenConnections;
            *++pdwCounter = ProviderStats->ConnectionsAfterNoRetry;
            *++pdwCounter = ProviderStats->ConnectionsAfterRetry;
            *++pdwCounter = ProviderStats->LocalDisconnects;
            *++pdwCounter = ProviderStats->RemoteDisconnects;
            *++pdwCounter = ProviderStats->LinkFailures;
            *++pdwCounter = ProviderStats->AdapterFailures;
            *++pdwCounter = ProviderStats->SessionTimeouts;
            *++pdwCounter = ProviderStats->CancelledConnections;
            *++pdwCounter = ProviderStats->RemoteResourceFailures;
            *++pdwCounter = ProviderStats->LocalResourceFailures;
            *++pdwCounter = ProviderStats->NotFoundFailures;
            *++pdwCounter = ProviderStats->NoListenFailures;
            *++pdwCounter = ProviderStats->DatagramsSent;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DatagramBytesSent;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->DatagramsReceived;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DatagramBytesReceived;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->PacketsSent;
            *++pdwCounter = ProviderStats->PacketsReceived;
            *++pdwCounter = ProviderStats->DataFramesSent;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DataFrameBytesSent;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->DataFramesReceived;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DataFrameBytesReceived;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->DataFramesResent;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DataFrameBytesResent;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->DataFramesRejected;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DataFrameBytesRejected;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->ResponseTimerExpirations;
            *++pdwCounter = ProviderStats->AckTimerExpirations;
            *++pdwCounter = ProviderStats->MaximumSendWindow;
            *++pdwCounter = ProviderStats->AverageSendWindow;
            *++pdwCounter = ProviderStats->PiggybackAckQueued;
            *++pdwCounter = ProviderStats->PiggybackAckTimeouts;
            *++pdwCounter = 0; //reserved

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                      ((PBYTE) pPerfCounterBlock +
                                       SIZE_OF_NBF_DATA);
        }

        pNbfResourceDataDefinition = (NBF_RESOURCE_DATA_DEFINITION *)
                                     ++pdwCounter;
    } else {
        pNbfResourceDataDefinition = (NBF_RESOURCE_DATA_DEFINITION *)
            pPerfInstanceDefinition;
    }

    TotalNumberOfResources = 0;

    pNbfDataDefinition->NbfObjectType.NumInstances = NumOfDevices;
    pNbfDataDefinition->NbfObjectType.TotalByteLength =
        QWORD_MULTIPLE((DWORD)((PBYTE) pdwCounter - (PBYTE) pNbfDataDefinition));

    if (CurrentProtocol == NBF_PROTOCOL) {

        RtlMoveMemory(pNbfResourceDataDefinition,
                      &NbfResourceDataDefinition,
                      sizeof(NBF_RESOURCE_DATA_DEFINITION));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pNbfResourceDataDefinition[1];

        pTDIData = TDITbl[CurrentProtocol].pTDIData;

        for (i = 0; i < NumOfDevices; i++, pTDIData++) {
            // for most cases, we will have only one deivce,
            // then we could just use the ProviderStats read
            // for NBF data.
            if (NumOfDevices > 1) {
                // need to read ProviderStat again for multiple devices
                QueryInfo.QueryType = TDI_QUERY_PROVIDER_STATISTICS;

                Status = NtDeviceIoControlFile(
                             pTDIData->fileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             IOCTL_TDI_QUERY_INFORMATION,
                             (PVOID)&QueryInfo,
                             sizeof(TDI_REQUEST_USER_QUERY_INFO),
                             (PVOID)ProviderStats,
                             ProviderStatsLength);

                if (Status != STATUS_SUCCESS) {
                    REPORT_ERROR (TDI_UNABLE_READ_DEVICE, LOG_DEBUG);
                    REPORT_ERROR_DATA (TDI_QUERY_INFO_ERROR,
                                       LOG_DEBUG,
                                       &IoStatusBlock,
                                       sizeof (IoStatusBlock));
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    return ERROR_SUCCESS;
                }
            }

            TotalNumberOfResources += pTDIData->NumberOfResources;

            for ( NumResource = 0;
                  NumResource < pTDIData->NumberOfResources;
                  NumResource++ ) {

                //
                //  Format and collect Nbf Resource data
                //

                if (NumResource < NUMBER_OF_NAMES) {
                    RtlInitUnicodeString(&ResourceName,
                                         NetResourceName[NumResource]);
                } else {
                    ResourceName.Length = 0;
                    ResourceName.MaximumLength = MAX_NBF_RESOURCE_NAME_LENGTH +
                                                 sizeof(UNICODE_NULL);
                    ResourceName.Buffer = ResourceNameBuffer;
                    RtlIntegerToUnicodeString(NumResource,
                                              10,
                                              &ResourceName);
                }

                MonBuildInstanceDefinitionByUnicodeString(
                    pPerfInstanceDefinition,
                    (PVOID *)&pPerfCounterBlock,
                    ObjectNameTitleIndices[CurrentProtocol],
                    i,
                    (DWORD)PERF_NO_UNIQUE_ID,
                    &ResourceName);

                pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_NBF_RESOURCE_DATA);

                pdwCounter = (PDWORD)&pPerfCounterBlock[1]; // define pointer to first
                                                            // counter in block
                *pdwCounter++ =
                    ProviderStats->ResourceStats[NumResource].MaximumResourceUsed;
                *pdwCounter++ =
                    ProviderStats->ResourceStats[NumResource].AverageResourceUsed;
                *pdwCounter++ =
                    ProviderStats->ResourceStats[NumResource].ResourceExhausted;

                // set pointer to where next instance buffer should show up

                pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                          ((PBYTE) pPerfCounterBlock +
                                           SIZE_OF_NBF_RESOURCE_DATA);
                // set for loop termination

                pdwCounter = (PDWORD) pPerfInstanceDefinition;

            }  // NumberOfResources
        }   // NumOfDevices
    } // NBF_PROTOCOL

    *lppData = (LPVOID) ALIGN_ON_QWORD(pdwCounter);

    pNbfResourceDataDefinition->NbfResourceObjectType.TotalByteLength =
        QWORD_MULTIPLE((DWORD)((PBYTE) pdwCounter - (PBYTE) pNbfResourceDataDefinition));

    if (CurrentProtocol != NBF_PROTOCOL) {
        *lpNumObjectTypes = 1;
        // bytes used are those of the first (i.e. only) object returned
        *lpcbTotalBytes = pNbfDataDefinition->NbfObjectType.TotalByteLength;
    } else {
        // set count of object types returned
        *lpNumObjectTypes = NBF_NUM_PERF_OBJECT_TYPES;
        // set length of this object
        //  *lpcbTotalBytes;
        // note the bytes used by first object
        *lpcbTotalBytes = pNbfDataDefinition->NbfObjectType.TotalByteLength;
        // add the bytes used by the second object
        *lpcbTotalBytes +=
            pNbfResourceDataDefinition->NbfResourceObjectType.TotalByteLength;
        // set number of instances loaded
        pNbfResourceDataDefinition->NbfResourceObjectType.NumInstances =
            TotalNumberOfResources;
    }

    REPORT_INFORMATION (TDI_COLLECT_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
}


DWORD
CloseNbfPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Nbf devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    return CloseTDIPerformanceData(NBF_PROTOCOL);
}

DWORD
CloseIPXPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to IPX devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    return CloseTDIPerformanceData(IPX_PROTOCOL);
}

DWORD
CloseSPXPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to SPX devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    return CloseTDIPerformanceData(SPX_PROTOCOL);
}

DWORD
CloseNWNBPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to NWNB devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    return CloseTDIPerformanceData(NWNB_PROTOCOL);
}

DWORD
CloseTDIPerformanceData(
    DWORD CurrentProtocol
)

/*++

Routine Description:

    This routine closes the open handles to TDI devices.

Arguments:

    Current protocol index.


Return Value:

    ERROR_SUCCESS

--*/

{
    REPORT_INFORMATION (TDI_CLOSE_ENTERED, LOG_VERBOSE);

    if (dwTdiProtocolRefCount[CurrentProtocol] > 0) {
        dwTdiProtocolRefCount[CurrentProtocol]--;
        if (dwTdiProtocolRefCount[CurrentProtocol] == 0) {
            CleanUpTDIData (CurrentProtocol);
        }
    }

    if (dwTdiRefCount > 0) {
        dwTdiRefCount--;
        if (dwTdiRefCount == 0) {
            if ( ProviderStats ) {
                FREEMEM(ProviderStats);
                ProviderStats = NULL;
                REPORT_INFORMATION (TDI_PROVIDER_STATS_FREED, LOG_VERBOSE);
            }
        }
    }

    MonCloseEventLog ();

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\perftcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perftcp.h  

Abstract:

    This file provides the RFC 1156 Object Identifier Strings
    for all the performance data kept by SNMP agents that 
    are interesting to the Performance monitor. 

Author:

    Christos Tsollis 8/28/92  

Revision History:


--*/
#ifndef _PERFTCP_H_
#define _PERFTCP_H_
// 
// This is the array of the Object Identifier Strings for the IP, ICMP, TCP and
// UDP performance data kept by SNMP agents that are interesting to the 
// Performance Monitor.
//


#define NO_OF_OIDS	55  // Number of IP, ICMP, TCP and UDP Oids used


CHAR *OidStr[NO_OF_OIDS] =
{
	".iso.org.dod.internet.mgmt.mib-2.interfaces.ifNumber.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInReceives.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInHdrErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInAddrErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipForwDatagrams.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInUnknownProtos.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInDiscards.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInDelivers.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipOutRequests.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipOutDiscards.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipOutNoRoutes.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipReasmReqds.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipReasmOKs.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipReasmFails.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipFragOKs.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipFragFails.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipFragCreates.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpCurrEstab.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpActiveOpens.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpPassiveOpens.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpAttemptFails.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpEstabResets.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpInSegs.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpOutSegs.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpRetransSegs.0",
	".iso.org.dod.internet.mgmt.mib-2.udp.udpInDatagrams.0",
	".iso.org.dod.internet.mgmt.mib-2.udp.udpNoPorts.0",
	".iso.org.dod.internet.mgmt.mib-2.udp.udpInErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.udp.udpOutDatagrams.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInMsgs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInDestUnreachs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInTimeExcds.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInParmProbs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInSrcQuenchs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInRedirects.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInEchos.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInEchoReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInTimestamps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInTimestampReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInAddrMasks.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInAddrMaskReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutMsgs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutDestUnreachs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutTimeExcds.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutParmProbs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutSrcQuenchs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutRedirects.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutEchos.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutEchoReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutTimestamps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutTimestampReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutAddrMasks.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutAddrMaskReps.0"
};


//
// The indices of the various counters in their VarBind lists.
//

#define IF_NUMBER_INDEX				0
#define IP_INRECEIVES_INDEX			1
#define IP_INHDRERRORS_INDEX			2
#define IP_INADDRERRORS_INDEX			3
#define IP_FORWDATAGRAMS_INDEX			4
#define IP_INUNKNOWNPROTOS_INDEX		5
#define IP_INDISCARDS_INDEX			6
#define IP_INDELIVERS_INDEX			7
#define IP_OUTREQUESTS_INDEX			8
#define IP_OUTDISCARDS_INDEX			9
#define IP_OUTNOROUTES_INDEX			10
#define IP_REASMREQDS_INDEX			11
#define IP_REASMOKS_INDEX			12
#define IP_REASMFAILS_INDEX			13
#define IP_FRAGOKS_INDEX			14
#define IP_FRAGFAILS_INDEX			15
#define IP_FRAGCREATES_INDEX			16
#define TCP_CURRESTAB_INDEX			17
#define TCP_ACTIVEOPENS_INDEX			18
#define TCP_PASSIVEOPENS_INDEX			19
#define TCP_ATTEMPTFAILS_INDEX			20
#define TCP_ESTABRESETS_INDEX			21
#define TCP_INSEGS_INDEX			22
#define TCP_OUTSEGS_INDEX			23
#define TCP_RETRANSSEGS_INDEX			24
#define UDP_INDATAGRAMS_INDEX			25
#define UDP_NOPORTS_INDEX			26
#define UDP_INERRORS_INDEX			27
#define UDP_OUTDATAGRAMS_INDEX			28

#define ICMP_INMSGS_INDEX			0
#define ICMP_INERRORS_INDEX			1
#define ICMP_INDESTUNREACHS_INDEX		2
#define ICMP_INTIMEEXCDS_INDEX			3
#define ICMP_INPARMPROBS_INDEX			4
#define ICMP_INSRCQUENCHS_INDEX			5
#define ICMP_INREDIRECTS_INDEX			6
#define ICMP_INECHOS_INDEX			7
#define ICMP_INECHOREPS_INDEX			8
#define ICMP_INTIMESTAMPS_INDEX			9
#define ICMP_INTIMESTAMPREPS_INDEX		10
#define ICMP_INADDRMASKS_INDEX			11
#define ICMP_INADDRMASKREPS_INDEX		12
#define ICMP_OUTMSGS_INDEX			13
#define ICMP_OUTERRORS_INDEX			14
#define ICMP_OUTDESTUNREACHS_INDEX		15
#define ICMP_OUTTIMEEXCDS_INDEX			16
#define ICMP_OUTPARMPROBS_INDEX			17
#define ICMP_OUTSRCQUENCHS_INDEX		18
#define ICMP_OUTREDIRECTS_INDEX			19
#define ICMP_OUTECHOS_INDEX			20
#define ICMP_OUTECHOREPS_INDEX			21
#define ICMP_OUTTIMESTAMPS_INDEX		22
#define ICMP_OUTTIMESTAMPREPS_INDEX		23
#define ICMP_OUTADDRMASKS_INDEX			24
#define ICMP_OUTADDRMASKREPS_INDEX		25


// 
// This is the array of the Object Identifier Strings for the Network Interface
// performance data kept by SNMP agents that are interesting to the 
// Performance Monitor.
//


#define NO_OF_IF_OIDS	14	// Number of Network Interface Oids used


CHAR *IfOidStr[NO_OF_IF_OIDS] =
{
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifIndex",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifSpeed",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInOctets", 
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInUcastPkts",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInNUcastPkts", 
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInDiscards",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInErrors",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInUnknownProtos",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutOctets", 
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutUcastPkts",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutNUcastPkts", 
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutDiscards",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutErrors",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutQLen"
};



//
// The indices of the various counters in the above array.
//

#define IF_INDEX_INDEX				0
#define IF_SPEED_INDEX				1
#define IF_INOCTETS_INDEX			2
#define IF_INUCASTPKTS_INDEX			3
#define IF_INNUCASTPKTS_INDEX			4
#define IF_INDISCARDS_INDEX			5
#define IF_INERRORS_INDEX			6
#define IF_INUNKNOWNPROTOS_INDEX		7
#define IF_OUTOCTETS_INDEX			8
#define IF_OUTUCASTPKTS_INDEX			9
#define IF_OUTNUCASTPKTS_INDEX			10
#define IF_OUTDISCARDS_INDEX			11
#define IF_OUTERRORS_INDEX			12
#define IF_OUTQLEN_INDEX			13


SNMPAPI SnmpMgrText2Oid (
    IN LPSTR string,
    OUT AsnObjectIdentifier *oid);

#endif //_PERFTCP_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\perfnbt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

      perfnbt.h  

Abstract:

   This file provides the function prototypes for the routines
   to open, collect and close Nbt Performance Data. It also
   provides the perfnbt.c module with some structure and
   constant definitions.

Author:

   Christos Tsollis 8/26/92  

Revision History:


--*/
#ifndef  _PERFNBT_H_
#define  _PERFNBT_H_

// 
//  Nbt structures and constants (many of them are really defined in 
//  <sys\snet\nbt_stat.h>
//

#define NBT_DEVICE 		"\\Device\\Streams\\nbt"
#define MAX_ENDPOINTS_PER_MSG	32   // max no. of ENDPOINT_INFOs per message
#define HOSTNAME_LENGTH		17
#define SCOPE_ID_LENGTH		240
#define NBT_ENDPOINT_INFO	NBT_XEBINFO


//
// Structures passed/returned in s_ioctl() command
//

typedef struct nbt_stat		NBT_STATUS;
typedef struct nbt_info		NBT_INFO; 


//
// Per Endpoint (Connection) Data
//

typedef struct xebinfo		ENDPOINT_INFO;

    
//
// Other structures
//

typedef struct strbuf		BUFFER_STRUCT;
typedef struct strioctl		IOCTL_STRUCT;

//
// Prototypes for the Nbt routines
//

extern DWORD OpenNbtPerformanceData (IN LPWSTR);
extern DWORD CollectNbtPerformanceData (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
extern DWORD CloseNbtPerformanceData ();

SIZE_T
trimspaces(
    IN PCHAR string,
    IN SIZE_T len
    );

#endif //_PERFNBT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\perfnbt.c ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfnbt.c

Abstract:

   This file implements the Extensible Objects for
   the LAN object types

Created:


Revision History:

--*/
//
// include files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>
#include <windows.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <winperf.h>
#include "perfctr.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "perfnbt.h"
#include "datanbt.h"

// New header file for getting nbt data
#pragma warning (disable : 4201)
#include <tdi.h>
#include <nbtioctl.h>
#pragma warning (default : 4201)

enum eSTATE
{
    NBT_RECONNECTING,      // waiting for the worker thread to run NbtConnect
    NBT_IDLE,              // not Transport connection
    NBT_ASSOCIATED,        // associated with an address element
    NBT_CONNECTING,        // establishing Transport connection
    NBT_SESSION_INBOUND,   // waiting for a session request after tcp connection setup inbound
    NBT_SESSION_WAITACCEPT, // waiting for accept after a listen has been satisfied
    NBT_SESSION_OUTBOUND,  // waiting for a session response after tcp connection setup
    NBT_SESSION_UP,        // got positive response
    NBT_DISCONNECTING,     // sent a disconnect down to Tcp, but it hasn't completed yet
    NBT_DISCONNECTED      // a session has been disconnected but not closed with TCP yet
};

//
//  References to constants which initialize the Object type definitions
//

extern NBT_DATA_DEFINITION NbtDataDefinition;

#define NBT_CONNECTION_NAME_LENGTH     17
#define NETBIOS_NAME_SIZE              NBT_CONNECTION_NAME_LENGTH-1

//
// Nbt data structures
//

typedef struct _NBT_DEVICE_DATA {
   HANDLE            hFileHandle;
   UNICODE_STRING    DeviceName;
} NBT_DEVICE_DATA, *PNBT_DEVICE_DATA;

PNBT_DEVICE_DATA     pNbtDeviceData;
int                  MaxNbtDeviceName;
int                  NumberOfNbtDevices = 0;

// initial count - will update to last
PVOID                pNbtDataBuffer = NULL;
int                  NbtDataBufferSize;

LONG                dwNbtRefCount = 0;

// HANDLE NbtHandle = INVALID_HANDLE_VALUE; // Handle of Nbt Device


#define NBT_CONTROLLING_STREAM   "CSB" // Ignore Controlling Stream XEB
#define NBT_LISTEN_CONNECTION    3     // All NBT connections with type <= 3,
                                       // are just listening for clients


// The error value returned by the perfctrs.dll when an error occurs while we
// are getting the data for the NBT connections.
// The error codes we get from the socket calls (OpenStream(), s_ioctl(),
// getmsg()) are Unix errors, not Dos or Windows errors. Hopefully, somebody
// will implement the conversion from these errors to Windows errors.
// The error value is not used within the Collect data routine because this
// routine shouldn't return an error in case it fails to collect Nbt data from
// connections. In this case, it just returns the buffer it was supposed to
// place the data into, unchanged.

#define ERROR_NBT_NET_RESPONSE   \
         (RtlNtStatusToDosError(STATUS_INVALID_NETWORK_RESPONSE))

#define     BUFF_SIZE   4096

PM_OPEN_PROC    OpenNbtPerformanceData;
PM_COLLECT_PROC CollectNbtPerformanceData;
PM_CLOSE_PROC   CloseNbtPerformanceData;

//------------------------------------------------------------------------
NTSTATUS
OpenNbt(
    IN char                *path,
    OUT PHANDLE            pHandle,
    OUT UNICODE_STRING     *uc_name_string
)

/*++

Routine Description:

    This function opens a stream.

Arguments:

    path        - path to the STREAMS driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    HANDLE              StreamHandle = NULL;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    NTSTATUS            status;

    RtlInitString(&name_string, path);

    RtlAnsiStringToUnicodeString(uc_name_string, & name_string, TRUE);
    InitializeObjectAttributes(
            & ObjectAttributes,
            uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

    status =
            NtCreateFile(
                    & StreamHandle,
                    SYNCHRONIZE | FILE_READ_DATA ,
//                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                    & ObjectAttributes,
                    & IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0);

    * pHandle = StreamHandle;

    return(status);

} // Open_nbt

NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS                        status;
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
    IO_STATUS_BLOCK                 iosb;
    PVOID                           pInput;
    ULONG                           SizeInput;

    if (Ioctl == IOCTL_TDI_QUERY_INFORMATION)
    {
        pInput = &QueryInfo;
        QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status or whatever
        SizeInput = sizeof(TDI_REQUEST_QUERY_INFORMATION);
    }
    else
    {
        pInput = NULL;
        SizeInput = 0;
    }

    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    return(status);

}  // DeviceIoCtrl


PCHAR
printable(
    IN PCHAR  string,
    IN PCHAR  StrOut
    )

/*++

Routine Description:

    This procedure converts non prinatble characaters to periods ('.')

Arguments:
    string - the string to convert
    StrOut - ptr to a string to put the converted string into

Return Value:

    a ptr to the string that was converted (Strout)

--*/
{
    PCHAR   Out;
    PCHAR   cp;
    LONG     i;

    Out = StrOut;
    for (cp = string, i= 0; i < NETBIOS_NAME_SIZE; cp++,i++) {
        if (isprint(*cp)) {
            *Out++ = *cp;
            continue;
        }

        if (*cp >= 128) { /* extended characters are ok */
            *Out++ = *cp;
            continue;
        }
        *Out++ = '.';
    }
    return(StrOut);
}  // printable


SIZE_T
trimspaces(
    IN PCHAR string,
    IN SIZE_T len
    )
{
    CHAR c;

    while (len > 1) {
        c = string[len-1];
        if ((c != ' ') && (c != '\0') && (c != '\t'))
            break;
        len--;
        string[len] = 0;
    }
    return len;
}


#pragma warning ( disable : 4127)
DWORD
OpenNbtPerformanceData (
   IN LPWSTR dwVoid            // not used by this routine
)

/*++


Routine Description:

    This routine will open the Nbt device and remember the handle returned
    by the device.


Arguments:

    None.


Return Value:

    ERROR_NBT_NET_RESPONSE  if unable to open NBT stream device

    ERROR_SUCCESS if open was successful

--*/
{
    PCHAR   SubKeyLinkage=(PCHAR)"system\\currentcontrolset\\services\\netbt\\linkage";
    PCHAR   Linkage=(PCHAR)"Export";
    CHAR    *pBuffer = NULL;
    CHAR    *lpLocalDeviceNames;
    LONG    status, status2;
    DWORD   Type;
    ULONG   size;
    HKEY    Key = NULL;
    HANDLE  hFileHandle;
    UNICODE_STRING   fileString;
    NTSTATUS ntstatus;
    PNBT_DEVICE_DATA   pTemp;

    UNREFERENCED_PARAMETER (dwVoid);

    MonOpenEventLog(APP_NAME);

    REPORT_INFORMATION (NBT_OPEN_ENTERED, LOG_VERBOSE);

    if (InterlockedIncrement(&dwNbtRefCount) == 1) {

        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SubKeyLinkage,
                     0,
                     KEY_READ,
                     &Key);

        if (status == ERROR_SUCCESS) {
            // now read the linkage values
            size = 0;
            status2 = RegQueryValueEx(Key,
                        Linkage,
                        NULL,
                        &Type,
                        (LPBYTE)pBuffer,
                        &size);
            if ((size > 0) && (size < BUFF_SIZE) &&
                    ((status2 == ERROR_MORE_DATA) ||
                     (status2 == ERROR_SUCCESS))) {
                pBuffer = ALLOCMEM(size + sizeof(WCHAR));
                if (pBuffer == NULL) {
                    RegCloseKey(Key);
                    return ERROR_OUTOFMEMORY;
                }
                status2 = RegQueryValueEx(Key,
                            Linkage,
                            NULL,
                            &Type,
                            (LPBYTE)pBuffer,
                            &size);
            }
            RegCloseKey(Key);
            if (status2 != ERROR_SUCCESS) {
                if (pBuffer != NULL) {
                    FREEMEM(pBuffer);
                }
                return ERROR_SUCCESS;
            }
       }
       else {
          return ERROR_SUCCESS;
       }

       if (pBuffer == NULL) {
          return ERROR_SUCCESS;
       }
       lpLocalDeviceNames = pBuffer;
       while (TRUE) {

          if (*lpLocalDeviceNames == '\0') {
             break;
          }

          ntstatus = OpenNbt (lpLocalDeviceNames,
             &hFileHandle,
             &fileString);

          if (NT_SUCCESS(ntstatus)) {
             if (NumberOfNbtDevices == 0) {
                // allocate memory to hold the device data
                pNbtDeviceData = ALLOCMEM(sizeof(NBT_DEVICE_DATA));

                if (pNbtDeviceData == NULL) {
                   RtlFreeUnicodeString(&fileString);
                   if (pBuffer) {
                       FREEMEM(pBuffer);
                   }
                   NtClose(hFileHandle);
                   return ERROR_OUTOFMEMORY;
                }
             }
             else {
                // resize to hold multiple devices
                // cannot use ALLOCMEM here
                pTemp = REALLOCMEM(pNbtDeviceData,
                            sizeof(NBT_DEVICE_DATA) * (NumberOfNbtDevices + 1));
                if (pTemp == NULL) {
                   NtClose(hFileHandle);
                   RtlFreeUnicodeString(&fileString);
                   FREEMEM(pNbtDeviceData);
                   pNbtDeviceData = NULL;
                   REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
                   break;
                }
                else {
                    pNbtDeviceData = pTemp;
                }
             }

             // build the Data structure for this device instance
             pNbtDeviceData[NumberOfNbtDevices].hFileHandle
                = hFileHandle;
             pNbtDeviceData[NumberOfNbtDevices].DeviceName.MaximumLength =
                fileString.MaximumLength;
             pNbtDeviceData[NumberOfNbtDevices].DeviceName.Length =
                fileString.Length;
             pNbtDeviceData[NumberOfNbtDevices].DeviceName.Buffer =
                fileString.Buffer;
             NumberOfNbtDevices++;

             if (fileString.MaximumLength > MaxNbtDeviceName) {
                MaxNbtDeviceName = fileString.MaximumLength;
             }

              // we only support one device at this point since we cannot
              // tell which Connection goes with which device

              break;
          }  // ntstatus OK
          else {
             RtlFreeUnicodeString(&fileString);

              // increment to the next device string
             lpLocalDeviceNames += strlen(lpLocalDeviceNames) + 1;
          }
      }  // while TRUE
   }

   REPORT_SUCCESS (NBT_OPEN_PERFORMANCE_DATA, LOG_DEBUG);
   if (pBuffer) {
       FREEMEM(pBuffer);
   }
   return ERROR_SUCCESS;

}
#pragma warning ( default : 4127)


DWORD
CollectNbtPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Nbt counters.

   IN       LPWSTR   lpValueName
         pointer to a wide character null-terminated string passed by the
         registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  lpNumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.
--*/
{

   // Variables for reformatting the Nbt data

   LARGE_INTEGER UNALIGNED *pliCounter;
   NBT_DATA_DEFINITION     *pNbtDataDefinition;
   PPERF_OBJECT_TYPE       pNbtObject;
   ULONG                   SpaceNeeded;
   UNICODE_STRING          ConnectionName;
   ANSI_STRING             AnsiConnectionName;
   WCHAR                   ConnectionNameBuffer[NBT_CONNECTION_NAME_LENGTH + 20];
#if 0
   // be sure to check the reference below...
   WCHAR                   DeviceNameBuffer[NBT_CONNECTION_NAME_LENGTH + 1 + 128];
#endif
   CHAR                    AnsiConnectionNameBuffer[NBT_CONNECTION_NAME_LENGTH + 1 + 20];
   WCHAR                   TotalName[] = L"Total";
   PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
   PERF_COUNTER_BLOCK      *pPerfCounterBlock;
   CHAR                    NameOut[NETBIOS_NAME_SIZE +4];

//   int                     ConnectionCounter = 0; /* this is not used anymore */
   LARGE_INTEGER           TotalReceived, TotalSent;

   DWORD                   dwDataReturn[2];
   NTSTATUS                status;
   tCONNECTION_LIST        *pConList;
   tCONNECTIONS            *pConns;
   LONG                    Count;
   int                     i;
   int                     NumberOfConnections = 5;   // assume 5 to start

   if (lpValueName == NULL) {
       REPORT_INFORMATION (NBT_COLLECT_ENTERED, LOG_VERBOSE);
   } else {
       REPORT_INFORMATION_DATA (NBT_COLLECT_ENTERED, LOG_VERBOSE,
          lpValueName, (lstrlenW(lpValueName) * sizeof(WCHAR)));
   }


   //
   // define pointer for Object Data structure (NBT object def.)
   //

   pNbtDataDefinition = (NBT_DATA_DEFINITION *) *lppData;
   pNbtObject = (PPERF_OBJECT_TYPE) pNbtDataDefinition;

   if (!pNbtDeviceData || NumberOfNbtDevices == 0)
      {
      //
      // Error getting NBT info, so return 0 bytes, 0 objects and
      //  log error
      //
      if (NumberOfNbtDevices > 0) {
          // only report an error if there are devices
          // returning data but they can't be read.
          REPORT_ERROR (NBT_IOCTL_INFO_ERROR, LOG_USER);
      }
      *lpcbTotalBytes = (DWORD) 0;
      *lpNumObjectTypes = (DWORD) 0;
      return ERROR_SUCCESS;
      }

   if (!pNbtDataBuffer)
      {
      NbtDataBufferSize = 1024L;
      pNbtDataBuffer = ALLOCMEM(NbtDataBufferSize);
      if (!pNbtDataBuffer)
         {
         *lpcbTotalBytes = (DWORD) 0;
         *lpNumObjectTypes = (DWORD) 0;
         return ERROR_SUCCESS;
         }
      }

   REPORT_SUCCESS (NBT_IOCTL_INFO_SUCCESS, LOG_VERBOSE);


   // Compute space needed to hold NBT data
   SpaceNeeded = sizeof(NBT_DATA_DEFINITION) +
      (NumberOfConnections *
      NumberOfNbtDevices *
      (sizeof(PERF_INSTANCE_DEFINITION) +
      QWORD_MULTIPLE((NBT_CONNECTION_NAME_LENGTH + 1) * sizeof(WCHAR)) +
      QWORD_MULTIPLE(MaxNbtDeviceName)
      + SIZE_OF_NBT_DATA));

   if ( *lpcbTotalBytes < SpaceNeeded ) {
      dwDataReturn[0] = *lpcbTotalBytes;
      dwDataReturn[1] = SpaceNeeded;
      REPORT_WARNING_DATA (NBT_DATA_BUFFER_SIZE, LOG_DEBUG,
         &dwDataReturn[0], sizeof (dwDataReturn));
      return ERROR_MORE_DATA;
   }



   AnsiConnectionName.Length =
   AnsiConnectionName.MaximumLength = sizeof(AnsiConnectionNameBuffer);
   AnsiConnectionName.Buffer = AnsiConnectionNameBuffer;
   RtlZeroMemory(AnsiConnectionNameBuffer, sizeof(AnsiConnectionNameBuffer));

   //
   //  If here, then there's a object to display so initialize
   //    the Object data structure in the buffer passed to us.
   //
   RtlMoveMemory(pNbtDataDefinition, &NbtDataDefinition, sizeof(NBT_DATA_DEFINITION));
   //
   // point to where the first instance of this will be (if we find one.
   //
   pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
               (pNbtDataDefinition + 1);

   TotalReceived.LowPart =  0; // initialize counters
   TotalSent.LowPart = 0;
   TotalReceived.HighPart =  0; // initialize counters
   TotalSent.HighPart = 0;

   // NOTE:- we only support NumberOfNbtDevices == 1 since
   // DeviceIoCtrl can't tell which connection is for which NBT device
   for (i=0; i < NumberOfNbtDevices; i++)
      {
      if (pNbtDeviceData[i].hFileHandle == 0 ||
         pNbtDeviceData[i].hFileHandle == INVALID_HANDLE_VALUE)
         {
         continue;
         }

      status = STATUS_BUFFER_OVERFLOW;
      while (status == STATUS_BUFFER_OVERFLOW)
         {
         status = DeviceIoCtrl (
            pNbtDeviceData[i].hFileHandle,
            pNbtDataBuffer,
            NbtDataBufferSize,
            IOCTL_NETBT_GET_CONNECTIONS);
         if (status == STATUS_BUFFER_OVERFLOW)
            {
            // resize to hold multiple devices
            NbtDataBufferSize += 1024L;
            FREEMEM(pNbtDataBuffer);
            pNbtDataBuffer = ALLOCMEM(NbtDataBufferSize);

            if (pNbtDataBuffer == NULL || NbtDataBufferSize == 0x0FFFFL)
               {
               *lpcbTotalBytes = (DWORD) 0;
               *lpNumObjectTypes = (DWORD) 0;
               if (pNbtDataBuffer != NULL) {
                   FREEMEM(pNbtDataBuffer);
               }
               pNbtDataBuffer = NULL;
               return ERROR_SUCCESS;
               }
            }
         }  // while Buffer overflow

      pConList = (tCONNECTION_LIST *) pNbtDataBuffer;
      Count = pConList->ConnectionCount;
      pConns = pConList->ConnList;

      if (Count == 0)
         {
         continue;
         }

      if (NumberOfConnections < Count)
         {
         NumberOfConnections = Count;

         // Better check space needed to hold NBT data again
         // this is because the Count could be hugh
         SpaceNeeded = sizeof(NBT_DATA_DEFINITION) +
            (NumberOfConnections *
            NumberOfNbtDevices *
            (sizeof(PERF_INSTANCE_DEFINITION) +
            QWORD_MULTIPLE((NBT_CONNECTION_NAME_LENGTH + 1) * sizeof(WCHAR)) +
            QWORD_MULTIPLE(MaxNbtDeviceName )
            + SIZE_OF_NBT_DATA));


         if ( *lpcbTotalBytes < SpaceNeeded ) {
            dwDataReturn[0] = *lpcbTotalBytes;
            dwDataReturn[1] = SpaceNeeded;
            REPORT_WARNING_DATA (NBT_DATA_BUFFER_SIZE, LOG_DEBUG,
               &dwDataReturn[0], sizeof (dwDataReturn));
            return ERROR_MORE_DATA;
            }
         }

      while ( Count-- ) {
         if (pConns->State == NBT_SESSION_UP) {
            // only care about UP connection
            PCHAR str, strName = NULL;
            SIZE_T len;

            if (pConns->RemoteName[0]) {
                strName = pConns->RemoteName;
            }
            else if (pConns->LocalName[0]) {
                if (pConns->LocalName[NETBIOS_NAME_SIZE-1] < ' ') {
                    strName = pConns->LocalName;
                }
                else {
                    strName = pConns->RemoteName;
                }
            }
            if (strName == NULL) {
                AnsiConnectionNameBuffer[0] = ' ';
                AnsiConnectionNameBuffer[1] = 0;
                AnsiConnectionName.Length = 1;
                AnsiConnectionName.MaximumLength = 2;
            }
            else {
                str = printable(strName, NameOut);
                len = strlen(str);
                if (len >= NBT_CONNECTION_NAME_LENGTH)
                    len = NBT_CONNECTION_NAME_LENGTH - 1;    // truncate name
                len = trimspaces(str, len);
                strncpy(AnsiConnectionNameBuffer, str, len);
                AnsiConnectionNameBuffer[len] = 0;
                AnsiConnectionName.Length = (USHORT) len;
                AnsiConnectionName.MaximumLength = (USHORT) len+1;
            }

            ConnectionName.Length =
               ConnectionName.MaximumLength =
               sizeof(ConnectionNameBuffer);
            ConnectionName.Buffer = ConnectionNameBuffer;

            RtlAnsiStringToUnicodeString (&ConnectionName,
               &AnsiConnectionName,
               FALSE);

#if 0
            // no need to put in device name since we can
            // only support one device
            lstrcpyW (DeviceNameBuffer, pNbtDeviceData[i].DeviceName.Buffer);
            lstrcatW (DeviceNameBuffer, L" ");
            lstrcatW (DeviceNameBuffer, ConnectionNameBuffer);

            ConnectionName.Length =
               lstrlenW (DeviceNameBuffer) * sizeof(WCHAR);
            ConnectionName.MaximumLength =
               sizeof(DeviceNameBuffer);
            ConnectionName.Buffer = DeviceNameBuffer;
#endif

            //
            //    load instance data into buffer
            //
            MonBuildInstanceDefinitionByUnicodeString (pPerfInstanceDefinition,
               (PVOID *) &pPerfCounterBlock,
               0,
               0,
               (DWORD)PERF_NO_UNIQUE_ID,   // no unique ID, Use the name instead
//               ConnectionCounter++,
               &ConnectionName);

            //
            //    adjust object size values to include new instance
            //

            pNbtObject->NumInstances++;
            //
            // initialize this instance's counter block

            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_NBT_DATA);

            pliCounter = (LARGE_INTEGER UNALIGNED * ) (pPerfCounterBlock + 2);

            *(pliCounter++) = pConns->BytesRcvd;
            TotalReceived.QuadPart = TotalReceived.QuadPart +
               pConns->BytesRcvd.QuadPart;

            *pliCounter++ = pConns->BytesSent;
            TotalSent.QuadPart = TotalSent.QuadPart +
               pConns->BytesSent.QuadPart;

            pliCounter->QuadPart = pConns->BytesRcvd.QuadPart +
               pConns->BytesSent.QuadPart;

            //
            // update pointer for next instance
            //
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
               (((PBYTE) pPerfCounterBlock) + SIZE_OF_NBT_DATA);

            }  // pConns->State == NBT_SESSION_UP

         pConns++;

         } // while ( Count-- )
      }  // for i < NumberOfNbtDevices



   // The last instance definition contains the total data from all the
   // displayed connections

   RtlInitUnicodeString (&ConnectionName, TotalName);
   MonBuildInstanceDefinitionByUnicodeString (pPerfInstanceDefinition,
            (PVOID *) &pPerfCounterBlock,
            0,
            0,
//            ConnectionCounter++,
            (DWORD)PERF_NO_UNIQUE_ID,   // no unique ID, Use the name instead
            &ConnectionName);

   //
   //    adjust object size values to include new instance
   //

   pNbtObject->NumInstances++;
   pNbtObject->TotalByteLength += QWORD_MULTIPLE(sizeof (PERF_INSTANCE_DEFINITION)
                                  + SIZE_OF_NBT_DATA);

   // initialize counter block for this instance

   pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_NBT_DATA);

   // load counters

   pliCounter = (LARGE_INTEGER UNALIGNED * ) (pPerfCounterBlock + 2);
   (*(pliCounter++)) = TotalReceived;
   (*(pliCounter++)) = TotalSent;
   pliCounter->QuadPart = TotalReceived.QuadPart + TotalSent.QuadPart;
   pliCounter++;

   // Set returned values

   *lpNumObjectTypes = NBT_NUM_PERF_OBJECT_TYPES;
   *lpcbTotalBytes = QWORD_MULTIPLE((DWORD)((LPBYTE)pliCounter-(LPBYTE)pNbtObject));
   *lppData = (LPVOID) ((PCHAR) pNbtObject + *lpcbTotalBytes);

   pNbtDataDefinition->NbtObjectType.TotalByteLength = *lpcbTotalBytes;

   REPORT_INFORMATION (NBT_COLLECT_DATA, LOG_DEBUG);
   return ERROR_SUCCESS;
}



DWORD
CloseNbtPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Nbt devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    int     i;

    REPORT_INFORMATION (NBT_CLOSE, LOG_VERBOSE);

    if (InterlockedDecrement(&dwNbtRefCount) == 0) {
        if (pNbtDeviceData) {
            for (i=0; i < NumberOfNbtDevices; i++) {
               if (pNbtDeviceData[i].DeviceName.Buffer) {
                   RtlFreeUnicodeString(&(pNbtDeviceData[i].DeviceName));
               }

               if (pNbtDeviceData[i].hFileHandle) {
                   NtClose (pNbtDeviceData[i].hFileHandle);
               }
            }

            FREEMEM(pNbtDeviceData);

            pNbtDeviceData = NULL;
            NumberOfNbtDevices = 0;
        }


        if (pNbtDataBuffer) {
              FREEMEM(pNbtDataBuffer);
              pNbtDataBuffer = NULL;
              NbtDataBufferSize = 0;
        }
    }
    MonCloseEventLog();


    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\perfctrs\perftcp.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perftcp.c

Abstract:

    This file implements the Extensible Objects for
    the TCP/IP LAN object types

Created:

    Christos Tsollis  08/26/92

Revision History:

    10/28/92    a-robw (Bob Watson)
            added Message Logging and Foreign Computer Support interface.


--*/
//
//  Disable SNMP interface
//
//      This file has been modified to circumvent the SNMP service and
//      go right to the agent DLL. In doing this, performance has been
//      improved at the expense of only being able to query the local
//      machine. The USE_SNMP flag has been used to save as much of the
//      old code as possible (it used to work) but the emphesis of this
//      modification is to make it work "around" SNMP and, as such, the
//      USE_SNMP blocks of code HAVE NOT (at this time) BEEN TESTED!
//      Caveat Emptor!  (a-robw)
//
#ifdef USE_SNMP
#undef USE_SNMP
#endif

//#define LOAD_MGMTAPI
#ifdef LOAD_MGMTAPI
#undef LOAD_MGMTAPI
#endif

#define LOAD_INETMIB1
//#ifdef LOAD_INETMIB1
//#undef LOAD_INETMIB1
//#endif

//
//  Disable DSIS interface for now
//
#ifdef USE_DSIS
#undef USE_DSIS
#endif

//
// Use IPHLPAPI.DLL
//
#ifndef USE_SNMP
#define USE_IPHLPAPI
#ifdef  LOAD_INETMIB1
#undef  LOAD_INETMIB1
#endif
#endif

//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntprfctr.h>
#include <windows.h>
#include <winperf.h>
#include <winbase.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#ifdef USE_SNMP
#include <mgmtapi.h>
#endif
#include <snmp.h>
#ifdef USE_IPHLPAPI
#include <iphlpapi.h>
#include <winsock2.h>
#endif
#include "perfctr.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "perfnbt.h"
//#include "perfdsis.h"   ! not yet !
#ifndef USE_IPHLPAPI
#include "perftcp.h"
#endif
#include "datatcp.h"

#define ALIGN_SIZE 0x00000008

//
//  Global Variables
//

//
// References to constants which initialize the Object type definitions
//

extern NET_INTERFACE_DATA_DEFINITION    NetInterfaceDataDefinition;
extern IP_DATA_DEFINITION               IpDataDefinition;
extern ICMP_DATA_DEFINITION             IcmpDataDefinition;
extern TCP_DATA_DEFINITION              TcpDataDefinition;
extern UDP_DATA_DEFINITION              UdpDataDefinition;
//IPv6
extern IP6_DATA_DEFINITION               Ip6DataDefinition;
extern ICMP6_DATA_DEFINITION			 Icmp6DataDefinition;
extern TCP6_DATA_DEFINITION              Tcp6DataDefinition;
extern UDP6_DATA_DEFINITION              Udp6DataDefinition;

HANDLE  hEventLog = NULL;

#ifndef USE_SNMP    // only include if not using SNMP interface
//
HANDLE  hSnmpEvent = NULL;  // handler for SNMP Extension Agent

#endif

//
// TCP/IP data structures
//
#ifdef USE_SNMP
LPSNMP_MGR_SESSION      TcpIpSession = (LPSNMP_MGR_SESSION) NULL;
                                        // The SNMP manager session providing
                                        // the requested information.
#else
BOOL                    TcpIpSession = FALSE;
                                        // The SNMP manager session providing
                                        // the requested information.
#endif

#ifdef USE_IPHLPAPI
#define MAX_INTERFACE_LEN   MAX_PATH    // Maximum length of a network interface
                                        // name
#define DEFAULT_INTERFACES  20          // Default interfaces count

DWORD        IfNum;

// IPv6
MIB_IPSTATS  IpStats6;
MIB_ICMP_EX  IcmpStats6;
MIB_TCPSTATS TcpStats6;
MIB_UDPSTATS UdpStats6;

// IPv4
MIB_IPSTATS  IpStats;
MIB_ICMP     IcmpStats;
MIB_TCPSTATS TcpStats;
MIB_UDPSTATS UdpStats;

PMIB_IFTABLE IfTable = NULL;
DWORD        IfTableSize = 0;
#else
AsnObjectName           RefNames[NO_OF_OIDS];

RFC1157VarBind          RefVariableBindingsArray[NO_OF_OIDS],
                        VariableBindingsArray[NO_OF_OIDS];
                                        // The array of the variable bindings,
                                        // used by the SNMP agent functions
                                        // to record the info we want for the
                                        // IP, ICMP, TCP and UDP protocols




RFC1157VarBind          IFPermVariableBindingsArray[NO_OF_IF_OIDS];
                                        // The initialization array of the
                                        // variable bindings,
                                        // used by the SNMP agent functions
                                        // to record the info we want for each
                                        // of the Network Interfaces


RFC1157VarBindList      RefVariableBindings;
RFC1157VarBindList      RefIFVariableBindings;
RFC1157VarBindList      RefVariableBindingsICMP;
                                        // The headers of the lists with the
                                        // variable bindings.
                                        // The headers of the lists with the
                                        // variable bindings.

RFC1157VarBind          NetIfRequest;   // structure for net request
RFC1157VarBindList      NetIfRequestList;

//
//  Constants
//

#define TIMEOUT             500     // Communication timeout in milliseconds
#define RETRIES             5       // Communication time-out/retry count

#define MAX_INTERFACE_LEN   10      // Maximum length of a network interface
                                    // name


#define OIDS_OFFSET         0       // Offset of other than the ICMP Oids
                                    // in the VariableBindingsArray[]
#define ICMP_OIDS_OFFSET    29      // Offset of the ICMP Oids in the array



#define OIDS_LENGTH         29      // Number of the other than the ICMP
                                    // Oids in the VariableBindingsArray[]
#define ICMP_OIDS_LENGTH    26      // Number of the ICMP Oids in the array

//
// Macro Definitions (To avoid long expressions)
//

#define IF_COUNTER(INDEX)        \
                  (IFVariableBindings.list[(INDEX)].value.asnValue.counter)
#define IF_GAUGE(INDEX)                \
                  (IFVariableBindings.list[(INDEX)].value.asnValue.gauge)
#define IP_COUNTER(INDEX)        \
                  (VariableBindings.list[(INDEX)].value.asnValue.counter)
#define ICMP_COUNTER(INDEX)        \
                  (VariableBindingsICMP.list[(INDEX)].value.asnValue.counter)
#define TCP_COUNTER(INDEX)        \
                  (VariableBindings.list[(INDEX)].value.asnValue.counter)
#define UDP_COUNTER(INDEX)        \
                  (VariableBindings.list[(INDEX)].value.asnValue.counter)
#endif

#define TCP_OBJECT  0x00000001
#define UDP_OBJECT  0x00000002
#define IP_OBJECT   0x00000004
#define ICMP_OBJECT 0x00000008

//IPv6
#define TCP6_OBJECT 0x00000010
#define UDP6_OBJECT 0x00000020
#define IP6_OBJECT  0x00000040
#define ICMP6_OBJECT 0x00000080

#define NET_OBJECT  0x00000100
#define NBT_OBJECT  0x00000200
#define SNMP_OBJECTS (TCP_OBJECT+UDP_OBJECT+IP_OBJECT+ICMP_OBJECT+NET_OBJECT+TCP6_OBJECT+IP6_OBJECT+UDP6_OBJECT+ICMP6_OBJECT)
#define SNMP_ERROR  0x40000000


#define DO_COUNTER_OBJECT(flags,counter) \
                    ((((flags) & (counter)) == (counter)) ? TRUE : FALSE)

//
//  Function Prototypes
//

PM_OPEN_PROC    OpenTcpIpPerformanceData;
PM_COLLECT_PROC CollectTcpIpPerformanceData;
PM_CLOSE_PROC   CloseTcpIpPerformanceData;

#ifdef LOAD_INETMIB1
HANDLE  hInetMibDll;
PFNSNMPEXTENSIONINIT pSnmpExtensionInit;
PFNSNMPEXTENSIONQUERY pSnmpExtensionQuery;
#endif

DWORD   dwTcpRefCount = 0;

static const WCHAR szFriendlyNetworkInterfaceNames[] = {L"FriendlyNetworkInterfaceNames"};
static const WCHAR szTcpipPerformancePath[] = {L"SYSTEM\\CurrentControlSet\\Services\\TcpIp\\Performance"};
static BOOL bUseFriendlyNames = FALSE;

__inline Assign64(
    IN LONGLONG       qwSrc,
    IN PLARGE_INTEGER pqwDest
    )
{
    PLARGE_INTEGER pqwSrc = (PLARGE_INTEGER) &qwSrc;
    pqwDest->LowPart  = pqwSrc->LowPart;
    pqwDest->HighPart = pqwSrc->HighPart;
}

static
BOOL
FriendlyNameIsSet ()
{
    BOOL bReturn = TRUE;

    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hKeyTcpipPerformance = NULL;
    DWORD   dwType = 0;
    DWORD   dwSize = 0;
    DWORD   dwValue = 0;
    
    dwStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        szTcpipPerformancePath,
        0L,
        KEY_READ,
        &hKeyTcpipPerformance);

    if (dwStatus == ERROR_SUCCESS) {
        dwSize = sizeof(dwValue);
        dwStatus = RegQueryValueExW (
            hKeyTcpipPerformance,
            szFriendlyNetworkInterfaceNames,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);

        if ((dwStatus == ERROR_SUCCESS) && (dwValue == 0) && 
            ((dwType == REG_DWORD) || ((dwType == REG_BINARY) && (dwSize == sizeof (DWORD))))) {
            bReturn = FALSE;
        }

        RegCloseKey (hKeyTcpipPerformance);
    }

    return bReturn;
}

DWORD
OpenTcpIpPerformanceData (
    IN LPWSTR dwVoid        // Argument needed only to conform to calling
                            // interface for this routine. (NT > 312) RBW
)
/*++

Routine Description:

    This routine will open all the TCP/IP devices and remember the handles
    returned by the devices.


Arguments:

    IN LPWSTR dwVoid
        not used

Return Value:

    ERROR_SUCCESS if successful completion
    error returned by OpenNbtPerformanceData
    error returned by OpenDsisPerformanceData
    or Win32 Error value

--*/
{
    DWORD         Status;
    TCHAR         ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD         cchBuffer = MAX_COMPUTERNAME_LENGTH+1;

    DWORD    dwDataReturn[2];  // event log data
#ifdef LOAD_INETMIB1
    UINT    nErrorMode;
#endif

#ifndef USE_IPHLPAPI
    register i;
#ifdef LOAD_MGMTAPI
    HANDLE  hMgmtApiDll;    // handle to library
    FARPROC     SnmpMgrStrToOid;    // address of function
#else
#define     SnmpMgrStrToOid(a,b)    SnmpMgrText2Oid((a),(b))
#endif

#ifdef LOAD_INETMIB1
    AsnObjectIdentifier     SnmpOid;
#endif
#endif

    UNREFERENCED_PARAMETER (dwVoid);
    
    MonOpenEventLog (APP_NAME);

    REPORT_INFORMATION (TCP_OPEN_ENTERED, LOG_VERBOSE);

    HEAP_PROBE();

    if (dwTcpRefCount == 0) {
        // Open NBT
        Status = OpenNbtPerformanceData (0L);
        if ( Status != ERROR_SUCCESS ) {
            // NBT reports any Open errors to the user
            REPORT_ERROR (TCP_NBT_OPEN_FAIL, LOG_DEBUG);
            return Status;
        }
        REPORT_INFORMATION (TCP_NBT_OPEN_SUCCESS, LOG_VERBOSE);

#ifdef USE_DSIS
        Status = OpenDsisPerformanceData (0L);
        if (Status != ERROR_SUCCESS) {
            // DSIS Open reports Open errors to the user
            REPORT_ERROR  (TCP_DSIS_OPEN_FAIL, LOG_DEBUG);
            return (Status);
        }

        REPORT_INFORMATION (TCP_DSIS_OPEN_SUCCESS, LOG_VERBOSE);
#endif // USE_DSIS

#ifdef LOAD_MGMTAPI   // this STILL craps out

        hMgmtApiDll = LoadLibrary ("MGMTAPI.DLL");

        if (hMgmtApiDll == NULL) {
            dwDataReturn[0] = GetLastError ();
            REPORT_ERROR_DATA (TCP_LOAD_LIBRARY_FAIL, LOG_USER,
                &dwDataReturn[0], (sizeof (DWORD)));
            return (dwDataReturn[0]);
        }

        SnmpMgrStrToOid = GetProcAddress (hMgmtApiDll, "SnmpMgrStrToOid");

        if (!(BOOL)SnmpMgrStrToOid) {
            dwDataReturn[0] = GetLastError();
            REPORT_ERROR_DATA (TCP_GET_STRTOOID_ADDR_FAIL, LOG_USER,
                &dwDataReturn[0], (sizeof (DWORD)));
            CloseNbtPerformanceData ();
            FreeLibrary (hMgmtApiDll);
            return (dwDataReturn[0]);
        }
#else

        // SnmpMgrStrToOid is defined as a macro above

#endif // LOAD_MGMTAPI

#ifdef LOAD_INETMIB1   // this STILL craps out

        // don't pop up any dialog boxes
        nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);

        hInetMibDll = LoadLibrary ("INETMIB1.DLL");

        if (hInetMibDll == NULL) {
            dwDataReturn[0] = GetLastError ();
            REPORT_ERROR_DATA (TCP_LOAD_LIBRARY_FAIL, LOG_USER,
                &dwDataReturn[0], (sizeof (DWORD)));
            CloseNbtPerformanceData ();
            // restore Error Mode
            SetErrorMode (nErrorMode);
            return (dwDataReturn[0]);
        } else {
            // restore Error Mode
            SetErrorMode (nErrorMode);
        }

        pSnmpExtensionInit = (PFNSNMPEXTENSIONINIT)GetProcAddress
            (hInetMibDll, "SnmpExtensionInit");
        pSnmpExtensionQuery = (PFNSNMPEXTENSIONQUERY)GetProcAddress
            (hInetMibDll, "SnmpExtensionQuery");

        if (!pSnmpExtensionInit || !pSnmpExtensionQuery) {
            dwDataReturn[0] = GetLastError();
            REPORT_ERROR_DATA (TCP_LOAD_ROUTINE_FAIL, LOG_USER,
                &dwDataReturn[0], (sizeof (DWORD)));
            FreeLibrary (hInetMibDll);
            CloseNbtPerformanceData ();
            return (dwDataReturn[0]);
        }

#endif  // LOAD_INETMIB1
        // Initialize the Variable Binding list for IP, ICMP, TCP and UDP

        Status = 0; // initialize error count

        HEAP_PROBE();

#ifndef USE_IPHLPAPI
        for (i = 0; i < NO_OF_OIDS; i++) {
            if (!SnmpMgrStrToOid (OidStr[i], &(RefNames[i]))) {
                Status++;
                REPORT_ERROR_DATA (TCP_BAD_OBJECT, LOG_DEBUG,
                    OidStr[i], strlen(OidStr[i]));
                RefNames[i].ids = NULL;
                RefNames[i].idLength = 0;
            }
            RefVariableBindingsArray[i].value.asnType = ASN_NULL;
        }

        if (Status == 0) {
            REPORT_INFORMATION (TCP_BINDINGS_INIT, LOG_VERBOSE);
        }

        HEAP_PROBE();

        // Initialize the Variable Binding list for Network interfaces

        Status = 0;
        for (i = 0; i < NO_OF_IF_OIDS; i++) {
            if (!SnmpMgrStrToOid (IfOidStr[i], &(IFPermVariableBindingsArray[i].name))) {
                Status++;
                REPORT_ERROR_DATA (TCP_BAD_OBJECT, LOG_DEBUG,
                    IfOidStr[i], strlen(IfOidStr[i]));
            }

            IFPermVariableBindingsArray[i].value.asnType = ASN_NULL;
        }

        HEAP_PROBE();

#ifdef LOAD_MGMTAPI
        FreeLibrary (hMgmtApiDll);  // done with SnmpMgrStrToOid routine
#endif
        // initialize list structures

        RefVariableBindings.list = RefVariableBindingsArray + OIDS_OFFSET;
        RefVariableBindings.len = OIDS_LENGTH;

        RefVariableBindingsICMP.list =
            RefVariableBindingsArray + ICMP_OIDS_OFFSET;
        RefVariableBindingsICMP.len = ICMP_OIDS_LENGTH;

        RefIFVariableBindings.list = IFPermVariableBindingsArray;
        RefIFVariableBindings.len = NO_OF_IF_OIDS;
#endif

        if ( GetComputerName ((LPTSTR)ComputerName, (LPDWORD)&cchBuffer) == FALSE ) {
            dwDataReturn[0] = GetLastError();
            dwDataReturn[1] = 0;
            REPORT_ERROR_DATA (TCP_COMPUTER_NAME, LOG_USER,
                    &dwDataReturn[0], sizeof(dwDataReturn));
            CloseNbtPerformanceData ();
            return dwDataReturn[0];
        }

#ifdef USE_IPHLPAPI
        // enforce that TcpIpSession is on.
        //
        TcpIpSession = TRUE;
#else
#ifdef USE_SNMP

        // Establish the SNMP connection to communicate with the local SNMP agent

    /* This portion of the code for OpenTcpIpPerformanceData() could be used in
       the CollectTcpIpPerformanceData() routine to open an SNMP Manager session
       and collect data for the Network Interfaces, and IP, ICMP, TCP and UDP
       protocols for a remote machine.

       So, name this portion of the code: A
     */

        if ( (TcpIpSession = SnmpMgrOpen ((LPSTR) ComputerName,
                (LPSTR) "public",
                TIMEOUT,
                RETRIES)) == NULL ) {
            dwDataReturn[0] = GetLastError();
            REPORT_ERROR_DATA (TCP_SNMP_MGR_OPEN, LOG_USER,
                &dwDataReturn[0], sizeof(DWORD));
            return dwDataReturn[0];
        }

    /* End of code A
     */
#else

        // if not using the standard SNMP interface, then TcpIpSession is
        // a "boolean" to indicate if a session has been initialized and
        // can therefore be used

        TcpIpSession =  FALSE;       // make sure it's FALSE

        // initialize inet mib routines

        Status = (*pSnmpExtensionInit)(
            0L,
            &hSnmpEvent,    // event is created by Init Routine
            &SnmpOid
            );

        if (Status) {
            TcpIpSession = TRUE;   // return TRUE to indicate OK
        }

#endif  // USE_SNMP
#endif

        bUseFriendlyNames = FriendlyNameIsSet();
    }
    dwTcpRefCount++;

    HEAP_PROBE();
    REPORT_INFORMATION (TCP_OPEN_PERFORMANCE_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
} // OpenTcpIpPerformanceData



#pragma warning ( disable : 4127)
DWORD
CollectTcpIpPerformanceData(
    LPWSTR  lpValueName,
    LPVOID  *lppData,
    LPDWORD lpcbTotalBytes,
    LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for all the TCP/IP counters.

Arguments:

    Pointer to unicode string which is value passed to the registry for the
    query.

    Pointer to pointer to where to place the data.

    Size in bytes of the data buffer.


Return Value:

    Win32 Status.  If successful, pointer to where to place the data
    will be set to location following this routine's returned data block.

--*/

{


    DWORD                                Status;

    // Variables for reformatting the TCP/IP data

    register PDWORD                     pdwCounter, pdwPackets;
    NET_INTERFACE_DATA_DEFINITION       *pNetInterfaceDataDefinition;
    IP_DATA_DEFINITION                  *pIpDataDefinition;
    ICMP_DATA_DEFINITION                *pIcmpDataDefinition;
    TCP_DATA_DEFINITION                 *pTcpDataDefinition;
    UDP_DATA_DEFINITION                 *pUdpDataDefinition;
//IPv6
	IP6_DATA_DEFINITION                 *pIp6DataDefinition;
	ICMP6_DATA_DEFINITION				*pIcmp6DataDefinition;
    TCP6_DATA_DEFINITION                *pTcp6DataDefinition;
    UDP6_DATA_DEFINITION                *pUdp6DataDefinition;
    DWORD                               SpaceNeeded;
    UNICODE_STRING                      InterfaceName;
    ANSI_STRING                         AnsiInterfaceName;
    WCHAR                               InterfaceNameBuffer[MAX_INTERFACE_LEN+1];
    CHAR                                AnsiInterfaceNameBuffer[MAX_INTERFACE_LEN+1];
    register PERF_INSTANCE_DEFINITION   *pPerfInstanceDefinition;
    PERF_COUNTER_BLOCK                  *pPerfCounterBlock;
    LPVOID                              lpDataTemp;
    DWORD                               NumObjectTypesTemp;

    LPWSTR                              lpFromString;
    DWORD                               dwQueryType;
    DWORD                               dwCounterFlags;
    DWORD                               dwThisChar;
    DWORD                               dwBlockSize;

    // Variables for collecting the TCP/IP data

    AsnInteger                          ErrorStatus;
    AsnInteger                          ErrorIndex;
    DWORD                               NetInterfaces;
    DWORD                               Interface;
    DWORD                               SentTemp;
    DWORD                               ReceivedTemp;

    DWORD                               dwDataReturn[2]; // for error values
    BOOL                                bFreeName;

#ifndef USE_IPHLPAPI
    int                                 i;
    BOOL                                bStatus;
#if USE_SNMP
    RFC1157VarBind                      IFVariableBindingsArray[NO_OF_IF_OIDS];
                                         // The array of the variable bindings,
                                         // used by the SNMP agent functions
                                         // to record the info we want for each
                                         // of the Network Interfaces

    RFC1157VarBind                      *VBElem;

    AsnInteger                          VBItem;
#endif

    RFC1157VarBindList                  IFVariableBindings,
                                        IFVariableBindingsCall,
                                        VariableBindings,
                                        VariableBindingsICMP;
                                        // The header of the above list with
                                        // the variable bindings.
#endif

    //
    //  ***************** executable code starts here *******************
    //
    ErrorStatus = 0L;
    ErrorIndex = 0L;

    if (lpValueName == NULL) {
        REPORT_INFORMATION (TCP_COLLECT_ENTERED, LOG_VERBOSE);
    } else {
        REPORT_INFORMATION_DATA (TCP_COLLECT_ENTERED, LOG_VERBOSE,
            (LPVOID)lpValueName, (DWORD)(lstrlenW(lpValueName)*sizeof(WCHAR)));
    }
    //
    // IF_DATA are all in DWORDS. We need to allow 1 of the octets which
    // will be __int64
    //
    dwBlockSize = SIZE_OF_IF_DATA + (1 * sizeof(DWORD));

    HEAP_PROBE();
    //
    // before doing anything else,
    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {

        // find start of computer name to pass to CollectDsisPerformanceData
        // this should put the pointer at the first character after the space
        // presumably the computer name

        lpFromString = lpValueName +
            ((sizeof(L"Foreign ")/sizeof(WCHAR))+1);
        // check for double slash notation and move past if found

        while (*lpFromString == '\\') {
            lpFromString++;
        }

        //
        // initialize local variables for sending to CollectDsisPerformanceData
        // routine
        //
        lpDataTemp = *lppData;
        SpaceNeeded = *lpcbTotalBytes;
        NumObjectTypesTemp = *lpNumObjectTypes;

        REPORT_INFORMATION_DATA (TCP_FOREIGN_COMPUTER_CMD, LOG_VERBOSE,
            (LPVOID)lpFromString, (DWORD)(lstrlenW(lpFromString)*sizeof(WCHAR)));
#ifdef USE_DSIS
        Status = CollectDsisPerformanceData (
            lpFromString,
                (LPVOID *) &lpDataTemp,
                  (LPDWORD) &SpaceNeeded,
                  (LPDWORD) &NumObjectTypesTemp);
        //
        // look at returned arguments to see if an error occured
        //  and send the appropriate event to the event log
        //
        if (Status == ERROR_SUCCESS) {

            if (NumObjectTypesTemp > 0) {
                REPORT_INFORMATION_DATA (TCP_DSIS_COLLECT_DATA_SUCCESS, LOG_DEBUG,
                &NumObjectTypesTemp, sizeof (NumObjectTypesTemp));
            } else {
                REPORT_ERROR (TCP_DSIS_NO_OBJECTS, LOG_DEBUG);
            }

            //
            //    update main return variables
            //
            *lppData = lpDataTemp;
            *lpcbTotalBytes = SpaceNeeded;
            *lpNumObjectTypes = NumObjectTypesTemp;
            return ERROR_SUCCESS;
        } else {
            REPORT_ERROR_DATA (TCP_DSIS_COLLECT_DATA_ERROR, LOG_DEBUG,
                &Status, sizeof (Status));
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return Status;
        }
#else
        // no foreign data interface supported
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
#endif // USE_DSIS
    } // endif QueryType == Foreign

    dwCounterFlags = 0;

    // determine what to return

    if (dwQueryType == QUERY_GLOBAL) {
        dwCounterFlags |= NBT_OBJECT;
        dwCounterFlags |= SNMP_OBJECTS;
    } else if (dwQueryType == QUERY_ITEMS) {
        // check for the items provided by this routine
        //
        //  Since the data requests for the following protocols are all
        //  bundled together, we'll send back all the data. Collecting it
        //  via SNMP is the hard part. once that's done, sending it back
        //  is trivial.
        //
		
        if (IsNumberInUnicodeList (TCP_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        } else if (IsNumberInUnicodeList (UDP_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        } else if (IsNumberInUnicodeList (IP_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        } else if (IsNumberInUnicodeList (ICMP_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
		} else if (IsNumberInUnicodeList (TCP6_OBJECT_TITLE_INDEX, lpValueName)) {
			dwCounterFlags |= SNMP_OBJECTS;
		} else if (IsNumberInUnicodeList (UDP6_OBJECT_TITLE_INDEX, lpValueName)) {
			dwCounterFlags |= SNMP_OBJECTS;
		} else if (IsNumberInUnicodeList (IP6_OBJECT_TITLE_INDEX, lpValueName)) {
			dwCounterFlags |= SNMP_OBJECTS;
		} else if (IsNumberInUnicodeList (ICMP6_OBJECT_TITLE_INDEX, lpValueName)) {
			dwCounterFlags |= SNMP_OBJECTS;
        } else if (IsNumberInUnicodeList (NET_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        }

        if (IsNumberInUnicodeList (NBT_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= NBT_OBJECT;
        }
		
    }

#ifndef USE_IPHLPAPI
    // copy Binding array structures to working buffers for Snmp queries

    RtlMoveMemory (VariableBindingsArray,
        RefVariableBindingsArray,
        sizeof (RefVariableBindingsArray));

    VariableBindings.list        = VariableBindingsArray + OIDS_OFFSET;
    VariableBindings.len         = OIDS_LENGTH;

    VariableBindingsICMP.list    = VariableBindingsArray + ICMP_OIDS_OFFSET;
    VariableBindingsICMP.len     = ICMP_OIDS_LENGTH;
#endif
    if (DO_COUNTER_OBJECT (dwCounterFlags, NBT_OBJECT)) {
        // Copy the parameters. We'll call the NBT Collect routine with these
        // parameters
        lpDataTemp = *lppData;
        SpaceNeeded = *lpcbTotalBytes;
        NumObjectTypesTemp = *lpNumObjectTypes;

        // Collect NBT data
        Status = CollectNbtPerformanceData (lpValueName,
                                            (LPVOID *) &lpDataTemp,
                                            (LPDWORD) &SpaceNeeded,
                                            (LPDWORD) &NumObjectTypesTemp) ;
        if (Status != ERROR_SUCCESS)  {
            // NBT Collection routine logs error messages to user
            REPORT_ERROR_DATA (TCP_NBT_COLLECT_DATA, LOG_DEBUG,
            &Status, sizeof (Status));
            *lpcbTotalBytes = 0L;
            *lpNumObjectTypes = 0L;
            return Status;
        }
    } else {
        // Initialize the parameters. We'll use these local
        // parameters for remaining routines if NBT didn't use them
        lpDataTemp = *lppData;
        SpaceNeeded = 0;
        NumObjectTypesTemp = 0;
    }

    /* To collect data for the Network Interfaces, and IP, ICMP, TCP and UDP
    protocols for a remote machine whose name is in the Unicode string pointed
    to by the lpValueName argument of CollectTcpIpData() routine, modify the
    routine as follows:

    1. Remove all the Nbt stuff from the code.

    2. Convert the remote machine name from Unicode to Ansi, and have a local
    LPSTR variable pointing to the Ansi remote machine name.

    3. Place the above portion of the code named A after this comment.

    4. Place the code named B (which is at the end of the file) at the end
    of this routine to close the opened SNMP session.

    */

    // get network info from SNMP agent

    if ((dwCounterFlags & SNMP_OBJECTS) > 0) { // if any SNMP Objects selected
        if (TRUE) { // and not a skeleton request
#ifdef USE_SNMP
            if ( TcpIpSession == (LPSNMP_MGR_SESSION) NULL ) {
                REPORT_WARNING (TCP_NULL_SESSION, LOG_DEBUG);
                *lppData = lpDataTemp;
                *lpcbTotalBytes = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }
#else
            if (!TcpIpSession) {
                REPORT_WARNING (TCP_NULL_SESSION, LOG_DEBUG);
                *lppData = lpDataTemp;
                *lpcbTotalBytes = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }
#endif
            // Get the data for the IP, ICMP, TCP and UDP protocols, as well as
            // the number of existing network interfaces.

            // create local query list

            HEAP_PROBE();

#ifdef USE_IPHLPAPI
            Status = GetNumberOfInterfaces(&IfNum);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData          = lpDataTemp;
                *lpcbTotalBytes   = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            Status = GetIpStatisticsEx(&IpStats, AF_INET);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData          = lpDataTemp;
                *lpcbTotalBytes   = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            Status = GetTcpStatisticsEx(&TcpStats, AF_INET);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData          = lpDataTemp;
                *lpcbTotalBytes   = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            Status = GetUdpStatisticsEx(&UdpStats, AF_INET);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData          = lpDataTemp;
                *lpcbTotalBytes   = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            Status = GetIcmpStatistics(&IcmpStats);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_ICMP_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData          = lpDataTemp;
                *lpcbTotalBytes   = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

			Status = GetIpStatisticsEx(&IpStats6, AF_INET6);
            if (Status)
            {
				if (Status != ERROR_NOT_SUPPORTED) {

					dwDataReturn[0] = Status;
					dwDataReturn[1] = 0;
					REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
					&dwDataReturn[0], sizeof(dwDataReturn));
					*lppData          = lpDataTemp;
					*lpcbTotalBytes   = SpaceNeeded;
					*lpNumObjectTypes = NumObjectTypesTemp;
					return ERROR_SUCCESS;
				}
            }

            Status = GetTcpStatisticsEx(&TcpStats6, AF_INET6);
            if (Status)
            {
				if (Status != ERROR_NOT_SUPPORTED) {

					dwDataReturn[0] = Status;
					dwDataReturn[1] = 0;
					REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
					&dwDataReturn[0], sizeof(dwDataReturn));
					*lppData          = lpDataTemp;
					*lpcbTotalBytes   = SpaceNeeded;
					*lpNumObjectTypes = NumObjectTypesTemp;
					return ERROR_SUCCESS;
				}
            }

            Status = GetUdpStatisticsEx(&UdpStats6, AF_INET6);
            if (Status)
            {
				if (Status != ERROR_NOT_SUPPORTED) {

					dwDataReturn[0] = Status;
					dwDataReturn[1] = 0;
					REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
					&dwDataReturn[0], sizeof(dwDataReturn));
					*lppData          = lpDataTemp;
					*lpcbTotalBytes   = SpaceNeeded;
					*lpNumObjectTypes = NumObjectTypesTemp;
					return ERROR_SUCCESS;
				}
            }

			Status = GetIcmpStatisticsEx(&IcmpStats6, AF_INET6);
			if (Status)
			{
				if (Status != ERROR_NOT_SUPPORTED) {

					dwDataReturn[0] = Status;
					dwDataReturn[1] = 0;
					REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
					&dwDataReturn[0], sizeof(dwDataReturn));
					*lppData          = lpDataTemp;
					*lpcbTotalBytes   = SpaceNeeded;
					*lpNumObjectTypes = NumObjectTypesTemp;
					return ERROR_SUCCESS;
				}
			}

            HEAP_PROBE();
        } // endif (TRUE)
#else
#ifdef USE_SNMP
            SnmpUtilVarBindListCpy (&VariableBindings,
                &RefVariableBindings);
#else

            for (i = 0; i < NO_OF_OIDS; i++) {
                SnmpUtilOidCpy (&(RefVariableBindingsArray[i].name),
                                &(RefNames[i]));
            }

            VariableBindings.list = RtlAllocateHeap (
                RtlProcessHeap(),
                0L,
                (RefVariableBindings.len * sizeof(RFC1157VarBind)));

            if (!VariableBindings.list) {
                REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                *lppData = lpDataTemp;
                *lpcbTotalBytes = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            } else {
                RtlMoveMemory (
                    VariableBindings.list,
                    RefVariableBindings.list,
                    (RefVariableBindings.len * sizeof(RFC1157VarBind)));
                VariableBindings.len = RefVariableBindings.len;
            }
#endif

            HEAP_PROBE();

#ifdef USE_SNMP
            bStatus = SnmpMgrRequest (TcpIpSession,
                                ASN_RFC1157_GETREQUEST,
                                &VariableBindings,
                                &ErrorStatus,
                                &ErrorIndex);
#else
            bStatus = (*pSnmpExtensionQuery) (ASN_RFC1157_GETREQUEST,
                                &VariableBindings,
                                &ErrorStatus,
                                &ErrorIndex);
#endif
            if ( !bStatus ) {
                dwDataReturn[0] = ErrorStatus;
                dwDataReturn[1] = ErrorIndex;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData = lpDataTemp;
                *lpcbTotalBytes = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                SnmpUtilVarBindListFree (&VariableBindings);
                return ERROR_SUCCESS;
            }


            if ( ErrorStatus > 0 ) {
                dwDataReturn[0] = ErrorStatus;
                dwDataReturn[1] = ErrorIndex;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData = lpDataTemp;
                *lpcbTotalBytes = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                SnmpUtilVarBindListFree (&VariableBindings);
                return ERROR_SUCCESS;
            }

            HEAP_PROBE();

#ifdef USE_SNMP
            SnmpUtilVarBindListCpy (&VariableBindingsICMP,
                &RefVariableBindingsICMP);
#else
            VariableBindingsICMP.list = RtlAllocateHeap (
                RtlProcessHeap(),
                0L,
                (RefVariableBindingsICMP.len * sizeof(RFC1157VarBind)));

            if (!VariableBindingsICMP.list) {
                REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                *lppData = lpDataTemp;
                *lpcbTotalBytes = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            } else {
                RtlMoveMemory (
                    VariableBindingsICMP.list,
                    RefVariableBindingsICMP.list,
                    (RefVariableBindingsICMP.len * sizeof(RFC1157VarBind)));
                VariableBindingsICMP.len = RefVariableBindingsICMP.len;
            }
#endif

            HEAP_PROBE();

#ifdef USE_SNMP
            bStatus = SnmpMgrRequest (TcpIpSession,
                                ASN_RFC1157_GETREQUEST,
                                &VariableBindingsICMP,
                                &ErrorStatus,

#else
            bStatus = (*pSnmpExtensionQuery) (ASN_RFC1157_GETREQUEST,
                                &VariableBindingsICMP,
                                &ErrorStatus,
                                &ErrorIndex);
#endif

            if ( !bStatus ) {
                dwDataReturn[0] = ErrorStatus;
                dwDataReturn[1] = ErrorIndex;
                REPORT_ERROR_DATA (TCP_ICMP_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData = lpDataTemp;
                *lpcbTotalBytes = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;

                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);

                return ERROR_SUCCESS;
            }
            if ( ErrorStatus > 0 ) {
                dwDataReturn[0] = ErrorStatus;
                dwDataReturn[1] = ErrorIndex;
                REPORT_ERROR_DATA (TCP_ICMP_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
                *lppData = lpDataTemp;
                *lpcbTotalBytes = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;

                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);

                return ERROR_SUCCESS;
            }
        } // endif (TRUE)

        HEAP_PROBE();

        // make sure everything made it back OK

        if (VariableBindingsICMP.list == 0) {
            REPORT_WARNING (TCP_NULL_ICMP_BUFF, LOG_DEBUG);
            dwCounterFlags |= (SNMP_ERROR); // return null data
        }

        if (VariableBindings.list == 0) {
            REPORT_WARNING (TCP_NULL_TCP_BUFF, LOG_DEBUG);
            dwCounterFlags |= (SNMP_ERROR); // return null data
            dwCounterFlags &= ~NET_OBJECT; // don't do NET Interface ctrs.
        }
#endif

        if (DO_COUNTER_OBJECT(dwCounterFlags, SNMP_ERROR)) {
            REPORT_WARNING (TCP_NULL_SNMP_BUFF, LOG_USER);
        }

        if (DO_COUNTER_OBJECT (dwCounterFlags, NET_OBJECT)) {

            SpaceNeeded += QWORD_MULTIPLE(sizeof (NET_INTERFACE_DATA_DEFINITION));
            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif
                return ERROR_MORE_DATA;
            }

            pNetInterfaceDataDefinition =
                (NET_INTERFACE_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pNetInterfaceDataDefinition,
                    &NetInterfaceDataDefinition,
                    sizeof (NET_INTERFACE_DATA_DEFINITION));

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                        (pNetInterfaceDataDefinition + 1);
#ifdef USE_IPHLPAPI
            NetInterfaces = IfNum;
#else
            NetInterfaces =
                VariableBindings.list[IF_NUMBER_INDEX].value.asnValue.number;
#endif

            REPORT_INFORMATION_DATA (TCP_NET_INTERFACE, LOG_VERBOSE,
                &NetInterfaces, sizeof(NetInterfaces));

            if ( NetInterfaces ) {

                // Initialize the Variable Binding list for the
                // Network Interface Performance Data

#ifndef USE_IPHLPAPI
                HEAP_PROBE();
#ifdef USE_SNMP
                SnmpUtilVarBindListCpy (&IFVariableBindings,
                    &RefIFVariableBindings);
#else

                SnmpUtilVarBindListCpy (&IFVariableBindingsCall,
                    &RefIFVariableBindings);

                IFVariableBindings.list = RtlAllocateHeap (
                    RtlProcessHeap(),
                    0L,
                    (RefIFVariableBindings.len * sizeof(RFC1157VarBind)));

                if (!IFVariableBindings.list) {
                    REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                    *lppData = lpDataTemp;
                    *lpcbTotalBytes = SpaceNeeded;
                    *lpNumObjectTypes = NumObjectTypesTemp;
                    return ERROR_SUCCESS;
                } else {
                    RtlMoveMemory (
                        IFVariableBindings.list,
                        IFVariableBindingsCall.list,
                        (IFVariableBindingsCall.len * sizeof(RFC1157VarBind)));
                    IFVariableBindings.len = RefIFVariableBindings.len;
                }
#endif
#endif
                HEAP_PROBE();

                // Initialize buffer for the network interfaces' names

                AnsiInterfaceName.Length = 0;
                AnsiInterfaceName.MaximumLength = MAX_INTERFACE_LEN + 1;
                AnsiInterfaceName.Buffer = AnsiInterfaceNameBuffer;

            }

#ifdef USE_IPHLPAPI

            Status = GetNumberOfInterfaces(&NetInterfaces);
            if ((Status != ERROR_SUCCESS) || (NetInterfaces < DEFAULT_INTERFACES)) {
                NetInterfaces = DEFAULT_INTERFACES;
            }
            IfTableSize = SIZEOF_IFTABLE(NetInterfaces);
            Status = ERROR_INSUFFICIENT_BUFFER;
            SentTemp = 0;
            IfTable = NULL;
            while ((Status == ERROR_INSUFFICIENT_BUFFER) &&
                   (SentTemp++ < 10)) {
                if (IfTable) {
                    HeapFree(RtlProcessHeap(), 0L, IfTable);
                }
                IfTable = (PMIB_IFTABLE) RtlAllocateHeap(
                        RtlProcessHeap(), 0L, IfTableSize);
                if (!IfTable)
                {
                    REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                    *lppData = lpDataTemp;
                    *lpcbTotalBytes = SpaceNeeded;
                    *lpNumObjectTypes = NumObjectTypesTemp;
                    return ERROR_SUCCESS;
                }
                Status = GetIfTable(IfTable, & IfTableSize, FALSE);
            }
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_NET_GETNEXT_REQUEST, LOG_DEBUG,
                &dwDataReturn[0], sizeof(dwDataReturn));
#ifdef USE_IPHLPAPI
                if (IfTable) {
                    RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
                    IfTable = NULL;
                }
#endif
                *lppData          = lpDataTemp;
                *lpcbTotalBytes   = SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            NetInterfaces = IfTable->dwNumEntries;
#endif
            // Loop for every network interface

            for ( Interface = 0; Interface < NetInterfaces; Interface++ )  {

                // Get the data for the network interface
                HEAP_PROBE();
#ifndef USE_IPHLPAPI
#ifdef USE_SNMP
                bStatus = SnmpMgrRequest ( TcpIpSession,
                                    ASN_RFC1157_GETNEXTREQUEST,
                                    &IFVariableBindings,
                                    &ErrorStatus,
                                    &ErrorIndex);
#else
                bStatus = (*pSnmpExtensionQuery) (ASN_RFC1157_GETNEXTREQUEST,
                                    &IFVariableBindings,
                                    &ErrorStatus,
                                    &ErrorIndex);
#endif
                HEAP_PROBE();

                if ( ! bStatus ) {
                            continue;
                }

                if ( ErrorStatus > 0 ) {
                    dwDataReturn[0] = ErrorStatus;
                    dwDataReturn[1] = ErrorIndex;
                    REPORT_ERROR_DATA (TCP_NET_GETNEXT_REQUEST, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                    continue;
                }
#endif

                bFreeName = FALSE;
                InterfaceName.Length = 0;
                InterfaceName.MaximumLength = (MAX_INTERFACE_LEN + 1) * sizeof (WCHAR);
                InterfaceName.Buffer = InterfaceNameBuffer;

                // Everything is fine, so go get the data (prepare a new instance)
#ifdef USE_IPHLPAPI
                RtlInitAnsiString(&AnsiInterfaceName, (PCSZ) IfTable->table[Interface].bDescr);
#else
                AnsiInterfaceName.Length = (USHORT)sprintf (AnsiInterfaceNameBuffer,
                        "%ld",
                        IFVariableBindings.list[IF_INDEX_INDEX].value.asnValue.number);
#endif
                AnsiInterfaceName.Length
                    = (USHORT) trimspaces(
                                    AnsiInterfaceName.Buffer,
                                    AnsiInterfaceName.Length);

                if (AnsiInterfaceName.Length > MAX_INTERFACE_LEN) {
                    RtlInitUnicodeString(&InterfaceName, NULL);
                    if (NT_SUCCESS(RtlAnsiStringToUnicodeString(
                                        &InterfaceName,
                                        &AnsiInterfaceName,
                                        TRUE))) {
                            bFreeName = TRUE;
                    }
                    else {
                        AnsiInterfaceName.Buffer[MAX_INTERFACE_LEN] = 0;
                        AnsiInterfaceName.Length = MAX_INTERFACE_LEN;
                    }
                }
                if (AnsiInterfaceName.Length <= MAX_INTERFACE_LEN) {

                    RtlAnsiStringToUnicodeString (&InterfaceName,
                                                   &AnsiInterfaceName,
                                                   FALSE);
                }
                SpaceNeeded += QWORD_MULTIPLE(sizeof (PERF_INSTANCE_DEFINITION) +
                    InterfaceName.Length + sizeof(UNICODE_NULL) +
                    dwBlockSize);

                if ( *lpcbTotalBytes < SpaceNeeded ) {
                    dwDataReturn[0] = *lpcbTotalBytes;
                    dwDataReturn[1] = SpaceNeeded;
                    REPORT_WARNING_DATA (TCP_NET_BUFFER_SIZE, LOG_DEBUG,
                        &dwDataReturn[0], sizeof(dwDataReturn));
                    //
                    //  if the buffer size is too small here, throw everything
                    //  away (including the NBT stuff) and return buffer size
                    //  error. If all goes well the caller will call back shortly
                    //  with a larger buffer and everything will be re-collected.
                    //
                    *lpcbTotalBytes = 0;
                    *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                    SnmpUtilVarBindListFree (&IFVariableBindings);
                    SnmpUtilVarBindListFree (&VariableBindings);
                    SnmpUtilVarBindListFree (&VariableBindingsICMP);
#else
                    if (IfTable) {
                        RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
                        IfTable = NULL;
                    }
#endif
                    if (bFreeName) {
                        RtlFreeUnicodeString(&InterfaceName);
                    }

                    return ERROR_MORE_DATA;
                }

                if (bUseFriendlyNames) {
                    // replace any reserved characters in the instance name with safe ones
                    for (dwThisChar = 0; dwThisChar <= (InterfaceName.Length / sizeof (WCHAR)); dwThisChar++) {
                        switch (InterfaceName.Buffer[dwThisChar]) {
                            case L'(': InterfaceName.Buffer[dwThisChar] = L'['; break;
                            case L')': InterfaceName.Buffer[dwThisChar] = L']'; break;
                            case L'#': InterfaceName.Buffer[dwThisChar] = L'_'; break;
                            case L'/': InterfaceName.Buffer[dwThisChar] = L'_'; break;
                            case L'\\': InterfaceName.Buffer[dwThisChar] = L'_'; break;
                            default: break;
                        }
                    }
                }


                MonBuildInstanceDefinitionByUnicodeString (pPerfInstanceDefinition,
                                            (PVOID *) &pPerfCounterBlock,
                                            0,
                                            0,
                                            (bUseFriendlyNames ? (DWORD)PERF_NO_UNIQUE_ID : (DWORD)(Interface + 1)),
                                            &InterfaceName);

                if (bFreeName) {
                    RtlFreeUnicodeString(&InterfaceName);
                }
                pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(dwBlockSize);

                pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
                Assign64( IfTable->table[Interface].dwInOctets
                            + IfTable->table[Interface].dwOutOctets,
                          (PLARGE_INTEGER) pdwCounter);
    
                REPORT_INFORMATION (TCP_COPYING_DATA, LOG_VERBOSE);

                pdwPackets = pdwCounter + 2;

                pdwCounter += 4; // skip packet counters first

                *++pdwCounter = IfTable->table[Interface].dwSpeed;
                *++pdwCounter = IfTable->table[Interface].dwInOctets;

                ReceivedTemp = *++pdwCounter = IfTable->table[Interface].dwInUcastPkts;
                ReceivedTemp += *++pdwCounter = IfTable->table[Interface].dwInNUcastPkts;
                ReceivedTemp += *++pdwCounter = IfTable->table[Interface].dwInDiscards;
                ReceivedTemp += *++pdwCounter = IfTable->table[Interface].dwInErrors;
                ReceivedTemp += *++pdwCounter = IfTable->table[Interface].dwInUnknownProtos;
                *++pdwCounter = IfTable->table[Interface].dwOutOctets;
                SentTemp = *++pdwCounter = IfTable->table[Interface].dwOutUcastPkts;
                SentTemp += *++pdwCounter = IfTable->table[Interface].dwOutNUcastPkts;
                *++pdwCounter = IfTable->table[Interface].dwOutDiscards;
                *++pdwCounter = IfTable->table[Interface].dwOutErrors;
                *++pdwCounter = IfTable->table[Interface].dwOutQLen;
#else
                Assign64( IF_COUNTER(IF_INOCTETS_INDEX) +
                                        IF_COUNTER(IF_OUTOCTETS_INDEX,
                          (PLARGE_INTEGER) pdwCounter);

                REPORT_INFORMATION (TCP_COPYING_DATA, LOG_VERBOSE);

                pdwPackets = pdwCounter + 2;
                pdwCounter += 4;    // skip packet counters first
                //
                // NOTE: We are skipping 2 words for Total bytes,
                // and one each for total packets, in packets & out packets
                //

                *++pdwCounter = IF_GAUGE(IF_SPEED_INDEX);
                *++pdwCounter = IF_COUNTER(IF_INOCTETS_INDEX);

                ReceivedTemp = *++pdwCounter = IF_COUNTER(IF_INUCASTPKTS_INDEX);
                ReceivedTemp += *++pdwCounter = IF_COUNTER(IF_INNUCASTPKTS_INDEX);
                ReceivedTemp += *++pdwCounter = IF_COUNTER(IF_INDISCARDS_INDEX);
                ReceivedTemp += *++pdwCounter = IF_COUNTER(IF_INERRORS_INDEX);
                ReceivedTemp += *++pdwCounter = IF_COUNTER(IF_INUNKNOWNPROTOS_INDEX);
                *++pdwCounter = IF_COUNTER(IF_OUTOCTETS_INDEX);

                SentTemp = *pdwCounter = IF_COUNTER(IF_OUTUCASTPKTS_INDEX);
                SentTemp += *++pdwCounter = IF_COUNTER(IF_OUTNUCASTPKTS_INDEX);
                *++pdwCounter = IF_COUNTER(IF_OUTDISCARDS_INDEX);
                *++pdwCounter = IF_COUNTER(IF_OUTERRORS_INDEX);
                *++pdwCounter = IF_COUNTER(IF_OUTQLEN_INDEX);
#endif
                *pdwPackets = ReceivedTemp + SentTemp;
                *++pdwPackets = ReceivedTemp;
                *++pdwPackets = SentTemp;

                pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                        (((PBYTE) pPerfCounterBlock) + dwBlockSize);

#ifndef USE_IPHLPAPI
#if USE_SNMP
                // Prepare to get the data for the next network interface

                if ( Interface < NetInterfaces ) {

                        for ( i = 0; i < NO_OF_IF_OIDS; i++ ) {

//                        SnmpUtilOidFree (&IFVariableBindingsArray[i].name);

                        SnmpUtilOidCpy (&IFVariableBindingsArray[i].name,
                                &IFVariableBindings.list[i].name);
                        }
                }

                SnmpUtilVarBindListFree (&IFVariableBindings);

                IFVariableBindings.list = IFVariableBindingsArray;
                IFVariableBindings.len  = NO_OF_IF_OIDS;
#else
                if ( Interface < NetInterfaces ) {

                    // since SnmpExtesionQuery returned newly allocated
                    // OID buffers, we need to:
                    //  1. free the original OID Buffers
                    //  2. copy the new into the old
                    //  3. free the returned buffers (OID's and data)
                    //  4. realloc a clean "new" buffer and
                    //  5. copy the new OIDS (with empty data) into
                    //      new buffer

                    for ( i = 0; i < NO_OF_IF_OIDS; i++ ) {

//                        SnmpUtilOidFree (&IFVariableBindingsCall.list[i].name);

                        SnmpUtilOidCpy (&IFVariableBindingsCall.list[i].name,
                                &IFVariableBindings.list[i].name);

                    }
                    SnmpUtilVarBindListFree (&IFVariableBindings);

                    IFVariableBindings.list = RtlAllocateHeap (
                        RtlProcessHeap(),
                        0L,
                        (RefIFVariableBindings.len * sizeof(RFC1157VarBind)));

                    if (!VariableBindings.list) {
                        REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                        *lppData = lpDataTemp;
                        *lpcbTotalBytes = SpaceNeeded;
                        *lpNumObjectTypes = NumObjectTypesTemp;
#ifdef USE_IPHLPAPI
                        if (IfTable) {
                            RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
                            IfTable = NULL;
                        }
#endif
                        return ERROR_SUCCESS;
                    } else {
                        RtlMoveMemory (
                            IFVariableBindings.list,
                            IFVariableBindingsCall.list,
                            (IFVariableBindingsCall.len * sizeof(RFC1157VarBind)));
                        IFVariableBindings.len = RefIFVariableBindings.len;
                    }
                }

#endif
#endif
                HEAP_PROBE();
            }

            pNetInterfaceDataDefinition->NetInterfaceObjectType.TotalByteLength =
                QWORD_MULTIPLE((DWORD)((PBYTE) pPerfInstanceDefinition - (PBYTE) pNetInterfaceDataDefinition));

            pNetInterfaceDataDefinition->NetInterfaceObjectType.NumInstances =
                        NetInterfaces;

            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)pPerfInstanceDefinition;
            // SpaceNeeded is kept up already

            HEAP_PROBE();

            if ( NetInterfaces ) {
#ifndef USE_IPHLPAPI
               SnmpUtilVarBindListFree (&IFVariableBindings);
//            SnmpUtilVarBindListFree (&IFVariableBindingsCall);
               RtlFreeHeap (RtlProcessHeap(), 0L, IFVariableBindingsCall.list);
#endif
            }

            HEAP_PROBE();

        } // end if Net Counters

        // Get IP data

#ifdef USE_IPHLPAPI

        if (IfTable) {
            RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
            IfTable = NULL;
        }
#endif

        HEAP_PROBE();

        if (DO_COUNTER_OBJECT (dwCounterFlags, IP_OBJECT)) {

            SpaceNeeded += QWORD_MULTIPLE(sizeof(IP_DATA_DEFINITION)   + SIZE_OF_IP_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif
                return ERROR_MORE_DATA;
            }

            pIpDataDefinition = (IP_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pIpDataDefinition,
                &IpDataDefinition,
                sizeof (IP_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pIpDataDefinition + 1);
            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_IP_DATA);

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = IpStats.dwInReceives + IpStats.dwOutRequests;
            *++pdwCounter = IpStats.dwInReceives;
            *++pdwCounter = IpStats.dwInHdrErrors;
            *++pdwCounter = IpStats.dwInAddrErrors;
            *++pdwCounter = IpStats.dwForwDatagrams;
            *++pdwCounter = IpStats.dwInUnknownProtos;
            *++pdwCounter = IpStats.dwInDiscards;
            *++pdwCounter = IpStats.dwInDelivers;
            *++pdwCounter = IpStats.dwOutRequests;
            *++pdwCounter = IpStats.dwOutDiscards;
            *++pdwCounter = IpStats.dwOutNoRoutes;
            *++pdwCounter = IpStats.dwReasmReqds;
            *++pdwCounter = IpStats.dwReasmOks;
            *++pdwCounter = IpStats.dwReasmFails;
            *++pdwCounter = IpStats.dwFragOks;
            *++pdwCounter = IpStats.dwFragFails;
            *++pdwCounter = IpStats.dwFragCreates;
#else
            *pdwCounter = IP_COUNTER(IP_INRECEIVES_INDEX) +
                            IP_COUNTER(IP_OUTREQUESTS_INDEX);

            *++pdwCounter = IP_COUNTER(IP_INRECEIVES_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INHDRERRORS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INADDRERRORS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_FORWDATAGRAMS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INUNKNOWNPROTOS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INDISCARDS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INDELIVERS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_OUTREQUESTS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_OUTDISCARDS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_OUTNOROUTES_INDEX);
            *++pdwCounter = IP_COUNTER(IP_REASMREQDS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_REASMOKS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_REASMFAILS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_FRAGOKS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_FRAGFAILS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_FRAGCREATES_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp +=1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

        HEAP_PROBE();

        // Get ICMP data

        if (DO_COUNTER_OBJECT (dwCounterFlags, ICMP_OBJECT)) {
            // The data for the network interfaces are now ready. So, let's get
            // the data for the IP, ICMP, TCP and UDP protocols.

            SpaceNeeded += QWORD_MULTIPLE(sizeof(ICMP_DATA_DEFINITION)  + SIZE_OF_ICMP_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif
                return ERROR_MORE_DATA;
            }

            pIcmpDataDefinition = (ICMP_DATA_DEFINITION *) lpDataTemp;;

            RtlMoveMemory (pIcmpDataDefinition,
                &IcmpDataDefinition,
                sizeof (ICMP_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pIcmpDataDefinition + 1);
            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_ICMP_DATA);

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = IcmpStats.stats.icmpInStats.dwMsgs
                          + IcmpStats.stats.icmpOutStats.dwMsgs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwMsgs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwErrors;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwDestUnreachs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwTimeExcds;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwParmProbs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwSrcQuenchs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwRedirects;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwEchos;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwEchoReps;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwTimestamps;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwTimestampReps;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwAddrMasks;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwAddrMaskReps;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwMsgs;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwErrors;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwDestUnreachs;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwTimeExcds;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwParmProbs;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwSrcQuenchs;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwRedirects;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwEchos;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwEchoReps;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwTimestamps;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwTimestampReps;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwAddrMasks;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwAddrMaskReps;
#else
            *pdwCounter = ICMP_COUNTER(ICMP_INMSGS_INDEX) +
                    ICMP_COUNTER(ICMP_OUTMSGS_INDEX);

            *++pdwCounter = ICMP_COUNTER(ICMP_INMSGS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INERRORS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INDESTUNREACHS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INTIMEEXCDS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INPARMPROBS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INSRCQUENCHS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INREDIRECTS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INECHOS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INECHOREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INTIMESTAMPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INTIMESTAMPREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INADDRMASKS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INADDRMASKREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTMSGS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTERRORS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTDESTUNREACHS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTTIMEEXCDS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTPARMPROBS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTSRCQUENCHS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTREDIRECTS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTECHOS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTECHOREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTTIMESTAMPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTTIMESTAMPREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTADDRMASKS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTADDRMASKREPS_INDEX);
#endif

            HEAP_PROBE();

//            SnmpUtilVarBindListFree (&VariableBindingsICMP);

            HEAP_PROBE();

            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

#ifndef USE_IPHLPAPI
        SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif

        HEAP_PROBE();

        // Get TCP data

        if (DO_COUNTER_OBJECT (dwCounterFlags, TCP_OBJECT)) {

            // The data for the network interfaces are now ready. So, let's get
            // the data for the IP, ICMP, TCP and UDP protocols.

            SpaceNeeded += QWORD_MULTIPLE(sizeof(TCP_DATA_DEFINITION)  + SIZE_OF_TCP_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
#endif
                return ERROR_MORE_DATA;
            }

            pTcpDataDefinition = (TCP_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pTcpDataDefinition,
                &TcpDataDefinition,
                sizeof (TCP_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pTcpDataDefinition + 1);
            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_TCP_DATA);

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = TcpStats.dwInSegs + TcpStats.dwOutSegs;
            *++pdwCounter = TcpStats.dwCurrEstab;
            *++pdwCounter = TcpStats.dwActiveOpens;
            *++pdwCounter = TcpStats.dwPassiveOpens;
            *++pdwCounter = TcpStats.dwAttemptFails;
            *++pdwCounter = TcpStats.dwEstabResets;
            *++pdwCounter = TcpStats.dwInSegs;
            *++pdwCounter = TcpStats.dwOutSegs;
            *++pdwCounter = TcpStats.dwRetransSegs;
#else
            *pdwCounter = TCP_COUNTER(TCP_INSEGS_INDEX) +
                    TCP_COUNTER(TCP_OUTSEGS_INDEX);

            *++pdwCounter = TCP_GAUGE(TCP_CURRESTAB_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_ACTIVEOPENS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_PASSIVEOPENS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_ATTEMPTFAILS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_ESTABRESETS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_INSEGS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_OUTSEGS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_RETRANSSEGS_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

        HEAP_PROBE();

        // Get UDP data

        if (DO_COUNTER_OBJECT (dwCounterFlags, UDP_OBJECT)) {

            // The data for the network interfaces are now ready. So, let's get
            // the data for the IP, ICMP, TCP and UDP protocols.

            SpaceNeeded += QWORD_MULTIPLE(sizeof(UDP_DATA_DEFINITION)   + SIZE_OF_UDP_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
#endif
                return ERROR_MORE_DATA;
            }

            pUdpDataDefinition = (UDP_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pUdpDataDefinition,
                &UdpDataDefinition,
                sizeof (UDP_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pUdpDataDefinition + 1);
            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_UDP_DATA);

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = UdpStats.dwInDatagrams + UdpStats.dwOutDatagrams;
            *++pdwCounter = UdpStats.dwInDatagrams;
            *++pdwCounter = UdpStats.dwNoPorts;
            *++pdwCounter = UdpStats.dwInErrors;
            *++pdwCounter = UdpStats.dwOutDatagrams;
#else
            *pdwCounter = UDP_COUNTER(UDP_INDATAGRAMS_INDEX) +
                    UDP_COUNTER(UDP_OUTDATAGRAMS_INDEX);

            *++pdwCounter = UDP_COUNTER(UDP_INDATAGRAMS_INDEX);
            *++pdwCounter = UDP_COUNTER(UDP_NOPORTS_INDEX);
            *++pdwCounter = UDP_COUNTER(UDP_INERRORS_INDEX);
            *++pdwCounter = UDP_COUNTER(UDP_OUTDATAGRAMS_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

        HEAP_PROBE();

	    // Get IPv6 data

		if (DO_COUNTER_OBJECT (dwCounterFlags, IP6_OBJECT)) {

            SpaceNeeded += QWORD_MULTIPLE(sizeof(IP6_DATA_DEFINITION)   + SIZE_OF_IP6_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif
                return ERROR_MORE_DATA;
            }

			// PATCHIT

			pIp6DataDefinition = (IP6_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pIp6DataDefinition,
                &Ip6DataDefinition,
                sizeof (IP6_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pIp6DataDefinition + 1);
            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_IP6_DATA);

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI

            *pdwCounter   = IpStats6.dwInReceives + IpStats6.dwOutRequests;
            *++pdwCounter = IpStats6.dwInReceives;
            *++pdwCounter = IpStats6.dwInHdrErrors;
            *++pdwCounter = IpStats6.dwInAddrErrors;
            *++pdwCounter = IpStats6.dwForwDatagrams;
            *++pdwCounter = IpStats6.dwInUnknownProtos;
            *++pdwCounter = IpStats6.dwInDiscards;
            *++pdwCounter = IpStats6.dwInDelivers;
            *++pdwCounter = IpStats6.dwOutRequests;
            *++pdwCounter = IpStats6.dwOutDiscards;
            *++pdwCounter = IpStats6.dwOutNoRoutes;
            *++pdwCounter = IpStats6.dwReasmReqds;
            *++pdwCounter = IpStats6.dwReasmOks;
            *++pdwCounter = IpStats6.dwReasmFails;
            *++pdwCounter = IpStats6.dwFragOks;
            *++pdwCounter = IpStats6.dwFragFails;
            *++pdwCounter = IpStats6.dwFragCreates;
#else
            *pdwCounter = IP6_COUNTER(IP6_INRECEIVES_INDEX) +
                            IP6_COUNTER(IP6_OUTREQUESTS_INDEX);

            *++pdwCounter = IP6_COUNTER(IP6_INRECEIVES_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_INHDRERRORS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_INADDRERRORS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_FORWDATAGRAMS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_INUNKNOWNPROTOS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_INDISCARDS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_INDELIVERS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_OUTREQUESTS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_OUTDISCARDS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_OUTNOROUTES_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_REASMREQDS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_REASMOKS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_REASMFAILS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_FRAGOKS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_FRAGFAILS_INDEX);
            *++pdwCounter = IP6_COUNTER(IP6_FRAGCREATES_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp +=1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

		HEAP_PROBE();

        // Get ICMPv6 data

        if (DO_COUNTER_OBJECT (dwCounterFlags, ICMP6_OBJECT)) {

            SpaceNeeded += QWORD_MULTIPLE(sizeof(ICMP6_DATA_DEFINITION)  + SIZE_OF_ICMP6_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif
                return ERROR_MORE_DATA;
            }

            pIcmp6DataDefinition = (ICMP6_DATA_DEFINITION *) lpDataTemp;;

            RtlMoveMemory (pIcmp6DataDefinition,
                &Icmp6DataDefinition,
                sizeof (ICMP6_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pIcmp6DataDefinition + 1);
            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_ICMP6_DATA);

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI

            *pdwCounter   = IcmpStats6.icmpInStats.dwMsgs
                          + IcmpStats6.icmpOutStats.dwMsgs;
            *++pdwCounter = IcmpStats6.icmpInStats.dwMsgs;
            *++pdwCounter = IcmpStats6.icmpInStats.dwErrors;
			*++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_DST_UNREACH];
            *++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_PACKET_TOO_BIG];
            *++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_TIME_EXCEEDED];
            *++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_PARAM_PROB];
            *++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_ECHO_REQUEST];
            *++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_ECHO_REPLY];
            *++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_MEMBERSHIP_QUERY];
            *++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_MEMBERSHIP_REPORT];
            *++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ICMP6_MEMBERSHIP_REDUCTION];
			*++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ND_ROUTER_SOLICIT];
			*++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ND_ROUTER_ADVERT];
			*++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ND_NEIGHBOR_SOLICIT];
			*++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ND_NEIGHBOR_ADVERT];
			*++pdwCounter = IcmpStats6.icmpInStats.rgdwTypeCount[ND_REDIRECT];
            *++pdwCounter = IcmpStats6.icmpOutStats.dwMsgs;
            *++pdwCounter = IcmpStats6.icmpOutStats.dwErrors;
			*++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_DST_UNREACH];
            *++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_PACKET_TOO_BIG];
            *++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_TIME_EXCEEDED];
            *++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_PARAM_PROB];
            *++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_ECHO_REQUEST];
            *++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_ECHO_REPLY];
            *++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_MEMBERSHIP_QUERY];
            *++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_MEMBERSHIP_REPORT];
            *++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ICMP6_MEMBERSHIP_REDUCTION];
			*++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ND_ROUTER_SOLICIT];
			*++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ND_ROUTER_ADVERT];
			*++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ND_NEIGHBOR_SOLICIT];
			*++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ND_NEIGHBOR_ADVERT];
			*++pdwCounter = IcmpStats6.icmpOutStats.rgdwTypeCount[ND_REDIRECT];
#endif

            HEAP_PROBE();

            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

        // Get TCPv6 data
        
		if (DO_COUNTER_OBJECT (dwCounterFlags, TCP6_OBJECT)) {

            // The data for the network interfaces are now ready. So, let's get
            // the data for the IPv6, TCPv6 and UDPv6 protocols.

            SpaceNeeded += QWORD_MULTIPLE(sizeof(TCP6_DATA_DEFINITION)  + SIZE_OF_TCP6_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
#endif
                return ERROR_MORE_DATA;
            }

            pTcp6DataDefinition = (TCP6_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pTcp6DataDefinition,
                &Tcp6DataDefinition,
                sizeof (TCP6_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pTcp6DataDefinition + 1);
            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_TCP6_DATA);

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = TcpStats6.dwInSegs + TcpStats6.dwOutSegs;
            *++pdwCounter = TcpStats6.dwCurrEstab;
            *++pdwCounter = TcpStats6.dwActiveOpens;
            *++pdwCounter = TcpStats6.dwPassiveOpens;
            *++pdwCounter = TcpStats6.dwAttemptFails;
            *++pdwCounter = TcpStats6.dwEstabResets;
            *++pdwCounter = TcpStats6.dwInSegs;
            *++pdwCounter = TcpStats6.dwOutSegs;
            *++pdwCounter = TcpStats6.dwRetransSegs;
#else
            *pdwCounter = TCP6_COUNTER(TCP6_INSEGS_INDEX) +
                    TCP6_COUNTER(TCP6_OUTSEGS_INDEX);

            *++pdwCounter = TCP_GAUGE6(TCP6_CURRESTAB_INDEX);
            *++pdwCounter = TCP6_COUNTER(TCP6_ACTIVEOPENS_INDEX);
            *++pdwCounter = TCP6_COUNTER(TCP6_PASSIVEOPENS_INDEX);
            *++pdwCounter = TCP6_COUNTER(TCP6_ATTEMPTFAILS_INDEX);
            *++pdwCounter = TCP6_COUNTER(TCP6_ESTABRESETS_INDEX);
            *++pdwCounter = TCP6_COUNTER(TCP6_INSEGS_INDEX);
            *++pdwCounter = TCP6_COUNTER(TCP6_OUTSEGS_INDEX);
            *++pdwCounter = TCP6_COUNTER(TCP6_RETRANSSEGS_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

        HEAP_PROBE();

        // Get UDPv6 data

        if (DO_COUNTER_OBJECT (dwCounterFlags, UDP6_OBJECT)) {

            // The data for the network interfaces are now ready. So, let's get
            // the data for the IPv6, TCPv6 and UDPv6 protocols.

            SpaceNeeded += QWORD_MULTIPLE(sizeof(UDP6_DATA_DEFINITION)   + SIZE_OF_UDP6_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn[0], sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
#endif
                return ERROR_MORE_DATA;
            }

            pUdp6DataDefinition = (UDP6_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pUdp6DataDefinition,
                &Udp6DataDefinition,
                sizeof (UDP6_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pUdp6DataDefinition + 1);
            pPerfCounterBlock->ByteLength = QWORD_MULTIPLE(SIZE_OF_UDP6_DATA);

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = UdpStats6.dwInDatagrams + UdpStats6.dwOutDatagrams;
            *++pdwCounter = UdpStats6.dwInDatagrams;
            *++pdwCounter = UdpStats6.dwNoPorts;
            *++pdwCounter = UdpStats6.dwInErrors;
            *++pdwCounter = UdpStats6.dwOutDatagrams;
#else
            *pdwCounter = UDP6_COUNTER(UDP6_INDATAGRAMS_INDEX) +
                    UDP6_COUNTER(UDP6_OUTDATAGRAMS_INDEX);

            *++pdwCounter = UDP6_COUNTER(UDP6_INDATAGRAMS_INDEX);
            *++pdwCounter = UDP6_COUNTER(UDP6_NOPORTS_INDEX);
            *++pdwCounter = UDP6_COUNTER(UDP6_INERRORS_INDEX);
            *++pdwCounter = UDP6_COUNTER(UDP6_OUTDATAGRAMS_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

#ifndef USE_IPHLPAPI
#ifdef USE_SNMP

        // Get prepared for the next data collection

        VariableBindings.list       = VariableBindingsArray + OIDS_OFFSET;
        VariableBindings.len        = OIDS_LENGTH;
        VariableBindingsICMP.list   = VariableBindingsArray + ICMP_OIDS_OFFSET;
        VariableBindingsICMP.len    = ICMP_OIDS_LENGTH;

#else
        HEAP_PROBE();

        SnmpUtilVarBindListFree (&VariableBindings);

        HEAP_PROBE();

#endif
#endif
    } // endif SNMP Objects

    // Set the returned values

    *lppData = (LPVOID) lpDataTemp;
    *lpcbTotalBytes = SpaceNeeded;
    *lpNumObjectTypes = NumObjectTypesTemp;

    HEAP_PROBE();

    REPORT_SUCCESS (TCP_COLLECT_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
} // CollectTcpIpPerformanceData
#pragma warning ( default : 4127)

DWORD
CloseTcpIpPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to TCP/IP devices.

Arguments:

    None.


Return Value:

    Win32 Status.

--*/

{
#ifndef USE_IPHLPAPI
    int i;
#endif

    REPORT_INFORMATION (TCP_ENTERING_CLOSE, LOG_VERBOSE);

    if (dwTcpRefCount > 0) {
        dwTcpRefCount--;
        if (dwTcpRefCount == 0) {
            // Close NBT
            CloseNbtPerformanceData ();


#ifdef USE_DSIS
            // Close DSIS
            CloseDsisPerformanceData ();
#endif // USE_DSIS

            /* This portion of the code for CloseTcpIpPerformanceData() could be used in
               the CollectTcpIpPerformanceData() routine to close an open SNMP Manager
               session.

               So, name this portion of the code: B

            */
#ifdef USE_SNMP
            if ( TcpIpSession != (LPSNMP_MGR_SESSION) NULL ) {
                if ( ! SnmpMgrClose (TcpIpSession) ) {
                    REPORT_ERROR_DATA (TCP_SNMP_MGR_CLOSE, LOG_DEBUG,
                        GetLastError (), sizeof(DWORD));
                }

                TcpIpSession = (LPSNMP_MGR_SESSION) NULL;
            } else {
                REPORT_WARNING (TCP_NULL_SESSION, LOG_DEBUG);
            }

            /* End of code B
             */
#endif

            HEAP_PROBE();

#ifndef USE_IPHLPAPI
            for (i = 0; i < NO_OF_OIDS; i++) {
                SnmpUtilOidFree ( &(RefNames[i]));
            }

            HEAP_PROBE();

            for (i = 0; i < NO_OF_IF_OIDS; i++) {
                SnmpUtilOidFree (&(IFPermVariableBindingsArray[i].name));
            }

            HEAP_PROBE();
#else
            if (IfTable) {
                RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
                IfTable = NULL;
            }
#endif

#if 0
            // this is closed by the INETMIB1 on process detach
            // so we don't need to do it here.

            // close event handle used by SNMP
            if (CloseHandle (hSnmpEvent)) {
                hSnmpEvent = NULL;
            }
#endif

#ifdef LOAD_INETMIB1

            FreeLibrary (hInetMibDll);

#endif
        }
    }

    MonCloseEventLog();

    return ERROR_SUCCESS;

}   // CloseTcpIpPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\dataheap.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataheap.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Heap Performance data objects

Created:

    Adrian Marinescu  9-Mar-2000

Revision History:

--*/

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataheap.h"

// dummy variable for field sizing.

static HEAP_COUNTER_DATA   tcd;

//
//  Constant structure initializations 
//      defined in dataheap.h
//

HEAP_DATA_DEFINITION HeapDataDefinition = {
    {   0,
        sizeof(HEAP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        HEAP_OBJECT_TITLE_INDEX,
        0,
        (HEAP_OBJECT_TITLE_INDEX + 1),
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(HEAP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1762,
        0,
        1763,
        0,
        -6,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.CommittedBytes),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->CommittedBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1764,
        0,
        1765,
        0,
        -7,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.ReservedBytes),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->ReservedBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1766,
        0,
        1767,
        0,
        -7,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.VirtualBytes),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->VirtualBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1768,
        0,
        1769,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.FreeSpace),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->FreeSpace
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1770,
        0,
        1771,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.FreeListLength),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->FreeListLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1772,
        0,
        1773,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.AllocTime),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->AllocTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1774,
        0,
        1775,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.FreeTime),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->FreeTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1776,
        0,
        1777,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.UncommitedRangesLength),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->UncommitedRangesLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1778,
        0,
        1779,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.DiffOperations),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->DiffOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1780,
        0,
        1781,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LookasideAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LookasideAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1782,
        0,
        1783,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LookasideFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LookasideFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1784,
        0,
        1785,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.SmallAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->SmallAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1786,
        0,
        1787,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.SmallFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->SmallFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1788,
        0,
        1789,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.MedAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->MedAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1790,
        0,
        1791,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.MedFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->MedFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1792,
        0,
        1793,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LargeAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LargeAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1794,
        0,
        1795,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LargeFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LargeFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1796,
        0,
        1797,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.TotalAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->TotalAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1798,
        0,
        1799,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.TotalFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->TotalFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1800,
        0,
        1801,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.LookasideBlocks),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LookasideBlocks
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1802,
        0,
        1803,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.LargestLookasideDepth),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LargestLookasideDepth
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1804,
        0,
        1805,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.BlockFragmentation),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->BlockFragmentation
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1806,
        0,
        1807,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.VAFragmentation),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->VAFragmentation
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1808,
        0,
        1809,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LockContention),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LockContention
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\dataexpr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAEXPR.h

Abstract:

    Header file for the Windows NT Extended Process Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATA_EX_PROCESS_H_
#define _DATA_EX_PROCESS_H_

//
//  extended process performance definition structure
//

typedef struct _EXPROCESS_DATA_DEFINITION {
    PERF_OBJECT_TYPE        ExProcessObjectType;
    PERF_COUNTER_DEFINITION ProcessId;
    PERF_COUNTER_DEFINITION ImageReservedBytes;
    PERF_COUNTER_DEFINITION ImageFreeBytes;
    PERF_COUNTER_DEFINITION ReservedBytes;
    PERF_COUNTER_DEFINITION FreeBytes;
    PERF_COUNTER_DEFINITION CommitNoAccess;
    PERF_COUNTER_DEFINITION CommitReadOnly;
    PERF_COUNTER_DEFINITION CommitReadWrite;
    PERF_COUNTER_DEFINITION CommitWriteCopy;
    PERF_COUNTER_DEFINITION CommitExecute;
    PERF_COUNTER_DEFINITION CommitExecuteRead;
    PERF_COUNTER_DEFINITION CommitExecuteWrite;
    PERF_COUNTER_DEFINITION CommitExecuteWriteCopy;
    PERF_COUNTER_DEFINITION ReservedNoAccess;
    PERF_COUNTER_DEFINITION ReservedReadOnly;
    PERF_COUNTER_DEFINITION ReservedReadWrite;
    PERF_COUNTER_DEFINITION ReservedWriteCopy;
    PERF_COUNTER_DEFINITION ReservedExecute;
    PERF_COUNTER_DEFINITION ReservedExecuteRead;
    PERF_COUNTER_DEFINITION ReservedExecuteWrite;
    PERF_COUNTER_DEFINITION ReservedExecuteWriteCopy;
    PERF_COUNTER_DEFINITION UnassignedNoAccess;
    PERF_COUNTER_DEFINITION UnassignedReadOnly;
    PERF_COUNTER_DEFINITION UnassignedReadWrite;
    PERF_COUNTER_DEFINITION UnassignedWriteCopy;
    PERF_COUNTER_DEFINITION UnassignedExecute;
    PERF_COUNTER_DEFINITION UnassignedExecuteRead;
    PERF_COUNTER_DEFINITION UnassignedExecuteWrite;
    PERF_COUNTER_DEFINITION UnassignedExecuteWriteCopy;
    PERF_COUNTER_DEFINITION ImageTotalNoAccess;
    PERF_COUNTER_DEFINITION ImageTotalReadOnly;
    PERF_COUNTER_DEFINITION ImageTotalReadWrite;
    PERF_COUNTER_DEFINITION ImageTotalWriteCopy;
    PERF_COUNTER_DEFINITION ImageTotalExecute;
    PERF_COUNTER_DEFINITION ImageTotalExecuteRead;
    PERF_COUNTER_DEFINITION ImageTotalExecuteWrite;
    PERF_COUNTER_DEFINITION ImageTotalExecuteWriteCopy;
} EXPROCESS_DATA_DEFINITION, * PEXPROCESS_DATA_DEFINITION;

typedef struct _EXPROCESS_COUNTER_DATA {
    PERF_COUNTER_BLOCK       CounterBlock;
    DWORD                    Reserved;  // for alignment
    LONGLONG                 ProcessId;
    LONGLONG                 ImageReservedBytes;
    LONGLONG                 ImageFreeBytes;
    LONGLONG                 ReservedBytes;
    LONGLONG                 FreeBytes;
    LONGLONG                 CommitNoAccess;
    LONGLONG                 CommitReadOnly;
    LONGLONG                 CommitReadWrite;
    LONGLONG                 CommitWriteCopy;
    LONGLONG                 CommitExecute;
    LONGLONG                 CommitExecuteRead;
    LONGLONG                 CommitExecuteWrite;
    LONGLONG                 CommitExecuteWriteCopy;
    LONGLONG                 ReservedNoAccess;
    LONGLONG                 ReservedReadOnly;
    LONGLONG                 ReservedReadWrite;
    LONGLONG                 ReservedWriteCopy;
    LONGLONG                 ReservedExecute;
    LONGLONG                 ReservedExecuteRead;
    LONGLONG                 ReservedExecuteWrite;
    LONGLONG                 ReservedExecuteWriteCopy;
    LONGLONG                 UnassignedNoAccess;
    LONGLONG                 UnassignedReadOnly;
    LONGLONG                 UnassignedReadWrite;
    LONGLONG                 UnassignedWriteCopy;
    LONGLONG                 UnassignedExecute;
    LONGLONG                 UnassignedExecuteRead;
    LONGLONG                 UnassignedExecuteWrite;
    LONGLONG                 UnassignedExecuteWriteCopy;
    LONGLONG                 ImageTotalNoAccess;
    LONGLONG                 ImageTotalReadOnly;
    LONGLONG                 ImageTotalReadWrite;
    LONGLONG                 ImageTotalWriteCopy;
    LONGLONG                 ImageTotalExecute;
    LONGLONG                 ImageTotalExecuteRead;
    LONGLONG                 ImageTotalExecuteWrite;
    LONGLONG                 ImageTotalExecuteWriteCopy;
} EXPROCESS_COUNTER_DATA, *PEXPROCESS_COUNTER_DATA;

extern EXPROCESS_DATA_DEFINITION ExProcessDataDefinition;

#endif // _DATA_EX_PROCESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\dataheap.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAHEAP.h

Abstract:

    Header file for the Windows NT heap Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Adrian Marinescu  9-Mar-2000

Revision History:


--*/

#ifndef _DATAHEAP_H_
#define _DATAHEAP_H_

//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _HEAP_DATA_DEFINITION {
    PERF_OBJECT_TYPE		HeapObjectType;
    PERF_COUNTER_DEFINITION	CommittedBytes;
    PERF_COUNTER_DEFINITION	ReservedBytes;
    PERF_COUNTER_DEFINITION	VirtualBytes;
    PERF_COUNTER_DEFINITION	FreeSpace;
    PERF_COUNTER_DEFINITION	FreeListLength;
    PERF_COUNTER_DEFINITION	AllocTime;
    PERF_COUNTER_DEFINITION	FreeTime;
    PERF_COUNTER_DEFINITION	UncommitedRangesLength;
    PERF_COUNTER_DEFINITION	DiffOperations;
    PERF_COUNTER_DEFINITION	LookasideAllocs;
    PERF_COUNTER_DEFINITION	LookasideFrees;
    PERF_COUNTER_DEFINITION	SmallAllocs;
    PERF_COUNTER_DEFINITION	SmallFrees;
    PERF_COUNTER_DEFINITION	MedAllocs;
    PERF_COUNTER_DEFINITION	MedFrees;
    PERF_COUNTER_DEFINITION	LargeAllocs;
    PERF_COUNTER_DEFINITION	LargeFrees;
    PERF_COUNTER_DEFINITION	TotalAllocs;
    PERF_COUNTER_DEFINITION	TotalFrees;
    PERF_COUNTER_DEFINITION	LookasideBlocks;
    PERF_COUNTER_DEFINITION	LargestLookasideDepth;
    PERF_COUNTER_DEFINITION	BlockFragmentation;
    PERF_COUNTER_DEFINITION	VAFragmentation;
    PERF_COUNTER_DEFINITION	LockContention;
} HEAP_DATA_DEFINITION, *PHEAP_DATA_DEFINITION;


typedef struct _HEAP_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    LONG                    Reserved1;      // for alignment of longlongs
    ULONGLONG	            CommittedBytes;
    ULONGLONG	            ReservedBytes;
    ULONGLONG	            VirtualBytes;
    ULONGLONG	            FreeSpace;
    LONG	                FreeListLength;
    LONG                    Reserved2;      // for alignment of longlongs
    LONGLONG            	AllocTime;
    LONGLONG                FreeTime;
    ULONG                   UncommitedRangesLength;
    ULONG                   DiffOperations;
    ULONG                   LookasideAllocs;
    ULONG                   LookasideFrees;
    ULONG                   SmallAllocs;
    ULONG                   SmallFrees;
    ULONG                   MedAllocs;
    ULONG                   MedFrees;
    ULONG                   LargeAllocs;
    ULONG                   LargeFrees;
    ULONG                   TotalAllocs;
    ULONG                   TotalFrees;
    ULONG                   LookasideBlocks;
    ULONG                   LargestLookasideDepth;
    ULONG                   BlockFragmentation;
    ULONG                   VAFragmentation;
    ULONG                   LockContention;
    ULONG                   Reserved3;
} HEAP_COUNTER_DATA, *PHEAP_COUNTER_DATA;

extern  HEAP_DATA_DEFINITION HeapDataDefinition;

#endif // _DATAHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\dataexpr.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataexpr.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Extended Process Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataexpr.h"

// dummy variable for field sizing.
static EXPROCESS_COUNTER_DATA   ecd;

//
//  Constant structure initializations 
//      defined in dataexpr.h
//

EXPROCESS_DATA_DEFINITION ExProcessDataDefinition = {
    {   0,
        sizeof (EXPROCESS_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        EXPROCESS_OBJECT_TITLE_INDEX,
        0,
        787,
        0,
        PERF_DETAIL_WIZARD,
        (sizeof(EXPROCESS_DATA_DEFINITION) - sizeof (PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        784,
        0,
        785,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ProcessId),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ProcessId
    },              
    {   sizeof(PERF_COUNTER_DEFINITION),
        776,
        0,
        777,
        0,
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageReservedBytes),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageReservedBytes
    },              
    {   sizeof(PERF_COUNTER_DEFINITION),
        778,
        0,
        779,
        0,
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageFreeBytes),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageFreeBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        780,
        0,                                 
        781,
        0,
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedBytes),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        782,
        0,                               
        783,
        0,   
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.FreeBytes),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->FreeBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        710,
        0,                           
        711,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitNoAccess),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        712,
        0,
        713,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitReadOnly),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        714,
        0,
        715,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitReadWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        716,
        0,
        717,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        718,
        0,
        719,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitExecute),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        720,
        0,
        721,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitExecuteRead),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitExecuteRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        722,
        0,
        723,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitExecuteWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitExecuteWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        724,
        0,
        725,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitExecuteWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        726,
        0,
        727,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedNoAccess),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        728,
        0,
        729,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedReadOnly),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        730,
        0,
        731,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedReadWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        732,
        0,
        733,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        734,
        0,
        735,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedExecute),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        736,
        0,
        737,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedExecuteRead),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedExecuteRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        738,
        0,
        739,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedExecuteWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedExecuteWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        742,
        0,
        743,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedExecuteWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        744,
        0,
        745,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedNoAccess),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        746,
        0,
        747,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedReadOnly),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        748,
        0,
        749,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedReadWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        750,
        0,
        751,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        752,
        0,
        753,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedExecute),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        754,
        0,
        755,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedExecuteRead),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedExecuteRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        756,
        0,
        757,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedExecuteWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedExecuteWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        758,
        0,
        759,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedExecuteWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        760,
        0,
        761,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalNoAccess),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        762,
        0,
        763,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalReadOnly),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        764,
        0,
        765,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalReadWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        766,
        0,
        767,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        768,
        0,
        769,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalExecute),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        770,
        0,
        771,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalExecuteRead),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalExecuteRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        772,
        0,
        773,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalExecuteWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalExecuteWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        774,
        0,
        775,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalExecuteWriteCopy
    }

};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\dataimag.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAIMAG.h

Abstract:

    Header file for the Windows NT Image Details Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAPHYS_H_
#define _DATAPHYS_H_

//
//  image details disk performance definition structure
//

typedef struct _IMAGE_DATA_DEFINITION {
    PERF_OBJECT_TYPE        ImageObjectType;
    PERF_COUNTER_DEFINITION ImageAddrNoAccess;
    PERF_COUNTER_DEFINITION ImageAddrReadOnly;
    PERF_COUNTER_DEFINITION ImageAddrReadWrite;
    PERF_COUNTER_DEFINITION ImageAddrWriteCopy;
    PERF_COUNTER_DEFINITION ImageAddrExecute;
    PERF_COUNTER_DEFINITION ImageAddrExecuteReadOnly;
    PERF_COUNTER_DEFINITION ImageAddrExecuteReadWrite;
    PERF_COUNTER_DEFINITION ImageAddrExecuteWriteCopy;
} IMAGE_DATA_DEFINITION, *PIMAGE_DATA_DEFINITION;


typedef struct _IMAGE_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG                 ImageAddrNoAccess;
    LONGLONG                 ImageAddrReadOnly;
    LONGLONG                 ImageAddrReadWrite;
    LONGLONG                 ImageAddrWriteCopy;
    LONGLONG                 ImageAddrExecute;
    LONGLONG                 ImageAddrExecuteReadOnly;
    LONGLONG                 ImageAddrExecuteReadWrite;
    LONGLONG                 ImageAddrExecuteWriteCopy;
} IMAGE_COUNTER_DATA, * PIMAGE_COUNTER_DATA;

extern IMAGE_DATA_DEFINITION  ImageDataDefinition;

#endif // _DATAPHYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\datajob.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datajob.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Job Performance data objects

Created:

    Bob Watson  10-Oct-97

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datajob.h"

// dummy variable for field sizing.
static JOB_COUNTER_DATA		jcd;
static JOB_DETAILS_COUNTER_DATA		jdd;

//
//  Constant structure initializations 
//      defined in datajob.h
//

JOB_DATA_DEFINITION JobDataDefinition = {
    {   0,  // depends on number of instances found
        sizeof(JOB_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        JOB_OBJECT_TITLE_INDEX,
        0,
        JOB_OBJECT_TITLE_INDEX + 1,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(JOB_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 2,
        0,
        JOB_FIRST_COUNTER_INDEX + 3,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jcd.CurrentProcessorTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 4,
        0,
        JOB_FIRST_COUNTER_INDEX + 5,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jcd.CurrentUserTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentUserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 6,
        0,
        JOB_FIRST_COUNTER_INDEX + 7,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jcd.CurrentKernelTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentKernelTime
    },
#ifdef _DATAJOB_INCLUDE_TOTAL_COUNTERS
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 8,
        0,
        JOB_FIRST_COUNTER_INDEX + 9,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.TotalProcessorTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TotalProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 10,
        0,
        JOB_FIRST_COUNTER_INDEX + 11,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.TotalUserTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TotalUserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 12,
        0,
        JOB_FIRST_COUNTER_INDEX + 13,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.TotalKernelTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TotalKernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 22,
        0,
        JOB_FIRST_COUNTER_INDEX + 23,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.CurrentProcessorUsage),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentProcessorUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 24,
        0,
        JOB_FIRST_COUNTER_INDEX + 25,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.CurrentUserUsage),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentUserUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 26,
        0,
        JOB_FIRST_COUNTER_INDEX + 27,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.CurrentKernelUsage),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentKernelUsage
    },
#endif //_DATAJOB_INCLUDE_TOTAL_COUNTERS
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 14,
        0,
        JOB_FIRST_COUNTER_INDEX + 15,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(jcd.PageFaults),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->PageFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 16,
        0,
        JOB_FIRST_COUNTER_INDEX + 17,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jcd.TotalProcessCount),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TotalProcessCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 18,
        0,
        JOB_FIRST_COUNTER_INDEX + 19,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jcd.ActiveProcessCount),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->ActiveProcessCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 20,
        0,
        JOB_FIRST_COUNTER_INDEX + 21,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jcd.TerminatedProcessCount),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TerminatedProcessCount
    }
};

JOB_DETAILS_DATA_DEFINITION JobDetailsDataDefinition = {
    {   0,  // depends on number of instanced found
        sizeof(JOB_DETAILS_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        JOB_DETAILS_OBJECT_TITLE_INDEX,
        0,
        JOB_DETAILS_OBJECT_TITLE_INDEX + 1,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(JOB_DETAILS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        189,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jdd.ProcessorTime),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        157,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jdd.UserTime),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        159,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jdd.KernelTime),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        172,
        0,
        173,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PeakVirtualSize),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PeakVirtualSize
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        174,
        0,
        175,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.VirtualSize),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->VirtualSize
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        28,
        0,
        177,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(jdd.PageFaults),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PageFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        178,
        0,
        179,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PeakWorkingSet),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PeakWorkingSet
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        180,
        0,
        181,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.TotalWorkingSet),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->TotalWorkingSet
    },
#ifdef _DATAPROC_PRIVATE_WS_
    {   sizeof(PERF_COUNTER_DEFINITION),
        1478,
        0,
        1479,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PrivateWorkingSet),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PrivateWorkingSet
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1480,
        0,
        1481,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.SharedWorkingSet),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->SharedWorkingSet
    },
#endif
    {   sizeof(PERF_COUNTER_DEFINITION),
        182,
        0,
        183,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PeakPageFile),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PeakPageFile
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        184,
        0,
        185,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PageFile),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PageFile
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        186,
        0,
        187,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PrivatePages),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PrivatePages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        680,
        0,
        681,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.ThreadCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ThreadCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        682,
        0,
        683,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.BasePriority),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->BasePriority
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        684,
        0,
        685,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_ELAPSED_TIME,
        sizeof(jdd.ElapsedTime),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ElapsedTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        784,
        0,
        785,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.ProcessId),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1410,
        0,
        1411,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.CreatorProcessId),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->CreatorProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        57,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.PagedPool),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        59,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.NonPagedPool),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->NonPagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        952,
        0,
        953,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.HandleCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->HandleCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1412,
        0,
        1413,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.ReadOperationCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ReadOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1414,
        0,
        1415,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.WriteOperationCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->WriteOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1416,
        0,
        1417,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.DataOperationCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->DataOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1418,
        0,
        1419,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.OtherOperationCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->OtherOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1420,
        0,
        1421,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.ReadTransferCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ReadTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1422,
        0,
        1423,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.WriteTransferCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->WriteTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1424,
        0,
        1425,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.DataTransferCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->DataTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1426,
        0,
        1427,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.OtherTransferCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->OtherTransferCount
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\dataimag.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataimag.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Image Details Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataimag.h"

// dummy variable for field sizing.
static IMAGE_COUNTER_DATA   icd;

//
//  Constant structure initializations 
//      defined in dataimag.h
//
IMAGE_DATA_DEFINITION  ImageDataDefinition = {
    {   0,
        sizeof (IMAGE_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        IMAGE_OBJECT_TITLE_INDEX,
        0,
        741,
        0,
        PERF_DETAIL_WIZARD,
        (sizeof(IMAGE_DATA_DEFINITION) - sizeof (PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        788,
        0,
        789,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrNoAccess),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        790,
        0,
        791,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrReadOnly),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        792,
        0,
        793,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrReadWrite),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        794,
        0,
        795,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrWriteCopy),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        796,
        0,
        797,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrExecute),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        798,
        0,
        799,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrExecuteReadOnly),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrExecuteReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        800,
        0,
        801,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrExecuteReadWrite),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrExecuteReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        802,
        0,
        803,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrExecuteWriteCopy
    }
};



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\datajob.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

      DATAJOB.h

Abstract:

    Header file for the Windows NT Processor Job Object counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/
#ifndef _DATAJOB_H_
#define _DATAJOB_H_

// don't include the "TOTAL" counters since we are reporting only rates
// (for now) the total rates are redundant.

#ifndef _DATAJOB_INCLUDE_TOTAL_COUNTERS
#define _DATAJOB_INCLUDE_TOTAL_COUNTERS
#endif


//
//  Process data object definitions.
//
//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _JOB_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    JobObjectType;
    PERF_COUNTER_DEFINITION	    cdCurrentProcessorTime;
    PERF_COUNTER_DEFINITION	    cdCurrentUserTime;
    PERF_COUNTER_DEFINITION	    cdCurrentKernelTime;
#ifdef _DATAJOB_INCLUDE_TOTAL_COUNTERS
    PERF_COUNTER_DEFINITION	    cdTotalProcessorTime;
    PERF_COUNTER_DEFINITION	    cdTotalUserTime;
    PERF_COUNTER_DEFINITION	    cdTotalKernelTime;
    PERF_COUNTER_DEFINITION	    cdCurrentProcessorUsage;
    PERF_COUNTER_DEFINITION	    cdCurrentUserUsage;
    PERF_COUNTER_DEFINITION	    cdCurrentKernelUsage;
#endif
    PERF_COUNTER_DEFINITION	    cdPageFaults;
	PERF_COUNTER_DEFINITION		cdTotalProcessCount;
	PERF_COUNTER_DEFINITION		cdCurrentProcessCount;
	PERF_COUNTER_DEFINITION		cdTerminatedProcessCount;
} JOB_DATA_DEFINITION, * PJOB_DATA_DEFINITION;

typedef struct _JOB_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    LONGLONG                    CurrentProcessorTime;
    LONGLONG                    CurrentUserTime;
    LONGLONG                    CurrentKernelTime;
#ifdef _DATAJOB_INCLUDE_TOTAL_COUNTERS
    LONGLONG                    TotalProcessorTime;
    LONGLONG                    TotalUserTime;
    LONGLONG                    TotalKernelTime;
    LONGLONG                    CurrentProcessorUsage;
    LONGLONG                    CurrentUserUsage;
    LONGLONG                    CurrentKernelUsage;
#endif //_DATAJOB_INCLUDE_TOTAL_COUNTERS
    DWORD                  	    PageFaults;
    DWORD                  	    TotalProcessCount;
    DWORD                  	    ActiveProcessCount;
    DWORD                  	    TerminatedProcessCount;
} JOB_COUNTER_DATA, * PJOB_COUNTER_DATA;

extern JOB_DATA_DEFINITION JobDataDefinition;

typedef struct _JOB_DETAILS_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    JobDetailsObjectType;
    PERF_COUNTER_DEFINITION	    cdProcessorTime;
    PERF_COUNTER_DEFINITION	    cdUserTime;
    PERF_COUNTER_DEFINITION	    cdKernelTime;
    PERF_COUNTER_DEFINITION	    cdPeakVirtualSize;
    PERF_COUNTER_DEFINITION	    cdVirtualSize;
    PERF_COUNTER_DEFINITION	    cdPageFaults;
    PERF_COUNTER_DEFINITION	    cdPeakWorkingSet;
    PERF_COUNTER_DEFINITION	    cdTotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	PERF_COUNTER_DEFINITION		cdPrivateWorkingSet;
	PERF_COUNTER_DEFINITION		cdSharedWorkingSet;
#endif
    PERF_COUNTER_DEFINITION	    cdPeakPageFile;
    PERF_COUNTER_DEFINITION	    cdPageFile;
    PERF_COUNTER_DEFINITION	    cdPrivatePages;
    PERF_COUNTER_DEFINITION     cdThreadCount;
    PERF_COUNTER_DEFINITION     cdBasePriority;
    PERF_COUNTER_DEFINITION     cdElapsedTime;
    PERF_COUNTER_DEFINITION     cdProcessId;
    PERF_COUNTER_DEFINITION     cdCreatorProcessId;
    PERF_COUNTER_DEFINITION     cdPagedPool;
    PERF_COUNTER_DEFINITION     cdNonPagedPool;
    PERF_COUNTER_DEFINITION     cdHandleCount;
    PERF_COUNTER_DEFINITION     cdReadOperationCount;
    PERF_COUNTER_DEFINITION     cdWriteOperationCount;
    PERF_COUNTER_DEFINITION     cdDataOperationCount;
    PERF_COUNTER_DEFINITION     cdOtherOperationCount;
    PERF_COUNTER_DEFINITION     cdReadTransferCount;
    PERF_COUNTER_DEFINITION     cdWriteTransferCount;
    PERF_COUNTER_DEFINITION     cdDataTransferCount;
    PERF_COUNTER_DEFINITION     cdOtherTransferCount;
} JOB_DETAILS_DATA_DEFINITION, * PJOB_DETAILS_DATA_DEFINITION;

typedef struct _JOB_DETAILS_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                  	    PageFaults;
    LONGLONG                    ProcessorTime;
    LONGLONG                    UserTime;
    LONGLONG                    KernelTime;
    LONGLONG                    PeakVirtualSize;
    LONGLONG                    VirtualSize;
    LONGLONG               	    PeakWorkingSet;
    LONGLONG               	    TotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	DWORD						PrivateWorkingSet;
	DWORD						SharedWorkingSet;
#endif
    LONGLONG                    PeakPageFile;
    LONGLONG                    PageFile;
    LONGLONG                    PrivatePages;
    DWORD                       ThreadCount;
    DWORD                       BasePriority;
    LONGLONG                    ElapsedTime;
    LONGLONG                    ProcessId;
    LONGLONG                    CreatorProcessId;
    DWORD                       PagedPool;
    DWORD                       NonPagedPool;
    DWORD                       HandleCount;
    DWORD                       Reserved;       // for alignment
    LONGLONG                    ReadOperationCount;
    LONGLONG                    WriteOperationCount;
    LONGLONG                    DataOperationCount;
    LONGLONG                    OtherOperationCount;
    LONGLONG                    ReadTransferCount;
    LONGLONG                    WriteTransferCount;
    LONGLONG                    DataTransferCount;
    LONGLONG                    OtherTransferCount;
} JOB_DETAILS_COUNTER_DATA, *PJOB_DETAILS_COUNTER_DATA;

extern JOB_DETAILS_DATA_DEFINITION	JobDetailsDataDefinition;

#endif // _DATAJOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\dataproc.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataproc.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Process Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataproc.h"

// dummy variable for field sizing.
static PROCESS_COUNTER_DATA   pcd;

//
//  Constant structure initializations 
//      defined in dataproc.h
//

PROCESS_DATA_DEFINITION ProcessDataDefinition = {

    {   0,  // depends on number of instanced found
        sizeof(PROCESS_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        PROCESS_OBJECT_TITLE_INDEX,
        0,
        231,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(PROCESS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        189,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER,
        sizeof(pcd.ProcessorTime),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        157,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(pcd.UserTime),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        159,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(pcd.KernelTime),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        172,
        0,
        173,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PeakVirtualSize),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PeakVirtualSize
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        174,
        0,
        175,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.VirtualSize),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->VirtualSize
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        28,
        0,
        177,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(pcd.PageFaults),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PageFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        178,
        0,
        179,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PeakWorkingSet),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PeakWorkingSet
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        180,
        0,
        181,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.TotalWorkingSet),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->TotalWorkingSet
    },
#ifdef _DATAPROC_PRIVATE_WS_
    {   sizeof(PERF_COUNTER_DEFINITION),
        1478,
        0,
        1479,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PrivateWorkingSet),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PrivateWorkingSet
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1480,
        0,
        1481,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.SharedWorkingSet),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->SharedWorkingSet
    },
#endif
    {   sizeof(PERF_COUNTER_DEFINITION),
        182,
        0,
        183,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PeakPageFile),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PeakPageFile
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        184,
        0,
        185,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PageFile),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PageFile
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        186,
        0,
        187,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PrivatePages),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PrivatePages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        680,
        0,
        681,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.ThreadCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ThreadCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        682,
        0,
        683,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.BasePriority),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->BasePriority
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        684,
        0,
        685,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_ELAPSED_TIME,
        sizeof(pcd.ElapsedTime),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ElapsedTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        784,
        0,
        785,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.ProcessId),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1410,
        0,
        1411,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.CreatorProcessId),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->CreatorProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        57,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.PagedPool),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        59,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.NonPagedPool),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->NonPagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        952,
        0,
        953,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.HandleCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->HandleCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1412,
        0,
        1413,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.ReadOperationCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ReadOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1414,
        0,
        1415,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.WriteOperationCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->WriteOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1416,
        0,
        1417,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.DataOperationCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->DataOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1418,
        0,
        1419,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.OtherOperationCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->OtherOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1420,
        0,
        1421,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.ReadTransferCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ReadTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1422,
        0,
        1423,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.WriteTransferCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->WriteTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1424,
        0,
        1425,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.DataTransferCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->DataTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1426,
        0,
        1427,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.OtherTransferCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->OtherTransferCount
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\datatdet.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datatdet.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Thread Detail Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datatdet.h"

// dummy variable for field sizing.
static THREAD_DETAILS_COUNTER_DATA  tdcd;

//
//  Constant structure initializations 
//      defined in datatdet.h
//

THREAD_DETAILS_DATA_DEFINITION ThreadDetailsDataDefinition =
{
    {
        0,
        sizeof (THREAD_DETAILS_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        THREAD_DETAILS_OBJECT_TITLE_INDEX,
        0,
        (THREAD_DETAILS_OBJECT_TITLE_INDEX+1),
        0,
        PERF_DETAIL_WIZARD,
        (sizeof(THREAD_DETAILS_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) /
            sizeof (PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L, 0L},
        {0L, 0L}
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        708,
        0,
        709,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT_HEX,
        sizeof (tdcd.UserPc),
        (DWORD)(ULONG_PTR)&((PTHREAD_DETAILS_COUNTER_DATA)0)->UserPc
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\datatdet.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATATDET.h

Abstract:

    Header file for the Windows NT Thread Detail Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATA_THREAD_DETAIL_H_
#define _DATA_THREAD_DETAIL_H_

//
//  thread detail performance definition structure
//
typedef struct _THREAD_DETAILS_DATA_DEFINITION {
    PERF_OBJECT_TYPE        ThreadDetailsObjectType;
    PERF_COUNTER_DEFINITION UserPc;
} THREAD_DETAILS_DATA_DEFINITION, *PTHREAD_DETAILS_DATA_DEFINITION;

typedef struct _THREAD_DETAILS_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   Reserved;
    LONGLONG		    UserPc;
} THREAD_DETAILS_COUNTER_DATA, * PTHREAD_DETAILS_COUNTER_DATA;

extern THREAD_DETAILS_DATA_DEFINITION ThreadDetailsDataDefinition;

#endif // _DATA_THREAD_DETAIL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\datathrd.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datathrd.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Thread Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datathrd.h"

// dummy variable for field sizing.
static THREAD_COUNTER_DATA   tcd;

//
//  Constant structure initializations 
//      defined in datathrd.h
//
THREAD_DATA_DEFINITION ThreadDataDefinition = {
    {   0,
        sizeof(THREAD_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        THREAD_OBJECT_TITLE_INDEX,
        0,
        233,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(THREAD_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        146,
        0,
        197,
        0,
        -2,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.ContextSwitches),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ContextSwitches
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        191,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER,
        sizeof (tcd.ProcessorTime),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        193,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof (tcd.UserTime),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        195,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof (tcd.KernelTime),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        684,
        0,
        699,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_ELAPSED_TIME,
        sizeof (tcd.ThreadElapsedTime),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadElapsedTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        694,
        0,
        695,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ThreadPriority),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadPriority
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        682,
        0,
        697,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ThreadBasePriority),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadBasePriority
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        706,
        0,
        707,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT_HEX,
        sizeof (tcd.ThreadStartAddr),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadStartAddr
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        46,
        0,
        47,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ThreadState),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadState
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        336,
        0,
        337,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.WaitReason),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->WaitReason
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        784,
        0,
        785,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ProcessId),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        804,
        0,
        805,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ThreadId),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadId
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\dataproc.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAPROC.h

Abstract:

    Header file for the Windows NT Processor Process counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/
#ifndef _DATAPROC_H_
#define _DATAPROC_H_

#ifdef	_DATAPROC_PRIVATE_WS_
#undef	_DATAPROC_PRIVATE_WS_
#endif

//
//  Process data object definitions.
//
//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _PROCESS_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    ProcessObjectType;
    PERF_COUNTER_DEFINITION	    cdProcessorTime;
    PERF_COUNTER_DEFINITION	    cdUserTime;
    PERF_COUNTER_DEFINITION	    cdKernelTime;
    PERF_COUNTER_DEFINITION	    cdPeakVirtualSize;
    PERF_COUNTER_DEFINITION	    cdVirtualSize;
    PERF_COUNTER_DEFINITION	    cdPageFaults;
    PERF_COUNTER_DEFINITION	    cdPeakWorkingSet;
    PERF_COUNTER_DEFINITION	    cdTotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	PERF_COUNTER_DEFINITION		cdPrivateWorkingSet;
	PERF_COUNTER_DEFINITION		cdSharedWorkingSet;
#endif
	PERF_COUNTER_DEFINITION	    cdPeakPageFile;
    PERF_COUNTER_DEFINITION	    cdPageFile;
    PERF_COUNTER_DEFINITION	    cdPrivatePages;
    PERF_COUNTER_DEFINITION     cdThreadCount;
    PERF_COUNTER_DEFINITION     cdBasePriority;
    PERF_COUNTER_DEFINITION     cdElapsedTime;
    PERF_COUNTER_DEFINITION     cdProcessId;
    PERF_COUNTER_DEFINITION     cdCreatorProcessId;
    PERF_COUNTER_DEFINITION     cdPagedPool;
    PERF_COUNTER_DEFINITION     cdNonPagedPool;
    PERF_COUNTER_DEFINITION     cdHandleCount;
    PERF_COUNTER_DEFINITION     cdReadOperationCount;
    PERF_COUNTER_DEFINITION     cdWriteOperationCount;
    PERF_COUNTER_DEFINITION     cdDataOperationCount;
    PERF_COUNTER_DEFINITION     cdOtherOperationCount;
    PERF_COUNTER_DEFINITION     cdReadTransferCount;
    PERF_COUNTER_DEFINITION     cdWriteTransferCount;
    PERF_COUNTER_DEFINITION     cdDataTransferCount;
    PERF_COUNTER_DEFINITION     cdOtherTransferCount;
} PROCESS_DATA_DEFINITION, * PPROCESS_DATA_DEFINITION;

typedef struct _PROCESS_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                  	    PageFaults;
    LONGLONG                    ProcessorTime;
    LONGLONG                    UserTime;
    LONGLONG                    KernelTime;
    LONGLONG              	    PeakVirtualSize;
    LONGLONG                    VirtualSize;
    LONGLONG                  	PeakWorkingSet;
    LONGLONG                  	TotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	DWORD						PrivateWorkingSet;
	DWORD						SharedWorkingSet;
#endif
    LONGLONG                    PeakPageFile;
    LONGLONG                    PageFile;
    LONGLONG                    PrivatePages;
    DWORD                       ThreadCount;
    DWORD                       BasePriority;
    LONGLONG                    ElapsedTime;
    DWORD                       ProcessId;
    DWORD                       CreatorProcessId;
    DWORD                       PagedPool;
    DWORD                       NonPagedPool;
    DWORD                       HandleCount;
    DWORD                       Reserved;   // for alignment
    LONGLONG                    ReadOperationCount;
    LONGLONG                    WriteOperationCount;
    LONGLONG                    DataOperationCount;
    LONGLONG                    OtherOperationCount;
    LONGLONG                    ReadTransferCount;
    LONGLONG                    WriteTransferCount;
    LONGLONG                    DataTransferCount;
    LONGLONG                    OtherTransferCount;
} PROCESS_COUNTER_DATA, * PPROCESS_COUNTER_DATA;

extern PROCESS_DATA_DEFINITION ProcessDataDefinition;

#endif // _DATAPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfimag.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfimag.c

Abstract:

    This file implements an Performance Object that presents
    Image details performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "dataimag.h"

DWORD APIENTRY
BuildImageObject (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes,
    IN      BOOL    bLongImageName
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

    IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

    IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

    IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    IN      BOOL    bLongImageName
            TRUE -- use the full path of the library file name in the instance
            FALSE - use only the file name in the instance

    Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    PIMAGE_DATA_DEFINITION          pImageDataDefinition;
    PPERF_INSTANCE_DEFINITION       pPerfInstanceDefinition;
    PIMAGE_COUNTER_DATA             pICD;
    DWORD                           dwNumInstances;

    DWORD                           dwImageNameLength;

    DWORD                           dwProcessIndex;

    PPROCESS_VA_INFO                pThisProcess;
    PMODINFO                        pThisImage;

    dwNumInstances = 0;

    pImageDataDefinition = (IMAGE_DATA_DEFINITION *) *lppData;

    //
    //  Check for sufficient space for Image object type definition
    //

    TotalLen = sizeof(IMAGE_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               MAX_PROCESS_NAME_LENGTH +
               sizeof(IMAGE_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define Page File data block
    //

    memcpy(pImageDataDefinition,
        &ImageDataDefinition,
        sizeof(IMAGE_DATA_DEFINITION));

    // update object title index if this is a Long Image object

    if (bLongImageName) {
        pImageDataDefinition->ImageObjectType.ObjectNameTitleIndex =
            LONG_IMAGE_OBJECT_TITLE_INDEX;
        pImageDataDefinition->ImageObjectType.ObjectHelpTitleIndex =
            LONG_IMAGE_OBJECT_TITLE_INDEX + 1;
    }

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                &pImageDataDefinition[1];

    // Now load data for each Image

    pThisProcess = pProcessVaInfo;
    dwProcessIndex = 0;
    TotalLen = sizeof(IMAGE_DATA_DEFINITION);

    while (pThisProcess) {

        pThisImage = pThisProcess->pMemBlockInfo;

        while (pThisImage) {

            dwImageNameLength = (bLongImageName ? pThisImage->LongInstanceName->Length :
                    pThisImage->InstanceName->Length);
            dwImageNameLength += sizeof(WCHAR);
            dwImageNameLength = QWORD_MULTIPLE(dwImageNameLength);
        
            // see if this instance will fit

            TotalLen += sizeof (PERF_INSTANCE_DEFINITION) +
                dwImageNameLength + 
//                (MAX_PROCESS_NAME_LENGTH + 1) * sizeof (WCHAR) +
                sizeof (DWORD) +
                sizeof (IMAGE_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_MORE_DATA;
            }

            MonBuildInstanceDefinition (pPerfInstanceDefinition,
                (PVOID *) &pICD,
                EXPROCESS_OBJECT_TITLE_INDEX,
                dwProcessIndex,
                (DWORD)-1,
                (bLongImageName ? pThisImage->LongInstanceName->Buffer :
                    pThisImage->InstanceName->Buffer));

            pICD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(IMAGE_COUNTER_DATA));

            pICD->ImageAddrNoAccess           = pThisImage->CommitVector[NOACCESS];
            pICD->ImageAddrReadOnly           = pThisImage->CommitVector[READONLY];
            pICD->ImageAddrReadWrite          = pThisImage->CommitVector[READWRITE];
            pICD->ImageAddrWriteCopy          = pThisImage->CommitVector[WRITECOPY];
            pICD->ImageAddrExecute            = pThisImage->CommitVector[EXECUTE];
            pICD->ImageAddrExecuteReadOnly    = pThisImage->CommitVector[EXECUTEREAD];
            pICD->ImageAddrExecuteReadWrite   = pThisImage->CommitVector[EXECUTEREADWRITE];
            pICD->ImageAddrExecuteWriteCopy   = pThisImage->CommitVector[EXECUTEWRITECOPY];

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pICD[1];

            // adjust Total Length value to reflect ACTUAL size used

            TotalLen = (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pImageDataDefinition);

            dwNumInstances++;

            pThisImage = pThisImage->pNextModule;
        }
        pThisProcess = pThisProcess->pNextProcess;
        dwProcessIndex++;
    }

    pImageDataDefinition->ImageObjectType.NumInstances += dwNumInstances;

    *lpcbTotalBytes =
        pImageDataDefinition->ImageObjectType.TotalByteLength =
            QWORD_MULTIPLE(
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pImageDataDefinition));

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Image Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID) ((PCHAR) pImageDataDefinition + *lpcbTotalBytes);

    // increment number of objects in this data block
    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CollectImageObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    return BuildImageObject (
                lppData,
                lpcbTotalBytes,
                lpNumObjectTypes,
                FALSE); // use short names
}

DWORD APIENTRY
CollectLongImageObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    return BuildImageObject (
                lppData,
                lpcbTotalBytes,
                lpNumObjectTypes,
                TRUE); // use long names
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfexpr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfexpr.c

Abstract:

    This file implements an Performance Object that presents
    Extended Process performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "dataexpr.h"

DWORD APIENTRY
CollectExProcessObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block
    DWORD   NumExProcessInstances;

    PPROCESS_VA_INFO            pThisProcess;   // pointer to current process
    PERF_INSTANCE_DEFINITION    *pPerfInstanceDefinition;
    EXPROCESS_DATA_DEFINITION   *pExProcessDataDefinition;

    PEXPROCESS_COUNTER_DATA     pECD;

    if (pProcessVaInfo) {   // process only if a buffer is available
        pExProcessDataDefinition = (EXPROCESS_DATA_DEFINITION *)*lppData;

        // check for sufficient space in buffer for at least one entry

        TotalLen = sizeof(EXPROCESS_DATA_DEFINITION) +
                    sizeof(PERF_INSTANCE_DEFINITION) +
                    (MAX_PROCESS_NAME_LENGTH + 1) * sizeof (WCHAR) +
                    sizeof(EXPROCESS_COUNTER_DATA);

        if (*lpcbTotalBytes < TotalLen) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        // copy process data block to buffer

        memcpy (pExProcessDataDefinition,
                        &ExProcessDataDefinition,
                        sizeof(EXPROCESS_DATA_DEFINITION));

        NumExProcessInstances = 0;

        pThisProcess = pProcessVaInfo;

        TotalLen = sizeof(EXPROCESS_DATA_DEFINITION);

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pExProcessDataDefinition[1];

        while (pThisProcess) {

            // see if this instance will fit

            TotalLen += sizeof (PERF_INSTANCE_DEFINITION) +
                (MAX_PROCESS_NAME_LENGTH + 1) * sizeof (WCHAR) +
                sizeof (DWORD) +
                sizeof (EXPROCESS_COUNTER_DATA);

            if (*lpcbTotalBytes < TotalLen) {
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;
                return ERROR_MORE_DATA;
            }

            MonBuildInstanceDefinition (pPerfInstanceDefinition,
                (PVOID *) &pECD,
                0,
                0,
                (DWORD)-1,
                pThisProcess->pProcessName->Buffer);

            NumExProcessInstances++;

            pECD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (EXPROCESS_COUNTER_DATA));

            // load counters from the process va data structure

            pECD->ProcessId             = pThisProcess->dwProcessId;
            pECD->ImageReservedBytes    = pThisProcess->ImageReservedBytes;
            pECD->ImageFreeBytes        = pThisProcess->ImageFreeBytes;
            pECD->ReservedBytes         = pThisProcess->ReservedBytes;
            pECD->FreeBytes             = pThisProcess->FreeBytes;

            pECD->CommitNoAccess        = pThisProcess->MappedCommit[NOACCESS];
            pECD->CommitReadOnly        = pThisProcess->MappedCommit[READONLY];
            pECD->CommitReadWrite       = pThisProcess->MappedCommit[READWRITE];
            pECD->CommitWriteCopy       = pThisProcess->MappedCommit[WRITECOPY];
            pECD->CommitExecute         = pThisProcess->MappedCommit[EXECUTE];
            pECD->CommitExecuteRead     = pThisProcess->MappedCommit[EXECUTEREAD];
            pECD->CommitExecuteWrite    = pThisProcess->MappedCommit[EXECUTEREADWRITE];
            pECD->CommitExecuteWriteCopy = pThisProcess->MappedCommit[EXECUTEWRITECOPY];

            pECD->ReservedNoAccess      = pThisProcess->PrivateCommit[NOACCESS];
            pECD->ReservedReadOnly      = pThisProcess->PrivateCommit[READONLY];
            pECD->ReservedReadWrite     = pThisProcess->PrivateCommit[READWRITE];
            pECD->ReservedWriteCopy     = pThisProcess->PrivateCommit[WRITECOPY];
            pECD->ReservedExecute       = pThisProcess->PrivateCommit[EXECUTE];
            pECD->ReservedExecuteRead   = pThisProcess->PrivateCommit[EXECUTEREAD];
            pECD->ReservedExecuteWrite  = pThisProcess->PrivateCommit[EXECUTEREADWRITE];
            pECD->ReservedExecuteWriteCopy = pThisProcess->PrivateCommit[EXECUTEWRITECOPY];

            pECD->UnassignedNoAccess    = pThisProcess->OrphanTotals.CommitVector[NOACCESS];
            pECD->UnassignedReadOnly    = pThisProcess->OrphanTotals.CommitVector[READONLY];
            pECD->UnassignedReadWrite   = pThisProcess->OrphanTotals.CommitVector[READWRITE];
            pECD->UnassignedWriteCopy   = pThisProcess->OrphanTotals.CommitVector[WRITECOPY];
            pECD->UnassignedExecute     = pThisProcess->OrphanTotals.CommitVector[EXECUTE];
            pECD->UnassignedExecuteRead = pThisProcess->OrphanTotals.CommitVector[EXECUTEREAD];
            pECD->UnassignedExecuteWrite = pThisProcess->OrphanTotals.CommitVector[EXECUTEREADWRITE];
            pECD->UnassignedExecuteWriteCopy = pThisProcess->OrphanTotals.CommitVector[EXECUTEWRITECOPY];

            pECD->ImageTotalNoAccess    = pThisProcess->MemTotals.CommitVector[NOACCESS];
            pECD->ImageTotalReadOnly    = pThisProcess->MemTotals.CommitVector[READONLY];
            pECD->ImageTotalReadWrite   = pThisProcess->MemTotals.CommitVector[READWRITE];
            pECD->ImageTotalWriteCopy   = pThisProcess->MemTotals.CommitVector[WRITECOPY];
            pECD->ImageTotalExecute     = pThisProcess->MemTotals.CommitVector[EXECUTE];
            pECD->ImageTotalExecuteRead = pThisProcess->MemTotals.CommitVector[EXECUTEREAD];
            pECD->ImageTotalExecuteWrite = pThisProcess->MemTotals.CommitVector[EXECUTEREADWRITE];
            pECD->ImageTotalExecuteWriteCopy = pThisProcess->MemTotals.CommitVector[EXECUTEWRITECOPY];

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pECD[1];

            pThisProcess = pThisProcess->pNextProcess; // point to next process
        } // end while not at end of list

    } // end if valid process info buffer
    else {
        // pProcessVaInfo is NULL.  Initialize the DataDef and return
        // with no data
        pExProcessDataDefinition = (EXPROCESS_DATA_DEFINITION *)*lppData;

        TotalLen = sizeof(EXPROCESS_DATA_DEFINITION) +
            sizeof (PERF_INSTANCE_DEFINITION) +
            (MAX_PROCESS_NAME_LENGTH + 1) * sizeof (WCHAR) +
            sizeof (DWORD) +
            sizeof (EXPROCESS_COUNTER_DATA);

        if (*lpcbTotalBytes < TotalLen) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        // copy process data block to buffer

        memcpy (pExProcessDataDefinition,
                        &ExProcessDataDefinition,
                        sizeof(EXPROCESS_DATA_DEFINITION));

        NumExProcessInstances = 0;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pExProcessDataDefinition[1];

    }

    pExProcessDataDefinition->ExProcessObjectType.NumInstances =
        NumExProcessInstances;

    *lpcbTotalBytes =
        pExProcessDataDefinition->ExProcessObjectType.TotalByteLength =
        QWORD_MULTIPLE(
        (DWORD)((PCHAR) pPerfInstanceDefinition -
        (PCHAR) pExProcessDataDefinition));

    *lppData = (LPVOID) ((PCHAR) pExProcessDataDefinition + *lpcbTotalBytes);

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\datathrd.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATATHRD.h

Abstract:

    Header file for the Windows NT Thread Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATATHRD_H_
#define _DATATHRD_H_

//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _THREAD_DATA_DEFINITION {
    PERF_OBJECT_TYPE		ThreadObjectType;
    PERF_COUNTER_DEFINITION	ContextSwitches;
    PERF_COUNTER_DEFINITION	ProcessorTime;
    PERF_COUNTER_DEFINITION	UserTime;
    PERF_COUNTER_DEFINITION	KernelTime;
    PERF_COUNTER_DEFINITION ThreadElapsedTime;
    PERF_COUNTER_DEFINITION ThreadPriority;
    PERF_COUNTER_DEFINITION ThreadBasePriority;
    PERF_COUNTER_DEFINITION ThreadStartAddr;
    PERF_COUNTER_DEFINITION ThreadState;
    PERF_COUNTER_DEFINITION WaitReason;
    PERF_COUNTER_DEFINITION ProcessId;
    PERF_COUNTER_DEFINITION ThreadId;
} THREAD_DATA_DEFINITION;


typedef struct _THREAD_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                  	ContextSwitches;
    LONGLONG        	    ProcessorTime;
    LONGLONG        	    UserTime;
    LONGLONG        	    KernelTime;
    LONGLONG                ThreadElapsedTime;
    DWORD                   ThreadPriority;
    DWORD                   ThreadBasePriority;
    LPVOID                  ThreadStartAddr;
    DWORD                   ThreadState;
    DWORD                   WaitReason;
    DWORD                   ProcessId;
    DWORD                   ThreadId;
} THREAD_COUNTER_DATA, * PTHREAD_COUNTER_DATA;

extern  THREAD_DATA_DEFINITION ThreadDataDefinition;

#endif // _DATATHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfproc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfproc.c

Abstract:

    This file implements an Performance Object that presents
    Image details performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "dataproc.h"

static  BOOL           bOldestProcessTime = FALSE;
static  LARGE_INTEGER  OldestProcessTime = {0,0};


DWORD APIENTRY
CollectProcessObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;

    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition;
    PPROCESS_DATA_DEFINITION    pProcessDataDefinition;
    PPROCESS_COUNTER_DATA       pPCD;
    PROCESS_COUNTER_DATA        pcdTotal;

    ULONG   NumProcessInstances;
    BOOLEAN NullProcess;

    PUNICODE_STRING pProcessName;
    ULONG ProcessBufferOffset;

    pProcessDataDefinition = (PROCESS_DATA_DEFINITION *) *lppData;

    //
    //  Check for sufficient space for Process object type definition
    //

    TotalLen = sizeof(PROCESS_DATA_DEFINITION) +
               sizeof (PERF_INSTANCE_DEFINITION) +
               MAX_VALUE_NAME_LENGTH +
               sizeof(PROCESS_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define Process data block
    //

    memcpy(pProcessDataDefinition,
           &ProcessDataDefinition,
           sizeof(PROCESS_DATA_DEFINITION));

    pProcessDataDefinition->ProcessObjectType.PerfTime = PerfTime;

    ProcessBufferOffset = 0;

    // Now collect data for each process

    NumProcessInstances = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessBuffer;

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pProcessDataDefinition[1];

    // adjust TotalLen to be the size of the buffer already in use
    TotalLen = sizeof (PROCESS_DATA_DEFINITION);

    // zero the total instance buffer
    memset (&pcdTotal, 0, sizeof (pcdTotal));

    while ( ProcessInfo != NULL ) {

        // see if this instance will fit
        TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                   ((MAX_PROCESS_NAME_LENGTH+1+sizeof(DWORD)) * sizeof(WCHAR)) +
                   sizeof (PROCESS_COUNTER_DATA);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        // check for Live processes
        //  (i.e. name or threads)

        pProcessName = NULL;

        if ((ProcessInfo->ImageName.Buffer != NULL) ||
            (ProcessInfo->NumberOfThreads > 0)){
                // thread is not Dead
            // get process name
            pProcessName = GetProcessShortName (ProcessInfo);
            NullProcess = FALSE;
        } else {
            // thread is dead
            NullProcess = TRUE;
        }

        if ( !NullProcess ) {

            // get the old process creation time the first time we are in
            // this routine
            if (!bOldestProcessTime) {
                if (OldestProcessTime.QuadPart <= 0) {
                    OldestProcessTime = ProcessInfo->CreateTime;
                } else if (ProcessInfo->CreateTime.QuadPart > 0) {
                    // both time values are not zero, see which one is smaller
                    if (OldestProcessTime.QuadPart >
                        ProcessInfo->CreateTime.QuadPart) {
                        OldestProcessTime = ProcessInfo->CreateTime;
                    }
                }
            }

            // get Pool usage for this process

            NumProcessInstances++;

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pPCD,
                0,
                0,
                (DWORD)-1,
                (pProcessName ? pProcessName->Buffer : L"")
                );

            // test structure for Quadword Alignment
            assert (((DWORD)(pPCD) & 0x00000007) == 0);

            //
            //  Format and collect Process data
            //

            pPCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (PROCESS_COUNTER_DATA));
            //
            //  Convert User time from 100 nsec units to counter frequency.
            //
            pcdTotal.ProcessorTime +=
                pPCD->ProcessorTime = ProcessInfo->KernelTime.QuadPart +
                                    ProcessInfo->UserTime.QuadPart;
            pcdTotal.UserTime +=
                pPCD->UserTime = ProcessInfo->UserTime.QuadPart;
            pcdTotal.KernelTime +=
                pPCD->KernelTime = ProcessInfo->KernelTime.QuadPart;

            pcdTotal.PeakVirtualSize +=
                pPCD->PeakVirtualSize = ProcessInfo->PeakVirtualSize;
            pcdTotal.VirtualSize +=
                pPCD->VirtualSize = ProcessInfo->VirtualSize;

            pcdTotal.PageFaults +=
                pPCD->PageFaults = ProcessInfo->PageFaultCount;
            pcdTotal.PeakWorkingSet +=
                pPCD->PeakWorkingSet = ProcessInfo->PeakWorkingSetSize;
            pcdTotal.TotalWorkingSet +=
                pPCD->TotalWorkingSet = ProcessInfo->WorkingSetSize;

#ifdef _DATAPROC_PRIVATE_WS_
            pcdTotal.PrivateWorkingSet +=
                pPCD->PrivateWorkingSet = ProcessInfo->PrivateWorkingSetSize;
            pcdTotal.SharedWorkingSet +=
                pPCD->SharedWorkingSet =
					ProcessInfo->WorkingSetSize -
					ProcessInfo->PrivateWorkingSetSize;
#endif //_DATAPROC_PRIVATE_WS_

            pcdTotal.PeakPageFile +=
                pPCD->PeakPageFile = ProcessInfo->PeakPagefileUsage;
            pcdTotal.PageFile +=
                pPCD->PageFile = ProcessInfo->PagefileUsage;

            pcdTotal.PrivatePages +=
                pPCD->PrivatePages = ProcessInfo->PrivatePageCount;

            pcdTotal.ThreadCount +=
                pPCD->ThreadCount = ProcessInfo->NumberOfThreads;

            // base priority is not totaled
            pPCD->BasePriority = ProcessInfo->BasePriority;

            // elpased time is not totaled
            if (bOldestProcessTime &&
                (ProcessInfo->CreateTime.QuadPart <= 0)) {
                pPCD->ElapsedTime = OldestProcessTime.QuadPart;
            } else {
                pPCD->ElapsedTime = ProcessInfo->CreateTime.QuadPart;
            }

            pPCD->ProcessId = HandleToUlong(ProcessInfo->UniqueProcessId);
            pPCD->CreatorProcessId = HandleToUlong(ProcessInfo->InheritedFromUniqueProcessId);

            pcdTotal.PagedPool +=
                pPCD->PagedPool = (DWORD)ProcessInfo->QuotaPagedPoolUsage;
            pcdTotal.NonPagedPool +=
                pPCD->NonPagedPool = (DWORD)ProcessInfo->QuotaNonPagedPoolUsage;
            pcdTotal.HandleCount +=
                pPCD->HandleCount = (DWORD)ProcessInfo->HandleCount;

            
            // update I/O counters
            pcdTotal.ReadOperationCount +=
                pPCD->ReadOperationCount = ProcessInfo->ReadOperationCount.QuadPart;
            pcdTotal.DataOperationCount += 
                pPCD->DataOperationCount = ProcessInfo->ReadOperationCount.QuadPart;
            pcdTotal.WriteOperationCount +=
                pPCD->WriteOperationCount = ProcessInfo->WriteOperationCount.QuadPart;
            pcdTotal.DataOperationCount += ProcessInfo->WriteOperationCount.QuadPart;
                pPCD->DataOperationCount += ProcessInfo->WriteOperationCount.QuadPart;
            pcdTotal.OtherOperationCount +=
                pPCD->OtherOperationCount = ProcessInfo->OtherOperationCount.QuadPart;

            pcdTotal.ReadTransferCount +=
                pPCD->ReadTransferCount = ProcessInfo->ReadTransferCount.QuadPart;
            pcdTotal.DataTransferCount +=
                pPCD->DataTransferCount = ProcessInfo->ReadTransferCount.QuadPart;
            pcdTotal.WriteTransferCount +=
                pPCD->WriteTransferCount = ProcessInfo->WriteTransferCount.QuadPart;
            pcdTotal.DataTransferCount += ProcessInfo->WriteTransferCount.QuadPart;
                pPCD->DataTransferCount += ProcessInfo->WriteTransferCount.QuadPart;
            pcdTotal.OtherTransferCount +=
                pPCD->OtherTransferCount = ProcessInfo->OtherTransferCount.QuadPart;
                        
            // set perfdata pointer to next byte
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pPCD[1];
        }
        // exit if this was the last process in list
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        // point to next buffer in list
        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset];

    }

    if (NumProcessInstances > 0) {

        // see if the total instance will fit
        TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                    (MAX_PROCESS_NAME_LENGTH+1+sizeof(DWORD))*
                        sizeof(WCHAR) +
                   sizeof (PROCESS_COUNTER_DATA);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        // it looks like it will fit so create "total" instance

        NumProcessInstances++;

        // set the Total Elapsed Time to be the current time so that it will
        // show up as 0 when displayed.
        pcdTotal.ElapsedTime = pProcessDataDefinition->ProcessObjectType.PerfTime.QuadPart;

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *) &pPCD,
            0,
            0,
            (DWORD)-1,
            wszTotal);

        // test structure for Quadword Alignment
        assert (((DWORD)(pPCD) & 0x00000007) == 0);

        //
        //  Format and collect Process data
        //
        memcpy (pPCD, &pcdTotal, sizeof (pcdTotal));
        pPCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (PROCESS_COUNTER_DATA));
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pPCD[1];

    }

    // flag so we don't have to get the oldest Process Creation time again.
    bOldestProcessTime = TRUE;

    // Note number of process instances

    pProcessDataDefinition->ProcessObjectType.NumInstances =
        NumProcessInstances;

    //
    //  Now we know how large an area we used for the
    //  Process definition, so we can update the offset
    //  to the next object definition
    //

    *lpcbTotalBytes =
        pProcessDataDefinition->ProcessObjectType.TotalByteLength =
        QWORD_MULTIPLE(
        (DWORD)((PCHAR) pPerfInstanceDefinition -
        (PCHAR) pProcessDataDefinition));

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Process Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID) ((PCHAR) pProcessDataDefinition + *lpcbTotalBytes);

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfjob.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    perfjob.c

Abstract:

    This file implements an Performance Job Object that presents
    information on the Job Object

Created:

    Bob Watson  8-Oct-1997

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "procmsg.h"
#include "datajob.h"

#define MAX_STR_CHAR    1024
#define    MAX_STR_SIZE    ((DWORD)((MAX_STR_CHAR - 1)* sizeof(WCHAR)))
#define MAX_NAME_LENGTH    MAX_PATH

#define BUFFERSIZE 1024

DWORD    dwBufferSize = BUFFERSIZE;

const WCHAR szJob[] = L"Job";
const WCHAR szObjDirName[] = L"\\BaseNamedObjects";

#define MAX_EVENT_STRINGS    4
WORD    wEvtStringCount;
LPWSTR    szEvtStringArray[MAX_EVENT_STRINGS];

UNICODE_STRING DirectoryName = {(sizeof(szObjDirName) - sizeof(WCHAR)), // name len - NULL
                                sizeof(szObjDirName),                   // size of buffer    
                                (PWCHAR)szObjDirName};                   // address of buffer

BOOL    bOpenJobErrorLogged = FALSE;

PSYSTEM_PROCESS_INFORMATION APIENTRY
GetProcessPointerFromProcessId (
    IN    ULONG_PTR    dwPid
)
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    ULONG ProcessBufferOffset = 0;
    BOOLEAN NullProcess;
    
    DWORD    dwIndex = 0;
    BOOL    bNotFound    = TRUE;
    BOOL    bMoreProcesses = FALSE;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessBuffer;
    if (ProcessInfo) {
        if (ProcessInfo->NextEntryOffset != 0) {
            bMoreProcesses = TRUE;
        }
    }
    while ( bMoreProcesses && bNotFound &&
            (ProcessInfo != NULL)) {
        // check for Live processes
        //  (i.e. name or threads)

        if ((ProcessInfo->ImageName.Buffer != NULL) ||
            (ProcessInfo->NumberOfThreads > 0)){
                // thread is not Dead
            NullProcess = FALSE;
        } else {
            // thread is dead
            NullProcess = TRUE;
        }

        if (( !NullProcess )  && (dwPid == (HandleToUlong(ProcessInfo->UniqueProcessId)))) {
            // found it so return current value
            bNotFound = FALSE;
            continue;
        } else {
            dwIndex++;
        }
        // exit if this was the last process in list
        if (ProcessInfo->NextEntryOffset == 0) {
            bMoreProcesses = FALSE;
            continue;
        }

        // point to next buffer in list
        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset];
    }

    if (bNotFound) {
        return NULL;
    } else {
        return ProcessInfo;
    }
}

DWORD APIENTRY
CollectJobObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition;
    PJOB_DATA_DEFINITION        pJobDataDefinition;
    PJOB_COUNTER_DATA            pJCD;
    JOB_COUNTER_DATA            jcdTotal;

    NTSTATUS Status     = STATUS_SUCCESS;
    NTSTATUS tmpStatus  = STATUS_SUCCESS;
    HANDLE DirectoryHandle, JobHandle;
    ULONG ReturnedLength;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    OBJECT_ATTRIBUTES Attributes;
    WCHAR    wszNameBuffer[MAX_STR_CHAR];
    DWORD    dwSize;
    PUCHAR  Buffer;
    BOOL    bStatus;
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION JobAcctInfo;

    DWORD    dwWin32Status = ERROR_SUCCESS;
    ACCESS_MASK ExtraAccess = 0;
    ULONG Context = 0;
    DWORD    NumJobInstances = 0;

    // get size of a data block that has 1 instance
    TotalLen = sizeof(JOB_DATA_DEFINITION) +        // object def + counter defs
               sizeof (PERF_INSTANCE_DEFINITION) +    // 1 instance def
               MAX_VALUE_NAME_LENGTH +                // 1 instance name
               sizeof(JOB_COUNTER_DATA);            // 1 instance data block

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    // cast callers buffer to the object data definition type
    pJobDataDefinition = (JOB_DATA_DEFINITION *) *lppData;

    //
    //  Define Job Object data block
    //

    memcpy(pJobDataDefinition,
           &JobDataDefinition,
           sizeof(JOB_DATA_DEFINITION));

    // set timestamp of this object
    pJobDataDefinition->JobObjectType.PerfTime = PerfTime;

    // Now collect data for each job object found in system
    //
    //  Perform initial setup
    //
    Buffer = ALLOCMEM(dwBufferSize);
    if ((Buffer == NULL)) {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFPROC_UNABLE_ALLOCATE_JOB_DATA,
            NULL,
            0,
            0,
            NULL,
            NULL);
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pJobDataDefinition[1];

    // adjust TotalLen to be the size of the buffer already in use
    TotalLen = sizeof (JOB_DATA_DEFINITION);

    // zero the total instance buffer
    memset (&jcdTotal, 0, sizeof (jcdTotal));

    //
    //  Open the directory for list directory access
    //
    // this should always succeed since it's a system name we
    // will be querying
    //
    InitializeObjectAttributes( &Attributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    
    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY | ExtraAccess,
                                    &Attributes
                                  );
    if (NT_SUCCESS( Status )) {
        //
        // Get the actual name of the object directory object.
        //

        NameInfo = (POBJECT_NAME_INFORMATION) &Buffer[0];
        Status = NtQueryObject( DirectoryHandle,
                                 ObjectNameInformation,
                                 NameInfo,
                                 dwBufferSize,
                                 (PULONG) NULL );
    }

    if (NT_SUCCESS( Status )) {
        //
        //  Query the entire directory in one sweep
        //
        for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                              Buffer,
                                              dwBufferSize,
                                              FALSE,
                                              FALSE,
                                              &Context,
                                              &ReturnedLength );
             NT_SUCCESS( Status );
             Status = NtQueryDirectoryObject( DirectoryHandle,
                                              Buffer,
                                              dwBufferSize,
                                              FALSE,
                                              FALSE,
                                              &Context,
                                              &ReturnedLength ) ) {

            //
            //  Check the status of the operation.
            //

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            //  For every record in the buffer type out the directory information
            //

            //
            //  Point to the first record in the buffer, we are guaranteed to have
            //  one otherwise Status would have been No More Files
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

            //
            //  Continue while there's a valid record.  
            //
            while (DirInfo->Name.Length != 0) {

                //
                //  Print out information about the Job
                //

                if (wcsncmp ( DirInfo->TypeName.Buffer, &szJob[0], ((sizeof(szJob)/sizeof(WCHAR)) - 1)) == 0) {
                    SIZE_T len;
                    UNICODE_STRING JobName;

                    // this is really a job, so list the name
                    dwSize = DirInfo->Name.Length;
                    if (dwSize >= (MAX_STR_SIZE - sizeof(szObjDirName))) {
                        dwSize = MAX_STR_SIZE - sizeof(szObjDirName) - 1;
                    }
                    len = wcslen(szObjDirName);
                    wcscpy(wszNameBuffer, szObjDirName);
                    wszNameBuffer[len] = L'\\';
                    len++;
                    memcpy (&wszNameBuffer[len], DirInfo->Name.Buffer, dwSize);
                    wszNameBuffer[dwSize/sizeof(WCHAR)+len] = 0;

                    // now query the process ID's for this job

                    RtlInitUnicodeString(&JobName, wszNameBuffer);
                    InitializeObjectAttributes(
                        &Attributes,
                        &JobName,
                        0,
                        NULL, NULL);
                    Status = NtOpenJobObject(
                                &JobHandle,
                                JOB_OBJECT_QUERY,
                                &Attributes);
                    if (NT_SUCCESS(Status)) {

                        // strip Job name prefix for instance name
                        memcpy (wszNameBuffer, DirInfo->Name.Buffer, dwSize);
                        wszNameBuffer[dwSize/sizeof(WCHAR)] = 0;

                        bStatus = QueryInformationJobObject (
                            JobHandle,
                            JobObjectBasicAccountingInformation,
                            &JobAcctInfo,
                            sizeof(JobAcctInfo),
                            &ReturnedLength);

                        ASSERT (ReturnedLength == sizeof(JobAcctInfo));

                        if (bStatus) {
                            // *** create and initialize perf data instance here ***

                            // see if this instance will fit
                            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                                       QWORD_MULTIPLE ((DirInfo->Name.Length + sizeof(WCHAR))) +
                                       sizeof (JOB_COUNTER_DATA);

                            if ( *lpcbTotalBytes < TotalLen ) {
                                *lpcbTotalBytes = 0;
                                *lpNumObjectTypes = 0;
                                Status = STATUS_NO_MEMORY;
                                dwWin32Status =  ERROR_MORE_DATA;
                                break;
                            }

                            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                (PVOID *) &pJCD,
                                0,
                                0,
                                (DWORD)-1,
                                wszNameBuffer);

                            // test structure for Quadword Alignment
                            assert (((DWORD)(pJCD) & 0x00000007) == 0);

                            //
                            //  Format and collect Process data
                            //

                            pJCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (JOB_COUNTER_DATA));

                            jcdTotal.CurrentProcessorTime +=                     
                                pJCD->CurrentProcessorTime =
                                    JobAcctInfo.TotalUserTime.QuadPart +
                                    JobAcctInfo.TotalKernelTime.QuadPart;

                            jcdTotal.CurrentUserTime +=
                                pJCD->CurrentUserTime = JobAcctInfo.TotalUserTime.QuadPart;
                            jcdTotal.CurrentKernelTime +=
                                pJCD->CurrentKernelTime = JobAcctInfo.TotalKernelTime.QuadPart;

#ifdef _DATAJOB_INCLUDE_TOTAL_COUNTERS
                            // convert these times from 100 ns Time base to 1 mS time base
                            jcdTotal.TotalProcessorTime +=
                                pJCD->TotalProcessorTime =
                                    (JobAcctInfo.ThisPeriodTotalUserTime.QuadPart +
                                    JobAcctInfo.ThisPeriodTotalKernelTime.QuadPart) / 10000;
                            jcdTotal.TotalUserTime +=
                                pJCD->TotalUserTime =
                                    JobAcctInfo.ThisPeriodTotalUserTime.QuadPart / 10000;
                            jcdTotal.TotalKernelTime +=
                                pJCD->TotalKernelTime =
                                    JobAcctInfo.ThisPeriodTotalKernelTime.QuadPart / 1000;
                            jcdTotal.CurrentProcessorUsage +=
                                pJCD->CurrentProcessorUsage =
                                    (JobAcctInfo.TotalUserTime.QuadPart +
                                     JobAcctInfo.TotalKernelTime.QuadPart) / 10000;

                            jcdTotal.CurrentUserUsage +=
                                pJCD->CurrentUserUsage =
                                    JobAcctInfo.TotalUserTime.QuadPart / 10000;

                            jcdTotal.CurrentKernelUsage +=
                                pJCD->CurrentKernelUsage =
                                    JobAcctInfo.TotalKernelTime.QuadPart / 10000;
#endif
                            jcdTotal.PageFaults +=
                                pJCD->PageFaults = JobAcctInfo.TotalPageFaultCount;
                            jcdTotal.TotalProcessCount +=
                                pJCD->TotalProcessCount = JobAcctInfo.TotalProcesses;
                            jcdTotal.ActiveProcessCount +=
                                pJCD->ActiveProcessCount = JobAcctInfo.ActiveProcesses;
                            jcdTotal.TerminatedProcessCount +=
                                pJCD->TerminatedProcessCount = JobAcctInfo.TotalTerminatedProcesses;

                            NumJobInstances++;

                            CloseHandle (JobHandle);

                            // set perfdata pointer to next byte
                            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJCD[1];
                        } else {
                            // unable to query job accounting info
                            dwWin32Status = GetLastError();
                            tmpStatus     = Status;
                            Status        = STATUS_SUCCESS;
                            if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
                                wEvtStringCount = 0;
                                szEvtStringArray[wEvtStringCount++] = wszNameBuffer;
                                // unable to open this Job
                                ReportEventW (hEventLog,
                                        EVENTLOG_WARNING_TYPE,
                                        0,
                                        PERFPROC_UNABLE_QUERY_JOB_ACCT,
                                        NULL,
                                        wEvtStringCount,
                                        sizeof(DWORD),
                                        szEvtStringArray,
                                        (LPVOID) & dwWin32Status);
                                bOpenJobErrorLogged = TRUE;
                            }
                        }
                    } else {
                        dwWin32Status = GetLastError();
                        tmpStatus     = Status;
                        Status        = STATUS_SUCCESS;
                        if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
                            wEvtStringCount = 0;
                            szEvtStringArray[wEvtStringCount++] = wszNameBuffer;
                            // unable to open this Job
                            ReportEventW (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    PERFPROC_UNABLE_OPEN_JOB,
                                    NULL,
                                    wEvtStringCount,
                                    sizeof(DWORD),
                                    szEvtStringArray,
                                    (LPVOID) & dwWin32Status);
                            bOpenJobErrorLogged = TRUE;
                        }
                    }
                }

                //
                //  There is another record so advance DirInfo to the next entry
                //

                DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                              sizeof( OBJECT_DIRECTORY_INFORMATION ) );

            }

            RtlZeroMemory( Buffer, dwBufferSize );

        }

        if ((Status == STATUS_NO_MORE_FILES) ||
            (Status == STATUS_NO_MORE_ENTRIES)) {
            // this is OK
            Status = STATUS_SUCCESS;
        }

        if (Status == STATUS_SUCCESS && NumJobInstances == 0
                                     && bOpenJobErrorLogged == TRUE
                                     && dwWin32Status != ERROR_SUCCESS) {
            Status = tmpStatus;
        }

        //
        //  Now close the directory object
        //

        (VOID) NtClose( DirectoryHandle );
    }

    if (Buffer) {
        FREEMEM(Buffer);
    }

    if (NT_SUCCESS(Status)) {
        if (NumJobInstances > 0) {
            // see if the total instance will fit
            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                        QWORD_MULTIPLE((MAX_NAME_LENGTH+1+sizeof(DWORD))*
                          sizeof(WCHAR) +
                       sizeof (JOB_COUNTER_DATA));

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;
                return ERROR_MORE_DATA;
            }

            // it looks like it will fit so create "total" instance

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pJCD,
                0,
                0,
                (DWORD)-1,
                wszTotal);

            // test structure for Quadword Alignment
            assert (((DWORD)(pJCD) & 0x00000007) == 0);

            //
            //  transfer total info
            //
            memcpy (pJCD, &jcdTotal, sizeof (jcdTotal));
            pJCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (JOB_COUNTER_DATA));

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJCD[1];
            NumJobInstances++;
        }

        pJobDataDefinition->JobObjectType.NumInstances =
            NumJobInstances;
        //
        //  Now we know how large an area we used for the
        //  data, so we can update the offset
        //  to the next object definition
        //

        *lpcbTotalBytes =
            pJobDataDefinition->JobObjectType.TotalByteLength =
            QWORD_MULTIPLE(
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pJobDataDefinition));

#if DBG
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFPROC: Job Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) ((PCHAR) pJobDataDefinition + *lpcbTotalBytes);

        *lpNumObjectTypes = 1;

    } else {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
            wEvtStringCount = 0;
            szEvtStringArray[wEvtStringCount++] = DirectoryName.Buffer;
            // unable to query the object directory
            ReportEventW (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    PERFPROC_UNABLE_QUERY_OBJECT_DIR,
                    NULL,
                    wEvtStringCount,
                    sizeof(DWORD),
                    szEvtStringArray,
                    (LPVOID)&Status);
            bOpenJobErrorLogged = TRUE;
        }
    }

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CollectJobDetailData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PUNICODE_STRING pProcessName;

    DWORD   TotalLen;            //  Length of the total return block

    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition;
    PJOB_DETAILS_DATA_DEFINITION        pJobDetailsDataDefinition;
    PJOB_DETAILS_COUNTER_DATA            pJDCD;
    JOB_DETAILS_COUNTER_DATA            jdcdTotal;
    JOB_DETAILS_COUNTER_DATA            jdcdGrandTotal;


    NTSTATUS Status    = STATUS_SUCCESS;
    NTSTATUS tmpStatus = STATUS_SUCCESS;
    HANDLE DirectoryHandle, JobHandle;
    ULONG ReturnedLength;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    OBJECT_ATTRIBUTES Attributes;
    WCHAR    wszNameBuffer[MAX_STR_CHAR];
    DWORD    i, dwSize;
    PUCHAR  Buffer;
    BOOL    bStatus;
    PJOBOBJECT_BASIC_PROCESS_ID_LIST pJobPidList;

    DWORD    dwWin32Status = ERROR_SUCCESS;
    ACCESS_MASK ExtraAccess = 0;
    ULONG Context = 0;
    DWORD    NumJobObjects = 0;
    DWORD    NumJobDetailInstances = 0;

    // get size of a data block that has 1 instance
    TotalLen = sizeof(JOB_DETAILS_DATA_DEFINITION) +        // object def + counter defs
               sizeof (PERF_INSTANCE_DEFINITION) +    // 1 instance def
               MAX_VALUE_NAME_LENGTH +                // 1 instance name
               sizeof(JOB_DETAILS_COUNTER_DATA);            // 1 instance data block

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    // cast callers buffer to the object data definition type
    pJobDetailsDataDefinition = (JOB_DETAILS_DATA_DEFINITION *) *lppData;

    //
    //  Define Job Details Object data block
    //

    memcpy(pJobDetailsDataDefinition,
           &JobDetailsDataDefinition,
           sizeof(JOB_DETAILS_DATA_DEFINITION));

    // set timestamp of this object
    pJobDetailsDataDefinition->JobDetailsObjectType.PerfTime = PerfTime;

    // Now collect data for each job object found in system
    //
    //  Perform initial setup
    //
    Buffer = NULL;
    pJobPidList = NULL;
    if (hLibHeap) {
        Buffer = ALLOCMEM(dwBufferSize);
        pJobPidList = ALLOCMEM(dwBufferSize);
    }
    if ((Buffer == NULL) || (pJobPidList == NULL)) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        // free the one that got allocated (if any)
        if (Buffer != NULL) FREEMEM(Buffer);
        if (pJobPidList != NULL) FREEMEM(pJobPidList);
        ReportEventW(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFPROC_UNABLE_ALLOCATE_JOB_DATA,
            NULL,
            0,
            0,
            szEvtStringArray,
            NULL);
        return ERROR_SUCCESS;
    }

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pJobDetailsDataDefinition[1];

    // adjust TotalLen to be the size of the buffer already in use
    TotalLen = sizeof (JOB_DETAILS_DATA_DEFINITION);

    // zero the total instance buffer
    memset (&jdcdGrandTotal, 0, sizeof (jdcdGrandTotal));

    //
    //  Open the directory for list directory access
    //
    // this should always succeed since it's a system name we
    // will be querying
    //
    InitializeObjectAttributes( &Attributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    
    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY | ExtraAccess,
                                    &Attributes
                                  );
    if (NT_SUCCESS( Status )) {
        //
        // Get the actual name of the object directory object.
        //

        NameInfo = (POBJECT_NAME_INFORMATION) &Buffer[0];
        Status = NtQueryObject( DirectoryHandle,
                                 ObjectNameInformation,
                                 NameInfo,
                                 dwBufferSize,
                                 (PULONG) NULL );
    }

    if (NT_SUCCESS( Status )) {
        //
        //  Query the entire directory in one sweep
        //
        for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                              Buffer,
                                              dwBufferSize,
                                              FALSE,
                                              FALSE,
                                              &Context,
                                              &ReturnedLength );
             NT_SUCCESS( Status );
             Status = NtQueryDirectoryObject( DirectoryHandle,
                                              Buffer,
                                              dwBufferSize,
                                              FALSE,
                                              FALSE,
                                              &Context,
                                              &ReturnedLength ) ) {

            //
            //  Check the status of the operation.
            //

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            //  For every record in the buffer type out the directory information
            //

            //
            //  Point to the first record in the buffer, we are guaranteed to have
            //  one otherwise Status would have been No More Files
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

            //
            //  contine while there's a valid record
            //

            while (DirInfo->Name.Length != 0) {

                //
                //  Print out information about the Job
                //

                if (wcsncmp ( DirInfo->TypeName.Buffer, &szJob[0], ((sizeof(szJob)/sizeof(WCHAR)) - 1)) == 0) {
                    SIZE_T len;
                    UNICODE_STRING JobName;

                    // this is really a job, so list the name
                    dwSize = DirInfo->Name.Length;
                    if (dwSize > (MAX_STR_SIZE - sizeof(szObjDirName))) {
                        dwSize = MAX_STR_SIZE - sizeof(szObjDirName);
                    }
                    len = wcslen(szObjDirName);
                    wcscpy(wszNameBuffer, szObjDirName);
                    wszNameBuffer[len] = L'\\';
                    len++;
                    memcpy (&wszNameBuffer[len], DirInfo->Name.Buffer, dwSize);
                    wszNameBuffer[dwSize/sizeof(WCHAR)+len] = 0;

                    // now query the process ID's for this job

                    RtlInitUnicodeString(&JobName, wszNameBuffer);
                    InitializeObjectAttributes(
                        &Attributes,
                        &JobName,
                        0,
                        NULL, NULL);
                    Status = NtOpenJobObject(
                                &JobHandle,
                                JOB_OBJECT_QUERY,
                                &Attributes);

                    // clear the Job total counter block
                    memset (&jdcdTotal, 0, sizeof (jdcdTotal));

                    if (NT_SUCCESS(Status)) {
                        // strip Job name prefix for instance name
                        memcpy (wszNameBuffer, DirInfo->Name.Buffer, dwSize);
                        wszNameBuffer[dwSize/sizeof(WCHAR)] = 0;

                        // now query the process ID's for this job

                        bStatus = QueryInformationJobObject (
                            JobHandle,
                            JobObjectBasicProcessIdList,
                            pJobPidList,
                            dwBufferSize,
                            &ReturnedLength);

//                        ASSERT (bStatus == TRUE);
                        ASSERT (ReturnedLength <= BUFFERSIZE);
                        ASSERT (pJobPidList->NumberOfAssignedProcesses ==
                            pJobPidList->NumberOfProcessIdsInList);

                        // test to see if there was enough room in the first buffer
                        // for everything, if not, expand the buffer and retry

                        if ((bStatus) && (pJobPidList->NumberOfAssignedProcesses >
                            pJobPidList->NumberOfProcessIdsInList))    {
                            dwBufferSize +=
                                (pJobPidList->NumberOfAssignedProcesses -
                                 pJobPidList->NumberOfProcessIdsInList) *
                                 sizeof (DWORD);
                            FREEMEM(pJobPidList);
                            pJobPidList = ALLOCMEM (dwBufferSize);
                            if (pJobPidList != NULL) {
                                bStatus = QueryInformationJobObject (
                                    JobHandle,
                                    JobObjectBasicProcessIdList,
                                    pJobPidList,
                                    dwBufferSize,
                                    &ReturnedLength);
                            } else {        
                                bStatus = FALSE;
                                SetLastError ( ERROR_OUTOFMEMORY );
                            }
                        }

                        if (bStatus) {

                            for (i=0;i < pJobPidList->NumberOfProcessIdsInList; i++) {
                                // *** create and initialize perf data instance here ***
                                // get process data object from ID
                                ProcessInfo = GetProcessPointerFromProcessId (pJobPidList->ProcessIdList[i]);
                                
//                                ASSERT (ProcessInfo != NULL);

                                if (ProcessInfo != NULL) {

                                    // get process name
                                    pProcessName = GetProcessShortName (ProcessInfo);
                                    ReturnedLength = pProcessName->Length + sizeof(WCHAR);

                                    // see if this instance will fit
                                    TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                                               QWORD_MULTIPLE (ReturnedLength) +
                                               sizeof (JOB_DETAILS_COUNTER_DATA);

                                    if ( *lpcbTotalBytes < TotalLen ) {
                                        *lpcbTotalBytes = 0;
                                        *lpNumObjectTypes = 0;
                                        Status = STATUS_NO_MEMORY;
                                        dwWin32Status =  ERROR_MORE_DATA;
                                        break;
                                    }

                                    MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                        (PVOID *) &pJDCD,
                                        JOB_OBJECT_TITLE_INDEX,
                                        NumJobObjects,
                                        (DWORD)-1,
                                        pProcessName->Buffer);

                                    // test structure for Quadword Alignment
                                    assert (((DWORD)(pJDCD) & 0x00000007) == 0);

                                    //
                                    //  Format and collect Process data
                                    //

                                    pJDCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (JOB_DETAILS_COUNTER_DATA));
                                    //
                                    //  Convert User time from 100 nsec units to counter frequency.
                                    //
                                    jdcdTotal.ProcessorTime +=
                                        pJDCD->ProcessorTime = ProcessInfo->KernelTime.QuadPart +
                                                            ProcessInfo->UserTime.QuadPart;
                                    jdcdTotal.UserTime +=
                                        pJDCD->UserTime = ProcessInfo->UserTime.QuadPart;
                                    jdcdTotal.KernelTime +=
                                        pJDCD->KernelTime = ProcessInfo->KernelTime.QuadPart;

                                    jdcdTotal.PeakVirtualSize +=
                                        pJDCD->PeakVirtualSize = ProcessInfo->PeakVirtualSize;
                                    jdcdTotal.VirtualSize +=
                                        pJDCD->VirtualSize = ProcessInfo->VirtualSize;

                                    jdcdTotal.PageFaults +=
                                        pJDCD->PageFaults = ProcessInfo->PageFaultCount;
                                    jdcdTotal.PeakWorkingSet +=
                                        pJDCD->PeakWorkingSet = ProcessInfo->PeakWorkingSetSize;
                                    jdcdTotal.TotalWorkingSet +=
                                        pJDCD->TotalWorkingSet = ProcessInfo->WorkingSetSize;

#ifdef _DATAPROC_PRIVATE_WS_
                                    jdcdTotal.PrivateWorkingSet +=
                                        pJDCD->PrivateWorkingSet = ProcessInfo->PrivateWorkingSetSize;
                                    jdcdTotal.SharedWorkingSet +=
                                        pJDCD->SharedWorkingSet =
                                            ProcessInfo->WorkingSetSize -
                                            ProcessInfo->PrivateWorkingSetSize;
#endif
                                    jdcdTotal.PeakPageFile +=
                                        pJDCD->PeakPageFile = ProcessInfo->PeakPagefileUsage;
                                    jdcdTotal.PageFile +=
                                        pJDCD->PageFile = ProcessInfo->PagefileUsage;

                                    jdcdTotal.PrivatePages +=
                                        pJDCD->PrivatePages = ProcessInfo->PrivatePageCount;

                                    jdcdTotal.ThreadCount +=
                                        pJDCD->ThreadCount = ProcessInfo->NumberOfThreads;

                                    // base priority is not totaled
                                    pJDCD->BasePriority = ProcessInfo->BasePriority;

                                    // elpased time is not totaled
                                    pJDCD->ElapsedTime = ProcessInfo->CreateTime.QuadPart;

                                    pJDCD->ProcessId = HandleToUlong(ProcessInfo->UniqueProcessId);
                                    pJDCD->CreatorProcessId = HandleToUlong(ProcessInfo->InheritedFromUniqueProcessId);

                                    jdcdTotal.PagedPool +=
                                        pJDCD->PagedPool = (DWORD)ProcessInfo->QuotaPagedPoolUsage;
                                    jdcdTotal.NonPagedPool +=
                                        pJDCD->NonPagedPool = (DWORD)ProcessInfo->QuotaNonPagedPoolUsage;
                                    jdcdTotal.HandleCount +=
                                        pJDCD->HandleCount = (DWORD)ProcessInfo->HandleCount;

                                    // update I/O counters
                                    jdcdTotal.ReadOperationCount +=
                                        pJDCD->ReadOperationCount = ProcessInfo->ReadOperationCount.QuadPart;
                                    jdcdTotal.DataOperationCount += 
                                        pJDCD->DataOperationCount = ProcessInfo->ReadOperationCount.QuadPart;
                                    jdcdTotal.WriteOperationCount +=
                                        pJDCD->WriteOperationCount = ProcessInfo->WriteOperationCount.QuadPart;
                                    jdcdTotal.DataOperationCount += ProcessInfo->WriteOperationCount.QuadPart;
                                        pJDCD->DataOperationCount += ProcessInfo->WriteOperationCount.QuadPart;
                                    jdcdTotal.OtherOperationCount +=
                                        pJDCD->OtherOperationCount = ProcessInfo->OtherOperationCount.QuadPart;

                                    jdcdTotal.ReadTransferCount +=
                                        pJDCD->ReadTransferCount = ProcessInfo->ReadTransferCount.QuadPart;
                                    jdcdTotal.DataTransferCount +=
                                        pJDCD->DataTransferCount = ProcessInfo->ReadTransferCount.QuadPart;
                                    jdcdTotal.WriteTransferCount +=
                                        pJDCD->WriteTransferCount = ProcessInfo->WriteTransferCount.QuadPart;
                                    jdcdTotal.DataTransferCount += ProcessInfo->WriteTransferCount.QuadPart;
                                        pJDCD->DataTransferCount += ProcessInfo->WriteTransferCount.QuadPart;
                                    jdcdTotal.OtherTransferCount +=
                                        pJDCD->OtherTransferCount = ProcessInfo->OtherTransferCount.QuadPart;
                        
                                    // set perfdata pointer to next byte
                                    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJDCD[1];

                                    NumJobDetailInstances++;
                                } else {
                                    // unable to locate info on this process
                                    // for now, we'll ignore this...
                                }
                            }
                        
                            CloseHandle (JobHandle);

                            // see if this instance will fit
                            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                                       QWORD_MULTIPLE (MAX_STR_SIZE) +
                                       sizeof (JOB_DETAILS_COUNTER_DATA);

                            if ( *lpcbTotalBytes < TotalLen ) {
                                *lpcbTotalBytes = 0;
                                *lpNumObjectTypes = 0;
                                Status = STATUS_NO_MEMORY;
                                dwWin32Status =  ERROR_MORE_DATA;
                                break;
                            }

                            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                (PVOID *) &pJDCD,
                                JOB_OBJECT_TITLE_INDEX,
                                NumJobObjects,
                                (DWORD)-1,
                                wszTotal);

                            // test structure for Quadword Alignment
                            assert (((DWORD)(pJDCD) & 0x00000007) == 0);

                            // copy total data to caller's buffer

                            memcpy (pJDCD, &jdcdTotal, sizeof (jdcdTotal));
                            pJDCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (JOB_DETAILS_COUNTER_DATA));

                            // update grand total instance
                            //
                            jdcdGrandTotal.ProcessorTime += jdcdTotal.ProcessorTime;
                            jdcdGrandTotal.UserTime += jdcdTotal.UserTime;
                            jdcdGrandTotal.KernelTime += jdcdTotal. KernelTime;
                            jdcdGrandTotal.PeakVirtualSize += jdcdTotal.PeakVirtualSize;
                            jdcdGrandTotal.VirtualSize += jdcdTotal.VirtualSize;

                            jdcdGrandTotal.PageFaults += jdcdTotal.PageFaults;
                            jdcdGrandTotal.PeakWorkingSet += jdcdTotal.PeakWorkingSet;
                            jdcdGrandTotal.TotalWorkingSet += jdcdTotal.TotalWorkingSet;

#ifdef _DATAPROC_PRIVATE_WS_
                            jdcdGrandTotal.PrivateWorkingSet += jdcdTotal.PrivateWorkingSet;
                            jdcdGrandTotal.SharedWorkingSet += jdcdTotal.SharedWorkingSet;
#endif

                            jdcdGrandTotal.PeakPageFile += jdcdTotal.PeakPageFile;
                            jdcdGrandTotal.PageFile += jdcdTotal.PageFile;
                            jdcdGrandTotal.PrivatePages += jdcdTotal.PrivatePages;
                            jdcdGrandTotal.ThreadCount += jdcdTotal.ThreadCount;

                            jdcdGrandTotal.PagedPool += jdcdTotal.PagedPool;
                            jdcdGrandTotal.NonPagedPool += jdcdTotal.NonPagedPool;
                            jdcdGrandTotal.HandleCount += jdcdTotal.HandleCount;

                            // set perfdata pointer to next byte
                            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJDCD[1];

                            NumJobDetailInstances++;
                            NumJobObjects++;
                        } else {
                            // unable to read PID list from Job
                            dwWin32Status = GetLastError();
                            tmpStatus     = Status;
                            Status        = STATUS_SUCCESS;
                            if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
                                wEvtStringCount = 0;
                                szEvtStringArray[wEvtStringCount++] = wszNameBuffer;
                                // unable to open this Job
                                ReportEventW (hEventLog,
                                        EVENTLOG_WARNING_TYPE,
                                        0,
                                        PERFPROC_UNABLE_QUERY_JOB_PIDS,
                                        NULL,
                                        wEvtStringCount,
                                        sizeof(DWORD),
                                        szEvtStringArray,
                                        (LPVOID) & dwWin32Status);
                                bOpenJobErrorLogged = TRUE;
                            }
                        }
                    } else {
                        dwWin32Status = GetLastError();
                        tmpStatus     = Status;
                        Status        = STATUS_SUCCESS;
                        if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
                            wEvtStringCount = 0;
                            szEvtStringArray[wEvtStringCount++] = wszNameBuffer;
                            // unable to open this Job
                            ReportEventW (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    PERFPROC_UNABLE_OPEN_JOB,
                                    NULL,
                                    wEvtStringCount,
                                    sizeof(DWORD),
                                    szEvtStringArray,
                                    (LPVOID) & dwWin32Status);
                            bOpenJobErrorLogged = TRUE;
                        }
                    }
                }

                //
                //  There is another record so advance DirInfo to the next entry
                //

                DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                              sizeof( OBJECT_DIRECTORY_INFORMATION ) );

            }

            RtlZeroMemory( Buffer, dwBufferSize );

        }

        if ((Status == STATUS_NO_MORE_FILES) ||
            (Status == STATUS_NO_MORE_ENTRIES)) {
            // this is OK
            Status = STATUS_SUCCESS;
        }

        if (Status == STATUS_SUCCESS && NumJobDetailInstances == 0
                                     && bOpenJobErrorLogged == TRUE
                                     && dwWin32Status != ERROR_SUCCESS) {
            Status = tmpStatus;
        }

        //
        //  Now close the directory object
        //

        (VOID) NtClose( DirectoryHandle );

        if (NumJobDetailInstances > 0) {
            // see if this instance will fit
            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                       QWORD_MULTIPLE (MAX_STR_SIZE) +
                       sizeof (JOB_DETAILS_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;
                Status = STATUS_NO_MEMORY;
                dwWin32Status =  ERROR_MORE_DATA;
            } else {

                // set the Total Elapsed Time to be the current time so that it will
                // show up as 0 when displayed.
                jdcdGrandTotal.ElapsedTime = pJobDetailsDataDefinition->JobDetailsObjectType.PerfTime.QuadPart;

                // build the grand total instance
                MonBuildInstanceDefinition(pPerfInstanceDefinition,
                    (PVOID *) &pJDCD,
                    JOB_OBJECT_TITLE_INDEX,
                    NumJobObjects,
                    (DWORD)-1,
                    wszTotal);

                // test structure for Quadword Alignment
                //ASSERT (((ULONG_PTR)(pJDCD) & 0x00000007) == 0);

                // copy total data to caller's buffer

                memcpy (pJDCD, &jdcdGrandTotal, sizeof (jdcdGrandTotal));
                pJDCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (JOB_DETAILS_COUNTER_DATA));

                // update pointers
                pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJDCD[1];
                NumJobDetailInstances++;
            }
        }

        pJobDetailsDataDefinition->JobDetailsObjectType.NumInstances =
            NumJobDetailInstances;

        //
        //  Now we know how large an area we used for the
        //  Process definition, so we can update the offset
        //  to the next object definition
        //

        *lpcbTotalBytes =
             pJobDetailsDataDefinition->JobDetailsObjectType.TotalByteLength =
            QWORD_MULTIPLE(
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pJobDetailsDataDefinition));

#if DBG
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFPROC: Job Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) ((PCHAR) pJobDetailsDataDefinition + *lpcbTotalBytes);

        *lpNumObjectTypes = 1;
    
    } else {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
            wEvtStringCount = 0;
            szEvtStringArray[wEvtStringCount++] = DirectoryName.Buffer;
            // unable to query the object directory
            ReportEventW (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    PERFPROC_UNABLE_QUERY_OBJECT_DIR,
                    NULL,
                    wEvtStringCount,
                    sizeof(DWORD),
                    szEvtStringArray,
                    (LPVOID)&Status);
            bOpenJobErrorLogged = TRUE;

        }
    }

    if (Buffer) {
        FREEMEM(Buffer);
    }
    if (pJobPidList) {
        FREEMEM(pJobPidList);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfheap.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfheap.c

Abstract:

    This file implements an Performance Object that presents
    Heap performance object data

Created:

    Adrian Marinescu  9-Mar-2000

Revision History:


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "dataheap.h"


//
//  Redefinition for heap data
//


#define MAX_HEAP_COUNT 200
#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64
#define HEAP_OP_COUNT 2

#define HEAP_OP_ALLOC 0
#define HEAP_OP_FREE 1

typedef struct _HEAP_ENTRY {
    USHORT Size;
    USHORT PreviousSize;
    UCHAR SegmentIndex;
    UCHAR Flags;
    UCHAR UnusedBytes;
    UCHAR SmallTagIndex;
#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PVOID UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PVOID TagEntries;
    PVOID UCRSegments;
    PVOID UnusedUnCommittedRanges;

    ULONG AlignRound;
    ULONG AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    USHORT FreeListsInUseTerminate;
    USHORT AllocatorBackTraceIndex;
    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PVOID PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PVOID LockVariable;
    PVOID CommitRoutine;

    PVOID Lookaside;
    ULONG LookasideLockCount;

} HEAP, *PHEAP;

typedef struct _HEAP_PERF_DATA {

    UINT64 CountFrequence;
    UINT64 OperationTime[HEAP_OP_COUNT];

    //
    //  The data bellow are only for sampling
    //

    ULONG  Sequence;

    UINT64 TempTime[HEAP_OP_COUNT];
    ULONG  TempCount[HEAP_OP_COUNT];

} HEAP_PERF_DATA, *PHEAP_PERF_DATA;

//
//  The heap index structure
//

typedef struct _HEAP_INDEX {
    
    ULONG ArraySize;
    ULONG VirtualMemorySize;

    HEAP_PERF_DATA PerfData;

    union {
        
        PULONG FreeListsInUseUlong;
        PUCHAR FreeListsInUseBytes;
    } u;

    PVOID *FreeListHints;

} HEAP_INDEX, *PHEAP_INDEX;


typedef struct _HEAP_LOOKASIDE {
    SLIST_HEADER ListHead;

    USHORT Depth;
    USHORT MaximumDepth;

    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;

    ULONG LastTotalAllocates;
    ULONG LastAllocateMisses;

    ULONG Counters[2];

} HEAP_LOOKASIDE, *PHEAP_LOOKASIDE;

//
//  Local variables
//

static HEAP_LOOKASIDE LookasideBuffer[HEAP_MAXIMUM_FREELISTS];
static DWORD PageSize = 0;

//
//  Implementation for heap query function
//

BOOLEAN
ReadHeapData (
    IN HANDLE hProcess,
    IN ULONG HeapNumber,
    IN PHEAP Heap,
    OUT PHEAP_COUNTER_DATA    pHCD
    )

/*++

    Routine Description:
    
        The routine loads into the given heap couter structure the 
        data from the heap structure

    Arguments:
    
        hProcess - The process containing the heap
        
        Heap - the heap address
        
        pPerfInstanceDefinition - Performance instance definition data
        
        pHCD - Counter data

    Returns:
        Returns TRUE if query succeeds.

--*/

{
    HEAP_SEGMENT CrtSegment;
    HEAP CrtHeap;
    ULONG SegmentIndex;
    RTL_CRITICAL_SECTION CriticalSection;
    HEAP_INDEX HeapIndex;

    ULONG i;

    //
    //  Read the heap structure from the process address space
    //

    if (!ReadProcessMemory(hProcess, Heap, &CrtHeap, sizeof(CrtHeap), NULL)) {

        return FALSE;
    }

    //
    //  We won't display data for heaps w/o index. 
    //

    if ((CrtHeap.LargeBlocksIndex == NULL) 
            &&
        (HeapNumber != 0)) {

        //
        //  We are not handling small heaps
        //

        return FALSE;
    }

    pHCD->FreeSpace = CrtHeap.TotalFreeSize;
    pHCD->FreeListLength = CrtHeap.NonDedicatedListLength;

    pHCD->CommittedBytes = 0;
    pHCD->ReservedBytes = 0;
    pHCD->VirtualBytes = 0;
    pHCD->UncommitedRangesLength = 0;

    //
    //  Walking the heap segments and get the virtual address counters
    //

    for (SegmentIndex = 0; SegmentIndex < HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        if ((CrtHeap.Segments[SegmentIndex] == NULL) ||
            !ReadProcessMemory(hProcess, CrtHeap.Segments[SegmentIndex], &CrtSegment, sizeof(CrtSegment), NULL)) {

            break;
        }

        pHCD->ReservedBytes += CrtSegment.NumberOfPages * PageSize;
        pHCD->CommittedBytes += (CrtSegment.NumberOfPages - CrtSegment.NumberOfUnCommittedPages) * PageSize;
        pHCD->VirtualBytes += CrtSegment.NumberOfPages * PageSize - CrtSegment.LargestUnCommittedRange;
        pHCD->UncommitedRangesLength += CrtSegment.NumberOfUnCommittedRanges;
    }

    if (pHCD->CommittedBytes == 0) {
        pHCD->CommittedBytes = 1;
    }

    if (pHCD->VirtualBytes == 0) {
        pHCD->VirtualBytes = 1;
    }
    
    //
    //  Compute the heap fragmentation counters
    //

    pHCD->BlockFragmentation = (ULONG)(pHCD->FreeSpace * 100 / pHCD->CommittedBytes);
    pHCD->VAFragmentation =(ULONG)(((pHCD->VirtualBytes - pHCD->CommittedBytes)*100)/pHCD->VirtualBytes);

    //
    //  Read the lock contention
    //

    pHCD->LockContention = 0;

    if (ReadProcessMemory(hProcess, CrtHeap.LockVariable, &CriticalSection, sizeof(CriticalSection), NULL)) {
        
        RTL_CRITICAL_SECTION_DEBUG DebugInfo;

        if (ReadProcessMemory(hProcess, CriticalSection.DebugInfo, &DebugInfo, sizeof(DebugInfo), NULL)) {

            pHCD->LockContention = DebugInfo.ContentionCount;
        }
    }

    //
    //  Walk the lookaside to count the blocks
    //

    pHCD->LookasideAllocs = 0;
    pHCD->LookasideFrees = 0;
    pHCD->LookasideBlocks = 0;
    pHCD->LargestLookasideDepth = 0;
    pHCD->SmallAllocs = 0;
    pHCD->SmallFrees = 0;
    pHCD->MedAllocs = 0;
    pHCD->MedFrees = 0;
    pHCD->LargeAllocs = 0;
    pHCD->LargeFrees = 0;
    
    if (ReadProcessMemory(hProcess, CrtHeap.Lookaside, &LookasideBuffer, sizeof(LookasideBuffer), NULL)) {

        for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i++) {
            
            pHCD->SmallAllocs += LookasideBuffer[i].TotalAllocates;
            pHCD->SmallFrees += LookasideBuffer[i].TotalFrees;
            pHCD->LookasideAllocs += LookasideBuffer[i].TotalAllocates - LookasideBuffer[i].AllocateMisses;
            pHCD->LookasideFrees += LookasideBuffer[i].TotalFrees - LookasideBuffer[i].FreeMisses;

            if (LookasideBuffer[i].Depth > pHCD->LargestLookasideDepth) {

                pHCD->LargestLookasideDepth = LookasideBuffer[i].Depth;
            }

            if (i == 0) {
                
            } else if (i < 8) {
                
                pHCD->MedAllocs += LookasideBuffer[i].Counters[0];
                pHCD->MedFrees += LookasideBuffer[i].Counters[1];
            } else {
                
                pHCD->LargeAllocs += LookasideBuffer[i].Counters[0];
                pHCD->LargeFrees += LookasideBuffer[i].Counters[1];
            }
        }
    }
    
    pHCD->LookasideBlocks = pHCD->LookasideFrees - pHCD->LookasideAllocs;

    //
    //  Calculate the totals
    //

    pHCD->TotalAllocs = pHCD->SmallAllocs + pHCD->MedAllocs + pHCD->LargeAllocs;
    pHCD->TotalFrees = pHCD->SmallFrees + pHCD->MedFrees + pHCD->LargeFrees;
    
    //
    //  Set the difference between allocs and frees
    //

    pHCD->DiffOperations = pHCD->TotalAllocs - pHCD->TotalFrees;
    
    pHCD->AllocTime = 0;
    pHCD->AllocTime = 0;

    //
    //  Determine the alloc/free rates
    //
    
    if (ReadProcessMemory(hProcess, CrtHeap.LargeBlocksIndex, &HeapIndex, sizeof(HeapIndex), NULL)) {

        if (HeapIndex.PerfData.OperationTime[0]) {
            pHCD->AllocTime = HeapIndex.PerfData.CountFrequence / HeapIndex.PerfData.OperationTime[0];
        }
        
        if (HeapIndex.PerfData.OperationTime[1]) {
            pHCD->FreeTime = HeapIndex.PerfData.CountFrequence / HeapIndex.PerfData.OperationTime[1];
        }
    }
    
    return TRUE;
}


DWORD APIENTRY
CollectHeapObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)

/*++

Routine Description:

    This routine will return the data for the heap object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/

{
    LONG    lReturn = ERROR_SUCCESS;

    DWORD  TotalLen;            //  Length of the total return block

    PHEAP_DATA_DEFINITION pHeapDataDefinition;
    PPERF_INSTANCE_DEFINITION pPerfInstanceDefinition;
    PHEAP_COUNTER_DATA    pHCD;

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    ULONG ProcessNumber;
    ULONG NumHeapInstances;
    ULONG HeapNumber;
    ULONG ProcessBufferOffset;
    UNICODE_STRING HeapName;
    WCHAR HeapNameBuffer[MAX_THREAD_NAME_LENGTH+1];
    BOOL  bMoreProcesses = FALSE;
    
    HeapName.Length = 0;
    HeapName.MaximumLength = (MAX_THREAD_NAME_LENGTH + 1) * sizeof(WCHAR);
    HeapName.Buffer = HeapNameBuffer;

    pHeapDataDefinition = (HEAP_DATA_DEFINITION *) *lppData;

    //
    //  Get the page size from the system
    //

    if (!PageSize) {
        SYSTEM_INFO SystemInfo;
        
        GetSystemInfo(&SystemInfo);
        PageSize = SystemInfo.dwPageSize;

    }

    //
    //  Check for sufficient space for Thread object type definition
    //

    TotalLen = sizeof(HEAP_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               sizeof(HEAP_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define the heap data block
    //

    memcpy(pHeapDataDefinition,
           &HeapDataDefinition,
           sizeof(HEAP_DATA_DEFINITION));

    pHeapDataDefinition->HeapObjectType.PerfTime = PerfTime;

    ProcessBufferOffset = 0;

    //
    // Now collect data for each process
    //

    ProcessNumber = 0;
    NumHeapInstances = 0;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;

    pPerfInstanceDefinition =
        (PPERF_INSTANCE_DEFINITION)&pHeapDataDefinition[1];
    TotalLen = sizeof(HEAP_DATA_DEFINITION);

    if (ProcessInfo) {
        if (ProcessInfo->NextEntryOffset != 0) {
            bMoreProcesses = TRUE;
        }
    }
    while ( bMoreProcesses && (ProcessInfo != NULL)) {

        HANDLE hProcess;
        NTSTATUS Status;
        PROCESS_BASIC_INFORMATION BasicInfo;

        //
		// Get a handle to the process.
        //

		hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
									   PROCESS_VM_READ,
									   FALSE, (DWORD)(ULONGLONG)ProcessInfo->UniqueProcessId );

		if ( hProcess ) {
            
            //
            //  Get the process PEB
            //

            Status = NtQueryInformationProcess(
                        hProcess,
                        ProcessBasicInformation,
                        &BasicInfo,
                        sizeof(BasicInfo),
                        NULL
                        );

            if ( NT_SUCCESS(Status) ) {
                
                ULONG NumberOfHeaps;
                PVOID ProcessHeaps[MAX_HEAP_COUNT];
                PVOID HeapBuffer;
                PPEB Peb;
                
                Peb = BasicInfo.PebBaseAddress;

                //
                //  Read the heaps from the process PEB
                //

                if (!ReadProcessMemory(hProcess, &Peb->NumberOfHeaps, &NumberOfHeaps, sizeof(NumberOfHeaps), NULL)) {

                    goto READERROR;
                }

                //
                //  Limit the number of heaps to be read
                //

                if (NumberOfHeaps > MAX_HEAP_COUNT) {

                    NumberOfHeaps = MAX_HEAP_COUNT;
                }

                if (!ReadProcessMemory(hProcess, &Peb->ProcessHeaps, &HeapBuffer, sizeof(HeapBuffer), NULL)) {

                    goto READERROR;
                }
                
                if (!ReadProcessMemory(hProcess, HeapBuffer, &ProcessHeaps[0], NumberOfHeaps * sizeof(PVOID), NULL)) {

                    goto READERROR;
                }

                //
                //  Loop through the heaps and retireve the data
                //

                for (HeapNumber = 0; HeapNumber < NumberOfHeaps; HeapNumber++) {

                    TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                               (MAX_THREAD_NAME_LENGTH+1+sizeof(DWORD))*
                                   sizeof(WCHAR) +
                               sizeof (HEAP_COUNTER_DATA);

                    if ( *lpcbTotalBytes < TotalLen ) {
                        *lpcbTotalBytes = (DWORD) 0;
                        *lpNumObjectTypes = (DWORD) 0;
                        
                        CloseHandle( hProcess );
                        return ERROR_MORE_DATA;
                    }
                    
                    //
                    //  Build the monitor instance based on the process name and 
                    //  heap address
                    //

                    Status = RtlIntegerToUnicodeString( (ULONG)(ULONGLONG)ProcessHeaps[HeapNumber],
                                                        16,
                                                        &HeapName);

                    if (!NT_SUCCESS(Status)) {  // just in case
                        HeapName.Length = 2 * sizeof(WCHAR);
                        memcpy(HeapNameBuffer, L"-1", HeapName.Length);
                        HeapName.Buffer[2] = UNICODE_NULL;
                    }
                    MonBuildInstanceDefinition(pPerfInstanceDefinition,
                        (PVOID *) &pHCD,
                        PROCESS_OBJECT_TITLE_INDEX,
                        ProcessNumber,
                        (DWORD)-1,
                        HeapName.Buffer);

                    pHCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(HEAP_COUNTER_DATA));
                    
                    //
                    //  Get the data from the heap
                    //

                    if (ReadHeapData ( hProcess,
                                       HeapNumber,
                                       (PHEAP)ProcessHeaps[HeapNumber],
                                       pHCD) ) {

                        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pHCD[1];
                        NumHeapInstances++;
                    }
                }
            }
READERROR:
    		CloseHandle( hProcess );
        }

        ProcessNumber++;
        
        //
        //  Move to the next process, if any
        //

        if (ProcessInfo->NextEntryOffset == 0) {
            bMoreProcesses = FALSE;
            continue;
        }

        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                       &pProcessBuffer[ProcessBufferOffset];
    }

    // Note number of heap instances

    pHeapDataDefinition->HeapObjectType.NumInstances =
        NumHeapInstances;

    //
    //  Now we know how large an area we used for the
    //  heap definition, so we can update the offset
    //  to the next object definition
    //

    *lpcbTotalBytes =
        pHeapDataDefinition->HeapObjectType.TotalByteLength =
            QWORD_MULTIPLE(
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pHeapDataDefinition));

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Heap Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID) ((PCHAR) pHeapDataDefinition + *lpcbTotalBytes);

    *lpNumObjectTypes = 1;

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfsprc.h ===
#define MAX_PROCESS_NAME_LENGTH (MAX_PATH*sizeof(WCHAR))
#define MAX_THREAD_NAME_LENGTH  (10*sizeof(WCHAR))

//
//  Value to decide if process names should be collected from:
//      the SystemProcessInfo structure (fastest)
//          -- or --
//      the process's image file (slower, but shows Unicode filenames)
//
#define PNCM_NOT_DEFINED    ((LONG)-1)
#define PNCM_SYSTEM_INFO    0L
#define PNCM_MODULE_FILE    1L

#define IDLE_PROCESS_ID     ((DWORD)0)
#define SYSTEM_PROCESS_ID   ((DWORD)7)

//
// Process/Thread name format
//
#define NAME_FORMAT_BLANK           1           // Nothing appended
#define NAME_FORMAT_ID              2           // PID/TID appended

#define NAME_FORMAT_DEFAULT         1           // Default to what it used to be

//
//  VA structures & defines
//
#define NOACCESS            0
#define READONLY            1
#define READWRITE           2
#define WRITECOPY           3
#define EXECUTE             4
#define EXECUTEREAD         5
#define EXECUTEREADWRITE    6
#define EXECUTEWRITECOPY    7
#define MAXPROTECT          8

typedef struct _MODINFO {
    PVOID   BaseAddress;
    ULONG_PTR VirtualSize;
    PUNICODE_STRING InstanceName;
    PUNICODE_STRING LongInstanceName;
    ULONG_PTR TotalCommit;
    ULONG_PTR CommitVector[MAXPROTECT];
    struct _MODINFO   *pNextModule;
} MODINFO, *PMODINFO;

typedef struct _PROCESS_VA_INFO {
    PUNICODE_STRING      pProcessName;
    HANDLE               hProcess;
    ULONG_PTR             dwProcessId;
    //  process VA information
    PPROCESS_BASIC_INFORMATION BasicInfo;
    //  process VA statistics
    ULONG_PTR            ImageReservedBytes;
    ULONG_PTR            ImageFreeBytes;
    ULONG_PTR            ReservedBytes;
    ULONG_PTR            FreeBytes;
    ULONG_PTR            MappedGuard;
    ULONG_PTR            MappedCommit[MAXPROTECT];
    ULONG_PTR            PrivateGuard;
    ULONG_PTR            PrivateCommit[MAXPROTECT];
    //  process image statistics
    PMODINFO            pMemBlockInfo;  // pointer to image list
    MODINFO             OrphanTotals;   // blocks with no image
    MODINFO             MemTotals;      // sum of image data
    DWORD               LookUpTime;
    struct _PROCESS_VA_INFO    *pNextProcess;
} PROCESS_VA_INFO, *PPROCESS_VA_INFO;

extern PPROCESS_VA_INFO     pProcessVaInfo;    // list head

extern const WCHAR IDLE_PROCESS[];
extern const WCHAR SYSTEM_PROCESS[];

extern  PUNICODE_STRING pusLocalProcessNameBuffer;

extern  HANDLE                          hEventLog;       // handle to event log
extern  HANDLE                          hLibHeap;       // local heap
extern  LPWSTR  wszTotal;

extern  LPBYTE                          pProcessBuffer;
extern  LARGE_INTEGER                   PerfTime;

PM_LOCAL_COLLECT_PROC CollectProcessObjectData;
PM_LOCAL_COLLECT_PROC CollectThreadObjectData;
PM_LOCAL_COLLECT_PROC CollectHeapObjectData;
PM_LOCAL_COLLECT_PROC CollectExProcessObjectData;
PM_LOCAL_COLLECT_PROC CollectImageObjectData;
PM_LOCAL_COLLECT_PROC CollectLongImageObjectData;
PM_LOCAL_COLLECT_PROC CollectThreadDetailsObjectData;
PM_LOCAL_COLLECT_PROC CollectJobObjectData;
PM_LOCAL_COLLECT_PROC CollectJobDetailData;

PUNICODE_STRING
GetProcessShortName (
    PSYSTEM_PROCESS_INFORMATION pProcess
);

PPROCESS_VA_INFO
GetSystemVaData (
    IN PSYSTEM_PROCESS_INFORMATION
);

BOOL
FreeSystemVaData (
    IN PPROCESS_VA_INFO
);

ULONG
PerfIntegerToWString(
    IN ULONG Value,
    IN ULONG Base,
    IN LONG OutputLength,
    OUT LPWSTR String
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfsprc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfsprc.c

Abstract:


Author:

    Bob Watson (a-robw) Aug 95

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wchar.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"
#include "procmsg.h"

#include "dataheap.h" 


// bit field definitions for collect function flags
#define POS_READ_SYS_PROCESS_DATA       ((DWORD)0x00010000)
#define POS_READ_PROCESS_VM_DATA        ((DWORD)0x00020000)
#define	POS_READ_JOB_OBJECT_DATA		((DWORD)0x00040000)
#define POS_READ_JOB_DETAIL_DATA		((DWORD)0x00080000)
#define POS_READ_HEAP_DATA		        ((DWORD)0x00100000)

#define POS_COLLECT_PROCESS_DATA        ((DWORD)0x00010001)
#define POS_COLLECT_THREAD_DATA         ((DWORD)0x00010003)
#define POS_COLLECT_EXPROCESS_DATA      ((DWORD)0x00030004)
#define POS_COLLECT_IMAGE_DATA          ((DWORD)0x0003000C)
#define POS_COLLECT_LONG_IMAGE_DATA     ((DWORD)0x00030014)
#define POS_COLLECT_THREAD_DETAILS_DATA ((DWORD)0x00030024)
#define POS_COLLECT_JOB_OBJECT_DATA		((DWORD)0x00050040)
#define POS_COLLECT_JOB_DETAIL_DATA		((DWORD)0x000D00C1)
#define POS_COLLECT_HEAP_DATA           ((DWORD)0x00110101) 

#define POS_COLLECT_FUNCTION_MASK       ((DWORD)0x000001FF)

#define POS_COLLECT_GLOBAL_DATA         ((DWORD)0x001501C3)
#define POS_COLLECT_GLOBAL_NO_HEAP      ((DWORD)0x000500C3)
#define POS_COLLECT_FOREIGN_DATA        ((DWORD)0)
#define POS_COLLECT_COSTLY_DATA         ((DWORD)0x0003003C)

// global variables to this DLL

HANDLE  hEventLog     = NULL;
LPWSTR  wszTotal = NULL;
HANDLE  hLibHeap = NULL;

LPBYTE  pProcessBuffer = NULL;
PPROCESS_VA_INFO     pProcessVaInfo = NULL;
PUNICODE_STRING pusLocalProcessNameBuffer = NULL;

LARGE_INTEGER PerfTime = {0,0};

const WCHAR IDLE_PROCESS[] = L"Idle";
const WCHAR SYSTEM_PROCESS[] = L"System";

const WCHAR szPerflibSubKey[] = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
const WCHAR szPerfProcSubKey[] = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\PerfProc\\Performance";

const WCHAR szDisplayHeapPerfObject[] = L"DisplayHeapPerfObject";
const WCHAR szProcessNameFormat[] = L"ProcessNameFormat";
const WCHAR szThreadNameFormat[] = L"ThreadNameFormat";
const WCHAR szExe[] = L".EXE";

BOOL    PerfSprc_DisplayHeapPerfObject = FALSE;
DWORD   PerfSprc_dwProcessNameFormat = NAME_FORMAT_DEFAULT;
DWORD   PerfSprc_dwThreadNameFormat = NAME_FORMAT_DEFAULT;

extern DWORD bOpenJobErrorLogged;

// variables local to this module

POS_FUNCTION_INFO    posDataFuncInfo[] = {
    {PROCESS_OBJECT_TITLE_INDEX,    POS_COLLECT_PROCESS_DATA,   0,  CollectProcessObjectData},
    {THREAD_OBJECT_TITLE_INDEX,     POS_COLLECT_THREAD_DATA,    0,  CollectThreadObjectData},
    {EXPROCESS_OBJECT_TITLE_INDEX,  POS_COLLECT_EXPROCESS_DATA, 0,  CollectExProcessObjectData},
    {IMAGE_OBJECT_TITLE_INDEX,      POS_COLLECT_IMAGE_DATA,     0,  CollectImageObjectData},
    {LONG_IMAGE_OBJECT_TITLE_INDEX, POS_COLLECT_LONG_IMAGE_DATA,0,  CollectLongImageObjectData},
    {THREAD_DETAILS_OBJECT_TITLE_INDEX, POS_COLLECT_THREAD_DETAILS_DATA, 0, CollectThreadDetailsObjectData},
	{JOB_OBJECT_TITLE_INDEX,		POS_COLLECT_JOB_OBJECT_DATA, 0,	CollectJobObjectData},
	{JOB_DETAILS_OBJECT_TITLE_INDEX, POS_COLLECT_JOB_DETAIL_DATA, 0, CollectJobDetailData},
    {HEAP_OBJECT_TITLE_INDEX,       POS_COLLECT_HEAP_DATA,      0,  CollectHeapObjectData}
};

#define POS_NUM_FUNCS   (sizeof(posDataFuncInfo) / sizeof(posDataFuncInfo[1]))

BOOL    bInitOk  = FALSE;
DWORD   dwOpenCount = 0;
DWORD   ProcessBufSize = LARGE_BUFFER_SIZE;

PM_OPEN_PROC    OpenSysProcessObject;
PM_COLLECT_PROC CollecSysProcessObjectData;
PM_CLOSE_PROC   CloseSysProcessObject;

__inline
VOID
PerfpQuerySystemTime(
    IN PLARGE_INTEGER SystemTime
    )
{
    do {
        SystemTime->HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime->LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime->HighPart != USER_SHARED_DATA->SystemTime.High2Time);

}

VOID
PerfProcGlobalSettings (
    VOID
)
{
    NTSTATUS            Status;
    HANDLE              hPerfProcKey;
    OBJECT_ATTRIBUTES   oaPerfProcKey;
    UNICODE_STRING      PerfProcSubKeyString;
    UNICODE_STRING      NameInfoValueString;
    PKEY_VALUE_PARTIAL_INFORMATION    pKeyInfo;
    DWORD               dwBufLen;
    DWORD               dwRetBufLen;
    PDWORD              pdwValue;

    PerfpQuerySystemTime(&PerfTime);

    RtlInitUnicodeString (
        &PerfProcSubKeyString,
        szPerfProcSubKey);

    InitializeObjectAttributes(
            &oaPerfProcKey,
            &PerfProcSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerfProcKey,
                MAXIMUM_ALLOWED,
                &oaPerfProcKey
                );

    if (NT_SUCCESS (Status)) {
        // registry key opened, now read value.
        // allocate enough room for the structure, - the last
        // UCHAR in the struct, but + the data buffer (a dword)

        dwBufLen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) -
            sizeof(UCHAR) + sizeof (DWORD);

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCMEM (dwBufLen);

        if (pKeyInfo != NULL) {
            // initialize value name string
            RtlInitUnicodeString (
                &NameInfoValueString,
                szDisplayHeapPerfObject);

            dwRetBufLen = 0;
            Status = NtQueryValueKey (
                hPerfProcKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                // check value of return data buffer
                pdwValue = (PDWORD)&pKeyInfo->Data[0];
                if (*pdwValue == 1) {
                    PerfSprc_DisplayHeapPerfObject = TRUE;
                } else {
                    // all other values will cause this routine to return
                    // the default value of FALSE 
                }
            }

            RtlInitUnicodeString(
                &NameInfoValueString,
                szProcessNameFormat);
            dwRetBufLen = 0;
            Status = NtQueryValueKey(
                hPerfProcKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                pdwValue = (PDWORD) &pKeyInfo->Data[0];
                PerfSprc_dwProcessNameFormat = *pdwValue;
            }

            RtlInitUnicodeString(
                &NameInfoValueString,
                szThreadNameFormat);
            dwRetBufLen = 0;
            Status = NtQueryValueKey(
                hPerfProcKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                pdwValue = (PDWORD) &pKeyInfo->Data[0];
                PerfSprc_dwThreadNameFormat = *pdwValue;
            }

            FREEMEM (pKeyInfo);
        }
        // close handle
        NtClose (hPerfProcKey);
    }
    if ((PerfSprc_dwProcessNameFormat < NAME_FORMAT_BLANK) ||
        (PerfSprc_dwProcessNameFormat > NAME_FORMAT_ID))
        PerfSprc_dwProcessNameFormat = NAME_FORMAT_DEFAULT;
    if ((PerfSprc_dwThreadNameFormat < NAME_FORMAT_BLANK) ||
        (PerfSprc_dwThreadNameFormat > NAME_FORMAT_ID))
        PerfSprc_dwThreadNameFormat = NAME_FORMAT_DEFAULT;
}

BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    perform any initialization function that apply to all object
    modules

--*/
{
    BOOL    bReturn = TRUE;
    WCHAR   wszTempBuffer[MAX_PATH];
    LONG    lStatus;
    DWORD   dwBufferSize;

    UNREFERENCED_PARAMETER (DllHandle);

    // open handle to the event log
    if (hEventLog == NULL) {
        hEventLog = MonOpenEventLog((LPWSTR)L"PerfProc");

        // create the local heap
        hLibHeap = HeapCreate (0, 1, 0);

        if (hLibHeap == NULL) {
            return FALSE;
        }
    }

    wszTempBuffer[0] = 0;
    wszTempBuffer[MAX_PATH-1] = UNICODE_NULL;

    lStatus = GetPerflibKeyValue (
        szTotalValue,
        REG_SZ,
        sizeof(wszTempBuffer) - sizeof(WCHAR),
        (LPVOID)&wszTempBuffer[0],
        DEFAULT_TOTAL_STRING_LEN,
        (LPVOID)&szDefaultTotalString[0]);

    if (lStatus == ERROR_SUCCESS) {
        // then a string was returned in the temp buffer
        dwBufferSize = lstrlenW (wszTempBuffer) + 1;
        dwBufferSize *= sizeof (WCHAR);
        wszTotal = ALLOCMEM (dwBufferSize);
        if (wszTotal == NULL) {
            // unable to allocate buffer so use static buffer
            wszTotal = (LPWSTR)&szDefaultTotalString[0];
        } else {
            memcpy (wszTotal, wszTempBuffer, dwBufferSize);
        }
    } else {
        // unable to get string from registry so just use static buffer
        wszTotal = (LPWSTR)&szDefaultTotalString[0];
    }

    return bReturn;
}

BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    UNREFERENCED_PARAMETER (DllHandle);

    if (dwOpenCount > 0) {
        // the Library is being unloaded before it was
        // closed so close it now as this is the last
        // chance to do it before the library is tossed.
        // if the value of dwOpenCount is > 1, set it to
        // one to insure everything will be closed when
        // the close function is called.
        if (dwOpenCount > 1) dwOpenCount = 1;
        CloseSysProcessObject();
    }

    if ((wszTotal != NULL) && (wszTotal != &szDefaultTotalString[0])) {
        FREEMEM (wszTotal);
        wszTotal = NULL;
    }

    if (HeapDestroy (hLibHeap)) hLibHeap = NULL;

    if (hEventLog != NULL) {
        MonCloseEventLog ();
    }

    return TRUE;
}

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    ReservedAndUnused;

    // this will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach (DLLHandle);

        case DLL_PROCESS_DETACH:
            return DllProcessDetach (DLLHandle);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            return TRUE;
    }
}

PUNICODE_STRING
GetProcessShortName (
    PSYSTEM_PROCESS_INFORMATION pProcess
)
/*++

GetProcessShortName

Inputs:
    PSYSTEM_PROCESS_INFORMATION pProcess

    address of System Process Information data structure.

Outputs:

    None

Returns:

    Pointer to an initialized Unicode string (created by this routine)
    that contains the short name of the process image or a numeric ID
    if no name is found.

    If unable to allocate memory for structure, then NULL is returned.

--*/
{
    PWCHAR  pSlash;
    PWCHAR  pPeriod;
    PWCHAR  pThisChar;

    WORD    wStringSize;

    WORD    wThisChar;
    ULONG   ProcessId;
    WORD    wLength;

    // this routine assumes that the allocated memory has been zero'd

    if (pusLocalProcessNameBuffer == NULL) {
        // allocate Unicode String Structure and adjacent buffer  first
        wLength = MAX_INSTANCE_NAME * sizeof(WCHAR);
        if (pProcess->ImageName.Length > 0) {
            if (wLength < pProcess->ImageName.Length) {
                wLength = pProcess->ImageName.Length;
            }
        }
        wStringSize = sizeof(UNICODE_STRING) + wLength + 64 + (WORD) sizeof(UNICODE_NULL);

        pusLocalProcessNameBuffer =
            ALLOCMEM ((DWORD)wStringSize);

        if (pusLocalProcessNameBuffer == NULL) {
            return NULL;
        } else {
            pusLocalProcessNameBuffer->MaximumLength = (WORD)(wStringSize - (WORD)sizeof (UNICODE_STRING));
        }
    }
    else if (pusLocalProcessNameBuffer->Buffer == NULL || pusLocalProcessNameBuffer->MaximumLength == 0) {
        // something wrong here. Return immediately.
        SetLastError(ERROR_INVALID_DATA);
        return NULL;
    }
    else {
        wStringSize = pusLocalProcessNameBuffer->MaximumLength;
    }
    pusLocalProcessNameBuffer->Length = 0;
    pusLocalProcessNameBuffer->Buffer = (PWCHAR)&pusLocalProcessNameBuffer[1];

    memset (     // buffer must be zero'd so we'll have a NULL Term
        pusLocalProcessNameBuffer->Buffer, 0,
        (DWORD)pusLocalProcessNameBuffer->MaximumLength);

    ProcessId = HandleToUlong(pProcess->UniqueProcessId);
    if (pProcess->ImageName.Buffer) {   // some name has been defined

        pSlash = (PWCHAR)pProcess->ImageName.Buffer;
        pPeriod = (PWCHAR)pProcess->ImageName.Buffer;
        pThisChar = (PWCHAR)pProcess->ImageName.Buffer;
        wThisChar = 0;

        //
        //  go from beginning to end and find last backslash and
        //  last period in name
        //

        while (*pThisChar != 0) { // go until null
            if (*pThisChar == L'\\') {
                pSlash = pThisChar;
            } else if (*pThisChar == L'.') {
                pPeriod = pThisChar;
            }
            pThisChar++;    // point to next char
            wThisChar += sizeof(WCHAR);
            if (wThisChar >= pProcess->ImageName.Length) {
                break;
            }
        }

        // if pPeriod is still pointing to the beginning of the
        // string, then no period was found

        if (pPeriod == (PWCHAR)pProcess->ImageName.Buffer) {
            pPeriod = pThisChar; // set to end of string;
        } else {
            // if a period was found, then see if the extension is
            // .EXE, if so leave it, if not, then use end of string
            // (i.e. include extension in name)

            if (lstrcmpiW(pPeriod, szExe) != 0) {
                pPeriod = pThisChar;
            }
        }

        if (*pSlash == L'\\') { // if pSlash is pointing to a slash, then
            pSlash++;   // point to character next to slash
        }

        // copy characters between period (or end of string) and
        // slash (or start of string) to make image name

        wStringSize = (WORD)((PCHAR)pPeriod - (PCHAR)pSlash); // size in bytes
        wLength = pusLocalProcessNameBuffer->MaximumLength - sizeof(UNICODE_NULL);
        if (wStringSize >= wLength) {
            wStringSize = wLength;
        }

        memcpy (pusLocalProcessNameBuffer->Buffer, pSlash, wStringSize);

        // null terminate is
        // not necessary because allocated memory is zero-init'd
        pPeriod = (PWCHAR) ((PCHAR) pusLocalProcessNameBuffer->Buffer + wStringSize);
        if (PerfSprc_dwProcessNameFormat == NAME_FORMAT_ID) {
            ULONG Length;
            Length = PerfIntegerToWString(
                        ProcessId,
                        10,
                        (pusLocalProcessNameBuffer->MaximumLength - wStringSize)
                            / sizeof(WCHAR),
                        pPeriod+1);
            if (Length > 0)
                *pPeriod = L'_';
            wStringSize = wStringSize + (WORD) (Length * sizeof(WCHAR));
        }
        pusLocalProcessNameBuffer->Length = wStringSize;
    } else {    // no name defined so use Process #

        // check  to see if this is a system process and give it
        // a name

        switch (ProcessId) {
            case IDLE_PROCESS_ID:
                RtlAppendUnicodeToString (pusLocalProcessNameBuffer,
                    (LPWSTR)IDLE_PROCESS);
                break;

            case SYSTEM_PROCESS_ID:
                RtlAppendUnicodeToString (pusLocalProcessNameBuffer,
                    (LPWSTR)SYSTEM_PROCESS);
                break;

            // if the id is not a system process, then use the id as the name

            default:
                if (!NT_SUCCESS(RtlIntegerToUnicodeString (ProcessId,
                                    10,
                                    pusLocalProcessNameBuffer))) {
                    pusLocalProcessNameBuffer->Length = 2 * sizeof(WCHAR);
                    memcpy(pusLocalProcessNameBuffer->Buffer, L"-1",
                        pusLocalProcessNameBuffer->Length);
                    pusLocalProcessNameBuffer->Buffer[2] = UNICODE_NULL;
                }

                break;
        }


    }

    return pusLocalProcessNameBuffer;
}

#pragma warning (disable : 4706)

DWORD
GetSystemProcessData (
)
{
    DWORD   dwReturnedBufferSize;
    NTSTATUS Status;
    DWORD WinError;

    //
    //  Get process data from system.
    //  if bGotProcessInfo is TRUE, that means we have the process
    //  info. collected earlier when we are checking for costly
    //  object types.
    //
    if (pProcessBuffer == NULL) {
        // allocate a new block
        pProcessBuffer = ALLOCMEM (ProcessBufSize);
        if (pProcessBuffer == NULL) {
            return ERROR_OUTOFMEMORY;
        }
    }

    PerfpQuerySystemTime(&PerfTime);
    while( (Status = NtQuerySystemInformation(
                            SystemProcessInformation,
                            pProcessBuffer,
                            ProcessBufSize,
                            &dwReturnedBufferSize)) == STATUS_INFO_LENGTH_MISMATCH ) {
        // expand buffer & retry
        if (ProcessBufSize < dwReturnedBufferSize) {
            ProcessBufSize = dwReturnedBufferSize;
        }
        ProcessBufSize = PAGESIZE_MULTIPLE(ProcessBufSize + INCREMENT_BUFFER_SIZE);

        FREEMEM(pProcessBuffer);
        if ( !(pProcessBuffer = ALLOCMEM(ProcessBufSize)) ) {
            return (ERROR_OUTOFMEMORY);
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        // convert to win32 error
        WinError = (DWORD)RtlNtStatusToDosError(Status);
    }
    else {
        WinError = ERROR_SUCCESS;
    }

    return (WinError);

}
#pragma warning (default : 4706)

DWORD APIENTRY
OpenSysProcessObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER (lpDeviceNames);

    if (dwOpenCount == 0) {
        // clear the job object open error flag
        bOpenJobErrorLogged = FALSE;
        PerfProcGlobalSettings();
    }

    dwOpenCount++;

    bInitOk = TRUE;

    return  ERROR_SUCCESS;
}

DWORD APIENTRY
CollectSysProcessObjectData (
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN       LPWSTR   lpValueName
            pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    NTSTATUS    status;

    // build bit mask of functions to call

    DWORD       dwQueryType;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;
    DWORD       dwNumObjectsFromFunction;
    DWORD       dwOrigBuffSize;
    DWORD       dwByteSize;
#if DBG
    LPVOID      lpPrev   = NULL;
    ULONGLONG   llRemain = 0;
#endif

    if (!bInitOk) {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFPROC_NOT_OPEN,
            NULL,
            0,
            0,
            NULL,
            NULL);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto COLLECT_BAIL_OUT;
    }

    dwQueryType = GetQueryType (lpValueName);

    switch (dwQueryType) {
        case QUERY_ITEMS:
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (IsNumberInUnicodeList (
                    posDataFuncInfo[FunctionIndex].dwObjectId, lpValueName)) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                }
            }
            break;

        case QUERY_GLOBAL:
            // only return the HEAP data in a global query if it's enabled
            // if they ask for it specifically, then it's OK
            if (PerfSprc_DisplayHeapPerfObject) {
                FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
            } else {
                // filter out the heap perf object
                FunctionCallMask = POS_COLLECT_GLOBAL_NO_HEAP;
            }
            break;

        case QUERY_FOREIGN:
            FunctionCallMask = POS_COLLECT_FOREIGN_DATA;
            break;

        case QUERY_COSTLY:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;

        default:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;
    }

    // collect data  from system
    if (FunctionCallMask & POS_READ_SYS_PROCESS_DATA) {
        status = GetSystemProcessData ();

        if (!NT_SUCCESS(status)) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFPROC_UNABLE_QUERY_PROCESS_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }
    } else {
        status = ERROR_SUCCESS;
    }
    
    // collect data  from system
    if ((status == ERROR_SUCCESS) &&
        (pProcessBuffer != NULL) &&
        (FunctionCallMask & POS_READ_PROCESS_VM_DATA)) {
         pProcessVaInfo = GetSystemVaData (
              (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer);
        // call function

        if (pProcessVaInfo == NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFPROC_UNABLE_QUERY_VM_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
            // zero buffer
        }
    } else {
        // zero buffer
    }

    // collect data
    *lpNumObjectTypes = 0;
    dwOrigBuffSize = dwByteSize = *lpcbTotalBytes;
    *lpcbTotalBytes = 0;

    // remove query bits
    FunctionCallMask &= POS_COLLECT_FUNCTION_MASK;

#if DBG
    lpPrev   = * lppData;
    if (((ULONG_PTR) (* lppData) & 0x00000007) != 0) {
        DbgPrint("CollectSysProcessObjectData received misaligned buffer %p\n", lpPrev);
    }
#endif
    for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
        if ((posDataFuncInfo[FunctionIndex].dwCollectFunctionBit & FunctionCallMask) == 
            (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit & POS_COLLECT_FUNCTION_MASK)) {
            dwNumObjectsFromFunction = 0;
            lReturn = (*posDataFuncInfo[FunctionIndex].pCollectFunction) (
                lppData,
                &dwByteSize,
                &dwNumObjectsFromFunction);
#if DBG
            llRemain = (ULONGLONG) (((LPBYTE) (* lppData)) - ((LPBYTE) lpPrev));
            if ((llRemain & 0x0000000000000007) != 0) {
                DbgPrint("CollectSysProcessObjectData function %d returned misaligned buffer size (%p,%p)\n",
                        FunctionIndex, lpPrev, * lppData);
                ASSERT ((llRemain & 0x0000000000000007) == 0);
            }
            else if (((ULONG_PTR) (* lppData) & 0x00000007) != 0) {
                DbgPrint("CollectSysProcessObjectData function %d returned misaligned buffer %X\n",
                        FunctionIndex, *lppData);
            }
            lpPrev = * lppData;
#endif

            if (lReturn == ERROR_SUCCESS) {
                *lpNumObjectTypes += dwNumObjectsFromFunction;
                *lpcbTotalBytes += dwByteSize;
                dwOrigBuffSize -= dwByteSize;
                dwByteSize = dwOrigBuffSize;
            } else {
                break;
            }
        }
    }

    // this list of data must be freed after use
    if (pProcessVaInfo != NULL) {

        FreeSystemVaData (pProcessVaInfo);
        pProcessVaInfo = NULL;

    }


    // *lppData is updated by each function
    // *lpcbTotalBytes is updated after each successful function
    // *lpNumObjects is updated after each successful function

COLLECT_BAIL_OUT:

    return lReturn;
}

DWORD APIENTRY
CloseSysProcessObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD   status = ERROR_SUCCESS;
    PVOID   buffer;

    if (!bInitOk) {
        return status;
    }
    if (--dwOpenCount == 0) {
        if (hLibHeap != NULL) {
            // close
            if (pProcessBuffer != NULL) {
                buffer = pProcessBuffer;
                pProcessBuffer = NULL;
                FREEMEM (buffer);
            }

            if (pusLocalProcessNameBuffer != NULL) {
                buffer = pusLocalProcessNameBuffer;
                pusLocalProcessNameBuffer = NULL;
                FREEMEM (buffer);
            }
        }
    }
    return  status;

}

const CHAR PerfpIntegerWChars[] = {L'0', L'1', L'2', L'3', L'4', L'5',
                                   L'6', L'7', L'8', L'9', L'A', L'B',
                                   L'C', L'D', L'E', L'F'};

ULONG
PerfIntegerToWString(
    IN ULONG Value,
    IN ULONG Base,
    IN LONG OutputLength,
    OUT LPWSTR String
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Mask = 0;
    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    Base = 10; Shift = 0;  // Default to 10
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
    }

    s = &Result[ 32 ];
    *s = L'\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = PerfpIntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[ 32 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( 0 );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length*sizeof(WCHAR) );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = L'\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( 0 );
            }

        return( Length );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfthrd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfthrd.c

Abstract:

    This file implements an Performance Object that presents
    Thread performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "datathrd.h"

extern DWORD PerfSprc_dwThreadNameFormat;


DWORD APIENTRY
CollectThreadObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    DWORD  TotalLen;            //  Length of the total return block

    THREAD_DATA_DEFINITION *pThreadDataDefinition;
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
    PTHREAD_COUNTER_DATA    pTCD;
    THREAD_COUNTER_DATA     tcdTotal;

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    ULONG ProcessNumber;
    ULONG NumThreadInstances;
    ULONG ThreadNumber;
    ULONG ProcessBufferOffset;
    BOOLEAN NullProcess;
    BOOL    bMoreThreads;

    // total thread accumulator variables

    UNICODE_STRING ThreadName;
    WCHAR ThreadNameBuffer[MAX_THREAD_NAME_LENGTH+1];

    pThreadDataDefinition = (THREAD_DATA_DEFINITION *) *lppData;

    //
    //  Check for sufficient space for Thread object type definition
    //

    TotalLen = sizeof(THREAD_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               sizeof(THREAD_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define Thread data block
    //

    ThreadName.Length =
    ThreadName.MaximumLength = (MAX_THREAD_NAME_LENGTH + 1) * sizeof(WCHAR);
    ThreadName.Buffer = ThreadNameBuffer;
    RtlZeroMemory(ThreadNameBuffer, ThreadName.MaximumLength);

    memcpy(pThreadDataDefinition,
           &ThreadDataDefinition,
           sizeof(THREAD_DATA_DEFINITION));

    pThreadDataDefinition->ThreadObjectType.PerfTime = PerfTime;

    ProcessBufferOffset = 0;

    // Now collect data for each Thread

    ProcessNumber = 0;
    NumThreadInstances = 0;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;

    pPerfInstanceDefinition =
        (PPERF_INSTANCE_DEFINITION)&pThreadDataDefinition[1];
    TotalLen = sizeof(THREAD_DATA_DEFINITION);

    // clear total accumulator
    memset (&tcdTotal, 0, sizeof (tcdTotal));

    bMoreThreads = FALSE;
    if (ProcessInfo) {
        if (ProcessInfo->NextEntryOffset != 0) {
            bMoreThreads = TRUE;
        }
    }
    while ( bMoreThreads && (ProcessInfo != NULL)) {

        if ( ProcessInfo->ImageName.Buffer != NULL ||
             ProcessInfo->NumberOfThreads > 0 ) {
            NullProcess = FALSE;
        } else {
            NullProcess = TRUE;
        }

        ThreadNumber = 0;       //  Thread number of this process

        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

        while ( !NullProcess &&
                ThreadNumber < ProcessInfo->NumberOfThreads ) {

            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                       (MAX_THREAD_NAME_LENGTH+1+sizeof(DWORD))*
                           sizeof(WCHAR) +
                       sizeof (THREAD_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_MORE_DATA;
            }

            if (PerfSprc_dwThreadNameFormat == NAME_FORMAT_ID) {
                PerfIntegerToWString(
                    HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                    10,
                    MAX_THREAD_NAME_LENGTH+1,
                    ThreadNameBuffer);
            }
            else {
                // The only name we've got is the thread number

                if (!NT_SUCCESS(RtlIntegerToUnicodeString(ThreadNumber,
                                   10,
                                   &ThreadName))) {
                    ThreadName.Length = 2 * sizeof(WCHAR);
                    memcpy(ThreadName.Buffer, L"-1", ThreadName.Length);
                    ThreadName.Buffer[2] = UNICODE_NULL;
                }
            }

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pTCD,
                PROCESS_OBJECT_TITLE_INDEX,
                ProcessNumber,
                (DWORD)-1,
                ThreadName.Buffer);

            // test structure for Quadword Alignment
            assert (((DWORD)(pTCD) & 0x00000007) == 0);

            //
            //
            //  Format and collect Thread data
            //

            pTCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(THREAD_COUNTER_DATA));

            //
            //  Convert User time from 100 nsec units to counter
            //  frequency.
            //
            tcdTotal.ProcessorTime +=
                pTCD->ProcessorTime = ThreadInfo->KernelTime.QuadPart +
                                        ThreadInfo->UserTime.QuadPart;

            tcdTotal.UserTime +=
                pTCD->UserTime = ThreadInfo->UserTime.QuadPart;
            tcdTotal.KernelTime +=
                pTCD->KernelTime = ThreadInfo->KernelTime.QuadPart;

            tcdTotal.ContextSwitches +=
                pTCD->ContextSwitches = ThreadInfo->ContextSwitches;

            pTCD->ThreadElapsedTime = ThreadInfo->CreateTime.QuadPart;

            pTCD->ThreadPriority = (ThreadInfo->ClientId.UniqueProcess == 0) ?
                0 : ThreadInfo->Priority;

            pTCD->ThreadBasePriority = ThreadInfo->BasePriority;
            pTCD->ThreadStartAddr = ThreadInfo->StartAddress;
            pTCD->ThreadState =
                (DWORD)((ThreadInfo->ThreadState > 7) ?
                    7 : ThreadInfo->ThreadState);
            pTCD->WaitReason = (DWORD)ThreadInfo->WaitReason;

            // now stuff in the process and thread id's
            pTCD->ProcessId = HandleToUlong(ThreadInfo->ClientId.UniqueProcess);
            pTCD->ThreadId = HandleToUlong(ThreadInfo->ClientId.UniqueThread);

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pTCD[1];

            NumThreadInstances++;
            ThreadNumber++;
            ThreadInfo++;
        }

        if ( !NullProcess ) {
            ProcessNumber++;
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            bMoreThreads = FALSE;
            continue;
        }

        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset];
    }

    if (NumThreadInstances > 0) {

        // See if the total instance will fit

        TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                    (MAX_THREAD_NAME_LENGTH+1+sizeof(DWORD))*
                        sizeof(WCHAR) +
                    sizeof (THREAD_COUNTER_DATA);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        // set the Total Elapsed Time to be the current time so that it will
        // show up as 0 when displayed.
        tcdTotal.ThreadElapsedTime = pThreadDataDefinition->ThreadObjectType.PerfTime.QuadPart;

        // use the "total" for this instance
        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *) &pTCD,
            PROCESS_OBJECT_TITLE_INDEX,
            ProcessNumber,
            (DWORD)-1,
            wszTotal);

        // test structure for Quadword Alignment
        assert (((DWORD)(pTCD) & 0x00000007) == 0);

        //
        //
        //  Format and collect Thread data
        //

        memcpy (pTCD, &tcdTotal, sizeof(tcdTotal));
        pTCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof(THREAD_COUNTER_DATA));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pTCD[1];

        NumThreadInstances++;
    }
    // Note number of Thread instances

    pThreadDataDefinition->ThreadObjectType.NumInstances =
        NumThreadInstances;

    //
    //  Now we know how large an area we used for the
    //  Thread definition, so we can update the offset
    //  to the next object definition
    //

    *lpcbTotalBytes =
        pThreadDataDefinition->ThreadObjectType.TotalByteLength =
            QWORD_MULTIPLE(
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pThreadDataDefinition));

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Thread Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID) ((PCHAR) pThreadDataDefinition + *lpcbTotalBytes);

    *lpNumObjectTypes = 1;

    return lReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perfva.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992   Microsoft Corporation

Module Name:

    prflibva.c

Abstract:

    Virtual address space counter evaluation routines

    computes the process and image virtual address space usage for return
    via Perfmon API

Author:

    Stolen from the "internal" PVIEW SDK program and adapted for Perfmon by:

    a-robw (Bob Watson) 11/29/92

Revision History:

--*/
//
//  define routine's "personality"
//
#define UNICODE 1
//
//  Include files
//

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"

#define DEFAULT_INCR (64*1024)
#ifdef _WIN64
#define STOP_AT (PVOID)(0xFFFFFFFF80000000)
#else
#define STOP_AT (PVOID)(0x80000000)
#endif

// Function Prototypes

PPROCESS_VA_INFO
GetProcessVaData (
    IN PSYSTEM_PROCESS_INFORMATION
);

PMODINFO
GetModuleVaData (
    PLDR_DATA_TABLE_ENTRY,  // module information structure
    PPROCESS_VA_INFO        // process data structure
);

BOOL
FreeProcessVaData (
    IN PPROCESS_VA_INFO
);

BOOL
FreeModuleVaData (
    IN PMODINFO
);


PMODINFO
LocateModInfo(
    IN PMODINFO,
    IN PVOID,
    IN SIZE_T
    );

DWORD
ProtectionToIndex(
    IN ULONG
    );

DWORD   dwProcessCount;
DWORD   dwModuleCount;


PPROCESS_VA_INFO
GetSystemVaData (
    IN PSYSTEM_PROCESS_INFORMATION pFirstProcess
)
/*++

GetSystemVaData

    Obtains the Process and Image Virtual Address information for all
    processes running on the system. (note that the routines called by
    this function allocate data structures consequently the corresponding
    FreeSystemVaData must be called to prevent memory "leaks")

Arguments

    IN PSYSTEM_PROCESS_INFORMATION
        pFirstProcess
            Pointer to first process in list of process structures returned
            by NtQuerySystemInformation service

Return Value

    Pointer to first process in list of processes
    or NULL if unable to obtain data

--*/
{
    PSYSTEM_PROCESS_INFORMATION     pThisProcess;
    PPROCESS_VA_INFO                pReturnValue = NULL;
    PPROCESS_VA_INFO                pLastProcess;
    PPROCESS_VA_INFO                pNewProcess;
    DWORD                           dwStartTime;
    BOOL                            bMoreProcesses;

    dwProcessCount = 0;
    dwModuleCount = 0;

    if (pFirstProcess != NULL) {

        pThisProcess = pFirstProcess;
        pLastProcess = NULL;
        bMoreProcesses = TRUE;

        while ( bMoreProcesses ) {  // loop exit is at bottom of loop
            dwStartTime = GetTickCount ();
            pNewProcess = GetProcessVaData(
                    pThisProcess);  // pointer to process Info structure
            if (pNewProcess) { // process data found OK
                pNewProcess->LookUpTime = GetTickCount() - dwStartTime;
                dwProcessCount++;
                if (!pLastProcess) {    // this is the first process returned
                    pReturnValue = pNewProcess; // save return value here
                } else {
                    pLastProcess->pNextProcess = pNewProcess;
                }
                pLastProcess = pNewProcess;
            }
            if ( pThisProcess->NextEntryOffset == 0 ) {
                bMoreProcesses = FALSE; // this is the last entry
            } else {   // point to the next process info structure
				pThisProcess = (PSYSTEM_PROCESS_INFORMATION)
					((PBYTE)pThisProcess + pThisProcess->NextEntryOffset);
            }
        }
        return pReturnValue;    // return pointer to first list entry
    } else {
        return NULL;
    }
}

PPROCESS_VA_INFO
GetProcessVaData (
    IN PSYSTEM_PROCESS_INFORMATION     pProcess
)
/*++

GetProcessVaData

    Gets the Virtual Memory usage details for the process passed in the
    argument list. Collects the data for all images in use by the process.

    Note that this routine allocates data structures that must be freed
    (using the FreeProcessVaData routine) when finished with them.


Arguments

    IN HANDLE hProcess
        handle to the process to collect data for

Return Value

    Pointer to completed Process VA info structure or
    NULL if unable to collect data
--*/
{
    NTSTATUS                Status;
    HANDLE                  hProcess;
    PPROCESS_VA_INFO        pThisProcess;
    PPEB                    pPeb;
    PPEB_LDR_DATA           Ldr;
    PLIST_ENTRY             LdrHead, LdrNext;
    LDR_DATA_TABLE_ENTRY    LdrEntryData, *pLdrEntry;
    PMODINFO                pNewModule, pLastModule;
    PVOID                   pBaseAddress;
    MEMORY_BASIC_INFORMATION VaBasicInfo;
    DWORD                   dwProtection;
    PMODINFO                pMod;
    SIZE_T                  dwRegionSize;
    OBJECT_ATTRIBUTES       obProcess;
    CLIENT_ID               ClientId;
    PUNICODE_STRING         pProcessNameBuffer;

    // get handle to process

    ClientId.UniqueThread = (HANDLE)NULL;
    ClientId.UniqueProcess = pProcess->UniqueProcessId;

    InitializeObjectAttributes(
        &obProcess,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = NtOpenProcess(
        &hProcess,
        (ACCESS_MASK)PROCESS_ALL_ACCESS,
        &obProcess,
        &ClientId);

    if (! NT_SUCCESS(Status)){
        // unable to open the process, but still want to
        // create pThisProcess so we will not mess up
        // the process sequence.
        hProcess = 0;
//        return NULL;    // unable to open process
    }

    // allocate structure

    pThisProcess = ALLOCMEM (sizeof (PROCESS_VA_INFO));

    if (pThisProcess) { // allocation successful
        // initialize fields

        pThisProcess->BasicInfo =  ALLOCMEM (sizeof (PROCESS_BASIC_INFORMATION));

        if (!pThisProcess->BasicInfo) {
            // Bailout if unable to allocate memory
            goto PBailOut;
        }

        // zero process counters
        pThisProcess->MappedGuard = 0;
        pThisProcess->PrivateGuard = 0;
        pThisProcess->ImageReservedBytes = 0;
        pThisProcess->ImageFreeBytes = 0;
        pThisProcess->ReservedBytes = 0;
        pThisProcess->FreeBytes = 0;

        // get process short name from Process Info Structure

        // alloc a new buffer since GetProcessShortName reuses the name
        // buffer
        pThisProcess->pProcessName = ALLOCMEM ((sizeof(UNICODE_STRING) + MAX_PROCESS_NAME_LENGTH));

        if (pThisProcess->pProcessName != NULL) {
            pThisProcess->pProcessName->Length = 0;
            pThisProcess->pProcessName->MaximumLength = MAX_PROCESS_NAME_LENGTH;
            pThisProcess->pProcessName->Buffer = (PWSTR)(&pThisProcess->pProcessName[1]);

            pProcessNameBuffer = GetProcessShortName (pProcess);
            RtlCopyUnicodeString (pThisProcess->pProcessName,
                pProcessNameBuffer);
        } else {
            pThisProcess->pProcessName = NULL;
        }

        pThisProcess->dwProcessId = HandleToUlong(pProcess->UniqueProcessId);
        pThisProcess->hProcess = hProcess;

        // zero list pointers
        pThisProcess->pMemBlockInfo = NULL;
        pThisProcess->pNextProcess = NULL;

        if (hProcess) {

            Status = NtQueryInformationProcess (
                hProcess,
                ProcessBasicInformation,
                pThisProcess->BasicInfo,
                sizeof (PROCESS_BASIC_INFORMATION),
                NULL);

            if (!NT_SUCCESS(Status)){
                // if error reading data, then bail out
                goto SuccessExit;
            }

            // get pointer to the Process Environment Block

            pPeb = pThisProcess->BasicInfo->PebBaseAddress;

            // read address of loader information structure

            Status = NtReadVirtualMemory (
                hProcess,
                &pPeb->Ldr,
                &Ldr,
                sizeof (Ldr),
                NULL);

            // bail out if unable to read information

            if (!NT_SUCCESS(Status)){
                // if error reading data, then bail out
                goto SuccessExit;
            }

            //
            // get head pointer to linked list of memory modules used by
            // this process
            //

            LdrHead = &Ldr->InMemoryOrderModuleList;

            // Get address of next list entry

            Status = NtReadVirtualMemory (
                hProcess,
                &LdrHead->Flink,
                &LdrNext,
                sizeof (LdrNext),
                NULL);

            // bail out if unable to read information

            if (!NT_SUCCESS(Status)){
                // if error reading data, then bail out
                goto SuccessExit;
            }

            pLastModule = NULL;

            // walk down the list of modules until back at the top.
            // to list all the images in use by this process

            while ( LdrNext != LdrHead ) {
                // get record attached to list entry
	            pLdrEntry = CONTAINING_RECORD(LdrNext,
                                            LDR_DATA_TABLE_ENTRY,
                                            InMemoryOrderLinks);

                Status = NtReadVirtualMemory(
                            hProcess,
                            pLdrEntry,
                            &LdrEntryData,
                            sizeof(LdrEntryData),
                            NULL
                            );
                // if unable to read memory, then give up rest of search
                // and return what we have already.
                if ( !NT_SUCCESS(Status) ) {
                    goto SuccessExit;
                }


                pNewModule = GetModuleVaData (
                    &LdrEntryData,
                    pThisProcess);
                if (pNewModule) {   // if structure returned...
                    dwModuleCount++;
                    if (!pLastModule) { // if this is the first module...
                        // then set list head pointer
                        pThisProcess->pMemBlockInfo = pNewModule;
                    } else {
                        // otherwise link to list
                        pLastModule->pNextModule = pNewModule;
                    }
                    pLastModule = pNewModule;
                }
                LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
            } // end while not at end of list


            // now that we have a list of all images, query the process'
            // virtual memory for the list of memory blocks in use by this
            // process and assign them to the appropriate category of memory

            pBaseAddress = NULL;    // start at 0 and go to end of User VA space

            while (pBaseAddress < STOP_AT) { // truncate to 32-bit if necessary

                Status = NtQueryVirtualMemory (
                    hProcess,
                    pBaseAddress,
                    MemoryBasicInformation,
                    &VaBasicInfo,
                    sizeof(VaBasicInfo),
                    NULL);

                if (!NT_SUCCESS(Status)) {
                    goto SuccessExit;
                } else {
                    // get protection type for index into counter array
                    dwRegionSize = VaBasicInfo.RegionSize;
                    switch (VaBasicInfo.State) {
                        case MEM_COMMIT:
                            // if the memory is for an IMAGE, then search the image list
                            // for the corresponding image to update
                            dwProtection = ProtectionToIndex(VaBasicInfo.Protect);
                            if (VaBasicInfo.Type == MEM_IMAGE) {
                                // update process total
                                pThisProcess->MemTotals.CommitVector[dwProtection] += dwRegionSize;
                                pMod = LocateModInfo (pThisProcess->pMemBlockInfo, pBaseAddress, dwRegionSize);
                                if (pMod) { // if matching image found, then update
                                    pMod->CommitVector[dwProtection] += dwRegionSize;
                                    pMod->TotalCommit += dwRegionSize;
                                } else { // otherwise update orphan total
                                    pThisProcess->OrphanTotals.CommitVector[dwProtection] += dwRegionSize;
                                }
                            } else {
                                // if not assigned to an image, then update the process
                                // counters
                                if (VaBasicInfo.Type == MEM_MAPPED) {
                                    pThisProcess->MappedCommit[dwProtection] += dwRegionSize;
                                } else {
                                    pThisProcess->PrivateCommit[dwProtection] += dwRegionSize;
                                }
                            }
                            break;

                        case MEM_RESERVE:
                            if (VaBasicInfo.Type == MEM_IMAGE) {
                                pThisProcess->ImageReservedBytes += dwRegionSize;
                            } else {
                                pThisProcess->ReservedBytes += dwRegionSize;
                            }
                            break;

                        case MEM_FREE:
                            if (VaBasicInfo.Type == MEM_IMAGE) {
                                pThisProcess->ImageFreeBytes += dwRegionSize;
                            } else {
                                pThisProcess->FreeBytes += dwRegionSize;
                            }
                            break;

                        default:
                            break;
                    } // end switch (VaBasicInfo.State)
                } // endif QueryVM ok

                // go to next memory block

                pBaseAddress = (PVOID)((ULONG_PTR)pBaseAddress + dwRegionSize);

            } // end whil not at the end of  memory
        } // endif hProcess not NULL
    } // endif pThisProcess not NULL

SuccessExit:

    if (hProcess) CloseHandle(hProcess);

    return pThisProcess;

//
//  error recovery section, called when the routine is unable to
//  complete successfully to clean up before leaving
//

PBailOut:
    if (pThisProcess->BasicInfo) {
        FREEMEM (pThisProcess->BasicInfo);
    }
    FREEMEM (pThisProcess);
    if (hProcess) CloseHandle(hProcess);
    return NULL;
}

PMODINFO
GetModuleVaData (
    PLDR_DATA_TABLE_ENTRY ModuleListEntry,  // module information structure
    PPROCESS_VA_INFO    pProcess            // process data structure
)
/*++

GetModuleVaData

    Gets the Virtual Memory usage details for the module pointed to by the
    Process Memory Module List Entry argument in the argument list

    Note that this routine allocates data structures that must be freed
    (using the FreeModuleVaData routine) when finished with them.

Arguments

    IN HANDLE ModuleListEntry

Return Value

    Pointer to completed Module VA info structure or
    NULL if unable to collect data

--*/
{
    PMODINFO    pThisModule = NULL;    // module structure that is returned
    PUNICODE_STRING pusInstanceName = NULL;    // process->image
    PUNICODE_STRING pusLongInstanceName = NULL;    // process->fullimagepath
    UNICODE_STRING  usImageFileName = {0,0, NULL};	// image file name
    UNICODE_STRING  usExeFileName = {0,0, NULL};    // short name
    UNICODE_STRING  usNtFileName = {0,0, NULL};     // full Nt File Name

    PWCHAR          p,p1;
    NTSTATUS    Status;
    HANDLE      hFile;
    HANDLE      hMappedFile;
    WORD        wStringSize;

    PVOID       MappedAddress;
    PVOID       MapBase;
    SIZE_T      dwMappedSize;

    PIMAGE_DOS_HEADER   DosHeader;
    PIMAGE_NT_HEADERS   FileHeader;

    LARGE_INTEGER       liSectionSize;
    PLARGE_INTEGER       pliSectionSize;
    LARGE_INTEGER       liSectionOffset;
    OBJECT_ATTRIBUTES   obFile;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOL                bRetCode;
	USHORT              wBufOffset;
	USHORT              wDiffSize;

    // allocate this item's memory

    pThisModule = ALLOCMEM (sizeof (MODINFO));

    if (!pThisModule) {
        return NULL;
    }

    // allocate this items Instance Name Buffer

    wStringSize = (WORD)(ModuleListEntry->BaseDllName.MaximumLength +
        sizeof (UNICODE_NULL));

    pusInstanceName = ALLOCMEM (wStringSize + sizeof(UNICODE_STRING))  ;

    if (!pusInstanceName) {
        goto MBailOut;
    }

    pusInstanceName->Length = 0;
    pusInstanceName->MaximumLength = wStringSize;
    pusInstanceName->Buffer = (PWCHAR)&pusInstanceName[1];

    // save instance name using full file path

    wStringSize = (WORD)(ModuleListEntry->FullDllName.MaximumLength +
        sizeof (UNICODE_NULL));

    pusLongInstanceName = ALLOCMEM (wStringSize + sizeof (UNICODE_STRING));

    if (!pusLongInstanceName) {
        goto MBailOut;
    }

    pusLongInstanceName->Length = 0;
    pusLongInstanceName->MaximumLength = wStringSize;
    pusLongInstanceName->Buffer = (PWCHAR)&pusLongInstanceName[1];

    // allocate temporary buffer for image name

    usImageFileName.Length = ModuleListEntry->FullDllName.Length;
    usImageFileName.MaximumLength = ModuleListEntry->FullDllName.MaximumLength;
    usImageFileName.Buffer = ALLOCMEM(usImageFileName.MaximumLength);
    if ( !usImageFileName.Buffer ) {
        goto MBailOut;
    }

    // allocate temporary buffer for exe name

    usExeFileName.Length = ModuleListEntry->BaseDllName.Length;
    usExeFileName.MaximumLength = ModuleListEntry->BaseDllName.MaximumLength;
    usExeFileName.Buffer = ALLOCMEM(usExeFileName.MaximumLength);
    if ( !usExeFileName.Buffer ) {
        goto MBailOut;
    }
    usExeFileName.Buffer[0] = UNICODE_NULL;

    // read base .exe/.dll name of image

    Status = NtReadVirtualMemory(
            pProcess->hProcess,
        	ModuleListEntry->BaseDllName.Buffer,
        	usExeFileName.Buffer,
        	usExeFileName.MaximumLength,
            NULL
            );
    if ( !NT_SUCCESS(Status) ) {
        goto MBailOut;
    }

    usImageFileName.Buffer[0] = UNICODE_NULL;
    // read full name of image
    Status = NtReadVirtualMemory(
            pProcess->hProcess,
        	ModuleListEntry->FullDllName.Buffer,
        	usImageFileName.Buffer,
        	usImageFileName.MaximumLength,
            NULL
            );

    if ( !NT_SUCCESS(Status) ) {
        goto MBailOut;
    }

    // make a DOS filename to convert to NT again

	wDiffSize = wBufOffset = 0;
    p = p1 = usImageFileName.Buffer;
    while (*p != (WCHAR)0){
        if (*p == L':'){
            p1 = p;
			wDiffSize = wBufOffset;
        }
		wBufOffset += sizeof(WCHAR);
        p++;
    }
    if (p1 != usImageFileName.Buffer) {
		// move pointer
        usImageFileName.Buffer = --p1;
		// adjust length fields
		wDiffSize -= (USHORT)(sizeof(WCHAR));
		usImageFileName.Length = usImageFileName.Length - wDiffSize;
		usImageFileName.MaximumLength = usImageFileName.MaximumLength - wDiffSize;
    }

    // Create/copy a NT filename for Nt file operation

    bRetCode = RtlDosPathNameToNtPathName_U (
        usImageFileName.Buffer,
        &usNtFileName,
        NULL,
        NULL);

    if ( !bRetCode ) {
        goto MBailOut;
    }

    // get handle to file

    InitializeObjectAttributes(
        &obFile,
        &usNtFileName,
        FILE_ATTRIBUTE_NORMAL | OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile (
        &hFile,
        (ACCESS_MASK)GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
        &obFile,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL & FILE_ATTRIBUTE_VALID_FLAGS,
        FILE_SHARE_READ,
        FILE_OPEN,
        0,
        NULL,
        0);

    if (!NT_SUCCESS(Status)) {
        goto MBailOut;
    }

    pliSectionSize = &liSectionSize;
    liSectionSize.HighPart = 0;
    liSectionSize.LowPart = 0;

    InitializeObjectAttributes (
        &obFile,
        NULL,
        0,
        NULL,
        NULL);

    Status = NtCreateSection (
        &hMappedFile,
        SECTION_QUERY | SECTION_MAP_READ,
        &obFile,
        pliSectionSize,
        PAGE_READONLY,
        SEC_COMMIT,
        hFile);

    if ( ! NT_SUCCESS(Status)) {
        CloseHandle(hFile);
        goto MBailOut;
        }

    // get pointer to mapped memory
    MappedAddress = MapBase = NULL;
    dwMappedSize = 0;

    liSectionOffset.LowPart = 0;
    liSectionOffset.HighPart = 0;

    Status = NtMapViewOfSection (
        hMappedFile,
        NtCurrentProcess(),
        &MapBase,
        0L,
        0L,
        &liSectionOffset,
        &dwMappedSize,
        ViewShare,
        0L,
        PAGE_READONLY);

    CloseHandle(hMappedFile);

    if (NT_SUCCESS(Status)) {
        MappedAddress = MapBase;
    } else {
        CloseHandle(hFile);
        goto MBailOut;
    }

    // check for dos image signature (if a dos file)

    DosHeader = (PIMAGE_DOS_HEADER)MappedAddress;

    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
        UnmapViewOfFile(MappedAddress);
        CloseHandle(hFile);
        goto MBailOut;
        }

    FileHeader = (PIMAGE_NT_HEADERS)((UINT_PTR)DosHeader + DosHeader->e_lfanew);

    if ( FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
        UnmapViewOfFile(MappedAddress);
        CloseHandle(hFile);
        goto MBailOut;
        }

    // get base address for this module and save in local data structure

    pThisModule->BaseAddress = ModuleListEntry->DllBase;

    // get image name

    RtlCopyUnicodeString (
        pusInstanceName,
        &usExeFileName);

    RtlCopyUnicodeString (
        pusLongInstanceName,
        &usImageFileName);

    pThisModule->InstanceName = pusInstanceName;
    pThisModule->LongInstanceName = pusLongInstanceName;
    pThisModule->pNextModule = NULL;
    pThisModule->TotalCommit = 0;

    memset (
        &pThisModule->CommitVector[0], 0,
        sizeof (pThisModule->CommitVector));

    pThisModule->VirtualSize = FileHeader->OptionalHeader.SizeOfImage;

    // close file handles

    UnmapViewOfFile(MappedAddress);
    CloseHandle(hFile);

    // free local memory
    // this is allocated by an RTL function RtlDosPathNameToNtPathName_U.
    RtlFreeHeap(RtlProcessHeap(), 0, usNtFileName.Buffer);

//    FREEMEM (
//        RelativeName.RelativeName.Buffer);

    FREEMEM (usExeFileName.Buffer);

    return (pThisModule);   // return pointer to completed module structure
//
//  Module bail out point, called when the routine is unable to continue
//  for some reason. This cleans up any allocated memory, etc.
//
MBailOut:

    if (pThisModule) {
        FREEMEM (pThisModule);
    }

    if (usNtFileName.Buffer) {
        // this is allocated by an RTL function RtlDosPathNameToNtPathName_U.
        RtlFreeHeap(RtlProcessHeap(), 0, usNtFileName.Buffer);
    }

//    if (RelativeName.RelativeName.Buffer) {
//        FREEMEM (
//            RelativeName.RelativeName.Buffer);
//    }

    if (pusInstanceName) {
        FREEMEM (pusInstanceName);

        }

    if (pusLongInstanceName) {
        FREEMEM (pusLongInstanceName);

        }

    if (usExeFileName.Buffer){
        FREEMEM (usExeFileName.Buffer);
        }

    if (usImageFileName.Buffer) {
        FREEMEM(usImageFileName.Buffer);
    }

    return NULL;
}

PMODINFO
LocateModInfo(
    IN PMODINFO    pFirstMod,
    IN PVOID    pAddress,
    IN SIZE_T   dwExtent
    )
/*++

LocateModInfo

    Locates the images associated with the address passed in the argument list

Arguments

    IN PMODINFO pFirstMod,
        first module entry  in process list

    IN PVOID Address
        Address to search for in list

Return Value

    Pointer to matching image or
    NULL if no match found

--*/
{
    PMODINFO    pThisMod;

    pThisMod = pFirstMod;

    while (pThisMod)  { // go to end of list or match is found

        // match criteria are:
        //  address >= Module BaseAddress  and
        //  address+extent between base and base+image_extent

        if (pAddress >= pThisMod->BaseAddress) {
            if ((PVOID)((PDWORD)pAddress + dwExtent) <=
                (PVOID)((ULONG_PTR)pThisMod->BaseAddress+pThisMod->VirtualSize)) {
                return (pThisMod);
            }
        }

        pThisMod = pThisMod->pNextModule;

    }

    return NULL;
}

DWORD
ProtectionToIndex(
    IN ULONG Protection
    )
/*++

ProtectionToIndex

    Determine the memory access protection type and return local code

Arguments

   IN ULONG
        Protection

        Process memory protection mask

Return Value

    Local value of protection type

--*/
{
    Protection &= (PAGE_NOACCESS |
                    PAGE_READONLY |
                    PAGE_READWRITE |
                    PAGE_WRITECOPY |
                    PAGE_EXECUTE |
                    PAGE_EXECUTE_READ |
                    PAGE_EXECUTE_READWRITE |
                    PAGE_EXECUTE_WRITECOPY);

    switch ( Protection ) {

        case PAGE_NOACCESS:
                return NOACCESS;

        case PAGE_READONLY:
                return READONLY;

        case PAGE_READWRITE:
                return READWRITE;

        case PAGE_WRITECOPY:
                return WRITECOPY;

        case PAGE_EXECUTE:
                return EXECUTE;

        case PAGE_EXECUTE_READ:
                return EXECUTEREAD;

        case PAGE_EXECUTE_READWRITE:
                return EXECUTEREADWRITE;

        case PAGE_EXECUTE_WRITECOPY:
                return EXECUTEWRITECOPY;
        default:
                return 0xFFFFFFFF;
        }
}

BOOL
FreeSystemVaData (
    IN PPROCESS_VA_INFO pFirstProcess
)
{
    PPROCESS_VA_INFO pThisProcess, pNextProcess;

    pThisProcess = pFirstProcess;
    while (pThisProcess) {
        pNextProcess = pThisProcess->pNextProcess;  // save pointer to next
        FreeProcessVaData (pThisProcess);
        pThisProcess = pNextProcess;    // do next until NULL pointer
    }
    return (FALSE);
}

BOOL
FreeProcessVaData (
    IN PPROCESS_VA_INFO pProcess
)
{
    PMODINFO    pThisModule, pNextModule;

    if (pProcess) {
        if (pProcess->pProcessName) {
            FREEMEM (pProcess->pProcessName);
            pProcess->pProcessName = NULL;
        }
        if (pProcess->BasicInfo) {
            FREEMEM (pProcess->BasicInfo);
            pProcess->BasicInfo = NULL;
        }


        pThisModule = pProcess->pMemBlockInfo;
        while (pThisModule) {
            pNextModule = pThisModule->pNextModule;
            FreeModuleVaData (pThisModule);
            pThisModule = pNextModule;
        }
        //
        //  and finally throw ourselves away
        //
        FREEMEM (pProcess);
    }
    return FALSE;
}

BOOL
FreeModuleVaData (
    IN PMODINFO pModule
)
{
    if (pModule) {
        if (pModule->InstanceName) {
            FREEMEM(pModule->InstanceName);
            pModule->InstanceName = NULL;
        }
        if (pModule->LongInstanceName) {
            FREEMEM(pModule->LongInstanceName);
            pModule->LongInstanceName = NULL;
        }
        FREEMEM (pModule);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\extinit.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000   Microsoft Corporation

Module Name:

    extinit.c

Abstract:

    This file implements all the initialization library routines operating on
    extensible performance libraries.

Author:

    JeePang

Revision History:

    09/27/2000  -   JeePang     - Moved from perflib.c

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <winperf.h>
#include <rpc.h>
#include <strsafe.h>
#include "regrpc.h"
#include "ntconreg.h"
#include "prflbmsg.h"   // event log messages
#include "perflib.h"
#pragma warning(default:4306)

//
//  used for error logging control
#define DEFAULT_ERROR_LIMIT         1000

DWORD   dwExtCtrOpenProcWaitMs = OPEN_PROC_WAIT_TIME;
LONG    lExtCounterTestLevel = EXT_TEST_UNDEFINED;

// precompiled security descriptor
// System and NetworkService has full access
//
// since this is RELATIVE, it will work on both IA32 and IA64
//
DWORD g_PrecSD[] = {
        0x80040001, 0x00000044, 0x00000050, 0x00000000,
        0x00000014, 0x00300002, 0x00000002, 0x00140000,
        0x001f0001, 0x00000101, 0x05000000, 0x00000012,
        0x00140000, 0x001f0001, 0x00000101, 0x05000000,
        0x00000014, 0x00000101, 0x05000000, 0x00000014,
        0x00000101, 0x05000000, 0x00000014 };

DWORD g_SizeSD = 0;

DWORD g_RuntimeSD[  (sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE)
                                 + sizeof(SECURITY_DESCRIPTOR_RELATIVE)
                                 + 4 * (sizeof(SID) + SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
                  / sizeof(DWORD)];

BOOL
PerflibCreateSD()
{
    BOOL         bRet   = FALSE;
    HANDLE       hToken = NULL;
    TOKEN_USER * pToken_User;

    bRet = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, & hToken);
    if (bRet) {
        DWORD dwSize = sizeof(TOKEN_USER) + sizeof(SID)
                     + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD));
        try {
            pToken_User  = (TOKEN_USER *) _alloca(dwSize);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            pToken_User = NULL;
            bRet = FALSE;
        }
        if (bRet) {
            bRet = GetTokenInformation(
                        hToken, TokenUser, pToken_User, dwSize, & dwSize);
        }
        if (bRet) {
            SID SystemSid = { SID_REVISION, 1, SECURITY_NT_AUTHORITY,
                                               SECURITY_LOCAL_SYSTEM_RID };
            PSID  pSIDUser = pToken_User->User.Sid;
            DWORD dwSids;
            DWORD ACLLength;
            DWORD dwSizeSD;
            SECURITY_DESCRIPTOR_RELATIVE * pLocalSD = NULL;
            PACL  pDacl = NULL;

            dwSize    = GetLengthSid(pSIDUser);
            dwSids    = 2;
            ACLLength = (ULONG) sizeof(ACL)
                      + (dwSids * (  (ULONG) sizeof(ACCESS_ALLOWED_ACE)
                                   - sizeof(ULONG)))
                      + dwSize
                      + sizeof(SystemSid);

            dwSizeSD  = sizeof(SECURITY_DESCRIPTOR_RELATIVE)
                      + dwSize + dwSize + ACLLength;
            pLocalSD  = (SECURITY_DESCRIPTOR_RELATIVE *) ALLOCMEM(dwSizeSD); 
            if (pLocalSD == NULL) {
                CloseHandle(hToken);
                return FALSE;
            }

            pLocalSD->Revision = SECURITY_DESCRIPTOR_REVISION;
            pLocalSD->Control  = SE_DACL_PRESENT|SE_SELF_RELATIVE;
            
            memcpy((BYTE *) pLocalSD + sizeof(SECURITY_DESCRIPTOR_RELATIVE),
                   pSIDUser,
                   dwSize);
            pLocalSD->Owner = (DWORD) sizeof(SECURITY_DESCRIPTOR_RELATIVE);
            
            memcpy((BYTE *) pLocalSD + sizeof(SECURITY_DESCRIPTOR_RELATIVE)
                                     + dwSize,
                   pSIDUser,
                   dwSize);
            pLocalSD->Group = (DWORD) (  sizeof(SECURITY_DESCRIPTOR_RELATIVE)
                                       + dwSize);

            pDacl = (PACL) ALLOCMEM(ACLLength);
            if (pDacl == NULL) {
                FREEMEM(pLocalSD);
                CloseHandle(hToken);
                return FALSE;
            }
            bRet = InitializeAcl(pDacl, ACLLength, ACL_REVISION);
            if (bRet) {
                bRet = AddAccessAllowedAceEx(pDacl,
                                             ACL_REVISION,
                                             0,
                                             MUTEX_ALL_ACCESS,
                                             & SystemSid);
                if (bRet) {
                    bRet = AddAccessAllowedAceEx(pDacl,
                                                 ACL_REVISION,
                                                 0,
                                                 MUTEX_ALL_ACCESS,
                                                 pSIDUser);
                    
                    if (bRet) {
                        memcpy((BYTE *)   pLocalSD
                                        + sizeof(SECURITY_DESCRIPTOR_RELATIVE)
                                        + dwSize
                                        + dwSize,
                               pDacl,
                               ACLLength);                 
                        pLocalSD->Dacl = (DWORD)
                                (  sizeof(SECURITY_DESCRIPTOR_RELATIVE)
                                 + dwSize + dwSize);

                        if (RtlValidRelativeSecurityDescriptor(
                                pLocalSD,
                                dwSizeSD,
                                OWNER_SECURITY_INFORMATION
                                        | GROUP_SECURITY_INFORMATION
                                        | DACL_SECURITY_INFORMATION)) {
                            g_SizeSD = dwSizeSD;
                            memcpy(g_RuntimeSD, pLocalSD, dwSizeSD);
                        }
                        else {
                            bRet = FALSE;
                        }
                    }
                }
            }
            if (pLocalSD) {
                FREEMEM(pLocalSD);
            }
            if (pDacl) {
                FREEMEM(pDacl);
            }
        }
        CloseHandle(hToken);
    }

    return bRet;
}

PEXT_OBJECT
AllocateAndInitializeExtObject (
    HKEY    hServicesKey,
    HKEY    hPerfKey,
    PUNICODE_STRING  usServiceName
)
/*++

 AllocateAndInitializeExtObject

    allocates and initializes an extensible object information entry
    for use by the performance library.

    a pointer to the initialized block is returned if all goes well,
    otherwise no memory is allocated and a null pointer is returned.

    The calling function must close the open handles and free this
    memory block when it is no longer needed.

 Arguments:

    hServicesKey    -- open registry handle to the
        HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services hey

    hPerfKey -- the open registry key to the Performance sub-key under
        the selected service

    szServiceName -- The name of the service

--*/
{
    LONG    Status;
    HKEY    hKeyLinkage;

    BOOL    bUseQueryFn = FALSE;

    PEXT_OBJECT  pReturnObject = NULL;

    DWORD   dwType;
    DWORD   dwSize;
    DWORD   dwFlags = 0;
    DWORD   dwKeep;
    DWORD   dwObjectArray[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD   dwObjIndex = 0;
    SIZE_T  dwMemBlockSize = sizeof(EXT_OBJECT);
    DWORD   dwLinkageStringLen = 0;
    DWORD   dwErrorLimit;

    PCHAR   szOpenProcName;
    PCHAR   szCollectProcName;
    PCHAR   szCloseProcName;
    PWCHAR  szLibraryString;
    PWCHAR  szLibraryExpPath;
    PWCHAR  mszObjectList;
    PWCHAR  szLinkageKeyPath;
    LPWSTR  szLinkageString = NULL;     // max path wasn't enough for some paths

    SIZE_T  OpenProcLen, CollectProcLen, CloseProcLen;
    SIZE_T  LibStringLen, LibExpPathLen, ObjListLen;
    SIZE_T  LinkageKeyLen;

    DLL_VALIDATION_DATA DllVD;
    FILETIME    LocalftLastGoodDllFileDate;

    DWORD   dwOpenTimeout;
    DWORD   dwCollectTimeout;

    LPWSTR  szThisObject;
    LPWSTR  szThisChar;

    LPSTR   pNextStringA;
    LPWSTR  pNextStringW;

    WCHAR   szMutexName[MAX_NAME_PATH+40];
    WCHAR   szPID[32];

    WORD    wStringIndex;
    LPWSTR  szMessageArray[2];
    BOOL    bDisable = FALSE;
    LPWSTR  szServiceName;
    PCHAR   pBuffer = NULL;     // Buffer to store all registry value strings
    PWCHAR  swzTail;
    PCHAR   szTail;
    DWORD   hErr;
    size_t  nCharsLeft;
    DWORD   MAX_STR, MAX_WSTR;  // Make this global if we want this dynamic

    // read the performance DLL name

    MAX_STR  = MAX_NAME_PATH;
    MAX_WSTR = MAX_STR * sizeof(WCHAR);

    szServiceName = (LPWSTR) usServiceName->Buffer;

    dwSize = (3 * MAX_STR) + (4 * MAX_WSTR);
    pBuffer = ALLOCMEM(dwSize);
    //
    // Assumes that the allocated heap is zeroed.
    //
    if (pBuffer == NULL) {
        return NULL;
    }

    szLibraryString = (PWCHAR) pBuffer;
    szLibraryExpPath = (PWCHAR) ((PCHAR) szLibraryString + MAX_WSTR);

    szOpenProcName = (PCHAR) szLibraryExpPath + MAX_WSTR;
    szCollectProcName = szOpenProcName + MAX_STR;
    szCloseProcName = szCollectProcName + MAX_STR;
    mszObjectList = (PWCHAR) (szCloseProcName + MAX_STR);
    szLinkageKeyPath = (PWCHAR) ((PCHAR) mszObjectList + MAX_WSTR);

    dwType = 0;
    LocalftLastGoodDllFileDate.dwLowDateTime = 0;
    LocalftLastGoodDllFileDate.dwHighDateTime = 0;
    memset (&DllVD, 0, sizeof(DllVD));
    dwErrorLimit = DEFAULT_ERROR_LIMIT;
    dwCollectTimeout = dwExtCtrOpenProcWaitMs;
    dwOpenTimeout = dwExtCtrOpenProcWaitMs;

    dwSize = MAX_WSTR;
    Status = PrivateRegQueryValueExW (hPerfKey,
                            DLLValue,
                            NULL,
                            &dwType,
                            (LPBYTE)szLibraryString,
                            &dwSize);

    if (Status == ERROR_SUCCESS) {
        LibStringLen = QWORD_MULTIPLE(dwSize + 1);
        szLibraryExpPath = (PWCHAR) ((PCHAR) szLibraryString + LibStringLen);
        LibExpPathLen = 8;

        if (dwType == REG_EXPAND_SZ) {
            // expand any environment vars
            dwSize = ExpandEnvironmentStringsW(
                szLibraryString,
                szLibraryExpPath,
                MAX_STR);

            if ((dwSize > MAX_STR) || (dwSize == 0)) {
                Status = ERROR_INVALID_DLL;
            } else {
                dwSize += 1;
                dwSize *= sizeof(WCHAR);
                LibExpPathLen = QWORD_MULTIPLE(dwSize);
                dwMemBlockSize += LibExpPathLen;
            }
        } else if (dwType == REG_SZ) {
            // look for dll and save full file Path
            dwSize = SearchPathW (
                NULL,   // use standard system search path
                szLibraryString,
                NULL,
                MAX_STR,
                szLibraryExpPath,
                NULL);

            if ((dwSize > MAX_STR) || (dwSize == 0)) {
                Status = ERROR_INVALID_DLL;
            } else {
                dwSize += 1;
                dwSize *= sizeof(WCHAR);
                LibExpPathLen = QWORD_MULTIPLE(dwSize);
                dwMemBlockSize += LibExpPathLen;
            }
        } else {
            Status = ERROR_INVALID_DLL;
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
        }

        szOpenProcName = (PCHAR) szLibraryExpPath + LibExpPathLen;
        OpenProcLen = 8;
        LibStringLen = 8;
        LibExpPathLen = 8;
        LinkageKeyLen = 8;

        if (Status == ERROR_SUCCESS) {
            // we have the DLL name so get the procedure names
            dwType = 0;
            dwSize = MAX_STR;
            Status = PrivateRegQueryValueExA (hPerfKey,
                                    OpenValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szOpenProcName,
                                    &dwSize);
            if ((Status != ERROR_SUCCESS) || (szOpenProcName[0] == 0)) {
                if (szServiceName != NULL) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT,
                        ARG_TYPE_WSTR, Status,
                        szServiceName, usServiceName->MaximumLength, NULL));
                }
                else {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
                }
//                DebugPrint((1, "No open procedure for %ws %d\n",
//                                szServiceName, Status));
                bDisable = TRUE;
                if (THROTTLE_PERFLIB(PERFLIB_PROC_NAME_NOT_FOUND)) {
                    wStringIndex = 0;
                    szMessageArray[wStringIndex++] = (LPWSTR) L"Open";
                    szMessageArray[wStringIndex++] = szServiceName;
                    ReportEvent(hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        (DWORD)PERFLIB_PROC_NAME_NOT_FOUND,
                        NULL,
                        wStringIndex,
                        0,
                        szMessageArray,
                        NULL);
                }
                OpenProcLen = 8;    // 8 byte alignment
            }
            else {
                DebugPrint((2, "Found %s for %ws\n",
                    szOpenProcName, szServiceName));
                OpenProcLen = QWORD_MULTIPLE(dwSize + 1);   // 8 byte alignment
                szOpenProcName[dwSize] = 0;     // add a NULL always to be safe
            }
        }
#ifdef DBG
        else {
            DebugPrint((1, "Invalid DLL found for %ws\n",
                szServiceName));
        }
#endif

        if (Status == ERROR_SUCCESS) {
            // add in size of previous string
            // the size value includes the Term. NULL
            dwMemBlockSize += OpenProcLen;

            // we have the procedure name so get the timeout value
            dwType = 0;
            dwSize = sizeof(dwOpenTimeout);
            Status = PrivateRegQueryValueExW (hPerfKey,
                                    OpenTimeout,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwOpenTimeout,
                                    &dwSize);

            // if error, then apply default
            if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                dwOpenTimeout = dwExtCtrOpenProcWaitMs;
                Status = ERROR_SUCCESS;
            }

        }

        szCloseProcName = szOpenProcName + OpenProcLen;
        CloseProcLen = 8;

        if (Status == ERROR_SUCCESS) {
            // get next string

            dwType = 0;
            dwSize = MAX_STR;
            Status = PrivateRegQueryValueExA (hPerfKey,
                                    CloseValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szCloseProcName,
                                    &dwSize);
            if ((Status != ERROR_SUCCESS) || (szCloseProcName[0] == 0)) {
                if (szServiceName != NULL) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT,
                        ARG_TYPE_WSTR, Status,
                        szServiceName, usServiceName->MaximumLength, NULL));
                }
                else {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
                }
//                DebugPrint((1, "No close procedure for %ws\n",
//                    szServiceName));
                if (THROTTLE_PERFLIB(PERFLIB_PROC_NAME_NOT_FOUND)) {
                    wStringIndex = 0;
                    szMessageArray[wStringIndex++] = (LPWSTR) L"Close";
                    szMessageArray[wStringIndex++] = szServiceName;
                    ReportEvent(hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        (DWORD)PERFLIB_PROC_NAME_NOT_FOUND,
                        NULL,
                        wStringIndex,
                        0,
                        szMessageArray,
                        NULL);
                }
                bDisable = TRUE;
            }
            else {
                DebugPrint((2, "Found %s for %ws\n",
                            szCloseProcName, szServiceName));
                CloseProcLen = QWORD_MULTIPLE(dwSize + 1);
            }
        }

        // Initialize defaults first
        szCollectProcName = szCloseProcName + CloseProcLen;
        CollectProcLen = 8;
        mszObjectList = (PWCHAR) ((PCHAR) szCollectProcName + CollectProcLen);

        if (Status == ERROR_SUCCESS) {
            // add in size of previous string
            // the size value includes the Term. NULL
            dwMemBlockSize += CloseProcLen;

            // try to look up the query function which is the
            // preferred interface if it's not found, then
            // try the collect function name. If that's not found,
            // then bail
            dwType = 0;
            dwSize = MAX_STR;
            Status = PrivateRegQueryValueExA (hPerfKey,
                                    QueryValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szCollectProcName,
                                    &dwSize);

            if (Status == ERROR_SUCCESS) {
                // add in size of the Query Function Name
                // the size value includes the Term. NULL
                CollectProcLen = QWORD_MULTIPLE(dwSize + 1);
                dwMemBlockSize += CollectProcLen;
                // get next string

                bUseQueryFn = TRUE;
                // the query function can support a static object list
                // so look it up

            } else {
                // the QueryFunction wasn't found so look up the
                // Collect Function name instead
                dwType = 0;
                dwSize = MAX_STR;
                Status = PrivateRegQueryValueExA (hPerfKey,
                                        CollectValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCollectProcName,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    // add in size of Collect Function Name
                    // the size value includes the Term. NULL
                    CollectProcLen = QWORD_MULTIPLE(dwSize+1);
                    dwMemBlockSize += CollectProcLen;
                }
            }
            if ((Status != ERROR_SUCCESS) || (szCollectProcName[0] == 0)) {
                if (szServiceName != NULL) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT,
                        ARG_TYPE_WSTR, Status,
                        szServiceName, usServiceName->MaximumLength, NULL));
                }
                else {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
                }
//                DebugPrint((1, "No collect procedure for %ws\n",
//                    szServiceName));
                bDisable = TRUE;
                if (THROTTLE_PERFLIB(PERFLIB_PROC_NAME_NOT_FOUND)) {
                    wStringIndex = 0;
                    szMessageArray[wStringIndex++] = (LPWSTR) L"Collect";
                    szMessageArray[wStringIndex++] = szServiceName;
                    ReportEvent(hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        (DWORD)PERFLIB_PROC_NAME_NOT_FOUND,
                        NULL,
                        wStringIndex,
                        0,
                        szMessageArray,
                        NULL);
                }
            }
#ifdef DBG
            else {
                DebugPrint((2, "Found %s for %ws\n",
                    szCollectProcName, szServiceName));
            }
#endif

            if (Status == ERROR_SUCCESS) {
                // we have the procedure name so get the timeout value
                dwType = 0;
                dwSize = sizeof(dwCollectTimeout);
                Status = PrivateRegQueryValueExW (hPerfKey,
                                        CollectTimeout,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)&dwCollectTimeout,
                                        &dwSize);

                // if error, then apply default
                if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwCollectTimeout = dwExtCtrOpenProcWaitMs;
                    Status = ERROR_SUCCESS;
                }
            }
            // get the list of supported objects if provided by the registry

            mszObjectList = (PWCHAR) ((PCHAR) szCollectProcName + CollectProcLen);
            ObjListLen = 8;
            dwType = 0;
            dwSize = MAX_WSTR;
            Status = PrivateRegQueryValueExW (hPerfKey,
                                    ObjListValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)mszObjectList,
                                    &dwSize);

            if (Status == ERROR_SUCCESS) {
                ObjListLen = QWORD_MULTIPLE(dwSize + 1);
                if (dwType == REG_SZ) {
                    szThisObject = NULL;
                    for (szThisChar = mszObjectList; * szThisChar != L'\0'; szThisChar ++) {
                        if (* szThisChar == L' ') {
                            if (szThisObject == NULL) {
                                // Extra space, skip.
                                continue;
                            }
                            else {
                                if (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION) {
                                    * szThisChar = L'\0';
                                    dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
                                    dwObjIndex ++;
                                    * szThisChar = L' ';
                                    szThisObject = NULL;
                                }
                            }
                        }
                        else if (szThisObject == NULL) {
                            szThisObject = szThisChar;
                        }
                    }
                    if ((szThisObject != NULL) && (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION)) {
                        if ((szThisObject != szThisChar) && (*szThisChar == L'\0')) {
                            dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
                            dwObjIndex ++;
                            szThisObject = NULL;
                        }
                    }
                }
                else if (dwType == REG_MULTI_SZ) {
                    for (szThisObject = mszObjectList, dwObjIndex = 0;
                            (* szThisObject != L'\0') && (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION);
                            szThisObject += lstrlenW(szThisObject) + 1) {
                        dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
                        dwObjIndex ++;
                    }
                }
                else {
                    // skip unknown ObjectList value.
                    szThisObject = NULL;
                }
                if (szThisObject != NULL && * szThisObject != L'\0') {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, 0, NULL));
                    if (THROTTLE_PERFLIB(PERFLIB_TOO_MANY_OBJECTS)) {
                        ReportEvent (hEventLog,
                            EVENTLOG_ERROR_TYPE,             // error type
                            0,                               // category (not used
                            (DWORD)PERFLIB_TOO_MANY_OBJECTS, // event,
                            NULL,                           // SID (not used),
                            0,                              // number of strings
                            0,                              // sizeof raw data
                            NULL,                           // message text array
                            NULL);                          // raw data
                    }
                }
            } else {
                // reset status since not having this is
                //  not a showstopper
                Status = ERROR_SUCCESS;
            }

            szLinkageKeyPath = (PWCHAR) ((PCHAR) mszObjectList + ObjListLen);

            if (Status == ERROR_SUCCESS) {
                dwType = 0;
                dwKeep = 0;
                dwSize = sizeof(dwKeep);
                Status = PrivateRegQueryValueExW (hPerfKey,
                                        KeepResident,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)&dwKeep,
                                        &dwSize);

                if ((Status == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                    if (dwKeep == 1) {
                        dwFlags |= PERF_EO_KEEP_RESIDENT;
                    } else {
                        // no change.
                    }
                } else {
                    // not fatal, just use the defaults.
                    Status = ERROR_SUCCESS;
                }

            }
            if (Status == ERROR_SUCCESS) {
                dwType = REG_DWORD;
                dwSize = sizeof(DWORD);
                PrivateRegQueryValueExW(
                    hPerfKey,
                    cszFailureLimit,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwErrorLimit,
                    &dwSize);
            }
        }
    }
    else {
        if (szServiceName != NULL) {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT,
                ARG_TYPE_WSTR, Status,
                szServiceName, WSTRSIZE(szServiceName), NULL));
        }
        else {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
        }
//        DebugPrint((1, "Cannot key for %ws. Error=%d\n",
//            szServiceName, Status));
    }

    if (Status == ERROR_SUCCESS) {
        // get Library validation time
        dwType = 0;
        dwSize = sizeof(DllVD);
        Status = PrivateRegQueryValueExW (hPerfKey,
                                cszLibraryValidationData,
                                NULL,
                                &dwType,
                                (LPBYTE)&DllVD,
                                &dwSize);

        if ((Status != ERROR_SUCCESS) ||
            (dwType != REG_BINARY) ||
            (dwSize != sizeof (DllVD))){
            // then set this entry to be 0
            TRACE((WINPERF_DBG_TRACE_INFO),
                (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status,
                &dwType, sizeof(dwType), &dwSize, sizeof(dwSize), NULL));
            memset (&DllVD, 0, sizeof(DllVD));
            // and clear the error
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS) {
        // get the file timestamp of the last successfully accessed file
        dwType = 0;
        dwSize = sizeof(LocalftLastGoodDllFileDate);
        memset (&LocalftLastGoodDllFileDate, 0, sizeof(LocalftLastGoodDllFileDate));
        Status = PrivateRegQueryValueExW (hPerfKey,
                                cszSuccessfulFileData,
                                NULL,
                                &dwType,
                                (LPBYTE)&LocalftLastGoodDllFileDate,
                                &dwSize);

        if ((Status != ERROR_SUCCESS) ||
            (dwType != REG_BINARY) ||
            (dwSize != sizeof (LocalftLastGoodDllFileDate))) {
            // then set this entry to be Invalid
            memset (&LocalftLastGoodDllFileDate, 0xFF, sizeof(LocalftLastGoodDllFileDate));
            // and clear the error
            TRACE((WINPERF_DBG_TRACE_INFO),
                (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status,
                &dwType, sizeof(dwType), &dwSize, sizeof(dwSize), NULL));
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS) {

        hErr = StringCchCopyEx(szLinkageKeyPath, MAX_STR, szServiceName,
                              &swzTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
        if (SUCCEEDED(hErr)) {
            hErr = StringCchCopy(swzTail, nCharsLeft, LinkageKey);
        }
        hKeyLinkage = INVALID_HANDLE_VALUE;
        Status = HRESULT_CODE(hErr);
        if (SUCCEEDED(hErr)) {
            Status = RegOpenKeyExW (
                        hServicesKey,
                        szLinkageKeyPath,
                        0L,
                        KEY_READ,
                        &hKeyLinkage);
        }

        if ((Status == ERROR_SUCCESS) && (hKeyLinkage != INVALID_HANDLE_VALUE)) {
            // look up export value string
            dwSize = 0;
            dwType = 0;
            Status = PrivateRegQueryValueExW (
                hKeyLinkage,
                ExportValue,
                NULL,
                &dwType,
                NULL,
                &dwSize);
            // get size of string
            if (((Status != ERROR_SUCCESS) && (Status != ERROR_MORE_DATA)) ||
                ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) {
                dwLinkageStringLen = 0;
                szLinkageString = NULL;
                // not finding a linkage key is not fatal so correct
                // status
                Status = ERROR_SUCCESS;
            } else {
                // allocate buffer
                szLinkageString = (LPWSTR)ALLOCMEM(dwSize + sizeof(UNICODE_NULL));

                if (szLinkageString != NULL) {
                    // read string into buffer
                    dwType = 0;
                    Status = PrivateRegQueryValueExW (
                        hKeyLinkage,
                        ExportValue,
                        NULL,
                        &dwType,
                        (LPBYTE)szLinkageString,
                        &dwSize);

                    if ((Status != ERROR_SUCCESS) ||
                        ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) {
                        // clear & release buffer
                        FREEMEM (szLinkageString);
                        szLinkageString = NULL;
                        dwLinkageStringLen = 0;
                        // not finding a linkage key is not fatal so correct
                        // status
                        Status = ERROR_SUCCESS;
                    } else {
                        // add size of linkage string to buffer
                        // the size value includes the Term. NULL
                        dwLinkageStringLen = dwSize + 1;
                        dwMemBlockSize += QWORD_MULTIPLE(dwLinkageStringLen);
                    }
                } else {
                    // clear & release buffer
                    dwLinkageStringLen = 0;
                    Status = ERROR_OUTOFMEMORY;
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status,
                        &dwSize, sizeof(dwSize), NULL));
                }
            }
            RegCloseKey (hKeyLinkage);
        } else {
            // not finding a linkage key is not fatal so correct
            // status
            // clear & release buffer
            szLinkageString = NULL;
            dwLinkageStringLen = 0;
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS) {
        // add in size of service name
        SIZE_T nDestSize;

        dwSize = usServiceName->MaximumLength;
        dwMemBlockSize += QWORD_MULTIPLE(dwSize);

        // allocate and initialize a new ext. object block
        pReturnObject = ALLOCMEM (dwMemBlockSize);

        if (pReturnObject != NULL) {
            // copy values to new buffer (all others are NULL)
            pNextStringA = (LPSTR)&pReturnObject[1];
            nDestSize = dwMemBlockSize - sizeof(EXT_OBJECT);

            // copy Open Procedure Name
            pReturnObject->szOpenProcName = pNextStringA;
            hErr = StringCbCopyExA(pNextStringA, nDestSize, szOpenProcName,
                        &szTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
            if (FAILED(hErr)) {
                Status = HRESULT_CODE(hErr);
                goto AddFailed;
            }
            pNextStringA = ALIGN_ON_QWORD(szTail + 1);  // skip pass the NULL
            nDestSize = nCharsLeft - (pNextStringA - szTail);

            pReturnObject->dwOpenTimeout = dwOpenTimeout;

            // copy collect function or query function
            pReturnObject->szCollectProcName = pNextStringA;
            hErr = StringCbCopyExA(pNextStringA, nDestSize, szCollectProcName,
                        &szTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
            if (FAILED(hErr)) {
                Status = HRESULT_CODE(hErr);
                goto AddFailed;
            }
            pNextStringA = ALIGN_ON_QWORD(szTail + 1);
            nDestSize = nCharsLeft - (pNextStringA - szTail);

            pReturnObject->dwCollectTimeout = dwCollectTimeout;

            // copy Close Procedure Name
            pReturnObject->szCloseProcName = pNextStringA;
            hErr = StringCbCopyExA(pNextStringA, nDestSize, szCloseProcName,
                        &szTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
            if (FAILED(hErr)) {
                Status = HRESULT_CODE(hErr);
                goto AddFailed;
            }
            pNextStringA = ALIGN_ON_QWORD(szTail + 1);
            nDestSize = nCharsLeft - (pNextStringA - szTail);

            // copy Library path
            pNextStringW = (LPWSTR)pNextStringA;
            pReturnObject->szLibraryName = pNextStringW;
            hErr = StringCchCopyExW(pNextStringW, nDestSize/sizeof(WCHAR), 
                        szLibraryExpPath, (PWCHAR *) &szTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
            if (FAILED(hErr)) {
                Status = HRESULT_CODE(hErr);
                goto AddFailed;
            }
            pNextStringW = (PWCHAR) ALIGN_ON_QWORD(szTail + sizeof(UNICODE_STRING));
            nDestSize = (nCharsLeft * sizeof(WCHAR)) - ((PCHAR) pNextStringW - szTail);

            // copy Linkage String if there is one
            if (szLinkageString != NULL) {
                pReturnObject->szLinkageString = pNextStringW;
                memcpy (pNextStringW, szLinkageString, dwLinkageStringLen);

                // length includes extra NULL char and is in BYTES
                pNextStringW += (dwLinkageStringLen / sizeof (WCHAR));
                pNextStringW = ALIGN_ON_QWORD(pNextStringW);   // not necessary!
                // release the buffer now that it's been copied
                FREEMEM (szLinkageString);
                szLinkageString = NULL;
                nDestSize -= QWORD_MULTIPLE(dwLinkageStringLen);
            }

            // copy Service name
            pReturnObject->szServiceName = pNextStringW;
            hErr = StringCchCopyExW(pNextStringW, nDestSize/sizeof(WCHAR),
                        szServiceName, (PWCHAR *) &szTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
            if (FAILED(hErr)) {
                Status = HRESULT_CODE(hErr);
                goto AddFailed;
            }
            pNextStringW = (PWCHAR) ALIGN_ON_QWORD(szTail + sizeof(UNICODE_STRING));
            nDestSize = (nCharsLeft * sizeof(WCHAR)) - ((PCHAR) pNextStringW - szTail);

            // load flags
            if (bUseQueryFn) {
                dwFlags |= PERF_EO_QUERY_FUNC;
            }
            pReturnObject->dwFlags =  dwFlags;

            pReturnObject->hPerfKey = hPerfKey;

            pReturnObject->LibData = DllVD; // validation data
            pReturnObject->ftLastGoodDllFileDate = LocalftLastGoodDllFileDate;

            // the default test level is "all tests"
            // if the file and timestamp work out OK, this can
            // be reset to the system test level
            pReturnObject->dwValidationLevel = EXT_TEST_ALL;

            // load Object array
            if (dwObjIndex > 0) {
                pReturnObject->dwNumObjects = dwObjIndex;
                memcpy (pReturnObject->dwObjList,
                    dwObjectArray, (dwObjIndex * sizeof(dwObjectArray[0])));
            }

            pReturnObject->llLastUsedTime = 0;

            // create Mutex name
            hErr = StringCchCopyEx(szMutexName, MAX_STR, szServiceName,
                            &swzTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
            if (SUCCEEDED(hErr)) {
                hErr = StringCchCopyEx(swzTail, nCharsLeft,
                            (LPCWSTR)L"_Perf_Library_Lock_PID_",
                            &swzTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
            }

            if (FAILED(hErr)) { // should not happen
                Status = HRESULT_CODE(hErr);
            }
            //
            // 16 chars for ULONG is plenty, so assume _ultow cannot fail
            //
            _ultow ((ULONG)GetCurrentProcessId(), szPID, 16);
            hErr = StringCchCopy(swzTail, nCharsLeft, szPID);
            if (FAILED(hErr)) { // Should not happen
                szPID[0] = 0;
            }

            {
                SECURITY_ATTRIBUTES sa;
                BOOL                bImpersonating = FALSE;
                HANDLE              hThreadToken   = NULL;

                bImpersonating = OpenThreadToken(GetCurrentThread(),
                                                 TOKEN_IMPERSONATE,
                                                 TRUE,
                                                 & hThreadToken);
                if (bImpersonating) {
                    bImpersonating = RevertToSelf();
                }

                if (g_SizeSD == 0) {
                    if (PerflibCreateSD()) {
                        sa.nLength              = g_SizeSD;
                        sa.lpSecurityDescriptor = (LPVOID) g_RuntimeSD;
                        sa.bInheritHandle       = FALSE;
                    }
                    else {
                        sa.nLength              = sizeof(g_PrecSD);
                        sa.lpSecurityDescriptor = (LPVOID) g_PrecSD;
                        sa.bInheritHandle       = FALSE;

                    }
                }
                else {
                    sa.nLength              = g_SizeSD;
                    sa.lpSecurityDescriptor = (LPVOID) g_RuntimeSD;
                    sa.bInheritHandle       = FALSE;
                }

                pReturnObject->hMutex = CreateMutexW(& sa, FALSE, szMutexName);

                if (bImpersonating) {
                    BOOL bRet;
                    bRet = SetThreadToken(NULL, hThreadToken);
                    if (!bRet)
                        Status = GetLastError();
                }
                if (hThreadToken)   CloseHandle(hThreadToken);
            }
            pReturnObject->dwErrorLimit = dwErrorLimit;
            if (   pReturnObject->hMutex != NULL
                && GetLastError() == ERROR_ALREADY_EXISTS) {
                Status = ERROR_SUCCESS;
            }
            else {
                Status = GetLastError();
            }
        } else {
            Status = ERROR_OUTOFMEMORY;
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, (ULONG)dwMemBlockSize, NULL));
        }
    }
    AddFailed :

    if ((Status == ERROR_SUCCESS) && (lpPerflibSectionAddr != NULL)) {
        PPERFDATA_SECTION_HEADER  pHead;
        DWORD           dwEntry;
        PPERFDATA_SECTION_RECORD  pEntry;
        // init perf data section
        pHead = (PPERFDATA_SECTION_HEADER)lpPerflibSectionAddr;
        pEntry = (PPERFDATA_SECTION_RECORD)lpPerflibSectionAddr;
        // get the entry first
        // the "0" entry is the header
        if (pHead->dwEntriesInUse < pHead->dwMaxEntries) {
            dwEntry = ++pHead->dwEntriesInUse;
            pReturnObject->pPerfSectionEntry = &pEntry[dwEntry];
            lstrcpynW (pReturnObject->pPerfSectionEntry->szServiceName,
                pReturnObject->szServiceName, PDSR_SERVICE_NAME_LEN);
        } else {
            // the list is full so bump the missing entry count
            pHead->dwMissingEntries++;
            pReturnObject->pPerfSectionEntry = NULL;
        }
    }


    if (Status != ERROR_SUCCESS) {
        SetLastError (Status);
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
        if (bDisable) {
            DisableLibrary(hPerfKey, szServiceName, PERFLIB_DISABLE_ALL);
        }
        if (pReturnObject) {
            FREEMEM(pReturnObject);
            pReturnObject = NULL;
        }
        if (szLinkageString) {
            FREEMEM(szLinkageString);
        }
    }

    if (pReturnObject) {
        InitializeListHead((PLIST_ENTRY)&pReturnObject->ErrorLog);
        DebugPrint((3, "Initialize list %X\n", pReturnObject->ErrorLog));
    }
    if (pBuffer) {
        FREEMEM(pBuffer);
    }
    return pReturnObject;
}


void
OpenExtensibleObjects (
)

/*++

Routine Description:

    This routine will search the Configuration Registry for modules
    which will return data at data collection time.  If any are found,
    and successfully opened, data structures are allocated to hold
    handles to them.

    The global data access in this section is protected by the
    hGlobalDataMutex acquired by the calling function.

Arguments:

    None.
                  successful open.

Return Value:

    None.

--*/

{

    DWORD dwIndex;               // index for enumerating services
    ULONG KeyBufferLength;       // length of buffer for reading key data
    ULONG ValueBufferLength;     // length of buffer for reading value data
    ULONG ResultLength;          // length of data returned by Query call
    HANDLE hPerfKey;             // Root of queries for performance info
    HANDLE hServicesKey;         // Root of services
    REGSAM samDesired;           // access needed to query
    NTSTATUS Status;             // generally used for Nt call result status
    ANSI_STRING AnsiValueData;   // Ansi version of returned strings
    UNICODE_STRING ServiceName;  // name of service returned by enumeration
    UNICODE_STRING PathName;     // path name to services
    UNICODE_STRING PerformanceName;  // name of key holding performance data
    UNICODE_STRING ValueDataName;    // result of query of value is this name
    OBJECT_ATTRIBUTES ObjectAttributes;  // general use for opening keys
    PKEY_BASIC_INFORMATION KeyInformation;   // data from query key goes here

    LPTSTR  szMessageArray[8];
    DWORD   dwRawDataDwords[8];     // raw data buffer
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    DWORD   dwDefaultValue;
    HKEY    hPerflibKey = NULL;

    PEXT_OBJECT      pLastObject = NULL;
    PEXT_OBJECT      pThisObject = NULL;

    //  Initialize do failure can deallocate if allocated

    ServiceName.Buffer = NULL;
    KeyInformation = NULL;
    ValueDataName.Buffer = NULL;
    AnsiValueData.Buffer = NULL;
    hServicesKey = NULL;

    dwIndex = 0;

    RtlInitUnicodeString(&PathName, ExtPath);
    RtlInitUnicodeString(&PerformanceName, PerfSubKey);

    try {
        // get current event log level
        dwDefaultValue = LOG_USER;
        Status = GetPerflibKeyValue (
                    EventLogLevel,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPVOID)&lEventLogLevel,
                    sizeof(DWORD),
                    (LPVOID)&dwDefaultValue,
                    &hPerflibKey);

        dwDefaultValue = EXT_TEST_ALL;
        Status = GetPerflibKeyValue (
                    ExtCounterTestLevel,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPVOID)&lExtCounterTestLevel,
                    sizeof(DWORD),
                    (LPVOID)&dwDefaultValue,
                    &hPerflibKey);

        dwDefaultValue = OPEN_PROC_WAIT_TIME;
        Status = GetPerflibKeyValue (
                    OpenProcedureWaitTime,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPVOID)&dwExtCtrOpenProcWaitMs,
                    sizeof(DWORD),
                    (LPVOID)&dwDefaultValue,
                    &hPerflibKey);

        dwDefaultValue = PERFLIB_TIMING_THREAD_TIMEOUT;
        Status = GetPerflibKeyValue (
                    LibraryUnloadTime,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPVOID)&dwThreadAndLibraryTimeout,
                    sizeof(DWORD),
                    (LPVOID)&dwDefaultValue,
                    &hPerflibKey);

        if (hPerflibKey != NULL) {
            NtClose(hPerflibKey);
        }

        // register as an event log source if not already done.

        if (hEventLog == NULL) {
            hEventLog = RegisterEventSource (NULL, (LPCWSTR)TEXT("Perflib"));
        }

        if (ExtensibleObjects == NULL) {
            // create a list of the known performance data objects
            ServiceName.Length = 0;         // Initial to mean empty string
            ServiceName.MaximumLength = (WORD)(MAX_KEY_NAME_LENGTH +
                                        PerformanceName.MaximumLength +
                                        sizeof(UNICODE_NULL));

            ServiceName.Buffer = ALLOCMEM(ServiceName.MaximumLength);

            InitializeObjectAttributes(&ObjectAttributes,
                                    &PathName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

            samDesired = KEY_READ;

            Status = NtOpenKey(&hServicesKey,
                            samDesired,
                            &ObjectAttributes);


            KeyBufferLength = sizeof(KEY_BASIC_INFORMATION) + MAX_KEY_NAME_LENGTH;

            KeyInformation = ALLOCMEM(KeyBufferLength);

            ValueBufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) +
                                MAX_VALUE_NAME_LENGTH +
                                MAX_VALUE_DATA_LENGTH;

            ValueDataName.MaximumLength = MAX_VALUE_DATA_LENGTH;
            ValueDataName.Buffer = ALLOCMEM(ValueDataName.MaximumLength);

            AnsiValueData.MaximumLength = MAX_VALUE_DATA_LENGTH/sizeof(WCHAR);
            AnsiValueData.Buffer = ALLOCMEM(AnsiValueData.MaximumLength);

            //
            //  Check for successful NtOpenKey and allocation of dynamic buffers
            //

            if ( NT_SUCCESS(Status) &&
                ServiceName.Buffer != NULL &&
                KeyInformation != NULL &&
                ValueDataName.Buffer != NULL &&
                AnsiValueData.Buffer != NULL ) {

                dwIndex = 0;

                // wait longer than the thread to give the timing thread
                // a chance to finish on it's own. This is really just a
                // failsafe step.

                while (NT_SUCCESS(Status)) {

                    Status = NtEnumerateKey(hServicesKey,
                                            dwIndex,
                                            KeyBasicInformation,
                                            KeyInformation,
                                            KeyBufferLength,
                                            &ResultLength);

                    dwIndex++;  //  next time, get the next key

                    if( !NT_SUCCESS(Status) ) {
                        // This is the normal exit: Status should be
                        // STATUS_NO_MORE_VALUES
                        break;
                    }

                    // Concatenate Service name with "\\Performance" to form Subkey

                    if ( ServiceName.MaximumLength >=
                        (USHORT)( KeyInformation->NameLength + sizeof(UNICODE_NULL) ) ) {

                        ServiceName.Length = (USHORT) KeyInformation->NameLength;

                        RtlMoveMemory(ServiceName.Buffer,
                                    KeyInformation->Name,
                                    ServiceName.Length);

                        // remember ServiceName terminator
                        dwDataIndex = ServiceName.Length/sizeof(WCHAR);
                        ServiceName.Buffer[dwDataIndex] = 0;          // null term

                        // zero terminate the buffer if space allows

                        RtlAppendUnicodeStringToString(&ServiceName,
                                                    &PerformanceName);

                        // Open Service\Performance Subkey

                        InitializeObjectAttributes(&ObjectAttributes,
                                                &ServiceName,
                                                OBJ_CASE_INSENSITIVE,
                                                hServicesKey,
                                                NULL);

                        samDesired = KEY_WRITE | KEY_READ; // to be able to disable perf DLL's

                        Status = NtOpenKey(&hPerfKey,
                                        samDesired,
                                        &ObjectAttributes);

                        if(! NT_SUCCESS(Status) ) {
                            samDesired = KEY_READ; // try read only access

                            Status = NtOpenKey(&hPerfKey,
                                            samDesired,
                                            &ObjectAttributes);
                        }

                        if( NT_SUCCESS(Status) ) {
                            // this has a performance key so read the info
                            // and add the entry to the list
                            ServiceName.Buffer[dwDataIndex] = 0;  // Put back terminator
                            pThisObject = AllocateAndInitializeExtObject (
                                hServicesKey, hPerfKey, &ServiceName);

                            if (pThisObject != NULL) {
                                if (ExtensibleObjects == NULL) {
                                    // set head pointer
                                    pLastObject =
                                        ExtensibleObjects = pThisObject;
                                    NumExtensibleObjects = 1;
                                } else {
                                    pLastObject->pNext = pThisObject;
                                    pLastObject = pThisObject;
                                    NumExtensibleObjects++;
                                }
                            } else {
                                TRACE((WINPERF_DBG_TRACE_FATAL),
                                    (&PerflibGuid, __LINE__, PERF_OPEN_EXT_OBJS, ARG_TYPE_WSTR, 0,
                                    ServiceName.Buffer, ServiceName.MaximumLength, NULL));
                                // the object wasn't initialized so toss
                                // the perf subkey handle.
                                // otherwise keep it open for later
                                // use and it will be closed when
                                // this extensible object is closed
                                NtClose (hPerfKey);
                            }
                        } else {
                                TRACE((WINPERF_DBG_TRACE_FATAL),
                                    (&PerflibGuid, __LINE__, PERF_OPEN_EXT_OBJS, ARG_TYPE_WSTR, Status,
                                    ServiceName.Buffer, ServiceName.MaximumLength, NULL));

                            // unable to open the performance subkey
                            if ((Status != STATUS_OBJECT_NAME_NOT_FOUND) &&
                                 THROTTLE_PERFLIB(PERFLIB_NO_PERFORMANCE_SUBKEY) &&
                                (lEventLogLevel >= LOG_DEBUG)) {
                                // an error other than OBJECT_NOT_FOUND should be
                                // displayed if error logging is enabled
                                // if DEBUG level is selected, then write all
                                // non-success status returns to the event log
                                //
                                dwDataIndex = wStringIndex = 0;
                                dwRawDataDwords[dwDataIndex++] = PerfpDosError(Status);
                                if (lEventLogLevel >= LOG_DEBUG) {
                                    // if this is DEBUG mode, then log
                                    // the NT status as well.
                                    dwRawDataDwords[dwDataIndex++] =
                                        (DWORD)Status;
                                }
                                szMessageArray[wStringIndex++] =
                                    ServiceName.Buffer;
                                ReportEvent (hEventLog,
                                    EVENTLOG_WARNING_TYPE,        // error type
                                    0,                          // category (not used)
                                    (DWORD)PERFLIB_NO_PERFORMANCE_SUBKEY, // event,
                                    NULL,                       // SID (not used),
                                    wStringIndex,               // number of strings
                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                    szMessageArray,                // message text array
                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                            }
                        }
                    }
                    Status = STATUS_SUCCESS;  // allow loop to continue
                }
            }
        }
    } finally {
        if (hServicesKey != NULL) {
            NtClose(hServicesKey);
        }
        if ( ServiceName.Buffer ) {
            FREEMEM(ServiceName.Buffer);
        }
        if ( KeyInformation ) {
            FREEMEM(KeyInformation);
        }
        if ( ValueDataName.Buffer ) {
            FREEMEM(ValueDataName.Buffer);
        }
        if ( AnsiValueData.Buffer ) {
            FREEMEM(AnsiValueData.Buffer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perfdlls\process\perftdet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perftdet.c

Abstract:

    This file implements an Performance Object that presents
    Thread details performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#define PERF_HEAP hLibHeap
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "datatdet.h"

DWORD APIENTRY
CollectThreadDetailsObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block

    PTHREAD_DETAILS_DATA_DEFINITION pThreadDetailDataDefinition;
    PPERF_INSTANCE_DEFINITION       pPerfInstanceDefinition;
    PTHREAD_DETAILS_COUNTER_DATA    pTDCD;

    PSYSTEM_PROCESS_INFORMATION     ProcessInfo;
    PSYSTEM_THREAD_INFORMATION      ThreadInfo = NULL;

    ULONG ProcessNumber;
    ULONG NumThreadInstances;
    ULONG ThreadNumber = 0;
    ULONG ProcessBufferOffset;
    BOOLEAN NullProcess;

    NTSTATUS            Status;     // return from Nt Calls
    LONGLONG		llPcValue;  // value of current thread PC
    OBJECT_ATTRIBUTES   Obja;       // object attributes for thread context
    HANDLE              hThread;    // handle to current thread
    CONTEXT             ThreadContext; // current thread context struct

    UNICODE_STRING ThreadName;
    WCHAR ThreadNameBuffer[MAX_THREAD_NAME_LENGTH+1];
    BOOL    bMoreThreads;

    pThreadDetailDataDefinition = (THREAD_DETAILS_DATA_DEFINITION *) *lppData;

    //
    //  Check for sufficient space for Thread object type definition
    //

    TotalLen = sizeof(THREAD_DETAILS_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               sizeof(THREAD_DETAILS_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define Thread data block
    //

    ThreadName.Length =
    ThreadName.MaximumLength = (MAX_THREAD_NAME_LENGTH + 1) * sizeof(WCHAR);
    ThreadName.Buffer = ThreadNameBuffer;

    memcpy (pThreadDetailDataDefinition,
           &ThreadDetailsDataDefinition,
           sizeof(THREAD_DETAILS_DATA_DEFINITION));

    ProcessBufferOffset = 0;

    // Now collect data for each Thread

    ProcessNumber = 0;
    NumThreadInstances = 0;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                              &pThreadDetailDataDefinition[1];

    TotalLen = sizeof (THREAD_DETAILS_DATA_DEFINITION);

    bMoreThreads = FALSE;
    if (ProcessInfo) {
        if (ProcessInfo->NextEntryOffset != 0) {
            bMoreThreads = TRUE;
        }
    }
    while ( bMoreThreads  && (ProcessInfo != NULL)) {

        if ( ProcessInfo->ImageName.Buffer != NULL ||
            ProcessInfo->NumberOfThreads > 0 ) {
            NullProcess = FALSE;
            ThreadNumber = 0;       //  Thread number of this process
            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        } else {
            NullProcess = TRUE;
        }

        while ( !NullProcess &&
                ThreadNumber < ProcessInfo->NumberOfThreads ) {

            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                       (MAX_THREAD_NAME_LENGTH+1+sizeof(DWORD))*
                           sizeof(WCHAR) +
                       sizeof (THREAD_DETAILS_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;
                return ERROR_MORE_DATA;
            }

            // Get Thread Context Information for Current PC field

            llPcValue = 0;
            InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);
            Status = NtOpenThread(
                        &hThread,
                        THREAD_GET_CONTEXT,
                        &Obja,
                        &ThreadInfo->ClientId
                        );
            if ( NT_SUCCESS(Status) ) {
                ThreadContext.ContextFlags = CONTEXT_CONTROL;
                Status = NtGetContextThread(hThread,&ThreadContext);
                NtClose(hThread);
                if ( NT_SUCCESS(Status) ) {
                    llPcValue = (LONGLONG)CONTEXT_TO_PROGRAM_COUNTER(&ThreadContext);
                } else {
                    llPcValue = 0;  // an error occured so send back 0 PC
                }
            } else {
                llPcValue = 0;  // an error occured so send back 0 PC
            }

            // The only name we've got is the thread number

            if (!NT_SUCCESS(RtlIntegerToUnicodeString(
                                ThreadNumber,
                                10,
                                &ThreadName))) {
                ThreadName.Length = 2 * sizeof(WCHAR);
                memcpy(ThreadName.Buffer, L"-1", ThreadName.Length);
                ThreadName.Buffer[2] = UNICODE_NULL;
            }

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pTDCD,
                EXPROCESS_OBJECT_TITLE_INDEX,
                ProcessNumber,
                (DWORD)-1,
                ThreadName.Buffer);

            //
            //
            //  Format and collect Thread data
            //

            pTDCD->CounterBlock.ByteLength = QWORD_MULTIPLE(sizeof (THREAD_DETAILS_COUNTER_DATA));

            pTDCD->UserPc = llPcValue;

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pTDCD[1];
            NumThreadInstances++;
            ThreadNumber++;
            ThreadInfo++;
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            // no more entries so bail out of the loop
            bMoreThreads = FALSE;
            continue;
        }

        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset];

        if ( !NullProcess ) {
            ProcessNumber++;
        }
    }

    // Note number of Thread instances

    pThreadDetailDataDefinition->ThreadDetailsObjectType.NumInstances =
        NumThreadInstances;

    //
    //  Now we know how large an area we used for the
    //  Thread definition, so we can update the offset
    //  to the next object definition
    //

    *lpcbTotalBytes =
        pThreadDetailDataDefinition->ThreadDetailsObjectType.TotalByteLength =
            QWORD_MULTIPLE(
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pThreadDetailDataDefinition));

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Thread Details Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID) ((PCHAR) pThreadDetailDataDefinition + *lpcbTotalBytes);

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\extlib.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000   Microsoft Corporation

Module Name:

    extlib.c

Abstract:

    This file implements all the library routines operating on
    extensible performance libraries.

Author:

    JeePang

Revision History:

    09/27/2000  -   JeePang     - Moved from perflib.c

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <winperf.h>
#include <rpc.h>
#include "regrpc.h"
#include "ntconreg.h"
#include "prflbmsg.h"   // event log messages
#include "perflib.h"
#pragma warning(default:4306)

// default trusted file list
// all files presume to start with "perf"

// static LONGLONG    llTrustedNamePrefix = 0x0066007200650050;   // "Perf"
#define NAME_PREFIX L"Perf"

DWORD       dwTrustedFileNames[] = {
    0x0053004F,         // "OS"   for PerfOS.dll
    0x0065004E,         // "Ne"   for PerfNet.dll
    0x00720050,         // "Pr"   for PerfProc.dll
    0x00690044          // "Di"   for PerfDisk.dll
};

CONST DWORD dwTrustedFileNameCount = 
                sizeof(dwTrustedFileNames) / sizeof (dwTrustedFileNames[0]);
// there must be at least 8 chars in the name to be checked as trusted by
// default trusted file names are at least 8 chars in length

CONST DWORD dwMinTrustedFileNameLen = 6;

BOOL
ServiceIsTrustedByDefault (
    LPCWSTR     szServiceName
)
{
    BOOL        bReturn = FALSE;
    DWORD       dwNameToTest;
    DWORD       dwIdx;

    if (szServiceName != NULL) {
        // check for min size
        dwIdx = 0;
        while ((dwIdx < dwMinTrustedFileNameLen) && (szServiceName[dwIdx] > 0))
            dwIdx++;

        if (dwIdx == dwMinTrustedFileNameLen) {
            // test first 4 bytes to see if they match
            if (!wcsncmp(szServiceName, NAME_PREFIX, sizeof(LONGLONG))) {
                // then see if the rest is in this list
                dwNameToTest = * ((DWORD *)(szServiceName+4));
                for (dwIdx = 0; dwIdx < dwTrustedFileNameCount; dwIdx++) {
                    if (dwNameToTest == dwTrustedFileNames[dwIdx]) {
                        // match found
                        bReturn = TRUE;
                        break;
                    } else {
                        // no match so continue
                    }
                }
            } else {
                // no match so return false
            }
        } else {
            // the name to be checked is too short so it mustn't be
            // a trusted one.
        }
    } else {
        // no string so return false
    }
    return bReturn;
}

DWORD
CloseExtObjectLibrary (
    PEXT_OBJECT  pObj,
    BOOL        bCloseNow
)
/*++

  CloseExtObjectLibrary
    Closes and unloads the specified performance counter library and
    deletes all references to the functions.

    The unloader is "lazy" in that it waits for the library to be
    inactive for a specified time before unloading. This is due to the
    fact that Perflib can not ever be certain that no thread will need
    this library from one call to the next. In order to prevent "thrashing"
    due to constantly loading and unloading of the library, the unloading
    is delayed to make sure it's not really needed.

    This function expects locked and exclusive access to the object while
    it is opening. This must be provided by the calling function.

 Arguments:

    pObj    -- pointer to the object information structure of the
                perf object to close

    bCloseNow -- the flag to indicate the library should be closed
                immediately. This is the result of the calling function
                closing the registry key.

--*/
{
    DWORD       Status = ERROR_SUCCESS;
    LONGLONG    TimeoutTime;

    if (((dwThreadAndLibraryTimeout == 0) ||
         (dwThreadAndLibraryTimeout == INFINITE)) && !bCloseNow) {
        return Status;
    }
    if (pObj->hLibrary != NULL) {
        // get current time to test timeout
        TimeoutTime = GetTimeAsLongLong();
        // timeout time is in ms
        TimeoutTime -= dwThreadAndLibraryTimeout;

        // don't close the library unless the object hasn't been accessed for
        // a while or the caller is closing the key

        if ((TimeoutTime > pObj->llLastUsedTime) || bCloseNow) {

            // don't toss if this library has the "keep" flag set and this
            // isn't a "close now" case

            if (!bCloseNow && (pObj->dwFlags & PERF_EO_KEEP_RESIDENT)) {
                // keep it loaded until the key is closed.
            } else {
                // then this is the last one to close the library
                // free library

                try {
                    // call close function for this DLL
                    if (pObj->CloseProc) {
                        Status = (*pObj->CloseProc)();
                    }
                    else {
                        Status = ERROR_PROC_NOT_FOUND;
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    Status = GetExceptionCode();
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_CLOSE_EXTOBJLIB, 
                        ARG_TYPE_STR, Status,
//                        pObj->szCloseProcName,
//                        STRSIZE(pObj->szCloseProcName), NULL));
                        TRACE_STR(pObj->szCloseProcName), NULL));
                }
                FreeLibrary(pObj->hLibrary);
                pObj->hLibrary = NULL;

                // clear all pointers that are now invalid
                pObj->OpenProc = NULL;
                pObj->CollectProc = NULL;
                pObj->QueryProc = NULL;
                pObj->CloseProc = NULL;
                InterlockedIncrement((LONG *)&pObj->dwCloseCount);

                pObj->llLastUsedTime = 0;
            }
        }

        Status = ERROR_SUCCESS;
    } else {
        // already closed
        Status = ERROR_SUCCESS;
    }

    PerfpDeleteErrorLogs(&pObj->ErrorLog);

    return Status;
}


DWORD
OpenExtObjectLibrary (
    PEXT_OBJECT  pObj
)
/*++

 OpenExtObjectLibrary

    Opens the specified library and looks up the functions used by
    the performance library. If the library is successfully
    loaded and opened then the open procedure is called to initialize
    the object.

    This function expects locked and exclusive access to the object while
    it is opening. This must be provided by the calling function.

 Arguments:

    pObj    -- pointer to the object information structure of the
                perf object to close

--*/
{
    DWORD   FnStatus = ERROR_SUCCESS;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwOpenEvent = PERFLIB_OPEN_PROC_FAILURE;
    DWORD   dwType;
    DWORD   dwSize;
    DWORD   dwValue;

    // variables used for event logging
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    ULONG_PTR   dwRawDataDwords[8];
    LPWSTR  szMessageArray[8];

    HANDLE  hPerflibFuncTimer = NULL;
    DLL_VALIDATION_DATA CurrentDllData;

    OPEN_PROC_WAIT_INFO opwInfo;
    UINT    nErrorMode;
    LPWSTR  szServiceName;
    DWORD   szServiceNameSize;

    BOOL    bUseTimer;
    // check to see if the library has already been opened

    if (pObj == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pObj->dwFlags & PERF_EO_DISABLED) return ERROR_SERVICE_DISABLED;

    if (pObj->hLibrary == NULL) {
        // library isn't loaded yet, so
        // check to see if this function is enabled

        szServiceName = pObj->szServiceName;
        if (szServiceName == NULL) {
            szServiceName = (LPWSTR) &NULL_STRING[0];
        }
        szServiceNameSize = WSTRSIZE(szServiceName);

        dwType = 0;
        dwSize = sizeof (dwValue);
        dwValue = 0;
        Status = PrivateRegQueryValueExW (
            pObj->hPerfKey,
            DisablePerformanceCounters,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);

        if ((Status == ERROR_SUCCESS) &&
            (dwType == REG_DWORD)) {

            pObj->dwFlags &= ~PERF_EO_DISABLED;

            switch (dwValue) {
                case PERFLIB_DISABLE_ALL :        // disabled on all platforms
                    // then DON'T Load this library
                    pObj->dwFlags |= PERF_EO_DISABLED;
                    DebugPrint((4, "Perflib:%d %ws disabled\n", __LINE__, szServiceName));
                    TRACE((WINPERF_DBG_TRACE_INFO),
                        (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                        ARG_TYPE_WSTR, 0, szServiceName,
                        szServiceNameSize, NULL));
                    break;
                case PERFLIB_DISABLE_X32 :        // disabled only on WIN32 WOW
                {
#if _WIN32
                    NTSTATUS NtStatus;
                    ULONG_PTR Wow64Info = 0;

                    NtStatus = NtQueryInformationProcess(
                                    NtCurrentProcess(),
                                    ProcessWow64Information,
                                    &Wow64Info,
                                    sizeof(Wow64Info),
                                    NULL);
                    if (NT_SUCCESS(NtStatus) && (Wow64Info)) {
                        pObj->dwFlags |= PERF_EO_DISABLED;
                        DebugPrint((4, "Perflib:%d X86 %ws disabled in WOW64\n", __LINE__, szServiceName));
                        TRACE((WINPERF_DBG_TRACE_INFO),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_TYPE_WSTR, 0, szServiceName,
                            szServiceNameSize, NULL));
                    }
#endif
                    break;
                }
                case PERFLIB_DISABLE_IA64 :        // disabled only on WIN64 native
#if _WIN64
                    pObj->dwFlags |= PERF_EO_DISABLED;
                        DebugPrint((4, "Perflib:%d %ws disabled in WIN64\n", __LINE__, szServiceName));
                        TRACE((WINPERF_DBG_TRACE_INFO),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_TYPE_WSTR, 0, szServiceName,
                            szServiceNameSize, NULL));
#endif
                    break;
                // else falls through for _WIN32
            }
        }
        else {
            // set the error status & the flag value
            Status = ERROR_SUCCESS;
            pObj->dwFlags &= ~PERF_EO_DISABLED;
        }

        if ((Status == ERROR_SUCCESS)  &&
            (pObj->LibData.FileSize > 0)) {

            if (ServiceIsTrustedByDefault(szServiceName)) {
                // then set as trusted and continue
                pObj->dwFlags |= PERF_EO_TRUSTED;
            } else {
                // see if this is a trusted file or a file that has been updated
                // get the file information
                memset (&CurrentDllData, 0, sizeof(CurrentDllData));
                Status = GetPerfDllFileInfo (
                    pObj->szLibraryName,
                    &CurrentDllData);

                if (Status == ERROR_SUCCESS) {
                    // compare file data to registry data and update flags
                    if ((pObj->LibData.CreationDate.dwHighDateTime ==
                         CurrentDllData.CreationDate.dwHighDateTime) &&
                        ((pObj->LibData.CreationDate.dwLowDateTime >> 25) ==
                         (CurrentDllData.CreationDate.dwLowDateTime >> 25)) &&
                        (pObj->LibData.FileSize == CurrentDllData.FileSize)) {
                        pObj->dwFlags |= PERF_EO_TRUSTED;
                    } else {
                        TRACE((WINPERF_DBG_TRACE_WARNING),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_TYPE_WSTR, 0, szServiceName,
                            szServiceNameSize, NULL));
                        if (THROTTLE_PERFDLL(PERFLIB_NOT_TRUSTED_FILE, pObj)) {
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                szServiceName;

                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)PERFLIB_NOT_TRUSTED_FILE,  // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                0,                          // sizeof raw data
                                szMessageArray,             // message text array
                                NULL);                       // raw data
                        }
                    }
                }
            }
        }

        if ((Status == ERROR_SUCCESS) && (!(pObj->dwFlags & PERF_EO_DISABLED))) {
            //  go ahead and load it
            nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);
            // then load library & look up functions
            pObj->hLibrary = LoadLibraryExW (pObj->szLibraryName,
                    NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
            if (pObj->hLibrary != NULL) {
                // lookup function names
                pObj->OpenProc = (OPENPROC)GetProcAddress(
                    pObj->hLibrary, pObj->szOpenProcName);
                if (pObj->OpenProc == NULL) {
                    Status = GetLastError();
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                        Status, szServiceName, szServiceNameSize,
                        TRACE_STR(pObj->szOpenProcName), NULL));
                    if (THROTTLE_PERFDLL(PERFLIB_OPEN_PROC_NOT_FOUND, pObj)) {
                        WCHAR wszProcName[MAX_PATH+1];

                        // load data for eventlog message
                        dwDataIndex = wStringIndex = 0;
                        dwRawDataDwords[dwDataIndex++] =
                            (ULONG_PTR)Status;
                        wcstombs(pObj->szOpenProcName, wszProcName, MAX_PATH);
                        szMessageArray[wStringIndex++] = &wszProcName[0];
                        szMessageArray[wStringIndex++] =
                            pObj->szLibraryName;
                        szMessageArray[wStringIndex++] =
                            szServiceName;

                        ReportEvent (hEventLog,
                            EVENTLOG_ERROR_TYPE,        // error type
                            0,                          // category (not used)
                            (DWORD)PERFLIB_OPEN_PROC_NOT_FOUND,              // event,
                            NULL,                       // SID (not used),
                            wStringIndex,               // number of strings
                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                            szMessageArray,             // message text array
                            (LPVOID)&dwRawDataDwords[0]);           // raw data

                    }
                    DisablePerfLibrary(pObj, PERFLIB_DISABLE_ALL);
                }

                if (Status == ERROR_SUCCESS) {
                    if (pObj->dwFlags & PERF_EO_QUERY_FUNC) {
                        pObj->QueryProc = (QUERYPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->CollectProc = (COLLECTPROC)pObj->QueryProc;
                    } else {
                        pObj->CollectProc = (COLLECTPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->QueryProc = (QUERYPROC)pObj->CollectProc;
                    }

                    if (pObj->CollectProc == NULL) {
                        Status = GetLastError();
                        TRACE((WINPERF_DBG_TRACE_FATAL),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                            Status, szServiceName, szServiceNameSize,
                            TRACE_STR(pObj->szCollectProcName), NULL));
                        if (THROTTLE_PERFDLL(PERFLIB_COLLECT_PROC_NOT_FOUND, pObj)) {
                            WCHAR wszProcName[MAX_PATH+1];

                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (ULONG_PTR)Status;
                            wcstombs(pObj->szCollectProcName,
                                     wszProcName, MAX_PATH);
                            szMessageArray[wStringIndex++] = &wszProcName[0];
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                szServiceName;

                            ReportEvent (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)PERFLIB_COLLECT_PROC_NOT_FOUND,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                szMessageArray,             // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }
                        DisablePerfLibrary(pObj, PERFLIB_DISABLE_ALL);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    pObj->CloseProc = (CLOSEPROC)GetProcAddress (
                        pObj->hLibrary, pObj->szCloseProcName);

                    if (pObj->CloseProc == NULL) {
                        Status = GetLastError();
                        TRACE((WINPERF_DBG_TRACE_FATAL),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                            Status, szServiceName, szServiceNameSize,
                            TRACE_STR(pObj->szCloseProcName), NULL));
                        if (THROTTLE_PERFDLL(PERFLIB_CLOSE_PROC_NOT_FOUND, pObj)) {
                            WCHAR wszProcName[MAX_PATH+1];

                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (ULONG_PTR)Status;
                            wcstombs(pObj->szCollectProcName,
                                     wszProcName, MAX_PATH);
                            szMessageArray[wStringIndex++] = &wszProcName[0];
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                szServiceName;

                            ReportEvent (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)PERFLIB_CLOSE_PROC_NOT_FOUND,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                szMessageArray,             // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }

                        DisablePerfLibrary(pObj, PERFLIB_DISABLE_ALL);
                    }
                }

                bUseTimer = TRUE;   // default
                if (!(lPerflibConfigFlags & PLCF_NO_DLL_TESTING)) {
                    if (pObj->dwFlags & PERF_EO_TRUSTED) {
                        bUseTimer = FALSE;   // Trusted DLL's are not timed
                    }
                } else {
                    // disable DLL testing
                    bUseTimer = FALSE;   // Timing is disabled as well
                }

                if (Status == ERROR_SUCCESS) {
                    try {
                        // start timer
                        opwInfo.pNext = NULL;
                        opwInfo.szLibraryName = pObj->szLibraryName;
                        opwInfo.szServiceName = szServiceName;
                        opwInfo.dwWaitTime = pObj->dwOpenTimeout;
                        opwInfo.dwEventMsg = PERFLIB_OPEN_PROC_TIMEOUT;
                        opwInfo.pData = (LPVOID)pObj;
                        if (bUseTimer) {
                            hPerflibFuncTimer = StartPerflibFunctionTimer(&opwInfo);
                            // if no timer, continue anyway, even though things may
                            // hang, it's better than not loading the DLL since they
                            // usually load OK
                            //
                            if (hPerflibFuncTimer == NULL) {
                                // unable to get a timer entry
                                TRACE((WINPERF_DBG_TRACE_WARNING),
                                      (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB, 0, 0, NULL));
                            }
                        } else {
                            hPerflibFuncTimer = NULL;
                        }

                        // call open procedure to initialize DLL
                        if (pObj->OpenProc) {
                            FnStatus = (*pObj->OpenProc)(pObj->szLinkageString);
                        }
                        else {
                            FnStatus = ERROR_PROC_NOT_FOUND;
                            dwOpenEvent = PERFLIB_OPEN_PROC_NOT_FOUND;
                        }
                        // check the result.
                        if (FnStatus != ERROR_SUCCESS) {
                            TRACE((WINPERF_DBG_TRACE_FATAL),
                                (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                                FnStatus, szServiceName, szServiceNameSize,
                                pObj->szLinkageString, (pObj->szLinkageString) ?
                                WSTRSIZE(pObj->szLinkageString) : 0, NULL));
                            dwOpenEvent = PERFLIB_OPEN_PROC_FAILURE;
                            if (FnStatus != ERROR_ACCESS_DENIED) {
                                pObj->dwOpenFail ++;
                            }
                            else {  // remember the thread Id
                                pObj->ThreadId = GetCurrentThreadId();
                                pObj->dwOpenFail = 0;   // usually only 1 type of failure
                            }
                        } else {
                            pObj->ThreadId = 0;
                            InterlockedIncrement((LONG *)&pObj->dwOpenCount);
                        }

                    } except (EXCEPTION_EXECUTE_HANDLER) {
                        FnStatus = GetExceptionCode();
                        TRACE((WINPERF_DBG_TRACE_FATAL),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_DEF(ARG_TYPE_WSTR, 1), FnStatus,
                            szServiceName, szServiceNameSize, NULL));
                        dwOpenEvent = PERFLIB_OPEN_PROC_EXCEPTION;
                    }

                    if (hPerflibFuncTimer != NULL) {
                        // kill timer
                        Status = KillPerflibFunctionTimer (hPerflibFuncTimer);
                        hPerflibFuncTimer = NULL;
                    }

                    if (FnStatus != ERROR_SUCCESS) {
                        if (dwOpenEvent == PERFLIB_OPEN_PROC_EXCEPTION) {
                            DisablePerfLibrary(pObj, PERFLIB_DISABLE_ALL);
                        }
                        if  (THROTTLE_PERFDLL(dwOpenEvent, pObj)) {
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (ULONG_PTR)FnStatus;
                            szMessageArray[wStringIndex++] =
                                szServiceName;
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;

                            ReportEventW (hEventLog,
                                (WORD)EVENTLOG_ERROR_TYPE, // error type
                                0,                          // category (not used)
                                dwOpenEvent,                // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                szMessageArray,                // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }
                    }
                }

                if (FnStatus != ERROR_SUCCESS) {
                    // clear fields
                    pObj->OpenProc = NULL;
                    pObj->CollectProc = NULL;
                    pObj->QueryProc = NULL;
                    pObj->CloseProc = NULL;
                    if (pObj->hLibrary != NULL) {
                        FreeLibrary (pObj->hLibrary);
                        pObj->hLibrary = NULL;
                    }
                    Status = FnStatus;
                } else {
                    pObj->llLastUsedTime = GetTimeAsLongLong();
                }
            } else {
                Status = GetLastError();
                TRACE((WINPERF_DBG_TRACE_FATAL),
                    (& PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB, ARG_DEF(ARG_TYPE_WSTR, 1), Status,
                    szServiceName, szServiceNameSize, NULL));
                if (Status == ERROR_BAD_EXE_FORMAT) {
                    // report error event and disable performance counter DLL.
                    DWORD dwDisable = 0;
                    DWORD dwEvent   = PERFLIB_INVALID_WOW32_PERF_DLL;
#if _WIN64
                    // Unable to load IA64 version performance counter DLL, this might be the case that
                    // performance counter DLL is 32-bit version. Disable on WIN64 native case.
                    //
                    dwEvent   = PERFLIB_INVALID_IA64_PERF_DLL;
                    dwDisable = PERFLIB_DISABLE_IA64;
#endif
#if _WIN32
                    // Unable to load WIN32 version performance counter DLL, this might be the case that
                    // performance counter DLL is 64-bit native version. Disable on WIN32 WOW case.
                    //
                    if (dwDisable == PERFLIB_DISABLE_IA64) {
                        dwDisable = PERFLIB_DISABLE_ALL;
                    }
                    else {
                        dwDisable = PERFLIB_DISABLE_X32;
                    }
#endif
                    dwDataIndex = wStringIndex = 0;
                    dwRawDataDwords[dwDataIndex ++] = (ULONG_PTR) Status;
                    szMessageArray[wStringIndex ++] = szServiceName;

                    ReportEventW(hEventLog,
                                 (WORD) EVENTLOG_ERROR_TYPE,      // error type
                                 0,                               // category (not used)
                                 dwEvent,                         // event,
                                 NULL,                            // SID (not used),
                                 wStringIndex,                    // number of strings
                                 dwDataIndex * sizeof(ULONG_PTR), // sizeof raw data
                                 szMessageArray,                  // message text array
                                 (LPVOID) & dwRawDataDwords[0]);  // raw data
                    DisablePerfLibrary(pObj, dwDisable);
                }
            }
            SetErrorMode (nErrorMode);
        }
    } else {
        // else already open so bump the ref count
        pObj->llLastUsedTime = GetTimeAsLongLong();
    }

    return Status;
}

#ifdef _WIN64
DWORD
ExtpAlignBuffer(
    PCHAR lpLastBuffer,
    PCHAR *lpNextBuffer,
    DWORD lpBytesLeft
    )
{
    PCHAR lpAligned;
    PCHAR lpBuffer = *lpNextBuffer;
    PPERF_OBJECT_TYPE pObject;

    if ((ULONG_PTR) lpBuffer & (ULONG_PTR) 0x07) {
        DWORD dwAdjust;
        lpAligned = ALIGN_ON_QWORD(lpBuffer);
        dwAdjust = (DWORD) (lpAligned - (PCHAR)lpBuffer);
        if (lpBytesLeft < dwAdjust) // No more room to align
            return 0;
        lpBytesLeft = lpBytesLeft - dwAdjust;
        pObject = (PPERF_OBJECT_TYPE) lpLastBuffer;
        while (((PCHAR) pObject + pObject->TotalByteLength) < lpBuffer) {
            pObject = (PPERF_OBJECT_TYPE) (((PCHAR) pObject) + pObject->TotalByteLength);
        }
        if ((PCHAR) pObject < lpBuffer) {
            pObject->TotalByteLength += dwAdjust;
        }
    }
    *lpNextBuffer = lpBuffer;
    return lpBytesLeft;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\ntconreg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1996   Microsoft Corporation

Module Name:

    ntconreg.h

Abstract:

    Header file for the NT Configuration Registry

    This file contains definitions which provide the interface to
    the Performance Configuration Registry.
    NOTE: This file is also included by other files in the regular
    registry support routines.

Author:

    Russ Blake  11/15/91

Revision History:

    04/20/91    -   russbl      -   Converted to lib in Registry
                                      from stand-alone .dll form.
    11/04/92    -   a-robw      -  added pagefile counters


--*/
//
#include <winperf.h>    // for fn prototype declarations
#include <ntddnfs.h>
#include <srvfsctl.h>
#include <assert.h>
//
//  Until USER supports Unicode, we have to work in ASCII:
//

#define DEFAULT_NT_CODE_PAGE 437
#define UNICODE_CODE_PAGE      0

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
//  Assumes x is DWORD, and returns a DWORD
//
#define DWORD_MULTIPLE(x) (((ULONG)(x) + ((4)-1)) & ~((ULONG)(4)-1))
#define QWORD_MULTIPLE(x) (((ULONG)(x) + ((8)-1)) & ~((ULONG)(8)-1))

//
//  Returns a PVOID
//
#define ALIGN_ON_DWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((4)-1)) & ~((ULONG_PTR)(4)-1)))
#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))

//
//  Definitions for internal use by the Performance Configuration Registry
//
//  They have been moved to perfdlls and perflib.h and left here
//  for references only
//

// #define NUM_VALUES 2
// #define MAX_INSTANCE_NAME 32
// #define DEFAULT_LARGE_BUFFER 8*1024
// #define INCREMENT_BUFFER_SIZE 4*1024
// #define MAX_PROCESS_NAME_LENGTH 256*sizeof(WCHAR)
// #define MAX_THREAD_NAME_LENGTH 10*sizeof(WCHAR)
// #define MAX_KEY_NAME_LENGTH 256*sizeof(WCHAR)
// #define MAX_VALUE_NAME_LENGTH 256*sizeof(WCHAR)
// #define MAX_VALUE_DATA_LENGTH 256*sizeof(WCHAR)

typedef PM_OPEN_PROC    *OPENPROC;
typedef PM_COLLECT_PROC *COLLECTPROC;
typedef PM_QUERY_PROC   *QUERYPROC;
typedef PM_CLOSE_PROC   *CLOSEPROC;

DWORD
PerfOpenKey (
    IN HKEY hKey
    );

BOOL
PerfRegInitialize ();

BOOL
PerfRegCleanup ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\extquery.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000   Microsoft Corporation

Module Name:

    extinit.c

Abstract:

    This file implements all the initialization library routines operating on
    extensible performance libraries.

Author:

    JeePang

Revision History:

    09/27/2000  -   JeePang     - Moved from perflib.c

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <winperf.h>
#include <rpc.h>
#include "regrpc.h"
#include "ntconreg.h"
#include "prflbmsg.h"   // event log messages
#include "perflib.h"
#pragma warning(default:4306)

//
//  static constant definitions
//
//      constants used by guard page testing
//
#define GUARD_PAGE_SIZE 1024
#define GUARD_PAGE_CHAR 0xA5
#define GUARD_PAGE_DWORD 0xA5A5A5A5

typedef struct _EXT_OBJ_ITEM {
    DWORD       dwObjId;
    DWORD       dwFlags;
} EXT_OBJ_LIST, *PEXT_OBJ_LIST;

#define PERF_EOL_ITEM_FOUND ((DWORD)0x00000001)

__inline
DWORD
RegisterExtObjListAccess ()
{
    LONG    Status;
    LARGE_INTEGER   liWaitTime;

    if (hGlobalDataMutex != NULL) {
        liWaitTime.QuadPart = MakeTimeOutValue(QUERY_WAIT_TIME);
        // wait for access to the list of ext objects
        Status = NtWaitForSingleObject (
            hGlobalDataMutex,
            FALSE,
            &liWaitTime);
        if (Status != WAIT_TIMEOUT) {
            if (hExtObjListIsNotInUse != NULL) {
                // indicate that we are going to use the list
                InterlockedIncrement ((LONG *)&dwExtObjListRefCount);
                if (dwExtObjListRefCount > 0) {
                    ResetEvent (hExtObjListIsNotInUse); // indicate list is busy
                } else {
                    SetEvent (hExtObjListIsNotInUse); // indicate list is not busy
                }
                Status = ERROR_SUCCESS;
            } else {
                Status = ERROR_NOT_READY;
            }
            ReleaseMutex (hGlobalDataMutex);
        }  // else return status;
    } else {
        Status = ERROR_LOCK_FAILED;
    }
    return Status;
}

__inline
DWORD
DeRegisterExtObjListAccess ()
{
    LONG    Status;
    LARGE_INTEGER   liWaitTime;

    if (hGlobalDataMutex != NULL) {
        liWaitTime.QuadPart = MakeTimeOutValue(QUERY_WAIT_TIME);
        // wait for access to the list of ext objects
        Status = NtWaitForSingleObject (
            hGlobalDataMutex,
            FALSE,
            &liWaitTime);
        if (Status != WAIT_TIMEOUT) {
            if (hExtObjListIsNotInUse != NULL) {
                assert (dwExtObjListRefCount > 0);
                // indicate that we are going to use the list
                InterlockedDecrement ((LONG *)&dwExtObjListRefCount);
                if (dwExtObjListRefCount > 0) {
                    ResetEvent (hExtObjListIsNotInUse); // indicate list is busy
                } else {
                    SetEvent (hExtObjListIsNotInUse); // indicate list is not busy
                }
                Status = ERROR_SUCCESS;
            } else {
                Status = ERROR_NOT_READY;
            }
            ReleaseMutex (hGlobalDataMutex);
        }  // else return status;
    } else {
        Status = ERROR_LOCK_FAILED;
    }
    return Status;
}

LONG
QueryExtensibleData (
    COLLECT_THREAD_DATA * pArgs
)
/*++
  QueryExtensibleData -    Get data from extensible objects

      Inputs:

          dwQueryType         - Query type (GLOBAL, COSTLY, item list, etc.)

          lpValueName         -   pointer to value string (unused)

          lpData              -   pointer to start of data block
                                  where data is being collected

          lpcbData            -   pointer to size of data buffer

          lppDataDefinition   -   pointer to pointer to where object
                                  definition for this object type should
                                  go

      Outputs:

          *lppDataDefinition  -   set to location for next Type
                                  Definition if successful

      Returns:

          0 if successful, else Win 32 error code of failure


--*/
{
    DWORD   dwQueryType = pArgs->dwQueryType;
    LPWSTR  lpValueName = pArgs->lpValueName;
    LPBYTE  lpData = pArgs->lpData;
    LPDWORD lpcbData = pArgs->lpcbData;
    LPVOID  *lppDataDefinition = pArgs->lppDataDefinition;

    DWORD Win32Error=ERROR_SUCCESS;          //  Failure code
    DWORD BytesLeft;
    DWORD InitialBytesLeft;
    DWORD NumObjectTypes;

    LPVOID  lpExtDataBuffer = NULL;
    LPVOID  lpCallBuffer = NULL;
    LPVOID  lpLowGuardPage = NULL;
    LPVOID  lpHiGuardPage = NULL;
    LPVOID  lpEndPointer = NULL;
    LPVOID  lpBufferBefore = NULL;
    LPVOID  lpBufferAfter = NULL;
    PUCHAR  lpCheckPointer;
    LARGE_INTEGER   liStartTime, liEndTime, liWaitTime, liDiff;

    PEXT_OBJECT  pThisExtObj = NULL;
    DWORD   dwLibEntry;

    BOOL    bGuardPageOK;
    BOOL    bBufferOK;
    BOOL    bException;
    BOOL    bUseSafeBuffer;
    BOOL    bUnlockObjData = FALSE;

    LPTSTR  szMessageArray[8];
    ULONG_PTR   dwRawDataDwords[8];     // raw data buffer
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    LONG    lReturnValue = ERROR_SUCCESS;

    LONG    lDllTestLevel;

    LONG                lInstIndex;
    DWORD               lCtrIndex;
    PERF_OBJECT_TYPE    *pObject, *pNextObject;
    PERF_INSTANCE_DEFINITION    *pInstance;
    PERF_COUNTER_DEFINITION     *pCounterDef;
    PERF_DATA_BLOCK     *pPerfData;
    BOOL                bForeignDataBuffer;

    DWORD           dwItemsInArray = 0;
    DWORD           dwItemsInList = 0;
    volatile PEXT_OBJ_LIST   pQueryList = NULL;
    LPWSTR          pwcThisChar;

    DWORD           dwThisNumber;
    DWORD           dwIndex, dwEntry;
    BOOL            bFound;
    BOOL            bDisabled = FALSE;
    BOOL            bUseTimer;
    DWORD           dwType = 0;
    DWORD           dwValue = 0;
    DWORD           dwSize = sizeof(DWORD);
    DWORD           status = 0;
    DWORD           dwObjectBufSize;

    OPEN_PROC_WAIT_INFO opwInfo;
    HANDLE  hPerflibFuncTimer;
    PVOID           pNewBuffer;

    HEAP_PROBE();

    //
    // Make sure that the caller's buffer is aligned properly
    //

#ifdef _WIN64
    if ((ULONG_PTR) *lppDataDefinition & (ULONG_PTR) 0x07) {
        DebugPrint((0, "QueryExtensibleData: lppDataDefinition not aligned %I64x\n", lppDataDefinition));
        return ERROR_INVALID_USER_BUFFER;
    }
/*
    if ((ULONG_PTR) *lpcbData & (ULONG_PTR) 0x07) {
        DebugPrint((0, "QueryExtensibleData: lpcbData not aligned %I64x\n", *lpcbData));
        return ERROR_INVALID_USER_BUFFER;
    }
*/
    if ((ULONG_PTR) lpData & (ULONG_PTR) 0x07) {
        DebugPrint((0, "QueryExtensibleData: lpData not aligned %I64x\n", lpData));
        return ERROR_INVALID_USER_BUFFER;
    }
#endif
    // see if perf data has been disabled
    // this is to prevent crashing WINLOGON if the
    // system has installed a bogus DLL

    if (ghKeyPerflib == NULL || ghKeyPerflib == INVALID_HANDLE_VALUE) {
        // Ignore Status return. We only need ghKeyPerflib to query "DisablePerformanceCounters" DWORD value.
        //
        HKEY lhKeyPerflib = NULL;
        status = (DWORD) RegOpenKeyExW(HKEY_LOCAL_MACHINE, HKLMPerflibKey, 0L, KEY_READ, & lhKeyPerflib);
        if (status == ERROR_SUCCESS) {
            if (InterlockedCompareExchangePointer(& ghKeyPerflib, lhKeyPerflib, NULL) != NULL) {
                RegCloseKey(lhKeyPerflib);
                lhKeyPerflib = NULL;
            }
        }
    }

    assert (ghKeyPerflib != NULL);
    dwSize = sizeof(dwValue);
    dwValue = dwType = 0;
    if (ghKeyPerflib != NULL && ghKeyPerflib != INVALID_HANDLE_VALUE) {
        status = PrivateRegQueryValueExW(
                        ghKeyPerflib,
                        DisablePerformanceCounters,
                        NULL,
                        & dwType,
                        (LPBYTE) & dwValue,
                        & dwSize);
        if (status == ERROR_SUCCESS && dwType == REG_DWORD && dwValue == 1) {
            // then DON'T Load any libraries and unload any that have been
            // loaded
            bDisabled = TRUE;
        }
    }

    // if data collection is disabled and there's a collection thread
    // then close it
    if (bDisabled && (hCollectThread != NULL)) {
        pArgs->dwActionFlags = CTD_AF_CLOSE_THREAD;
    } else if (!bDisabled &&
        ((hCollectThread == NULL) && (dwCollectionFlags == COLL_FLAG_USE_SEPARATE_THREAD))) {
        // then data collection is enabled and they want a separate collection
        // thread, but there's no thread at the moment, so create it here
        pArgs->dwActionFlags = CTD_AF_OPEN_THREAD;
    }

    lReturnValue = RegisterExtObjListAccess();

    if (lReturnValue == ERROR_SUCCESS) {
        liStartTime.QuadPart = 0;
        InitialBytesLeft = 0;
        liEndTime.QuadPart = 0;

        if ((dwQueryType == QUERY_ITEMS) && (!bDisabled)) {
            // alloc the call list
            pwcThisChar = lpValueName;
            dwThisNumber = 0;

            // read the value string and build an object ID list

            while (*pwcThisChar != 0) {
                dwThisNumber = GetNextNumberFromList (
                    pwcThisChar, &pwcThisChar);
                if (dwThisNumber != 0) {
                    if (dwItemsInList >= dwItemsInArray) {
                        dwItemsInArray += 16;   // starting point for # of objects
                        pNewBuffer = NULL;
                        if (pQueryList == NULL) {
                            // alloc a new buffer
                            pNewBuffer = ALLOCMEM ((sizeof(EXT_OBJ_LIST) * dwItemsInArray));
                        } else {
                            // realloc a new buffer
                            pNewBuffer = REALLOCMEM(pQueryList,
                                (sizeof(EXT_OBJ_LIST) * dwItemsInArray));
                        }
                        if (pNewBuffer == NULL) {
                            // unable to alloc memory so bail
                            if (pQueryList)
                                FREEMEM(pQueryList);
                            return ERROR_OUTOFMEMORY;
                        }
                        else {
                            pQueryList = pNewBuffer;
                        }
                    }

                    // then add to the list
                    pQueryList[dwItemsInList].dwObjId = dwThisNumber;
                    pQueryList[dwItemsInList].dwFlags = 0;
                    dwItemsInList++;
                }
            }

            if (Win32Error == ERROR_SUCCESS) {
                //
                //  Walk through list of ext. objects and tag the ones to call
                //  as the query objects are found
                //
                for (pThisExtObj = ExtensibleObjects, dwLibEntry = 0;
                    pThisExtObj != NULL;
                    pThisExtObj = pThisExtObj->pNext, dwLibEntry++) {

                    if (pThisExtObj->dwNumObjects > 0) {
                        // then examine list
                        for (dwIndex = 0; dwIndex < pThisExtObj->dwNumObjects; dwIndex++) {
                            // look at each entry in the list
                            for (dwEntry = 0; dwEntry < dwItemsInList; dwEntry++) {
                                if (pQueryList[dwEntry].dwObjId == pThisExtObj->dwObjList[dwIndex]) {
                                    // tag this entry as found
                                    pQueryList[dwEntry].dwFlags |= PERF_EOL_ITEM_FOUND;
                                    // tag the object as needed
                                    pThisExtObj->dwFlags |= PERF_EO_OBJ_IN_QUERY;
                                }
                            }
                        }
                    } else {
                        // this entry doesn't list it's supported objects
                    }
                }

                assert (dwLibEntry == NumExtensibleObjects);

                // see if any in the query list do not have entries

                bFound = TRUE;
                for (dwEntry = 0; dwEntry < dwItemsInList; dwEntry++) {
                    if (!(pQueryList[dwEntry].dwFlags & PERF_EOL_ITEM_FOUND)) {
                        // no matching object found
                        bFound = FALSE;
                        break;
                    }
                }

                if (!bFound) {
                    // at least one of the object ID's in the query list was
                    // not found in an object that supports an object list
                    // then tag all entries that DO NOT support an object list
                    // to be called and hope one of them supports it/them.
                    for (pThisExtObj = ExtensibleObjects;
                         pThisExtObj != NULL;
                         pThisExtObj = pThisExtObj->pNext) {
                        if (pThisExtObj->dwNumObjects == 0) {
                            // tag this one so it will be called
                            pThisExtObj->dwFlags |= PERF_EO_OBJ_IN_QUERY;
                        }
                    }
                }
            } // end if first scan was successful

            if (pQueryList != NULL) FREEMEM (pQueryList);
        } // end if QUERY_ITEMS


        if (lReturnValue == ERROR_SUCCESS) {
            for (pThisExtObj = ExtensibleObjects;
                 pThisExtObj != NULL;
                 pThisExtObj = pThisExtObj->pNext) {

                // set the current ext object pointer
                pArgs->pCurrentExtObject = pThisExtObj;
                // convert timeout value
                liWaitTime.QuadPart = MakeTimeOutValue (pThisExtObj->dwCollectTimeout);

                // close the unused Perf DLL's IF:
                //  the perflib key is disabled or this is an item query
                //  and this is an Item (as opposed to a global or foreign)  query or
                //      the requested objects are not it this library or this library is disabled
                //  and this library has been opened
                //
                if (((dwQueryType == QUERY_ITEMS) || bDisabled) &&
                    (bDisabled || (!(pThisExtObj->dwFlags & PERF_EO_OBJ_IN_QUERY)) || (pThisExtObj->dwFlags & PERF_EO_DISABLED)) &&
                    (pThisExtObj->hLibrary != NULL)) {
                    // then free this object
                    if (pThisExtObj->hMutex != NULL) {
                        NTSTATUS NtStatus = NtWaitForSingleObject (
                            pThisExtObj->hMutex,
                            FALSE,
                            &liWaitTime);
                        Win32Error = PerfpDosError(NtStatus);
                        if (NtStatus == STATUS_SUCCESS) {
                            // then we got a lock
                            CloseExtObjectLibrary (pThisExtObj, bDisabled);
                            ReleaseMutex (pThisExtObj->hMutex);
                        } else {
                            pThisExtObj->dwLockoutCount++;
                            DebugPrint((0, "Unable to Lock object for %ws to close in Query\n", pThisExtObj->szServiceName));
                        }
                    } else {
                        Win32Error = ERROR_LOCK_FAILED;
                        DebugPrint((0, "No Lock found for %ws\n", pThisExtObj->szServiceName));
                    }

                    if (hCollectThread != NULL) {
                        // close the collection thread

                    }
                } else if (((dwQueryType == QUERY_FOREIGN) ||
                            (dwQueryType == QUERY_GLOBAL) ||
                            (dwQueryType == QUERY_COSTLY) ||
                            ((dwQueryType == QUERY_ITEMS) &&
                             (pThisExtObj->dwFlags & PERF_EO_OBJ_IN_QUERY))) &&
                           (!(pThisExtObj->dwFlags & PERF_EO_DISABLED))) {

                    // initialize values to pass to the extensible counter function
                    NumObjectTypes = 0;
                    BytesLeft = (DWORD) (*lpcbData - ((LPBYTE) *lppDataDefinition - lpData));
                    bException = FALSE;

                    if ((pThisExtObj->hLibrary == NULL) ||
                        (dwQueryType == QUERY_GLOBAL) ||
                        (dwQueryType == QUERY_COSTLY)) {
                        // lock library object
                        if (pThisExtObj->hMutex != NULL) {
                            NTSTATUS NtStatus = NtWaitForSingleObject (
                                pThisExtObj->hMutex,
                                FALSE,
                                &liWaitTime);
                            Win32Error = ERROR_SUCCESS;
                            if (NtStatus == STATUS_SUCCESS) {
                                // if this is a global or costly query, then reset the "in query"
                                // flag for this object. The next ITEMS query will restore it.
                                if ((dwQueryType == QUERY_GLOBAL) ||
                                    (dwQueryType == QUERY_COSTLY)) {
                                    pThisExtObj->dwFlags &= ~PERF_EO_OBJ_IN_QUERY;
                                }
                                // if necessary, open the library
                                if (pThisExtObj->hLibrary == NULL) {
                                    if ((GetCurrentThreadId() != pThisExtObj->ThreadId) &&
                                        (pThisExtObj->dwOpenFail == 0)) {
                                        // make sure the library is open
                                        Win32Error = OpenExtObjectLibrary(pThisExtObj);
                                        if (Win32Error != ERROR_SUCCESS) {
#if DBG
                                            if (Win32Error != ERROR_SERVICE_DISABLED) {
                                                // SERVICE_DISABLED is returned when the
                                                // service has been disabled via ExCtrLst.
                                                // so no point in complaining about it.
                                                // assume error has been posted
                                                DebugPrint((0, "Unable to open perf counter library for %ws, Error: 0x%8.8x\n",
                                                    pThisExtObj->szServiceName, Win32Error));
                                            }
#endif
                                            ReleaseMutex (pThisExtObj->hMutex);
                                            continue; // to next entry
                                        }
                                    }
                                    else {
                                        ReleaseMutex (pThisExtObj->hMutex);
                                        continue; // to next entry
                                    }
                                }
                                ReleaseMutex (pThisExtObj->hMutex);
                            } else {
                                Win32Error = PerfpDosError(NtStatus);
                                pThisExtObj->dwLockoutCount++;
                                DebugPrint((0, "Unable to Lock object for %ws to open for Query\n", pThisExtObj->szServiceName));
                            }
                        } else {
                            Win32Error = ERROR_LOCK_FAILED;
                            DebugPrint((0, "No Lock found for %ws\n", pThisExtObj->szServiceName));
                        }
                    } else {
                        // library should be ready to use
                    }

                    // if this dll is trusted, then use the system
                    // defined test level, otherwise, test it
                    // thorourghly
                    bUseTimer = TRUE;   // default
                    if (!(lPerflibConfigFlags & PLCF_NO_DLL_TESTING)) {
                        if (pThisExtObj->dwFlags & PERF_EO_TRUSTED) {
                            lDllTestLevel = lExtCounterTestLevel;
                            bUseTimer = FALSE;   // Trusted DLL's are not timed
                        } else {
                            // not trusted so use full test
                            lDllTestLevel = EXT_TEST_ALL;
                        }
                    } else {
                        // disable DLL testing
                        lDllTestLevel = EXT_TEST_NOMEMALLOC;
                        bUseTimer = FALSE;   // Timing is disabled as well
                    }

                    if (lDllTestLevel < EXT_TEST_NOMEMALLOC) {
                        bUseSafeBuffer = TRUE;
                    } else {
                        bUseSafeBuffer = FALSE;
                    }

                    // allocate a local block of memory to pass to the
                    // extensible counter function.

                    if (bUseSafeBuffer) {
                        lpExtDataBuffer = ALLOCMEM (BytesLeft + (2*GUARD_PAGE_SIZE));
                    } else {
                        lpExtDataBuffer =
                            lpCallBuffer = *lppDataDefinition;
                    }

                    if (lpExtDataBuffer != NULL) {

                        if (bUseSafeBuffer) {
                            // set buffer pointers
                            lpLowGuardPage = lpExtDataBuffer;
                            lpCallBuffer = (LPBYTE)lpExtDataBuffer + GUARD_PAGE_SIZE;
                            lpHiGuardPage = (LPBYTE)lpCallBuffer + BytesLeft;
                            lpEndPointer = (LPBYTE)lpHiGuardPage + GUARD_PAGE_SIZE;

                            // initialize GuardPage Data

                            memset (lpLowGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
                            memset (lpHiGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
                        }

                        lpBufferBefore = lpCallBuffer;
                        lpBufferAfter = NULL;
                        hPerflibFuncTimer = NULL;

                        try {
                            //
                            //  Collect data from extensible objects
                            //

                            if (pThisExtObj->hMutex != NULL) {
                                NTSTATUS NtStatus = NtWaitForSingleObject (
                                    pThisExtObj->hMutex,
                                    FALSE,
                                    &liWaitTime);
                                Win32Error = PerfpDosError(NtStatus);
                                if ((NtStatus == STATUS_SUCCESS)  &&
                                    (pThisExtObj->CollectProc != NULL)) {

                                    bUnlockObjData = TRUE;

                                    opwInfo.pNext = NULL;
                                    opwInfo.szLibraryName = pThisExtObj->szLibraryName;
                                    opwInfo.szServiceName = pThisExtObj->szServiceName;
                                    opwInfo.dwWaitTime = pThisExtObj->dwCollectTimeout;
                                    opwInfo.dwEventMsg = PERFLIB_COLLECTION_HUNG;
                                    opwInfo.pData = (LPVOID)pThisExtObj;
                                    if (bUseTimer) {
                                        hPerflibFuncTimer = StartPerflibFunctionTimer(&opwInfo);
                                        // if no timer, continue anyway, even though things may
                                        // hang, it's better than not loading the DLL since they
                                        // usually load OK
                                        //
                                        if (hPerflibFuncTimer == NULL) {
                                            // unable to get a timer entry
                                            DebugPrint((0, "Unable to acquire timer for Collect Proc\n"));
                                        }
                                    } else {
                                        hPerflibFuncTimer = NULL;
                                    }

                                    InitialBytesLeft = BytesLeft;

                                    NtQueryPerformanceCounter (&liStartTime, NULL);

                                    Win32Error =  (*pThisExtObj->CollectProc) (
                                            lpValueName,
                                            &lpCallBuffer,
                                            &BytesLeft,
                                            &NumObjectTypes);

                                    NtQueryPerformanceCounter (&liEndTime, &liDiff);

                                    if (liDiff.QuadPart > 0) {
                                        liDiff.QuadPart = (liEndTime.QuadPart - liStartTime.QuadPart) /
                                                                (liDiff.QuadPart / 1000) ;
                                        if ((liDiff.QuadPart > 100) || (Win32Error != ERROR_SUCCESS)) {
                                            TRACE((WINPERF_DBG_TRACE_INFO),
                                                 (&PerflibGuid, __LINE__, PERF_QUERY_EXTDATA,
                                                 ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_ULONG64, 2), Win32Error, 
                                                 pThisExtObj->szServiceName, WSTRSIZE(pThisExtObj->szServiceName),
                                                 liDiff, sizeof(liDiff), NULL));
                                        }
                                    }

                                    if (hPerflibFuncTimer != NULL) {
                                        // kill timer
                                        KillPerflibFunctionTimer (hPerflibFuncTimer);
                                        hPerflibFuncTimer = NULL;
                                    }

                                    // update statistics

                                    pThisExtObj->dwLastBufferSize = BytesLeft;

                                    if (BytesLeft > pThisExtObj->dwMaxBufferSize) {
                                        pThisExtObj->dwMaxBufferSize = BytesLeft;
                                    }

                                    if ((Win32Error == ERROR_MORE_DATA) &&
                                        (InitialBytesLeft > pThisExtObj->dwMaxBufferRejected)) {
                                        pThisExtObj->dwMaxBufferRejected = InitialBytesLeft;
                                    }

                                    lpBufferAfter = lpCallBuffer;

                                    pThisExtObj->llLastUsedTime = GetTimeAsLongLong();

                                    ReleaseMutex (pThisExtObj->hMutex);
                                    bUnlockObjData = FALSE;
#if DBG
                                    if ( (((ULONG_PTR) lpCallBuffer) & 0x07) != 0) {
                                        DbgPrint("Perflib: Misaligned pointer %X returned from '%s'\n",
                                            lpCallBuffer, pThisExtObj->szLibraryName);
//                                        ASSERT( (((ULONG_PTR)lpCallBuffer) & 0x07) == 0);
                                    }
#endif
                                } else {
                                    if (pThisExtObj->CollectProc != NULL) {
                                        DebugPrint((0,
                                            "Unable to Lock object for %ws to Collect data\n",
                                            pThisExtObj->szServiceName));
                                        TRACE((WINPERF_DBG_TRACE_ERROR), (&PerflibGuid, __LINE__,
                                            PERF_QUERY_EXTDATA, ARG_TYPE_WSTR, Win32Error,
                                            pThisExtObj->szServiceName, WSTRSIZE(pThisExtObj->szServiceName),
                                            NULL));
                                        if (THROTTLE_PERFDLL(PERFLIB_COLLECTION_HUNG, pThisExtObj)) {
                                            dwDataIndex = wStringIndex = 0;
                                            dwRawDataDwords[dwDataIndex++] = BytesLeft;
                                            dwRawDataDwords[dwDataIndex++] =
                                                (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szServiceName;
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szLibraryName;
                                            ReportEvent (hEventLog,
                                                EVENTLOG_WARNING_TYPE,      // error type
                                                0,                          // category (not used)
                                                (DWORD)PERFLIB_COLLECTION_HUNG,   // event,
                                                NULL,                       // SID (not used),
                                                wStringIndex,              // number of strings
                                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                szMessageArray,                // message text array
                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                        }

                                        pThisExtObj->dwLockoutCount++;
                                    } else {
                                        // else it's not open so ignore.
                                        BytesLeft = 0;
                                        NumObjectTypes = 0;
                                    }
                                }
                            } else {
                                Win32Error = ERROR_LOCK_FAILED;
                                DebugPrint((0, "No Lock found for %ws\n", pThisExtObj->szServiceName));
                                TRACE((WINPERF_DBG_TRACE_ERROR), (&PerflibGuid, __LINE__,
                                    PERF_QUERY_EXTDATA, ARG_TYPE_WSTR, Win32Error,
                                    pThisExtObj->szServiceName, WSTRSIZE(pThisExtObj->szServiceName),
                                    NULL));
                            }

                            if ((Win32Error == ERROR_SUCCESS) && (BytesLeft > 0)) {
                                // increment perf counters
                                if (BytesLeft > InitialBytesLeft) {
                                    TRACE((WINPERF_DBG_TRACE_ERROR), (&PerflibGuid, __LINE__,
                                        PERF_QUERY_EXTDATA, ARG_TYPE_WSTR, Win32Error,
                                        pThisExtObj->szServiceName, WSTRSIZE(pThisExtObj->szServiceName),
                                        BytesLeft, sizeof(DWORD), InitialBytesLeft, sizeof(DWORD),
                                        NULL));
                                    if (THROTTLE_PERFDLL(PERFLIB_INVALID_SIZE_RETURNED, pThisExtObj)) {
                                        // memory error
                                        dwDataIndex = wStringIndex = 0;
                                        dwRawDataDwords[dwDataIndex++] = (ULONG_PTR)InitialBytesLeft;
                                        dwRawDataDwords[dwDataIndex++] = (ULONG_PTR)BytesLeft;
                                        szMessageArray[wStringIndex++] =
                                            pThisExtObj->szServiceName;
                                        szMessageArray[wStringIndex++] =
                                            pThisExtObj->szLibraryName;
                                        ReportEvent (hEventLog,
                                            EVENTLOG_ERROR_TYPE,      // error type
                                            0,                          // category (not used)
                                            (DWORD)PERFLIB_INVALID_SIZE_RETURNED,   // event,
                                            NULL,                       // SID (not used),
                                            wStringIndex,              // number of strings
                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                            szMessageArray,                // message text array
                                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                                    }

                                    // disable the dll unless:
                                    //      testing has been disabled.
                                    //      or this is a trusted DLL (which are never disabled)
                                    //  the event log message should be reported in any case since
                                    //  this is a serious error
                                    //
                                    if ((!(lPerflibConfigFlags & PLCF_NO_DLL_TESTING)) &&
                                        (!(pThisExtObj->dwFlags & PERF_EO_TRUSTED))) {
                                        DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                                    }
                                    // set error values to correct entries
                                    BytesLeft = 0;
                                    NumObjectTypes = 0;
                                } else {
                                    // the buffer seems ok so far, so validate it

                                    InterlockedIncrement ((LONG *)&pThisExtObj->dwCollectCount);
                                    pThisExtObj->llElapsedTime +=
                                        liEndTime.QuadPart - liStartTime.QuadPart;

                                    // test all returned buffers for correct alignment
                                    if ((((ULONG_PTR)BytesLeft & (ULONG_PTR)0x07)) &&
                                        !(lPerflibConfigFlags & PLCF_NO_ALIGN_ERRORS)) {
                                        if (((pThisExtObj->dwFlags & PERF_EO_ALIGN_ERR_POSTED) == 0) &&
                                            THROTTLE_PERFDLL(PERFLIB_BUFFER_ALIGNMENT_ERROR, pThisExtObj)) {
                                            dwDataIndex = wStringIndex = 0;
                                            dwRawDataDwords[dwDataIndex++] = (ULONG_PTR)lpCallBuffer;
                                            dwRawDataDwords[dwDataIndex++] = (ULONG_PTR)BytesLeft;
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szServiceName;
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szLibraryName;
                                            ReportEvent (hEventLog,
                                                EVENTLOG_WARNING_TYPE,      // error type
                                                0,                          // category (not used)
                                                (DWORD)PERFLIB_BUFFER_ALIGNMENT_ERROR,   // event,
                                                NULL,                       // SID (not used),
                                                wStringIndex,              // number of strings
                                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                szMessageArray,                // message text array
                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            pThisExtObj->dwFlags |= PERF_EO_ALIGN_ERR_POSTED;
                                        }
#ifdef _WIN64
                                        // try and fix up BytesLeft and lpCallBuffer
                                        BytesLeft = ExtpAlignBuffer(lpBufferBefore,
                                                        (PCHAR*) &lpCallBuffer, (InitialBytesLeft - BytesLeft));
                                        lpBufferAfter = lpCallBuffer;
#endif
                                    }

                                    if (bUseSafeBuffer) {
                                        // a data buffer was returned and
                                        // the function returned OK so see how things
                                        // turned out...
                                        //
                                        //
                                        // check for buffer corruption here
                                        //
                                        bBufferOK = TRUE; // assume it's ok until a check fails
                                        //
                                        if (lDllTestLevel <= EXT_TEST_BASIC) {
                                            DWORD BytesAvailable;
                                            //
                                            //  check 1: bytes left should be the same as
                                            //      new data buffer ptr - orig data buffer ptr
                                            //
                                            BytesAvailable = (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                            if (BytesLeft != BytesAvailable) {
                                                if (THROTTLE_PERFDLL(PERFLIB_BUFFER_POINTER_MISMATCH, pThisExtObj)) {
                                                    // issue WARNING, that bytes left param is incorrect
                                                    // load data for eventlog message
                                                    // this error is correctable
                                                    dwDataIndex = wStringIndex = 0;
                                                    dwRawDataDwords[dwDataIndex++] = BytesLeft;
                                                    dwRawDataDwords[dwDataIndex++] = BytesAvailable;
                                                    szMessageArray[wStringIndex++] =
                                                        pThisExtObj->szServiceName;
                                                    szMessageArray[wStringIndex++] =
                                                        pThisExtObj->szLibraryName;
                                                    ReportEvent (hEventLog,
                                                        EVENTLOG_WARNING_TYPE,      // error type
                                                        0,                          // category (not used)
                                                        (DWORD)PERFLIB_BUFFER_POINTER_MISMATCH,   // event,
                                                        NULL,                       // SID (not used),
                                                        wStringIndex,              // number of strings
                                                        dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                        szMessageArray,                // message text array
                                                        (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                }

                                                TRACE((WINPERF_DBG_TRACE_ERROR), (&PerflibGuid, __LINE__,
                                                    PERF_QUERY_EXTDATA, ARG_TYPE_WSTR, Win32Error,
                                                    pThisExtObj->szServiceName, WSTRSIZE(pThisExtObj->szServiceName),
                                                    BytesLeft, sizeof(DWORD), BytesAvailable, sizeof(DWORD),
                                                    NULL));
                                                // toss this buffer
                                                bBufferOK = FALSE;
                                                DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                                                // <<old code>>
                                                // we'll keep the buffer, since the returned bytes left
                                                // value is ignored anyway, in order to make the
                                                // rest of this function work, we'll fix it here
                                                // BytesLeft = (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                                // << end old code >>
                                            }
                                            //
                                            //  check 2: buffer after ptr should be < hi Guard page ptr
                                            //
                                            if (((LPBYTE)lpBufferAfter > (LPBYTE)lpHiGuardPage) && bBufferOK) {
                                                // see if they exceeded the allocated memory
                                                if ((LPBYTE)lpBufferAfter >= (LPBYTE)lpEndPointer) {
                                                    // this is very serious since they've probably trashed
                                                    // the heap by overwriting the heap sig. block
                                                    // issue ERROR, buffer overrun
                                                    if (THROTTLE_PERFDLL(PERFLIB_HEAP_ERROR, pThisExtObj)) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        dwRawDataDwords[dwDataIndex++] =
                                                            (ULONG_PTR)((LPBYTE)lpBufferAfter - (LPBYTE)lpHiGuardPage);
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_HEAP_ERROR,  // event,
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,               // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,             // message text array
                                                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                    }
                                                } else {
                                                    // issue ERROR, buffer overrun
                                                    if (THROTTLE_PERFDLL(PERFLIB_BUFFER_OVERFLOW, pThisExtObj)) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        dwRawDataDwords[dwDataIndex++] =
                                                            (ULONG_PTR)((LPBYTE)lpBufferAfter - (LPBYTE)lpHiGuardPage);
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_BUFFER_OVERFLOW,     // event,
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,              // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,                // message text array
                                                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                    }
                                                }
                                                bBufferOK = FALSE;
                                                DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                                                // since the DLL overran the buffer, the buffer
                                                // must be too small (no comments about the DLL
                                                // will be made here) so the status will be
                                                // changed to ERROR_MORE_DATA and the function
                                                // will return.
                                                Win32Error = ERROR_MORE_DATA;
                                            }
                                            //
                                            //  check 3: check lo guard page for corruption
                                            //
                                            if (bBufferOK) {
                                                bGuardPageOK = TRUE;
                                                for (lpCheckPointer = (PUCHAR)lpLowGuardPage;
                                                        lpCheckPointer < (PUCHAR)lpBufferBefore;
                                                    lpCheckPointer++) {
                                                    if (*lpCheckPointer != GUARD_PAGE_CHAR) {
                                                        bGuardPageOK = FALSE;
                                                            break;
                                                    }
                                                }
                                                if (!bGuardPageOK) {
                                                    // issue ERROR, Lo Guard Page corrupted
                                                    if (THROTTLE_PERFDLL(PERFLIB_GUARD_PAGE_VIOLATION, pThisExtObj)) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_GUARD_PAGE_VIOLATION, // event
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,              // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,                // message text array
                                                            (LPVOID)&dwRawDataDwords[0]);           // raw data


                                                    }
                                                    bBufferOK = FALSE;
                                                    DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                                                }
                                            }
                                            //
                                            //  check 4: check hi guard page for corruption
                                            //
                                            if (bBufferOK) {
                                                bGuardPageOK = TRUE;
                                                for (lpCheckPointer = (PUCHAR)lpHiGuardPage;
                                                    lpCheckPointer < (PUCHAR)lpEndPointer;
                                                    lpCheckPointer++) {
                                                        if (*lpCheckPointer != GUARD_PAGE_CHAR) {
                                                            bGuardPageOK = FALSE;
                                                        break;
                                                    }
                                                }
                                                if (!bGuardPageOK) {
                                                    // issue ERROR, Hi Guard Page corrupted
                                                    if (THROTTLE_PERFDLL(PERFLIB_GUARD_PAGE_VIOLATION, pThisExtObj)) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_GUARD_PAGE_VIOLATION, // event,
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,              // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,                // message text array
                                                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                    }

                                                    bBufferOK = FALSE;
                                                    DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                                                }
                                            }
                                            //
                                            if ((lDllTestLevel <= EXT_TEST_ALL) && bBufferOK) {
                                                //
                                                //  Internal consistency checks
                                                //
                                                //
                                                //  Check 5: Check object length field values
                                                //
                                                // first test to see if this is a foreign
                                                // computer data block or not
                                                //
                                                pPerfData = (PERF_DATA_BLOCK *)lpBufferBefore;
                                                if ((pPerfData->Signature[0] == (WCHAR)'P') &&
                                                    (pPerfData->Signature[1] == (WCHAR)'E') &&
                                                    (pPerfData->Signature[2] == (WCHAR)'R') &&
                                                    (pPerfData->Signature[3] == (WCHAR)'F')) {
                                                    // if this is a foreign computer data block, then the
                                                    // first object is after the header
                                                    pObject = (PERF_OBJECT_TYPE *) (
                                                        (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                                    bForeignDataBuffer = TRUE;
                                                } else {
                                                    // otherwise, if this is just a buffer from
                                                    // an extensible counter, the object starts
                                                    // at the beginning of the buffer
                                                    pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                                    bForeignDataBuffer = FALSE;
                                                }
                                                // go to where the pointers say the end of the
                                                // buffer is and then see if it's where it
                                                // should be
                                                dwObjectBufSize = 0;
                                                for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                                    dwObjectBufSize += pObject->TotalByteLength;
                                                    pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                        pObject->TotalByteLength);
                                                }
                                                if (((LPBYTE)pObject != (LPBYTE)lpCallBuffer) ||
                                                    (dwObjectBufSize > BytesLeft)) {
                                                    // then a length field is incorrect. This is FATAL
                                                    // since it can corrupt the rest of the buffer
                                                    // and render the buffer unusable.
                                                    if (THROTTLE_PERFDLL(
                                                            PERFLIB_INCORRECT_OBJECT_LENGTH,
                                                            pThisExtObj)) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        dwRawDataDwords[dwDataIndex++] = NumObjectTypes;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_INCORRECT_OBJECT_LENGTH, // event,
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,               // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,             // message text array
                                                            (LPVOID)&dwRawDataDwords[0]); // raw data
                                                    }
                                                    bBufferOK = FALSE;
                                                    DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                                                }
                                                //
                                                //  Test 6: Test Object definitions fields
                                                //
                                                if (bBufferOK) {
                                                    // set object pointer
                                                    if (bForeignDataBuffer) {
                                                        pObject = (PERF_OBJECT_TYPE *) (
                                                            (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                                    } else {
                                                        // otherwise, if this is just a buffer from
                                                        // an extensible counter, the object starts
                                                        // at the beginning of the buffer
                                                        pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                                    }

                                                    for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                                        pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                            pObject->DefinitionLength);

                                                        if (pObject->NumCounters != 0) {
                                                            pCounterDef = (PERF_COUNTER_DEFINITION *)
                                                                ((LPBYTE)pObject + pObject->HeaderLength);
                                                            lCtrIndex = 0;
                                                            while (lCtrIndex < pObject->NumCounters) {
                                                                if ((LPBYTE)pCounterDef < (LPBYTE)pNextObject) {
                                                                    // still ok so go to next counter
                                                                    pCounterDef = (PERF_COUNTER_DEFINITION *)
                                                                        ((LPBYTE)pCounterDef + pCounterDef->ByteLength);
                                                                    lCtrIndex++;
                                                                } else {
                                                                    bBufferOK = FALSE;
                                                                    break;
                                                                }
                                                            }
                                                            if ((LPBYTE)pCounterDef != (LPBYTE)pNextObject) {
                                                                bBufferOK = FALSE;
                                                            }
                                                        }

                                                        if (!bBufferOK) {
                                                            break;
                                                        } else {
                                                            pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                                pObject->TotalByteLength);
                                                        }
                                                    }

                                                    if (!bBufferOK) {
                                                        if (THROTTLE_PERFDLL(
                                                                PERFLIB_INVALID_DEFINITION_BLOCK,
                                                                pThisExtObj)) {
                                                            // load data for eventlog message
                                                            dwDataIndex = wStringIndex = 0;
                                                            dwRawDataDwords[dwDataIndex++] = pObject->ObjectNameTitleIndex;
                                                            szMessageArray[wStringIndex++] =
                                                                pThisExtObj->szLibraryName;
                                                            szMessageArray[wStringIndex++] =
                                                                pThisExtObj->szServiceName;
                                                            ReportEvent (hEventLog,
                                                                EVENTLOG_ERROR_TYPE,        // error type
                                                                0,                          // category (not used)
                                                                (DWORD)PERFLIB_INVALID_DEFINITION_BLOCK, // event,
                                                                NULL,                       // SID (not used),
                                                                wStringIndex,              // number of strings
                                                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                                szMessageArray,                // message text array
                                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                        }
                                                        DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                                                    }

                                                }
                                                //
                                                //  Test 7: Test instance field size values
                                                //
                                                if (bBufferOK) {
                                                    // set object pointer
                                                    if (bForeignDataBuffer) {
                                                        pObject = (PERF_OBJECT_TYPE *) (
                                                            (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                                    } else {
                                                        // otherwise, if this is just a buffer from
                                                        // an extensible counter, the object starts
                                                        // at the beginning of the buffer
                                                        pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                                    }

                                                    for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                                        pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                            pObject->TotalByteLength);

                                                        if (pObject->NumInstances != PERF_NO_INSTANCES) {
                                                            pInstance = (PERF_INSTANCE_DEFINITION *)
                                                                ((LPBYTE)pObject + pObject->DefinitionLength);
                                                            lInstIndex = 0;
                                                            while (lInstIndex < pObject->NumInstances) {
                                                                PERF_COUNTER_BLOCK *pCounterBlock;

                                                                pCounterBlock = (PERF_COUNTER_BLOCK *)
                                                                    ((PCHAR) pInstance + pInstance->ByteLength);

                                                                pInstance = (PERF_INSTANCE_DEFINITION *)
                                                                    ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);

                                                                lInstIndex++;
                                                            }
                                                            if ((LPBYTE)pInstance > (LPBYTE)pNextObject) {
                                                                bBufferOK = FALSE;
                                                            }
                                                        }

                                                        if (!bBufferOK) {
                                                            break;
                                                        } else {
                                                            pObject = pNextObject;
                                                        }
                                                    }

                                                    if (!bBufferOK) {
                                                        if (THROTTLE_PERFDLL(
                                                            PERFLIB_INCORRECT_INSTANCE_LENGTH,
                                                            pThisExtObj)) {
                                                            // load data for eventlog message
                                                            dwDataIndex = wStringIndex = 0;
                                                            dwRawDataDwords[dwDataIndex++] = pObject->ObjectNameTitleIndex;
                                                            szMessageArray[wStringIndex++] =
                                                                pThisExtObj->szLibraryName;
                                                            szMessageArray[wStringIndex++] =
                                                                pThisExtObj->szServiceName;
                                                            ReportEvent (hEventLog,
                                                                EVENTLOG_ERROR_TYPE,        // error type
                                                                0,                          // category (not used)
                                                                (DWORD)PERFLIB_INCORRECT_INSTANCE_LENGTH, // event,
                                                                NULL,                       // SID (not used),
                                                                wStringIndex,              // number of strings
                                                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                                szMessageArray,                // message text array
                                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                        }
                                                        DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                                                    }
                                                }
                                            }
                                        }
                                        //
                                        // if all the tests pass,then copy the data to the
                                        // original buffer and update the pointers
                                        if (bBufferOK) {
                                            RtlMoveMemory (*lppDataDefinition,
                                                lpBufferBefore,
                                                BytesLeft); // returned buffer size
                                        } else {
                                            NumObjectTypes = 0; // since this buffer was tossed
                                            BytesLeft = 0; // reset the size value since the buffer wasn't used
                                        }
                                    } else {
                                        // function already copied data to caller's buffer
                                        // so no further action is necessary
                                    }
                                    *lppDataDefinition = (LPVOID)((LPBYTE)(*lppDataDefinition) + BytesLeft);    // update data pointer
                                }
                            } else {
                                if (Win32Error != ERROR_SUCCESS) {
                                    InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                                }
                                if (bUnlockObjData) {
                                    ReleaseMutex (pThisExtObj->hMutex);
                                }

                                NumObjectTypes = 0; // clear counter
                            }// end if function returned successfully

                        } except (EXCEPTION_EXECUTE_HANDLER) {
                            Win32Error = GetExceptionCode();
                            InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                            bException = TRUE;

                            if (bUnlockObjData) {
                                ReleaseMutex (pThisExtObj->hMutex);
                                bUnlockObjData = FALSE;
                            }

                            if (hPerflibFuncTimer != NULL) {
                                // kill timer
                                KillPerflibFunctionTimer (hPerflibFuncTimer);
                                hPerflibFuncTimer = NULL;
                            }
                        }

                        if (bUseSafeBuffer) {
                            FREEMEM (lpExtDataBuffer);
                        }
                    } else {
                        // unable to allocate memory so set error value
                        Win32Error = ERROR_OUTOFMEMORY;
                    } // end if temp buffer allocated successfully
                    //
                    //  Update the count of the number of object types
                    //
                    ((PPERF_DATA_BLOCK) lpData)->NumObjectTypes += NumObjectTypes;

                    if ( Win32Error != ERROR_SUCCESS) {
                        if (bException ||
                            !((Win32Error == ERROR_MORE_DATA) ||
                              (Win32Error == WAIT_TIMEOUT))) {
                            // inform on exceptions & illegal error status only
                            if (THROTTLE_PERFDLL(PERFLIB_COLLECT_PROC_EXCEPTION, pThisExtObj)) {
                                // load data for eventlog message
                                dwDataIndex = wStringIndex = 0;
                                dwRawDataDwords[dwDataIndex++] = Win32Error;
                                szMessageArray[wStringIndex++] =
                                    pThisExtObj->szServiceName;
                                szMessageArray[wStringIndex++] =
                                    pThisExtObj->szLibraryName;
                                ReportEvent (hEventLog,
                                    EVENTLOG_ERROR_TYPE,        // error type
                                    0,                          // category (not used)
                                    (DWORD)PERFLIB_COLLECT_PROC_EXCEPTION,   // event,
                                    NULL,                       // SID (not used),
                                    wStringIndex,              // number of strings
                                    dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                    szMessageArray,                // message text array
                                    (LPVOID)&dwRawDataDwords[0]);           // raw data

                            } else {
                                if (bException) {
                                    DebugPrint((0, "Extensible Counter %d generated an exception code: 0x%8.8x (%dL)\n",
                                        NumObjectTypes, Win32Error, Win32Error));
                                } else {
                                    DebugPrint((0, "Extensible Counter %d returned error code: 0x%8.8x (%dL)\n",
                                        NumObjectTypes, Win32Error, Win32Error));
                                }
                            }
                            if (bException) {
                                DisablePerfLibrary(pThisExtObj, PERFLIB_DISABLE_ALL);
                            }
                        }
                        // the ext. dll is only supposed to return:
                        //  ERROR_SUCCESS even if it encountered a problem, OR
                        //  ERROR_MODE_DATA if the buffer was too small.
                        // if it's ERROR_MORE_DATA, then break and return the
                        // error now, since it'll just be returned again and again.
                        if (Win32Error == ERROR_MORE_DATA) {
                            lReturnValue = Win32Error;
                            break;
                        }
                    }

                    // update perf data in global section
                    if (pThisExtObj->pPerfSectionEntry != NULL) {
                        pThisExtObj->pPerfSectionEntry->llElapsedTime =
                            pThisExtObj->llElapsedTime;

                        pThisExtObj->pPerfSectionEntry->dwCollectCount =
                            pThisExtObj->dwCollectCount;

                        pThisExtObj->pPerfSectionEntry->dwOpenCount =
                            pThisExtObj->dwOpenCount;

                        pThisExtObj->pPerfSectionEntry->dwCloseCount =
                            pThisExtObj->dwCloseCount;

                        pThisExtObj->pPerfSectionEntry->dwLockoutCount =
                            pThisExtObj->dwLockoutCount;

                        pThisExtObj->pPerfSectionEntry->dwErrorCount =
                            pThisExtObj->dwErrorCount;

                        pThisExtObj->pPerfSectionEntry->dwLastBufferSize =
                            pThisExtObj->dwLastBufferSize;

                        pThisExtObj->pPerfSectionEntry->dwMaxBufferSize =
                            pThisExtObj->dwMaxBufferSize;

                        pThisExtObj->pPerfSectionEntry->dwMaxBufferRejected =
                            pThisExtObj->dwMaxBufferRejected;

                    } else {
                        // no data section was initialized so skip
                    }
                } // end if this object is to be called
            } // end for each object
        } // else an error occurred so unable to call functions
        Win32Error = DeRegisterExtObjListAccess();
    } // else unable to access ext object list

    HEAP_PROBE();

    if (bDisabled) lReturnValue = ERROR_SERVICE_DISABLED;
    return lReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\perflib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000-2001   Microsoft Corporation

Module Name:

    perflib.h

Abstract:

        Private functions and data structures used by perflib only

Author:

    JeePang  09/27/2000

Revision History:


--*/

#ifndef _PERFLIB_H_
#define _PERFLIB_H_
#define _WMI_SOURCE_
#include <wmistr.h>
#include <evntrace.h>

//
// Private registry function to prevent query within RegQueryValue
// This needs to preceed winperfp.h since it needs this function
//
LONG
PrivateRegQueryValueExT (
    HKEY    hKey,
    LPVOID  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    bUnicode
);

#define StartTraceW   EtwStartTraceW
#define QueryTraceW   EtwQueryTraceW
#define TraceEvent    EtwTraceEvent

extern 
ULONG
WMIAPI
EtwStartTraceW(
    OUT    PTRACEHANDLE            LoggerHandle,
    IN     LPCWSTR                 LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

extern
ULONG
WMIAPI
EtwQueryTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

extern
ULONG 
WMIAPI
EtwTraceEvent(
    IN TRACEHANDLE LoggerHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    );

#include <winperfp.h>

//
// Commonly used macros
//

#define HEAP_PROBE()    ;       // Not implemented

#define ALLOCMEM(size)     RtlAllocateHeap (RtlProcessHeap(), HEAP_ZERO_MEMORY, size)
#define REALLOCMEM(pointer, newsize) \
                                    RtlReAllocateHeap (RtlProcessHeap(), 0, pointer, newsize)
#define FREEMEM(pointer)   if ((pointer)) { RtlFreeHeap (RtlProcessHeap(), 0, pointer); }

#define MAX_KEY_NAME_LENGTH 256*sizeof(WCHAR)
#define MAX_VALUE_NAME_LENGTH 256*sizeof(WCHAR)
#define MAX_VALUE_DATA_LENGTH 256*sizeof(WCHAR)

//
// Use this constant to include "\\Performance" and terminator as well
// NOTE: This must be 8-byte multiple, which is 280 here
//
#define MAX_NAME_PATH MAX_VALUE_DATA_LENGTH + 11 * sizeof(WCHAR) + sizeof(UNICODE_NULL)

//  flag to determine the "noisiness" of the event logging
//  this value is read from the system registry when the extensible
//  objects are loaded and used for the subsequent calls.
//
//
//    Levels:  LOG_UNDEFINED = registry log level not read yet
//             LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging      (warnings & errors)
//             LOG_VERBOSE = Maximum Debugging    (informational, success,
//                              error and warning messages
//
#define  LOG_UNDEFINED  ((LONG)-1)
#define  LOG_NONE       0
#define  LOG_USER       1
#define  LOG_DEBUG      2
#define  LOG_VERBOSE    3

//
//  define configurable extensible counter buffer testing
//
//  Test Level      Event that will prevent data buffer
//                  from being returne in PerfDataBlock
//
//  EXT_TEST_NOMEMALLOC Collect Fn. writes directly to calling fn's buffer
//
//      all the following test levels have the collect fn. write to a
//      buffer allocated separately from the calling fn's buffer
//
//  EXT_TEST_NONE   Collect Fn. Returns bad status or generates exception
//  EXT_TEST_BASIC  Collect Fn. has buffer overflow or violates guard page
//  EXT_TEST_ALL    Collect Fn. object or instance lengths are not conistent
//
//
#define     EXT_TEST_UNDEFINED  0
#define     EXT_TEST_ALL        1
#define     EXT_TEST_BASIC      2
#define     EXT_TEST_NONE       3
#define     EXT_TEST_NOMEMALLOC 4

#define PERFLIB_DISABLE_NONE 0
#define PERFLIB_DISABLE_ALL  1
#define PERFLIB_DISABLE_X32  2
#define PERFLIB_DISABLE_IA64 4

//  Misc. configuration flags used by lPerflibConfigFlags
//
//      PLCF_NO_ALIGN_ERRORS        if set inhibit alignment error messages
//      PLCF_NO_DISABLE_DLLS        if set, auto disable of bad perf DLL's is inhibited
//      PLCF_NO_DLL_TESTING         disable all DLL testing for ALL dll's (overrides lExtCounterTestLevel)
//      PLCF_ENABLE_TIMEOUT_DISABLE if set then disable when timeout errors occur (unless PLCF_NO_DISABLE_DLLS is set)
//      PLCF_ENABLE_PERF_SECTION    enable the perflib performance data memory section
//
#define PLCF_NO_ALIGN_ERRORS        ((DWORD)0x00000001)
#define PLCF_NO_DISABLE_DLLS        ((DWORD)0x00000002)
#define PLCF_NO_DLL_TESTING         ((DWORD)0x00000004)
#define PLCF_ENABLE_TIMEOUT_DISABLE ((DWORD)0x00000008)
#define PLCF_ENABLE_PERF_SECTION    ((DWORD)0x00000010)

// #define     PLCF_DEFAULT    PLCF_ENABLE_PERF_SECTION
#define PLCF_DEFAULT        PLCF_NO_DLL_TESTING

#define COLL_FLAG_USE_SEPARATE_THREAD   1

#define CTD_AF_NO_ACTION        ((DWORD)0x00000000)
#define CTD_AF_CLOSE_THREAD     ((DWORD)0x00000001)
#define CTD_AF_OPEN_THREAD      ((DWORD)0x00000002)

//
// Constants & Flags used for EXT_OBJECT->dwFlags
//

// use query proc
#define PERF_EO_QUERY_FUNC          ((DWORD)0x00000001)
// true when DLL ret. error
#define PERF_EO_BAD_DLL             ((DWORD)0x00000002)
// true if lib should not be trimmed
#define PERF_EO_KEEP_RESIDENT       ((DWORD)0x00000004)
// true when in query list
#define PERF_EO_OBJ_IN_QUERY        ((DWORD)0x80000000)
// set if alignment error has been posted to event log
#define PERF_EO_ALIGN_ERR_POSTED    ((DWORD)0x00000008)
// set of the "Disable Performance Counters" value is set
#define PERF_EO_DISABLED            ((DWORD)0x00000010)
// set when the DLL is deemed trustworthy
#define PERF_EO_TRUSTED             ((DWORD)0x00000020)
// set when the DLL has been replaced with a new file
#define PERF_EO_NEW_FILE            ((DWORD)0x00000040)

typedef struct _DLL_VALIDATION_DATA {
    FILETIME    CreationDate;
    LONGLONG    FileSize;
} DLL_VALIDATION_DATA, *PDLL_VALIDATION_DATA;

#define EXT_OBJ_INFO_NAME_LENGTH    32

typedef struct _PERFDATA_SECTION_HEADER {
    DWORD       dwEntriesInUse;
    DWORD       dwMaxEntries;
    DWORD       dwMissingEntries;
    DWORD       dwInitSignature;
    BYTE        reserved[112];
} PERFDATA_SECTION_HEADER, *PPERFDATA_SECTION_HEADER;

#define PDSH_INIT_SIG   ((DWORD)0x01234567)

#define PDSR_SERVICE_NAME_LEN   32
typedef struct _PERFDATA_SECTION_RECORD {
    WCHAR       szServiceName[PDSR_SERVICE_NAME_LEN];
    LONGLONG    llElapsedTime;
    DWORD       dwCollectCount; // number of times Collect successfully called
    DWORD       dwOpenCount;    // number of Loads & opens
    DWORD       dwCloseCount;   // number of Unloads & closes
    DWORD       dwLockoutCount; // count of lock timeouts
    DWORD       dwErrorCount;   // count of errors (other than timeouts)
    DWORD       dwLastBufferSize; // size of the last buffer returned
    DWORD       dwMaxBufferSize; // size of MAX buffer returned
    DWORD       dwMaxBufferRejected; // size of largest buffer returned as too small
    BYTE        Reserved[24];     // reserved to make structure 128 bytes
} PERFDATA_SECTION_RECORD, *PPERFDATA_SECTION_RECORD;

//
// Default wait times for perf procs
//
#define CLOSE_WAIT_TIME     5000L   // wait time for query mutex (in ms)
#define QUERY_WAIT_TIME     2000L    // wait time for query mutex (in ms)
#define OPEN_PROC_WAIT_TIME 10000L  // default wait time for open proc to finish (in ms)

#define THROTTLE_PERFLIB(X)     PerfpThrottleError( (DWORD)(X), NULL, &PerfpErrorLog )
#define THROTTLE_PERFDLL(X,Y)   PerfpThrottleError((DWORD)(X), (Y)->hPerfKey, &(Y)->ErrorLog)

typedef struct _ERROR_LOG {
    LIST_ENTRY  Entry;
    ULONG       ErrorNumber;
    ULONG       ErrorCount;
    LONG64      LastTime;
} ERROR_LOG, *PERROR_LOG;

typedef struct _EXT_OBJECT {
        struct _EXT_OBJECT *pNext;   // pointer to next item in list
        HANDLE      hMutex;         // sync mutex for this function
        OPENPROC    OpenProc;       // address of the open routine
        LPSTR       szOpenProcName; // open procedure name
        LPWSTR      szLinkageString; // param for open proc
        COLLECTPROC CollectProc;    // address of the collect routine
        QUERYPROC   QueryProc;      // address of query proc
        LPSTR       szCollectProcName;  // collect procedure name
        DWORD       dwCollectTimeout;   // wait time in MS for collect proc
        DWORD       dwOpenTimeout;  // wait time in MS for open proc
        CLOSEPROC   CloseProc;     // address of the close routine
        LPSTR       szCloseProcName;    // close procedure name
        HANDLE      hLibrary ;     // handle returned by LoadLibraryW
        LPWSTR      szLibraryName;  // full path of library
        HKEY        hPerfKey;       // handle to performance sub key fo this service
        DWORD       dwNumObjects;  // number of supported objects
        DWORD       dwObjList[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];    // address of array of supported objects
        DWORD       dwFlags;        // flags
        DWORD       dwValidationLevel; // collect function validation/test level
        LPWSTR      szServiceName;  // service name
        LONGLONG    llLastUsedTime; // FILETIME of last access
        DLL_VALIDATION_DATA   LibData; // validation data
        FILETIME    ftLastGoodDllFileDate; // creation date of last successfully accessed DLL
// Performance statistics
        PPERFDATA_SECTION_RECORD      pPerfSectionEntry;  // pointer to entry in global section
        LONGLONG    llElapsedTime;  // time spent in call
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwLastBufferSize; // size of the last buffer returned
        DWORD       dwMaxBufferSize; // size of MAX buffer returned
        DWORD       dwMaxBufferRejected; // size of largest buffer returned as too small
        DWORD       dwErrorLimit;
        DWORD       dwOpenFail; // number of open failures
        ERROR_LOG   ErrorLog;
        DWORD       ThreadId;       // ThreadId of last failed caller
} EXT_OBJECT, *PEXT_OBJECT;

#define PERF_EOL_ITEM_FOUND ((DWORD)0x00000001)

typedef struct _COLLECT_THREAD_DATA {
    DWORD   dwQueryType;
    LPWSTR  lpValueName;
    LPBYTE  lpData;
    LPDWORD lpcbData;
    LPVOID  *lppDataDefinition;
    PEXT_OBJECT  pCurrentExtObject;
    LONG    lReturnValue;
    DWORD   dwActionFlags;
} COLLECT_THREAD_DATA, * PCOLLECT_THREAD_DATA;

// convert mS to relative time
#define MakeTimeOutValue(ms) ((LONGLONG)((LONG)(ms) * -10000L))

extern DWORD   dwThreadAndLibraryTimeout;
extern LONG    lEventLogLevel;
extern HANDLE  hEventLog;
extern LPVOID  lpPerflibSectionAddr;
extern DWORD    NumExtensibleObjects;
extern LONG    lExtCounterTestLevel;
extern PEXT_OBJECT  ExtensibleObjects;
extern HKEY    ghKeyPerflib;
extern HANDLE  hCollectThread;
extern DWORD   dwCollectionFlags;
extern DWORD   ComputerNameLength;
extern LPWSTR  pComputerName;
extern LONG    lPerflibConfigFlags;
extern HANDLE   hGlobalDataMutex;
extern HANDLE   hExtObjListIsNotInUse;
extern DWORD    dwExtObjListRefCount;
extern DWORD    dwErrorCount;

//
// Inline functions used by all
//

__inline
LONGLONG
GetTimeAsLongLong ()
/*++
    Returns time performance timer converted to ms.

-*/
{
    LARGE_INTEGER liCount, liFreq;
    LONGLONG        llReturn;

    if (NtQueryPerformanceCounter (&liCount, &liFreq) == STATUS_SUCCESS) {
        llReturn = liCount.QuadPart * 1000 / liFreq.QuadPart;
    } else {
        llReturn = 0;
    }
    return llReturn;
}

//
// From utils.h
//

#define LAST_BASE_INDEX 1847

// query types

#define QUERY_GLOBAL       1
#define QUERY_ITEMS        2
#define QUERY_FOREIGN      3
#define QUERY_COSTLY       4
#define QUERY_COUNTER      5
#define QUERY_HELP         6
#define QUERY_ADDCOUNTER   7
#define QUERY_ADDHELP      8

// structure for passing to extensible counter open procedure wait thread

typedef struct _OPEN_PROC_WAIT_INFO {
    struct _OPEN_PROC_WAIT_INFO *pNext;
    LPWSTR  szLibraryName;
    LPWSTR  szServiceName;
    DWORD   dwWaitTime;
    DWORD   dwEventMsg;
    LPVOID  pData;
} OPEN_PROC_WAIT_INFO, FAR * LPOPEN_PROC_WAIT_INFO;

#define PERFLIB_TIMING_THREAD_TIMEOUT  120000  // 2 min (in milliseconds)
// #define PERFLIB_TIMING_THREAD_TIMEOUT   30000  // 30 sec (for debugging)

extern const   WCHAR GLOBAL_STRING[];
extern const   WCHAR COSTLY_STRING[];

extern const   DWORD VALUE_NAME_LENGTH;
extern const   WCHAR DisablePerformanceCounters[];
//
// Registry settings/values supported by Perflib
//

extern const   WCHAR DLLValue[];
extern const   CHAR OpenValue[];
extern const   CHAR CloseValue[];
extern const   CHAR CollectValue[];
extern const   CHAR QueryValue[];
extern const   WCHAR ObjListValue[];
extern const   WCHAR LinkageKey[];
extern const   WCHAR ExportValue[];
extern const   WCHAR PerflibKey[];
extern const   WCHAR HKLMPerflibKey[];
extern const   WCHAR CounterValue[];
extern const   WCHAR HelpValue[];
extern const   WCHAR PerfSubKey[];
extern const   WCHAR ExtPath[];
extern const   WCHAR OpenTimeout[];
extern const   WCHAR CollectTimeout[];
extern const   WCHAR EventLogLevel[];
extern const   WCHAR ExtCounterTestLevel[];
extern const   WCHAR OpenProcedureWaitTime[];
extern const   WCHAR TotalInstanceName[];
extern const   WCHAR LibraryUnloadTime[];
extern const   WCHAR KeepResident[];
extern const   WCHAR NULL_STRING[];
extern const   WCHAR UseCollectionThread[];
extern const   WCHAR cszLibraryValidationData[];
extern const   WCHAR cszSuccessfulFileData[];
extern const   WCHAR cszPerflibFlags[];
extern const   WCHAR FirstCounter[];
extern const   WCHAR LastCounter[];
extern const   WCHAR FirstHelp[];
extern const   WCHAR LastHelp[];
extern const   WCHAR cszFailureCount[];
extern const   WCHAR cszFailureLimit[];

//
// From perfsec.h
//

//
//  Value to decide if process names should be collected from:
//      the SystemProcessInfo structure (fastest)
//          -- or --
//      the process's image file (slower, but shows Unicode filenames)
//
#define PNCM_NOT_DEFINED    ((LONG)-1)
#define PNCM_SYSTEM_INFO    0L
#define PNCM_MODULE_FILE    1L
//
//  Value to decide if the SE_PROFILE_SYSTEM_NAME priv should be checked
//
#define CPSR_NOT_DEFINED    ((LONG)-1)
#define CPSR_EVERYONE       0L
#define CPSR_CHECK_ENABLED  1L
#define CPSR_CHECK_PRIVS    1L

//
// Common functions
//
VOID
OpenExtensibleObjects(
    );

DWORD
OpenExtObjectLibrary (
    PEXT_OBJECT  pObj
);

DWORD
CloseExtObjectLibrary (
    PEXT_OBJECT  pObj,
    BOOL        bCloseNow
);

LONG
QueryExtensibleData (
    COLLECT_THREAD_DATA * pArgs
);

#ifdef _WIN64
DWORD
ExtpAlignBuffer(
    PCHAR lpLastBuffer,
    PCHAR *lpNextBuffer,
    DWORD lpBytesLeft
    );
#endif

//
// From perfname.c
//

NTSTATUS
PerfGetNames (
   DWORD    QueryType,
   PUNICODE_STRING lpValueName,
   LPBYTE   lpData,
   LPDWORD  lpcbData,
   LPDWORD  lpcbLen,
   LPWSTR   lpLangId
);

VOID
PerfGetLangId(
    WCHAR *FullLangId
    );

VOID
PerfGetPrimaryLangId(
    DWORD   dwLangId,
    WCHAR * PrimaryLangId
    );


//
// From utils.c
//

NTSTATUS
GetPerflibKeyValue (
    IN      LPCWSTR szItem,
    IN      DWORD   dwRegType,
    IN      DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    OUT     LPVOID  pReturnBuffer,
    IN      DWORD   dwDefaultSize,  // ... of pDefault in bytes
    IN      LPVOID  pDefault,
    IN OUT  PHKEY   pKey
);

BOOL
MatchString (
    IN LPCWSTR lpValueArg,
    IN LPCWSTR lpNameArg
);


DWORD
GetQueryType (
    IN LPWSTR lpValue
);

DWORD
GetNextNumberFromList (
    IN LPWSTR   szStartChar,
    IN LPWSTR   *szNextChar
);

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
);

BOOL
MonBuildPerfDataBlock(
    PERF_DATA_BLOCK *pBuffer,
    PVOID *pBufferNext,
    DWORD NumObjectTypes,
    DWORD DefaultObject
);

//
// Timer functions
//
HANDLE
StartPerflibFunctionTimer (
    IN  LPOPEN_PROC_WAIT_INFO pInfo
);

DWORD
KillPerflibFunctionTimer (
    IN  HANDLE  hPerflibTimer
);


DWORD
DestroyPerflibFunctionTimer (
);

LONG
GetPerfDllFileInfo (
    LPCWSTR             szFileName,
    PDLL_VALIDATION_DATA  pDllData
);

#define PrivateRegQueryValueExW(a,b,c,d,e,f)    \
        PrivateRegQueryValueExT(a,(LPVOID)b,c,d,e,f,TRUE)

#define PrivateRegQueryValueExA(a,b,c,d,e,f)    \
        PrivateRegQueryValueExT(a,(LPVOID)b,c,d,e,f,FALSE)

DWORD
PerfpDosError(
    IN NTSTATUS Status
    );

#ifdef DBG
VOID
PerfpDebug(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x) PerfpDebug x
#else
#define DebugPrint(x)
#endif // DBG

DWORD
DisablePerfLibrary (
    PEXT_OBJECT  pObj,
    DWORD        dwValue
);

DWORD
DisableLibrary(
    IN HKEY   hPerfKey,
    IN LPWSTR szServiceName,
    IN DWORD  dwValue
);

/*
DWORD
PerfCheckRegistry(
    IN HKEY hPerfKey,
    IN LPCWSTR szServiceName
    );
*/

extern RTL_CRITICAL_SECTION PerfpCritSect;
extern ERROR_LOG PerfpErrorLog;

VOID
PerfpDeleteErrorLogs(
    IN PERROR_LOG ErrorLog
    );

ULONG
PerfpThrottleError(
    IN DWORD ErrorNumber,
    IN HKEY hKey,
    IN PERROR_LOG ErrorLog
    );

//
// From perfsec.c
//

BOOL
TestClientForPriv (
    BOOL    *pbThread,
    LPTSTR  szPrivName
);

BOOL
TestClientForAccess (
    VOID
);

LONG
GetProcessNameColMeth (
    VOID
);

LONG
GetPerfDataAccess (
    VOID
);

#endif // _PERFLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\perflib.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1994   Microsoft Corporation

Module Name:

    perflib.c

Abstract:

    This file implements the Configuration Registry
    for the purposes of the Performance Monitor.


    This file contains the code which implements the Performance part
    of the Configuration Registry.

Author:

    Russ Blake  11/15/91

Revision History:

    04/20/91    -   russbl      -   Converted to lib in Registry
                                      from stand-alone .dll form.
    11/04/92    -   a-robw      -  added pagefile and image counter routines

    11/01/96    -   bobw        -  revamped to support dynamic loading and
                                    unloading of performance modules

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <winperf.h>
#include <rpc.h>
#include "regrpc.h"
#include "ntconreg.h"
#include "prflbmsg.h"   // event log messages
#include <initguid.h>
#include <guiddef.h>
#include <strsafe.h>
#define _INIT_WINPERFP_
#include "perflib.h"
#pragma warning (default:4306)

#define NUM_VALUES 2

//
//  performance gathering thead priority
//
#define DEFAULT_THREAD_PRIORITY     THREAD_BASE_PRIORITY_LOWRT
//
//  constants
//
const   WCHAR DLLValue[] = L"Library";
const   CHAR OpenValue[] = "Open";
const   CHAR CloseValue[] = "Close";
const   CHAR CollectValue[] = "Collect";
const   CHAR QueryValue[] = "Query";
const   WCHAR ObjListValue[] = L"Object List";
const   WCHAR LinkageKey[] = L"\\Linkage";
const   WCHAR ExportValue[] = L"Export";
const   WCHAR PerflibKey[] = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
const   WCHAR HKLMPerflibKey[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
const   WCHAR CounterValue[] = L"Counter";
const   WCHAR HelpValue[] = L"Help";
const   WCHAR PerfSubKey[] = L"\\Performance";
const   WCHAR ExtPath[] = L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services";
const   WCHAR OpenTimeout[] = L"Open Timeout";
const   WCHAR CollectTimeout[] = L"Collect Timeout";
const   WCHAR EventLogLevel[] = L"EventLogLevel";
const   WCHAR ExtCounterTestLevel[] = L"ExtCounterTestLevel";
const   WCHAR OpenProcedureWaitTime[] = L"OpenProcedureWaitTime";
const   WCHAR TotalInstanceName[] = L"TotalInstanceName";
const   WCHAR LibraryUnloadTime[] = L"Library Unload Time";
const   WCHAR KeepResident[] = L"Keep Library Resident";
const   WCHAR NULL_STRING[] = L"\0";    // pointer to null string
const   WCHAR UseCollectionThread[] = L"UseCollectionThread";
const   WCHAR cszLibraryValidationData[] = L"Library Validation Code";
const   WCHAR cszSuccessfulFileData[] = L"Successful File Date";
const   WCHAR cszPerflibFlags[] = L"Configuration Flags";
const   WCHAR FirstCounter[] = L"First Counter";
const   WCHAR LastCounter[] = L"Last Counter";
const   WCHAR FirstHelp[] = L"First Help";
const   WCHAR LastHelp[] = L"Last Help";
const   WCHAR cszFailureCount[] = L"Error Count";
const   WCHAR cszFailureLimit[] = L"Error Count Limit";
const   WCHAR cszBusy[] = L"Updating";

//
//  external variables defined in perfname.c
//
extern   WCHAR    DefaultLangId[];
WCHAR    NativeLangId[8] = L"\0";

//
//  Data collection thread variables
//
#define COLLECTION_WAIT_TIME        10000L  // 10 seconds to get all the data
HANDLE   hCollectThread = NULL;
#define COLLECT_THREAD_PROCESS_EVENT    0
#define COLLECT_THREAD_EXIT_EVENT       1
#define COLLECT_THREAD_LOOP_EVENT_COUNT 2

#define COLLECT_THREAD_DONE_EVENT       2
#define COLLECT_THREAD_EVENT_COUNT      3
HANDLE  hCollectEvents[COLLECT_THREAD_EVENT_COUNT];
BOOL    bThreadHung = FALSE;

DWORD CollectThreadFunction (LPVOID dwArg);

#define COLL_FLAG_USE_SEPARATE_THREAD   1
DWORD   dwCollectionFlags = 0;

//
//      Global variable Definitions
//
// event log handle for perflib generated errors
//
HANDLE  hEventLog = NULL;

//
//  used to count concurrent opens.
//
LONG NumberOfOpens = 0;

//
//  Synchronization objects for Multi-threaded access
//
HANDLE   hGlobalDataMutex = NULL; // sync for ctr object list

//
//  computer name cache buffers. Initialized in predefh.c
//

DWORD ComputerNameLength;
LPWSTR pComputerName = NULL;

//  The next pointer is used to point to an array of addresses of
//  Open/Collect/Close routines found by searching the Configuration Registry.

//                  object list head
PEXT_OBJECT ExtensibleObjects = NULL;
//
//                  count of active list users (threads)
DWORD       dwExtObjListRefCount = 0;
//
//                  event to indicate the object list is not in use
HANDLE      hExtObjListIsNotInUse = NULL;
//
//                  Number of Extensible Objects found during the "open" call
DWORD       NumExtensibleObjects = 0;
//
//  see if the perflib data is restricted to ADMIN's ONLY or just anyone
//
LONG    lCheckProfileSystemRight = CPSR_NOT_DEFINED;

//
//  flag to see if the ProfileSystemPerformance priv should be set.
//      if it is attempted and the caller does not have permission to use this priv.
//      it won't be set. This is only attempted once.
//
BOOL    bEnableProfileSystemPerfPriv = FALSE;

//
//  timeout value (in mS) for timing threads & libraries
//
DWORD   dwThreadAndLibraryTimeout = PERFLIB_TIMING_THREAD_TIMEOUT;

//      global key for access to HKLM\Software\....\Perflib
//
HKEY    ghKeyPerflib = NULL;

//
//      Error report frequency

DWORD   dwErrorFrequency = 1;

LONG    lEventLogLevel = LOG_USER;
LONG    lPerflibConfigFlags = PLCF_DEFAULT;
DWORD   dwErrorCount = 0;
ERROR_LOG PerfpErrorLog;

// performance data block entries
WCHAR   szPerflibSectionFile[MAX_PATH];
WCHAR   szPerflibSectionName[MAX_PATH];
WCHAR   szUpdatingServiceName[MAX_PATH];
HANDLE  hPerflibSectionFile = NULL;
HANDLE  hPerflibSectionMap = NULL;
LPVOID  lpPerflibSectionAddr = NULL;
BOOL    bPerflibOpen = FALSE;

DWORD   dwBoostPriority = 1;

#define     dwPerflibSectionMaxEntries  127L
const DWORD dwPerflibSectionSize = (sizeof(PERFDATA_SECTION_HEADER) + \
                                   (sizeof(PERFDATA_SECTION_RECORD) * dwPerflibSectionMaxEntries));

// forward function references

LONG
PerfEnumTextValue (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpValueName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData,
    OUT LPDWORD lpcbLen  OPTIONAL
    );

#if 0 // collection thread functions are not supported
DWORD
OpenCollectionThread (
)
{
    BOOL    bError = FALSE;
    DWORD   dwThreadID;

    assert (hCollectThread == NULL);

    // if it's already created, then just return
    if (hCollectThread != NULL) return ERROR_SUCCESS;

    bThreadHung = FALSE;
    hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] = CreateEvent (
        NULL,  // default security
        FALSE, // auto reset
        FALSE, // non-signaled
        NULL); // no name
    bError = hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] == NULL;
    assert (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] != NULL);

    hCollectEvents[COLLECT_THREAD_EXIT_EVENT] = CreateEvent (
        NULL,  // default security
        FALSE, // auto reset
        FALSE, // non-signaled
        NULL); // no name
    bError = (hCollectEvents[COLLECT_THREAD_EXIT_EVENT] == NULL) | bError;
    assert (hCollectEvents[COLLECT_THREAD_EXIT_EVENT] != NULL);

    hCollectEvents[COLLECT_THREAD_DONE_EVENT] = CreateEvent (
        NULL,  // default security
        FALSE, // auto reset
        FALSE, // non-signaled
        NULL); // no name
    bError = (hCollectEvents[COLLECT_THREAD_DONE_EVENT] == NULL) | bError;
    assert (hCollectEvents[COLLECT_THREAD_DONE_EVENT] != NULL);

    if (!bError) {
        // create data collection thread
        hCollectThread = CreateThread (
            NULL,   // default security
            0,      // default stack size
            (LPTHREAD_START_ROUTINE)CollectThreadFunction,
            NULL,   // no argument
            0,      // no flags
            &dwThreadID);  // we don't need the ID so it's in an automatic variable

        if (hCollectThread == NULL) {
            bError = TRUE;
        }

        assert (hCollectThread != NULL);
    }

    if (bError) {
        if (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] != NULL) {
            CloseHandle (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT]);
            hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] = NULL;
        }
        if (hCollectEvents[COLLECT_THREAD_EXIT_EVENT] != NULL) {
            CloseHandle (hCollectEvents[COLLECT_THREAD_EXIT_EVENT]);
            hCollectEvents[COLLECT_THREAD_EXIT_EVENT] = NULL;
        }
        if (hCollectEvents[COLLECT_THREAD_DONE_EVENT] != NULL) {
            CloseHandle (hCollectEvents[COLLECT_THREAD_DONE_EVENT] = NULL);
            hCollectEvents[COLLECT_THREAD_DONE_EVENT] = NULL;
        }

        if (hCollectThread != NULL) {
            CloseHandle (hCollectThread);
            hCollectThread = NULL;
        }

        return (GetLastError());
    } else {
        return ERROR_SUCCESS;
    }
}


DWORD
CloseCollectionThread (
)
{
    if (hCollectThread != NULL) {
        // close the data collection thread
        if (bThreadHung) {
            // then kill it the hard way
            // this might cause problems, but it's better than
            // a thread leak
            TerminateThread (hCollectThread, ERROR_TIMEOUT);
        } else {
            // then ask it to leave
            SetEvent (hCollectEvents[COLLECT_THREAD_EXIT_EVENT]);
        }
        // wait for thread to leave
        WaitForSingleObject (hCollectThread, COLLECTION_WAIT_TIME);

        // close the handles and clear the variables
        CloseHandle (hCollectThread);
        hCollectThread = NULL;

        CloseHandle (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT]);
        hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] = NULL;

        CloseHandle (hCollectEvents[COLLECT_THREAD_EXIT_EVENT]);
        hCollectEvents[COLLECT_THREAD_EXIT_EVENT] = NULL;

        CloseHandle (hCollectEvents[COLLECT_THREAD_DONE_EVENT]);
        hCollectEvents[COLLECT_THREAD_DONE_EVENT] = NULL;
    } else {
        // nothing was opened
    }
    return ERROR_SUCCESS;
}
#endif

DWORD
PerfOpenKey (
    IN HKEY hKey
)
{

    LARGE_INTEGER       liPerfDataWaitTime;
    PLARGE_INTEGER      pTimeout;

    NTSTATUS status = STATUS_SUCCESS;
    DWORD   dwFnStatus = ERROR_SUCCESS;     // status code to be returned
    DWORD   dwError = ERROR_SUCCESS;

    DWORD   dwType, dwSize, dwValue;
    HANDLE  hDataMutex;
    OSVERSIONINFOEXW OsVersion;

    if (hGlobalDataMutex == NULL) {
        hDataMutex = CreateMutex(NULL, FALSE, NULL);
        if (hDataMutex == NULL) {
            DebugPrint((0, "Perf Data Mutex Not Initialized\n"));
            goto OPD_Error_Exit_NoSemaphore;
        }
        if (InterlockedCompareExchangePointer(
                &hGlobalDataMutex,
                hDataMutex,
                NULL) != NULL) {
            CloseHandle(hDataMutex);    // mutex just got created by another thread
            hDataMutex = NULL;
        }
    }
    if ((dwThreadAndLibraryTimeout == 0) ||
        (dwThreadAndLibraryTimeout == INFINITE)) {
        pTimeout = NULL;
    }
    else {
        liPerfDataWaitTime.QuadPart = MakeTimeOutValue(dwThreadAndLibraryTimeout);
        pTimeout = &liPerfDataWaitTime;
    }

    status = NtWaitForSingleObject (
        hGlobalDataMutex, // Mutex
        FALSE,          // not alertable
        pTimeout);   // wait time

    if (status != STATUS_SUCCESS) {
        // unable to contine, return error;
        dwFnStatus = PerfpDosError(status);
        DebugPrint((0, "Status=%X in waiting for global mutex",
                status));
        goto OPD_Error_Exit_NoSemaphore;
    }

    // if here, then the data semaphore has been acquired by this thread

    if (InterlockedIncrement(& NumberOfOpens) == 1) {
        if (ghKeyPerflib == NULL) {
            HKEY lhKeyPerflib = NULL;
            dwFnStatus = (DWORD) RegOpenKeyExW(HKEY_LOCAL_MACHINE, HKLMPerflibKey, 0L, KEY_READ, & lhKeyPerflib);
            if (dwFnStatus != ERROR_SUCCESS) {
                DebugPrint((0, "Error=%d in RegOpenKeyExW call (%d)",
                        dwFnStatus, __LINE__));
                goto OPD_Error_Exit_NoSemaphore;
            }
            else {
                if (InterlockedCompareExchangePointer(& ghKeyPerflib, lhKeyPerflib, NULL) != NULL) {
                    RegCloseKey(lhKeyPerflib);
                    lhKeyPerflib = NULL;
                }
            }
        }

        assert (ghKeyPerflib != NULL);

        // check if we are in the middle of Lodctr/unlodctr. If so, don't open the performance data stuff.
        //
        dwSize     = MAX_PATH * sizeof(WCHAR);
        dwType     = 0;
        ZeroMemory(szUpdatingServiceName, dwSize);
        dwFnStatus = PrivateRegQueryValueExW(ghKeyPerflib,
                                             cszBusy,
                                             NULL,
                                             & dwType,
                                             (LPBYTE) szUpdatingServiceName,
                                             & dwSize);
        if (dwFnStatus == ERROR_SUCCESS) {
            // someone is running lodctr/unlodctr, bail out now.
            //
            InterlockedDecrement(& NumberOfOpens);
            if (hGlobalDataMutex != NULL) {
                ReleaseMutex(hGlobalDataMutex);
            }
            dwFnStatus = ERROR_SUCCESS;
            goto OPD_Error_Exit_NoSemaphore;
        }

        dwSize = sizeof(dwValue);
        dwValue = dwType = 0;
        dwFnStatus = PrivateRegQueryValueExW (
            ghKeyPerflib,
            DisablePerformanceCounters,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);

        if ((dwFnStatus == ERROR_SUCCESS) &&
            (dwType == REG_DWORD) &&
            (dwValue == 1)) {
            // then DON'T Load any libraries and unload any that have been
            // loaded
            InterlockedDecrement(&NumberOfOpens);    // since it didn't open.
            dwFnStatus = ERROR_SERVICE_DISABLED;
        } else {
            dwFnStatus = ERROR_SUCCESS;
            ComputerNameLength = 0;
            GetComputerNameW(pComputerName, &ComputerNameLength);
            ComputerNameLength++;  // account for the NULL terminator

            pComputerName = ALLOCMEM(ComputerNameLength * sizeof(WCHAR));
            if (pComputerName == NULL) {
                ComputerNameLength = 0;
            }
            else {
                if ( !GetComputerNameW(pComputerName, &ComputerNameLength) ) {
                //
                // Signal failure to data collection routine
                //

                    ComputerNameLength = 0;
                } else {
                    pComputerName[ComputerNameLength] = UNICODE_NULL;
                    ComputerNameLength = (ComputerNameLength+1) * sizeof(WCHAR);
                }
            }

            WinPerfStartTrace(ghKeyPerflib);

            // create event and indicate the list is busy
            hExtObjListIsNotInUse = CreateEvent (NULL, TRUE, FALSE, NULL);

            // read collection thread flag
            dwType = 0;
            dwSize = sizeof(DWORD);
            dwError = PrivateRegQueryValueExW (ghKeyPerflib,
                            cszPerflibFlags,
                            NULL,
                            &dwType,
                            (LPBYTE)&lPerflibConfigFlags,
                            &dwSize);

            if ((dwError == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                // then keep it
            } else {
                // apply default value
                lPerflibConfigFlags = PLCF_DEFAULT;
            }

            //
            // Create global section for perf data on perflibs
            // NOTE: This is optional only
            //
            if ((hPerflibSectionFile == NULL) && (lPerflibConfigFlags & PLCF_ENABLE_PERF_SECTION)) {
                PPERFDATA_SECTION_HEADER pHead;
                WCHAR   szPID[32];
                HRESULT hErr;
                size_t nDestSize, nCharsLeft;
                PWCHAR  szSectionName, szTail;

                dwError = ERROR_SUCCESS;
                // create section name
                nDestSize = MAX_PATH;
                _ultow ((ULONG)GetCurrentProcessId(), szPID, 16);

                // create filename
                szSectionName = &szPerflibSectionName[0];
                hErr = StringCchCopyExW(szSectionName, nDestSize,
                            (LPCWSTR)L"%TEMP%\\Perflib_Perfdata_",
                            &szTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
                if (SUCCEEDED(hErr)) {
                    szSectionName = szTail;
                    nDestSize = nCharsLeft;
                    hErr = StringCchCopyExW(szSectionName, nDestSize, 
                                szPID, &szTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);

                }
                if (SUCCEEDED(hErr)) {
                    szSectionName = szTail;
                    nDestSize = nCharsLeft;
                    hErr = StringCchCopyExW(szSectionName, nDestSize, (LPCWSTR)L".dat",
                                &szTail, &nCharsLeft, STRSAFE_NULL_ON_FAILURE);
                }
                if (SUCCEEDED(hErr)) {
                    nDestSize = ExpandEnvironmentStrings
                                    (szPerflibSectionName, szPerflibSectionFile, MAX_PATH);
                    if ((nDestSize == 0) || (nDestSize > MAX_PATH)) {
                        dwError = ERROR_MORE_DATA;
                    }
                }
                else {
                    dwError = ERROR_MORE_DATA;
                }

                if (dwError == ERROR_SUCCESS) {
                    hPerflibSectionFile = CreateFile (szPerflibSectionFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_TEMPORARY,
                        NULL);
                }

                if ((hPerflibSectionFile != INVALID_HANDLE_VALUE) &&
                    (hPerflibSectionFile != NULL)) {
                    // create file mapping object
                    hPerflibSectionMap = CreateFileMapping (
                        hPerflibSectionFile,
                        NULL,
                        PAGE_READWRITE,
                        0, dwPerflibSectionSize,
                        szPerflibSectionName);

                    if (hPerflibSectionMap != NULL) {
                        // map view of file
                        lpPerflibSectionAddr = MapViewOfFile (
                            hPerflibSectionMap,
                            FILE_MAP_WRITE,
                            0,0, dwPerflibSectionSize);
                        if (lpPerflibSectionAddr != NULL) {
                            // init section if not already
                            pHead = (PPERFDATA_SECTION_HEADER)lpPerflibSectionAddr;
                            if (pHead->dwInitSignature != PDSH_INIT_SIG) {
                                // then init
                                // clear file to 0
                                memset (pHead, 0, dwPerflibSectionSize);
                                pHead->dwEntriesInUse = 0;
                                pHead->dwMaxEntries = dwPerflibSectionMaxEntries;
                                pHead->dwMissingEntries = 0;
                                pHead->dwInitSignature = PDSH_INIT_SIG;
                            } else {
                                // already initialized so leave it
                            }
                        } else {
                            // unable to map file so close
                            TRACE((WINPERF_DBG_TRACE_WARNING),
                                  (&PerflibGuid, __LINE__, PERF_OPEN_KEY, 0, 0, NULL));
                            CloseHandle (hPerflibSectionMap);
                            hPerflibSectionMap = NULL;
                            CloseHandle (hPerflibSectionFile);
                            hPerflibSectionFile = NULL;
                        }
                    } else {
                        // unable to create file mapping so close file
                        TRACE((WINPERF_DBG_TRACE_WARNING),
                              (&PerflibGuid, __LINE__, PERF_OPEN_KEY, 0, 0, NULL));
                        CloseHandle (hPerflibSectionFile);
                        hPerflibSectionFile = NULL;
                    }
                } else {
                    // unable to open file so no perf stats available
                    TRACE((WINPERF_DBG_TRACE_WARNING),
                          (&PerflibGuid, __LINE__, PERF_OPEN_KEY, 0, 0, NULL));
                    hPerflibSectionFile = NULL;
                }
            }

            // find and open perf counters
            OpenExtensibleObjects();
            bPerflibOpen = TRUE;

            dwExtObjListRefCount = 0;
            SetEvent (hExtObjListIsNotInUse); // indicate the list is not busy

            // read collection thread flag
            dwType = 0;
            dwSize = sizeof(DWORD);
            dwError = PrivateRegQueryValueExW (ghKeyPerflib,
                            UseCollectionThread,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwCollectionFlags,
                            &dwSize);
            if ((dwError == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                // validate the answer
                switch (dwCollectionFlags) {
                    case 0:
                        // this is a valid value
                        break;

                    case COLL_FLAG_USE_SEPARATE_THREAD:
                        // this feature is not supported so skip through
                    default:
                        // this is for invalid values
                        dwCollectionFlags = 0;
                        // dwCollectionFlags = COLL_FLAG_USE_SEPARATE_THREAD;
                        break;
                }
            }

            if (dwError != ERROR_SUCCESS) {
                dwCollectionFlags = 0;
                // dwCollectionFlags = COLL_FLAG_USE_SEPARATE_THREAD;
            }

            if (dwCollectionFlags == COLL_FLAG_USE_SEPARATE_THREAD) {
                // create data collection thread
                // a seperate thread is required for COM/OLE compatibity as some
                // client threads may be COM initialized incorrectly for the
                // extensible counter DLL's that may be called
//                status = OpenCollectionThread ();
            } else {
                hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] = NULL;
                hCollectEvents[COLLECT_THREAD_EXIT_EVENT] = NULL;
                hCollectEvents[COLLECT_THREAD_DONE_EVENT] = NULL;
                hCollectThread = NULL;
            }
            dwError = ERROR_SUCCESS;
        }
        RtlZeroMemory(&OsVersion, sizeof(OsVersion));
        OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);
        status = RtlGetVersion((POSVERSIONINFOW) &OsVersion);
        if (NT_SUCCESS(status)) {
            if (OsVersion.wProductType == VER_NT_WORKSTATION) {
                dwBoostPriority = 0;
            }
        }
    }
    if ((hKey != HKEY_PERFORMANCE_DATA) && (dwFnStatus != ERROR_SERVICE_DISABLED)) {
        InterlockedDecrement(&NumberOfOpens);
    }
//    KdPrint(("PERFLIB: [Open]  Pid: %d, Number Of PerflibHandles: %d\n",
//            GetCurrentProcessId(), NumberOfOpens));

    if (hGlobalDataMutex != NULL) ReleaseMutex (hGlobalDataMutex);

OPD_Error_Exit_NoSemaphore:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_OPEN_KEY, 0, status,
           &NumberOfOpens, sizeof(NumberOfOpens), NULL));
    return dwFnStatus;
}


LONG
PerfRegQueryValue (
    IN HKEY hKey,
    IN PUNICODE_STRING lpValueName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE  lpData,
    OUT LPDWORD lpcbData,
    OUT LPDWORD lpcbLen  OPTIONAL
    )
/*++

    PerfRegQueryValue -   Get data

        Inputs:

            hKey            -   Predefined handle to open remote
                                machine

            lpValueName     -   Name of the value to be returned;
                                could be "ForeignComputer:<computername>
                                or perhaps some other objects, separated
                                by ~; must be Unicode string

            lpReserved      -   should be omitted (NULL)

            lpType          -   should be omitted (NULL)

            lpData          -   pointer to a buffer to receive the
                                performance data

            lpcbData        -   pointer to a variable containing the
                                size in bytes of the output buffer;
                                on output, will receive the number
                                of bytes actually returned

            lpcbLen         -   Return the number of bytes to transmit to
                                the client (used by RPC) (optional).

         Return Value:

            DOS error code indicating status of call or
            ERROR_SUCCESS if all ok

--*/
{
    DWORD  dwQueryType;         //  type of request
    DWORD  TotalLen;            //  Length of the total return block
    DWORD  Win32Error;          //  Failure code
    DWORD  lFnStatus = ERROR_SUCCESS;   // Win32 status to return to caller
    DWORD  dwcbData = 0;        // Content of *lpcbData
    DWORD  dwcbLen = 0;         // Content of *lpcbLen
    LPVOID pDataDefinition;     //  Pointer to next object definition
    UNICODE_STRING  usLocalValue = {0,0, NULL};

    PERF_DATA_BLOCK *pPerfDataBlock = (PERF_DATA_BLOCK *)lpData;

    LARGE_INTEGER   liQueryWaitTime ;
    THREAD_BASIC_INFORMATION    tbiData;

    LONG   lOldPriority, lNewPriority;

    NTSTATUS status = STATUS_SUCCESS;

    LPWSTR  lpLangId = NULL;

    DBG_UNREFERENCED_PARAMETER(lpReserved);

    HEAP_PROBE();

    
    lOldPriority = lNewPriority = -1;
    // make a local copy of the value string if the arg references
    // the static buffer since it can be overwritten by
    // some of the RegistryEventSource call made by this routine

    pDataDefinition = NULL;
    if (lpValueName != NULL) {
        if (lpValueName->Buffer == NULL) {
            lFnStatus = ERROR_INVALID_PARAMETER;
            goto PRQV_ErrorExit1;
        }
        if (lpValueName == &NtCurrentTeb( )->StaticUnicodeString) {
            if (RtlCreateUnicodeString (
                &usLocalValue, lpValueName->Buffer)) {
                lFnStatus = ERROR_SUCCESS;
            } else {
                // unable to create string
                lFnStatus = ERROR_INVALID_PARAMETER;
            }
        } else {
            // copy the arg to the local structure
            try {
                memcpy (&usLocalValue, lpValueName, sizeof(UNICODE_STRING));
            } except (EXCEPTION_EXECUTE_HANDLER) {
                lFnStatus = GetExceptionCode();
            }
        }
    }
    else {
        lFnStatus = ERROR_INVALID_PARAMETER;
        goto PRQV_ErrorExit1;
    }

    if (lFnStatus != ERROR_SUCCESS) {
        goto PRQV_ErrorExit1;
    }

    if (hGlobalDataMutex == NULL || bPerflibOpen == FALSE) {
        // if a Mutex was not allocated then the key needs to be opened.
        // Without synchronization, it's too easy for threads to get
        // tangled up
        lFnStatus = PerfOpenKey(hKey);

        if (lFnStatus == ERROR_SUCCESS) {
            if (!TestClientForAccess ()) {
                if (THROTTLE_PERFLIB(PERFLIB_ACCESS_DENIED)) {

                    LPTSTR  szMessageArray[2];
                    TCHAR   szUserName[128];
                    TCHAR   szModuleName[MAX_PATH];
                    DWORD   dwUserNameLength;

                    dwUserNameLength = sizeof(szUserName)/sizeof(TCHAR);
                    if (!GetUserName (szUserName, &dwUserNameLength)) {
                        szUserName[0] = 0;
                    }
                    if (!GetModuleFileName (NULL, szModuleName,
                            sizeof(szModuleName)/sizeof(TCHAR))) {
                        szModuleName[0] = 0;
                    }

                    szMessageArray[0] = szUserName;
                    szMessageArray[1] = szModuleName;

                    ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,        // error type
                        0,                          // category (not used)
                        (DWORD)PERFLIB_ACCESS_DENIED, // event,
                        NULL,                       // SID (not used),
                        2,                          // number of strings
                        0,                          // sizeof raw data
                        szMessageArray,             // message text array
                        NULL);                      // raw data
                }
                lFnStatus = ERROR_ACCESS_DENIED;
                TRACE((WINPERF_DBG_TRACE_FATAL),
                      (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, lFnStatus, NULL));
            }
        }
    }

    if (lFnStatus != ERROR_SUCCESS) {
        // goto the exit point
        goto PRQV_ErrorExit1;
    }
    if (dwBoostPriority != 0) {
        status = NtQueryInformationThread (
                    NtCurrentThread(),
                    ThreadBasicInformation,
                    &tbiData,
                    sizeof(tbiData),
                    NULL);

        if (NT_SUCCESS(status)) {
            lOldPriority = tbiData.Priority;
        } else {
            TRACE((WINPERF_DBG_TRACE_WARNING),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0,
                  status, NULL));
            lOldPriority = -1;
        }

        lNewPriority = DEFAULT_THREAD_PRIORITY; // perfmon's favorite priority

        //
        //  Only RAISE the priority here. Don't lower it if it's high
        //

        if ((lOldPriority > 0) && (lOldPriority < lNewPriority)) {

            status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadPriority,
                        &lNewPriority,
                        sizeof(lNewPriority)
                        );
            if (!NT_SUCCESS(status)) {
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0,
                      status, NULL));
                lOldPriority = -1;
            }

        } else {
            lOldPriority = -1;  // to save resetting at the end
        }
    }

    //
    // Set the length parameter to zero so that in case of an error,
    // nothing will be transmitted back to the client and the client won't
    // attempt to unmarshall anything.
    //

    dwcbData = 0;
    dwcbLen = 0;
    try {
        if( ARGUMENT_PRESENT( lpcbLen )) {
            *lpcbLen = 0;
        }
        if( lpcbData != NULL ) {
            dwcbData = *lpcbData;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        lFnStatus = Win32Error = GetExceptionCode();
    }

    // if here, then assume the caller has the necessary access

    /*
        determine query type, can be one of the following
            Global
                get all objects
            List
                get objects in list (usLocalValue)

            Foreign Computer
                call extensible Counter Routine only

            Costly
                costly object items

            Counter
                get counter names for the specified language Id

            Help
                get help names for the specified language Id

    */
    dwQueryType = GetQueryType (usLocalValue.Buffer);
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, dwQueryType, NULL));

    if (dwQueryType == QUERY_COUNTER || dwQueryType == QUERY_HELP ||
        dwQueryType == QUERY_ADDCOUNTER || dwQueryType == QUERY_ADDHELP ) {

        liQueryWaitTime.QuadPart = MakeTimeOutValue(QUERY_WAIT_TIME);

        status = NtWaitForSingleObject (
            hGlobalDataMutex, // semaphore
            FALSE,          // not alertable
            &liQueryWaitTime);          // wait 'til timeout

        if (status != STATUS_SUCCESS) {
            lFnStatus = ERROR_BUSY;
            Win32Error = ERROR_BUSY;
            TotalLen = dwcbData;
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
        } else {

            try {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
                if (hKey == HKEY_PERFORMANCE_DATA) {
                    lpLangId = NULL;
                } else if (hKey == HKEY_PERFORMANCE_TEXT) {
                    lpLangId = DefaultLangId;
                } else if (hKey == HKEY_PERFORMANCE_NLSTEXT) {
                    RtlZeroMemory(NativeLangId, 8 * sizeof(WCHAR));
                    lpLangId = &NativeLangId[0];
                    PerfGetLangId(NativeLangId);
                }

                status = PerfGetNames (
                    dwQueryType,
                    &usLocalValue,
                    lpData,
                    lpcbData,
                    lpcbLen,
                    lpLangId);

                TRACE((WINPERF_DBG_TRACE_INFO),
                    (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status,
                    &hKey, sizeof(hKey), NULL));

                if (! NT_SUCCESS(status) && (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
                    // Sublanguage doesn't exist, so try the real one
                    //
                    TRACE((WINPERF_DBG_TRACE_WARNING),
                          (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
                    RtlZeroMemory(NativeLangId, 8 * sizeof(WCHAR));
                    PerfGetPrimaryLangId(GetUserDefaultUILanguage(), NativeLangId);

                    if (lpcbData != NULL) * lpcbData = dwcbData;
                    if (lpcbLen  != NULL) * lpcbLen  = dwcbLen;

                    status = PerfGetNames (
                                dwQueryType,
                                &usLocalValue,
                                lpData,
                                lpcbData,
                                lpcbLen,
                                lpLangId);
                }

                if (!NT_SUCCESS(status)) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
                    // convert error to win32 for return
                }
                lFnStatus = PerfpDosError(status);

                if (ARGUMENT_PRESENT (lpType)) {
                    // test for optional value
                    *lpType = REG_MULTI_SZ;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                lFnStatus = Win32Error = GetExceptionCode();
            }

            ReleaseMutex (hGlobalDataMutex);
        }
    } else {
	    // define info block for data collection
	    COLLECT_THREAD_DATA CollectThreadData = {0, NULL, NULL, NULL, NULL, NULL, 0, 0};

        liQueryWaitTime.QuadPart = MakeTimeOutValue(QUERY_WAIT_TIME);

        status = NtWaitForSingleObject (
            hGlobalDataMutex, // semaphore
            FALSE,          // not alertable
            &liQueryWaitTime);          // wait 'til timeout

        if (status != STATUS_SUCCESS) {
            lFnStatus = ERROR_BUSY;
            Win32Error = ERROR_BUSY;
            TotalLen = dwcbData;
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
        } else {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
           //
           //  Format Return Buffer: start with basic data block
           //
           TotalLen = sizeof(PERF_DATA_BLOCK) +
                       ((CNLEN+sizeof(UNICODE_NULL))*sizeof(WCHAR));
           if ( dwcbData < TotalLen ) {
               Win32Error = ERROR_MORE_DATA;
               TRACE((WINPERF_DBG_TRACE_ERROR),
                     (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, TotalLen,
                 dwcbData, sizeof(DWORD), NULL));
           } else {
                // foreign data provider will return the perf data header

                Win32Error = ERROR_SUCCESS;
                try {
                    if (dwQueryType == QUERY_FOREIGN) {

                        // reset the values to avoid confusion

                        // *lpcbData = 0;  // 0 bytes  (removed to enable foreign computers)
                        if (lpData == NULL) {
                            Win32Error = ERROR_MORE_DATA;
                        }
                        else {
                            pDataDefinition = (LPVOID) lpData;
                            memset(lpData, 0, sizeof(PERF_DATA_BLOCK)); // clear out header
                        }
                    } else {
                        if (pPerfDataBlock == NULL) { // this is actually lpData
                            Win32Error = ERROR_MORE_DATA;
                        }
                        else {
                            MonBuildPerfDataBlock(pPerfDataBlock,
                                            (PVOID *) &pDataDefinition,
                                            0,
                                            PROCESSOR_OBJECT_TITLE_INDEX);
                        }
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    Win32Error = GetExceptionCode();
                }

                if (Win32Error == ERROR_SUCCESS) {
                    CollectThreadData.dwQueryType = dwQueryType;
                    CollectThreadData.lpValueName = usLocalValue.Buffer,
                    CollectThreadData.lpData = lpData;
                    CollectThreadData.lpcbData = lpcbData;
                    CollectThreadData.lppDataDefinition = &pDataDefinition;
                    CollectThreadData.pCurrentExtObject = NULL;
                    CollectThreadData.lReturnValue = ERROR_SUCCESS;
                    CollectThreadData.dwActionFlags = CTD_AF_NO_ACTION;

                    if (hCollectThread == NULL) {
                        // then call the function directly and hope for the best
                        Win32Error = QueryExtensibleData (
                            &CollectThreadData);
                    } else {
                        // collect the data in a separate thread
                        // load the args
                        // set event to get things going
                        SetEvent (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT]);

                        // now wait for the thread to return
                        Win32Error = WaitForSingleObject (
                            hCollectEvents[COLLECT_THREAD_DONE_EVENT],
                            COLLECTION_WAIT_TIME);

                        if (Win32Error == WAIT_TIMEOUT) {
                            bThreadHung = TRUE;
                            // log error

                            TRACE((WINPERF_DBG_TRACE_FATAL),
                                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, Win32Error, NULL));
                            if (THROTTLE_PERFLIB (PERFLIB_COLLECTION_HUNG)) {
                                LPSTR   szMessageArray[2];
                                WORD    wStringIndex;
                                // load data for eventlog message
                                wStringIndex = 0;
                                if (CollectThreadData.pCurrentExtObject != NULL) {
                                    szMessageArray[wStringIndex++] =
                                        CollectThreadData.pCurrentExtObject->szCollectProcName;
                                } else {
                                    szMessageArray[wStringIndex++] = "Unknown";
                                }

                                ReportEventA (hEventLog,
                                    EVENTLOG_ERROR_TYPE,        // error type
                                    0,                          // category (not used)
                                    (DWORD)PERFLIB_COLLECTION_HUNG,              // event,
                                    NULL,                       // SID (not used),
                                    wStringIndex,               // number of strings
                                    0,                          // sizeof raw data
                                    szMessageArray,             // message text array
                                    NULL);                      // raw data

                            }

                            DisablePerfLibrary(CollectThreadData.pCurrentExtObject, PERFLIB_DISABLE_ALL);

//                        DebugPrint((0, "Collection thread is hung in %s\n",
//                            CollectThreadData.pCurrentExtObject->szCollectProcName != NULL ?
//                            CollectThreadData.pCurrentExtObject->szCollectProcName : "Unknown"));
                            // and then wait forever for the thread to return
                            // this is done to prevent the function from returning
                            // while the collection thread is using the buffer
                            // passed in by the calling function and causing
                            // all kind of havoc should the buffer be changed and/or
                            // deleted and then have the thread continue for some reason

                            Win32Error = WaitForSingleObject (
                                hCollectEvents[COLLECT_THREAD_DONE_EVENT],
                                INFINITE);

                        }
                        bThreadHung = FALSE;    // in case it was true, but came out
                        // here the thread has returned so continue on
                        Win32Error = CollectThreadData.lReturnValue;
                    }
#if 0
                    if (CollectThreadData.dwActionFlags != CTD_AF_NO_ACTION) {
                        if (CollectThreadData.dwActionFlags == CTD_AF_OPEN_THREAD) {
                            OpenCollectionThread();
                        } else if (CollectThreadData.dwActionFlags == CTD_AF_CLOSE_THREAD) {
                            CloseCollectionThread();
                        } else {
                            assert (CollectThreadData.dwActionFlags != 0);
                        }
                    }
#endif
                }
            } // if (Win32Error == ERROR_SUCCESS)
            ReleaseMutex (hGlobalDataMutex);
        }

        // if an error was encountered, return it

        if (Win32Error != ERROR_SUCCESS) {
            lFnStatus = Win32Error;
        } else {
            //
            //  Final housekeeping for data return: note data size
            //

            TotalLen = (DWORD) ((PCHAR) pDataDefinition - (PCHAR) lpData);
            lFnStatus = ERROR_SUCCESS;
            try {
                if (lpcbData != NULL) {
                    *lpcbData = TotalLen;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                lFnStatus = GetExceptionCode();
            }

            pPerfDataBlock->TotalByteLength = TotalLen;
        }

        try {
            if (ARGUMENT_PRESENT (lpcbLen)) { // test for optional parameter
                *lpcbLen = TotalLen;
            }

            if (ARGUMENT_PRESENT (lpType)) { // test for optional value
                *lpType = REG_BINARY;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            lFnStatus = GetExceptionCode();
        }
    }

 PRQV_ErrorExit1:
    if (dwBoostPriority != 0) {
        // reset thread to original priority
        if ((lOldPriority > 0) && (lOldPriority != lNewPriority)) {
            NtSetInformationThread(
                NtCurrentThread(),
                ThreadPriority,
                &lOldPriority,
                sizeof(lOldPriority)
                );
        }
    }

    if (usLocalValue.Buffer != NULL) {
        // restore the value string if it was from the local static buffer
        // then free the local buffer
        if (lpValueName == &NtCurrentTeb( )->StaticUnicodeString) {
            USHORT Length = lpValueName->MaximumLength;
            if (Length > usLocalValue.MaximumLength) {
                Length = usLocalValue.MaximumLength;
            }
            memcpy (lpValueName->Buffer, usLocalValue.Buffer, Length);
            lpValueName->Buffer[(Length/sizeof(WCHAR))-1] = UNICODE_NULL;
            RtlFreeUnicodeString (&usLocalValue);
        }
    }

    HEAP_PROBE();
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, lFnStatus, NULL));
    return (LONG) lFnStatus;
}


LONG
PerfRegCloseKey
  (
    IN OUT PHKEY phKey
    )

/*++

Routine Description:

    Closes all performance handles when the usage count drops to 0.

Arguments:

    phKey - Supplies a handle to an open key to be closed.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    NTSTATUS status;
    LARGE_INTEGER   liQueryWaitTime ;

    HANDLE  hObjMutex;

    LONG    lReturn = ERROR_SUCCESS;
    HKEY    hKey;

    PEXT_OBJECT  pThisExtObj, pNextExtObj;
    //
    // Set the handle to NULL so that RPC knows that it has been closed.
    //

    hKey = *phKey;
    *phKey = NULL;

    if (hKey != HKEY_PERFORMANCE_DATA) {
        // no need to check HKEY_PERFORMANCE_TEXT and HKEY_PERFORMANCE_NLSTEXT.
        // Only HKEY_PERFORMANCE_DATA affects NumberOfOpens value.
        //
        return ERROR_SUCCESS;
    }

    if (NumberOfOpens <= 0) {
//        KdPrint(("PERFLIB: [Close] Pid: %d, Number Of PerflibHandles: %d\n",
//            GetCurrentProcessId(), NumberOfOpens));
        return ERROR_SUCCESS;
    }

    // wait for ext obj list to be "un"-busy

    liQueryWaitTime.QuadPart = MakeTimeOutValue (CLOSE_WAIT_TIME);
    status = NtWaitForSingleObject (
        hExtObjListIsNotInUse,
        FALSE,
        &liQueryWaitTime);

    if (status == STATUS_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status, NULL));

        // then the list is inactive so continue
        if (hGlobalDataMutex != NULL) {   // if a mutex was allocated, then use it

            // if here, then assume a mutex is ready

            liQueryWaitTime.QuadPart = MakeTimeOutValue(CLOSE_WAIT_TIME);

            status = NtWaitForSingleObject (
                hGlobalDataMutex, // semaphore
                FALSE,          // not alertable
                &liQueryWaitTime);          // wait forever

            if (status == STATUS_SUCCESS) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status,
                        &NumberOfOpens, sizeof(NumberOfOpens),
                        &hKey, sizeof(hKey), NULL));
                // now we have a lock on the global data, so continue
                if (hKey == HKEY_PERFORMANCE_DATA) {
                    if (InterlockedDecrement(&NumberOfOpens) == 0) {

                        // walk down list of known objects and close and delete each one
                        pNextExtObj = ExtensibleObjects;
                        while (pNextExtObj != NULL) {
                            // close and destroy each entry in the list
                            pThisExtObj = pNextExtObj;
                            hObjMutex = pThisExtObj->hMutex;
                            status = NtWaitForSingleObject (
                                hObjMutex,
                                FALSE,
                                &liQueryWaitTime);

                            if (status == STATUS_SUCCESS) {
                                TRACE((WINPERF_DBG_TRACE_INFO),
                                    (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status,
                                    pThisExtObj->szServiceName,
                                    WSTRSIZE(pThisExtObj->szServiceName),
                                    NULL));
                                InterlockedIncrement((LONG *)&pThisExtObj->dwLockoutCount);
                                status = CloseExtObjectLibrary(pThisExtObj, TRUE);

                                // close the handle to the perf subkey
                                NtClose (pThisExtObj->hPerfKey);

                                ReleaseMutex (hObjMutex);   // release
                                CloseHandle (hObjMutex);    // and free
                                pNextExtObj = pThisExtObj->pNext;
    
                                // toss the memory for this object
                                FREEMEM (pThisExtObj);
                            } else {
                                TRACE((WINPERF_DBG_TRACE_INFO),
                                    (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status,
                                    pThisExtObj->szServiceName,
                                    WSTRSIZE(pThisExtObj->szServiceName),
                                    NULL));
                                // this shouldn't happen since we've locked the
                                // list of objects
                                pNextExtObj = pThisExtObj->pNext;
                            }
                        } // while

                        // close the global objects
                        FREEMEM(pComputerName);
                        ComputerNameLength = 0;
                        pComputerName = NULL;

                        ExtensibleObjects = NULL;
                        NumExtensibleObjects = 0;

                        // close the timer thread
                        DestroyPerflibFunctionTimer ();

                        if (hEventLog != NULL) {
                            DeregisterEventSource (hEventLog);
                            hEventLog = NULL;
                        } // else the event log has already been closed

                        // release event handle
                        CloseHandle (hExtObjListIsNotInUse);
                        hExtObjListIsNotInUse = NULL;

//                        CloseCollectionThread();

                        if (ghKeyPerflib != NULL) {
                            RegCloseKey(ghKeyPerflib);
                        ghKeyPerflib = NULL;
                        }

                        if (lpPerflibSectionAddr != NULL) {
                            UnmapViewOfFile (lpPerflibSectionAddr);
                            lpPerflibSectionAddr = NULL;
                            CloseHandle (hPerflibSectionMap);
                            hPerflibSectionMap = NULL;
                            CloseHandle (hPerflibSectionFile);
                            hPerflibSectionFile = NULL;
                        }
                        ReleaseMutex(hGlobalDataMutex);
                    } else { // this isn't the last open call so return success
                        assert(NumberOfOpens != 0);
                        ReleaseMutex (hGlobalDataMutex);
                    }
                } // if (hKey == HKEY_PERFORMANCE_DATA)
            } else {
                TRACE((WINPERF_DBG_TRACE_FATAL),
                      (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status, NULL));
                // unable to lock the global data mutex in a timely fashion
                // so return
                lReturn = ERROR_BUSY;
            }
        } else {
            // if there's no mutex then something's fishy. It probably hasn't
            // been opened, yet.
            lReturn = ERROR_NOT_READY;
        }
    } else {
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status, NULL));
        // the object list is still in use so return and let the
        // caller try again later
        lReturn = WAIT_TIMEOUT;
    }

//    KdPrint(("PERFLIB: [Close] Pid: %d, Number Of PerflibHandles: %d\n",
//        GetCurrentProcessId(), NumberOfOpens));

    TRACE((WINPERF_DBG_TRACE_INFO),
        (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, lReturn,
        &NumberOfOpens, sizeof(NumberOfOpens), NULL));
    return lReturn;
}


LONG
PerfRegSetValue (
    IN HKEY hKey,
    IN LPWSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN LPBYTE  lpData,
    IN DWORD cbData
    )
/*++

    PerfRegSetValue -   Set data

        Inputs:

            hKey            -   Predefined handle to open remote
                                machine

            lpValueName     -   Name of the value to be returned;
                                could be "ForeignComputer:<computername>
                                or perhaps some other objects, separated
                                by ~; must be Unicode string

            lpReserved      -   should be omitted (NULL)

            lpType          -   should be REG_MULTI_SZ

            lpData          -   pointer to a buffer containing the
                                performance name

            lpcbData        -   pointer to a variable containing the
                                size in bytes of the input buffer;

         Return Value:

            DOS error code indicating status of call or
            ERROR_SUCCESS if all ok

--*/

{
    DWORD          dwQueryType;         //  type of request
    LPWSTR         lpLangId     = NULL;
    NTSTATUS       status;
    UNICODE_STRING String;
    LONG           lReturn      = ERROR_SUCCESS;
    DWORD          cbTmpData    = cbData;

    UNREFERENCED_PARAMETER(dwType);
    UNREFERENCED_PARAMETER(Reserved);

    try {
        dwQueryType = GetQueryType (lpValueName);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        lReturn = GetExceptionCode();
        goto Error_exit;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
        (&PerflibGuid, __LINE__, PERF_REG_SET_VALUE, 0, dwQueryType,
        &hKey, sizeof(hKey), NULL));

    // convert the query to set commands
    if ((dwQueryType == QUERY_COUNTER) ||
        (dwQueryType == QUERY_ADDCOUNTER)) {
        dwQueryType = QUERY_ADDCOUNTER;
    } else if ((dwQueryType == QUERY_HELP) ||
              (dwQueryType == QUERY_ADDHELP)) {
        dwQueryType = QUERY_ADDHELP;
    } else {
        lReturn = ERROR_BADKEY;
        goto Error_exit;
    }

    if (hKey == HKEY_PERFORMANCE_TEXT) {
        lpLangId = DefaultLangId;
    } else if (hKey == HKEY_PERFORMANCE_NLSTEXT) {
        lpLangId = &NativeLangId[0];
        PerfGetLangId(NativeLangId);
    } else {
        lReturn = ERROR_BADKEY;
        goto Error_exit;
    }

    try {
        RtlInitUnicodeString(&String, lpValueName);

        status = PerfGetNames (
            dwQueryType,
            &String,
            lpData,
            &cbData,
            NULL,
            lpLangId);

        if (!NT_SUCCESS(status) && (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_REG_SET_VALUE, 0, status, NULL));

            // Sublanguage doesn't exist, so try the real one
            //
            PerfGetPrimaryLangId(GetUserDefaultUILanguage(), NativeLangId);
            cbData = cbTmpData;
            status = PerfGetNames (
                        dwQueryType,
                        &String,
                        lpData,
                        &cbData,
                        NULL,
                        lpLangId);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        lReturn = GetExceptionCode();
        goto Error_exit;
    }
    if (!NT_SUCCESS(status)) {
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (&PerflibGuid, __LINE__, PERF_REG_SET_VALUE, 0, status, NULL));

        lReturn = (error_status_t)PerfpDosError(status);
    }

Error_exit:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_REG_SET_VALUE, 0, lReturn, NULL));
    return (lReturn);
}


LONG
PerfRegEnumKey (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT PUNICODE_STRING lpClass OPTIONAL,
    OUT PFILETIME lpftLastWriteTime OPTIONAL
    )

/*++

Routine Description:

    Enumerates keys under HKEY_PERFORMANCE_DATA.

Arguments:

    Same as RegEnumKeyEx.  Returns that there are no such keys.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNREFERENCED_PARAMETER(hKey);
    UNREFERENCED_PARAMETER(dwIndex);
    UNREFERENCED_PARAMETER(lpReserved);

    try {
        lpName->Length = 0;

        if (ARGUMENT_PRESENT (lpClass)) {
            lpClass->Length = 0;
        }

        if ( ARGUMENT_PRESENT(lpftLastWriteTime) ) {
            lpftLastWriteTime->dwLowDateTime = 0;
            lpftLastWriteTime->dwHighDateTime = 0;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }

    return ERROR_NO_MORE_ITEMS;
}


LONG
PerfRegQueryInfoKey (
    IN HKEY hKey,
    OUT PUNICODE_STRING lpClass,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    This returns information concerning the predefined handle
    HKEY_PERFORMANCE_DATA

Arguments:

    Same as RegQueryInfoKey.

Return Value:

    Returns ERROR_SUCCESS (0) for success.

--*/

{
    DWORD TempLength=0;
    DWORD MaxValueLen=0;
    UNICODE_STRING Null;
    SECURITY_DESCRIPTOR     SecurityDescriptor;
    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    DWORD                   PerfStatus = ERROR_SUCCESS;
    UNICODE_STRING          PerflibSubKeyString;
    BOOL                    bGetSACL = TRUE;

    UNREFERENCED_PARAMETER(lpReserved);

    try {
        if (lpClass->MaximumLength >= sizeof(UNICODE_NULL)) {
            lpClass->Length = 0;
            *lpClass->Buffer = UNICODE_NULL;
        }
        *lpcSubKeys = 0;
        *lpcbMaxSubKeyLen = 0;
        *lpcbMaxClassLen = 0;
        *lpcValues = NUM_VALUES;
        *lpcbMaxValueNameLen = VALUE_NAME_LENGTH;
        *lpcbMaxValueLen = 0;

        if ( ARGUMENT_PRESENT(lpftLastWriteTime) ) {
            lpftLastWriteTime->dwLowDateTime = 0;
            lpftLastWriteTime->dwHighDateTime = 0;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        PerfStatus = GetExceptionCode();
    }
    if (PerfStatus == ERROR_SUCCESS) {
        if ((hKey == HKEY_PERFORMANCE_TEXT) ||
            (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
            //
            // We have to go enumerate the values to determine the answer for
            // the MaxValueLen parameter.
            //
            Null.Buffer = NULL;
            Null.Length = 0;
            Null.MaximumLength = 0;
            PerfStatus = PerfEnumTextValue(hKey,
                              0,
                              &Null,
                              NULL,
                              NULL,
                              NULL,
                              &MaxValueLen,
                              NULL);
            if (PerfStatus == ERROR_SUCCESS) {
                PerfStatus = PerfEnumTextValue(hKey,
                                1,
                                &Null,
                                NULL,
                                NULL,
                                NULL,
                                &TempLength,
                                NULL);
            }

            try {
                if (PerfStatus == ERROR_SUCCESS) {
                    if (TempLength > MaxValueLen) {
                        MaxValueLen = TempLength;
                    }
                    *lpcbMaxValueLen = MaxValueLen;
                } else {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_REG_QUERY_INFO_KEY, 0, PerfStatus, NULL));
                    // unable to successfully enum text values for this
                    // key so return 0's and the error code
                    *lpcValues = 0;
                    *lpcbMaxValueNameLen = 0;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                PerfStatus = GetExceptionCode();
            }
        }
    }

    if (PerfStatus == ERROR_SUCCESS) {
        // continune if all is OK
        // now get the size of SecurityDescriptor for Perflib key

        RtlInitUnicodeString (
            &PerflibSubKeyString,
            PerflibKey);


        //
        // Initialize the OBJECT_ATTRIBUTES structure and open the key.
        //
        InitializeObjectAttributes(
                &Obja,
                &PerflibSubKeyString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );


        Status = NtOpenKey(
                    &hPerflibKey,
                    MAXIMUM_ALLOWED | ACCESS_SYSTEM_SECURITY,
                    &Obja
                    );

        if ( ! NT_SUCCESS( Status )) {
            Status = NtOpenKey(
                &hPerflibKey,
                    MAXIMUM_ALLOWED,
                    &Obja
                    );
            bGetSACL = FALSE;
        }

        if ( ! NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_INFO_KEY, 0, Status, NULL));
        } else {

            try {
                *lpcbSecurityDescriptor = 0;

                if (bGetSACL == FALSE) {
                    //
                    // Get the size of the key's SECURITY_DESCRIPTOR for OWNER, GROUP
                    // and DACL. These three are always accessible (or inaccesible)
                    // as a set.
                    //
                    Status = NtQuerySecurityObject(
                            hPerflibKey,
                            OWNER_SECURITY_INFORMATION
                            | GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION,
                            &SecurityDescriptor,
                            0,
                            lpcbSecurityDescriptor
                            );
                } else {
                    //
                    // Get the size of the key's SECURITY_DESCRIPTOR for OWNER, GROUP,
                    // DACL, and SACL.
                    //
                    Status = NtQuerySecurityObject(
                                hPerflibKey,
                                OWNER_SECURITY_INFORMATION
                                | GROUP_SECURITY_INFORMATION
                                | DACL_SECURITY_INFORMATION
                                | SACL_SECURITY_INFORMATION,
                                &SecurityDescriptor,
                                0,
                                lpcbSecurityDescriptor
                                );
                }

                if( Status != STATUS_BUFFER_TOO_SMALL ) {
                    *lpcbSecurityDescriptor = 0;
                } else {
                    // this is expected so set status to success
                    Status = STATUS_SUCCESS;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                PerfStatus = GetExceptionCode();
            }

            NtClose(hPerflibKey);
        } // else return status
        if (NT_SUCCESS( Status )) {
            PerfStatus = ERROR_SUCCESS;
        } else {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_INFO_KEY, 0, Status, NULL));
            // return error
            PerfStatus = PerfpDosError(Status);
        }
    }

    return (LONG) PerfStatus;
}


LONG
PerfRegEnumValue (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpValueName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData,
    OUT LPDWORD lpcbLen  OPTIONAL
    )

/*++

Routine Description:

    Enumerates Values under HKEY_PERFORMANCE_DATA.

Arguments:

    Same as RegEnumValue.  Returns the values.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    USHORT cbNameSize;
    LONG   ErrorCode;

    // table of names used by enum values
    UNICODE_STRING ValueNames[NUM_VALUES];

    ValueNames [0].Length = (WORD)(lstrlenW (GLOBAL_STRING) * sizeof(WCHAR));
    ValueNames [0].MaximumLength = (WORD)(ValueNames [0].Length + sizeof(UNICODE_NULL));
    ValueNames [0].Buffer =  (LPWSTR)GLOBAL_STRING;
    ValueNames [1].Length = (WORD)(lstrlenW(COSTLY_STRING) * sizeof(WCHAR));
    ValueNames [1].MaximumLength = (WORD)(ValueNames [1].Length + sizeof(UNICODE_NULL));
    ValueNames [1].Buffer = (LPWSTR)COSTLY_STRING;

    if (lpValueName == NULL || lpValueName->Buffer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if ((hKey == HKEY_PERFORMANCE_TEXT) ||
        (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        //
        // Assumes PerfEnumTextValue will use try block
        // 
        return(PerfEnumTextValue(hKey,
                                  dwIndex,
                                  lpValueName,
                                  lpReserved,
                                  lpType,
                                  lpData,
                                  lpcbData,
                                  lpcbLen));
    }

    if ( dwIndex >= NUM_VALUES ) {

        //
        // This is a request for data from a non-existent value name
        //

        try {
            *lpcbData = 0;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        return ERROR_NO_MORE_ITEMS;
    }

    cbNameSize = ValueNames[dwIndex].Length;
    ErrorCode = ERROR_SUCCESS;

    try {
        if ( lpValueName->MaximumLength < cbNameSize ) {
            ErrorCode = ERROR_MORE_DATA;
        } else {

             lpValueName->Length = cbNameSize;
             RtlCopyUnicodeString(lpValueName, &ValueNames[dwIndex]);

             if (ARGUMENT_PRESENT (lpType)) {
                *lpType = REG_BINARY;
             }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = GetExceptionCode();
    }

    if (ErrorCode == ERROR_SUCCESS) {
        ErrorCode = PerfRegQueryValue(hKey,
                              lpValueName,
                              NULL,
                              lpType,
                              lpData,
                              lpcbData,
                              lpcbLen);
    }
    return ErrorCode;
}


LONG
PerfEnumTextValue (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpValueName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData,
    OUT LPDWORD lpcbLen  OPTIONAL
    )
/*++

Routine Description:

    Enumerates Values under Perflib\lang

Arguments:

    Same as RegEnumValue.  Returns the values.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING FullValueName;
    LONG            lReturn = ERROR_SUCCESS;

    //
    // Only two values, "Counter" and "Help"
    //
    try {
        if (dwIndex==0) {
            lpValueName->Length = 0;
            RtlInitUnicodeString(&FullValueName, CounterValue);
        } else if (dwIndex==1) {
            lpValueName->Length = 0;
            RtlInitUnicodeString(&FullValueName, HelpValue);
        } else {
            lReturn = ERROR_NO_MORE_ITEMS;
        }

        if (lReturn == ERROR_SUCCESS) {
            RtlCopyUnicodeString(lpValueName, &FullValueName);

            //
            // We need to NULL terminate the name to make RPC happy.
            //
            if (lpValueName->Length+sizeof(WCHAR) <= lpValueName->MaximumLength) {
                lpValueName->Buffer[lpValueName->Length / sizeof(WCHAR)] = UNICODE_NULL;
                lpValueName->Length += sizeof(UNICODE_NULL);
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        lReturn = GetExceptionCode();
    }

    if (lReturn == ERROR_SUCCESS) {
        lReturn = PerfRegQueryValue(hKey,
                             &FullValueName,
                             lpReserved,
                             lpType,
                             lpData,
                             lpcbData,
                             lpcbLen);
    }

    return lReturn;

}

#if 0
DWORD
CollectThreadFunction (
    LPDWORD dwArg
)
{
    DWORD   dwWaitStatus = 0;
    BOOL    bExit = FALSE;
    NTSTATUS   status = STATUS_SUCCESS;
    THREAD_BASIC_INFORMATION    tbiData;
    LONG    lOldPriority, lNewPriority;
    LONG    lStatus;

    UNREFERENCED_PARAMETER (dwArg);

//    KdPrint(("PERFLIB: Entering Data Collection Thread: PID: %d, TID: %d\n",
//        GetCurrentProcessId(), GetCurrentThreadId()));
    // raise the priority of this thread
    status = NtQueryInformationThread (
        NtCurrentThread(),
        ThreadBasicInformation,
        &tbiData,
        sizeof(tbiData),
        NULL);

    if (NT_SUCCESS(status)) {
        lOldPriority = tbiData.Priority;
        lNewPriority = DEFAULT_THREAD_PRIORITY; // perfmon's favorite priority

        //
        //  Only RAISE the priority here. Don't lower it if it's high
        //
        if (lOldPriority < lNewPriority) {
            status = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadPriority,
                    &lNewPriority,
                    sizeof(lNewPriority)
                    );
            if (status != STATUS_SUCCESS) {
                DebugPrint((0, "Set Thread Priority failed: 0x%8.8x\n", status));
            }
        }
    }

    // wait for flags
    while (!bExit) {
        dwWaitStatus = WaitForMultipleObjects (
            COLLECT_THREAD_LOOP_EVENT_COUNT,
            hCollectEvents,
            FALSE, // wait for ANY event to go
            INFINITE); // wait for ever
        // see why the wait returned:
        if (dwWaitStatus == (WAIT_OBJECT_0 + COLLECT_THREAD_PROCESS_EVENT)) {
            // the event is cleared automatically
            // collect data
            lStatus = QueryExtensibleData (
                &CollectThreadData);
            CollectThreadData.lReturnValue = lStatus;
            SetEvent (hCollectEvents[COLLECT_THREAD_DONE_EVENT]);
        } else if (dwWaitStatus == (WAIT_OBJECT_0 + COLLECT_THREAD_EXIT_EVENT)) {
            bExit = TRUE;
            continue;   // go up and bail out
        } else {
            // who knows, so output message
            KdPrint(("\nPERFLILB: Collect Thread wait returned unknown value: 0x%8.8x",dwWaitStatus));
            bExit = TRUE;
            continue;
        }
    }
//    KdPrint(("PERFLIB: Leaving Data Collection Thread: PID: %d, TID: %d\n",
//        GetCurrentProcessId(), GetCurrentThreadId()));
    return ERROR_SUCCESS;
}
#endif

BOOL
PerfRegInitialize()
{
    RtlInitializeCriticalSection(&PerfpCritSect);
    InitializeListHead((PLIST_ENTRY) &PerfpErrorLog);
    return TRUE;
}

BOOL
PerfRegCleanup()
/*++

Routine Description:

    Cleans up anything that perflib uses before it unloads. Assumes
    that there are queries or perf reg opens outstanding.

Arguments:

    None

Return Value:

    Returns TRUE if succeed. FALSE otherwise.

--*/

{
    if (hGlobalDataMutex != NULL) {
        if (NumberOfOpens != 0)
            return FALSE;
        CloseHandle(hGlobalDataMutex);
        hGlobalDataMutex = NULL;
    }
    PerfpDeleteErrorLogs(&PerfpErrorLog);
    RtlDeleteCriticalSection(&PerfpCritSect);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\perfname.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
Copyright (c) 1992-1994   Microsoft Corporation

Module Name:
    perfname.c

Abstract:
    This file returns the Counter names or help text.

Author:
    HonWah Chan  10/12/93

Revision History:
--*/
#define UNICODE
#define _UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <strsafe.h>
#include "ntconreg.h"
#include "perflib.h"
#pragma warning(default:4306)

#define QUERY_GLOBAL       1
#define QUERY_ITEMS        2
#define QUERY_FOREIGN      3
#define QUERY_COSTLY       4
#define QUERY_COUNTER      5
#define QUERY_HELP         6
#define QUERY_ADDCOUNTER   7
#define QUERY_ADDHELP      8

#define tohexdigit(x) ((CHAR) (((x) < 10) ? ((x) + L'0') : ((x) + L'a' - 10)))

#define  LANG_ID_START  25
const WCHAR FileNameTemplate[]    = L"\\SystemRoot\\system32\\perf0000.dat";
const WCHAR SubFileNameTemplate[] = L"\\SystemRoot\\system32\\prf00000.dat";
const WCHAR DefaultLangId[]       = L"009";

extern   WCHAR COUNTER_STRING[];
extern   WCHAR HELP_STRING[];
extern   WCHAR ADDCOUNTER_STRING[];
extern   WCHAR ADDHELP_STRING[];

DWORD  GetLangIdFromSzLang(LPWSTR szLangId);
VOID   Perflib004Update(LPWSTR pLangIdRequest);
LPWSTR PerflibCheckPerfFile(LPWSTR szLangId, LPWSTR szRtnLang, DWORD dwRtnLang);

NTSTATUS
PerfGetNames(
   IN  DWORD           QueryType,
   IN  PUNICODE_STRING lpValueName,
   OUT LPBYTE          lpData,
   OUT LPDWORD         lpcbData,
   OUT LPDWORD         lpcbLen  OPTIONAL,
   IN  LPWSTR          lpLanguageId   OPTIONAL
   )
/*++
PerfGetCounterName

Arguments - Get either counter names or help text for the given language.
      If there is no language ID specified in the input, the default English
      version is returned.

Inputs -
   QueryType      -  Either QUERY_COUNTER or QUERY_HELP
                     or QUERY_ADDCOUNTER or QUERY_ADDHELP
   lpValueName    -  Either "Counter ???" or "Explain ???"
                     or "Addcounter ???" or "Addexplain ???"
   lpData         -  pointer to a buffer to receive the names
   lpcbData       -  pointer to a variable containing the size in bytes of
                     the output buffer; on output, will receive the number
                     of bytes actually returned
   lpcbLen        -  Return the number of bytes to transmit to
                     the client (used by RPC) (optional).
   lpLanguageId   -  Input string for the language id desired.

   Return Value -
            error code indicating status of call or
            ERROR_SUCCESS if all ok
--*/
{
    UNICODE_STRING            NtFileName;
    NTSTATUS                  Status;
    WCHAR                     Names[50], QueryChar;
    WCHAR                     szRtnLang[5];
    ULONG                     NameLen, StartIndex;
    OBJECT_ATTRIBUTES         ObjectAttributes;
    IO_STATUS_BLOCK           IoStatus;
    FILE_STANDARD_INFORMATION FileInformation;
    HANDLE                    File;
    LPWSTR                    pLangIdRequest;
    LPWSTR                    pTmpLangId;
    BOOL                      bAddNames, bSubLang;
    HRESULT                   hError;

    // build the file name
    hError = StringCchCopyW(Names, 50, FileNameTemplate);
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_GET_NAMES,
          ARG_DEF(ARG_TYPE_WSTR, 2), 0,
          &QueryType, sizeof(QueryType),
          lpValueName->Buffer, WSTRSIZE(lpValueName->Buffer), NULL));

    if (QueryType == QUERY_ADDCOUNTER || QueryType == QUERY_ADDHELP) {
        bAddNames = TRUE;
    } else {
        bAddNames = FALSE;
    }
    if (QueryType == QUERY_COUNTER || QueryType == QUERY_ADDCOUNTER) {
        QueryChar = L'c';
        NameLen = (ULONG) wcslen(COUNTER_STRING);
    } else {
        NameLen = (ULONG) wcslen(HELP_STRING);
        QueryChar = L'h';
    }

    if (lpLanguageId) {
        DWORD dwLangId = PRIMARYLANGID(GetLangIdFromSzLang(lpLanguageId));
        if (dwLangId == 0x004) {
            pLangIdRequest = lpLanguageId;
        }
        else {
            pLangIdRequest = PerflibCheckPerfFile(lpLanguageId, szRtnLang, 5);
            if (pLangIdRequest == NULL) {
                // It is possible that no PERFCxx.DAT and PERFHxxx.DAT files are present.
                // Restore pLangIdRequest to original value if PerflibCheckPerfFile() returns
                // NULL.
                //
                pLangIdRequest = lpLanguageId;
            }
        }
    } else {
        // get the lang id from the input lpValueName
        pLangIdRequest = lpValueName->Buffer + NameLen;
        do {
            if (lpValueName->Length < (NameLen + 3) * sizeof(WCHAR)) {
                // lpValueName is too small to contain the lang id, use default
                pLangIdRequest = (LPWSTR) DefaultLangId;
                break;
            }

            if (*pLangIdRequest >= L'0' && *pLangIdRequest <= L'9') {
                // found the first digit
                break;
            }
            pLangIdRequest++;
            NameLen++;
        } while (NameLen > 0); // always TRUE

        // Specially for 004 (CHT and CHS) if this is a Whistler upgrade.
        // Need to copy perfc004.dat/perfh004.dat to prfc0?04.dat/prfh0?04.dat
        // then rename perfc004.dat/perfh004.dat so that PERFLIB will not find
        // them in the future.
        // Currently this is a hack.
        //
        Perflib004Update(pLangIdRequest);

        pTmpLangId     = pLangIdRequest;
        pLangIdRequest = PerflibCheckPerfFile(pTmpLangId, szRtnLang, 5);
        if (pLangIdRequest == NULL) {
            pLangIdRequest = pTmpLangId;
        }
    }

    bSubLang =  ((pLangIdRequest[3] >= L'0') && (pLangIdRequest[3] <= L'9'));
    StartIndex = LANG_ID_START;
    if (bSubLang) {
        StartIndex = LANG_ID_START - 1;
        hError     = StringCchCopyW(Names, 50, SubFileNameTemplate);
    }

    Names[StartIndex] = QueryChar;
    Names[StartIndex + 1] = *pLangIdRequest++;
    Names[StartIndex + 2] = *pLangIdRequest++;
    Names[StartIndex + 3] = *pLangIdRequest++;
    if (bSubLang) {
        Names[StartIndex + 4] = *pLangIdRequest;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_GET_NAMES,
          ARG_DEF(ARG_TYPE_WSTR, 1), 0,
          Names, WSTRSIZE(Names), NULL));

    RtlInitUnicodeString(& NtFileName, Names);
    // open the file for info
    InitializeObjectAttributes( &ObjectAttributes,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL
                              );
    if (bAddNames) {
        // writing name to data file

        LARGE_INTEGER   ByteOffset;

        ByteOffset.LowPart = ByteOffset.HighPart = 0;
        Status = NtCreateFile( &File,
                               SYNCHRONIZE | GENERIC_WRITE,
                               &ObjectAttributes,
                               &IoStatus,
                               NULL,               // no initial size
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_SUPERSEDE,     // always create
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,               // no ea buffer
                               0                   // no ea buffer
                           );
        if (!NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            return( Status );
        }
        if (ARGUMENT_PRESENT(lpData) && ARGUMENT_PRESENT(lpcbData)) {
            Status = NtWriteFile( File,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatus,
                                  lpData,
                                  *lpcbData,
                                  &ByteOffset,
                                  NULL
                                 );
        }
        else {
            Status = ERROR_INVALID_PARAMETER;
        }

        if (!NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            NtClose( File );
            return( Status );
        }
    } else {
        // reading name from data file
        Status = NtOpenFile( &File,
                             SYNCHRONIZE | GENERIC_READ,
                             &ObjectAttributes,
                             &IoStatus,
                             FILE_SHARE_DELETE |
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE,
                             FILE_SYNCHRONOUS_IO_NONALERT |
                                FILE_NON_DIRECTORY_FILE
                           );

        if (!NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            return( Status );
        }

        Status = NtQueryInformationFile( File,
                                         &IoStatus,
                                         (PVOID)&FileInformation,
                                         sizeof( FileInformation ),
                                         FileStandardInformation
                                       );

        if (NT_SUCCESS( Status )) {
            if (FileInformation.EndOfFile.HighPart) {
                Status = STATUS_BUFFER_OVERFLOW;
                TRACE((WINPERF_DBG_TRACE_INFO),
                    (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            }
        }

        if (!NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            NtClose( File );
            return( Status );
        }

        if (! ARGUMENT_PRESENT(lpData) || ! ARGUMENT_PRESENT(lpcbData) ||
                        * lpcbData < FileInformation.EndOfFile.LowPart) {
            NtClose( File );
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            if (ARGUMENT_PRESENT (lpcbLen)) {
                // no data yet for the rpc
                *lpcbLen = 0;
            }
            if (ARGUMENT_PRESENT(lpcbData)) {
                *lpcbData = FileInformation.EndOfFile.LowPart;
            }
            if (ARGUMENT_PRESENT (lpData)) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                    (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
                return (STATUS_BUFFER_OVERFLOW);
            }

            return(STATUS_SUCCESS);
        }


        Status = NtReadFile( File,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             lpData,
                             FileInformation.EndOfFile.LowPart,
                             NULL,
                             NULL
                            );

        if (NT_SUCCESS( Status )) {

            Status = IoStatus.Status;

            if (NT_SUCCESS( Status )) {
                if (IoStatus.Information != FileInformation.EndOfFile.LowPart) {
                    Status = STATUS_END_OF_FILE;
                }
            }
        }
        else {
            TRACE((WINPERF_DBG_TRACE_INFO),
                (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
        }

        if (NT_SUCCESS( Status )) {
            if (ARGUMENT_PRESENT(lpcbData)) {
                *lpcbData = FileInformation.EndOfFile.LowPart;
            }
            if (ARGUMENT_PRESENT(lpcbLen)) {
                *lpcbLen = FileInformation.EndOfFile.LowPart;
            }
        }
    } // end of reading names

    NtClose (File);
    return (Status);
}

VOID
PerfGetPrimaryLangId(
    DWORD   dwLangId,
    WCHAR * PrimaryLangId
)
{
    // build the native language id
    WCHAR LangId;
    WCHAR nDigit;

    LangId           = (WCHAR) PRIMARYLANGID(dwLangId);
    nDigit           = (WCHAR) (LangId >> 8);
    PrimaryLangId[0] = tohexdigit(nDigit);
    nDigit           = (WCHAR) (LangId & 0XF0) >> 4;
    PrimaryLangId[1] = tohexdigit(nDigit);
    nDigit           = (WCHAR) (LangId & 0xF);
    PrimaryLangId[2] = tohexdigit(nDigit);
    PrimaryLangId[3] = L'\0';
}

VOID
PerfGetLangId(
    WCHAR * FullLangId
)
{
    WCHAR LangId;
    WCHAR nDigit;

    LangId        = (WCHAR) GetUserDefaultUILanguage();
    nDigit        = (LangId & 0xF000) >> 12;
    FullLangId[0] = tohexdigit(nDigit);
    nDigit        = (LangId & 0x0F00) >> 8;
    FullLangId[1] = tohexdigit(nDigit);
    nDigit        = (LangId & 0x00F0) >> 4;
    FullLangId[2] = tohexdigit(nDigit);
    nDigit        = LangId & 0xF;
    FullLangId[3] = tohexdigit(nDigit);
    FullLangId[4] = L'\0';
}

DWORD
GetLangIdFromSzLang(
    LPWSTR szLangId
)
{
    DWORD dwLangId  = 0;
    DWORD dwLangLen = lstrlenW(szLangId);
    DWORD i;
    WCHAR wszDigit;

    for (i = 0; i < dwLangLen; i ++) {
        dwLangId <<= 4;
        wszDigit = szLangId[i];
        if (wszDigit >= L'0' && wszDigit <= L'9') {
            dwLangId += (wszDigit - L'0');
        }
        else if (wszDigit >= L'a' && wszDigit <= 'f') {
            dwLangId += (10 + wszDigit - L'a');
        }
        else if (wszDigit >= L'A' && wszDigit <= 'F') {
            dwLangId += (10 + wszDigit - L'A');
        }
        else {
            dwLangId = 0;
            break;
        }
    }
    return dwLangId;
}

LPCWSTR szCtrLangFile    = L"perfc";
LPCWSTR szCtrSubLangFile = L"prfc";
LPCWSTR szHlpLangFile    = L"perfh";
LPCWSTR szHlpSubLangFile = L"prfh";
LPCWSTR sz004CtrLangFile = L"perfc004.dat";
LPCWSTR sz004HlpLangFile = L"perfh004.dat";
LPCWSTR szFileExt        = L".dat";

LPWSTR
PerflibFindCounterFile(
    IN  LPWSTR  szFilePath,
    IN  BOOLEAN bCheckSubLang,
    IN  LPWSTR  szLangId,
    OUT LPWSTR  szRtnLang,
    IN  DWORD   dwRtnLang
)
{
    WCHAR            szThisLang[5];
    WCHAR            szPrimaryLang[5];
    DWORD            dwThisLang;
    DWORD            dwFileLen;
    WIN32_FIND_DATAW FindFileData;
    DWORD            bResult = FALSE;
    HANDLE           hFile   = NULL;
    HRESULT          hError;

    hFile   = FindFirstFileExW(szFilePath, FindExInfoStandard, & FindFileData, FindExSearchNameMatch, NULL, 0);
    RtlZeroMemory(szRtnLang, dwRtnLang * sizeof(WCHAR));
    if (hFile != INVALID_HANDLE_VALUE) {
        if (bCheckSubLang) {
            do {
                dwFileLen = lstrlenW(FindFileData.cFileName);
                if (dwFileLen == 12) {
                    ZeroMemory(szThisLang, 5 * sizeof(WCHAR));
                    ZeroMemory(szPrimaryLang, 5 * sizeof(WCHAR));
                    hError = StringCchCopyW(szThisLang, 5, (LPWSTR) (FindFileData.cFileName + (dwFileLen - 8)));
                    dwThisLang = GetLangIdFromSzLang(szThisLang);
                    if (dwThisLang != 0) {
                        PerfGetPrimaryLangId(dwThisLang, szPrimaryLang);
                        bResult = (lstrcmpiW(szPrimaryLang, szLangId) == 0);
                        if (bResult == TRUE) {
                            hError = StringCchCopyW(szRtnLang, dwRtnLang, szThisLang);
                        }
                    }
                }
            }
            while (FindNextFileW(hFile, & FindFileData));
        }
        else {
            bResult = TRUE;
            hError = StringCchCopyW(szRtnLang, dwRtnLang, szLangId);
        }
        FindClose(hFile);
    }
    return bResult ? szRtnLang : NULL;
}

LPWSTR
PerflibCheckPerfFile(
    IN  LPWSTR LangId,
    OUT LPWSTR szRtnLang,
    IN  DWORD  dwRtnLang
)
{
    DWORD     dwSysDir  = GetSystemDirectoryW(NULL, 0);
    DWORD     dwSrchDir;
    DWORD     dwLangLen = lstrlenW(LangId);
    DWORD     dwLangId;
    LPWSTR    szLangId  = NULL;
    WCHAR     szLang[5];
    LPWSTR    szSysDir  = NULL;
    LPWSTR    szSrchDir = NULL;
    HRESULT   hError;

    if (dwSysDir == 0) goto Cleanup;

    dwSrchDir = lstrlenW(szCtrSubLangFile) + lstrlenW(LangId) + lstrlenW(szFileExt) + 1;
    if (dwSrchDir < 13) dwSrchDir = 13; // "8.3" filename format with NULL
    dwSrchDir += dwSysDir + 1;

    szSysDir = (LPWSTR) ALLOCMEM(sizeof(WCHAR) * (dwSysDir + 1 + dwSrchDir));
    if (szSysDir == NULL) goto Cleanup;
    else if (GetSystemDirectoryW(szSysDir, dwSysDir + 1) == 0) goto Cleanup;

    szSrchDir = szSysDir + dwSysDir + 1;

    if (dwLangLen == 4) {
        hError = StringCchPrintfW(szSrchDir, dwSrchDir, L"%ws\\%ws%ws%ws",
                        szSysDir, szCtrSubLangFile, LangId, szFileExt);
        szLangId = PerflibFindCounterFile(szSrchDir, FALSE, LangId, szRtnLang, dwRtnLang);
        if (szLangId == NULL) {
            dwLangId = GetLangIdFromSzLang(LangId);
            if (dwLangId != 0) {
                ZeroMemory(szLang, sizeof(WCHAR) * 5);
                PerfGetPrimaryLangId(dwLangId, szLang);
                ZeroMemory(szSrchDir, sizeof(WCHAR) * dwSrchDir);
                hError = StringCchPrintfW(szSrchDir, dwSrchDir, L"%ws\\%ws%ws%ws",
                                szSysDir, szCtrLangFile, szLang, szFileExt);
                szLangId = PerflibFindCounterFile(szSrchDir, FALSE, szLang, szRtnLang, dwRtnLang);
            }
        }
    }
    else {
        // dwLangId should be 3, this is primary UserDefaultUILanguage.
        //
        hError  = StringCchPrintfW(szSrchDir, dwSrchDir, L"%ws\\%ws%ws%ws",
                        szSysDir, szCtrLangFile, LangId, szFileExt);
        szLangId = PerflibFindCounterFile(szSrchDir, FALSE, LangId, szRtnLang, dwRtnLang);
        if (szLangId == NULL) {
            ZeroMemory(szSrchDir, sizeof(WCHAR) * dwSrchDir);
            hError = StringCchPrintfW(szSrchDir, dwSrchDir, L"%ws\\%ws??%ws%ws",
                            szSysDir, szCtrSubLangFile, (LPWSTR) (LangId + 1), szFileExt);
            szLangId = PerflibFindCounterFile(szSrchDir, TRUE, LangId, szRtnLang, dwRtnLang);
        }
    }

Cleanup:
    FREEMEM(szSysDir);
    return szLangId;
}

VOID
PerflibRename004File(
    IN  LPWSTR  szSysDir,
    IN  LPWSTR  szLangId,
    IN  BOOLEAN bCounterFile
)
{
    DWORD   dwSrchDir = lstrlenW(szSysDir) + 2 + 13 + 4; // 13 is for "8.3" filename with NULL; 4 is for ".tmp"
    LPWSTR  szTmpFile = NULL;
    LPWSTR  szSrchDir = NULL;
    LPWSTR  szName;
    HRESULT hError;

    szSrchDir = ALLOCMEM(2 * sizeof(WCHAR) * dwSrchDir);
    if (szSrchDir == NULL) goto Cleanup;

    szTmpFile = szSrchDir + dwSrchDir;

    szName  = (LPWSTR) ((bCounterFile) ? (sz004CtrLangFile) : (sz004HlpLangFile));
    hError  = StringCchPrintfW(szSrchDir, dwSrchDir, L"%ws\\%ws", szSysDir, szName);

    if (szLangId) {
        szName = (LPWSTR) ((bCounterFile) ? (szCtrSubLangFile) : (szHlpSubLangFile));
        hError = StringCchPrintfW(szTmpFile, dwSrchDir, L"%ws\\%ws%ws%ws", szSysDir, szName, szLangId, szFileExt);
        CopyFileW(szSrchDir, szTmpFile, FALSE);
    }
    else {
        szName = (LPWSTR) ((bCounterFile) ? (sz004CtrLangFile) : (sz004HlpLangFile));
        hError = StringCchPrintfW(szTmpFile, dwSrchDir, L"%ws\\%ws.tmp", szSysDir, szName);
        DeleteFileW(szTmpFile);
        MoveFileW(szSrchDir, szTmpFile);
    }

Cleanup:
    FREEMEM(szSrchDir);
}

VOID
Perflib004Update(
    IN  LPWSTR pLangIdRequest
)
{
    LPWSTR  szSysDir  = NULL;
    LPWSTR  szTmpFile = NULL;
    LPWSTR  szRtnLang = NULL;
    DWORD   dwSysDir;
    DWORD   dwTmpDir;
    HRESULT hError;

    if (GetLangIdFromSzLang(pLangIdRequest) != LANG_CHINESE) goto Cleanup;

    dwSysDir = GetSystemDirectoryW(NULL, 0);
    dwTmpDir = lstrlenW(szCtrSubLangFile) + 5 + lstrlenW(szFileExt) + 1; // 5 is for LangId
    if (dwSysDir == 0) goto Cleanup;

    szSysDir = (LPWSTR) ALLOCMEM(sizeof(WCHAR) * (dwSysDir + 1 + dwTmpDir + 5));
    if (szSysDir == NULL) goto Cleanup;

    szRtnLang = szSysDir  + dwSysDir + 1;
    szTmpFile = szRtnLang + 5;

    // Search whether PERFC004.DAT and PRFC0?04.DAT are in System32 directory
    //
    if (GetSystemDirectoryW(szSysDir, dwSysDir + 1) == 0)
        goto Cleanup;

    if (SearchPathW(szSysDir, sz004CtrLangFile, NULL, 0, NULL, NULL) == 0)
        goto Cleanup;

    PerfGetLangId(szRtnLang);
    hError = StringCchPrintfW(szTmpFile, dwTmpDir, L"%ws%ws%ws", szCtrSubLangFile, szRtnLang, szFileExt);
    if (SearchPathW(szSysDir, szTmpFile, NULL, 0, NULL, NULL) == 0)
        goto Cleanup;

    // Found PERFC004.DAT, assume that PERFH004.DAT is also there.
    // Rename to PRFC0?04.DAT/PRFH0?04.DAT
    //
    PerflibRename004File(szSysDir, szRtnLang, TRUE);
    PerflibRename004File(szSysDir, szRtnLang, FALSE);
    PerflibRename004File(szSysDir, NULL,      TRUE);
    PerflibRename004File(szSysDir, NULL,      FALSE);

Cleanup:
    FREEMEM(szSysDir);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\perfsec.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1994   Microsoft Corporation

Module Name:

    perfsec.c

Abstract:

    This file implements the _access checking functions used by the
    performance registry API's

Author:

    Bob Watson (a-robw)

Revision History:

    8-Mar-95    Created (and extracted from Perflib.c

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "ntconreg.h"
#include "perflib.h"
#pragma warning(default:4306)

#define INITIAL_SID_BUFFER_SIZE     4096
#define FREE_IF_ALLOC(x)    if ((x) != NULL) {FREEMEM(x);}

BOOL
TestTokenForPriv(
    HANDLE hToken,
	LPTSTR	szPrivName
)
/***************************************************************************\
* TestTokenForPriv
*
* Returns TRUE if the token passed has the specified privilege
*
* The token handle passed must have TOKEN_QUERY access.
*
* History:
* 03-07-95 a-robw		Created
\***************************************************************************/
{
	BOOL		bStatus;
	LUID		PrivLuid;
	PRIVILEGE_SET	PrivSet;
	LUID_AND_ATTRIBUTES	PrivLAndA[1];

	BOOL		bReturn = FALSE;

	// get value of priv

	bStatus = LookupPrivilegeValue (
		NULL,
		szPrivName,
		&PrivLuid);

	if (!bStatus) {
		// unable to lookup privilege
		goto Exit_Point;
	}

	// build Privilege Set for function call

	PrivLAndA[0].Luid = PrivLuid;
	PrivLAndA[0].Attributes = 0;

	PrivSet.PrivilegeCount = 1;
	PrivSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
	PrivSet.Privilege[0] = PrivLAndA[0];

	// check for the specified priv in the token

	bStatus = PrivilegeCheck (
		hToken,
		&PrivSet,
		&bReturn);

	if (bStatus) {
		SetLastError (ERROR_SUCCESS);
	}

    //
    // Tidy up
    //
Exit_Point:

    return(bReturn);
}

BOOL
TestClientForPriv (
	BOOL	*pbThread,
	LPTSTR	szPrivName
)
/***************************************************************************\
* TestClientForPriv
*
* Returns TRUE if our client has the specified privilege
* Otherwise, returns FALSE.
*
\***************************************************************************/
{
    BOOL bResult;
    BOOL bIgnore;
	DWORD	dwLastError;

	BOOL	bThreadFlag = FALSE; // assume data is from process or an error occurred

    HANDLE hClient;

	SetLastError (ERROR_SUCCESS);

    bResult = OpenThreadToken(GetCurrentThread(),	// This Thread
                             TOKEN_QUERY,           	//DesiredAccess
							 FALSE,					// use context of calling thread
                             &hClient);           	//TokenHandle
    if (!bResult) {
		// unable to get a Thread Token, try a Process Token
	    bResult = OpenProcessToken(GetCurrentProcess(),	// This Process
                             TOKEN_QUERY,           	//DesiredAccess
                             &hClient);           		//TokenHandle
	} else {
		// data is from current THREAD
		bThreadFlag = TRUE;
	}

    if (bResult) {
		try {
        	bResult = TestTokenForPriv( hClient, szPrivName );
        } except (EXCEPTION_EXECUTE_HANDLER) {
			bResult = FALSE;
		}
        bIgnore = CloseHandle( hClient );
        ASSERT(bIgnore == TRUE);
	} else {
		dwLastError = GetLastError ();
	}

	// set thread flag if present
	if (pbThread != NULL) {
		try {
			*pbThread = bThreadFlag;
        } except (EXCEPTION_EXECUTE_HANDLER) {
			SetLastError (ERROR_INVALID_PARAMETER);
		}
	}

    return(bResult);
}

LONG
GetProcessNameColMeth (
    VOID
)
{
    NTSTATUS            Status;
    HANDLE              hPerflibKey;
    OBJECT_ATTRIBUTES   oaPerflibKey;
    UNICODE_STRING      PerflibSubKeyString;
    UNICODE_STRING      NameInfoValueString;
    LONG                lReturn = PNCM_SYSTEM_INFO;
    PKEY_VALUE_PARTIAL_INFORMATION    pKeyInfo;
    DWORD               dwBufLen;
    DWORD               dwRetBufLen;
    PDWORD              pdwValue;

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    InitializeObjectAttributes(
            &oaPerflibKey,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                MAXIMUM_ALLOWED,
                &oaPerflibKey
                );

    if (NT_SUCCESS (Status)) {
        // registry key opened, now read value.
        // allocate enough room for the structure, - the last
        // UCHAR in the struct, but + the data buffer (a dword)

        dwBufLen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) -
            sizeof(UCHAR) + sizeof (DWORD);

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCMEM (dwBufLen);

        if (pKeyInfo != NULL) {
            // initialize value name string
            RtlInitUnicodeString (
                &NameInfoValueString,
                L"CollectUnicodeProcessNames");

            dwRetBufLen = 0;
            Status = NtQueryValueKey (
                hPerflibKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                // check value of return data buffer
                pdwValue = (PDWORD)&pKeyInfo->Data[0];
                if (*pdwValue == PNCM_MODULE_FILE) {
                    lReturn = PNCM_MODULE_FILE;
                } else {
                    // all other values will cause this routine to return
                    // the default value of PNCM_SYSTEM_INFO;
                }
            }

            FREEMEM (pKeyInfo);
        }
        // close handle
        NtClose (hPerflibKey);
    }

    return lReturn;
}

LONG
GetPerfDataAccess (
    VOID
)
{
    NTSTATUS            Status;
    HANDLE              hPerflibKey;
    OBJECT_ATTRIBUTES   oaPerflibKey;
    UNICODE_STRING      PerflibSubKeyString;
    UNICODE_STRING      NameInfoValueString;
    LONG                lReturn = CPSR_EVERYONE;
    PKEY_VALUE_PARTIAL_INFORMATION    pKeyInfo;
    DWORD               dwBufLen;
    DWORD               dwRetBufLen;
    PDWORD              pdwValue;

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    InitializeObjectAttributes(
            &oaPerflibKey,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                MAXIMUM_ALLOWED,
                &oaPerflibKey
                );

    if (NT_SUCCESS (Status)) {
        // registry key opened, now read value.
        // allocate enough room for the structure, - the last
        // UCHAR in the struct, but + the data buffer (a dword)

        dwBufLen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) -
            sizeof(UCHAR) + sizeof (DWORD);

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCMEM (dwBufLen);

        if (pKeyInfo != NULL) {

            // see if the user right should be checked

            // init value name string
            RtlInitUnicodeString (
                &NameInfoValueString,
                L"CheckProfileSystemRight");

            dwRetBufLen = 0;
            Status = NtQueryValueKey (
                hPerflibKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                // check value of return data buffer
                pdwValue = (PDWORD)&pKeyInfo->Data[0];
                if (*pdwValue == CPSR_CHECK_ENABLED) {
                    lReturn = CPSR_CHECK_PRIVS;
                } else {
                    // all other values will cause this routine to return
                    // the default value of CPSR_EVERYONE
                }
            }

            FREEMEM (pKeyInfo);
        }
        // close handle
        NtClose (hPerflibKey);
    }

    return lReturn;
}

BOOL
TestClientForAccess ( 
    VOID
)
/***************************************************************************\
* TestClientForAccess
*
* Returns TRUE if our client is allowed to read the perflib key.
* Otherwise, returns FALSE.
*
\***************************************************************************/
{
    HKEY hKeyPerflib;
    DWORD   dwStatus;
    BOOL bResult = FALSE;

    dwStatus = RegOpenKeyExW(
       HKEY_LOCAL_MACHINE,
       L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib",
       0L,
       KEY_READ,
       & hKeyPerflib);

    if (dwStatus == ERROR_SUCCESS) {
        RegCloseKey(hKeyPerflib);
        bResult = TRUE;
    }

    return (bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\sources.inc ===
TARGETNAME=perflib
TARGETPATH=obj
TARGETTYPE=LIBRARY

PASS1_PUBLISH={$(O)\perflib.lib=$(PROJECT_LIB_PATH)\perflib.lib}

INCLUDES=\
    ..\..;\
    $(PROJECT_ROOT)\screg\winreg\idl\$(O);\
    $(PROJECT_ROOT)\screg\winreg\prflbmsg\$(O);$(WINDOWS_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\perflib.c \
        ..\perfname.c \
        ..\perfsec.c \
        ..\utils.c \
        ..\extlib.c \
        ..\extinit.c \
        ..\extquery.c

LINKLIBS= $(BASE_LIB_PATH)\wmiclnt.lib

C_DEFINES=$(C_DEFINES) -DWIN32 -DSTRICT -D_ADVAPI32_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\prflbmsg\dummy.c ===
int
DummyEntryPoint(void)
{
    return 1 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\regconn\shutinit.c ===
#include <shutinit_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\perflib\utils.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1997   Microsoft Corporation

Module Name:

    utils.c

Abstract:

        Utility functions used by the performance library functions

Author:

    Russ Blake  11/15/91

Revision History:


--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <prflbmsg.h>
#include <regrpc.h>
#include "ntconreg.h"
#include "perflib.h"
#pragma warning(default:4306)

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < '0') ? INVALID : \
     (c > '9') ? INVALID : \
     DIGIT)

#define MAX_KEYWORD_LEN   (sizeof (ADDHELP_STRING) / sizeof(WCHAR))
const   WCHAR GLOBAL_STRING[]     = L"GLOBAL";
const   WCHAR FOREIGN_STRING[]    = L"FOREIGN";
const   WCHAR COSTLY_STRING[]     = L"COSTLY";
const   WCHAR COUNTER_STRING[]    = L"COUNTER";
const   WCHAR HELP_STRING[]       = L"EXPLAIN";
const   WCHAR HELP_STRING2[]      = L"HELP";
const   WCHAR ADDCOUNTER_STRING[] = L"ADDCOUNTER";
const   WCHAR ADDHELP_STRING[]    = L"ADDEXPLAIN";
const   WCHAR ONLY_STRING[]       = L"ONLY";
const   WCHAR DisablePerformanceCounters[] = L"Disable Performance Counters";

// minimum length to hold a value name understood by Perflib

const   DWORD VALUE_NAME_LENGTH = ((sizeof(COSTLY_STRING) * 2) + sizeof(UNICODE_NULL));

#define PL_TIMER_START_EVENT    0
#define PL_TIMER_EXIT_EVENT     1
#define PL_TIMER_NUM_OBJECTS    2

static HANDLE   hTimerHandles[PL_TIMER_NUM_OBJECTS] = {NULL,NULL};

static  HANDLE  hTimerDataMutex = NULL;
static  HANDLE  hPerflibTimingThread   = NULL;
static  LPOPEN_PROC_WAIT_INFO   pTimerItemListHead = NULL;
#define PERFLIB_TIMER_INTERVAL  200     // 200 ms Timer
#define PERFLIB_TIMEOUT_COUNT    64

extern HANDLE hEventLog;

#ifdef DBG
#include <stdio.h> // for _vsnprintf
#define DEBUG_BUFFER_LENGTH MAX_PATH*2

ULONG PerfLibDebug = 0;
UCHAR PerfLibDebugBuffer[DEBUG_BUFFER_LENGTH];
#endif

RTL_CRITICAL_SECTION PerfpCritSect;


//
//  Perflib functions:
//
NTSTATUS
GetPerflibKeyValue (
    IN      LPCWSTR szItem,
    IN      DWORD   dwRegType,
    IN      DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    OUT     LPVOID  pReturnBuffer,
    IN      DWORD   dwDefaultSize,  // ... of pDefault in bytes
    IN      LPVOID  pDefault,
    IN OUT  PHKEY   pKey
)
/*++

    read and return the current value of the specified value
    under the Perflib registry key. If unable to read the value
    return the default value from the argument list.

    the value is returned in the pReturnBuffer.

    NOTE: if pKey is NULL, this routine will open and close a local key
          if pKey is not NULL, this routine will return the handle to the
          Perflib regkey and the caller is responsible for closing it.

--*/
{

    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          PerflibSubKeyString;
    UNICODE_STRING          ValueNameString;
    LONG                    lReturn = STATUS_SUCCESS;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation;
    ULONG                   ValueBufferLength;
    ULONG                   ResultLength;
    BOOL                    bUseDefault = TRUE;

    Status = STATUS_SUCCESS;
    hPerflibKey = NULL;
    if (pKey != NULL) {
        hPerflibKey = *pKey;
    }
    if (hPerflibKey == NULL) {
        // initialize UNICODE_STRING structures used in this function

        RtlInitUnicodeString (
            &PerflibSubKeyString,
            (LPCWSTR)L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

        RtlInitUnicodeString (
            &ValueNameString,
            (LPWSTR)szItem);

        //
        // Initialize the OBJECT_ATTRIBUTES structure and open the key.
        //
        InitializeObjectAttributes(
                &Obja,
                &PerflibSubKeyString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

        Status = NtOpenKey(
                    &hPerflibKey,
                    KEY_READ,
                    &Obja
                    );
    }

    if (NT_SUCCESS( Status )) {
        // read value of desired entry

        ValueBufferLength = ResultLength = 1024;
        pValueInformation = ALLOCMEM(ResultLength);

        if (pValueInformation != NULL) {
            while ( (Status = NtQueryValueKey(hPerflibKey,
                                            &ValueNameString,
                                            KeyValuePartialInformation,
                                            pValueInformation,
                                            ValueBufferLength,
                                            &ResultLength))
                    == STATUS_BUFFER_OVERFLOW ) {

                FREEMEM(pValueInformation);
                pValueInformation = ALLOCMEM(ResultLength);
                if ( pValueInformation == NULL) {
                    ValueBufferLength = 0;
                    Status = STATUS_NO_MEMORY;
                    break;
                } else {
                    ValueBufferLength = ResultLength;
                }
            }

            if (NT_SUCCESS(Status)) {
                // check to see if it's the desired type
                if (pValueInformation->Type == dwRegType) {
                    // see if it will fit
                    if (pValueInformation->DataLength <= dwMaxSize) {
                        memcpy (pReturnBuffer, &pValueInformation->Data[0],
                            pValueInformation->DataLength);
                        bUseDefault = FALSE;
                        lReturn = STATUS_SUCCESS;
                    }
                }
            } else {
                // return the default value
                lReturn = Status;
            }
            // release temp buffer
            if (pValueInformation) {
                FREEMEM (pValueInformation);
            }
        } else {
            // unable to allocate memory for this operation so
            // just return the default value
        }
        if (pKey == NULL) {
            // close the local registry key
            NtClose(hPerflibKey);
        }
        else {
            *pKey = hPerflibKey;
        }
    } else {
        // return default value
    }

    if (bUseDefault) {
        memcpy (pReturnBuffer, pDefault, dwDefaultSize);
        lReturn = STATUS_SUCCESS;
    }

    return lReturn;
}

BOOL
MatchString (
    IN LPCWSTR lpValueArg,
    IN LPCWSTR lpNameArg
)
/*++

MatchString

    return TRUE if lpName is in lpValue.  Otherwise return FALSE

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

    IN lpName
        string for one of the keyword names

Return TRUE | FALSE

--*/
{
    BOOL    bFound      = TRUE; // assume found until contradicted
    LPWSTR  lpValue     = (LPWSTR)lpValueArg;
    LPWSTR  lpName      = (LPWSTR)lpNameArg;

    // check to the length of the shortest string

    while ((*lpValue != 0) && (*lpName != 0)) {
        if (*lpValue++ != *lpName++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    return (bFound);
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    QUERY_COUNTER
        if lpValue == pointer to "Counter" string

    QUERY_HELP
        if lpValue == pointer to "Explain" string

    QUERY_ADDCOUNTER
        if lpValue == pointer to "Addcounter" string

    QUERY_ADDHELP
        if lpValue == pointer to "Addexplain" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   LocalBuff[MAX_KEYWORD_LEN+1];
    WORD    i;

    if (lpValue == 0 || *lpValue == 0)
        return QUERY_GLOBAL;

    // convert the input string to Upper case before matching
    for (i=0; i < MAX_KEYWORD_LEN; i++) {
        if (*lpValue == TEXT(' ') || *lpValue == TEXT('\0')) {
            break;
        }
        LocalBuff[i] = *lpValue ;
        if (*lpValue >= TEXT('a') && *lpValue <= TEXT('z')) {
            LocalBuff[i]  = LocalBuff[i] - TEXT('a') + TEXT('A');
        }
        lpValue++ ;
    }
    LocalBuff[i] = TEXT('\0');

    // check for "Global" request
    if (MatchString (LocalBuff, GLOBAL_STRING))
        return QUERY_GLOBAL ;

    // check for "Foreign" request
    if (MatchString (LocalBuff, FOREIGN_STRING))
        return QUERY_FOREIGN ;

    // check for "Costly" request
    if (MatchString (LocalBuff, COSTLY_STRING))
        return QUERY_COSTLY;

    // check for "Counter" request
    if (MatchString (LocalBuff, COUNTER_STRING))
        return QUERY_COUNTER;

    // check for "Help" request
    if (MatchString (LocalBuff, HELP_STRING))
        return QUERY_HELP;

    if (MatchString (LocalBuff, HELP_STRING2))
        return QUERY_HELP;

    // check for "AddCounter" request
    if (MatchString (LocalBuff, ADDCOUNTER_STRING))
        return QUERY_ADDCOUNTER;

    // check for "AddHelp" request
    if (MatchString (LocalBuff, ADDHELP_STRING))
        return QUERY_ADDHELP;

    // None of the above, then it must be an item list
    return QUERY_ITEMS;

}

DWORD
GetNextNumberFromList (
    IN LPWSTR   szStartChar,
    IN LPWSTR   *szNextChar
)
/*++

 Reads a character string from the szStartChar to the next
 delimiting space character or the end of the string and returns
 the value of the decimal number found. If no valid number is found
 then 0 is returned. The pointer to the next character in the
 string is returned in the szNextChar parameter. If the character
 referenced by this pointer is 0, then the end of the string has
 been reached.

--*/
{
    DWORD   dwThisNumber    = 0;
    WCHAR   *pwcThisChar    = szStartChar;
    WCHAR   wcDelimiter     = L' ';
    BOOL    bValidNumber    = FALSE;

    if (szStartChar != 0) {
        do {
            switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
                case DIGIT:
                    // if this is the first digit after a delimiter, then
                    // set flags to start computing the new number
                    bValidNumber = TRUE;
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                    break;

                case DELIMITER:
                    // a delimter is either the delimiter character or the
                    // end of the string ('\0') if when the delimiter has been
                    // reached a valid number was found, then return it
                    //
                    if (bValidNumber || (*pwcThisChar == 0)) {
                        *szNextChar = pwcThisChar;
                        return dwThisNumber;
                    } else {
                        // continue until a non-delimiter char or the
                        // end of the file is found
                    }
                    break;

                case INVALID:
                    // if an invalid character was encountered, ignore all
                    // characters up to the next delimiter and then start fresh.
                    // the invalid number is not compared.
                    bValidNumber = FALSE;
                    break;

                default:
                    break;

            }
            pwcThisChar++;
        } while (pwcThisChar != NULL);    // always TRUE - avoid W4 warning
        return 0;
    } else {
        *szNextChar = szStartChar;
        return 0;
    }
}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;

    while (*pwcThisChar != 0) {
        dwThisNumber = GetNextNumberFromList (
            pwcThisChar, &pwcThisChar);
        if (dwNumber == dwThisNumber) return TRUE;
    }
    // if here, then the number wasn't found
    return FALSE;

}   // IsNumberInUnicodeList

BOOL
MonBuildPerfDataBlock(
    PERF_DATA_BLOCK *pBuffer,
    PVOID *pBufferNext,
    DWORD NumObjectTypes,
    DWORD DefaultObject
)
/*++

    MonBuildPerfDataBlock -     build the PERF_DATA_BLOCK structure

        Inputs:

            pBuffer         -   where the data block should be placed

            pBufferNext     -   where pointer to next byte of data block
                                is to begin; DWORD aligned

            NumObjectTypes  -   number of types of objects being reported

            DefaultObject   -   object to display by default when
                                this system is selected; this is the
                                object type title index
--*/

{
    // Initialize Signature and version ID for this data structure

    pBuffer->Signature[0] = L'P';
    pBuffer->Signature[1] = L'E';
    pBuffer->Signature[2] = L'R';
    pBuffer->Signature[3] = L'F';

    pBuffer->LittleEndian = TRUE;

    pBuffer->Version = PERF_DATA_VERSION;
    pBuffer->Revision = PERF_DATA_REVISION;

    //
    //  The next field will be filled in at the end when the length
    //  of the return data is known
    //

    pBuffer->TotalByteLength = 0;

    pBuffer->NumObjectTypes = NumObjectTypes;
    pBuffer->DefaultObject = DefaultObject;
    GetSystemTime(&pBuffer->SystemTime);
    NtQueryPerformanceCounter(&pBuffer->PerfTime,&pBuffer->PerfFreq);
    GetSystemTimeAsFileTime ((FILETIME *)&pBuffer->PerfTime100nSec.QuadPart);

    if ( ComputerNameLength ) {

        //  There is a Computer name: i.e., the network is installed

        pBuffer->SystemNameLength = ComputerNameLength;
        pBuffer->SystemNameOffset = sizeof(PERF_DATA_BLOCK);
        RtlMoveMemory(&pBuffer[1],
               pComputerName,
               ComputerNameLength);
        *pBufferNext = (PVOID) ((PCHAR) &pBuffer[1] +
                                QWORD_MULTIPLE(ComputerNameLength));
        pBuffer->HeaderLength = (DWORD)((PCHAR) *pBufferNext - (PCHAR) pBuffer);
    } else {

        // Member of Computers Anonymous

        pBuffer->SystemNameLength = 0;
        pBuffer->SystemNameOffset = 0;
        *pBufferNext = &pBuffer[1];
        pBuffer->HeaderLength = sizeof(PERF_DATA_BLOCK);
    }

    return 0;
}

//
// Timer functions
//
DWORD
PerflibTimerFunction (
    LPDWORD dwArg
)
/*++

 PerflibTimerFunction

    Timing thread used to write an event log message if the timer expires.

    This thread runs until the Exit event is set or the wait for the
    Exit event times out.

    While the start event is set, then the timer checks the current events
    to be timed and reports on any that have expired. It then sleeps for
    the duration of the timing interval after which it checks the status
    of the start & exit events to begin the next cycle.

    The timing events are added and deleted from the list only by the
    StartPerflibFunctionTimer and KillPerflibFunctionTimer functions.

 Arguments

    dwArg -- Not Used

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    BOOL                    bKeepTiming = TRUE;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo;
    LPWSTR                  szMessageArray[2];
    LARGE_INTEGER           liWaitTime;

    UNREFERENCED_PARAMETER (dwArg);

    DebugPrint ((5, "\nPERFLIB: Entering Timing Thread: PID: %d, TID: %d", 
        GetCurrentProcessId(), GetCurrentThreadId()));

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& PerflibGuid,
           __LINE__,
           PERF_TIMERFUNCTION,
           0,
           STATUS_SUCCESS,
           NULL));

    while (bKeepTiming) {
        liWaitTime.QuadPart =
            MakeTimeOutValue((PERFLIB_TIMING_THREAD_TIMEOUT));
        // wait for either the start or exit event flags to be set
        NtStatus = NtWaitForMultipleObjects (
                PL_TIMER_NUM_OBJECTS,
                &hTimerHandles[0],
                WaitAny,          //wait for either one to be set
                FALSE,            // not alertable
                &liWaitTime);

        if ((NtStatus != STATUS_TIMEOUT) &&
            (NtStatus <= STATUS_WAIT_3)) {
            if ((NtStatus - STATUS_WAIT_0) == PL_TIMER_EXIT_EVENT ) {
              DebugPrint ((5, "\nPERFLIB: Timing Thread received Exit Event (1): PID: %d, TID: %d", 
                    GetCurrentProcessId(), GetCurrentThreadId()));

                // then that's all
                bKeepTiming = FALSE;
                NtStatus = STATUS_SUCCESS;
                break;
            } else if ((NtStatus - STATUS_WAIT_0) == PL_TIMER_START_EVENT) {
                DebugPrint ((5, "\nPERFLIB: Timing Thread received Start Event: PID: %d, TID: %d", 
                    GetCurrentProcessId(), GetCurrentThreadId()));
                // then the timer is running so wait the interval period
                // wait on exit event here to prevent hanging
                liWaitTime.QuadPart =
                    MakeTimeOutValue((PERFLIB_TIMER_INTERVAL));
                NtStatus = NtWaitForSingleObject (
                        hTimerHandles[PL_TIMER_EXIT_EVENT],
                        FALSE,
                        &liWaitTime);

                if (NtStatus == STATUS_TIMEOUT) {
                    // then the wait time expired without being told
                    // to terminate the thread so
                    // now evaluate the list of timed events
                    // lock the data mutex
                    DWORD dwTimeOut = 0;

                    DebugPrint ((5, "\nPERFLIB: Timing Thread Evaluating Entries: PID: %d, TID: %d", 
                        GetCurrentProcessId(), GetCurrentThreadId()));

                    liWaitTime.QuadPart =
                        MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 2));

                    NtStatus = STATUS_TIMEOUT;
                    while (   NtStatus == STATUS_TIMEOUT
                           && dwTimeOut < PERFLIB_TIMEOUT_COUNT) {
                        NtStatus = NtWaitForSingleObject (
                                hTimerDataMutex,
                                FALSE,
                                & liWaitTime);
                        if (NtStatus == STATUS_TIMEOUT) {
                            dwTimeOut ++;
                            DebugPrint((5, "\nPERFLIB:NtWaitForSingleObject(TimerDataMutex,%d) time out for the %dth time. PID: %d, TID: %d",
                                    liWaitTime, dwTimeOut,
                                    GetCurrentProcessId(),
                                    GetCurrentThreadId()));
                            TRACE((WINPERF_DBG_TRACE_WARNING),
                                  (& PerflibGuid,
                                   __LINE__,
                                   PERF_TIMERFUNCTION,
                                   0,
                                   STATUS_TIMEOUT,
                                   & dwTimeOut, sizeof(dwTimeOut),
                                   NULL));
                        }
                    }

                    if (NtStatus != STATUS_WAIT_0) {
                        // cannot grab hTimerDataMutex, there is no guarantee
                        // that this is the exclusive one to work on
                        // pTimerItemListHead list, so just bail out.
                        //
                        bKeepTiming = FALSE;
                        NtStatus    = STATUS_SUCCESS;
                        TRACE((WINPERF_DBG_TRACE_WARNING),
                              (& PerflibGuid,
                               __LINE__,
                               PERF_TIMERFUNCTION,
                               0,
                               NtStatus,
                               NULL));
                        break;
                    }
                    else {
                        for (pLocalInfo = pTimerItemListHead;
                            pLocalInfo != NULL;
                            pLocalInfo = pLocalInfo->pNext) {

                              DebugPrint ((5, "\nPERFLIB: Timing Thread Entry %X. count %d: PID: %d, TID: %d", 
                              pLocalInfo, pLocalInfo->dwWaitTime,
                              GetCurrentProcessId(), GetCurrentThreadId()));

                            if (pLocalInfo->dwWaitTime > 0) {
                                if (pLocalInfo->dwWaitTime == 1) {
                                    if (THROTTLE_PERFLIB(pLocalInfo->dwEventMsg)) {
                                        // then this is the last interval so log error
                                        // if this DLL hasn't already been disabled

                                        szMessageArray[0] = pLocalInfo->szServiceName;
                                        szMessageArray[1] = pLocalInfo->szLibraryName;

                                        ReportEvent (hEventLog,
                                            EVENTLOG_ERROR_TYPE,  // error type
                                            0,                    // category (not used)
                                            (DWORD)pLocalInfo->dwEventMsg, // event,
                                            NULL,                 // SID (not used),
                                            2,                    // number of strings
                                            0,                    // sizeof raw data
                                            szMessageArray,       // message text array
                                            NULL);                // raw data
                                    }

                                    if (pLocalInfo->pData != NULL) {
                                        if (lPerflibConfigFlags & PLCF_ENABLE_TIMEOUT_DISABLE) {
                                            if (!(((PEXT_OBJECT)pLocalInfo->pData)->dwFlags & PERF_EO_DISABLED)) {
                                                // then pData is an extensible counter data block
                                                // disable the ext. counter
                                                DisablePerfLibrary((PEXT_OBJECT) pLocalInfo->pData,
                                                                   PERFLIB_DISABLE_ALL);
                                            } // end if not already disabled
                                        } // end if disable DLL on Timeouts is enabled
                                    } // data is NULL so skip
                                } 
                                pLocalInfo->dwWaitTime--;
                            }
                        }
                        ReleaseMutex (hTimerDataMutex);
                    }
                } else {
                  DebugPrint ((5, "\nPERFLIB: Timing Thread received Exit Event (2): PID: %d, TID: %d", 
                     GetCurrentProcessId(), GetCurrentThreadId()));

                    // we've been told to exit so
                    NtStatus = STATUS_SUCCESS;
                    bKeepTiming = FALSE;
                    break;
                }
            } else {
                // some unexpected error was returned
                assert (FALSE);
            }
        } else {
            DebugPrint ((5, "\nPERFLIB: Timing Thread Timed out: PID: %d, TID: %d", 
                GetCurrentProcessId(), GetCurrentThreadId()));
            // the wait timed out so it's time to go
            NtStatus = STATUS_SUCCESS;
            bKeepTiming = FALSE;
            break;
        }
    }

    DebugPrint ((5, "\nPERFLIB: Leaving Timing Thread: PID: %d, TID: %d", 
        GetCurrentProcessId(), GetCurrentThreadId()));

    return PerfpDosError(NtStatus);
}

HANDLE
StartPerflibFunctionTimer (
    IN  LPOPEN_PROC_WAIT_INFO pInfo
)
/*++

    Starts a timing event by adding it to the list of timing events.
    If the timer thread is not running, then the is started as well.

    If this is the first event in the list then the Start Event is
    set indicating that the timing thread can begin processing timing
    event(s).

--*/
{
    LONG    Status = ERROR_SUCCESS;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo = NULL;
    DWORD   dwLibNameLen = 0;
    DWORD   dwBufferLength = sizeof (OPEN_PROC_WAIT_INFO);
    LARGE_INTEGER   liWaitTime;
    HANDLE  hReturn = NULL;
    HANDLE  hDataMutex;

    if (pInfo == NULL) {
        // no required argument
        Status = ERROR_INVALID_PARAMETER;
    } else {
        // check on or create sync objects

        // allocate timing events for the timing thread
        if (hTimerHandles[PL_TIMER_START_EVENT] == NULL) {
            // create the event as NOT signaled since we're not ready to start
            hTimerHandles[PL_TIMER_START_EVENT] = CreateEvent (NULL, TRUE, FALSE, NULL);
            if (hTimerHandles[PL_TIMER_START_EVENT] == NULL) {
                Status = GetLastError();
            }
        }

        if (hTimerHandles[PL_TIMER_EXIT_EVENT] == NULL) {
            hTimerHandles[PL_TIMER_EXIT_EVENT] = CreateEvent (NULL, TRUE, FALSE, NULL);
            if (hTimerHandles[PL_TIMER_EXIT_EVENT] == NULL) {
            Status = GetLastError();
            }
        }

        // create data sync mutex if it hasn't already been created
        if (hTimerDataMutex  == NULL) {
            hDataMutex = CreateMutex(NULL, FALSE, NULL);
            if (hDataMutex == NULL) {
                Status = GetLastError();
            }
            else {
                if (InterlockedCompareExchangePointer(& hTimerDataMutex,
                        hDataMutex,
                        NULL) != NULL) {
                    CloseHandle(hDataMutex);
                    hDataMutex = NULL;
                }
                else {
                    hTimerDataMutex = hDataMutex;
                }
            }
        }
    }

    if (Status == ERROR_SUCCESS) {
        // continue creating timer entry
        if (hPerflibTimingThread != NULL) {
    	    // see if the handle is valid (i.e the thread is alive)
            Status = WaitForSingleObject (hPerflibTimingThread, 0);
    	    if (Status == WAIT_OBJECT_0) {
                // the thread has terminated so close the handle
                CloseHandle (hPerflibTimingThread);
    	        hPerflibTimingThread = NULL;
    	        Status = ERROR_SUCCESS;
    	    } else if (Status == WAIT_TIMEOUT) {
		// the thread is still running so continue
		Status = ERROR_SUCCESS;
    	    } else {
		// some other, probably serious, error
		// so pass it on through
	    }
        } else {
	        // the thread has never been created yet so continue
        }

        if (hPerflibTimingThread == NULL) {
            // create the timing thread

            assert (pTimerItemListHead == NULL);    // there should be no entries, yet

            // everything is ready for the timer thread

            hPerflibTimingThread = CreateThread (
                NULL, 0,
                (LPTHREAD_START_ROUTINE)PerflibTimerFunction,
                NULL, 0, NULL);

            assert (hPerflibTimingThread != NULL);
            if (hPerflibTimingThread == NULL) {
                Status = GetLastError();
            }
        }

        if (Status == ERROR_SUCCESS) {

            // compute the length of the required buffer;

            dwLibNameLen = (lstrlenW (pInfo->szLibraryName) + 1) * sizeof(WCHAR);
            dwBufferLength += dwLibNameLen;
            dwBufferLength += (lstrlenW (pInfo->szServiceName) + 1) * sizeof(WCHAR);
            dwBufferLength = QWORD_MULTIPLE (dwBufferLength);

            pLocalInfo = ALLOCMEM (dwBufferLength);
            if (pLocalInfo == NULL)
                Status = ERROR_OUTOFMEMORY;
        }
        if ((Status == ERROR_SUCCESS) && (pLocalInfo != NULL)) {

            // copy the arg buffer to the local list

            pLocalInfo->szLibraryName = (LPWSTR)&pLocalInfo[1];
            lstrcpyW (pLocalInfo->szLibraryName, pInfo->szLibraryName);
            pLocalInfo->szServiceName = (LPWSTR)
                ((LPBYTE)pLocalInfo->szLibraryName + dwLibNameLen);
            lstrcpyW (pLocalInfo->szServiceName, pInfo->szServiceName);
            // convert wait time in milliseconds to the number of "loops"
            pLocalInfo->dwWaitTime = pInfo->dwWaitTime / PERFLIB_TIMER_INTERVAL;
            if (pLocalInfo->dwWaitTime  == 0) pLocalInfo->dwWaitTime =1; // have at least 1 loop
            pLocalInfo->dwEventMsg = pInfo->dwEventMsg;
            pLocalInfo->pData = pInfo->pData;

            // wait for access to the data
            if (hTimerDataMutex != NULL) {
                NTSTATUS NtStatus;
                liWaitTime.QuadPart =
                    MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 2));

                NtStatus = NtWaitForSingleObject (
                    hTimerDataMutex,
                    FALSE,
                    &liWaitTime);
                Status = PerfpDosError(NtStatus);
            } else {
                Status = ERROR_NOT_READY;
            }

            if (Status == WAIT_OBJECT_0) {
                DebugPrint ((5, "\nPERFLIB: Timing Thread Adding Entry: %X (%d) PID: %d, TID: %d", 
                    pLocalInfo, pLocalInfo->dwWaitTime,
                    GetCurrentProcessId(), GetCurrentThreadId()));

                // we have access to the data so add this item to the front of the list
                pLocalInfo->pNext = pTimerItemListHead;
                pTimerItemListHead = pLocalInfo;
                ReleaseMutex (hTimerDataMutex);

                if (pLocalInfo->pNext == NULL) {
                    // then the list was empty before this call so start the timer
                    // going
                    SetEvent (hTimerHandles[PL_TIMER_START_EVENT]);
                }

                hReturn = (HANDLE)pLocalInfo;
            } else {
                SetLastError (Status);
            }
        } else {
            // unable to create thread
            SetLastError (Status);
        }
    } else {
        // unable to start timer
        SetLastError (Status);
    }

    return hReturn;
}

DWORD
KillPerflibFunctionTimer (
    IN  HANDLE  hPerflibTimer
)
/*++

    Terminates a timing event by removing it from the list. When the last
    item is removed from the list the Start event is reset so the timing
    thread will wait for either the next start event, exit event or it's
    timeout to expire.

--*/
{
    NTSTATUS Status;
    LPOPEN_PROC_WAIT_INFO   pArg = (LPOPEN_PROC_WAIT_INFO)hPerflibTimer;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo;
    BOOL                    bFound = FALSE;
    LARGE_INTEGER           liWaitTime;
    DWORD   dwReturn = ERROR_SUCCESS;

    if (hTimerDataMutex == NULL) {
        dwReturn = ERROR_NOT_READY;
    } else if (pArg == NULL) {
        dwReturn = ERROR_INVALID_HANDLE;
    } else {
	// so far so good
        // wait for access to the data
        liWaitTime.QuadPart =
            MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 2));
        Status = NtWaitForSingleObject (
            hTimerDataMutex,
            FALSE,
            &liWaitTime);

        if (Status == STATUS_WAIT_0) {
            // we have access to the list so walk down the list and remove the
            // specified item
            // see if it's the first one in the list

            DebugPrint ((5, "\nPERFLIB: Timing Thread Removing Entry: %X (%d) PID: %d, TID: %d", 
                pArg, pArg->dwWaitTime,
                GetCurrentProcessId(), GetCurrentThreadId()));

            if (pArg == pTimerItemListHead) {
                // then remove it
                pTimerItemListHead = pArg->pNext;
                bFound = TRUE;
            } else {
                for (pLocalInfo = pTimerItemListHead;
                    pLocalInfo != NULL;
                    pLocalInfo = pLocalInfo->pNext) {
                    if (pLocalInfo->pNext == pArg) {
                        pLocalInfo->pNext = pArg->pNext;
                        bFound = TRUE;
                        break;
                    }
                }
            }
            assert (bFound);

            if (bFound) {
                // it's out of the list so release the lock
                ReleaseMutex (hTimerDataMutex);

                if (pTimerItemListHead == NULL) {
                    // then the list is empty now so stop timing
                    // going
                    ResetEvent (hTimerHandles[PL_TIMER_START_EVENT]);
                }

                // free memory

                FREEMEM (pArg);
                dwReturn = ERROR_SUCCESS;
            } else {
                dwReturn = ERROR_NOT_FOUND;
            }
        } else {
            dwReturn = ERROR_TIMEOUT;
        }
    }

    return dwReturn;
}

DWORD
DestroyPerflibFunctionTimer (
)
/*++

    Terminates the timing thread and cancels any current timer events.
    NOTE: This routine can be called even if timer thread is not started!

--*/
{
    NTSTATUS    Status   = STATUS_WAIT_0;
    LPOPEN_PROC_WAIT_INFO   pThisItem;
    LPOPEN_PROC_WAIT_INFO   pNextItem;
    LARGE_INTEGER           liWaitTime;
    HANDLE hTemp;

    if (hTimerDataMutex != NULL) {
        DWORD  dwTimeOut = 0;
        LONG   dwStatus  = ERROR_SUCCESS;

        // wait for data mutex
        liWaitTime.QuadPart =
            MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 5));

        Status = STATUS_TIMEOUT;
        while (Status == STATUS_TIMEOUT && dwTimeOut < PERFLIB_TIMEOUT_COUNT) {
            Status = NtWaitForSingleObject (
                    hTimerDataMutex,
                    FALSE,
                    & liWaitTime);
            if (Status == STATUS_TIMEOUT) {
                if (hPerflibTimingThread != NULL) {
                    // see if the handle is valid (i.e the thread is alive)
                    dwStatus = WaitForSingleObject(hPerflibTimingThread,
                                                   liWaitTime.LowPart);
                    if (dwStatus == WAIT_OBJECT_0) {
                        // the thread has terminated so close the handle
                        Status = STATUS_WAIT_0;
                    }
                }
            }
            if (Status == STATUS_TIMEOUT) {
                dwTimeOut ++;
                DebugPrint((5, "\nPERFLIB:NtWaitForSingleObject(TimerDataMutex,%d) time out for the %dth time in DestroyPErflibFunctionTimer(). PID: %d, TID: %d",
                        liWaitTime, dwTimeOut,
                        GetCurrentProcessId(),
                        GetCurrentThreadId()));
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (& PerflibGuid,
                       __LINE__,
                       PERF_DESTROYFUNCTIONTIMER,
                       0,
                       STATUS_TIMEOUT,
                       & dwTimeOut, sizeof(dwTimeOut),
                       NULL));
            }
        }

        assert (Status != STATUS_TIMEOUT);
    }

    // free all entries in the list

    if (Status == STATUS_WAIT_0) {
        for (pNextItem = pTimerItemListHead;
            pNextItem != NULL;) {
            pThisItem = pNextItem;
            pNextItem = pThisItem->pNext;
            FREEMEM (pThisItem);
        }
    }
    else {
        TRACE((WINPERF_DBG_TRACE_WARNING),
              (& PerflibGuid,
               __LINE__,
               PERF_DESTROYFUNCTIONTIMER,
               0,
               Status,
               NULL));
    }
    // all items have been freed so clear header
    pTimerItemListHead = NULL;

    // set exit event
    if (hTimerHandles[PL_TIMER_EXIT_EVENT] != NULL) {
        SetEvent (hTimerHandles[PL_TIMER_EXIT_EVENT]);
    }

    if (hPerflibTimingThread != NULL) {
        // wait for thread to terminate
        liWaitTime.QuadPart =
            MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 5));

        Status = NtWaitForSingleObject (
            hPerflibTimingThread,
            FALSE,
            &liWaitTime);

        assert (Status != STATUS_TIMEOUT);

        hTemp = hPerflibTimingThread;
	    hPerflibTimingThread = NULL;
    	CloseHandle (hTemp);
    }

    if (hTimerDataMutex != NULL) {
        hTemp = hTimerDataMutex;
        hTimerDataMutex = NULL;
        // close handles and leave
    	ReleaseMutex (hTemp);
        CloseHandle (hTemp);
    }

    if (hTimerHandles[PL_TIMER_START_EVENT] != NULL) {
        CloseHandle (hTimerHandles[PL_TIMER_START_EVENT]);
        hTimerHandles[PL_TIMER_START_EVENT] = NULL;
    }

    if (hTimerHandles[PL_TIMER_EXIT_EVENT] != NULL) {
        CloseHandle (hTimerHandles[PL_TIMER_EXIT_EVENT]);
        hTimerHandles[PL_TIMER_EXIT_EVENT] = NULL;
    }

    return ERROR_SUCCESS;
}

LONG
PrivateRegQueryValueExT (
    HKEY    hKey,
    LPVOID  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    bUnicode
)
/*
    wrapper function to allow RegQueryValues while inside a RegQueryValue

*/
{
    LONG    ReturnStatus;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
	BOOL	bStatus;

    UNICODE_STRING      usLocal = {0,0,NULL};
    PSTR                AnsiValueBuffer;
    ULONG               AnsiValueLength;
    PWSTR               UnicodeValueBuffer;
    ULONG               UnicodeValueLength;
    ULONG               Index;

    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation;
    LONG                    ValueBufferLength;
    ULONG                   ResultLength;


    UNREFERENCED_PARAMETER (lpReserved);

    if (hKey == NULL || hKey == INVALID_HANDLE_VALUE) return ERROR_INVALID_HANDLE;

    if (bUnicode) {
        bStatus = RtlCreateUnicodeString (&usLocal, (LPCWSTR)lpValueName);
    } else {
        bStatus = RtlCreateUnicodeStringFromAsciiz (&usLocal, (LPCSTR)lpValueName);
    }

    if (bStatus) {

        ValueBufferLength =
		ResultLength =
			sizeof(KEY_VALUE_PARTIAL_INFORMATION) + *lpcbData;
        pValueInformation = ALLOCMEM(ResultLength);

        if (pValueInformation != NULL) {
            ntStatus = NtQueryValueKey(
                hKey,
                &usLocal,
                KeyValuePartialInformation,
                pValueInformation,
                ValueBufferLength,
                &ResultLength);

            if ((NT_SUCCESS(ntStatus) || ntStatus == STATUS_BUFFER_OVERFLOW)) {
                // return data
                if (ARGUMENT_PRESENT(lpType)) {
                    *lpType = pValueInformation->Type;
                }

                if (ARGUMENT_PRESENT(lpcbData)) {
                    *lpcbData = pValueInformation->DataLength;
                }

                if (NT_SUCCESS(ntStatus)) {
                    if (ARGUMENT_PRESENT(lpData)) {
                        if (!bUnicode &&
                            (pValueInformation->Type == REG_SZ ||
                            pValueInformation->Type == REG_EXPAND_SZ ||
                            pValueInformation->Type == REG_MULTI_SZ)
                        ) {
                            // then convert the unicode return to an
                            // ANSI string before returning
                            // the local wide buffer used

                            UnicodeValueLength  = ResultLength;
                            UnicodeValueBuffer  = (LPWSTR)&pValueInformation->Data[0];

                            AnsiValueBuffer = (LPSTR)lpData;
                            AnsiValueLength = ARGUMENT_PRESENT( lpcbData )?
                                                     *lpcbData : 0;
                            Index = 0;
                            ntStatus = RtlUnicodeToMultiByteN(
                                AnsiValueBuffer,
                                AnsiValueLength,
                                &Index,
                                UnicodeValueBuffer,
                                UnicodeValueLength);

                            if (NT_SUCCESS( ntStatus ) &&
                                (ARGUMENT_PRESENT( lpcbData ))) {
                                *lpcbData = Index;
                            }
                        } else {
                            if (pValueInformation->DataLength <= *lpcbData) {
                                // copy the buffer to the user's buffer
                                memcpy (lpData, &pValueInformation->Data[0],
                                    pValueInformation->DataLength);
                                ntStatus = STATUS_SUCCESS;
                             } else {
                                 ntStatus = STATUS_BUFFER_OVERFLOW;
                             }
                             *lpcbData = pValueInformation->DataLength;
                        }
                    }
                }
            }

            if (pValueInformation != NULL) {
                // release temp buffer
                FREEMEM (pValueInformation);
            }
        } else {
            // unable to allocate memory for this operation so
            ntStatus = STATUS_NO_MEMORY;
        }

        RtlFreeUnicodeString (&usLocal);
    } else {
		// this is a guess at the most likely cause for the string
		// creation to fail.
		ntStatus = STATUS_NO_MEMORY;
	}

    ReturnStatus = PerfpDosError(ntStatus);

    return ReturnStatus;
}

LONG
GetPerfDllFileInfo (
    LPCWSTR             szFileName,
    PDLL_VALIDATION_DATA  pDllData
)
{
    WCHAR   szFullPath[MAX_PATH*2];
    DWORD   dwStatus = ERROR_FILE_NOT_FOUND;
    DWORD   dwRetValue;
    HANDLE  hFile;
    BOOL    bStatus;
    LARGE_INTEGER   liSize;

    szFullPath[0] = UNICODE_NULL;
    dwRetValue = SearchPathW (
        NULL,
        szFileName,
        NULL,
        sizeof(szFullPath) / sizeof(szFullPath[0]),
        szFullPath,
        NULL);

    if (dwRetValue > 0) {
        //then the file was found so open it.
        hFile = CreateFileW (
            szFullPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL, 
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            // get file creation date/time
            bStatus = GetFileTime (
                hFile,
                &pDllData->CreationDate,
                NULL, NULL);
            if (bStatus)  {
                // get file size
                liSize.LowPart  =  GetFileSize (
                    hFile, (PULONG)&liSize.HighPart);
                if (liSize.LowPart != 0xFFFFFFFF) {
                    pDllData->FileSize = liSize.QuadPart;
                    dwStatus = ERROR_SUCCESS;
                } else {
                    dwStatus = GetLastError();
                }
            } else {
                dwStatus = GetLastError();
            } 

            CloseHandle (hFile);
        } else {
            dwStatus = GetLastError();
        }
    } else {
        dwStatus = GetLastError();
    }

    return dwStatus;
}

DWORD
DisablePerfLibrary (
    PEXT_OBJECT  pObj,
    DWORD        dwValue
)
{
    // continue only if the "Disable" feature is enabled and
    // if this library hasn't already been disabled.
    if ((!(lPerflibConfigFlags & PLCF_NO_DISABLE_DLLS)) &&
        (!(pObj->dwFlags & PERF_EO_DISABLED))) {

        // set the disabled bit in the info
        pObj->dwFlags |= PERF_EO_DISABLED;
        return DisableLibrary(pObj->hPerfKey, pObj->szServiceName, dwValue);
    }
    return ERROR_SUCCESS;
}


DWORD
DisableLibrary(
    IN HKEY hPerfKey,
    IN LPWSTR szServiceName,
    IN DWORD  dwValue
)
{
    //
    // This routine will disable regardless of settings
    //
    DWORD   dwLocalValue, dwSize;
    DWORD   dwFnStatus = ERROR_SUCCESS;
    WORD    wStringIndex = 0;
    LPWSTR  szMessageArray[2];

    dwLocalValue = dwValue;
    if (dwLocalValue != 1 && dwLocalValue != 2 && dwLocalValue != 4) dwLocalValue = 1;
    // disable perf library entry in the service key
    dwSize = sizeof(dwLocalValue);
    dwFnStatus = RegSetValueExW (
            hPerfKey,
            DisablePerformanceCounters,
            0L,
            REG_DWORD,
            (LPBYTE) & dwLocalValue,
            dwSize);
        // report error

    if (dwFnStatus == ERROR_SUCCESS) {
        // system disabled
        szMessageArray[wStringIndex++] =
            szServiceName;

        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,        // error type
            0,                          // category (not used)
            (DWORD)PERFLIB_LIBRARY_DISABLED,              // event,
            NULL,                       // SID (not used),
            wStringIndex,               // number of strings
            0,                          // sizeof raw data
            szMessageArray,             // message text array
            NULL);                      // raw data
    } else {
        // local disable only
        szMessageArray[wStringIndex++] =
            szServiceName;

        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,        // error type
            0,                          // category (not used)
            (DWORD)PERFLIB_LIBRARY_TEMP_DISABLED,              // event,
            NULL,                       // SID (not used),
            wStringIndex,               // number of strings
            0,                          // sizeof raw data
            szMessageArray,             // message text array
            NULL);                      // raw data
    }
    return ERROR_SUCCESS;
}

/*
DWORD
PerfCheckRegistry(
    IN HKEY hPerfKey,
    IN LPCWSTR szServiceName
    )
{
    DWORD dwType = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwData = 0;
    DWORD status;
    WORD  wStringIndex;
    LPWSTR szMessageArray[2];

    status = PrivateRegQueryValueExA(
                hPerfKey,
                FirstCounter,
                NULL,
                &dwType,
                (LPBYTE)&dwData,
                &dwSize);

    if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD) ||
        (dwData < LAST_BASE_INDEX)) {
        wStringIndex = 0;
        szMessageArray[wStringIndex++] = (LPWSTR) FirstCounter;
        szMessageArray[wStringIndex++] = (LPWSTR) szServiceName;
        ReportEvent(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            (DWORD)PERFLIB_REGVALUE_NOT_FOUND,
            NULL,
            wStringIndex,
            0,
            szMessageArray,
            NULL);
        return FALSE;
    }

    status = PrivateRegQueryValueExA(
                hPerfKey,
                LastCounter,
                NULL,
                &dwType,
                (LPBYTE)&dwData,
                &dwSize);

    if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD) ||
        (dwData <= LAST_BASE_INDEX)) {
        wStringIndex = 0;
        szMessageArray[wStringIndex++] = (LPWSTR) LastCounter;
        szMessageArray[wStringIndex++] = (LPWSTR) szServiceName;
        ReportEvent(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            (DWORD)PERFLIB_REGVALUE_NOT_FOUND,
            NULL,
            wStringIndex,
            0,
            szMessageArray,
            NULL);
        return FALSE;
    }

    status = PrivateRegQueryValueExA(
                hPerfKey,
                FirstHelp,
                NULL,
                &dwType,
                (LPBYTE)&dwData,
                &dwSize);

    if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD) ||
        (dwData < LAST_BASE_INDEX)) {
        wStringIndex = 0;
        szMessageArray[wStringIndex++] = (LPWSTR) FirstHelp;
        szMessageArray[wStringIndex++] = (LPWSTR) szServiceName;
        ReportEvent(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            (DWORD)PERFLIB_REGVALUE_NOT_FOUND,
            NULL,
            wStringIndex,
            0,
            szMessageArray,
            NULL);
        return FALSE;
    }

    status = PrivateRegQueryValueExA(
                hPerfKey,
                LastHelp,
                NULL,
                &dwType,
                (LPBYTE)&dwData,
                &dwSize);

    if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD) ||
        (dwData <= LAST_BASE_INDEX)) {
        wStringIndex = 0;
        szMessageArray[wStringIndex++] = (LPWSTR) LastHelp;
        szMessageArray[wStringIndex++] = (LPWSTR) szServiceName;
        ReportEvent(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            (DWORD)PERFLIB_REGVALUE_NOT_FOUND,
            NULL,
            wStringIndex,
            0,
            szMessageArray,
            NULL);
        return FALSE;
    }

    return TRUE;
}
*/

DWORD
PerfpDosError(
    IN NTSTATUS Status
    )
// Need to convert NtStatus that we generate to DosError
{
    if (Status == STATUS_SUCCESS)
        return ERROR_SUCCESS;
    if (Status == STATUS_BUFFER_OVERFLOW)
        return ERROR_MORE_DATA;
    if (Status == STATUS_TIMEOUT)
        return WAIT_TIMEOUT;
    if (Status == STATUS_WAIT_63)
        return (DWORD) ERROR_SUCCESS;
    if ((Status >= STATUS_ABANDONED) && (Status <= STATUS_ABANDONED_WAIT_63))
        return (DWORD) ERROR_CANCELLED;
    return RtlNtStatusToDosError(Status);
}

PERROR_LOG
PerfpFindError(
    IN ULONG  ErrorNumber,
    IN PERROR_LOG ErrorLog
    )
{
    PLIST_ENTRY entry, head;
    PERROR_LOG pError;

    DebugPrint((3, "PERFLIB:FindError Entering critsec for %d\n", ErrorNumber));
    RtlEnterCriticalSection(&PerfpCritSect);
    head = (PLIST_ENTRY) ErrorLog;
    entry = head->Flink;
    while (entry != head) {
        pError = (PERROR_LOG) entry;
        DebugPrint((4, "PERFLIB:FindError Comparing entry %X/%X %d\n",
                    entry, ErrorLog, pError->ErrorNumber));
        if (pError->ErrorNumber == ErrorNumber)
            break;
        entry = entry->Flink;
    }
    if (entry == head) {
        pError = ALLOCMEM(sizeof(ERROR_LOG));
        if (pError == NULL) {
        DebugPrint((3, "PERFLIB:FindError Leaving critsec1\n"));
            RtlLeaveCriticalSection(&PerfpCritSect);
            return NULL;
        }
        pError->ErrorNumber = ErrorNumber;
        pError->ErrorCount = 0;
        pError->LastTime = 0;
        entry = (PLIST_ENTRY) pError;
        DebugPrint((3, "PERFLIB:FindError Added entry %X to %X\n", entry, ErrorLog));
        InsertHeadList(head, entry);
    }
    else {
        RemoveEntryList(entry);
        InsertHeadList(head, entry);
        pError = (PERROR_LOG) entry;
        DebugPrint((3, "PERFLIB:FindError Found entry %X in %X\n", entry, ErrorLog));
    }
    DebugPrint((3, "PERFLIB:FindError Leaving critsec\n"));
    RtlLeaveCriticalSection(&PerfpCritSect);
    return (PERROR_LOG) entry;
}

ULONG
PerfpCheckErrorTime(
    IN PERROR_LOG   ErrorLog,
    IN LONG64       TimeLimit,
    IN HKEY         hKey
    )
{
    WCHAR wstr[32];
    LONG64 timeStamp;
    DWORD status, dwType, dwSize;
    ULONG bUpdate = FALSE;
    UNICODE_STRING uString;

    GetSystemTimeAsFileTime((PFILETIME) &timeStamp);
    DebugPrint((3, "PERFLIB: CheckErrorTime Error %d time %I64d last %I64d limit %I64d\n",
             ErrorLog->ErrorNumber, timeStamp, ErrorLog->LastTime, TimeLimit));

    if ((timeStamp - ErrorLog->LastTime) < TimeLimit)
        return FALSE;

    wstr[0] = UNICODE_NULL;
    if (hKey != NULL) {
        uString.Buffer = &wstr[0];
        uString.Length = 0;
        uString.MaximumLength = sizeof(wstr);

        RtlIntegerToUnicodeString(ErrorLog->ErrorNumber, 10, &uString);
        DebugPrint((3, "Err %d string %ws\n", ErrorLog->ErrorNumber, uString.Buffer));
        if (ErrorLog->LastTime == 0) {
            dwType = REG_DWORD;
            dwSize = sizeof(timeStamp);
            status = PrivateRegQueryValueExW(
                        hKey,
                        wstr, // Need to be string
                        NULL,
                        &dwType,
                        (LPBYTE) &ErrorLog->LastTime,
                        &dwSize
                        );
            if ((status == ERROR_SUCCESS) &&
                (dwType == REG_QWORD)) {
                if ((timeStamp - ErrorLog->LastTime) >= TimeLimit) {
                    ErrorLog->LastTime = 0;
                }
            }
        }
        if (ErrorLog->LastTime == 0) {
            bUpdate = TRUE;
            ErrorLog->LastTime = timeStamp;
            dwSiz