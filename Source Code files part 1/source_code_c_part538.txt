oot>::Iterator it(&m_CIRootList);
	while (!it.AtEnd()) {
		CCIRoot *pRoot = it.Current();
		it.Next();
		if (pRoot->m_dwInstance == dwInstance) {
			_ASSERT ((DWORD)lstrlenW(pRoot->m_pwszPath) < cbSize);
			if ((DWORD)lstrlenW(pRoot->m_pwszPath) < cbSize) {
				lstrcpyW(pwszBuffer, pRoot->m_pwszPath);
				hr = S_OK;
			} else {
				pwszBuffer[0] = L'\0';
				hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			}
			break;
		}
	}


	m_Lock.ShareUnlock();

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\xover\src\xcache.cpp ===
/*++

	xcache.cpp

	This file contains the code which caches CXoverIndex
	objects, and wraps the interfaces so that the user
	is hidden from the details of CXoverIndex objects etc...


--*/

#ifdef	UNIT_TEST
#ifndef	_VERIFY
#define	_VERIFY( f )	if( (f) ) ; else DebugBreak()
#endif

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif


extern	char	PeerTempDirectory[] ;

#endif

#include	<windows.h>
#include	"xoverimp.h"

static BOOL     g_IndexClassInitialized = FALSE ;
static DWORD    g_cNumXixObjectsPerTable = 256  ;


DWORD
HashFunction(	CArticleRef*	pRef ) {

	DWORD	seed = pRef->m_groupId ;
	DWORD	val = pRef->m_articleId ;

    return	((seed-val)*(seed * (val>>3))*(seed+val)) * 1103515245 + 12345;   // magic!!
}

HXOVER&
HXOVER::operator =( class	CXoverIndex*	pRight	)	{
	if( pRight != m_pIndex )	{
		CXoverIndex	*pTemp = m_pIndex;
		m_pIndex = pRight ;
		if (pTemp) CXIXCache::CheckIn( pTemp ) ;
	}
	return	*this ;
}

HXOVER::~HXOVER()	{
	if( m_pIndex )	{
		CXIXCache::CheckIn( m_pIndex ) ;
		m_pIndex = 0 ;
	}
}

CXoverCache*
CXoverCache::CreateXoverCache()	{

	return	new	CXoverCacheImplementation() ;

}


BOOL	XoverCacheLibraryInit(DWORD cNumXixObjectsPerTable)	{

    if( cNumXixObjectsPerTable ) {
        g_cNumXixObjectsPerTable = cNumXixObjectsPerTable ;
    }

	if( !CXoverIndex::InitClass( ) )	{
		return	FALSE ;
	}

	g_IndexClassInitialized = TRUE ;

	return	CacheLibraryInit() ;

}

BOOL	XoverCacheLibraryTerm()	{

	if( g_IndexClassInitialized ) {
		CXoverIndex::TermClass() ;
	}

	return	CacheLibraryTerm() ;

}


CXoverCacheImplementation::CXoverCacheImplementation()	 :
	m_cMaxPerTable( g_cNumXixObjectsPerTable ),
	m_TimeToLive( 3 ) {

}

BOOL
CXoverCacheImplementation::Init(
				long	cMaxHandles,
				PSTOPHINT_FN pfnStopHint
				 )	{
/*++

Routine Description :

	Initialize the Cache - create all our child subobjects
	and start up the necessary background thread !

Arguments :

	cMaxHandles - Maximum number of 'handles' or CXoverIndex
		we will allow clients to reference.
	pfnStopHint - call back function for sending stop hints during lengthy shutdown loops

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	m_HandleLimit = cMaxHandles;
	if( m_Cache.Init(	HashFunction,
						CXoverIndex::CompareKeys,
						60*30,
						m_cMaxPerTable * 16,
						16,
						0,
						pfnStopHint ) ) {

		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CXoverCacheImplementation::Term()	{
/*++



--*/


	EmptyCache() ;

#if 0
	if( m_IndexClassInitialized ) {
		CXoverIndex::TermClass() ;
	}
#endif

	return	TRUE ;
}

ARTICLEID
CXoverCacheImplementation::Canonicalize(
	ARTICLEID	artid
	)	{
/*++

Routine Description :

	This function figures out what file a particular Article ID
	will fall into.

Arguments :

	artid - Id of the article we are interested in !

Return Value :

	lowest article id within the file we are interested in !

--*/

	return	artid & ((~ENTRIES_PER_FILE)+1) ;
}

BOOL
CXoverCacheImplementation::RemoveEntry(
					IN	GROUPID	group,
					IN	LPSTR	szPath,
					IN	BOOL	fFlatDir,
					IN	ARTICLEID	article
					) {
/*++

Routine Description :

	This function will remove an entry for an article from
	an xover index file !

Arguments :

	group - The id of the group getting the xover entry
	szPath - Path to the newsgroups directory
	article - The id of the article within the group !

Return Value :

	TRUE if successfull, FALSE otherewise !

--*/

	ARTICLEID	artidBase = Canonicalize( article ) ;
	CArticleRef	artRef ;
	artRef.m_groupId = group ;
	artRef.m_articleId = artidBase ;


	CXIXConstructor	constructor ;

	constructor.m_lpstrPath = szPath ;
	constructor.m_fQueryOnly = FALSE ;
	constructor.m_fFlatDir = fFlatDir ;
	constructor.m_pOriginal = 0 ;

	CXoverIndex*	pXoverIndex ;

	if( (pXoverIndex = m_Cache.FindOrCreate(
								artRef,
								constructor,
								FALSE)) != 0  	)	{

		_ASSERT( pXoverIndex != 0 ) ;

		pXoverIndex->ExpireEntry(
								article
								) ;
		m_Cache.CheckIn( pXoverIndex ) ;
		return	TRUE ;
	}
	return	FALSE;
}

BOOL
CXoverCacheImplementation::FillBuffer(
		IN	CXoverCacheCompletion*	pRequest,
		IN	LPSTR	szPath,
		IN	BOOL	fFlatDir,
		OUT	HXOVER&	hXover
		)	{

	_ASSERT( pRequest != 0 ) ;
	_ASSERT( szPath != 0 ) ;

	GROUPID		groupId ;
	ARTICLEID	articleIdRequestLow ;
	ARTICLEID	articleIdRequestHigh ;
	ARTICLEID	articleIdGroupHigh ;

	pRequest->GetRange(	groupId,
						articleIdRequestLow,
						articleIdRequestHigh,
						articleIdGroupHigh
						) ;

	_ASSERT( articleIdRequestLow != INVALID_ARTICLEID ) ;
	_ASSERT( articleIdRequestHigh != INVALID_ARTICLEID ) ;
	_ASSERT( groupId != INVALID_GROUPID ) ;
	_ASSERT( articleIdRequestLow <= articleIdRequestHigh ) ;

	ARTICLEID	artidBase = Canonicalize( articleIdRequestLow ) ;
	CArticleRef	artRef ;
	artRef.m_groupId = groupId ;
	artRef.m_articleId = artidBase ;


	CXIXConstructor	constructor ;

	constructor.m_lpstrPath = szPath ;
	constructor.m_fQueryOnly = TRUE ;
	constructor.m_fFlatDir = fFlatDir ;
	constructor.m_pOriginal = pRequest ;

	CXoverIndex*	pXoverIndex ;

	if( (pXoverIndex = m_Cache.FindOrCreate(
								artRef,
								constructor,
								FALSE)) != 0  	)	{

		_ASSERT( pXoverIndex != 0 ) ;

		pXoverIndex->AsyncFillBuffer(
								pRequest,
								TRUE
								) ;
		//m_Cache.CheckIn( pXoverIndex ) ;
		return	TRUE ;
	}
	return	FALSE;

}

class	CXIXCallbackClass : public	CXIXCallbackBase {
public :

	GROUPID		m_groupId ;
	ARTICLEID	m_articleId ;

	BOOL	fRemoveCacheItem(
					CArticleRef*	pKey,
					CXoverIndex*	pData
					)	{

		return	pKey->m_groupId == m_groupId &&
					(m_articleId == 0 || pKey->m_articleId <= m_articleId) ;
	}
}	;


BOOL
CXoverCacheImplementation::FlushGroup(
				IN	GROUPID	group,
				IN	ARTICLEID	articleTop,
				IN	BOOL	fCheckInUse
				) {
/*++

Routine Description :

	This function will get rid of any cache'd CXoverIndex objects
	we may have around that meet the specifications.
	(ie. they are for the specified group and contains articles
	lower in number than articleTop)

Arguments :

	group - Group Id of the group we want to get rid of.
	articleTop - discard any thing have articleid's less than this
	fCheckInUse - if TRUE then don't discard CXoverIndex objects
		which are being used on another thread

	NOTE : Only pass FALSE for this parameter when you are CERTAIN
		that the CXoverIndex files will not be re-used - ie.
		due to a virtual root directory change !!!!
		Otherwise the Xover Index files can become corrupted !!!

Return Value :

	TRUE if successfull,
	FALSE otherwise

--*/

	CXIXCallbackClass	callback ;

	callback.m_groupId = group ;
	callback.m_articleId = articleTop ;

	return	m_Cache.ExpungeItems( &callback ) ;
}

class	CXIXCallbackClass2 : public	CXIXCallbackBase {
public :

	BOOL	fRemoveCacheItem(
					CArticleRef*	pKey,
					CXoverIndex*	pData
					)	{
		return	TRUE ;
	}
}	;



BOOL
CXoverCacheImplementation::EmptyCache() {
/*++

Routine Description :

	This function will get rid of all cache'd CXoverIndex objects
	We're called during shutdown when we want to get rid of everything !

Arguments :

	None.

Return Value :

	TRUE if successfull,
	FALSE otherwise

--*/

	CXIXCallbackClass2	callback ;

	return	m_Cache.ExpungeItems( &callback ) ;
}


BOOL
CXoverCacheImplementation::ExpireRange(
				IN	GROUPID	group,
				IN	LPSTR	szPath,
				IN	BOOL	fFlatDir,
				IN	ARTICLEID	articleLow,
				IN	ARTICLEID	articleHigh,
				OUT	ARTICLEID&	articleNewLow
				)	{
/*++

Routine Description :

	This function deletes all of the xover index files that
	contain article information in the range between ArticleLow
	and ArticleHigh inclusive.
	We may not erase the file containing ArticleHigh if ArticleHigh
	is not the last entry within that file.

Arguments :

	group -	ID of the group for which we are deleting Xover information
	szPath -	Directory containing newsgroup information
	articleLow - Low articleid of the expired articles
	articleHigh - Highest expired article number
	articleNewLog - Returns the new 'low' articleid.
		This is done so that we can insure that if we fail
		to delete an index file on one attempt, we will try again
		later !

Return Value :

	TRUE if no errors occurred
	FALSE if an error occurred.
		If an error occurs articleNewLow will be set so that
		if we are called again with articleNewLow as our articleLow
		parameter we will try to delete the problem index file again !

--*/


	articleNewLow = articleLow ;

	_ASSERT( articleHigh >= articleLow ) ;

	if( articleHigh < articleLow )		{
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	FALSE ;
	}

	ARTICLEID	articleLowCanon = Canonicalize( articleLow ) ;
	ARTICLEID	articleHiCanon = Canonicalize( articleHigh ) ;

	DWORD	status = ERROR_SUCCESS ;
	BOOL	fSuccessfull = FALSE ;

	//
	//	If the Low and Hi ends of the expired range are
	//	in the bounds of the index file, then we won't delete ANY
	//	files, as there can still be usefull entries within
	//	this file.
	//
	if( articleLowCanon != articleHiCanon ) {

		fSuccessfull = TRUE ;
		BOOL	fAdvanceNewLow = TRUE ;

		FlushGroup( group, articleHigh ) ;

		ARTICLEID	article = articleLowCanon ;

		while( article < articleHiCanon )	{

			char	szFile[MAX_PATH*2] ;
			CXoverIndex::ComputeFileName(
									CArticleRef( group, article ),
									szPath,
									szFile,
									fFlatDir
									) ;

			article += ENTRIES_PER_FILE ;

			_ASSERT( article <= articleHiCanon ) ;

			if( !DeleteFile(	szFile ) )	{

				if( GetLastError() != ERROR_FILE_NOT_FOUND )	{

					//
					//	Some serious kind of problem occurred -
					//	make sure we no longer advance articleNewLow
					//
					fSuccessfull &= FALSE ;

					fAdvanceNewLow = FALSE ;
					if( status == ERROR_SUCCESS )	{
						status = GetLastError() ;
					}
				}
			}
			if( fAdvanceNewLow )	{
				articleNewLow = article ;
			}
		}
	}
	SetLastError( status ) ;
	return	fSuccessfull ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\xover\src\xoverimp.h ===
/*++

	xoveridx.h

	This file contains the class definitions for the objects which manage
	Xover Data.

	Xover Data is stored in index files with the following format :

		(32BIT) OFFSET
		(32BIT)	LENGTH
			.
			.
			.
		XOVER ENTRY - LENGTH SPECIFIED IN HEADER
			.
			.
			.

	For our purposes we don't care what is in the Xover Entry.

	Each file will contains ENTRIES_PER_FILE entries.


	In memory, a file will be represented by a CXoverIndex object.
	A CXoverIndex keeps a copy of the OFFSET & LENGTH information
	in memory.  CXoverIndex objects are multi-thread accessible
	and use reader/writer synchronization to allow multiple clients
	to query.

	The CXoverCache object MUST ensure that a given file is represented
	by only one CXoverIndex object, or we'll become confused about
	where to append data when entries are made.




--*/

#pragma	warning(disable:4786)

#include	"xmemwrpr.h"
#include    "cpool.h"
#include    "refptr2.h"
#include    "rwnew.h"
#include	"cache2.h"
#include	"tigtypes.h"
#include	"nntptype.h"
#include	"vroot.h"
#include	"nntpvr.h"


#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

extern	DWORD	cMaxCacheEntries ;


#include	"xover.h"

//
//	Define a list of our pending requests !
//
typedef	TDListHead<	CXoverCacheCompletion, &CXoverCacheCompletion::PendDLIST >	PENDLIST ;
//
//	Define a way to iterate these things !
//
typedef	TDListIterator<	PENDLIST >	PENDITER ;

class	CCacheFillComplete :	public	CNntpComplete	{
private :

	enum	{
		SIGNATURE = 'CFaC'
	} ;

	//
	//	Looking good in the debugger !
	//
	DWORD			m_dwSignature ;

	//
	//	back pointer to the CXoverIndex object we are to fill !
	//
	class	CXoverIndex*	m_pIndex ;

	//
	//	Did we steal the IO buffer from a client ?
	//
	BOOL			m_fStolen ;

	//
	//	pointer to where we receive our results !
	//
	LPBYTE			m_lpbBuffer ;

	//
	//	size of the buffer we're using !
	//
	DWORD			m_cbBuffer ;

	//
	//	Where we capture the resultant fill info !
	//
	DWORD			m_cbTransfer ;

	//
	//	Where we capture the high number we got to !
	//
	ARTICLEID		m_articleIdLast ;
	//
	//	The original request that spurred us to do work !
	//
	CXoverCacheCompletion*	m_pComplete ;
public :

	CCacheFillComplete(	) :
		m_dwSignature( SIGNATURE ),
		m_pIndex( 0 ),
		m_fStolen( FALSE ),
		m_lpbBuffer( 0 ),
		m_cbBuffer( 0 ),
		m_cbTransfer( 0 ),
		m_pComplete( 0 )	{
	}

	//
	//	This is called when a driver drops its final reference - we will then
	//	go and write the data into the file !
	//
	//	We don't call delete because we're usually embedded into other objects !
	//
	void
	Destroy() ;

	//
	//	Go off and fill our with data !
	//
	BOOL
	StartFill(	CXoverIndex*	pIndex,
				CXoverCacheCompletion*	pComplete,
				BOOL			fStealBuffers
				) ;



} ;



//
//	This struct is used to represent the first bytes of each
//	xover index file.
//
struct	XoverIndex	{
	DWORD	m_XOffset ;
	DWORD	m_XLength ;
} ;

//
//	Maximum number of Xover entries in a single file !
//
#define	ENTRIES_PER_FILE	128


//
//	Class which represents one file containing Xover data.
//	These objects are built to be cacheable and accessed by
//	multiple threads.
//
class	CXoverIndex	{
private :

	friend	class	CCacheFillComplete ;

	//
	//	CPool to be used for allocating memory blocks for the
	//	Cache Data !
	//
	static	CPool			gCacheAllocator ;

	//
	//	CPool used to allocate CXoverIndex objects
	//
	static	CPool			gXoverIndexAllocator ;

	//
	//	These our constants for putting special bits into the lengths
	//	of XOVER records !
	//
	enum	{
		XOVER_HIGHWATER = 0x80000000,
		XOVER_HIGHWATERMASK = 0x7fffffff
	} ;

	static	DWORD	inline
	ComputeLength(	XoverIndex&	xi )	{
		return	xi.m_XLength & XOVER_HIGHWATERMASK ;
	}

	static	void	inline
	MarkAsHighwater(	XoverIndex&	xi )	{
		xi.m_XLength |= XOVER_HIGHWATER ;
	}

	inline	void
	UpdateHighwater( DWORD	index )		{
		if( index + m_Start.m_articleId+1 > m_artidHighWater ) {
			m_artidHighWater = index+m_Start.m_articleId+1 ;
		}
	}

	inline	BOOL
	IsWatermark( XoverIndex& xi )	{
		return	xi.m_XLength != 0 ;
	}


	//
	//	The lock that protects this object !
	//
	class	CShareLockNH	m_Lock ;

	//
	//	Are we in a complete state or not ?
	//
	BOOL	m_fInProgress ;

	//
	//	What is the high water mark for valid XOVER entries within this file ?
	//
	ARTICLEID	m_artidHighWater ;

	//
	//	List of pending requests !
	//
	PENDLIST	m_PendList ;

	//
	//	Is the contents of this index file sorted ?
	//
	BOOL		m_IsSorted ;

	//
	//	Handle to the file containing the Xover information
	//
	HANDLE		m_hFile ;

	//
	//	Is the cached index data dirty ??
	//
	BOOL		m_IsCacheDirty ;

	//
	//	Next offset we can use when appending an entry !!
	//
	DWORD		m_ibNextEntry ;

	//
	//	Number of entries in the index which are in use !
	//
	long		m_cEntries ;

	//
	//	the object which we use to issue async operations against
	//	store drivers !
	//
	CCacheFillComplete	m_FillComplete ;

	//
	//	Pointer to a page containing the Xover data
	//
	XoverIndex	m_IndexCache[ENTRIES_PER_FILE] ;

	//
	//	Determine whether we need to put the Async Xover
	//	request in a queue for later processing !
	//
	BOOL
	FQueueRequest(
			IN	CXoverCacheCompletion*	pAsyncComplete
			) ;


	//
	//	After some kind of error blow everything off
	//	and put us back to an 'illegal' state.
	//
	void
	Cleanup() ;

	//
	//	Check if the Xover data is in sorted order !
	//
	BOOL
	SortCheck(
				IN	DWORD	cbLength,
				OUT	long&	cEntries,
				OUT	BOOL&	fSorted
				) ;

	//
	//	Does the meat of copying data from the xover index
	//	file into a buffer.
	//
	DWORD
	FillBufferInternal(
				IN	BYTE*	lpb,
				IN	DWORD	cb,
				IN	ARTICLEID	artidStart,
				IN	ARTICLEID	artidFinish,
				OUT	ARTICLEID	&artidLast
				) ;

	//
	//	Does the meat of copying data from the xover index
	//	file into a buffer.
	//
	DWORD
	ListgroupFillInternal(
				IN	BYTE*	lpb,
				IN	DWORD	cb,
				IN	ARTICLEID	artidStart,
				IN	ARTICLEID	artidFinish,
				OUT	ARTICLEID	&artidLast
				) ;

	//
	//	Does the meat of sorting xover data
	//
	BOOL
	SortInternal(
				IN	LPSTR	szPathTemp,
				IN	LPSTR	szPathFile,
				OUT	char	(&szTempOut)[MAX_PATH*2],
				OUT	char	(&szFileOut)[MAX_PATH*2]
				) ;

public :

	//
	//	GroupId and Article Id of the first entry in this Xover index file !
	//
	CArticleRef	m_Start ;

	//
	//	This is a back pointer for the cache !
	//
	ICacheRefInterface*	m_pCacheRefInterface ;

	//
	//	I am an orphan when there is no hash table (CXCacheTable) referencing me,
	//	but I continue to exist serving client requests !  How can this
	//	happen you ask ?  Only when somebody changes virtual root
	//	directories while I am serving a client request !!!
	//
	BOOL		m_fOrphaned ;

	//
	//	Class initialization - setup our CPool's etc....
	//
	static	BOOL	InitClass() ;

	//
	//	Class termination - release our CPool's etc...
	//
	static	BOOL	TermClass() ;

	//
	//	override operator new to use our CPool
	//
	void*	operator	new( size_t	size )	{
					return	gCacheAllocator.Alloc() ;
					}

	//
	//	override operator delete to use our CPool
	//
	void	operator	delete( void* pv )	{
					gCacheAllocator.Free( pv ) ;
					}

	//
	//	Figure out what the file name is we want to open
	//	for this portion of the Xover data !
	//
	static
	void
	ComputeFileName(
				IN	class	CArticleRef&	ref,
				IN	LPSTR	szPath,
				OUT	char	(&szOutputPath)[MAX_PATH*2],
				IN	BOOL	fFlatDir,
				IN	LPSTR	szExtension = ".xix"
				) ;



	//
	//	Create a CXoverIndex object by specifying the group
	//	and articleid that the object will contain.
	//	Also specify the directory in which the index file will
	//	reside.
	//
	CXoverIndex(
			IN	class	CArticleRef&	start,
			IN	class	CXIXConstructor&	constructor
			) ;

	//
	//	Destructor - close handles
	//
	~CXoverIndex() ;

	//
	//	Do all of the expensive initialization we need to do !
	//
	BOOL
	Init(	IN	CArticleRef&		pKey,
			IN	CXIXConstructor&	constructor,
			IN	LPVOID				lpv
			) ;

	//
	//	Get the key being used to lookup these guys
	//
	CArticleRef&
	GetKey()	{
			return	m_Start ;
	}

	//
	//	Compare a key to the key in m_pXoverIndex we are using
	//
	int
	MatchKey( class	CArticleRef&	ref )	{
			return	ref.m_groupId == m_Start.m_groupId &&
					ref.m_articleId == m_Start.m_articleId ;
	}

	static
	int
	CompareKeys(	class	CArticleRef*	prefLeft,
					class	CArticleRef*	prefRight
					)	{

		if( prefLeft->m_groupId == prefRight->m_groupId )	{
			return	prefLeft->m_articleId - prefRight->m_articleId ;
		}
		return	prefLeft->m_groupId - prefRight->m_groupId ;
	}

	//
	//	Check that creation was successfull !
	//
	BOOL
	IsGood()	{
		return	m_hFile != INVALID_HANDLE_VALUE ;
	}

	//
	//	Given a buffer fill it with Xover data, starting from
	//	the specified
	//
	DWORD
	FillBuffer(
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) ;

	//
	//	Given a buffer fill it with Listgroup data, starting from
	//	the specified article id
	//
	DWORD
	ListgroupFill(
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) ;

	//
	//	NOW - issue an async Cache operation !
	//
	void
	AsyncFillBuffer(
			IN	CXoverCacheCompletion*	pAsyncComplete,
			IN	BOOL	fIsEdge
			) ;

	//
	//	Now - given an async request actually do the work !
	//
	void
	PerformXover(
			IN	CXoverCacheCompletion*	pAsyncComplete
			) ;

	//
	//	NOW - we've completed updating the Cache to the latest
	//	state of the underlying storage - so go ahead and complete
	//	pending XOVER operations !
	//
	void
	CompleteFill(
			IN	BOOL	fSuccess
			) ;



	//
	//	Add an Xover entry to this indexfile !
	//
	BOOL
	AppendEntry(
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	ARTICLEID	artid
			) ;

	//
	//	Append several entries to the XOVER results !
	//
	BOOL
	AppendMultiEntry(
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	ARTICLEID	artidNextAvail
			) ;

	//
	//	Given an ARTICLEID remove it from the xover index -
	//	This does nothing but NULL out the header offsets
	//
	void
	ExpireEntry(
			IN	ARTICLEID	artid
			) ;

	//
	//	Return TRUE if this index is already sorted !
	//
	BOOL
	IsSorted() ;

	//
	//	Sort the index !
	//
	BOOL
	Sort(
			IN	LPSTR	pathTemp,
			IN	LPSTR	pathFile,
			OUT	char	(&szTempOut)[MAX_PATH*2],
			OUT	char	(&szFileOut)[MAX_PATH*2]
			) ;

	//
	//	Flush the contents to disk and save the file !
	//
	BOOL
	Flush() ;

} ;

class	CXIXConstructor	{

	friend	class	CXoverIndex ;
	friend	class	CXoverCacheImplementation ;

	//
	//	Path to the directory which contains the necessary
	//	.xix files !
	//
	LPSTR		m_lpstrPath ;

	//
	//	If TRUE then we don't want to create a new file !
	//
	BOOL		m_fQueryOnly ;

	//
	//	If TRUE then we are keeping a whole bunch of newsgroups in
	//	one directory, and have a different naming scheme !
	//
	BOOL		m_fFlatDir ;

	//
	//	This is the request object that originated our request !
	//
	//	We will sneak off and use his buffer to do work !
	//
	CXoverCacheCompletion*	m_pOriginal ;

public :

	class	CXoverIndex*
	Create(	CArticleRef&	key,
			LPVOID&			percachedata
			) ;

	void
	Release(	class	CXoverIndex*,
				LPVOID	percachedata
				) ;

	static	void
	StaticRelease(	class	CXoverIndex*,
					LPVOID	percachedata
					) ;

} ;



//
//	forward definition
//
class	CXoverIndex ;

//
//	Maximum number of entries in our cache per CXCacheTable
//
#ifndef	DEBUG
#define	MAX_PER_TABLE		96
#else
#define	MAX_PER_TABLE		4
#endif

#ifndef	DEBUG
#define	SORT_FREQ			25
#else
#define	SORT_FREQ			1
#endif

//
//	Maximum number of CXoverIndex objects we will ever create !
//
#define	MAX_XOVER_INDEX		(1024*16)


//
//	This is the initial 'age' for newly created Xover entries
//	in our cache !
//
#define	START_AGE			3



typedef	MultiCacheEx< CXoverIndex, CArticleRef, CXIXConstructor >	CXIXCache ;

//typedef	CacheCallback< CXoverIndex >	CXIXCallbackBase ;

typedef	CXIXCache::EXPUNGEOBJECT	CXIXCallbackBase ;

class	CXoverCacheImplementation : public	CXoverCache	{
private :
	//
	//
	//
	DWORD			m_cMaxPerTable ;

	//
	//
	//
	DWORD			m_TimeToLive ;


	//
	//	This object handles all of the caching of CXoverIndex objects.
	//	What we need to do is present the appropriate interface !
	//
	CXIXCache		m_Cache ;

	//
	//	This counts the number of smart pointers we have returned
	//	to callers.  We return smart pointers to callers
	//
	long			m_HandleLimit ;

	DWORD
	MemberFillBuffer(
					IN  DWORD	(CXoverIndex::*pfn)( BYTE *, DWORD, ARTICLEID, ARTICLEID, ARTICLEID&),
					IN	BYTE*	lpb,
					IN	DWORD	cb,
					IN	DWORD	groupid,
					IN	LPSTR	szPath,
					IN	BOOL	fFlatDir,
					IN	ARTICLEID	artidStart,
					IN	ARTICLEID	artidFinish,
					OUT	ARTICLEID&	artidLast,
					OUT	HXOVER&		hXover
					);

public :

	//
	//	Create a CXoverCache object !
	//
	CXoverCacheImplementation() ;

	//
	//	destructor
	//
	virtual ~CXoverCacheImplementation() {}

	//
	//	Canonicalize the Article id
	//
	ARTICLEID
	Canonicalize(
			ARTICLEID	artid
			) ;

	//
	//	Initialize the Xover Cache
	//
	BOOL
	Init(
#ifndef	DEBUG
		long	cMaxHandles = MAX_HANDLES,
#else
		long	cMaxHandles = 5,
#endif
		PSTOPHINT_FN pfnStopHint = NULL
		) ;

	//
	//	Shutdown the background thread and kill everything !
	//
	BOOL
	Term() ;

	//
	//	This issues the asynchronous version of the XOVER request !
	//
	BOOL
	FillBuffer(
			IN	CXoverCacheCompletion*	pRequest,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			OUT	HXOVER&	hXover
			) ;

	//
	//	Dump everything out of the cache !
	//
	BOOL
	EmptyCache() ;

	//
	//	Dump all Cache entries for specified group from the cache !
	//	Note : when articleTop is 0 ALL cache entries are dropped,
	//	whereas when its something else we will drop only cache entries
	//	which fall below articleTop
	//
	BOOL
	FlushGroup(
			IN	GROUPID	group,
			IN	ARTICLEID	articleTop = 0,
			IN	BOOL	fCheckInUse = TRUE
			) ;

	//
	//	Delete all Xover index files for the specified group
	//	to the specified article -id
	//
	BOOL
	ExpireRange(
			IN	GROUPID	group,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			IN	ARTICLEID	articleLow,
			IN	ARTICLEID	articleHigh,
			OUT	ARTICLEID&	articleNewLow
			) ;

	//
	//	Remove an Xover entry !
	//
	BOOL
	RemoveEntry(
			IN	GROUPID	group,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			IN	ARTICLEID	article
			) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\common.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*         Copyright (C) 1994-1998 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

#if defined(__cplusplus)
extern "C" {
#endif

//
// Function prototypes
//

HRESULT
KillTask(
    LPTSTR      pName,
    LPSTR       pszMandatoryModule
    );


BOOL
EnableDebugPrivNT(
    VOID
    );

HRESULT
KillProcess(
    DWORD dwPid
    );

VOID
GetPidFromTitle(
    LPDWORD     pdwPid,
    HWND*       phwnd,
    LPCTSTR     pExeName
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\xover\src\xoveridx.cpp ===
/*++

	xoveridx.cpp -

	This file implements the CXoverIndex class.
	We provide all the supported needed to read and write xover
	data to xover index files.


--*/

#ifdef	UNIT_TEST
#ifndef	_VERIFY
#define	_VERIFY( f )	if( (f) ) ; else DebugBreak()
#endif

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

#endif

#include	<windows.h>
#include    <stdlib.h>
#include	"nntptype.h"
#include	"nntpvr.h"
#include	"xoverimp.h"


CPool	CXoverIndex::gCacheAllocator ;

CXoverIndex*
CXIXConstructor::Create(	CArticleRef&	key,
							LPVOID&			percachedata
							)	{
	return	new	CXoverIndex(	key,	*this ) ;
}

void
CXIXConstructor::StaticRelease(	CXoverIndex*	pIndex,
								LPVOID			percachedata
								)	{
	delete	pIndex ;
}

void
CXIXConstructor::Release(	CXoverIndex*	pIndex,
							LPVOID			percachedata
							)	{
	delete	pIndex ;
}





BOOL
CXoverIndex::InitClass()	{
/*++

Routine Description :

	This function initializes the CPool's we use to do all our allocations

Arguments :

	None.

Returns :

	TRUE if successfull, FALSE otherwise !

--*/


	return	gCacheAllocator.ReserveMemory(
								MAX_XOVER_INDEX,
								sizeof( CXoverIndex )
								) ;
}

BOOL
CXoverIndex::TermClass()	{
/*++

Routine Description :

	This function release all of our CPool memory.

Arguments :

	None.

Return Value :

	TRUE if successfull,
	FALSE otherwise.

--*/

	_ASSERT( gCacheAllocator.GetAllocCount() == 0 ) ;

	return	gCacheAllocator.ReleaseMemory() ;
}

void
CXoverIndex::Cleanup()	{
/*++

Routine Description :

	This function is used after fatal errors occur during Construction-
	we will release everything and return ourselves to a clearly invalid
	state.

Arguments :

	None.

Return Value :

	None.

--*/

	if( m_hFile != INVALID_HANDLE_VALUE ) {
		_VERIFY(	CloseHandle( m_hFile ) ) ;
	}

	m_hFile = INVALID_HANDLE_VALUE ;

}

void
CXoverIndex::ComputeFileName(
				IN	CArticleRef&	ref,
				IN	LPSTR	szPath,
				OUT	char	(&szOutputPath)[MAX_PATH*2],
				IN	BOOL	fFlatDir,
				IN	LPSTR	szExtension
				)	{
/*++

Routine Description :

	This function will build the filename to use for an xover index file.

Arguments :

	szPath - Directory containing the newsgroup
	szOutputPath - buffer which will get the file name

Return Value :

	None :

--*/


	DWORD	dw = ref.m_articleId ;

	WORD	w = LOWORD( dw ) ;
	BYTE	lwlb = LOBYTE( w ) ;
	BYTE	lwhb = HIBYTE( w ) ;

	w = HIWORD( dw ) ;
	BYTE	hwlb = LOBYTE( w ) ;
	BYTE	hwhb = HIBYTE( w ) ;

	DWORD	dwTemp = MAKELONG( MAKEWORD( hwhb, hwlb ), MAKEWORD( lwhb, lwlb )  ) ;

	lstrcpy( szOutputPath, szPath ) ;
	char*	pch = szOutputPath + lstrlen( szPath ) ;
	*pch++ = '\\' ;
	_itoa( dwTemp, pch, 16 ) ;

	if( fFlatDir )	{
		char	szTemp[32] ;
		ZeroMemory( szTemp, sizeof( szTemp ) ) ;
		szTemp[0] = '_' ;
		_itoa( ref.m_groupId, szTemp+1, 16 ) ;
		lstrcat( pch, szTemp ) ;
	}
	lstrcat( pch, szExtension ) ;
}


BOOL
CXoverIndex::SortCheck(
				IN	DWORD	cbLength,
				OUT	long&	cEntries,
				OUT	BOOL&	fSorted
				)	{
/*++

Routine Description :

	Given that we have read into memory the index portion of
	the index file this function will check the validity of the
	index data AS WELL AS Determining whether the contents are
	sorted.

Arguments :

	cbLength - Number of bytes of data in the file
	fSorted - Out parameter we will set to TRUE if the data is sorted.

Return Value :

	TRUE if data is valid. FALSE if file is corrupt

--*/

	DWORD	cbStart = sizeof( XoverIndex ) * ENTRIES_PER_FILE ;
	DWORD	cbMax = sizeof( XoverIndex ) * ENTRIES_PER_FILE ;

	cEntries = 0 ;
	fSorted = TRUE ;

	for( int i=0; i < ENTRIES_PER_FILE; i++ ) {

		if( m_IndexCache[i].m_XOffset != 0 )	{
			if( cbStart != m_IndexCache[i].m_XOffset ) {
				fSorted = FALSE ;
			}	else if( m_IndexCache[i].m_XOffset < (sizeof(XoverIndex) * ENTRIES_PER_FILE) )	{
				return	FALSE ;
			}	else	{
				cbStart += ComputeLength( m_IndexCache[i] ) ;
			}
			cEntries ++ ;
		}	else	if( ComputeLength( m_IndexCache[i] ) != 0 ) {
			return	FALSE ;
		}
		if(	IsWatermark( m_IndexCache[i] ) )	{
			UpdateHighwater( i ) ;
		}

		DWORD	cbTemp = m_IndexCache[i].m_XOffset + ComputeLength( m_IndexCache[i] ) ;
		cbMax = max( cbMax, cbTemp ) ;
	}

	if( cbLength != 0 &&
		cbMax > cbLength )
		return	FALSE ;
	return	TRUE ;
}



CXoverIndex::CXoverIndex(
				IN	CArticleRef&	start,
				IN	CXIXConstructor&	constructor
				) :
	m_fInProgress( FALSE ),
	m_Start( start ),
	m_artidHighWater( start.m_articleId ),
	m_IsSorted( FALSE ),
	m_hFile( INVALID_HANDLE_VALUE ),
	m_cEntries( 0 ),
	m_IsCacheDirty( FALSE ),
	m_fOrphaned( FALSE ),
	m_pCacheRefInterface( 0 )	{
/*++

Routine Description :

	Construct a valid CXoverIndex object from a file.
	If the file is empty than this is an empty CXoverIndex object.

Arguments :

	start -		GROUPID and Article Id of first entry in the index file
	path -		Path to the newsgroup containg the index file !
	pLock -		Lock to be used for access to CXoverIndex object !

Return Value :

	None.

--*/



	ZeroMemory( &m_IndexCache, sizeof( m_IndexCache ) ) ;
}


BOOL
CXoverIndex::Init(
				IN	CArticleRef&		key,
				IN	CXIXConstructor&	constructor,
				IN	LPVOID				lpv
				)	{
/*++

Routine Description :

	Construct a valid CXoverIndex object from a file.
	If the file is empty than this is an empty CXoverIndex object.

Arguments :

	start -		GROUPID and Article Id of first entry in the index file
	path -		Path to the newsgroup containg the index file !
	pLock -		Lock to be used for access to CXoverIndex object !

Return Value :

	None.

--*/


	char	szFileName[MAX_PATH*2] ;

	BOOL	fReturn = FALSE ;

	_ASSERT( key.m_groupId == m_Start.m_groupId ) ;
	_ASSERT( key.m_articleId == m_Start.m_articleId ) ;

	ComputeFileName(	key,
						constructor.m_lpstrPath,
						szFileName,
						constructor.m_fFlatDir
						) ;

	m_hFile = CreateFile(	szFileName,
							GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ,
							0,
							!constructor.m_fQueryOnly ? OPEN_EXISTING : OPEN_ALWAYS,
    						FILE_FLAG_WRITE_THROUGH | FILE_ATTRIBUTE_NORMAL,
							INVALID_HANDLE_VALUE
							) ;

	if( m_hFile == INVALID_HANDLE_VALUE ) {

		Cleanup() ;

	}	else	{

		DWORD	cb = GetFileSize( m_hFile, 0 ) ;
		if( cb != 0 ) {

			//
			//	Pre-existing file - lets examine the contents !
			//
			if( cb < sizeof( XoverIndex[ENTRIES_PER_FILE] ) ) {

				//
				//	This file is BOGUS ! - clean up !
				//
				Cleanup() ;

			}	else	{

				m_ibNextEntry = cb ;

				DWORD	cbRead ;
				BOOL	fRead ;
				fRead = ReadFile(
							m_hFile,
							&m_IndexCache,
							sizeof( m_IndexCache ),
							&cbRead,
							0
							) ;

				//
				//	Unable to read the file - cleanup and fail the call
				//
				if( !fRead ) {

					Cleanup() ;

				}	else	{

					_ASSERT( cbRead == sizeof( m_IndexCache ) ) ;

					if( !SortCheck(
								cb,
								m_cEntries,
								m_IsSorted
								)	)	{

						Cleanup() ;

					}	else	{

						fReturn = TRUE ;

					}
				}
			}
		}	else	{

			if( constructor.m_fQueryOnly )	{
				//
				//	This is a brand spanking new file
				//	We don't have to do anything in this case !
				//

				m_ibNextEntry = sizeof( m_IndexCache ) ;
				m_IsSorted = TRUE ;

				//
				//	go ahead and issue the necessary async operations that will
				//	fill this item up !
				//
				m_fInProgress = TRUE ;
				if( m_FillComplete.StartFill(	this, constructor.m_pOriginal, TRUE ) )	{
					//
					//	The user only want to read things - in which case we should
					//	issue an operation to start this thing going !
					//
					fReturn = TRUE ;
				}	else	{
					Cleanup() ;
				}

			}	else	{
				Cleanup() ;
			}
		}
	}
	return	fReturn ;
}



CXoverIndex::~CXoverIndex()	{
/*++

Routine Description :

	This function is called when we are destroying a CXoverIndex object.

	******** Does not grab locks *************

	We assume only one thread can be calling our destructor ever !


Arguments :

	None.

Return Value :

	None.


--*/

	if( IsGood() ) {
		Flush() ;
	}

	Cleanup() ;
}


DWORD
CXoverIndex::FillBuffer(
			IN	BYTE*	lpb,
			IN	DWORD	cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) {
/*++

Routine Description  :

	Read some xover data from the index file.
	We will call FillBufferInternal to do the actual work,
	we will just grab the necessary locks !

Arguments :

	lpb - Buffer to hold data
	cb -  Number of bytes available in buffer
	artidStart - Starting article id
	artidFinish - Last Article id
	artidLast - Out parameter gets the article id of the last
		entry we were able to read !

Return Value :

	Number of bytes read !

--*/


	m_Lock.ShareLock() ;

	DWORD	cbReturn = FillBufferInternal(
								lpb,
								cb,
								artidStart,
								artidFinish,
								artidLast
								) ;

	m_Lock.ShareUnlock() ;

	return	cbReturn ;
}

DWORD
CXoverIndex::FillBufferInternal(
			IN	BYTE*	lpb,
			IN	DWORD	cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) {
/*++

Routine Description :

	We are to fill up a provided buffer with Xover information from
	the index file.  We will fill it with complete entries only, we
	won't put in a partial entry.

	******* ASSUMES LOCK IS HELD *************

Arguments :

	lpb - Buffer to put data into
	cb -  Size of buffer
	artidStart - Article id of the first entry we are to put into the buffer
	artidFinish - Article id of the last entry we are to put into the buffer
		(inclusive - if artidFinish is in the file we will pass it !)
	artidLast - Out parameter which gets the last article id we were able
		to stuff into the buffer !

Return Value :

	Number of bytes put into the buffer !

--*/

	DWORD	cbReturn = 0 ;

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;


	//
	//	Validate that our arguments are in the correct range
	//

	_ASSERT( artidStart >= m_Start.m_articleId ) ;
	_ASSERT( artidFinish >= artidStart ) ;
	_ASSERT( artidStart < m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	if( artidFinish >= m_Start.m_articleId + ENTRIES_PER_FILE ) {
		//
		//	Make the finish point a boundary within our data
		//
		artidFinish = m_Start.m_articleId + (ENTRIES_PER_FILE-1) ;
	}
	//
	//	However, for the caller, the next point they should
	//	start should be in the next block of data, unless we are unable
	//	to fill their buffer with what we have in our data !
	//
	artidLast = artidFinish + 1 ;


	//
	//	Use pointers in all that follows instead of indices !
	//
	XoverIndex*	pStart = &m_IndexCache[artidStart - m_Start.m_articleId] ;
	XoverIndex*	pFinish = &m_IndexCache[artidFinish - m_Start.m_articleId] ;

	//
	//	find the true endpoints ! - skip all the 0 entries !
	//
	while( pStart->m_XOffset == 0 &&
			pStart <= pFinish )
		pStart ++ ;

	while( pFinish->m_XOffset == 0 &&
			pFinish >= pStart )
		pFinish -- ;

	//
	//	Well, is there really anything for us to do ??
	//
	if( pStart > pFinish ) {

		SetLastError( ERROR_NO_DATA ) ;
		return	0 ;


	}

	_ASSERT( pStart->m_XOffset != 0 ) ;
	_ASSERT( ComputeLength( *pStart ) != 0 ) ;

#if 0
	if(	m_IsSorted ) {

		//
		//	If the data is sorted, just do a readfile
		//	at the right boundaries for the buffer we have !
		//

		ovl.Offset = pStart->m_XOffset ;
		DWORD	cbRead ;


		DWORD	cbTemp = 0 ;
		for( ; pStart <= pFinish; pStart++ ) {

			if( (cbTemp + pStart->m_XLength) > cb ) {

				break ;

			}
			cbTemp += pStart->m_XLength ;
		}

		if( ReadFile(
					m_hFile,
					(LPVOID)lpb,
					cbTemp,
					&cbRead,
					&ovl
					)	)	{

			_ASSERT( cbRead == cbTemp ) ;

			if( pStart <= pFinish )
				artidLast = (pStart - &m_IndexCache[0]) + m_Start.m_articleId ;
			return	cbRead ;
		}	else	{

			return	 0 ;

		}

	}	else	{
#endif

		//
		//	The data is not sorted - we need to go and read each
		//	entry individually - we will do this by building
		//	runs of entries which are sorted and reading them in blocks
		//
		BYTE	*lpbRemaining = lpb ;
		DWORD	cbTemp = 0 ;
		DWORD	ibNext = 0 ;
		XoverIndex*	pSuccessfull = pStart ;

		while(	(pStart <= pFinish) &&
				(ComputeLength( *pStart ) + cbReturn) < cb ) {

			OVERLAPPED	ovl ;
			ZeroMemory( &ovl, sizeof( ovl ) ) ;

			DWORD	cbRemaining = cb - cbReturn ;
			ovl.Offset = pStart->m_XOffset ;
			DWORD	cbTemp = ComputeLength( *pStart ) ;

			ibNext = ovl.Offset + cbTemp ;

			//
			//	Roll up consecutive entries that will fit in the input
			//	buffer into a single read !
			//

			for( pStart++;	pStart <= pFinish &&
					((ComputeLength( *pStart ) + cbTemp) < cbRemaining) &&
					(pStart->m_XOffset == 0 ||
						pStart->m_XOffset == ibNext)  ;
							pStart ++) {

				cbTemp += ComputeLength( *pStart ) ;
				ibNext += ComputeLength( *pStart ) ;

				_ASSERT( cbTemp < cbRemaining ) ;
			}

			DWORD	cbRead ;

			if( !ReadFile(
						m_hFile,
						lpbRemaining,
						cbTemp,
						&cbRead,
						&ovl
						) )		{
				break ;
			}

			pSuccessfull = pStart ;

			lpbRemaining += cbTemp ;
			cbRemaining -= cbTemp ;
			cbReturn += cbTemp ;

			_ASSERT( cbReturn < cb ) ;
		}

		if( pStart <= pFinish )
			artidLast = (ARTICLEID)((pSuccessfull - &m_IndexCache[0]) + m_Start.m_articleId) ;
#if 0
	}
#endif
	_ASSERT( cbReturn < cb ) ;

	return	cbReturn ;
}

DWORD
CXoverIndex::ListgroupFill(
			IN	BYTE*	lpb,
			IN	DWORD	cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) {
/*++

Routine Description  :

	Read some xover data from the index file.
	We will call FillBufferInternal to do the actual work,
	we will just grab the necessary locks !

Arguments :

	lpb - Buffer to hold data
	cb -  Number of bytes available in buffer
	artidStart - Starting article id
	artidFinish - Last Article id
	artidLast - Out parameter gets the article id of the last
		entry we were able to read !

Return Value :

	Number of bytes read !

--*/


	m_Lock.ShareLock() ;

	DWORD	cbReturn = ListgroupFillInternal(
								lpb,
								cb,
								artidStart,
								artidFinish,
								artidLast
								) ;

	m_Lock.ShareUnlock() ;

	return	cbReturn ;
}



DWORD
CXoverIndex::ListgroupFillInternal(
			IN	BYTE*	lpb,
			IN	DWORD	cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) {
/*++

Routine Description :

	We are to fill up a provided buffer with Xover information from
	the index file.  We will fill it with complete entries only, we
	won't put in a partial entry.

	******* ASSUMES LOCK IS HELD *************

Arguments :

	lpb - Buffer to put data into
	cb -  Size of buffer
	artidStart - Article id of the first entry we are to put into the buffer
	artidFinish - Article id of the last entry we are to put into the buffer
		(inclusive - if artidFinish is in the file we will pass it !)
	artidLast - Out parameter which gets the last article id we were able
		to stuff into the buffer !

Return Value :

	Number of bytes put into the buffer !

--*/

	DWORD	cbReturn = 0 ;

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;


	//
	//	Validate that our arguments are in the correct range
	//

	_ASSERT( artidStart >= m_Start.m_articleId ) ;
	_ASSERT( artidFinish >= artidStart ) ;
	_ASSERT( artidStart < m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	if( artidFinish >= m_Start.m_articleId + ENTRIES_PER_FILE ) {
		//
		//	Make the finish point a boundary within our data
		//
		artidFinish = m_Start.m_articleId + (ENTRIES_PER_FILE-1) ;
	}
	//
	//	However, for the caller, the next point they should
	//	start should be in the next block of data, unless we are unable
	//	to fill their buffer with what we have in our data !
	//
	artidLast = artidFinish + 1 ;


	//
	//	Use pointers in all that follows instead of indices !
	//
	XoverIndex*	pStart = &m_IndexCache[artidStart - m_Start.m_articleId] ;
	XoverIndex*	pFinish = &m_IndexCache[artidFinish - m_Start.m_articleId] ;
	XoverIndex* pBegin = &m_IndexCache[0] ;

	//
	//	find the true endpoints ! - skip all the 0 entries !
	//
	while( pStart->m_XOffset == 0 &&
			pStart <= pFinish )
		pStart ++ ;

	while( pFinish->m_XOffset == 0 &&
			pFinish >= pStart )
		pFinish -- ;

	//
	//	Well, is there really anything for us to do ??
	//
	if( pStart > pFinish ) {

		SetLastError( ERROR_NO_DATA ) ;
		return	0 ;


	}

	_ASSERT( pStart->m_XOffset != 0 ) ;
	_ASSERT( ComputeLength( *pStart ) != 0 ) ;

	BYTE	*lpbRemaining = lpb ;
	DWORD	cbTemp = 0 ;
	DWORD	ibNext = 0 ;
	XoverIndex*	pSuccessfull = pStart ;

	while(	(pStart <= pFinish) &&
			(22 + cbReturn) < cb ) {

		DWORD	cbRemaining = cb - cbReturn ;
		DWORD	cbTemp = ComputeLength( *pStart ) ;

		_itoa( (int)(m_Start.m_articleId + (pStart-pBegin)),
				(char*)lpb+cbReturn,
				10
				) ;

		cbReturn += lstrlen( (char*)lpb + cbReturn ) ;
		lpb[cbReturn++] = '\r' ;
		lpb[cbReturn++] = '\n' ;

		pStart++ ;
		while( pStart->m_XOffset == 0 &&
			pStart <= pFinish )
			pStart ++ ;

		pSuccessfull = pStart ;
		_ASSERT( cbReturn < cb ) ;
	}

	if( pStart <= pFinish )
		artidLast = (ARTICLEID)((pSuccessfull - &m_IndexCache[0]) + m_Start.m_articleId) ;
	_ASSERT( cbReturn < cb ) ;

	return	cbReturn ;
}

BOOL
CXoverIndex::AppendEntry(
				IN	BYTE*	lpb,
				IN	DWORD	cb,
				IN	ARTICLEID	artid	)	{
/*++

Routine Description :

	This function will enter some data into the xover index file.

Arguments :

	lpb	-	Pointer to the data to put into xover table
	cb	-	Number of bytes of data to place into xover table
	artid -	Article Id.  We must convert this to a number within our range !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	BOOL	fSuccess = TRUE ;

	_ASSERT( artid >= m_Start.m_articleId ) ;
	_ASSERT( artid < m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	int	artOffset = artid - m_Start.m_articleId ;

	_ASSERT( artOffset >= 0 ) ;

	//
	//	Use a Shared Lock while we append the data,
	//	we can safely use InterlockedExchangeAdd() to compute
	//	the offset at which we append !
	//
	m_Lock.ShareLock() ;

	if( m_IndexCache[artOffset].m_XOffset != 0 ) {

		m_Lock.ShareUnlock() ;
		SetLastError( ERROR_ALREADY_EXISTS ) ;
		fSuccess = FALSE ;

	}	else	{

		OVERLAPPED	ovl ;
		ZeroMemory(	&ovl, sizeof( ovl ) ) ;

		DWORD	ibOffset = InterlockedExchangeAdd( (long*)&m_ibNextEntry, (long)cb ) ;
		ovl.Offset = ibOffset ;
		DWORD	dw ;

		fSuccess = WriteFile(
						m_hFile,
						lpb,
						cb,
						&dw,
						&ovl
						)  ;

		_ASSERT( !fSuccess || dw == cb ) ;

		m_Lock.ShareUnlock() ;

		if( fSuccess ) {
			//
			//	Now we will right out the newly modified entry we have made !
			//

			m_Lock.ExclusiveLock() ;

			XoverIndex*	pTemp = &m_IndexCache[artOffset] ;
			if( InterlockedExchange( (long*)&pTemp->m_XOffset, ibOffset ) != 0 ) {

				//
				//	Although we handle the error, the caller should not be reusing
				//	article id's
				//
				//_ASSERT( FALSE ) ;

				fSuccess = FALSE ;

			}	else	{

				pTemp->m_XLength = cb ;
				UpdateHighwater( artOffset ) ;

				ZeroMemory( &ovl, sizeof( ovl ) ) ;

				ovl.Offset = artOffset * sizeof( XoverIndex ) ;

				fSuccess &=
					WriteFile(
							m_hFile,
							pTemp,
							sizeof( XoverIndex ),
							&dw,
							&ovl
							) ;

				_ASSERT( !fSuccess || dw == sizeof( XoverIndex ) ) ;

				if( fSuccess ) {

					m_IsCacheDirty = TRUE ;
					_VERIFY( InterlockedIncrement( &m_cEntries ) > 0 ) ;

				}

				_ASSERT( !fSuccess || dw == sizeof( XoverIndex ) ) ;
			}

			//
			//	If we were successfull, and we were sorted then we should be
			//	able to figure out whether we are still sorted !
			//

			if( fSuccess && m_IsSorted )	{

				_ASSERT( m_IndexCache[artOffset].m_XOffset == ibOffset ) ;
				_ASSERT( ComputeLength( m_IndexCache[artOffset] ) == cb ) ;
				_ASSERT( m_cEntries <= ENTRIES_PER_FILE ) ;

				//
				//	If we were already in sorted order, go check if we
				//	still are !
				//
				if( m_IsSorted ) {

					//
					//	The only question is whether the guy which precedes us logically
					//	is also the previous entry physically !
					//
					while( --artOffset > 0 ) {

						if( m_IndexCache[artOffset].m_XOffset != 0 ) {
							if( m_IndexCache[artOffset].m_XOffset +
								ComputeLength( m_IndexCache[artOffset] ) !=
								ibOffset  )		{

								m_IsSorted = FALSE ;

							}
							break ;
						}
					}
					if( artOffset <= 0 &&
						m_cEntries != 0 ) {
						m_IsSorted = FALSE ;
					}
				}

				BOOL	fSorted ;
				long	cEntries ;
				//
				//	All the entries must still look valid !
				//
				_ASSERT( SortCheck( 0, cEntries, fSorted ) )  ;

				//
				//	Number of entries better jive !
				//
				_ASSERT( m_cEntries == cEntries ) ;

				//
				//	If we think things are sorted then SortCheck() better confirm that!
				//
				_ASSERT( !m_IsSorted || fSorted ) ;

				//
				//	Make sure we track the file size correctly !
				//
				_ASSERT( (m_ibNextEntry == GetFileSize( m_hFile, 0 )) || (0xFFFFFFFF == GetFileSize( m_hFile, 0 )) ) ;
			}

			m_Lock.ExclusiveUnlock() ;
		}

	}

	return	fSuccess ;
}

void
CXoverIndex::ExpireEntry(
		IN	ARTICLEID	artid
		)	{
/*++

Routine Description :

	This function deletes the xover entry of a specified article
	from the index file.  We do nothing to delete the information
	immediately - we just clear out the index information.

Arguments :

	artid - Article id of the entry to be removed !

Return Value :

	None.

--*/

	m_Lock.ExclusiveLock() ;

	_ASSERT( artid >= m_Start.m_articleId ) ;
	_ASSERT( artid < m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	DWORD	artOffset = artid - m_Start.m_articleId ;

	if( m_IndexCache[artOffset].m_XOffset != 0 ) {

		m_IndexCache[artOffset].m_XOffset = 0 ;
		m_IndexCache[artOffset].m_XLength = 0 ;
		MarkAsHighwater( m_IndexCache[artOffset] ) ;
		m_IsSorted = FALSE ;
		m_IsCacheDirty = TRUE ;
		_VERIFY( InterlockedDecrement( &m_cEntries ) >= 0 ) ;

	}

	m_Lock.ExclusiveUnlock() ;
}

BOOL
CXoverIndex::IsSorted()	{
/*++

Routine Description :

	Tell the caller whether the index file is currently sorted.

Arguments :

	None.

Return Value :

	TRUE if sorted, FALSE otherwise

--*/

	return	m_IsSorted ;

}

BOOL
CXoverIndex::Flush()	{
/*++

Routine Description :

	This function dumps any cached content to disk !

Arguments :

	None.

REturn Value :

	TRUE if successfull, FALSE otherwise !


--*/

	_ASSERT( IsGood() ) ;

	BOOL	fSuccess = TRUE ;

	m_Lock.ExclusiveLock() ;

	if( m_IsCacheDirty ) {

		OVERLAPPED	ovl ;
		ZeroMemory( &ovl, sizeof( ovl ) ) ;
		DWORD	dwWrite ;

		if( (fSuccess = WriteFile(	m_hFile,
							(LPVOID)&m_IndexCache,
							ENTRIES_PER_FILE * sizeof( XoverIndex ),
							&dwWrite,
							&ovl ) )  ) {

			m_IsCacheDirty = FALSE ;
		}
	}
	m_Lock.ExclusiveUnlock() ;

	return	fSuccess ;
}


void
CXoverIndex::AsyncFillBuffer(
					IN	CXoverCacheCompletion*	pAsyncComplete,
					IN	BOOL	fIsEdge
					)	{
/*++

Routine Description :

	This function determines whether we can perform the requested
	XOVER operation right now, or whether we should wait a while.

Arguments :

	pAsyncCompletion - the object representing the XOVER request !
	fIsEdge - if TRUE then this element of the XOVER cache is right
		where articles are being added !

Return Value :

	None.

--*/

	_ASSERT( pAsyncComplete != 0 ) ;

	m_Lock.ShareLock() ;

	BOOL fQueue = FQueueRequest( pAsyncComplete ) ;
	if( fQueue )	{
		//
		//	Convert to Exclusive and check again
		//
		if( !m_Lock.SharedToExclusive() ) {
			m_Lock.ShareUnlock() ;
			m_Lock.ExclusiveLock() ;
			fQueue = FQueueRequest( pAsyncComplete ) ;
		}
		if( fQueue )	{
			//
			//	Put the item on the queue !
			//
			m_PendList.PushFront( pAsyncComplete ) ;
			//
			//	Check to see whether we need to start a fill operation going !
			//
			if( !m_fInProgress ) {
				//
				//	Mark us as in progress with a Cache fill operation !
				//
				m_fInProgress = TRUE ;
				//
				//	This could lead to us re-entering the lock - we got to drop it here !
				//
				m_Lock.ExclusiveUnlock() ;
				if( !m_FillComplete.StartFill( this, pAsyncComplete, TRUE ) ) {
					fQueue = FALSE ;
				}
			}	else	{
				m_Lock.ExclusiveUnlock() ;
			}
			return ;
		}	else	{
			m_Lock.ExclusiveToShared() ;
		}
	}
	m_Lock.ShareUnlock() ;

	//
	//	If we arrive here we have the object locked shared ! - now we can
	//	go ahead and do the work !
	//
	PerformXover( pAsyncComplete ) ;
}

BOOL
CXoverIndex::FQueueRequest(
						IN	CXoverCacheCompletion*	pAsyncComplete
						)	{
/*++

Routine Description :

	This function determines whether we should queue an XOVER request
	behind a cache file operation !

Arguments :

	pAsyncComplete - the object representing the request !

Return Value :

	TRUE if we should Queue - FALSE otherwise !

--*/

	//
	//	if we have an operation in progress, we always wait !
	//
	if( m_fInProgress )		{
		return	TRUE ;
	}	else	{

		if( m_artidHighWater >= m_Start.m_articleId + ENTRIES_PER_FILE )	{
			return	FALSE ;
		}	else	{
			GROUPID	groupId ;
			ARTICLEID	articleIdLow ;
			ARTICLEID	articleIdHigh ;
			ARTICLEID	articleIdGroupHigh ;

			pAsyncComplete->GetRange(	groupId,
										articleIdLow,
										articleIdHigh,
										articleIdGroupHigh
										) ;

			_ASSERT( articleIdHigh >= articleIdLow ) ;
			_ASSERT( articleIdGroupHigh >= articleIdHigh  ) ;
			_ASSERT( groupId != INVALID_GROUPID && articleIdLow != INVALID_ARTICLEID &&
						articleIdHigh != INVALID_ARTICLEID && articleIdGroupHigh != INVALID_ARTICLEID ) ;

			if( articleIdGroupHigh >= m_artidHighWater )	{
				return	TRUE ;
			}
		}
	}
	return	FALSE ;
}

void
CXoverIndex::CompleteFill(
						BOOL	fSuccess
						)	{
/*++

Routine Description :

	This function is called when we've completed a cache fill.
	We take all pending requests and complete them !

Arguments :

	fSuccess - whether the cache fill was completed successfully !

Return Value :

	None.

--*/

	//
	//	Grab the lock and copy the pending list into our own private list !
	//
	PENDLIST	pendComplete ;
	m_Lock.ExclusiveLock() ;
	pendComplete.Join( m_PendList ) ;
	m_fInProgress = FALSE ;
	m_Lock.ExclusiveUnlock() ;

	for(	CXoverCacheCompletion*	pComplete = pendComplete.PopFront();
			pComplete != 0 ;
			pComplete = pendComplete.PopFront() )	{

		PerformXover( pComplete ) ;

	}
}

void
CXoverIndex::PerformXover(
					IN	CXoverCacheCompletion*	pAsyncComplete
					)	{
/*++

Routine Description :

	This function takes an async XOVER request and processes
	it from the cached information.

Arguments :

	pAsyncComplete - the async XOVER operation we are to process

Return Value :

	None

--*/

	//
	//	Get the arguments we need to perform the XOVER operation !
	//
	ARTICLEID	articleIdLow ;
	ARTICLEID	articleIdHigh ;
	ARTICLEID	articleIdGroupHigh ;
	LPBYTE		lpbBuffer ;
	DWORD		cbBuffer ;

	pAsyncComplete->GetArguments(	articleIdLow,
									articleIdHigh,
									articleIdGroupHigh,
									lpbBuffer,
									cbBuffer
									) ;

	_ASSERT( lpbBuffer != 0 ) ;
	_ASSERT( cbBuffer != 0 ) ;
	_ASSERT( articleIdLow != INVALID_ARTICLEID ) ;
	_ASSERT( articleIdHigh != INVALID_ARTICLEID ) ;

	m_Lock.ShareLock() ;

	ARTICLEID	articleIdLast ;
	DWORD		cbTransfer = FillBufferInternal(
											lpbBuffer,
											cbBuffer,
											articleIdLow,
											articleIdHigh,
											articleIdLast
											) ;
	m_Lock.ShareUnlock() ;

	pAsyncComplete->Complete(	TRUE,
								cbTransfer,
								articleIdLast
								) ;

	//
	//	Now return the request to the cache !
	//
	CXIXCache::CheckIn( this ) ;

}

BOOL
CXoverIndex::AppendMultiEntry(
						IN	LPBYTE	lpb,
						IN	DWORD	cb,
						ARTICLEID	artidNextAvail
						)	{
/*++

Routine Description :

	Our job is to process some XOVER data, and insert it into our cache.
	We're going to do some extra checking to ensure that :
		1) The data we get is ordered correctly
		2) The data we get doesn't overlap with something we alread have
	Both these conditions should be guaranteed by the way we fill our
	cache item !

Arguments :

	LPBYTE	lpb - buffer containing XOVER data !
	DWORD	cb - number of bytes of interesting stuff in the buffer !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	_ASSERT( lpb != 0 ) ;
	_ASSERT( cb != 0 ) ;

	//
	//	check that our buffer is properly terminated with a CRLF !
	//
	_ASSERT( lpb[cb-2] == '\r' ) ;
	_ASSERT( lpb[cb-1] == '\n' ) ;

	m_Lock.ExclusiveLock() ;

	LPBYTE	lpbEnd = lpb+cb ;
	LPBYTE	lpbBegin = lpb ;
	ARTICLEID	artidLast = m_Start.m_articleId ;

	DWORD	ibNextEntry = m_ibNextEntry ;

	while( lpbBegin < lpbEnd )	{

		//
		//	check that the entry is well formatted !
		//
		if( !isdigit( (UCHAR)lpbBegin[0] ) )	{
			SetLastError( ERROR_INVALID_DATA ) ;
			return	FALSE ;
		}
		//
		//	FIRST - determine what number the current entry is !
		//
		ARTICLEID	artid = atoi( (const char*)lpbBegin ) ;

		//
		//	We should only be picking up entries that are below our high water mark !
		//
		_ASSERT( artid >= m_artidHighWater ) ;
		if (artid < m_artidHighWater ) {
			_ASSERT( FALSE );
		}

		//
		//	XOVER entries should arrive in strictly increasing order !
		//
		if( artid < artidLast ||
				(artid >= m_Start.m_articleId + ENTRIES_PER_FILE))	{
			SetLastError( ERROR_INVALID_DATA ) ;
			_ASSERT( FALSE );
			m_Lock.ExclusiveUnlock();
			return	FALSE ;
		}
		artidLast = artid ;

		//
		//	Now - determine how big the entry is !
		//
		for( LPBYTE	lpbTerm = lpbBegin; *lpbTerm != '\n'; lpbTerm ++ ) ;
		lpbTerm++ ;
		_ASSERT( lpbTerm <= lpbEnd ) ;

		//
		//	So far everything looks good - so update our entry !
		//
		DWORD	index = artid - m_Start.m_articleId ;

		if( m_IndexCache[index].m_XOffset != 0 ) {
			SetLastError( ERROR_INVALID_DATA ) ;
			_ASSERT( FALSE );
			m_Lock.ExclusiveUnlock();
			return	FALSE ;
		}

		_ASSERT( index < ENTRIES_PER_FILE ) ;

		//
		//	Now update everything we need to track this XOVER entry !
		//
		m_IndexCache[index].m_XOffset = ibNextEntry ;
		m_IndexCache[index].m_XLength = (DWORD)(lpbTerm - lpbBegin) ;
		UpdateHighwater( index ) ;
		ibNextEntry += (DWORD)(lpbTerm-lpbBegin) ;
		lpbBegin = lpbTerm ;
		_VERIFY( InterlockedIncrement( &m_cEntries ) > 0 ) ;
		_ASSERT( m_cEntries <= ENTRIES_PER_FILE ) ;

	}

	//
	//	check to see if we have captured all the XOVER entries in this range !
	//
	if( artidNextAvail >= m_Start.m_articleId + ENTRIES_PER_FILE ) {
		//
		//	Mark the last entry in the file as a high water mark !
		//
		MarkAsHighwater( m_IndexCache[ENTRIES_PER_FILE-1] ) ;
		UpdateHighwater( ENTRIES_PER_FILE-1 ) ;
	}

	//
	//	If we reach this point - everything has gone well - do some IO's
	//	to put this stuff down on disk !
	//

	OVERLAPPED	ovl ;
	ZeroMemory(	&ovl, sizeof( ovl ) ) ;
	ovl.Offset = m_ibNextEntry ;
	m_ibNextEntry = ibNextEntry ;
	DWORD	dw ;

	BOOL	fSuccess = WriteFile(
								m_hFile,
								lpb,
								cb,
								&dw,
								&ovl
								) ;

	if( fSuccess )	{

		_ASSERT( dw == cb ) ;

		ZeroMemory( &ovl, sizeof( ovl ) ) ;

		//
		//	Now - write out the header !
		//
		fSuccess = WriteFile(	m_hFile,
								(LPVOID)&m_IndexCache,
								sizeof( m_IndexCache ),
								&dw,
								&ovl
								) ;
	}
	m_Lock.ExclusiveUnlock() ;
	return	fSuccess ;
}



BOOL
CCacheFillComplete::StartFill(	CXoverIndex*	pIndex,
								CXoverCacheCompletion*	pComplete,
								BOOL			fStealBuffers
								)	{
/*++

Routine Description :

	This function starts issuing XOVER operations against the underlying
	store driver and fills our cache file !

Arguments :

	pIndex - the CXoverIndex object we are to fill !
	pComplete - the original request that started this operation off !
	fStealBuffers - if TRUE we use the buffers from the original operation
		as our temp buffers !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( pIndex != 0 ) ;
	_ASSERT( pComplete != 0 ) ;

	m_pIndex = pIndex ;
	m_pComplete = pComplete ;

	ARTICLEID	articleIdInLow ;
	ARTICLEID	articleIdInHigh ;
	ARTICLEID	articleIdGroupHigh ;

	pComplete->GetArguments(	articleIdInLow,
								articleIdInHigh,
								articleIdGroupHigh,
								m_lpbBuffer,
								m_cbBuffer
								) ;

	_ASSERT( m_lpbBuffer != 0 ) ;
	_ASSERT( m_cbBuffer != 0 ) ;
	_ASSERT( articleIdInLow >= pIndex->m_Start.m_articleId ) ;
	_ASSERT( articleIdInLow < pIndex->m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	//
	//	should we allocate our own buffer ?
	//
	if( fStealBuffers )	{

		m_fStolen = TRUE ;

	}	else	{

		//
		//	get a big buffer !
		//
		m_cbBuffer = 32 * 1024 ;
		m_lpbBuffer = new	BYTE[m_cbBuffer] ;
		m_fStolen = FALSE ;
	}

	if( m_lpbBuffer )	{
		//
		//	Go ahead and issue a request !
		//	NOTE : the range is INCLUSIVE so we must be carefull !
		//
		m_pComplete->DoXover(	pIndex->m_artidHighWater,
							min( pIndex->m_Start.m_articleId+ENTRIES_PER_FILE-1, articleIdGroupHigh ),
							&m_articleIdLast,
							m_lpbBuffer,
							m_cbBuffer,
							&m_cbTransfer,
							this
							) ;
		return	TRUE ;
	}
	return	FALSE ;
}

void
CCacheFillComplete::Destroy()	{
/*++

Routine Description :

	This function is called when we have gotten some data from the underlying
	store driver - we will now write give this to the CXoverIndex object to process !

Arguments :

	None.

Return Value :

	None !

--*/


	//
	//	Assume we will need to continue
	//
	BOOL	fComplete = FALSE ;
	//
	//	Assume everything is working !
	//
	BOOL	fSuccess = TRUE ;


	GROUPID		groupId = INVALID_GROUPID ;
	ARTICLEID	articleIdInLow = INVALID_ARTICLEID ;
	ARTICLEID	articleIdInHigh = INVALID_ARTICLEID ;
	ARTICLEID	articleIdGroupHigh = INVALID_ARTICLEID ;

	//
	//	Did this operation succeed !
	//
	if( SUCCEEDED(GetResult()) )	{

		//
		//	We need to tell the CXoverIndex to save these bytes away !
		//
		_ASSERT( m_pIndex != 0 ) ;

		if( m_cbTransfer != 0 ) {
			m_pIndex->AppendMultiEntry(	m_lpbBuffer,
										m_cbTransfer,
										m_articleIdLast
										) ;
		}

		m_pComplete->GetRange(		groupId,
									articleIdInLow,
									articleIdInHigh,
									articleIdGroupHigh
									) ;

		//
		//	Now figure out if we are finished, or whether we
		//	should have another go around !
		//
		fComplete = (m_articleIdLast >=
			m_pIndex->m_Start.m_articleId + ENTRIES_PER_FILE) ||
			(m_articleIdLast >= articleIdGroupHigh) ||
			(m_cbTransfer == 0) ;

	}	else	{

		//
		//	In failure cases, we finish immediately !
		//
		fComplete = TRUE ;
		fSuccess = FALSE ;
	}

	//
	//	reset our state so we can be re-used !
	//
	Reset() ;

	//
	//	Continue to execute if need be !
	//
	if( !fComplete )	{

		//
		//	Go ahead and issue a request !
		//	NOTE : the range is INCLUSIVE so we must be carefull !
		//
		m_pComplete->DoXover(	m_articleIdLast,
							min( m_pIndex->m_Start.m_articleId+ENTRIES_PER_FILE-1, articleIdGroupHigh ),
							&m_articleIdLast,
							m_lpbBuffer,
							m_cbBuffer,
							&m_cbTransfer,
							this
							) ;


	}	else	{
		//
		//	Polish our state to brand new !
		//
		if( !m_fStolen )	{
			delete[]	m_lpbBuffer ;
		}
		m_lpbBuffer = 0 ;
		m_cbBuffer = 0 ;
		m_cbBuffer = 0 ;
		m_fStolen = FALSE ;
		m_pComplete = 0 ;
		CXoverIndex*	pIndex = m_pIndex ;
		m_pIndex = 0 ;
		//
		//	reset the completion object's vroot pointer to release our reference !
		//
		SetVRoot( 0 ) ;

		//
		//	Indicate that everything is done !
		//
		pIndex->CompleteFill(	fSuccess
								) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\enummod.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    enummod.c

Abstract:

    This module implements a remote module enumerator.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <stdlib.h>

#include "inetdbgp.h"

BOOLEAN
EnumModules(
    IN HANDLE ExtensionCurrentProcess,
    IN PFN_ENUMMODULES EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all loaded modules in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each module.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    PROCESS_BASIC_INFORMATION basicInfo;
    NTSTATUS status;
    PPEB peb;
    PPEB_LDR_DATA ldr = NULL;
    PLIST_ENTRY ldrHead, ldrNext;
    PLDR_DATA_TABLE_ENTRY ldrEntry;
    LDR_DATA_TABLE_ENTRY ldrEntryData;
    WCHAR tmpName[MAX_PATH];
    MODULE_INFO moduleInfo;

    //
    // Get the process info.
    //

    status = NtQueryInformationProcess(
                 ExtensionCurrentProcess,
                 ProcessBasicInformation,
                 &basicInfo,
                 sizeof(basicInfo),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) 
    {
        return FALSE;
    }

    peb = basicInfo.PebBaseAddress;

    if( peb == NULL ) 
    {
        return FALSE;
    }

    //
    // ldr = peb->Ldr
    //

    if( !ReadProcessMemory(
            ExtensionCurrentProcess,
            (LPCVOID)&peb->Ldr,
            &ldr,
            sizeof(ldr),
            NULL
            ) ) 
    {
        return FALSE;
    }

    ldrHead = &ldr->InMemoryOrderModuleList;

    //
    // ldrNext = ldrHead->Flink;
    //

    if( !ReadProcessMemory(
            ExtensionCurrentProcess,
            (LPCVOID)&ldrHead->Flink,
            &ldrNext,
            sizeof(ldrNext),
            NULL
            ) ) 
    {
        return FALSE;
    }

    while( ldrNext != ldrHead ) 
    {
        //
        // Read the LDR_DATA_TABLE_ENTRY structure and the module name.
        //

        ldrEntry = CONTAINING_RECORD(
                       ldrNext,
                       LDR_DATA_TABLE_ENTRY,
                       InMemoryOrderLinks
                       );

        if( !ReadProcessMemory(
                ExtensionCurrentProcess,
                (LPCVOID)ldrEntry,
                &ldrEntryData,
                sizeof(ldrEntryData),
                NULL
                ) ) 
        {
            return FALSE;
        }

        if( !ReadProcessMemory(
                ExtensionCurrentProcess,
                (LPCVOID)ldrEntryData.BaseDllName.Buffer,
                tmpName,
                ldrEntryData.BaseDllName.MaximumLength,
                NULL
                ) ) 
        {
            return FALSE;
        }

#pragma prefast(push)
#pragma prefast(disable:69, "Don't complain about using wsprintf being too slow") 

        // BaseName and tmpName are both MAX_PATH
        wsprintfA(
            moduleInfo.BaseName,
            "%ws",
            tmpName
            );

        if( !ReadProcessMemory(
                ExtensionCurrentProcess,
                (LPCVOID)ldrEntryData.FullDllName.Buffer,
                tmpName,
                ldrEntryData.FullDllName.MaximumLength,
                NULL
                ) ) 
        {
            return FALSE;
        }

        // FullName and tmpName are both MAX_PATH
        wsprintfA(
            moduleInfo.FullName,
            "%ws",
            tmpName
            );

#pragma prefast(pop)

        moduleInfo.DllBase = (ULONG_PTR)ldrEntryData.DllBase;
        moduleInfo.EntryPoint = (ULONG_PTR)ldrEntryData.EntryPoint;
        moduleInfo.SizeOfImage = (ULONG)ldrEntryData.SizeOfImage;

        //
        // Invoke the callback.
        //

        if( !(EnumProc)(
                Param,
                &moduleInfo
                ) ) {
            break;
        }

        ldrNext = ldrEntryData.InMemoryOrderLinks.Flink;

    }

    return TRUE;

}   // EnumModules
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\common.c ===
/*++

Module Name:

    common.c

Abstract:

    This module contains common apis used by tlist & kill.

--*/

#include <windows.h>
#include <winperf.h>   // for Windows NT
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "common.h"
#include "inetdbgp.h"

//
// manifest constants
//

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         _T("software\\microsoft\\windows nt\\currentversion\\perflib")
#define REGSUBKEY_COUNTERS  _T("Counters")
#define PROCESS_COUNTER     _T("process")
#define PROCESSID_COUNTER   _T("id process")
#define TITLE_SIZE          64

typedef struct _SearchWin {
    LPCTSTR pExeName;
    LPDWORD pdwPid ;
    HWND*   phwnd;
} SearchWin ;


typedef struct _SearchMod {
    LPSTR   pExeName;
    LPBOOL  pfFound;
} SearchMod ;


//
// prototypes
//

BOOL CALLBACK
EnumWindowsProc2(
    HWND    hwnd,
    LPARAM   lParam
    );

HRESULT
IsDllInProcess( 
    DWORD   dwProcessId,
    LPSTR   pszName,
    LPBOOL  pfFound
    );

// 
// Functions
//

HRESULT
KillTask(
    LPTSTR      pName,
    LPSTR       pszMandatoryModule
    )
/*++

Routine Description:

    Provides an API for killing a task.

Arguments:

    pName - process name to look for
    pszMandatoryModule - if non NULL then this module must be loaded in the process space
        for it to be killed.

Return Value:

    Status

--*/
{
    DWORD                        rc;

    TCHAR                        szSubKey[1024];
    LANGID                       lid;
    HKEY                         hKeyNames = NULL;

    DWORD                        dwType = 0;
    DWORD                        dwSize = 0;
    DWORD                        dwSpaceLeft = 0;
    LPBYTE                       buf = NULL;
    LPTSTR                       p;
    LPTSTR                       p2;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle = 0;
    DWORD                        dwProcessIdCounter = 0;
    HRESULT                      hres = S_OK;
    HRESULT                      hresTemp = S_OK;
    HRESULT                      hresKill = S_OK;

    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );

    // There will be enough space in szSubKey to take the perf key
    // along with the lid that has come in.  
    wsprintf( szSubKey, _T("%s\\%03x"), REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );

    if (rc != ERROR_SUCCESS) 
    {
        hres = HRESULT_FROM_WIN32( rc );
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS ) 
    {
        hres = HRESULT_FROM_WIN32( rc );
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (LPBYTE) malloc( dwSize );
    if (buf == NULL) 
    {
        hres = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }
    memset( buf, 0, dwSize );

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) 
    {
        hres = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //

    p = (LPTSTR)buf;
    while (*p) 
    {

#pragma prefast(push)
#pragma prefast(disable:400, "Don't complain about case insensitive compares") 

        if (lstrcmpi(p, PROCESS_COUNTER) == 0) 
        {
            //
            // look backwards for the counter number
            //

            // buffer should of advanced far enough
            // to have space before it now.
            if ( ( LPVOID )p < ( LPVOID )(buf+2) )
            {
                 hres = E_FAIL;
                 goto exit;
            }

            // szSubkey is 1024 characters of space.
            // we will be copying in a number some space
            // and then the word "process", this should
            // be plenty of space.
            //
            for( p2=p-2; _istdigit(*p2); p2--)
            {
                if ( ( LPVOID )p2 == ( LPVOID )buf )
                {
                     hres = E_FAIL;
                     goto exit;
                }
            }

            lstrcpy( szSubKey, p2+1 );
        }
        else if (lstrcmpi(p, PROCESSID_COUNTER) == 0) 
        {


            // buffer should of advanced far enough
            // to have space before it now.
            if ( ( LPVOID )p < ( LPVOID )(buf+2) )
            {
                 hres = E_FAIL;
                 goto exit;
            }

            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--)
            {

                if ( ( LPVOID )p2 == ( LPVOID )buf )
                {
                    hres = E_FAIL;
                    goto exit;
                }
            }

            dwProcessIdTitle = _ttol( p2+1 );
        }
#pragma prefast(pop)

        //
        // next string
        //
        p += (lstrlen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    free( buf );

    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = malloc( dwSize );
    if (buf == NULL) 
    {
        hres = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }
    memset( buf, 0, dwSize );


    for ( ; ; )
    {
        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              buf,
                              &dwSize
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize >= sizeof(PERF_DATA_BLOCK)) &&
            (pPerf)->Signature[0] == (WCHAR)'P' &&
            (pPerf)->Signature[1] == (WCHAR)'E' &&
            (pPerf)->Signature[2] == (WCHAR)'R' &&
            (pPerf)->Signature[3] == (WCHAR)'F' ) 
        {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) 
        {

            dwSize += EXTEND_SIZE;

            free ( buf );
            buf = NULL;

            buf = malloc( dwSize );
            if (buf == NULL) 
            {
                hres = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }
            memset( buf, 0, dwSize );

        }
        else 
        {
            // in the off case that we got data back under 
            // this key, but it was not the correct data, we 
            // need to return some error.
            if ( rc == ERROR_SUCCESS )
            {
                rc = ERROR_INVALID_DATA;
            }
            goto exit;
        }
    }

    // make sure we don't ever walk past the end of the perf counter stuff.
    // Subtract the space the PERF_DATA_BLOCK takes
    dwSpaceLeft = dwSize - pPerf->HeaderLength;

    // Validate that pObj will still be pointing
    // to memory we just read.
    if ( dwSpaceLeft < sizeof(PERF_OBJECT_TYPE) )
    {
        rc = ERROR_INVALID_DATA;
        goto exit;
    }
    else
    {
        // Subtract the space the PERF_OBJECT_BLOCK takes
        dwSpaceLeft = dwSpaceLeft - sizeof(PERF_OBJECT_TYPE);
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((LPBYTE)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //

    // Validate that we have enough space for all the
    // counter definitions we are expecting.
    // to memory we just read.
    if ( dwSpaceLeft < sizeof(PERF_COUNTER_DEFINITION) * pObj->NumCounters )
    {
        rc = ERROR_INVALID_DATA;
        goto exit;
    }
    else
    {
        // Subtract the space the PERF_OBJECT_BLOCK takes
        dwSpaceLeft = dwSpaceLeft - ( sizeof(PERF_COUNTER_DEFINITION) * pObj->NumCounters ) ;
    }

    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD_PTR)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) 
    {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) 
        {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    pInst = (PPERF_INSTANCE_DEFINITION) ((LPBYTE)pObj + pObj->DefinitionLength);

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //
    for (i=0; i<(DWORD)pObj->NumInstances; i++) 
    {
        // Validate that we have enough space for the
        // instance definition.
        if ( dwSpaceLeft < sizeof(PERF_INSTANCE_DEFINITION) ||
             dwSpaceLeft < pInst->ByteLength )
        {
            rc = ERROR_INVALID_DATA;
            goto exit;
        }
        else
        {
            dwSpaceLeft = dwSpaceLeft - pInst->ByteLength;
        }


        //
        // pointer to the process name
        //
        p = (LPTSTR) ((LPBYTE)pInst + pInst->NameOffset);

        //
        // get the process id
        //

        pCounter = (PPERF_COUNTER_BLOCK) ((LPBYTE)pInst + pInst->ByteLength);

        // Validate that we have enough space for the
        // counter values we are expecting.
        if ( dwSpaceLeft < sizeof(PERF_COUNTER_BLOCK) ||
             dwSpaceLeft < pCounter->ByteLength )
        {
            rc = ERROR_INVALID_DATA;
            goto exit;
        }
        else
        {
            dwSpaceLeft = dwSpaceLeft - pCounter->ByteLength;
        }

        if ( lstrcmpi( p, pName ) == 0 )
        {
            //
            // Kill process now, do not update pTask array
            //

            BOOL        fIsInProcess;
            DWORD       dwProcessId = *((LPDWORD) ((LPBYTE)pCounter + dwProcessIdCounter));

            if ( pszMandatoryModule == NULL ||
                 ( SUCCEEDED( hresTemp = IsDllInProcess( dwProcessId, pszMandatoryModule, &fIsInProcess ) ) &&
                   fIsInProcess ) )
            {
//              OutputDebugStringW(L"Killing ");
//              OutputDebugStringW(pName);
//              OutputDebugStringW(L"\r\n");
                hresTemp = KillProcess( dwProcessId );
            }

            // Need to remember the first failure, but we want
            // to go on and try to kill the rest as well
            if ( FAILED ( hresTemp ) && SUCCEEDED( hresKill ) )
            {
                hresKill = hresTemp;
            }

        }

        //
        // next process
        //

        pInst = (PPERF_INSTANCE_DEFINITION) ((LPBYTE)pCounter + pCounter->ByteLength);
    }

 exit:

    if (buf) 
    {
        free( buf );
    }

    if ( hKeyNames != NULL )
    {
        RegCloseKey( hKeyNames );
    }

    if ( SUCCEEDED ( hres ) )
    {
        return hresKill;
    }
    else
    {
        return hres;
    }
}

BOOL
EnableDebugPrivNT(
    VOID
    )

/*++

Routine Description:

    Changes the process's privilege so that kill works properly.

Arguments:


Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    HANDLE hToken;
    LUID DebugValue;
    TOKEN_PRIVILEGES tkp;

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) 
    {
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege
    //
    if (!LookupPrivilegeValue((LPTSTR) NULL,
            SE_DEBUG_NAME,
            &DebugValue)) 
    {
        return FALSE;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken,
        FALSE,
        &tkp,
        sizeof(TOKEN_PRIVILEGES),
        (PTOKEN_PRIVILEGES) NULL,
        (PDWORD) NULL);

    //
    // The return value of AdjustTokenPrivileges can't be tested
    //

    if (GetLastError() != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
EnumModulesCallback(
    LPVOID          pParam,
    PMODULE_INFO    pModuleInfo
    )
/*++

Routine Description:

    Called by module enumerator with info on current module

Arguments:

    pParam - as specified in the call to EnumModules()
    pModuleInfo - module information

Return Value:

    TRUE to continue enumeration, FALSE to stop it

--*/
{
    if ( !_strcmpi( pModuleInfo->BaseName, ((SearchMod*)pParam)->pExeName ) )
    {
        *((SearchMod*)pParam)->pfFound = TRUE;

        return FALSE;   // stop enumeration
    }

    return TRUE;
}


HRESULT
IsDllInProcess( 
    DWORD   dwProcessId,
    LPSTR   pszName,
    LPBOOL  pfFound
    )
/*++

Routine Description:

    Check if a module ( e.g. DLL ) exists in specified process

Arguments:

    dwProcessId - process ID to scan for module pszName
    pszName - module name to look for, e.g. "wam.dll"
    pfFound - updated with TRUE if pszName found in process dwProcessId
              valid only if functions succeed.

Return Value:

    Status. 

--*/
{
    HANDLE              hProcess;
    HRESULT             hres = S_OK;
    SearchMod           sm;

    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
                            PROCESS_VM_READ, 
                            FALSE, 
                            dwProcessId );
    if ( hProcess == NULL )
    {
        // PID may have gone away while we were 
        // working on it, if it has then we will
        // get invalid parameter when we try and
        // open it.
        if ( GetLastError() == ERROR_INVALID_PARAMETER )
        {
            *pfFound = FALSE;
            return S_OK;
        }

        return HRESULT_FROM_WIN32( GetLastError() );
    }

    sm.pExeName = pszName;
    sm.pfFound= pfFound;
    *pfFound = FALSE;

    if ( !EnumModules( hProcess, EnumModulesCallback, (LPVOID)&sm ) )
    {
        hres = E_FAIL;
    }

    CloseHandle( hProcess );

    return hres;
}


HRESULT
KillProcess(
    DWORD dwPid
    )
{
    HANDLE              hProcess = NULL;
    HRESULT             hres = S_OK;

    hProcess = OpenProcess( PROCESS_TERMINATE,
                                FALSE, 
                                dwPid );

    if ( hProcess == NULL )
    {        
        // Process might have gone away since we found it.
        if ( GetLastError() == ERROR_INVALID_PARAMETER )
        {
            return S_OK;
        }

        hres = HRESULT_FROM_WIN32( GetLastError() );
    }

    // OpenProcess worked
    if ( SUCCEEDED(hres) )
    {
        if (!TerminateProcess( hProcess, 1 )) 
        {
            //
            // If error code is access denied then the process may have
            // all ready been terminated, so treat this as success.  If
            // it was not caused by the process all ready being terminated
            // then we will catch the error below by timing out waiting
            // for the process to disappear.
            //
            if ( GetLastError() == ERROR_ACCESS_DENIED )
            {
                hres = S_OK;
            }
            else
            {
                hres = HRESULT_FROM_WIN32( GetLastError() );
            }
        }
        else
        {
            hres = S_OK;
        }

        CloseHandle( hProcess );
    }
    return hres;
}


VOID
GetPidFromTitle(
    LPDWORD     pdwPid,
    HWND*       phwnd,
    LPCTSTR     pExeName
    )
/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    pdwPid - updated with process ID of window matching window name or 0 if window not found
    phwnd - updated with window handle matching searched window name
    pExeName - window name to look for. Only the # of char present in this name will be 
               used during checking for a match ( e.g. "inetinfo.exe" will match "inetinfo.exe - Application error"

Return Value:

    None. *pdwPid will be 0 if no match is found

--*/
{
    SearchWin   sw;

    sw.pdwPid = pdwPid;
    sw.phwnd = phwnd;
    sw.pExeName = pExeName;
    *pdwPid = 0;

    //
    // enumerate all windows
    //
    EnumWindows( (WNDENUMPROC)EnumWindowsProc2, (LPARAM) &sw );
}



BOOL CALLBACK
EnumWindowsProc2(
    HWND    hwnd,
    LPARAM   lParam
    )
/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    hwnd             - window handle
    lParam           - ptr to SearchWin

Return Value:

    TRUE  - continues the enumeration

--*/
{
    DWORD             pid = 0;
    TCHAR             buf[TITLE_SIZE];
    SearchWin*        psw = (SearchWin*)lParam;

    //
    // get the processid for this window
    //

    if (!GetWindowThreadProcessId( hwnd, &pid )) 
    {
        return TRUE;
    }

    if (GetWindowText( hwnd, buf, sizeof(buf)/sizeof(TCHAR) ))
    {
        if ( lstrlen( buf ) > lstrlen( psw->pExeName ) )
        {
            buf[lstrlen( psw->pExeName )] = _T('\0');
        }

        if ( !lstrcmpi( psw->pExeName, buf ) )
        {
            *psw->phwnd = hwnd;
            *psw->pdwPid = pid;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\iisrestart.h ===
// IisRestart.h : Declaration of the CIisRestart

#ifndef __IISRESTART_H_
#define __IISRESTART_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CIisRestart
class ATL_NO_VTABLE CIisRestart : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CIisRestart, &CLSID_IisServiceControl>,
	public IDispatchImpl<IIisServiceControl, &IID_IIisServiceControl, &LIBID_IISRSTALib>
{
public:
	CIisRestart()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IISRESTART)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIisRestart)
	COM_INTERFACE_ENTRY(IIisServiceControl)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIisRestart
public:
	STDMETHOD(Status)(/*[IN]*/ DWORD dwBufferSize, /*[out, size_is(dwBufferSize)]*/ unsigned char *pbBuffer, /*[out]*/ DWORD *pdwMDRequiredBufferSize, /*[out]*/ DWORD *pdwNumServices);
	STDMETHOD(Reboot)( DWORD dwTimeoutMsecs, DWORD dwForceAppsClosed );
	STDMETHOD(Start)(DWORD dwTimeoutMsecs);
	STDMETHOD(Stop)(DWORD dwTimeoutMsecs, DWORD dwForce);
	STDMETHOD(Kill)();
};

#endif //__IISRESTART_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\iisrestart.cpp ===
/*
    IisRestart.cpp

    Implementation of CIisRestart ( IIisServiceControl )

    FILE HISTORY:
        Phillich    06-Oct-1998     Created

*/


#include "stdafx.h"
#include "IisRsta.h"
#include "IisRstam.h"
#include "IisRestart.h"
#include "common.h"

#define MAX_TASKS 8
#define SLEEP_INTERVAL  1000

typedef BOOL (*PFNQUERYSERVICECONFIG2)(SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD) ;
typedef BOOL (*PFNCHANGESERVICECONFIG2)(SC_HANDLE,DWORD,LPVOID);

//
// control block for control command requests
//

typedef struct {
    HRESULT     hres;
    LONG        lRefCount;
    DWORD       dwCmd;
    SC_HANDLE   hServiceHandle;
} SERVICE_COMMAND_CONTROL_BLOCK;



//
// Global functions
//
BOOL
W3SVCandHTTPFilter(
    DWORD currentIndex, 
    ENUM_SERVICE_STATUS* pessRoot,
    DWORD dwNumServices
    );

VOID EnableShutdownPrivilege(
    VOID
    );

HRESULT
EnumStartServices(
    SC_HANDLE   schSCM,
    LPTSTR      pszRoot,
    DWORD       dwTargetState,
    LPBYTE      abServiceList,
    DWORD       dwInitializeServiceListSize,
    LPBYTE*     ppbServiceList,
    LPDWORD     pdwNumServices,
    BOOL        fAddIisadmin
    );

HRESULT
SerializeEnumServiceBuffer( 
    LPENUM_SERVICE_STATUS   pessDependentServices,
    DWORD                   dwNumServices,
    LPBYTE                  pbBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwMDRequiredBufferSize 
    );

BOOL
IsEnableRemote(
    );

HRESULT
StopIIsAdmin(
    DWORD   dwTimeoutMsecs
    );

HRESULT
StartStopAll(
    LPTSTR  pszRoot,
    BOOL    fStart,
    DWORD   dwTimeoutMsecs
    );

BOOL
WaitForServiceStatus(
    SC_HANDLE   schDependent, 
    DWORD       dwDesiredServiceState,
    DWORD       dwTimeoutMsecs
    );

HRESULT
KillTaskByName(
    LPTSTR  pname,
    LPSTR   pszMandatoryModule
    );

VOID
ReportStatus(
    DWORD   dwId,
    DWORD   dwStatus
    );

HRESULT
SendControlToService( 
    SC_HANDLE   hServiceHandle,
    DWORD       dwCmd,
    LPDWORD     pdwTimeoutOutMsecs
    );

StartStopAllRecursive(
    SC_HANDLE               schSCM,
    ENUM_SERVICE_STATUS*    pessRoot,
    DWORD                   dwNumServices,
    BOOL                    fStart,
    BOOL                    fForceDemandStart,
    LPDWORD                 pdwTimeoutMsecs
    );

HRESULT
WhoAmI(
    LPTSTR* pPrincipal
    );

BOOL
CloseSystemExceptionHandler(
    LPCTSTR     pszWindowName
    );

/////////////////////////////////////////////////////////////////////////////
// CIisRestart


STDMETHODIMP 
CIisRestart::Stop(
    DWORD   dwTimeoutMsecs,
    DWORD   dwForce
    )
/*++

    Stop

        Stop all internet services ( services dependent on IISADMIN )
        first using SCM then optionaly using TerminateProcess if failure

    Arguments:

        dwTimeoutMsecs  - timeout for status check ( in ms )
        dwForce - !0 to force TerminateProcess if failure to stop services using SCM

    Returns:
        ERROR_RESOURCE_DISABLED if remote access to IIisRestart disabled
        ERROR_SERVICE_REQUEST_TIMEOUT if timeout waiting for all internet services status
            to be stopped
        otherwise COM status

--*/
{
    HRESULT hres = S_OK;

    if ( !IsEnableRemote() )
    {
        hres = HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED );
    }
    else 
    {
        //
        // Always kill Dr Watson, as the Dr Watson window may be still present after inetinfo process
        // was terminated after an exception, and in this case the Dr Watson process apparently still owns
        // some sockets resources preventing inetinfo to properly restart ( specifically binding TCP/IP sockets 
        // fails during inetinfo restart )
        //

        KillTaskByName(_T("drwtsn32"), NULL);

        hres = StartStopAll( _T("IISADMIN"), FALSE, dwTimeoutMsecs );
        if ( dwForce && FAILED( hres ) )
        {
            ReportStatus( IRSTAM_KILL_DUE_TO_FORCE, hres );
            hres = Kill();
        }
    }

    ReportStatus( IRSTAM_STOP, hres );

    return hres;
}


STDMETHODIMP 
CIisRestart::Start(
    DWORD   dwTimeoutMsecs
    )
/*++

    Start

        Start all internet services ( services dependent on IISADMIN )
        using SCM

    Arguments:

        dwTimeoutMsecs  - timeout for status check ( in ms )

    Returns:
        ERROR_RESOURCE_DISABLED if remote access to IIisRestart disabled
        ERROR_SERVICE_REQUEST_TIMEOUT if timeout waiting for all internet services status
            to be started
        otherwise COM status

--*/
{
    HRESULT hres = S_OK;

    if ( !IsEnableRemote() )
    {
        hres = HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED );
    }
    else
    {
        //
        // In 6.0 we will use IIS Reset /Start to bring up the
        // service again without stopping the services that can
        // keep running.  We still want to kill any dr watson's 
        // thou.  This should be harmless on a regular start.
        //

        //
        // Always kill Dr Watson, as the Dr Watson window may be still present after inetinfo process
        // was terminated after an exception, and in this case the Dr Watson process apparently still owns
        // some sockets resources preventing inetinfo to properly restart ( specifically binding TCP/IP sockets 
        // fails during inetinfo restart )
        //

        KillTaskByName(_T("drwtsn32"), NULL);

        hres = StartStopAll( _T("IISADMIN"), TRUE, dwTimeoutMsecs );
    }

    ReportStatus( IRSTAM_START, hres );

    return hres;
}


STDMETHODIMP 
CIisRestart::Reboot(
    DWORD   dwTimeoutMsecs, 
    DWORD   dwForceAppsClosed
    )
/*++

    Reboot

        Reboot the computer

    Arguments:

        dwTimeoutMsecs  - timeout for apps to be closed by user ( in ms )
        dwForceAppsClosed - force apps to be closed if hung

    Returns:
        ERROR_RESOURCE_DISABLED if remote access to IIisRestart disabled
        otherwise COM status

--*/
{
    HRESULT hres = S_OK;

    if ( !IsEnableRemote() )
    {
        hres =  HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED );
    }
    else
    {
        //
        // If this fails then we will get an error back from ExitWindowsEx()
        //

        EnableShutdownPrivilege();
    
        //
        // Make sure we will always reboot even if process(es) stuck
        //

        TCHAR*  pPrincipal;
        TCHAR*  pBuf;

        //
        // Format message to operator, includes name of user requesting shutdown.
        //

        if ( SUCCEEDED( hres = WhoAmI( &pPrincipal ) ) )
        {
            if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                (LPCVOID)NULL,  // no handle to module so this module's resource will be used.
                                IRSTAM_SYSSHUT,
                                0,
                                (LPTSTR)&pBuf,
                                1,
                                (va_list *)&pPrincipal ) )
            {
                if (InitiateSystemShutdownEx( NULL, 
                                            pBuf, 
                                            dwTimeoutMsecs/1000,    // timeout in seconds
                                            dwForceAppsClosed, 
                                            TRUE,
                                            SHTDN_REASON_FLAG_PLANNED | 
                                            SHTDN_REASON_MAJOR_OPERATINGSYSTEM | 
                                            SHTDN_REASON_MINOR_RECONFIG) == 0)
                {
                    hres = HRESULT_FROM_WIN32( GetLastError() );
                }
                LocalFree( (LPVOID)pBuf );
            }

            LocalFree( pPrincipal );
        }

    }

    ReportStatus( IRSTAM_REBOOT, hres );

    return hres;
}


STDMETHODIMP 
CIisRestart::Kill(
    )
/*++

    Kill

        Kill all internet services ( services dependent on IISADMIN )
        using TerminateProcess()

    Arguments:

        None

    Returns:
        ERROR_RESOURCE_DISABLED if remote access to IIisRestart disabled
        otherwise COM status

--*/
{
    HRESULT                 hres = S_OK;
    HRESULT                 hresReapply = S_OK;
    HRESULT                 hresKill = S_OK;
    BYTE                    abServiceList[2048];
    LPBYTE                  pbServiceList = NULL;
    DWORD                   dwNumServices = 0;
    SC_HANDLE               schSCM = NULL;
    SC_HANDLE               schSrv;
    LPBYTE*                 ppInfo = NULL;
    LPENUM_SERVICE_STATUS   pessDependentServices = NULL;
    DWORD                   dwNeeded;
    HINSTANCE               hAdvapi;
    PFNQUERYSERVICECONFIG2  pfnQueryServiceConfig2 = NULL;
    PFNCHANGESERVICECONFIG2 pfnChangeServiceConfig2 = NULL;
    SERVICE_FAILURE_ACTIONS sfaNoAction;
    SC_ACTION               saNoAction[3];
    DWORD                   i;
    BYTE                    abTemp[64];     // work-around for NT5 bug
    DWORD*                  adwPid = NULL;
    SERVICE_STATUS_PROCESS  status;
    DWORD                   cbNeeded = 0;

    if ( !IsEnableRemote() )
    {
        return  HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED );
    }

    //
    // Take a snapshot of Restart configuration
    // If unable to get ptr to service config2 API then consider this a success:
    // there is nothing to preserve.
    //

    hAdvapi = LoadLibrary(_T("ADVAPI32.DLL"));
    if ( hAdvapi != NULL )
    {
        pfnQueryServiceConfig2 = (PFNQUERYSERVICECONFIG2)GetProcAddress( hAdvapi, "QueryServiceConfig2W" );
        pfnChangeServiceConfig2 = (PFNCHANGESERVICECONFIG2)GetProcAddress( hAdvapi, "ChangeServiceConfig2W" );
    }

    if ( pfnQueryServiceConfig2 
         && pfnChangeServiceConfig2 )
    {
        schSCM = OpenSCManager(NULL,
                               NULL,
                               SC_MANAGER_ENUMERATE_SERVICE);
        if ( schSCM == NULL )
        {
            hres = HRESULT_FROM_WIN32( GetLastError() );
        }
        else 
        {
            //
            // Setup control block for no restart action.
            // We will replace existing actions with this control block
            //

            sfaNoAction.dwResetPeriod = INFINITE;
            sfaNoAction.lpCommand = _T("");
            sfaNoAction.lpRebootMsg = _T("");
            sfaNoAction.cActions = 3;
            sfaNoAction.lpsaActions = saNoAction;

            saNoAction[0].Type = SC_ACTION_NONE;
            saNoAction[0].Delay = 0;
            saNoAction[1].Type = SC_ACTION_NONE;
            saNoAction[1].Delay = 0;
            saNoAction[2].Type = SC_ACTION_NONE;
            saNoAction[2].Delay = 0;

            //
            // Enumerate all services dependent on IISADMIN ( including itself )
            //

            hres = EnumStartServices( schSCM,
                                      _T("IISADMIN"),
                                      SERVICE_STATE_ALL,
                                      abServiceList, 
                                      sizeof(abServiceList), 
                                      &pbServiceList, 
                                      &dwNumServices,
                                      TRUE );

            if ( SUCCEEDED( hres ) )
            {
                //
                // Store existing info in ppInfo array
                //
                adwPid = new DWORD[ dwNumServices ];
                // we don't check the adwPid here because
                // we will only use it below if we succeeded in allocating it.
                if ( adwPid )
                {
                    memset ( adwPid, 0, sizeof(DWORD) * dwNumServices );
                }

                ppInfo = (LPBYTE*)LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT, sizeof(LPBYTE) * dwNumServices );

                if ( ppInfo )
                {
                    pessDependentServices = (LPENUM_SERVICE_STATUS)pbServiceList;

                    for ( i = 0 ; 
                          (i < dwNumServices) && SUCCEEDED(hres) ;
                          ++i )
                    {
                        schSrv = OpenService( schSCM,
                                              pessDependentServices[i].lpServiceName,
                                              SERVICE_QUERY_CONFIG |
                                              SERVICE_CHANGE_CONFIG |
                                              SERVICE_QUERY_STATUS );

                        if ( schSrv )
                        {

                            if ( adwPid )
                            {
                                if ( QueryServiceStatusEx( schSrv, 
                                                           SC_STATUS_PROCESS_INFO,
                                                           (LPBYTE)&status,
                                                           sizeof( status ),
                                                           &cbNeeded ) )
                                {
                                    adwPid[i] = status.dwProcessId;
                                }
                            }

                            //
                            // 1st query config size, then alloc buffer and retrieve
                            // config. Note than ppInfo[] may be NULL is no config
                            // associated with this service.
                            //
                            // WARNING: must specify ptr to writable buffer even if specified
                            // buffer size is 0 due to bug in NT5 implementation of
                            // QueryServiceConfig2. Not sure about minimum buffer size
                            // ( sizeof(SERVICE_FAILURE_ACTIONS) ) ?
                            //

                            if ( !pfnQueryServiceConfig2( schSrv, 
                                                          SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                          (LPBYTE)abTemp, 
                                                          0, 
                                                          &dwNeeded ) )
                            {
                                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                                {
                                    // ppInfo is an array of ptrs to bytes.
                                    ppInfo[i] = (LPBYTE)LocalAlloc( LMEM_FIXED, dwNeeded );
                                    if ( ppInfo[i] != NULL )
                                    {
                                        if ( !pfnQueryServiceConfig2( schSrv, 
                                                                      SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                                      ppInfo[i], 
                                                                      dwNeeded, 
                                                                      &dwNeeded ) )
                                        {

                                            hres = HRESULT_FROM_WIN32( GetLastError() );
                                        }
                                    }
                                    else
                                    {
                                        hres = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                                    }
                                }
                                else
                                {
                                    hres = HRESULT_FROM_WIN32( GetLastError() );
                                }
                            }

                            if ( SUCCEEDED( hres ) )
                            {
                                if ( !pfnChangeServiceConfig2( schSrv, 
                                                               SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                               &sfaNoAction ) )
                                {
                                    hres = HRESULT_FROM_WIN32( GetLastError() );
                                }
                            }

                            CloseServiceHandle( schSrv );
                        }
                        else
                        {
                            hres = HRESULT_FROM_WIN32( GetLastError() );
                        }
                    }  // Close of the for loop
                }
                else
                {
                    hres = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                }
            }

            CloseServiceHandle( schSCM );
        }
    }


    //
    // Graceful exit failed, kill the IIS processes.
    // First, kill inetinfo, then kill the WAM instances.
    //

    // Issue:  Not sure why we do this, and if we need to do it for other exe's.
    CloseSystemExceptionHandler( _T("inetinfo.exe") );

    //
    // Always kill Dr Watson, as the Dr Watson window may be still present after inetinfo process
    // was terminated after an exception, and in this case the Dr Watson process apparently still owns
    // some sockets resources preventing inetinfo to properly restart ( specifically binding TCP/IP sockets 
    // fails during inetinfo restart )
    //

    // If we removed all the SCM config above then
    // we will attempt the kills
    if ( SUCCEEDED ( hres ) )
    {
        HRESULT hresKillTemp = S_OK;

        KillTaskByName(_T("drwtsn32"), NULL);

        hresKillTemp = KillTaskByName(_T("SVCHOST"), "iisw3adm.dll");   // MTS WAM containers
        if ( SUCCEEDED ( hresKill ) )
        {
            hresKill = hresKillTemp;
        }

        hresKillTemp = KillTaskByName(_T("W3WP"), NULL);   // MTS WAM containers
        if ( SUCCEEDED ( hresKill ) )
        {
            hresKill = hresKillTemp;
        }

        hresKillTemp = KillTaskByName(_T("INETINFO"), NULL);
        if ( SUCCEEDED ( hresKill ) )
        {
            hresKill = hresKillTemp;
        }

        hresKillTemp = KillTaskByName(_T("DLLHOST"),"wam.dll");   // COM+ WAM Containers
        if ( SUCCEEDED ( hresKill ) )
        {
            hresKill = hresKillTemp;
        }

        hresKillTemp = KillTaskByName(_T("ASPNET_WP"), NULL);   // ASP + Processes.
        if ( SUCCEEDED ( hresKill ) )
        {
            hresKill = hresKillTemp;
        }

        hresKillTemp = KillTaskByName(_T("DAVCDATA"), NULL);   // Dav support process.
        if ( SUCCEEDED ( hresKill ) )
        {
            hresKill = hresKillTemp;
        }


        // the following code will check the IISAdmin registry parameters for
        // a KillProcsOnFailure MULTI_SZ.  Any process names in this list will
        // be killed.

        HKEY        hKey;
        DWORD       dwType;
        DWORD       dwSize;
        TCHAR       achBuffer[1024];

        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                           TEXT("system\\CurrentControlSet\\services\\IISAdmin"), 
                           0, 
                           KEY_READ, 
                           &hKey ) == ERROR_SUCCESS )
        {
            DWORD Success = ERROR_SUCCESS;

            dwSize = sizeof( achBuffer );

            Success = RegQueryValueEx( hKey, 
                                  TEXT("KillProcsOnFailure"),
                                  0, 
                                  &dwType, 
                                  (LPBYTE)achBuffer, 
                                  &dwSize );
            if ( Success == ERROR_SUCCESS &&
                 dwType == REG_MULTI_SZ &&
                 dwSize > 2 )
            {

                TCHAR *pT = achBuffer;

                // parse the multisz.  The format is NULL Terminated strings
                // with an extra null terminator after the list.

                while (*pT) 
                {

                    hresKillTemp = KillTaskByName(pT, NULL);
                    if ( SUCCEEDED ( hresKill ) )
                    {
                        hresKill = hresKillTemp;
                    }
            
                    // _tcsnbcnt figures out how many bytes are in the 
                    // the first number of characters that _tcslen declares.
                    // So this calculation works out to be the number of bytes
                    // that we just looked at plus the null terminator.
                    dwSize -= (DWORD) _tcsnbcnt(pT,_tcslen(pT)) + sizeof(TCHAR);

                    pT += _tcslen(pT) + 1;

                }
            } // end of successfull opening of the key

            RegCloseKey( hKey );
        }

    }

    hresReapply = S_OK;

    //
    // Reapply restart configuration
    //

    //
    // At this point pessDependentServices if pessDependentServices
    // is null then we didn't touch the services so don't reset.
    //
    if ( ppInfo && pessDependentServices )
    {
        schSCM = OpenSCManager(NULL,
                               NULL,
                               SC_MANAGER_ENUMERATE_SERVICE);
        if ( schSCM == NULL )
        {
            hresReapply = HRESULT_FROM_WIN32( GetLastError() );
        }
        else 
        {
            for ( i = 0 ; i < dwNumServices ; ++i )
            {
                if ( ppInfo[i] )
                {
                    schSrv = OpenService( schSCM,
                                          pessDependentServices[i].lpServiceName,
                                          SERVICE_QUERY_CONFIG |
                                          SERVICE_CHANGE_CONFIG |
                                          SERVICE_QUERY_STATUS |
                                          SERVICE_START );

                    if ( schSrv )
                    {
 //                       OutputDebugStringW(L"Service = ");
 //                       OutputDebugStringW(pessDependentServices[i].lpServiceName);
 //                       OutputDebugStringW(L"\n");

                        //
                        // If any of these things are not true, then we want to wait
                        // for the pid to change, or the service to become stopped
                        // before adding back in the changes that we removed.  If these
                        // things are all true, then adding back in the actions won't really
                        // matter because the SCM won't do anything with the actions.
                        //
                        if ( ((LPSERVICE_FAILURE_ACTIONS) ppInfo[i])->cActions != 3 ||
                             ((LPSERVICE_FAILURE_ACTIONS) ppInfo[i])->lpsaActions == NULL ||
                             ((LPSERVICE_FAILURE_ACTIONS) ppInfo[i])->lpsaActions[0].Type != SC_ACTION_NONE ||
                             ((LPSERVICE_FAILURE_ACTIONS) ppInfo[i])->lpsaActions[1].Type != SC_ACTION_NONE ||
                             ((LPSERVICE_FAILURE_ACTIONS) ppInfo[i])->lpsaActions[2].Type != SC_ACTION_NONE )
                        {
                            // Wait for the service to be marked as stopped,
                            // just for a certain amount of time.
                            for ( DWORD x = 0; x < 10; x++ )
                            {
                                if ( QueryServiceStatusEx( schSrv, 
                                                           SC_STATUS_PROCESS_INFO,
                                                           (LPBYTE)&status,
                                                           sizeof( status ),
                                                           &cbNeeded ) )
                                {
                                    if ( adwPid && status.dwProcessId != adwPid[i] )
                                    {
                                        // pid didn't match, not the same
                                        // process we were looking at when
                                        // we went to kill.
                                        break;
                                    }

                                    if ( status.dwCurrentState == SERVICE_STOPPED )
                                    {
                                        break;
                                    }
                                }
                                else
                                {
                                    break;
                                }

                                Sleep ( 100 );
                            }
                        }

                        if ( !pfnChangeServiceConfig2( schSrv, 
                                                       SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                       ppInfo[i] ) )
                        {
                            hresReapply = HRESULT_FROM_WIN32( GetLastError() );
                        }

                        CloseServiceHandle( schSrv );
                    }
                    else
                    {
                        hresReapply = HRESULT_FROM_WIN32( GetLastError() );
                    }
                }
            }

            CloseServiceHandle( schSCM );
        }
    }

    // If we tried the kills and they failed then
    // we want to report back that error.  Note that
    // we check that the setup phase worked before
    // we even try the kill phase, so we can just
    // assume that.
    if ( FAILED(hresKill) )
    {
        hres = hresKill;
    }

    if ( SUCCEEDED(hres) && FAILED(hresReapply) )
    {
        hres = hresReapply;
    }

    ReportStatus( IRSTAM_KILL, hres );

    if ( hAdvapi )
    {
        FreeLibrary( hAdvapi );
    }

    //
    // cleanup
    //

    if ( ppInfo )
    {
        for ( i = 0 ; i < dwNumServices ; ++i )
        {
            if ( ppInfo[i] )
            {
                LocalFree( ppInfo[i] );
            }
        }
        LocalFree( ppInfo );
    }

    if ( pbServiceList != NULL 
         && pbServiceList != abServiceList )
    {
        LocalFree( pbServiceList );
    }

    if ( adwPid )
    {
        delete [] adwPid;
    }

    return hres;
}


//
// Helper functions
//

VOID 
EnableShutdownPrivilege(
    VOID
    )
/*++

    EnableShutdownPrivilege

        Enable shutdown privilege ( required to call ExitWindowsEx )

    Arguments:

        None

    Returns:
        Nothing. If error enabling the privilege the dependent operation
        will fail.

--*/
{
    HANDLE ProcessHandle;
    HANDLE TokenHandle = NULL;
    BOOL Result;
    LUID ShutdownValue;
    TOKEN_PRIVILEGES TokenPrivileges;

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of Shutdown privilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 SE_SHUTDOWN_NAME,
                 &ShutdownValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = ShutdownValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof(TokenPrivileges),
                NULL,
                NULL
                );
Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}

HRESULT
StartStopAll(
    LPTSTR  pszRoot,
    BOOL    fStart,
    DWORD   dwTimeoutMsecs
    )
/*++

    StartStopAll

        start or stop services dependency tree starting with specified root service

    Arguments:
        
        pszRoot - root of the service tree
        fStart - TRUE to start services, FALSE to stop
        dwTimeoutMsecs  - timeout for status check ( in ms )

    Returns:
        COM status

--*/
{
    SC_HANDLE               schSCM = NULL;
    SC_HANDLE               schRoot = NULL;
    HRESULT                 hresReturn = S_OK;
    ENUM_SERVICE_STATUS     ess;


    schSCM = OpenSCManager(NULL,
                           NULL,
                           SC_MANAGER_CONNECT);
    if ( schSCM == NULL )
    {
        hresReturn = HRESULT_FROM_WIN32( GetLastError() );
    }
    else 
    {
        schRoot = OpenService( schSCM, 
                               pszRoot, 
                               SERVICE_ALL_ACCESS );
        if ( schRoot != NULL )
        {
            if ( !QueryServiceStatus( schRoot, &ess.ServiceStatus ) )
            {
                hresReturn = HRESULT_FROM_WIN32( GetLastError() );
            }

            CloseServiceHandle( schRoot );

            if ( SUCCEEDED( hresReturn ) 
                    && ( fStart 
                         || ess.ServiceStatus.dwCurrentState != SERVICE_STOPPED) )
            {
                ess.lpServiceName = pszRoot;

                // if it's stopped, then whack the dllhosts that have wam.dll loaded

                if (ess.ServiceStatus.dwCurrentState == SERVICE_STOPPED) 
                {
                    KillTaskByName(_T("DLLHOST"),"wam.dll");   // COM+ WAM Containers
                }

                hresReturn = StartStopAllRecursive( schSCM, &ess, 1, fStart, TRUE, &dwTimeoutMsecs );

            }

            // check out the current state of the service

            schRoot = OpenService( schSCM, pszRoot, SERVICE_ALL_ACCESS );
            if ( schRoot != NULL )
            {
                if ( QueryServiceStatus( schRoot, &ess.ServiceStatus ) )
                {
                    // if it's stopped, then whack the dllhosts that have wam.dll loaded

                    if (ess.ServiceStatus.dwCurrentState == SERVICE_STOPPED)
                    {
                        KillTaskByName(_T("DLLHOST"),"wam.dll");   // COM+ WAM Containers
                    }
                }

                CloseServiceHandle( schRoot );
            }        
        }
        else
        {
            hresReturn = HRESULT_FROM_WIN32( GetLastError() );
        }

        CloseServiceHandle( schSCM );
    }

    return hresReturn;
}

StartStopAllRecursive(
    SC_HANDLE               schSCM,
    ENUM_SERVICE_STATUS*    pessRoot,
    DWORD                   dwNumServices,
    BOOL                    fStart,
    BOOL                    fForceDemandStart,
    LPDWORD                 pdwTimeoutMsecs
    )
/*++

    StartStopAllRecursive

        start or stop services dependency tree starting with specified root service

    Arguments:
        
        schSCM - handle to SCM
        pessRoot - list of services to start/stop recursively
        fStart - TRUE to start services, FALSE to stop
        fForceDemandStart - for start requests: TRUE to force start
                if SERVICE_DEMAND_START. Otherwise only start if service
                is auto start ( including boot & system start )
        dwTimeoutMsecs  - timeout for status check ( in ms )

    Returns:
        COM status

--*/
{
    DWORD                   dwBytesNeeded;
    DWORD                   dwNumRecServices = 0;
    HRESULT                 hresReturn = S_OK;
    BYTE                    abServiceList[2048];
    LPBYTE                  pbServiceList = NULL;
    BYTE                    abServiceConfig[1024];
    LPQUERY_SERVICE_CONFIG  pServiceConfig = NULL;
    SC_HANDLE*              phServiceHandle = NULL;
    DWORD                   i;
    DWORD                   dwServiceConfigSize;
    SERVICE_STATUS          ServiceStatus;
    DWORD                   dwSleepInterval = SLEEP_INTERVAL;

    if ( dwNumServices != 0 && 
         ( pessRoot == NULL ||
           pdwTimeoutMsecs == NULL ) )
    {
        return E_INVALIDARG;
    }

    if ( (phServiceHandle = (SC_HANDLE*)LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT,
                                                    dwNumServices * sizeof(SC_HANDLE) )) == NULL ) 
    {
        hresReturn = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    if ( SUCCEEDED(hresReturn) )
    {
        //
        // All services will be started/stopped at once
        // then periodically checked for status until all of them are running/stopped
        // or some error occured or timeout
        //

        if ( dwNumServices != 0 ) 
        {
            pServiceConfig = (LPQUERY_SERVICE_CONFIG)abServiceConfig;
            dwServiceConfigSize = sizeof( abServiceConfig );

            //
            // Open handles and send service control start command
            //

            for ( i = 0 ;
                  i < dwNumServices && SUCCEEDED(hresReturn) ; 
                  i++) 
            {
                //
                // Send command to Services
                //

                phServiceHandle[i] = OpenService( schSCM,
                                                  pessRoot[i].lpServiceName,
                                                  SERVICE_ALL_ACCESS );

                if ( phServiceHandle[i] != NULL )
                {
                    if ( fStart )
                    {
                        //
                        // Query service config to check if service should be started
                        // based on its Start Type.
                        //

                        if ( !QueryServiceConfig( phServiceHandle[i], 
                                                  (LPQUERY_SERVICE_CONFIG)abServiceConfig, 
                                                  dwServiceConfigSize, 
                                                  &dwBytesNeeded ) )
                        {
                            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) 
                            {
                                // If we are re-allocating and we all ready allocated once
                                // before first free up the memory.

                                if ( pServiceConfig != (LPQUERY_SERVICE_CONFIG) abServiceConfig )
                                {
                                    LocalFree( pServiceConfig );
                                }

                                if ( (pServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc( 
                                            LMEM_FIXED, 
                                            dwBytesNeeded )) == NULL ) 
                                {
                                    hresReturn = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                                }
                                else 
                                {
                                    dwServiceConfigSize = dwBytesNeeded;

                                    if ( !QueryServiceConfig( phServiceHandle[i], 
                                                              (LPQUERY_SERVICE_CONFIG)pServiceConfig, 
                                                              dwServiceConfigSize, 
                                                              &dwBytesNeeded ) )
                                    {
                                        hresReturn = HRESULT_FROM_WIN32( GetLastError() );
                                    }
                                }
                            }
                            else
                            {
                                hresReturn = HRESULT_FROM_WIN32( GetLastError() );
                            }
                        }

                        if ( SUCCEEDED(hresReturn) )
                        {
                            //
                            // Check if service auto start except if fForceDemandStart
                            // specified.  ForceDemandStart will only be specified for 
                            // the service that the command is directly issued on.  This 
                            // means that it will only be specified for IISADMIN.
                            //

                            if ( ( fForceDemandStart && pServiceConfig->dwStartType == SERVICE_DEMAND_START )
                                 || ( pServiceConfig->dwStartType == SERVICE_BOOT_START ||
                                      pServiceConfig->dwStartType == SERVICE_SYSTEM_START ||
                                      pServiceConfig->dwStartType == SERVICE_AUTO_START ) )
                            {
                                StartService( phServiceHandle[i], 0, NULL );

                                //
                                // Ask for only the services that are inactive.  So, for instance, 
                                // if we are attempting to restart the iisadmin service,
                                // and W3SVC is still active, we won't send it a command to restart.
                                //
                                hresReturn = EnumStartServices( schSCM,
                                                                pessRoot[i].lpServiceName,
                                                                SERVICE_INACTIVE,
                                                                abServiceList, 
                                                                sizeof(abServiceList), 
                                                                &pbServiceList, 
                                                                &dwNumRecServices,
                                                                FALSE );

                                if ( SUCCEEDED( hresReturn ) )
                                {
                                    hresReturn = StartStopAllRecursive( schSCM,
                                                                        (ENUM_SERVICE_STATUS*)pbServiceList,
                                                                        dwNumRecServices,
                                                                        fStart,
                                                                        FALSE,
                                                                        pdwTimeoutMsecs );

                                    if ( pbServiceList != NULL 
                                         && pbServiceList != abServiceList )
                                    {
                                        LocalFree( pbServiceList );
                                    }
                                }
                            }
                            else
                            {
                                //
                                // Don't want to start this service, so mark it
                                // as already running
                                //

                                if (wcscmp(pessRoot[i].lpServiceName,_T("IISADMIN")) == 0)
                                {
                                    hresReturn = HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE);
                                }
                                else
                                {
                                    pessRoot[i].ServiceStatus.dwCurrentState = SERVICE_RUNNING;
                                }
                            }
                        }
                    }
                    else  // handle stopping the service
                    {
                        if ( W3SVCandHTTPFilter(i, pessRoot, dwNumServices) )
                        {
                            continue;
                        }

                        // Remember if the service was stopped to start with.
                        BOOL fServiceWasStoppedToStartWith = ( pessRoot[i].ServiceStatus.dwCurrentState == SERVICE_STOPPED );
                        
                        // We will also need to stop dependent services if the are started all ready.
                        BOOL fHasDependentServices = FALSE;

                        if ( !fServiceWasStoppedToStartWith )
                        {
                            //
                            // if the service was not stopped to start with 
                            // we need to tell the service to stop.
                            //

                            hresReturn = SendControlToService( phServiceHandle[i],
                                                               SERVICE_CONTROL_STOP,
                                                               pdwTimeoutMsecs );

                            if ( hresReturn == HRESULT_FROM_WIN32( ERROR_SERVICE_REQUEST_TIMEOUT ) )
                            {
                                //
                                // WARNING!
                                //
                                // We're in trouble. Service did not respond in a timely fashion,
                                // and further attempt to use this handle ( including closing it )
                                // will also hang, so cancel the handle and leak it
                                //

                                phServiceHandle[i] = NULL;
                            }
                            else if ( hresReturn == HRESULT_FROM_WIN32( ERROR_DEPENDENT_SERVICES_RUNNING ) )
                            {
                                fHasDependentServices = TRUE;
                            }
                        }

                        //
                        // If it was stopped to start with, or if it was not but it couldn't
                        // be stopped because it has dependent services.  Go ahead and stop
                        // the dependent services.
                        //
                        if ( fHasDependentServices || fServiceWasStoppedToStartWith )
                        {

                            //
                            // Get the services that are active because we 
                            // are only interested in stopping services that
                            // are actually running.
                            //
                            hresReturn = EnumStartServices( schSCM,
                                                            pessRoot[i].lpServiceName,
                                                            SERVICE_ACTIVE,
                                                            abServiceList, 
                                                            sizeof(abServiceList), 
                                                            &pbServiceList, 
                                                            &dwNumRecServices,
                                                            FALSE );

                            if ( SUCCEEDED( hresReturn ) )
                            {
                                hresReturn = StartStopAllRecursive( schSCM,
                                                                    (ENUM_SERVICE_STATUS*)pbServiceList,
                                                                    dwNumRecServices,
                                                                    fStart,
                                                                    FALSE,
                                                                    pdwTimeoutMsecs );

                                if ( pbServiceList != NULL 
                                     && pbServiceList != abServiceList )
                                {
                                    LocalFree( pbServiceList );
                                }
                            }

                            if ( SUCCEEDED( hresReturn ) )
                            {
                                //
                                // If the service itself is not all ready stopped, then stop
                                // the service.  It could be that it is stopped ( due to a crash )
                                // and the other services that were dependent on them are still
                                // running.
                                //
                                if ( !fServiceWasStoppedToStartWith )
                                {

                                    hresReturn = SendControlToService( phServiceHandle[i],
                                                                       SERVICE_CONTROL_STOP,
                                                                       pdwTimeoutMsecs );

                                    // if we can hang above we could hang here...
                                    if ( hresReturn == HRESULT_FROM_WIN32( ERROR_SERVICE_REQUEST_TIMEOUT ) )
                                    {
                                        //
                                        // WARNING!
                                        //
                                        // We're in trouble. Service did not respond in a timely fashion,
                                        // and further attempt to use this handle ( including closing it )
                                        // will also hang, so cancel the handle and leak it
                                        //

                                        phServiceHandle[i] = NULL;
                                    }

                                }
                            }
                        }

                        if ( FAILED( hresReturn ) )
                        {
                            break;
                        }
                    }  // end of stopping code
                }  // end of valid service handle
            }  // end of loop

            //
            // Check service running
            //

            if ( (*pdwTimeoutMsecs < dwSleepInterval) && *pdwTimeoutMsecs )
            {
                dwSleepInterval = *pdwTimeoutMsecs;
            }

            for ( ;
                  SUCCEEDED( hresReturn );
                )
            {
                for ( i = 0 ;
                      i < dwNumServices; 
                      i++) 
                {
                    //
                    // Only query status for services known to be not running
                    //

                    if ( pessRoot[i].ServiceStatus.dwCurrentState 
                                != (DWORD)(fStart ? SERVICE_RUNNING : SERVICE_STOPPED) )
                    {
                        if ( QueryServiceStatus( phServiceHandle[i], &ServiceStatus ) )
                        {
                            //
                            // remember status
                            //

                            pessRoot[i].ServiceStatus.dwCurrentState = ServiceStatus.dwCurrentState;

                            if ( fStart && ServiceStatus.dwCurrentState == SERVICE_STOPPED )
                            {
                                //
                                // Service died during startup. no point keeping polling
                                // for service state : return an error
                                //

                                hresReturn = HRESULT_FROM_WIN32( ERROR_SERVICE_NOT_ACTIVE );
                                break;
                            }

                            if ( ServiceStatus.dwCurrentState != (DWORD)(fStart ? SERVICE_RUNNING : SERVICE_STOPPED) )
                            {
                                //
                                // will keep looping waiting for target service state
                                //

                                break;
                            }
                        }
                        else
                        {
                            hresReturn = HRESULT_FROM_WIN32( GetLastError() );
                            break;
                        }
                    }
                }

                //
                // if we did not checked all services then at least one of them
                // is not running ( or some error occured )
                //

                if ( SUCCEEDED( hresReturn ) && i != dwNumServices )
                {
                    if ( dwSleepInterval > *pdwTimeoutMsecs )
                    {
                        hresReturn = HRESULT_FROM_WIN32( ERROR_SERVICE_REQUEST_TIMEOUT );
                    }
                    else
                    {
                        Sleep( dwSleepInterval );

                        *pdwTimeoutMsecs -= dwSleepInterval;
                    }
                }
                else
                {
                    break;
                }
            }

            //
            // close service handles
            //

            for ( i = 0 ;
                  i < dwNumServices; 
                  i++) 
            {
                if ( phServiceHandle[i] != NULL )
                {
                    CloseServiceHandle( phServiceHandle[i] );
                }
            }
        }

        LocalFree( phServiceHandle );
    }

    if ( pServiceConfig != NULL 
         && pServiceConfig != (LPQUERY_SERVICE_CONFIG)abServiceConfig )
    {
        LocalFree( pServiceConfig );
    }

    return hresReturn;
}

extern "C"
DWORD WINAPI
ControlServiceThread(
    LPVOID  p
    )
/*++

    ControlServiceThread

        Send a command to a service

    Arguments:
        
        p - ptr to SERVICE_COMMAND_CONTROL_BLOCK

    Returns:
        0

--*/
{
    SERVICE_STATUS                  ssStatus;
    SERVICE_COMMAND_CONTROL_BLOCK*  pCB = (SERVICE_COMMAND_CONTROL_BLOCK*)p;

    if ( pCB == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( !ControlService( pCB->hServiceHandle, pCB->dwCmd, &ssStatus ) )
    {
        DWORD err = GetLastError();

        // do not report error if try to stop a stopped service
        if (err == ERROR_SERVICE_NOT_ACTIVE && pCB->dwCmd == SERVICE_CONTROL_STOP)
        {
            pCB->hres = S_OK;
        }
        else
        {
            pCB->hres = HRESULT_FROM_WIN32( err );
        }
    }
    else
    {
        pCB->hres = S_OK;
    }

    //nasty side affect of this function, if the count hit's
    //zero we delete it here.  Leaving P to point off, however
    //p does hold a ref count for itself so this should actually work fine.
    if ( InterlockedDecrement( &pCB->lRefCount ) == 0 )
    {
        delete pCB;
    }

    return ERROR_SUCCESS;
}


HRESULT
SendControlToService( 
    SC_HANDLE   hServiceHandle,
    DWORD       dwCmd,
    LPDWORD     pdwTimeoutMsecs
    )
/*++

    ControlServiceThread

        Send a command to a service with timeout

    Arguments:
        
        hServiceHandle - service to control
        dwCmd - command to send to service
        pdwTimeoutMsecs - timeout ( in ms ). updated on output based on time
                spent waiting for service status

    Returns:
        ERROR_SERVICE_REQUEST_TIMEOUT if timeout
        otherwise COM status

--*/
{
    HANDLE                          hT;
    DWORD                           dwID;
    DWORD                           dwBefore;
    DWORD                           dwAfter;
    SERVICE_COMMAND_CONTROL_BLOCK*  pCB;
    DWORD                           dwTimeoutMsecs;
    HRESULT                         hres;

    if ( pdwTimeoutMsecs == NULL )
    {
        return E_INVALIDARG;
    }
    
    dwTimeoutMsecs = *pdwTimeoutMsecs;

    //
    // Default timeout for ControlService is 120s, which is too long for us
    // so we create a thread to call ControlService and wait for thread
    // termination.
    // Communication between threads is handled by a refcounted control block 
    //
    pCB = new SERVICE_COMMAND_CONTROL_BLOCK;
    if ( pCB != NULL  )
    {
        pCB->lRefCount = 2;     // 1 for caller, 1 for callee
        pCB->dwCmd = dwCmd;
        pCB->hServiceHandle = hServiceHandle;
        pCB->hres = S_OK;

        dwBefore = GetTickCount();

        hT = CreateThread( NULL, 
                                0, 
                                (LPTHREAD_START_ROUTINE)ControlServiceThread, 
                                (LPVOID)pCB, 
                                0, 
                                &dwID );
        if ( hT != NULL )
        {
            if ( WaitForSingleObject( hT, dwTimeoutMsecs ) == WAIT_OBJECT_0 )
            {
                hres = pCB->hres;
            }
            else
            {
                hres = HRESULT_FROM_WIN32( ERROR_SERVICE_REQUEST_TIMEOUT );
            }

            CloseHandle( hT );

            if ( InterlockedDecrement( &pCB->lRefCount ) == 0 )
            {
                delete pCB;
            }

            //
            // Update caller's timeout
            //

            dwAfter = GetTickCount();

            if ( dwAfter > dwBefore )
            {
                if ( dwAfter - dwBefore <= dwTimeoutMsecs )
                {
                    *pdwTimeoutMsecs -= dwAfter - dwBefore;
                }
                else
                {
                    *pdwTimeoutMsecs = 0;
                }
            }
        }
        else
        {
            delete pCB;

            hres = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {
        hres = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    return hres;
}


HRESULT
SerializeEnumServiceBuffer( 
    LPENUM_SERVICE_STATUS   pessDependentServices,
    DWORD                   dwNumServices,
    LPBYTE                  pbBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwMDRequiredBufferSize 
    )
/*++

    SerializeEnumServiceBuffer

        Serialize array of ENUM_SERVICE_STATUS to buffer,
        replacing ptr by offset in buffer

    Arguments:
        
        pessDependentServices - array of ENUM_SERVICE_STATUS to serialize
        dwNumServices - # of entries in pessDependentServices
        pbBuffer - buffer filled with serialized status as array of SERIALIZED_ENUM_SERVICE_STATUS
        dwBufferSize - maximum size of pbBuffer
        pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small

    Returns:
        ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small
        otherwise COM status

--*/
{
    HRESULT     hresReturn = S_OK;
    DWORD       dwMinSize = 0;
    UINT        i;

    if ( dwNumServices != 0 &&
         pessDependentServices == NULL )
    {
        return E_INVALIDARG;
    }

    if ( !pbBuffer )
    {
        dwBufferSize = 0;
    }

    //
    // size of output buffer is based on size of array of SERIALIZED_ENUM_SERVICE_STATUS
    // plus size of all strings : service name & display name for each entry
    //

    dwMinSize = sizeof(SERIALIZED_ENUM_SERVICE_STATUS) * dwNumServices;

    for ( i = 0 ;
          i < dwNumServices ; 
          ++i )
    {
        UINT    cServiceName = (DWORD) _tcslen( pessDependentServices[i].lpServiceName ) + 1;
        UINT    cDisplayName = (DWORD) _tcslen( pessDependentServices[i].lpDisplayName ) + 1;

        //
        // do not update if output buffer is too small, but keep looping to determine
        // total size
        //

        if ( dwBufferSize >= dwMinSize + (cServiceName + cDisplayName) * sizeof(TCHAR)  )
        {
            //
            // copy service status as is
            //

            ((SERIALIZED_ENUM_SERVICE_STATUS*)pbBuffer)[i].ServiceStatus =
                    pessDependentServices[i].ServiceStatus;

            //
            // copy string and convert ptr to string to index in output buffer
            //

            memcpy( pbBuffer + dwMinSize, pessDependentServices[i].lpServiceName, cServiceName * sizeof(TCHAR) ); 
            ((SERIALIZED_ENUM_SERVICE_STATUS*)pbBuffer)[i].iServiceName = dwMinSize ;

            memcpy( pbBuffer + dwMinSize + cServiceName * sizeof(TCHAR), pessDependentServices[i].lpDisplayName, cDisplayName * sizeof(TCHAR)  );
            ((SERIALIZED_ENUM_SERVICE_STATUS*)pbBuffer)[i].iDisplayName = dwMinSize + cServiceName * sizeof(TCHAR) ;
        }

        dwMinSize += (cServiceName + cDisplayName) * sizeof(TCHAR) ;
    }

    if ( dwBufferSize < dwMinSize )
    {
        if ( pdwMDRequiredBufferSize )
        {
            *pdwMDRequiredBufferSize = dwMinSize;
        }

        hresReturn = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }

    return hresReturn;
}



STDMETHODIMP 
CIisRestart::Status(
    DWORD           dwBufferSize, 
    unsigned char * pbBuffer, 
    DWORD *         pdwMDRequiredBufferSize, 
    DWORD *         pdwNumServices
    )
/*++

    Status

        Return status of all internet services as array of ENUM_SERVICE_STATUS

    Arguments:
        
        dwBufferSize - maximum size of pbBuffer
        pbBuffer - buffer filled with serialized status as array of SERIALIZED_ENUM_SERVICE_STATUS
        pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small
        pdwNumServices - updated with number of entries stored in pbBuffer

    Returns:
        ERROR_RESOURCE_DISABLED if access to restart commands disabled
        ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small
        otherwise COM status

--*/
{
    SC_HANDLE               schSCM = NULL;
    HRESULT                 hresReturn = E_FAIL;
    BYTE                    abServiceList[2048];
    LPBYTE                  pbServiceList = NULL;
    LPENUM_SERVICE_STATUS   pessDependentServices;

    if ( pdwNumServices == NULL )
    {
        return E_INVALIDARG;
    }

    if ( !IsEnableRemote() )
    {
        hresReturn = HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED );
    }
    else
    {
        schSCM = OpenSCManager(NULL,
                               NULL,
                               SC_MANAGER_CONNECT);
        if ( schSCM == NULL )
        {
            hresReturn = HRESULT_FROM_WIN32( GetLastError() );
        }
        else 
        {
            hresReturn = EnumStartServices( schSCM,
                                            _T("IISADMIN"),
                                            SERVICE_STATE_ALL,
                                            abServiceList, 
                                            sizeof(abServiceList), 
                                            &pbServiceList, 
                                            pdwNumServices,
                                            FALSE );

            if ( SUCCEEDED(hresReturn) )
            {
                pessDependentServices = (LPENUM_SERVICE_STATUS)pbServiceList;

                hresReturn = SerializeEnumServiceBuffer( (LPENUM_SERVICE_STATUS)pbServiceList,
                                                         *pdwNumServices,
                                                         pbBuffer,
                                                         dwBufferSize,
                                                         pdwMDRequiredBufferSize );

                if ( pbServiceList != NULL 
                     && pbServiceList != abServiceList )
                {
                    LocalFree( pbServiceList );
                }
            }

            CloseServiceHandle(schSCM);
        }
    }

    return hresReturn;
}


HRESULT
EnumStartServices(
    SC_HANDLE   schSCM,
    LPTSTR      pszRoot,
    DWORD       dwTargetState,
    LPBYTE      abServiceList,
    DWORD       dwInitializeServiceListSize,
    LPBYTE*     ppbServiceList,
    LPDWORD     pdwNumServices,
    BOOL        fAddIisadmin
    )
/*++

    EnumStartServices

        Enumerate dependent services to output buffer as array of ENUM_SERVICE_STATUS

    Arguments:
        
        schSCM - handle to SCM
        pszRoot - service for which to enumerate dependencies
        dwTargetState - dwServiceState for call to EnumDependentServices()
        abServiceList - initial output buffer
        dwInitializeServiceListSize - maximum size of abServiceList
        ppbServiceList - updated with output buffer, may be abServiceList if long enough
                otherwise returned buffer is to be freed using LocalFree()
        pdwNumServices - updated with number of entries stored in pbBuffer
        fAddIisadmin - TRUE to add IISADMIN to list of dependent services

    Returns:
        COM status

--*/
{
    HRESULT     hresReturn = S_OK;
    SC_HANDLE   schIISADMIN = NULL;
    DWORD       dwBytesNeeded;
    DWORD       dwAddSize = 0;
    DWORD       dwOffsetSize = 0;


    if ( ppbServiceList == NULL ||
         pdwNumServices == NULL )
    {
        return E_INVALIDARG;
    }

    *ppbServiceList = NULL;

    schIISADMIN = OpenService(schSCM,
                              pszRoot,
                              STANDARD_RIGHTS_REQUIRED | 
                              SERVICE_ENUMERATE_DEPENDENTS);
    if (schIISADMIN == NULL) 
    {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
    }
    else 
    {
        if ( fAddIisadmin )
        {
            //
            // if initial size too small for Iisadmin description then fail
            //

            dwOffsetSize = sizeof(ENUM_SERVICE_STATUS );
            dwAddSize = dwOffsetSize;
            if ( dwAddSize > dwInitializeServiceListSize )
            {
                hresReturn = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                goto Cleanup;
            }

            //
            // Use global static name for IISADMIN, no need to copy it to output buffer
            //

            ((LPENUM_SERVICE_STATUS)abServiceList)->lpDisplayName = _T("IISADMIN");
            ((LPENUM_SERVICE_STATUS)abServiceList)->lpServiceName = _T("IISADMIN");

            //
            // don't want to check service status at this point as it may be stuck
            // so assume RUNNING. 
            //

            ((LPENUM_SERVICE_STATUS)abServiceList)->ServiceStatus.dwCurrentState = SERVICE_RUNNING;
        }

        if (!EnumDependentServices( schIISADMIN,
                                    dwTargetState,
                                    (LPENUM_SERVICE_STATUS)(abServiceList + dwOffsetSize),
                                    dwInitializeServiceListSize - dwAddSize,
                                    &dwBytesNeeded,
                                    pdwNumServices)) 
        {
            if (GetLastError() == ERROR_MORE_DATA)
            {
                if ( (*ppbServiceList = (LPBYTE)LocalAlloc( LMEM_FIXED, 
                                                            dwBytesNeeded + dwAddSize )) == NULL ) 
                {
                    hresReturn = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                }
                else 
                {
                    // dwOffsetSize is set to what dwAddSize was set to, so it is fine
                    // to memcpy this data, since we allocated more than dwAddSize above.
                    memcpy( *ppbServiceList, abServiceList, dwOffsetSize );

                    if (!EnumDependentServices( schIISADMIN,
                                                SERVICE_INACTIVE,
                                                (LPENUM_SERVICE_STATUS)(*ppbServiceList + dwOffsetSize),
                                                dwBytesNeeded,
                                                &dwBytesNeeded,
                                                pdwNumServices)) 
                    {
                        hresReturn = HRESULT_FROM_WIN32( GetLastError() );
                        LocalFree( *ppbServiceList );
                        *ppbServiceList = NULL;
                    }
                }
            }
            else 
            {
                hresReturn = HRESULT_FROM_WIN32( GetLastError() );
            }
        }
        else
        {
            *ppbServiceList = abServiceList;
        }
    }

Cleanup:

    if ( schIISADMIN ) 
    {
        CloseServiceHandle( schIISADMIN );
    }

    if ( fAddIisadmin && SUCCEEDED( hresReturn ) )
    {
        ++*pdwNumServices;
    }

    return hresReturn;
}


BOOL
IsEnableRemote(
    )
/*++

    IsEnableRemote

        Check if restart I/F enabled
        ( based on HKLM\SOFTWARE\Microsoft\INetStp::EnableRestart::REG_DWORD )

    Arguments:
        
        None

    Returns:
        TRUE if enabled, otherwise FALSE

--*/
{
    BOOL    fSt = FALSE;
    HKEY    hKey;
    DWORD   dwValue;
    DWORD   dwType;
    DWORD   dwSize;


    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                       TEXT("SOFTWARE\\Microsoft\\INetStp"), 
                       0, 
                       KEY_READ, 
                       &hKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey, 
                              TEXT("EnableRestart"),
                              0, 
                              &dwType, 
                              (LPBYTE)&dwValue, 
                              &dwSize ) == ERROR_SUCCESS )
        {
            if ( dwType == REG_DWORD )
            {
                fSt = dwValue == 1;
            }
            else
            {
                fSt = TRUE;
            }
        }
        else
        {
            fSt = TRUE;
        }

        RegCloseKey( hKey );
    }

    return fSt;
}


BOOL
CloseSystemExceptionHandler(
    LPCTSTR     pszWindowName
    )
/*++

    CloseSystemExceptionHandler

        Send a close ( e.g. terminate apps without debugging ) command to the window
        created by NT when a debugger is not configured to automatically start after app exception.
        This window stays on screen until interactive user select either OK or debug app, which is
        a problem for automated restart.
        So we locate this window and send it a command requesting stop w/o debugging.
        We locate the window by enumerating all windows and checking for window name beginning with the name
        of the application that raised an exception, e.g. "inetinfo.exe"

    Arguments:
        
        pszWindowName - window name where to send terminate command

    Returns:
        TRUE if SUCCESS, otherwise FALSE

--*/
{
    BOOL        fSt = TRUE;
    DWORD       dwPid = 0;
    HWND        hwnd;

    GetPidFromTitle( &dwPid, &hwnd, pszWindowName );

    if ( dwPid )
    {

        //
        // WARNING: major hack: turns out that WM_COMMAND 1 is the command to send to
        // the exception handler to ask it to close application w/o debugging
        // This works for NT5, may change in the future...
        //

        PostMessage( hwnd, WM_COMMAND, 1, 0 );

        Sleep( 1000 );

    }
    else
    {
        fSt = TRUE;
    }

    return fSt;
}


HRESULT
KillTaskByName(
    LPTSTR  pname,
    LPSTR   pszMandatoryModule
    )
/*++

    KillTaskByName

        Kill a process by name
        Most of the code was taken from the Platform SDK kill,c sample, and
        utilizes the common.c module included in this project.
        Works only on NT platforms ( NOT Win 9x )

    Arguments:
        
        pname - name of process to kill ( name of executable w/o extension )
        pszMandatoryModule - module name to look for, e.g. "wam.dll"
            can be NULL for unconditional kill

    Returns:
        COM status

--*/
{
    HRESULT           hres = S_OK;

    //
    // Obtain the ability to manipulate other processes
    //

    EnableDebugPrivNT();

    //
    // get the task list for the system
    //

    hres = KillTask( pname, pszMandatoryModule );

    return hres;
}


VOID
ReportStatus(
    DWORD   dwId,
    DWORD   dwStatus
    )
/*++

    ReportStatus

        Log status event

    Arguments:
        
        dwId - ID of event to log ( source is "IISCTLS" , SYSTEM log )
        dwStatus - status of operation ( HRESULT )

    Returns:
        Nothing

--*/
{
    HANDLE  hLog;
    LPTSTR  aParams[1];

    if ( (hLog = RegisterEventSource( NULL, _T("IISCTLS") )) != NULL )
    {
        if ( SUCCEEDED( WhoAmI( aParams + 0 ) ) )
        {
            ReportEvent( hLog, 
                         EVENTLOG_INFORMATION_TYPE, 
                         0, 
                         dwId, 
                         NULL, 
                         1, 
                         sizeof(DWORD), 
                         (LPCTSTR*)aParams, 
                         &dwStatus );
            LocalFree( aParams[0] );
        }

        DeregisterEventSource( hLog );
    }
}


HRESULT
WhoAmI(
    LPTSTR* ppPrincipal
    )
/*++

    WhoAmI

        Return currently impersonated user
        As this is a COM server running under the identity of the invoker
        this means we access the process token. So we might end up getting
        the wrong user name if the object is invoked in close succession 
        ( within the 5s server exit timeout ) by different users.

    Arguments:
        
        ppPrincipal - update with ptr to string containing user name ( domain\acct )
                      must be freed using LocalFree()

    Returns:
        Error status

--*/
{
    TCHAR*          pPrincipal;
    TCHAR           achUserName[512];
    TCHAR           achDomain[512];
    DWORD           dwLen;
    DWORD           dwDomainLen;
    SID_NAME_USE    SIDtype = SidTypeUser;
    HRESULT         hres = E_FAIL;



    //
    // So we have to access the process token and retrieve account & user name
    // by using LookupAccountSid()
    //

    HANDLE          hAccTok = NULL;

    if ( OpenProcessToken( GetCurrentProcess(),
                           TOKEN_EXECUTE|TOKEN_QUERY,
                           &hAccTok ) )
    {
        BYTE    abSidAndInfo[512];
        DWORD   dwReq;

        //
        // provide a reasonably sized buffer. If this fails we don't
        // retry with a bigger one.
        //

        if ( GetTokenInformation( hAccTok, 
                                  TokenUser, 
                                  (LPVOID)abSidAndInfo, 
                                  sizeof(abSidAndInfo), 
                                  &dwReq) )
        {
            dwLen = sizeof( achUserName ) / sizeof(TCHAR);
            dwDomainLen = sizeof(achDomain) / sizeof(TCHAR);

            //
            // provide a reasonably sized buffer. If this fails we don't
            // retry with a bigger one.
            //

            if ( LookupAccountSid( NULL, 
                                   ((SID_AND_ATTRIBUTES*)abSidAndInfo)->Sid, 
                                   achUserName, 
                                   &dwLen,
                                   achDomain, 
                                   &dwDomainLen, 
                                   &SIDtype) )
            {
                //
                // We return a LocalAlloc'ed buffer
                //

                dwLen = (DWORD) _tcslen( achUserName );
                dwDomainLen = (DWORD) _tcslen( achDomain );

                pPrincipal = (LPTSTR)LocalAlloc( LMEM_FIXED, 
                                                      (dwLen + 1 + dwDomainLen + 1 ) * sizeof(TCHAR) );
                if ( pPrincipal != NULL )
                {
                    memcpy( pPrincipal, 
                            achDomain, 
                            sizeof(TCHAR)*dwDomainLen );
                    pPrincipal[dwDomainLen] = '\\';
                    memcpy( pPrincipal + dwDomainLen + 1, 
                            achUserName, 
                            sizeof(TCHAR)*(dwLen+1) );
                    *ppPrincipal = pPrincipal;

                    hres = S_OK;
                }
                else
                {
                    hres = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
            else
            {
                hres = HRESULT_FROM_WIN32( GetLastError() );
            }
        }
        else
        {
            hres = HRESULT_FROM_WIN32( GetLastError() );
        }

        CloseHandle( hAccTok );
    }
    else
    {
        hres = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hres;
}

BOOL
W3SVCandHTTPFilter(
    DWORD currentIndex, 
    ENUM_SERVICE_STATUS* pessRoot,
    DWORD dwNumServices
    )
{
/*++

    W3SVCandHTTPFilter

        Return currently impersonated user
        As this is a COM server running under the identity of the invoker
        this means we access the process token. So we might end up getting
        the wrong user name if the object is invoked in close succession 
        ( within the 5s server exit timeout ) by different users.

    Arguments:
        
        DWORD currentIndex - index of the service we are deciding if we should process.
        ENUM_SERVICE_STATUS* pessRoot - the set of services we are working on.
        DWORD dwNumServices - the number of services in the set.

    Returns:
        TRUE if we found the w3svc and HTTPFilter on the same line and we are looking at the w3svc


--*/

    BOOL bResult = FALSE;

    // check if we are looking at the w3svc.  If we are find out if the
    // HTTPFilter is on the same level.  Note the HTTPFilter will always be listed
    // after the w3svc.
    if ( _wcsicmp( pessRoot[currentIndex].lpServiceName, L"w3svc" ) == 0 )
    {
        for ( DWORD i = currentIndex + 1;
              ( i < dwNumServices ) && ( bResult == FALSE );
              i++ )
        {
            if ( _wcsicmp( pessRoot[i].lpServiceName, L"HTTPFilter" ) == 0 )
            {
                bResult = TRUE;
            }
        }
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\cmdline\iisrsta.cxx ===
/*
    IisRsta.cxx

    Command line utility for access to IIisServiceControl

    FILE HISTORY:
        Phillich    06-Oct-1998     Created

*/

#define INITGUID

#include    <windows.h>
#include    <winnlsp.h>
#include    <tchar.h>
#include    <stdio.h>
#include    <ole2.h>
#include    <locale.h>
#include    "iisrsta.h"
#include    "iisrstam.h"

// Including so we can use the WIN32_FROM_HRESULT macro that is defined there
#include    "iisdef.h"

typedef BOOL (*PFNCHANGESERVICECONFIG2)(SC_HANDLE,DWORD,LPVOID);

#define MAX_STRINGIZED_ULONG_CHAR_COUNT 11      // "4294967295", including the terminating null


//
// Helper functions
//


VOID
DisplayErrorMessage(
    DWORD   dwErr
    )
/*++

    DisplayErrorMessage

        Display error message associated with error code

    Arguments:

        dwErr  - Win32 error code

    Returns:

        Nothing

--*/
{
    LPTSTR  pErr;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR)&pErr,
            0,
            NULL ) )
    {
        LPTSTR   p;

        p = _tcschr( pErr, TEXT('\r') );
        if ( p != NULL )
        {
            *p = TEXT('\0');
        }
        _fputts( pErr, stdout );

        LocalFree( pErr );
    }
}


VOID
PrintMessage(
    DWORD   dwId,
    DWORD   dwParams,
    LPVOID* pParams
    )
/*++

    PrintMessage

        Print message ( from message file ) with optional parameters

    Arguments:

        dwId - message ID
        dwParams - # of params in pParams
        pParams - ptr to array of parameters

    Returns:

        Nothing

--*/
{
    LPTSTR  pBuf;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        (LPCVOID)NULL,  //GetModuleHandle(NULL),
                        dwId,
                        0,
                        (LPTSTR)&pBuf,
                        dwParams,
                        (va_list *)pParams ) )
    {
        _fputts( pBuf, stdout );

        LocalFree( pBuf );
    }
}


VOID
CmdError( 
    DWORD   dwId,
    HRESULT hRes 
    )
/*++

    CmdError

        Display message followed by error description ( error message + numerical code )

    Arguments:

        dwId - message ID
        hRes - error code

    Returns:

        Nothing

--*/
{
    TCHAR   achBuf[128];

    PrintMessage( dwId, 0, NULL );

    if ( hRes == HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED ) )
    {
        PrintMessage( IRSTASTR_REMOTE_DISABLED, 0, NULL );
    }
    else if ( hRes == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
    {
        PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
    }
    else if ( hRes == HRESULT_FROM_WIN32( ERROR_SERVICE_NOT_ACTIVE ) )
    {
        PrintMessage( IRSTASTR_SERVICE_NOT_ACTIVE, 0, NULL );
    }
    else
    {
        DisplayErrorMessage( WIN32_FROM_HRESULT( hRes ) );
        wsprintf( achBuf, _T(" (%u, %x)\n"), (DWORD)hRes, (DWORD)hRes );
        _fputts( achBuf, stdout );
    }
}


LPTSTR
GetString(
    DWORD   dwId
    )
/*++

    GetString

        Retrieve message content

    Arguments:

        dwId - message ID

    Returns:

        Ptr to message. Must be freed using LocalFree()

--*/
{
    LPTSTR  pBuf;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
                        (LPCVOID)NULL,
                        dwId,
                        0,
                        (LPTSTR)&pBuf,
                        0,
                        NULL ) )
    {
        LPTSTR   p;

        p = _tcschr( pBuf, TEXT('\r') );
        if ( p != NULL )
        {
            *p = TEXT('\0');
        }
        return pBuf;
    }

    return NULL;
}



HRESULT
DeserializeEnumServiceBuffer( 
    LPBYTE                          pbInBuffer,
    DWORD                           dwNumServices,
    LPBYTE                          pbBuffer,
    DWORD                           dwBufferSize,
    LPDWORD                         pdwMDRequiredBufferSize 
    )
/*++

    DeserializeEnumServiceBuffer

        Deserialize array of SERIALIZED_ENUM_SERVICE_STATUS to buffer,
        replacing offset in buffer by ptr

    Arguments:
        
        pbInBuffer - buffer containing serialized status as array of SERIALIZED_ENUM_SERVICE_STATUS
        dwNumServices - # of entries in pbInBuffer
        pbBuffer - buffer filled with deserialized status as array of ENUM_SERVICE_STATUS
        dwBufferSize - maximum size of pbBuffer
        pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small

    Returns:
        ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small
        otherwise COM status

--*/
{
    HRESULT                         hresReturn = S_OK;
    DWORD                           dwMinSize = 0;
    UINT                            i;
    SERIALIZED_ENUM_SERVICE_STATUS* pessDependentServices = (SERIALIZED_ENUM_SERVICE_STATUS*)pbInBuffer;

    if ( !pbBuffer )
    {
        dwBufferSize = 0;
    }

    dwMinSize = sizeof(ENUM_SERVICE_STATUS) * dwNumServices;

    for ( i = 0 ;
          i < dwNumServices ; 
          ++i )
    {
        UINT    cServiceName = (UINT) _tcslen( (TCHAR*)(pbInBuffer + pessDependentServices[i].iServiceName) ) + 1;
        UINT    cDisplayName = (UINT) _tcslen( (TCHAR*)(pbInBuffer + pessDependentServices[i].iDisplayName) ) + 1;

        if ( dwBufferSize >= dwMinSize + ( cServiceName + cDisplayName ) * sizeof(TCHAR) )
        {
            ((LPENUM_SERVICE_STATUS)pbBuffer)[i].ServiceStatus =
                    pessDependentServices[i].ServiceStatus;

            memcpy( pbBuffer + dwMinSize, pbInBuffer + pessDependentServices[i].iServiceName, cServiceName * sizeof(TCHAR) ); 
            ((LPENUM_SERVICE_STATUS)pbBuffer)[i].lpServiceName = (TCHAR*)(pbBuffer + dwMinSize);

            memcpy( pbBuffer + dwMinSize + cServiceName * sizeof(TCHAR), pbInBuffer + pessDependentServices[i].iDisplayName, cDisplayName * sizeof(TCHAR) );
            ((LPENUM_SERVICE_STATUS)pbBuffer)[i].lpDisplayName = (TCHAR*)(pbBuffer + dwMinSize) + cServiceName;
        }

        dwMinSize += ( cServiceName + cDisplayName ) * sizeof(TCHAR);
    }

    if ( dwBufferSize < dwMinSize )
    {
        *pdwMDRequiredBufferSize = dwMinSize;

        hresReturn = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }

    return hresReturn;
}


HRESULT
SetEnableRemote(
    DWORD   dwValue
    )
/*++

    SetEnableRemote

        set restart I/F enabled flag in registry
        ( HKLM\SOFTWARE\Microsoft\INetStp::EnableRestart::REG_DWORD )

    Arguments:
        
        dwValue - 0 to disable I/F, !0 to enable

    Returns:
        status

--*/
{
    DWORD   dwSt = NO_ERROR;
    HKEY    hKey;

    
    //
    // Check admin privilege by accessing IISADMIN key for write
    //

    if ( ( dwSt = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                TEXT("SYSTEM\\CurrentControlSet\\Services\\IISADMIN"), 
                                0, 
                                KEY_WRITE, 
                                &hKey ) ) == ERROR_SUCCESS )
    {
        RegCloseKey( hKey );

        //
        // Set IISCTL interface access flag in registry
        //

        if ( ( dwSt = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                    TEXT("SOFTWARE\\Microsoft\\INetStp"), 
                                    0, 
                                    KEY_WRITE, 
                                    &hKey ) ) == ERROR_SUCCESS )
        {
            if ( ( dwSt = RegSetValueEx( hKey, 
                                         TEXT("EnableRestart"),
                                         0, 
                                         REG_DWORD, 
                                         (const BYTE*)&dwValue, 
                                         sizeof(DWORD) ) ) == ERROR_SUCCESS )
            {
            }

            RegCloseKey( hKey );
        }
    }

    return HRESULT_FROM_WIN32( dwSt );
}


BOOL
GetNumeric( 
    LPSTR   pszNumArg,
    LPDWORD pdwVal
    )
{
    // protect against being called wrong.
    if ( pszNumArg == NULL ||
         pdwVal == NULL )
    {
        return FALSE;
    }

    if ( !isdigit( (UCHAR)(*pszNumArg) ) )
    {
        return FALSE;
    }

    *pdwVal = atoi( pszNumArg );

    return TRUE;
}

BOOL 
IsIIS6orGreater(
    )
/*++

    IsIIS6orGreater

        According to Aaron we are guaranteed to have
        the appropriate keys in the registry by the
        time iisreset /scm is called.

    Arguments:
        
        None

    Returns:
        TRUE = IIS 6 or greater;
        FALSE = anything below IIS 6;

--*/
{
    // Assume it is not IIS 6.
    BOOL IsIIS6 = FALSE;

    HKEY        hKey;
    DWORD       dwValue;
    DWORD       dwType;
    DWORD       dwSize;

    // Check the registry of the major version setup number.
    // If it is not there we assume it is not a 6.0 machine,
    // since it's better to setup a 6.0 machine in 5.0 state
    // instead of a 5.0 machine in 6.0 state.
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                       TEXT("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"), 
                       0, 
                       KEY_READ, 
                       &hKey ) == ERROR_SUCCESS )
    {
        if ( RegQueryValueEx( hKey, 
                              TEXT("MajorVersion"),
                              0, 
                              &dwType, 
                              (LPBYTE)&dwValue, 
                              &dwSize ) == ERROR_SUCCESS )
        {
            
            if ( dwType == REG_DWORD )
            {
                if ( dwValue >= 6 ) 
                {
                    // were are running on a system that does not
                    // have atleast IIS 6 on it

                    IsIIS6 = TRUE;
                }

            }

        }

        RegCloseKey( hKey );

    }


    return IsIIS6;

}

HRESULT
SetSCM(
	BOOL	fEnable
	)
/*++

    SetSCM

        set SCM Recovery configuration for IISADMIN service.
        Does nothing on pre Windows 2000 systems.

    Arguments:
        
        fEnable - TRUE to enable IISRESET invocation on service failure, FALSE to disable

    Returns:
        status

--*/
{
    PFNCHANGESERVICECONFIG2 pfnChangeServiceConfig2 = NULL;
    SERVICE_FAILURE_ACTIONS sfaAction;
    SC_ACTION               saCmdline[3];
    SC_HANDLE               schSCM;
    SC_HANDLE               schSrv;
    HRESULT                 hres = S_OK;
    TCHAR                   achModuleName[MAX_PATH];
    TCHAR                   achFailureCommand[MAX_PATH+32];
    HINSTANCE               hAdvapi;

    hAdvapi = LoadLibrary(_T("ADVAPI32.DLL"));
    if ( hAdvapi != NULL )
    {
        pfnChangeServiceConfig2 = (PFNCHANGESERVICECONFIG2)GetProcAddress( hAdvapi, "ChangeServiceConfig2W" );
    }

    if ( pfnChangeServiceConfig2 )
    {
        if ( !GetModuleFileName( NULL, 
                                 achModuleName, 
                                 sizeof(achModuleName)/sizeof(TCHAR) ) )
        {
            hres = HRESULT_FROM_WIN32( GetLastError() );
        }

        if ( SUCCEEDED( hres ) )
        {
            schSCM = OpenSCManager(NULL,
                                   NULL,
                                   SC_MANAGER_CONNECT);
            if ( schSCM == NULL )
	        {
                hres = HRESULT_FROM_WIN32( GetLastError() );
            }
            else 
	        {

                // We need to determine what IIS version we are running on
                // in order to know the correct way to setup the server.

                BOOL fIIS6orGreater = IsIIS6orGreater();

                //
                // In IIS 5.1 we want to use the default /restart 
                // setting of iisreset.  In IIS 6 or greater we
                // want to use the /start option.  A customer
                // can configure it to use the /restart option, but
                // that is not the default for the scm.
                //
                if ( fIIS6orGreater )
                {
                    //achModuleName is MAX_PATH size, the rest of the string is less than 32 characters.
                    wsprintf( achFailureCommand, _T("\"%s\" /start /fail=%%1%%"), achModuleName );
                }
                else
                {
                    //achModuleName is MAX_PATH size, the rest of the string is less than 32 characters.
                    wsprintf( achFailureCommand, _T("\"%s\" /fail=%%1%%"), achModuleName );
                }

                sfaAction.lpCommand = achFailureCommand;
                sfaAction.lpRebootMsg = _T("");
                sfaAction.dwResetPeriod = 24 * 60 * 60;

                if ( fEnable )
                {
                    sfaAction.cActions = 3;
                    sfaAction.lpsaActions = saCmdline;
                    saCmdline[0].Type = SC_ACTION_RUN_COMMAND;
                    saCmdline[0].Delay = 1;
                    saCmdline[1].Type = SC_ACTION_RUN_COMMAND;
                    saCmdline[1].Delay = 1;
                    saCmdline[2].Type = SC_ACTION_RUN_COMMAND;
                    saCmdline[2].Delay = 1;
                }
                else
                {
                    sfaAction.cActions = 3;
                    sfaAction.lpsaActions = saCmdline;
                    saCmdline[0].Type = SC_ACTION_NONE;
                    saCmdline[0].Delay = 0;
                    saCmdline[1].Type = SC_ACTION_NONE;
                    saCmdline[1].Delay = 0;
                    saCmdline[2].Type = SC_ACTION_NONE;
                    saCmdline[2].Delay = 0;
                }

                schSrv = OpenService( schSCM,
                                      _T("IISADMIN"),
                                      SERVICE_CHANGE_CONFIG);

                if ( schSrv )
                {
                    if ( !pfnChangeServiceConfig2( schSrv, 
                                                   SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                   &sfaAction ) )
                    {
                        hres = HRESULT_FROM_WIN32( GetLastError() );
                    }

                    CloseServiceHandle( schSrv );
                }
                else
                {
                    hres = HRESULT_FROM_WIN32( GetLastError() );
                }

                //
                // Now that we have configured IISAdmin correctly, we also need to 
                // configure W3SVC.
                //

                if ( fIIS6orGreater )
                {

                    sfaAction.lpCommand = NULL;
                    sfaAction.lpRebootMsg = _T("");
                    sfaAction.dwResetPeriod = 24 * 60 * 60;

                    if ( fEnable )
                    {
                        sfaAction.cActions = 3;
                        sfaAction.lpsaActions = saCmdline;
                        saCmdline[0].Type = SC_ACTION_RESTART;
                        saCmdline[0].Delay = 1;
                        saCmdline[1].Type = SC_ACTION_RESTART;
                        saCmdline[1].Delay = 1;
                        saCmdline[2].Type = SC_ACTION_RESTART;
                        saCmdline[2].Delay = 1;
                    }
                    else
                    {
                        sfaAction.cActions = 3;
                        sfaAction.lpsaActions = saCmdline;
                        saCmdline[0].Type = SC_ACTION_NONE;
                        saCmdline[0].Delay = 0;
                        saCmdline[1].Type = SC_ACTION_NONE;
                        saCmdline[1].Delay = 0;
                        saCmdline[2].Type = SC_ACTION_NONE;
                        saCmdline[2].Delay = 0;
                    }

                    schSrv = OpenService( schSCM,
                                          _T("W3SVC"),
                                          SERVICE_CHANGE_CONFIG |
                                          SERVICE_START);

                    if ( schSrv )
                    {
                        if ( !pfnChangeServiceConfig2( schSrv, 
                                                       SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                       &sfaAction ) )
                        {
                            hres = HRESULT_FROM_WIN32( GetLastError() );
                        }

                        CloseServiceHandle( schSrv );
                    }
                    else
                    {
                        hres = HRESULT_FROM_WIN32( GetLastError() );
                    }
                } // end of setting up restart on w3svc.
                

                CloseServiceHandle( schSCM );
            }
        }

    }

    if ( hAdvapi )
    {
        FreeLibrary( hAdvapi );
    }

    return hres;
}


enum CMDS { CMD_NONE, CMD_START, CMD_STOP, CMD_REBOOT, CMD_RESTART, CMD_KILL };

// We use lstrcmpiA to compare arguments typed in with our cmd options
// on foreign code pages case insensitivity can be missed, but since we
// are comparing against the english letters, and don't use foreign letters
// I believe this will be ok.
#pragma prefast(push)
#pragma prefast(disable:400, "Don't complain about using lstrcmpiA") 

int __cdecl 
main( 
    int argc, 
    char*argv[] 
    )
/*++

    main

        main function

    Arguments:
        
        argc
        argv

    Returns:

        0 if no error, otherwise error code

--*/
{
    IIisServiceControl* pIf;
    int                 iA;
    int                 Status = 0;
    HRESULT             hRes;
    CMDS                iCmd = CMD_NONE;
    DWORD               dwStopTimeout = 60 * 1000;
    DWORD               dwRestartTimeout = 20 * 1000;
    DWORD               dwStartTimeout = 60 * 1000;
    LPBYTE              pbBuffer = NULL;
    BYTE                abBuffer[4096];
    LPBYTE              pbOutBuffer = NULL;
    BYTE                abOutBuffer[4096];
    DWORD               dwRequired;
    DWORD               dwNumServices;
    LPVOID              apvParams[8];
    UINT                i;
    BOOL                fNoCmd = FALSE;
    BOOL                fRebootOnError = FALSE;
    BOOL                fKillOnError = TRUE;
    BOOL                fForce = TRUE;
    BOOL                fRebootRestart = FALSE;
    BOOL                fStatus = FALSE;
    COSERVERINFO        csiMachineName;
    MULTI_QI            rgmq;
    WCHAR               awchComputer[64];
    LPSTR               pszMachineName = NULL;
    BOOL                fErrDisplayed = FALSE;
    DWORD               dwFailCount;
    ULONG               CodePage = 0;
    TCHAR               CodePageString[MAX_STRINGIZED_ULONG_CHAR_COUNT + 1];

    //
    // Make sure international versions display text ok - RonaldM
    //
    _tsetlocale( LC_ALL, _T(".OCP") );

    // in order to get output working when the user code page
    // does not match the system code page or the system installed language
    // we have added the following lines, thru the second _tsetlocale.
    // this was recommended by Rostislav Shabalin.  It was also recommended
    // to keep the original _tsetlocale because it may be setting configuration
    // that will not get changed in the second _tsetlocal call.  
    // See RAID Windows Bugs #712030 for more info.
    CodePage = GetConsoleOutputCP();

    CodePageString[0] = _T('.');
    _ultot(CodePage, &(CodePageString[1]), 10 );

    _tsetlocale( LC_ALL, CodePageString );


    // Per issue: 439690 we need to make this call to make sure
    // that localized builds work correctly in all cases.
    SetThreadUILanguage(0);

    _fputts( _T("\n"), stdout );

    //
    // scan command line
    //

    for ( iA = 1 ; 
          iA < argc ; 
          ++iA )
    {
        if ( argv[iA][0] == '-' || argv[iA][0] == '/' )
        {
            if ( !lstrcmpiA( argv[iA]+1, "ENABLE" ) )
            {
                hRes = SetEnableRemote( 1 );

                if ( FAILED( hRes ) )
                {
                    if ( hRes == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
                    {
                        PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
                    }
                    else
                    {
                        DisplayErrorMessage( WIN32_FROM_HRESULT( hRes ) );
                    }

                    Status = WIN32_FROM_HRESULT( hRes );
                }
                else
                {
                    PrintMessage( IRSTASTR_ENABLED, 0, NULL );
                }

                fNoCmd = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "DISABLE" ) )
            {
                hRes = SetEnableRemote( 0 );

                if ( FAILED( hRes ) )
                {
                    if ( hRes == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
                    {
                        PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
                    }
                    else
                    {
                        DisplayErrorMessage( WIN32_FROM_HRESULT( hRes ) );
                    }

                    Status = WIN32_FROM_HRESULT( hRes );
                }
                else
                {
                    PrintMessage( IRSTASTR_DISABLED, 0, NULL );
                }

                fNoCmd = TRUE;
            }
            else if ( !_strnicmp( argv[iA]+1, "SCM", sizeof("SCM")-1 ) )
            {
                if ( FAILED( hRes = SetSCM( TRUE ) ) )
                {
                    DisplayErrorMessage( WIN32_FROM_HRESULT( hRes ) );

                    Status = WIN32_FROM_HRESULT( hRes );
                }
                goto Exit;
            }
            else if ( !_strnicmp( argv[iA]+1, "NOSCM", sizeof("NOSCM")-1 ) )
            {
                if ( FAILED( hRes = SetSCM( FALSE ) ) )
                {
                    DisplayErrorMessage( WIN32_FROM_HRESULT( hRes ) );

                    Status = WIN32_FROM_HRESULT( hRes );
                }
                goto Exit;
            }
            else if ( !_strnicmp( argv[iA]+1, "STOPTIMEOUT:", sizeof("STOPTIMEOUT:")-1 ) )
            {
                if ( !GetNumeric( argv[iA]+ 1 + sizeof("STOPTIMEOUT:") - 1, &dwStopTimeout ) )
                {
                    goto invalid_param;
                }
                dwStopTimeout *= 1000;
            }
            else if ( !_strnicmp( argv[iA]+1, "TIMEOUT:", sizeof("TIMEOUT:")-1 ) )
            {
                if ( !GetNumeric( argv[iA]+ 1 + sizeof("TIMEOUT:") - 1, &dwStopTimeout ) )
                {
                    goto invalid_param;
                }
                dwStopTimeout *= 1000;
                dwRestartTimeout = dwStopTimeout;
            }
            else if ( !_strnicmp( argv[iA]+1, "STARTTIMEOUT:", sizeof("STARTTIMEOUT:")-1 ) )
            {
                if ( !GetNumeric( argv[iA]+ 1 + sizeof("STARTTIMEOUT:") - 1, &dwStartTimeout ) )
                {
                    goto invalid_param;
                }
                dwStartTimeout *= 1000;
            }
            else if ( !_strnicmp( argv[iA]+1, "RESTARTTIMEOUT:", sizeof("RESTARTTIMEOUT:")-1 ) )
            {
                if ( !GetNumeric( argv[iA]+ 1 + sizeof("RESTARTTIMEOUT:") - 1, &dwRestartTimeout ) )
                {
                    goto invalid_param;
                }
                dwRestartTimeout *= 1000;
            }
            else if ( !_strnicmp( argv[iA]+1, "fail=", sizeof("fail=")-1 ) )
            {
                //
                // SCM flag to control restart threshold. We restart only 
                // 50 times per SCM restart period.
                //
                // ...  The SCM UI already has a way to address this: they add
                //  a "/fail=N" parameter to the command line 
                // of the restarter app for each time they fail within the time 
                // period and leave it up to the restarter app to interpret 
                // this parameter and throttle restarts approprately.  
                // So...(here's the change request) we need to capture this 
                // value, and if "N" is greater than our limit for 1 day of
                // restarting (hardcoded to 50), we should just exit the 
                // command line app with a success code without doing anything,
                // i.e. "IISRESET.EXE /fail=50" should restart IIS,
                // but "IISRESET.EXE /fail=51" should be a no-op.
                // For simplicity, we should hardcode this value of 50 in 
                // our app-- if a user wants a different value, he can write
                // a batch file wrapper to do it!  You can see 
                // the SCM recovery tab for more info.
                //

                dwFailCount = atoi( argv[iA]+ 1 + sizeof("fail=") - 1 );

                if ( dwFailCount > 50 )
                {
                    return 0;
                }
            }
            else if ( !lstrcmpiA( argv[iA]+1, "START" ) )
            {
                if ( fRebootRestart )
                {
                }
                else if ( iCmd == CMD_STOP )
                {
                    iCmd = CMD_RESTART;
                }
                else
                {
                    iCmd = CMD_START;
                }
            }
            else if ( !lstrcmpiA( argv[iA]+1, "STOP" ) )
            {
                if ( fRebootRestart )
                {
                }
                if ( iCmd == CMD_START )
                {
                    iCmd = CMD_RESTART;
                }
                else
                {
                    iCmd = CMD_STOP;
                }
            }
            else if ( !lstrcmpiA( argv[iA]+1, "REBOOT" ) )
            {
                iCmd = CMD_REBOOT;
                fRebootRestart = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "KILL" ) )
            {
                iCmd = CMD_KILL;
                fRebootRestart = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "RESTART" ) )
            {
                iCmd = CMD_RESTART;
                fRebootRestart = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "STATUS" ) )
            {
                fStatus = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "REBOOTONERROR" ) )
            {
                fRebootOnError = TRUE;
                fKillOnError = FALSE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "NOFORCE" ) )
            {
                fKillOnError = FALSE;
                fForce = FALSE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "HELP" ) )
            {
                PrintMessage( IRSTASTR_USAGE, 0, NULL );

                return 0;
            }
            else
            {
invalid_param:
                PrintMessage( IRSTASTR_USAGE, 0, NULL );

                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            pszMachineName = argv[iA];
        }
    }

    if ( iCmd == CMD_NONE && !fNoCmd && !fStatus )
    {
        iCmd = CMD_RESTART;
    }

    //
    //fill the structure for CoCreateInstanceEx
    //

    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );

    if ( pszMachineName )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszMachineName,
                                   -1, // process whole string including null terminator
                                   awchComputer,
                                   sizeof(awchComputer) / sizeof(WCHAR)) )
        {
            return GetLastError();
        }

        csiMachineName.pwszName =  awchComputer;
    }
    else
    {
        csiMachineName.pwszName =  NULL;
    }

    if ( fNoCmd )
    {
        iCmd = CMD_NONE;
        fStatus = FALSE;
    }

    if ( iCmd != CMD_NONE || fStatus )
    {

        BOOL  fCoInitialized = true;
        //
        // call method
        //

        rgmq.pIID = &IID_IIisServiceControl;
        rgmq.pItf = NULL;
        rgmq.hr = 0;

        if (FAILED(hRes = CoInitializeEx( NULL, COINIT_MULTITHREADED ))) {

            fCoInitialized = false;
        }
        else if ( SUCCEEDED( hRes = CoCreateInstanceEx( CLSID_IisServiceControl,
                                                   NULL,
                                                   CLSCTX_SERVER,
                                                   &csiMachineName,
                                                   1,
                                                   &rgmq ) ) &&
             SUCCEEDED( hRes = rgmq.hr ) )
        {
            pIf = (IIisServiceControl*)rgmq.pItf;

            switch ( iCmd )
            {
                case CMD_START:
                    PrintMessage( IRSTASTR_START_ATTEMPT, 0, NULL );
                    hRes = pIf->Start( dwStartTimeout );
                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_START_SUCCESS, 0, NULL );
                    }
                    else
                    {
                        CmdError( IRSTASTR_START_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;

                case CMD_STOP:
                    PrintMessage( IRSTASTR_STOP_ATTEMPT, 0, NULL );
                    hRes = pIf->Stop( dwStopTimeout, fKillOnError );
                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_STOP_SUCCESS, 0, NULL );
                    }
                    else
                    {
                        CmdError( IRSTASTR_STOP_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;

                case CMD_REBOOT:
                    PrintMessage( IRSTASTR_REBOOT_ATTEMPT, 0, NULL );
                    hRes = pIf->Reboot( dwRestartTimeout, fForce );
                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_REBOOT_SUCCESS, 0, NULL );
                    }
                    else
                    {
                        CmdError( IRSTASTR_REBOOT_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;

                case CMD_KILL:
                    PrintMessage( IRSTASTR_KILL_ON_ERROR, 0, NULL );
                    hRes = pIf->Kill();
                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_KILL_SUCCESS, 0, NULL );
                    }
                    else
                    {
                        CmdError( IRSTASTR_KILL_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;

                case CMD_RESTART:

                    PrintMessage( IRSTASTR_STOP_ATTEMPT, 0, NULL );
                    hRes = pIf->Stop( dwRestartTimeout, fKillOnError );

                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_STOP_SUCCESS, 0, NULL );

                        PrintMessage( IRSTASTR_START_ATTEMPT, 0, NULL );
                        hRes = pIf->Start( dwStartTimeout );

                        if ( SUCCEEDED( hRes ) )
                        {
                            PrintMessage( IRSTASTR_RESTART_SUCCESS, 0, NULL );
                        }
                    }
                    if ( FAILED( hRes ) )
                    {
                        CmdError( IRSTASTR_RESTART_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;
            }

            if ( fStatus )
            {
                pbBuffer = NULL;
                fErrDisplayed = FALSE;

                if ( FAILED( hRes = pIf->Status( sizeof(abBuffer), 
                                                 abBuffer, 
                                                 &dwRequired, 
                                                 &dwNumServices ) ) )
                {
                    if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) == hRes )
                    {
                        if ( (pbBuffer = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired )) == NULL )
                        {
                            hRes = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                        }
                        else
                        {
                            hRes = pIf->Status( dwRequired, 
                                                pbBuffer, 
                                                &dwRequired, 
                                                &dwNumServices );
                        }
                    }
                }
                else
                {
                    pbBuffer = abBuffer;
                }

                if ( SUCCEEDED( hRes ) )
                {
                    pbOutBuffer = NULL;

                    if ( FAILED( hRes = DeserializeEnumServiceBuffer( pbBuffer, 
                                                                      dwNumServices, 
                                                                      abOutBuffer, 
                                                                      sizeof(abOutBuffer), 
                                                                      &dwRequired ) ) )
                    {
                        if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) == hRes )
                        {
                            if ( (pbOutBuffer = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired )) == NULL )
                            {
                                hRes = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                            }
                            else
                            {
                                hRes = DeserializeEnumServiceBuffer( pbBuffer, 
                                                                     dwNumServices, 
                                                                     pbOutBuffer, 
                                                                     dwRequired, 
                                                                     &dwRequired );
                            }
                        }
                    }
                    else
                    {
                        pbOutBuffer = abOutBuffer;
                    }
                }

                if ( SUCCEEDED( hRes ) )
                {
                    for ( i = 0 ; i < dwNumServices ; ++i )
                    {
                        apvParams[0] = ((LPENUM_SERVICE_STATUS)pbOutBuffer)[i].lpDisplayName;
                        apvParams[1] = ((LPENUM_SERVICE_STATUS)pbOutBuffer)[i].lpServiceName;

                        switch ( ((LPENUM_SERVICE_STATUS)pbOutBuffer)[i].ServiceStatus.dwCurrentState )
                        {
                            case SERVICE_STOPPED:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_STOPPED); break;

                            case SERVICE_START_PENDING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_START_PENDING); break;

                            case SERVICE_STOP_PENDING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_STOP_PENDING); break;

                            case SERVICE_RUNNING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_RUNNING); break;

                            case SERVICE_CONTINUE_PENDING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_CONTINUE_PENDING); break;

                            case SERVICE_PAUSE_PENDING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_PAUSE_PENDING); break;

                            case SERVICE_PAUSED:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_PAUSED); break;

                            default:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_DEFAULT); break;
                        }

                        PrintMessage( IRSTASTR_STATUS_ITEM, 3, apvParams );
                    }
                }

                if ( pbBuffer != NULL && pbBuffer != abBuffer )
                {
                    LocalFree( pbBuffer );
                }

                if ( pbOutBuffer != NULL && pbOutBuffer != abOutBuffer )
                {
                    LocalFree( pbOutBuffer );
                }

            }

            if ( FAILED( hRes ) && fRebootOnError
                 && ( iCmd == CMD_STOP || iCmd == CMD_RESTART ) )
            {
                fErrDisplayed = FALSE;
                PrintMessage( IRSTASTR_REBOOT_ON_ERROR, 0, NULL );

                hRes = pIf->Reboot( 0, fForce );

                if ( SUCCEEDED( hRes ) )
                {
                    PrintMessage( IRSTASTR_REBOOT_SUCCESS, 0, NULL );
                }
            }

            pIf->Release();

            if ( FAILED( hRes ) )
            {
                if ( !fErrDisplayed )
                {
                    if ( hRes == HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED ) )
                    {
                        PrintMessage( IRSTASTR_REMOTE_DISABLED, 0, NULL );
                    }
                    else if ( hRes == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
                    {
                        PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
                    }
                    else
                    {
                        DisplayErrorMessage( WIN32_FROM_HRESULT( hRes ) );
                    }
                }

                Status = WIN32_FROM_HRESULT( hRes );
            }
        }
        else
        {
            if ( hRes == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
            {
                PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
            }
            else
            {
                DisplayErrorMessage( WIN32_FROM_HRESULT( hRes ) );
            }

            Status = WIN32_FROM_HRESULT( hRes );
        }
        if (fCoInitialized) {
            CoUninitialize();
        }
    }

Exit:

    return Status;
}
#pragma prefast(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iisrsta.rc
//
#define IDS_PROJNAME                    100
#define IDR_Iisrsta                     100
#define IDR_IISRESTART                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\inetdbgp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    inetdbgp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Murali Krishnan (MuraliK) 22-Aug-1996

Revision History:

--*/

# ifndef _INETDBGP_H_
# define _INETDBGP_H_

//
// Module enumerator.
//

typedef struct _MODULE_INFO {
    ULONG_PTR DllBase;
    ULONG_PTR EntryPoint;
    ULONG SizeOfImage;
    CHAR BaseName[MAX_PATH];
    CHAR FullName[MAX_PATH];
} MODULE_INFO, *PMODULE_INFO;

typedef
BOOLEAN
(CALLBACK * PFN_ENUMMODULES)(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    );

BOOLEAN
EnumModules(
    IN HANDLE ExtensionCurrentProcess,
    IN PFN_ENUMMODULES EnumProc,
    IN PVOID Param
    );

# endif //  _INETDBGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

//#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\iisrsta.cpp ===
/*
    IisRsta.cpp

    Implementation of WinMain for COM IIisServiceControl handler

    FILE HISTORY:
        Phillich    06-Oct-1998     Created

*/


#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "iisrsta.h"
#include <secfcns.h>
#include <Aclapi.h>

#include "IisRestart.h"

const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

HRESULT
AddLaunchPermissionsAcl(
    PSECURITY_DESCRIPTOR pSD
    );

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IisServiceControl, CIisRestart)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//


int _cdecl 
main(
    int, 
    char
    ) 
{

    LPTSTR lpCmdLine = GetCommandLine();    // necessary for minimal CRT

    HRESULT hRes = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;
    PSID    psidAdmin = NULL;
    PACL    pACL = NULL;
    EXPLICIT_ACCESS ea;   
    SECURITY_DESCRIPTOR sd = {0};

    BOOL fCoInitialized = FALSE;

    hRes = CoInitializeEx(NULL,COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        goto exit;
    }

    fCoInitialized = TRUE;

    //
    // Get a sid that represents the Administrators group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinAdministratorsSid,
                                           &psidAdmin );
    if ( dwErr != ERROR_SUCCESS )
    {
        hRes = HRESULT_FROM_WIN32(dwErr);
        goto exit;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    SecureZeroMemory(&ea, sizeof(ea));

    //
    // Setup Administrators for read access.
    //
    SetExplicitAccessSettings(  &ea,
                                COM_RIGHTS_EXECUTE,
                                SET_ACCESS,
                                psidAdmin );

    //
    // Create a new ACL that contains the new ACEs.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS), &ea, NULL, &pACL);
    if ( dwErr != ERROR_SUCCESS )
    {
        hRes = HRESULT_FROM_WIN32(dwErr);
        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
    {
        hRes = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if (!SetSecurityDescriptorDacl(&sd,
            TRUE,     // fDaclPresent flag
            pACL,
            FALSE))   // not a default DACL
    {
        hRes = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if (!SetSecurityDescriptorOwner(&sd,
            psidAdmin,     // fDaclPresent flag
            FALSE))   // not a default DACL
    {
        hRes = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if (!SetSecurityDescriptorGroup(&sd,
            psidAdmin,      // fDaclPresent flag
            FALSE))         // not a default DACL
    {
        hRes = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    hRes = CoInitializeSecurity(
                    &sd,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_ANONYMOUS,
                    NULL,
                    EOAC_DYNAMIC_CLOAKING | 
                    EOAC_DISABLE_AAA | 
                    EOAC_NO_CUSTOM_MARSHAL,
                    NULL );

    if (FAILED(hRes)) 
    {
        goto exit;
    }

    _ASSERTE(SUCCEEDED(hRes));

    _Module.Init(ObjectMap,GetModuleHandle(NULL));
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine,szTokens);
    while (lpszToken != NULL)
    {

#pragma prefast(push)
#pragma prefast(disable:400, "Don't complain about case insensitive compares") 

        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_IISRESTART, FALSE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_IISRESTART, TRUE);

            // we need to do the Module.Terminate so we 
            // will just flow on with a bad hresult, however
            // it will end up getting returned to the user
            // so it is ok.
            hRes = AddLaunchPermissionsAcl(&sd);

            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);

#pragma prefast(pop)

    }


    if (bRun) {
        _Module.StartMonitor();
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
        {
            DispatchMessage(&msg);
        }

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

    _Module.Term();

exit:

    FreeWellKnownSid(&psidAdmin);

    if (pACL)
    {
        LocalFree(pACL);
        pACL = NULL;
    }

    if ( fCoInitialized )
    {
        CoUninitialize();
    }

    return (hRes);
}

HRESULT
AddLaunchPermissionsAcl(
    PSECURITY_DESCRIPTOR pSD
    )
{
    DWORD   Win32Error  = NO_ERROR;
    HRESULT hr          = S_OK;
    HKEY    KeyHandle   = NULL;
    PSECURITY_DESCRIPTOR pSDRelative = NULL;
    DWORD   dwBytesNeeded = 0;

    if ( MakeSelfRelativeSD( pSD,
                             pSDRelative,
                             &dwBytesNeeded ) )
    {
        // If this passes, then there is a real problem because
        // we didn't give it anywhere to copy to.  So 
        // we fail here.
        return E_FAIL;
    }

    Win32Error = GetLastError();
    if ( Win32Error != ERROR_INSUFFICIENT_BUFFER )
    {
        return HRESULT_FROM_WIN32(Win32Error);
    }

    // At this point we know the size of the data
    // that we are going to receive, so we can allocated
    // enough space.

    pSDRelative = ( PSECURITY_DESCRIPTOR ) new BYTE[ dwBytesNeeded ];
    if ( pSDRelative == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if ( !MakeSelfRelativeSD( pSD,
                             pSDRelative,
                             &dwBytesNeeded ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    Win32Error = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        L"AppID\\{E8FB8615-588F-11D2-9D61-00C04F79C5FE}",
                        NULL, 
                        KEY_WRITE, 
                        &KeyHandle
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"LaunchPermission",
                        NULL, 
                        REG_BINARY, 
                        reinterpret_cast<BYTE *>( pSDRelative ),
                        dwBytesNeeded
                        );
    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

exit:

    if ( KeyHandle != NULL )
    {
        RegCloseKey( KeyHandle );
    }

    if ( pSDRelative != NULL )
    {
        delete [] pSDRelative;
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#endif

#include <smtptype.h>
#include <smtpapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtp.inc ===
# Global settings for SMTP subprojects

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

!IFNDEF STAXINCDIR
STAXINCDIR=staxinc
!ENDIF

!IFNDEF SMTPDIR
SMTPDIR=smtp
!ENDIF

!INCLUDE $(IISBASEDIR)\$(STAXINCDIR)\build\paths.inc

STAXSMTP=$(STAXBASE)\$(SMTPDIR)
STAXSMTPTARGET=$(STAXSMTP)\$(_OBJ_DIR)
STAXSMTPLIBPATH=$(STAXSMTPTARGET)\$(TARGET_DIRECTORY)

# Hack to create the lib directory
!if [mkdir $(STAXSMTPTARGET)\$(TARGET_DIRECTORY)]
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\iisrsta\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E8FB8617_588F_11D2_9D61_00C04F79C5FE__INCLUDED_)
#define AFX_STDAFX_H__E8FB8617_588F_11D2_9D61_00C04F79C5FE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#pragma prefast(push)
#pragma prefast(disable:255 221, "atl error") 
#include <atlbase.h>
#pragma prefast(pop)

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;

#pragma prefast(push)
#pragma prefast(disable:248 255, "atl error") 
#include <atlcom.h>
#pragma prefast(pop)


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E8FB8617_588F_11D2_9D61_00C04F79C5FE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\restart\interfac\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    DLL startup routine.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>

}   // extern "C"

#include <iisrsta.h>


//
// Private globals.
//

//DECLARE_DEBUG_PRINTS_OBJECT();


//
// Private prototypes.
//


//
// DLL Entrypoint.
//

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    BOOL status = TRUE;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH :
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH :
        break;

    }

    return status;

}   // DLLEntry

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\admin.cpp ===
// admin.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "metautil.h"

#include "smtpadm.h"
#include "smtpcmn.h"
#include "smtpprop.h"
#include "admin.h"
#include "version.h"
#include "oleutil.h"

#include "metakey.h"

#define SMTP_DEF_SERVICE_VERSION	( 0 )	//  MCIS

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT          0
#define THIS_FILE_PROG_ID                       _T("Smtpadm.Admin.1")
#define THIS_FILE_IID                           IID_ISmtpAdmin

/////////////////////////////////////////////////////////////////////////////
//

CSmtpAdmin::CSmtpAdmin () :
	m_dwServiceInstance		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	m_dwServiceVersion	= SMTP_DEF_SERVICE_VERSION;
}

CSmtpAdmin::~CSmtpAdmin ()
{
	// All CComBSTR's are freed automatically.
}

STDMETHODIMP CSmtpAdmin::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdmin,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CSmtpAdmin::get_ServiceAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComBSTR						bstrT = _T("");
	CComPtr<ISmtpAdminService>	pISmtpAdminService;

	if (!bstrT) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	
	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminService,
		IID_ISmtpAdminService,
		&pISmtpAdminService, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminService->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminService
}

STDMETHODIMP CSmtpAdmin::get_VirtualServerAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComBSTR								bstrT = _T("");
	CComPtr<ISmtpAdminVirtualServer>	pISmtpAdminVirtualServer;

	if (!bstrT) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	
	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminVirtualServer,
		IID_ISmtpAdminVirtualServer,
		&pISmtpAdminVirtualServer, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminVirtualServer->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminVirtualServer->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminVirtualServer
}

STDMETHODIMP CSmtpAdmin::get_SessionsAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComBSTR						bstrT = _T("");
	CComPtr<ISmtpAdminSessions>	pISmtpAdminSessions;

	if (!bstrT) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminSessions,
		IID_ISmtpAdminSessions,
		&pISmtpAdminSessions, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminSessions->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminSessions->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminSessions
}


STDMETHODIMP CSmtpAdmin::get_AliasAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComBSTR						bstrT = _T("");
	CComPtr<ISmtpAdminAlias>	pISmtpAdminAlias;

	if (!bstrT) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminAlias,
		IID_ISmtpAdminAlias,
		&pISmtpAdminAlias, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminAlias->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminAlias->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminAlias
}


STDMETHODIMP CSmtpAdmin::get_UserAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComBSTR					bstrT = _T("");
	CComPtr<ISmtpAdminUser>	pISmtpAdminUser;

	if (!bstrT) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminUser,
		IID_ISmtpAdminUser,
		&pISmtpAdminUser, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminUser->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminUser->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminUser


}

STDMETHODIMP CSmtpAdmin::get_DLAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComBSTR					bstrT = _T("");
	CComPtr<ISmtpAdminDL>	pISmtpAdminDL;

	if (!bstrT) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	
	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminDL,
		IID_ISmtpAdminDL,
		&pISmtpAdminDL, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminDL->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminDL->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminDL
}

STDMETHODIMP CSmtpAdmin::get_DomainAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComBSTR						bstrT = _T("");
	CComPtr<ISmtpAdminDomain>	pISmtpAdminDomain;

	if (!bstrT) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminDomain,
		IID_ISmtpAdminDomain,
		&pISmtpAdminDomain, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminDomain->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminDomain->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminDomain
}

STDMETHODIMP CSmtpAdmin::get_VirtualDirectoryAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComBSTR								bstrT = _T("");
	CComPtr<ISmtpAdminVirtualDirectory>	pISmtpAdminVirtualDirectory;

	if (!bstrT) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminVirtualDirectory,
		IID_ISmtpAdminVirtualDirectory,
		&pISmtpAdminVirtualDirectory, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminVirtualDirectory->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminVirtualDirectory->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminVirtualDirectory
}


// Which service to configure:
	
STDMETHODIMP CSmtpAdmin::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CSmtpAdmin::put_Server ( BSTR strServer )
{
	return StdPropertyPutServerName ( &m_strServer, strServer );
}

STDMETHODIMP CSmtpAdmin::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CSmtpAdmin::put_ServiceInstance ( long lServiceInstance )
{
	return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance );
}

// Versioning:

STDMETHODIMP CSmtpAdmin::get_HighVersion ( long * plHighVersion )
{
	*plHighVersion = HIGH_VERSION;
	return NOERROR;
}

STDMETHODIMP CSmtpAdmin::get_LowVersion ( long * plLowVersion )
{
	*plLowVersion = LOW_VERSION;
	return NOERROR;
}

STDMETHODIMP CSmtpAdmin::get_BuildNum ( long * plBuildNumber )
{
	*plBuildNumber = BUILD_NUM;
	return NOERROR;
}

STDMETHODIMP CSmtpAdmin::get_ServiceVersion ( long * plServiceVersion )
{
	*plServiceVersion = m_dwServiceVersion;
	return NOERROR;
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::EnumerateInstances
//
//	Description:
//
//		Returns a list of the virtual servers on the given machine.
//
//	Parameters:
//
//		ppsaInstances - Returned SAFEARRAY of instance IDs.  
//			Must be freed by caller.
//
//	Returns:
//
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdmin::EnumerateInstances ( SAFEARRAY ** ppsaInstances )
{
	TraceFunctEnter ( "CSmtpAdmin::EnumerateInstances" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;
	SAFEARRAY * 		psaEmpty	= NULL;
	SAFEARRAYBOUND		sabound[1];

	// Check parameters:
	_ASSERT ( ppsaInstances != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaInstances ) );

	if ( ppsaInstances == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		hr = E_POINTER;
		goto Exit;
	}

	// Zero the out parameters:
	*ppsaInstances	= NULL;

	// Set the return array to an empty array:
	sabound[0].lLbound = 0;
	sabound[0].cElements = 0;

	psaEmpty = SafeArrayCreate ( VT_I4, 1, sabound );
	if ( psaEmpty == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	*ppsaInstances = psaEmpty;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
    BAIL_ON_FAILURE(hr);

	// Enumerate the instances:
	hr = QueryMetabaseInstances ( pMetabase, ppsaInstances );

Exit:
	if ( FAILED(hr) ) {
		_VERIFY ( SUCCEEDED (SafeArrayDestroy ( psaEmpty )) );
        if (ppsaInstances)
            *ppsaInstances = NULL;
	}

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdmin::EnumerateInstancesVariant ( SAFEARRAY ** ppsaInstances )
{
	TraceFunctEnter ( "CSmtpAdmin::EnumerateInstancesVariant" );

	HRESULT                 hr;
	SAFEARRAY       *       psaInstances    = NULL;

	hr = EnumerateInstances ( &psaInstances );
	BAIL_ON_FAILURE(hr);

	hr = LongArrayToVariantArray ( psaInstances, ppsaInstances );
	BAIL_ON_FAILURE(hr);

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::CreateInstance
//
//	Description:
//
//		Creates a new SMTP virtual server on the given machine.
//
//	Parameters:
//
//		plInstanceId - The new virtual server ID.
//
//	Returns:
//
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdmin::CreateInstance ( BSTR pstrMailRoot, long * plInstanceId )
{
	TraceFunctEnter ( "CSmtpAdmin::CreateInstance" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Check parameters:
	_ASSERT ( plInstanceId != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plInstanceId ) );

	if ( plInstanceId == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		hr = E_POINTER;
		goto Exit;
	}

	// Zero the out parameter:
	*plInstanceId 	= 0;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Create a new instance:
	hr = CreateNewInstance ( pMetabase, plInstanceId, pstrMailRoot );

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::DestroyInstance
//
//	Description:
//
//		Removes the given virtual server.
//
//	Parameters:
//
//		lInstanceId - The ID of the virtual server to delete.
//
//	Returns:
//
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdmin::DestroyInstance ( long lInstanceId )
{
	TraceFunctEnter ( "CSmtpAdmin::DestroyInstance" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Delete the instance:
	hr = DeleteInstance ( pMetabase, lInstanceId );

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::ErrorToString
//
//	Description:
//
//		Translates an SMTP_ERROR_CODE to a readable string.
//
//	Parameters:
//
//		lErrorCode 	- Win32 error code.
//		pstrError	- the readable error string.
//
//	Returns:
//
//		The error string in *pstrError.
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdmin::ErrorToString ( DWORD lErrorCode, BSTR * pstrError )
{
	TraceFunctEnter ( "CSmtpAdmin::ErrorToString" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pstrError ) );

	HRESULT		hr = NOERROR;
	DWORD		dwFormatFlags;
	WCHAR		wszError [ 1024 ];

	if ( pstrError == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad return pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	//----------------------------------------------------------------
	//
	//	Map error codes here:
	//

	//
	//----------------------------------------------------------------

	dwFormatFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;

	if ( !FormatMessage ( dwFormatFlags, NULL, lErrorCode, 0,      // Lang ID - Should be nonzero?
			wszError, 1024, NULL ) ) {

		// Didn't work, so put in a default message:

		WCHAR   wszFormat [ 256 ];

		wszFormat[0] = L'\0';
		if ( !LoadStringW ( _Module.GetResourceInstance (), IDS_UNKNOWN_ERROR, wszFormat, 256 ) ||
			!*wszFormat ) {

			wcscpy ( wszFormat, L"Unknown Error (%1!d!)" );
		}

		FormatMessage (
			FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
			wszFormat, 
			IDS_UNKNOWN_ERROR, 
			0, 
			wszError, 
			1024,
			(va_list *) &lErrorCode
			);
	}
	//
	// We need to strip out any " from the string, because
	// Javascript will barf.
	//

	LPWSTR  pch;

	for ( pch = wszError; *pch; pch++ ) {

		if ( *pch == L'\"' ) {
			*pch = L'\'';
		}
	}

	//
	// Strip off any trailing control characters.
	//
	for (pch = &wszError[wcslen(wszError) - 1];
		pch >= wszError && iswcntrl(*pch);
		pch --) {

		*pch = 0;
	}

	*pstrError = ::SysAllocString( wszError );

	if ( *pstrError == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}


//$-------------------------------------------------------------------
//
//	CSmtpAdmin::Tokenize
//
//	Description:
//
//		Makes the given string safe for HTML & Javascript
//
//	Parameters:
//
//		strIn - the input string
//		strOut - the resulting string with appropriate escape sequences.
//
//--------------------------------------------------------------------
STDMETHODIMP CSmtpAdmin::Tokenize ( BSTR strIn, BSTR * pstrOut )
{
	TraceFunctEnter ( "CSmtpAdmin::Tokenize" );

	_ASSERT ( IS_VALID_STRING ( strIn ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrOut ) );

	HRESULT		hr		= NOERROR;
	PWCHAR		pSrc	= strIn;
	PWCHAR		pSrcCur	= NULL;
	PWCHAR		pDstCur	= NULL;
	PWCHAR		pDst	= NULL;

	*pstrOut = NULL;

	pDst = new WCHAR [ 3 * lstrlen ( strIn ) + 1 ];
	if ( pDst == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

    for ( pSrcCur = pSrc, pDstCur = pDst; *pSrcCur; pSrcCur++ ) {
        switch ( *pSrcCur ) {
            case L'\\':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'5';
                *(pDstCur++) = L'c';
                break;

            case L' ':
                *(pDstCur++) = L'+';
                break;

            case L':':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'3';
                *(pDstCur++) = L'a';
                break;

            case L'/':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'2';
                *(pDstCur++) = L'f';
                break;

            default:
                *(pDstCur++) = *pSrcCur;
        }
    }
    *pDstCur = L'\0';

	*pstrOut = ::SysAllocString ( pDst );
	if ( *pstrOut == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	delete pDst;

	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}

	TraceFunctLeave ();
	return hr;
}


//$-------------------------------------------------------------------
//
//	CSmtpAdmin::QueryMetabaseInstances
//
//	Description:
//
//		Retrieves the list of virtual servers from the metabase
//
//	Parameters:
//
//		pMetabase		- the metabase object
//		ppsaInstances	- resulting array of instance ids.
//
//	Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdmin::QueryMetabaseInstances ( IMSAdminBase * pMetabase, SAFEARRAY ** ppsaInstances )
{
	TraceFunctEnter ( "CSmtpAdmin::QueryMetabaseInstances" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaInstances ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeySmtp ( pMetabase );
	SAFEARRAY *		psaResult		= NULL;
	DWORD			cValidInstances	= 0;
	SAFEARRAYBOUND	rgsaBound[1];
	DWORD			i;
	TCHAR			szName[ METADATA_MAX_NAME_LEN ];
	long			index[1];
	DWORD			dwInstance;

	hr = mkeySmtp.Open ( SMTP_MD_ROOT_PATH );

	if ( FAILED(hr) ) {
		goto Exit;
	}

	//	pickup the service version number:
	hr = mkeySmtp.GetDword ( _T(""), MD_SMTP_SERVICE_VERSION, &m_dwServiceVersion );
	if ( FAILED(hr) ) {
		m_dwServiceVersion	= SMTP_DEF_SERVICE_VERSION;
	}

	hr = mkeySmtp.GetIntegerChildCount ( &cValidInstances );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Allocate the array:
	rgsaBound[0].lLbound	= 0;
	rgsaBound[0].cElements	= cValidInstances;
	
	psaResult	= SafeArrayCreate ( VT_I4, 1, rgsaBound );

	if ( psaResult == NULL ) {
		FatalTrace ( 0, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	mkeySmtp.BeginChildEnumeration ();

	for ( i = 0; i < cValidInstances; i++ ) {
		hr = mkeySmtp.NextIntegerChild ( &dwInstance, szName );
		_ASSERT ( SUCCEEDED(hr) );

		index[0]	= i;
		hr			= SafeArrayPutElement ( psaResult, index, &dwInstance );
		_ASSERT ( SUCCEEDED(hr) );
	}

	*ppsaInstances = psaResult;
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED (hr) ) {
		SafeArrayDestroy ( psaResult );
	}

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::CreateNewInstance
//
//	Description:
//
//		Creates a new virtual server in the metabase.
//
//	Parameters:
//
//		pMetabase		- The metabase object
//		plInstanceId	- The new instance ID.
//
//	Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdmin::CreateNewInstance (
	IMSAdminBase * pMetabase,
	long * plInstanceId,
	BSTR bstrMailRoot
	)
{
	TraceFunctEnter ( "CSmtpAdmin::CreateNewInstance" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( plInstanceId ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeySmtp ( pMetabase );
	DWORD			dwInstance;
	TCHAR			szInstance [ METADATA_MAX_NAME_LEN ];
	TCHAR			szPath [ METADATA_MAX_NAME_LEN ];
	TCHAR			szDir [512];
	DWORD			cb;

	// Zero the out parameters:
	*plInstanceId	= NULL;

	hr = mkeySmtp.Open ( SMTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open SmtpSvc key, %x", GetLastError() );
		goto Exit;
	}

	hr = mkeySmtp.CreateIntegerChild ( &dwInstance, szInstance );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	wsprintf( szPath, _T("%s/Root"), szInstance );
	hr = mkeySmtp.CreateChild( szPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	wsprintf( szPath, _T("%s/Root/MailRoot"), szInstance );
	hr = mkeySmtp.CreateChild( szPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	//  create mail root virtual directory
	if( bstrMailRoot && bstrMailRoot[0] )
	{
		// get rid of '\' at the end
		cb = lstrlen( bstrMailRoot );
		if( cb > 0 && bstrMailRoot[cb-1] == _T('\\') )
			bstrMailRoot[cb-1] = _T('\0');

		wsprintf( szPath, _T("%s/Root/MailRoot"), szInstance );
		cb = wsprintf( szDir, _T("%s\\Mailbox"), bstrMailRoot );
		mkeySmtp.SetString( szPath, MD_VR_PATH, szDir);

		// set badmail, drop, pickup, queue keys
		wsprintf( szPath, _T("%s"), szInstance );

		cb = wsprintf( szDir, _T("%s\\Badmail"), bstrMailRoot );
		mkeySmtp.SetString( szPath, MD_BAD_MAIL_DIR, szDir);

		// K2 only has drop doamin
		if( SERVICE_IS_K2(m_dwServiceVersion) )
		{
			cb = wsprintf( szDir, _T("%s\\Drop"), bstrMailRoot );
			mkeySmtp.SetString( szPath, MD_MAIL_DROP_DIR, szDir );
		}


		cb = wsprintf( szDir, _T("%s\\Pickup"), bstrMailRoot );
		mkeySmtp.SetString( szPath, MD_MAIL_PICKUP_DIR, szDir );

		cb = wsprintf( szDir, _T("%s\\Queue"), bstrMailRoot );
		mkeySmtp.SetString( szPath, MD_MAIL_QUEUE_DIR, szDir );

		// set the routing sources, it's MultiSZ
		cb = wsprintf( szDir, _T("szDataDirectory=%s\\Route"), bstrMailRoot );
		szDir[cb] = szDir[cb+1] = _T('\0');
		mkeySmtp.SetMultiSz( szPath, MD_ROUTING_SOURCES, szDir, (cb+2) * sizeof(TCHAR) );

        // MCIS needs SendNDRTo and SendBadTo as "Postmaster", setup should set it on service level
        if( SERVICE_IS_MCIS(m_dwServiceVersion) )
        {
            mkeySmtp.SetString( szPath, MD_SEND_NDR_TO, TSTR_POSTMASTR_NAME );
            mkeySmtp.SetString( szPath, MD_SEND_BAD_TO, TSTR_POSTMASTR_NAME );
        }
	}

	//
	//  Initialize the server state:
	//

	mkeySmtp.SetDword ( szInstance, MD_SERVER_COMMAND, MD_SERVER_COMMAND_STOP );
	mkeySmtp.SetDword ( szInstance, MD_SERVER_STATE, MD_SERVER_STATE_STOPPED );
	mkeySmtp.SetDword ( szInstance, MD_SERVER_AUTOSTART, FALSE );

	// hr = mkeySmtp.Close();
	// BAIL_ON_FAILURE(hr);
	mkeySmtp.Close();

	hr = pMetabase->SaveData ( );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	*plInstanceId = dwInstance;

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::DeleteInstance
//
//	Description:
//
//		Removes a virtual server from the metabase
//
//	Parameters:
//
//		pMetabase	- The metabase object
//		lInstanceId	- The ID of the virtual server to delete.
//
//	Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdmin::DeleteInstance ( IMSAdminBase * pMetabase, long lInstanceId )
{
	TraceFunctEnter ( "CSmtpAdmin::CreateNewInstance" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeySmtp ( pMetabase );

    //
    //  Tell U2 to delete any mappings associated with this virtual server:
    //

    ::DeleteMapping ( m_strServer, (BSTR) MD_SERVICE_NAME, lInstanceId );

    //
    //  Delete the virtual server from the metabase:
    //

	hr = mkeySmtp.Open ( SMTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open SmtpSvc key, %x", GetLastError() );
		goto Exit;
	}

	hr = mkeySmtp.DestroyIntegerChild ( (DWORD) lInstanceId );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	// hr = mkeySmtp.Close();
	// BAIL_ON_FAILURE(hr);
	mkeySmtp.Close();

	hr = pMetabase->SaveData ( );
	if ( FAILED (hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\admin.h ===
// admin.h : Declaration of the CSmtpAdmin

// Dependencies:

#include "resource.h"       // main symbols

#include "metafact.h"

struct IMSAdminBase;

//  Service Versioning:

#define SERVICE_IS_K2(dwVersion)        ((dwVersion) == 1)
#define SERVICE_IS_MCIS(dwVersion)      ((dwVersion) == 0)


/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdmin : 
	public CComDualImpl<ISmtpAdmin, &IID_ISmtpAdmin, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdmin,&CLSID_CSmtpAdmin>
{
public:
	CSmtpAdmin();
	virtual ~CSmtpAdmin ();

BEGIN_COM_MAP(CSmtpAdmin)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmtpAdmin)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdmin) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdmin, _T("Smtpadm.Admin.1"), _T("Smtpadm.Admin"), IDS_SMTPADMIN_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISmtpAdmin
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Pointers to other ISmtpAdmin interfaces:
		
	STDMETHODIMP	get_ServiceAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_VirtualServerAdmin	( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_SessionsAdmin	( IDispatch ** ppIDispatch );

	STDMETHODIMP	get_AliasAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_UserAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_DLAdmin			( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_DomainAdmin		( IDispatch ** ppIDispatch );

	STDMETHODIMP	get_VirtualDirectoryAdmin		( IDispatch ** ppIDispatch );


	// Which service to configure:

	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Versioning:

	STDMETHODIMP	get_HighVersion		( long * plHighVersion );
	STDMETHODIMP	get_LowVersion		( long * plLowVersion );
	STDMETHODIMP	get_BuildNum		( long * plBuildNumber );
	STDMETHODIMP	get_ServiceVersion	( long * plServiceVersion );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	EnumerateInstances	( SAFEARRAY ** ppsaInstances );
	STDMETHODIMP    EnumerateInstancesVariant ( SAFEARRAY ** ppsaInstances );
	STDMETHODIMP	CreateInstance		( BSTR pstrMailRoot, long * plInstanceId );
	STDMETHODIMP	DestroyInstance		( long lInstanceId );
	STDMETHODIMP	ErrorToString		( DWORD dwErrorCode, BSTR * pstrError );
    STDMETHODIMP    Tokenize            ( BSTR strIn, BSTR * pstrOut );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	DWORD		m_dwServiceVersion;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT			QueryMetabaseInstances	( IMSAdminBase * pMetabase, SAFEARRAY ** ppsaInstances );
	HRESULT			CreateNewInstance		( IMSAdminBase * pMetabase, long * plInstanceId, BSTR pstrMailRoot );
	HRESULT			DeleteInstance			( IMSAdminBase * pMetabase, long lInstanceId );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\alias.cpp ===
// groups.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "smtpadm.h"
#include "alias.h"
#include "oleutil.h"
#include "smtpapi.h"

#include <lmapibuf.h>

#include "smtpcmn.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.Alias.1")
#define THIS_FILE_IID				IID_ISmtpAdminAlias

#define DEFAULT_NEWSGROUP_NAME			_T("")
#define DEFAULT_NEWSGROUP_DESCRIPTION	_T("")
#define DEFAULT_NEWSGROUP_MODERATOR		_T("")
#define DEFAULT_NEWSGROUP_READONLY		FALSE

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminAlias, CSmtpAdminAlias, IID_ISmtpAdminAlias)

STDMETHODIMP CSmtpAdminAlias::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdminAlias,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CSmtpAdminAlias::CSmtpAdminAlias () :
	m_lCount				( 0 ),
	m_lType					( NAME_TYPE_USER )
	// CComBSTR's are initialized to NULL by default.
{
    InitAsyncTrace ( );

    m_pSmtpNameList		= NULL;

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Alias") );
    m_iadsImpl.SetClass ( _T("IIsSmtpAlias") );
}

CSmtpAdminAlias::~CSmtpAdminAlias ()
{
	if ( m_pSmtpNameList ) {
		::NetApiBufferFree ( m_pSmtpNameList );
	}
	// All CComBSTR's are freed automatically.

    TermAsyncTrace ( );
}


//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminAlias,m_iadsImpl)


//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminAlias::get_Count ( long* plCount )
{
	return StdPropertyGet ( m_lCount, plCount );
}

	// The current alias's properties:

STDMETHODIMP CSmtpAdminAlias::get_EmailId ( BSTR * pstrEmailId )
{
	return StdPropertyGet ( m_strEmailId, pstrEmailId );
}

STDMETHODIMP CSmtpAdminAlias::put_EmailId ( BSTR strEmailId )
{
	return StdPropertyPut ( &strEmailId, strEmailId );
}

STDMETHODIMP CSmtpAdminAlias::get_Domain ( BSTR * pstrDomain )
{
	return StdPropertyGet ( m_strDomain, pstrDomain );
}

STDMETHODIMP CSmtpAdminAlias::put_Domain ( BSTR strDomain )
{
	return StdPropertyPut ( &m_strDomain, strDomain );
}

STDMETHODIMP CSmtpAdminAlias::get_Type ( long* plType )
{
	return StdPropertyGet ( m_lType, plType );
}

STDMETHODIMP CSmtpAdminAlias::put_Type ( long lType )
{
	return StdPropertyPut ( &m_lType, lType );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminAlias::Find ( 
	BSTR strWildmat,
	long cMaxResults
	)
{
	TraceFunctEnter ( "CSmtpAdminAlias::Find" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	// Free the old newsgroup list:
	if ( m_pSmtpNameList ) {
		::NetApiBufferFree ( m_pSmtpNameList );
		m_pSmtpNameList		= NULL;
	}
	m_lCount	= 0;

	dwErr = SmtpGetNameList ( 
					m_iadsImpl.QueryComputer(),  
					strWildmat, 
					NAME_TYPE_ALL,
					cMaxResults, 
					TRUE, 
					&m_pSmtpNameList,
					m_iadsImpl.QueryInstance());

	if ( dwErr != 0 ) {
		ErrorTraceX ( (LPARAM) this, "Failed to find alias: %x", dwErr );
		SetLastError( dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

	m_lCount = m_pSmtpNameList->cEntries;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminAlias::GetNth( long lIndex )
{
	_ASSERT( lIndex >=0 && lIndex < m_lCount );

	WCHAR*					pchStartOfDomain = NULL;
	WCHAR*					p = NULL;
	LPSMTP_NAME_ENTRY		pNameEntry;

	if( !m_pSmtpNameList )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_DIDNT_ENUMERATE);
	}

	if( lIndex < 0 || lIndex >= m_lCount )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_INVALID_INDEX);
	}

	//_ASSERT( CAddr::ValidateEmailName(m_pSmtpNameList[lIndex].lpszName) );

	pNameEntry = &m_pSmtpNameList->aNameEntry[lIndex];
	p = pNameEntry->lpszName;

	while( *p && *p != '@' ) p++;
	_ASSERT( *p );

	if( !*p )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_INVALID_ADDRESS);
	}

	pchStartOfDomain = p+1;

	m_lType = pNameEntry->dwType;

	m_strDomain = (LPCWSTR) pchStartOfDomain;

	*(pchStartOfDomain-1) = '\0';
	m_strEmailId = pNameEntry->lpszName; // converted to UNICODE
	*(pchStartOfDomain-1) = '@';	// turn it back

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\alias.h ===
// alias.h : Declaration of the CSmtpAdminAlias


#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminAlias : 
	public ISmtpAdminAlias,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminAlias,&CLSID_CSmtpAdminAlias>
{
public:
	CSmtpAdminAlias();
	virtual ~CSmtpAdminAlias();

BEGIN_COM_MAP(CSmtpAdminAlias)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminAlias)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminAlias) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminAlias, _T("Smtpadm.Alias.1"), _T("Smtpadm.Alias"), IDS_SMTPADMIN_ALIAS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminAlias
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminAlias
public:
    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// enumeration
	STDMETHODIMP    get_Count			( long* plCount  );


	// The current alias's properties:

	STDMETHODIMP	get_EmailId	( BSTR * pstrEmailId );
	STDMETHODIMP	put_EmailId	( BSTR strEmailId );

	STDMETHODIMP	get_Domain	( BSTR * pstrDomain );
	STDMETHODIMP	put_Domain	( BSTR strDomain );

	STDMETHODIMP	get_Type	( long * plType );
	STDMETHODIMP	put_Type	( long lType );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Find	( BSTR strWildmat,
							  long cMaxResults
							);

	STDMETHODIMP	GetNth	( long dwIndex );


	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	LONG		m_lCount;

	// current alias
	long		m_lType;

	CComBSTR	m_strEmailId;
	CComBSTR	m_strDomain;

	// Todo: add a list of alias
	LPSMTP_NAME_LIST		m_pSmtpNameList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\binding.h ===
// binding.h : Declaration of the CServerBinding & CServerBindings classes.


#include "resource.h"       // main symbols

//
//	Dependencies:
//

class CMultiSz;

//
//	A simple binding class:
//

class CBinding
{
public:
	CBinding () : 
		m_dwTcpPort ( 0 ),
		m_dwSslPort ( 0 )
		{ }

	CComBSTR	m_strIpAddress;
	long		m_dwTcpPort;
	long		m_dwSslPort;

	HRESULT	SetProperties ( BSTR strIpAddress, long dwTcpPort, long dwSslPort );
	inline HRESULT	SetProperties ( const CBinding & binding )
	{
		return SetProperties ( 
			binding.m_strIpAddress, 
			binding.m_dwTcpPort,
			binding.m_dwSslPort
			);
	}

private:
	// Don't call this:
	const CBinding & operator= ( const CBinding & );
};

/////////////////////////////////////////////////////////////////////////////
// The Binding Object

class CServerBinding : 
	public CComDualImpl<IServerBinding, &IID_IServerBinding, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CServerBindings;
	//friend class CVirtualServer;

public:
	CServerBinding();
	virtual ~CServerBinding ();
BEGIN_COM_MAP(CServerBinding)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IServerBinding)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CServerBinding) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IServerBinding
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_IpAddress	( BSTR * pstrIpAddress );
	STDMETHODIMP	put_IpAddress	( BSTR strIpAddress );

	STDMETHODIMP	get_TcpPort	( long * pdwTcpPort );
	STDMETHODIMP	put_TcpPort	( long dwTcpPort );

	STDMETHODIMP	get_SslPort	( long * plSslPort );
	STDMETHODIMP	put_SslPort	( long lSslPort );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	inline HRESULT	SetProperties	( const CBinding & binding )
	{
		return m_binding.SetProperties ( binding );
	}

	// Property variables:
	CBinding	m_binding;
};

/////////////////////////////////////////////////////////////////////////////
// The Bindings Object

class CServerBindings : 
	public CComDualImpl<IServerBindings, &IID_IServerBindings, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CServerBinding;
	//friend class CVirtualServer;

public:
	CServerBindings();
	virtual ~CServerBindings ();
BEGIN_COM_MAP(CServerBindings)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IServerBindings)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CServerBindings) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IServerBindings
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Count	( long * pdwCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Item			( long index, IServerBinding ** ppBinding );
	STDMETHODIMP	ItemDispatch	( long index, IDispatch ** ppBinding );
	STDMETHODIMP	Add				( BSTR strIpAddress, long dwTcpPort, long dwSslPort );
	STDMETHODIMP	ChangeBinding	( long index, IServerBinding * pBinding );
	STDMETHODIMP	ChangeBindingDispatch	( long index, IDispatch * pBinding );
	STDMETHODIMP	Remove			( long index );
	STDMETHODIMP	Clear			( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
	long			m_dwCount;
	CBinding *		m_rgBindings;
};

//////////////////////////////////////////////////////////////////////
//
//	Useful routines to go from IServerBindings to 
//	Metabase data types.
//
//////////////////////////////////////////////////////////////////////

HRESULT 
MDBindingsToIBindings ( 
	CMultiSz *				pmszBindings, 
	BOOL					fTcpBindings,
	IServerBindings *	    pBindings 
	);

HRESULT IBindingsToMDBindings ( 
	IServerBindings *	    pBindings,
	BOOL					fTcpBindings,
	CMultiSz *				pmszBindings
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\binding.cpp ===
// binding.cpp : Implementation of CServerBinding & CServerBindings.

#include "stdafx.h"
#include "smtpadm.h"
#include "cmultisz.h"
#include "binding.h"
#include "oleutil.h"
#include "smtpcmn.h"


HRESULT	CBinding::SetProperties ( 
	BSTR	strIpAddress, 
	long	dwTcpPort,
	long	dwSslPort
	)
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	m_strIpAddress	= strIpAddress;
	m_dwTcpPort		= dwTcpPort;
	m_dwSslPort		= dwSslPort;

	if ( !m_strIpAddress ) {
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_IServerBinding

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CServerBinding::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IServerBinding,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CServerBinding::CServerBinding ()
	// CComBSTR's are initialized to NULL by default.
{
}

CServerBinding::~CServerBinding ()
{
	// All CComBSTR's are freed automatically.
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CServerBinding::get_IpAddress ( BSTR * pstrIpAddress )
{
	return StdPropertyGet ( m_binding.m_strIpAddress, pstrIpAddress );
}

STDMETHODIMP CServerBinding::put_IpAddress ( BSTR strIpAddress )
{
	return StdPropertyPut ( &m_binding.m_strIpAddress, strIpAddress );
}

STDMETHODIMP CServerBinding::get_TcpPort ( long * pdwTcpPort )
{
	return StdPropertyGet ( m_binding.m_dwTcpPort, pdwTcpPort );
}

STDMETHODIMP CServerBinding::put_TcpPort ( long dwTcpPort )
{
	return StdPropertyPut ( &m_binding.m_dwTcpPort, dwTcpPort );
}

STDMETHODIMP CServerBinding::get_SslPort ( long * plSslPort )
{
	return StdPropertyGet ( m_binding.m_dwSslPort, plSslPort );
}

STDMETHODIMP CServerBinding::put_SslPort ( long lSslPort )
{
	return StdPropertyPut ( &m_binding.m_dwSslPort, lSslPort );
}

//
// Must define THIS_FILE_* macros to use SmtpCreateException()
//

#undef THIS_FILE_HELP_CONTEXT
#undef THIS_FILE_PROG_ID
#undef THIS_FILE_IID

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("smtpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_IServerBindings

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CServerBindings::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IServerBindings,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CServerBindings::CServerBindings () :
	m_dwCount			( 0 ),
	m_rgBindings		( NULL )
	// CComBSTR's are initialized to NULL by default.
{
}

CServerBindings::~CServerBindings ()
{
	// All CComBSTR's are freed automatically.

	delete [] m_rgBindings;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CServerBindings::get_Count ( long * pdwCount )
{
	return StdPropertyGet ( m_dwCount, pdwCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CServerBindings::Item ( 
	long index, 
	IServerBinding ** ppBinding 
	)
{
	TraceFunctEnter ( "CServerBindings::Item" );

	_ASSERT ( IS_VALID_OUT_PARAM ( ppBinding ) );

	*ppBinding = NULL;

	HRESULT								hr			= NOERROR;
	CComObject<CServerBinding> *	pBinding	= NULL;

	if ( index < 0 || index >= m_dwCount ) {
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = CComObject<CServerBinding>::CreateInstance ( &pBinding );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( pBinding );
	hr = pBinding->SetProperties ( m_rgBindings[index] );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->QueryInterface ( IID_IServerBinding, (void **) ppBinding );
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}

	if ( FAILED(hr) ) {
		delete pBinding;
	}

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CServerBindings::ItemDispatch ( long index, IDispatch ** ppDispatch )
{
	HRESULT						hr;
	CComPtr<IServerBinding>	pBinding;

	hr = Item ( index, &pBinding );
	BAIL_ON_FAILURE ( hr );

	hr = pBinding->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CServerBindings::Add ( 
	BSTR strIpAddress, 
	long dwTcpPort,
	long dwSslPort
	)
{
	TraceFunctEnter ( "CServerBindings::Add" );

	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	HRESULT		hr	= NOERROR;
	CBinding *	rgNewBindings	= NULL;
	long		i;

	//
	//	Validate the new binding:
	//

	//
	//	See if we can merge this binding with an existing one:
	//
	if ( dwTcpPort == 0 || dwSslPort == 0 ) {
		for ( i = 0; i < m_dwCount; i++ ) {

			if ( (dwTcpPort == 0 && m_rgBindings[i].m_dwSslPort == 0) ||
				 (dwSslPort == 0 && m_rgBindings[i].m_dwTcpPort == 0) ) {

				if ( lstrcmpi ( m_rgBindings[i].m_strIpAddress, strIpAddress ) == 0 ) {

					if ( m_rgBindings[i].m_dwSslPort == 0 ) {
						m_rgBindings[i].m_dwSslPort = dwSslPort;
					}
					else {
						m_rgBindings[i].m_dwTcpPort = dwTcpPort;
					}
					hr = NOERROR;
					goto Exit;
				}
			}
		}
	}

	//	Allocate the new binding array:
	rgNewBindings	= new CBinding [ m_dwCount + 1 ];
	if ( !rgNewBindings ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	//	Copy the old bindings to the new array:
	for ( i = 0; i < m_dwCount; i++ ) {
		hr = rgNewBindings[i].SetProperties ( m_rgBindings[i] );
		if ( FAILED (hr) ) {
			goto Exit;
		}
	}

	//	Add the new binding to the end of the array:
	hr = rgNewBindings[m_dwCount].SetProperties ( strIpAddress, dwTcpPort, dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	delete [] m_rgBindings;
	m_rgBindings = rgNewBindings;
	rgNewBindings = NULL;
	m_dwCount++;

Exit:
	if (FAILED(hr) && rgNewBindings)
		delete [] rgNewBindings;

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CServerBindings::ChangeBinding ( 
	long index, 
	IServerBinding * pBinding 
	)
{
	TraceFunctEnter ( "CServerBindings::ChangeBinding" );

	HRESULT		hr	= NOERROR;

	CComBSTR	strIpAddress;
	long		dwTcpPort;
	long		dwSslPort;

	if ( index < 0 || index >= m_dwCount ) {
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = pBinding->get_IpAddress ( &strIpAddress );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->get_TcpPort ( &dwTcpPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->get_SslPort ( &dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_rgBindings[index].SetProperties ( strIpAddress, dwTcpPort, dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CServerBindings::ChangeBindingDispatch ( long index, IDispatch * pDispatch )
{
	HRESULT						hr;
	CComPtr<IServerBinding>	pBinding;

	hr = pDispatch->QueryInterface ( IID_IServerBinding, (void **) &pBinding );
	BAIL_ON_FAILURE ( hr );

	hr = ChangeBinding ( index, pBinding );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CServerBindings::Remove ( long index )
{
	TraceFunctEnter ( "CServerBindings::Remove" );

	HRESULT		hr	= NOERROR;
	CBinding	temp;
	long		cPositionsToSlide;

	if ( index < 0 || index >= m_dwCount ) {
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	//	Slide the array down by one position:

	_ASSERT ( m_rgBindings );

	cPositionsToSlide	= (m_dwCount - 1) - index;

	_ASSERT ( cPositionsToSlide < m_dwCount );

	if ( cPositionsToSlide > 0 ) {
		// Save the deleted binding in temp:
		CopyMemory ( &temp, &m_rgBindings[index], sizeof ( CBinding ) );

		// Move the array down one:
		MoveMemory ( &m_rgBindings[index], &m_rgBindings[index + 1], sizeof ( CBinding ) * cPositionsToSlide );

		// Put the deleted binding on the end (so it gets destructed):
		CopyMemory ( &m_rgBindings[m_dwCount - 1], &temp, sizeof ( CBinding ) );

		// Zero out the temp binding:
		ZeroMemory ( &temp, sizeof ( CBinding ) );
	}

	m_dwCount--;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CServerBindings::Clear ( )
{
	delete [] m_rgBindings;
	m_rgBindings 	= NULL;
	m_dwCount		= 0;

	return NOERROR;
}

//////////////////////////////////////////////////////////////////////
//
//	Useful routines to go from IServerBindings to 
//	Metabase data types.
//
//////////////////////////////////////////////////////////////////////

static DWORD CountBindingChars ( LPCWSTR strIpAddress, DWORD dwPort )
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	DWORD		cchResult	= 0;
	WCHAR		wszPort [256];

	wsprintf ( wszPort, _T("%u"), dwPort );

	cchResult += lstrlen ( strIpAddress );	// <IPADDRESS>
	cchResult += 1;							// :
	cchResult += lstrlen ( wszPort );		// <PORT>
	cchResult += 1;							// :
//	cchResult += lstrlen ( strPathHeader );	// <PATHHEADER>

	cchResult += 1;		// For the terminating NULL

	return cchResult;
}

static void ToBindingString ( LPCWSTR strIpAddress, DWORD dwPort, LPWSTR wszBinding )
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );
	_ASSERT ( dwPort != 0 );

	_ASSERT ( !IsBadWritePtr ( wszBinding, CountBindingChars ( strIpAddress, dwPort ) ) );

	wsprintf ( wszBinding, _T("%s:%u:"), strIpAddress, dwPort );
}

static HRESULT FromBindingString ( LPCWSTR wszBinding, LPWSTR wszIpAddressOut, DWORD * pdwPort )
{
	HRESULT	hr	= NOERROR;

	LPWSTR	pchFirstColon;
	LPWSTR	pchSecondColon;

	WCHAR	wszIpAddress	[ 256 ];
	WCHAR	wszPort			[ 256 ];
	long	dwPort;

	LPWSTR	pchColon;

	wszIpAddress[0]	= NULL;
	wszPort[0]		= NULL;

	pchFirstColon = wcschr ( wszBinding, _T(':') );
	if ( pchFirstColon ) {
		pchSecondColon = wcschr ( pchFirstColon + 1, _T(':') );
	}

	if ( !pchFirstColon || !pchSecondColon ) {
		hr = E_FAIL;
		goto Exit;
	}

	lstrcpyn ( wszIpAddress, wszBinding, 250 );
	lstrcpyn ( wszPort, pchFirstColon + 1, 250 );

	// Get the Port:
	dwPort	= _wtoi ( wszPort );

	// Cutoff the IpAddress at the colon:
	pchColon = wcschr ( wszIpAddress, _T(':') );
	if ( pchColon ) {
		*pchColon = NULL;
	}

	lstrcpy ( wszIpAddressOut, wszIpAddress );
	*pdwPort		= dwPort;

Exit:
	return hr;
}

HRESULT 
MDBindingsToIBindings ( 
	CMultiSz *				pmsz, 
	BOOL					fTcpBindings,
	IServerBindings *	pBindings 
	)
{
	HRESULT		hr	= NOERROR;
	DWORD		cBindings;
	DWORD		i;
	LPCWSTR		pchCurrent;
	CBinding	binding;

	cBindings = pmsz->Count ();

	for ( 
			i = 0, pchCurrent = *pmsz; 
			i < cBindings; 
			i++, pchCurrent += lstrlen ( pchCurrent ) + 1 
		) {

		WCHAR	wszIpAddress[512];
		DWORD	dwPort;

		hr = FromBindingString ( pchCurrent, wszIpAddress, &dwPort );
		if ( FAILED(hr) ) {
			// Skip bad binding strings:
			hr = NOERROR;
			continue;
		}

		if ( fTcpBindings ) {
			hr = pBindings->Add ( wszIpAddress, dwPort, 0 );
		}
		else {
			hr = pBindings->Add ( wszIpAddress, 0, dwPort );
		}
		BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

HRESULT IBindingsToMDBindings ( 
	IServerBindings *	pBindings,
	BOOL					fTcpBindings,
	CMultiSz *				pmsz
	)
{
	HRESULT		hr	= NOERROR;
	long		cBindings;
	long		i;
	DWORD		cbCount		= 0;
	LPWSTR		wszBindings	= NULL;

	// Count the characters of the regular bindings list:
	cbCount	= 0;
	pBindings->get_Count ( &cBindings );

	for ( i = 0; i < cBindings; i++ ) {
		CComPtr<IServerBinding>	pBinding;
		CComBSTR					strIpAddress;
		long						lTcpPort;
		long						lSslPort;

		hr = pBindings->Item ( i, &pBinding );
		BAIL_ON_FAILURE(hr);

		pBinding->get_IpAddress	( &strIpAddress );
		pBinding->get_TcpPort	( &lTcpPort );
		pBinding->get_SslPort	( &lSslPort );

		if ( fTcpBindings ) {
			if ( lTcpPort != 0 ) {
				cbCount += CountBindingChars ( strIpAddress, lTcpPort );
			}
		}
		else {
			if ( lSslPort != 0 ) {
				cbCount += CountBindingChars ( strIpAddress, lSslPort );
			}
		}
	}

	if ( cbCount == 0 ) {
		cbCount		= 2;
		wszBindings	= new WCHAR [ cbCount ];

		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		wszBindings[0]	= NULL;
		wszBindings[1]	= NULL;
	}
	else {
		cbCount++;	// For double null terminator

		wszBindings	= new WCHAR [ cbCount ];
		if ( !wszBindings ) {
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		LPWSTR		pchCurrent	= wszBindings;

		for ( i = 0; i < cBindings; i++ ) {
			CComPtr<IServerBinding>	pBinding;
			CComBSTR					strIpAddress;
			long						lTcpPort;
			long						lSslPort;

			hr = pBindings->Item ( i, &pBinding );
			BAIL_ON_FAILURE(hr);

			pBinding->get_IpAddress	( &strIpAddress );
			pBinding->get_TcpPort	( &lTcpPort );
			pBinding->get_SslPort	( &lSslPort );

			if ( fTcpBindings ) {
				if ( lTcpPort != 0 ) {
					ToBindingString ( strIpAddress, lTcpPort, pchCurrent );
					pchCurrent += lstrlen ( pchCurrent ) + 1;
				}
			}
			else {
				if ( lSslPort != 0 ) {
					ToBindingString ( strIpAddress, lSslPort, pchCurrent );
					pchCurrent += lstrlen ( pchCurrent ) + 1;
				}
			}
		}

		*pchCurrent = NULL;
	}

	_ASSERT ( wszBindings[cbCount - 1] == NULL );
	_ASSERT ( wszBindings[cbCount - 2] == NULL );

	pmsz->Attach ( wszBindings );

Exit:
	return hr;
}

#if 0
	
DWORD CBinding::SizeInChars ( )
{
	DWORD		cchResult	= 0;
	WCHAR		wszTcpPort [256];

	wsprintf ( wszTcpPort, _T("%d"), m_dwTcpPort );

	cchResult += lstrlen ( m_strIpAddress );	// <IPADDRESS>
	cchResult += 1;								// :
	cchResult += lstrlen ( wszTcpPort );		// <TCPPORT>
	cchResult += 1;								// :
//	cchResult += lstrlen ( m_strPathHeader );	// <PATHHEADER>

	return cchResult;
}

void CBinding::ToString	( LPWSTR wszBinding )
{
	wsprintf ( wszBinding, _T("%s:%d:"), m_strIpAddress, m_dwTcpPort );
}

HRESULT CBinding::FromString ( LPCWSTR wszBinding )
{
	HRESULT	hr	= NOERROR;

	LPWSTR	pchFirstColon;
	LPWSTR	pchSecondColon;

	WCHAR	wszIpAddress 	[ 256 ];
	WCHAR	wszTcpPort		[ 256 ];
	long	dwTcpPort;

	LPWSTR	pchColon;

	wszIpAddress[0]		= NULL;
	wszTcpPort[0]		= NULL;

	pchFirstColon = wcschr ( wszBinding, _T(':') );
	if ( pchFirstColon ) {
		pchSecondColon = wcschr ( pchFirstColon + 1, _T(':') );
	}

	if ( !pchFirstColon || !pchSecondColon ) {
		hr = E_FAIL;
		goto Exit;
	}

	lstrcpyn ( wszIpAddress, wszBinding, 250 );
	lstrcpyn ( wszTcpPort, pchFirstColon + 1, 250 );

	// Get the TcpPort:
	dwTcpPort = _wtoi ( wszTcpPort );

	// Cutoff the IpAddress at the colon:
	pchColon = wcschr ( wszIpAddress, _T(':') );
	if ( pchColon ) {
		*pchColon = NULL;
	}

	m_strIpAddress	= wszIpAddress;
	m_dwTcpPort		= dwTcpPort;

	if ( !m_strIpAddress ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	return hr;
}

HRESULT CServerBindings::FromMultiSz ( CMultiSz * pmsz )
{
	HRESULT		hr;
	DWORD		cBindings;
	DWORD		i;
	LPCWSTR		pchCurrent;
	CBinding	binding;

	hr = Clear ();
	_ASSERT ( SUCCEEDED(hr) );

	cBindings = pmsz->Count ();

	for ( 
			i = 0, pchCurrent = *pmsz; 
			i < cBindings; 
			i++, pchCurrent += lstrlen ( pchCurrent ) + 1 
		) {

		hr = binding.FromString ( pchCurrent );
		if ( FAILED(hr) ) {
			if ( hr == E_FAIL ) {
				// Skip the bad binding strings.
				continue;
			}
			else {
				goto Exit;
			}
		}

		hr = Add ( binding.m_strIpAddress, binding.m_dwTcpPort );
		if ( FAILED(hr) ) {
			goto Exit;
		}
	}

Exit:
	return hr;
}

HRESULT CServerBindings::ToMultiSz ( CMultiSz * pmsz )
{
	HRESULT	hr	= NOERROR;
	DWORD	cchSize;
	long	i;
	LPWSTR	wszBindings;
	LPWSTR	pchCurrent;

	// Special case - the empty binding list:
	if ( m_dwCount == 0 ) {
		cchSize		= 2;
		wszBindings	= new WCHAR [ cchSize ];

		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		wszBindings[0]	= NULL;
		wszBindings[1]	= NULL;
	}
	else {

		cchSize = 0;

		for ( i = 0; i < m_dwCount; i++ ) {
			cchSize += m_rgBindings[i].SizeInChars ( ) + 1;
		}
		// Add the size of the final terminator:
		cchSize += 1;

		wszBindings = new WCHAR [ cchSize ];
		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		for ( i = 0, pchCurrent = wszBindings; i < m_dwCount; i++ ) {

			m_rgBindings[i].ToString ( pchCurrent );
			pchCurrent += lstrlen ( pchCurrent ) + 1;
		}

		// Add the final NULL terminator:
		*pchCurrent = NULL;
	}

	_ASSERT ( wszBindings[cchSize - 1] == NULL );
	_ASSERT ( wszBindings[cchSize - 2] == NULL );

	pmsz->Attach ( wszBindings );

	_ASSERT ( pmsz->Count () == (DWORD) m_dwCount );

Exit:
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\dl.cpp ===
// dl.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "smtpadm.h"
#include "dl.h"
#include "oleutil.h"
#include "smtpapi.h"

#include <lmapibuf.h>

#include "smtpcmn.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.DL.1")
#define THIS_FILE_IID				IID_ISmtpAdminDL

#define DEFAULT_NEWSGROUP_NAME			_T("")
#define DEFAULT_NEWSGROUP_DESCRIPTION	_T("")
#define DEFAULT_NEWSGROUP_MODERATOR		_T("")
#define DEFAULT_NEWSGROUP_READONLY		FALSE

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminDL, CSmtpAdminDL, IID_ISmtpAdminDL)

STDMETHODIMP CSmtpAdminDL::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdminDL,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CSmtpAdminDL::CSmtpAdminDL ()
	// CComBSTR's are initialized to NULL by default.
{
	m_pSmtpNameList = NULL;
	m_lType			= NAME_TYPE_LIST_NORMAL;
	m_lCount		= 0;
	m_lMemberType	= NAME_TYPE_USER;

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("DL") );
    m_iadsImpl.SetClass ( _T("IIsSmtpDL") );
}

CSmtpAdminDL::~CSmtpAdminDL ()
{
	if ( m_pSmtpNameList ) {
		::NetApiBufferFree ( m_pSmtpNameList );
		m_pSmtpNameList		= NULL;
	}
	// All CComBSTR's are freed automatically.
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminDL,m_iadsImpl)


// DL property

STDMETHODIMP CSmtpAdminDL::get_DLName ( BSTR * pstrDLName )
{
	return StdPropertyGet ( m_strDLName, pstrDLName );
}

STDMETHODIMP CSmtpAdminDL::put_DLName ( BSTR strDLName )
{
	return StdPropertyPut ( &m_strDLName, strDLName );
}

STDMETHODIMP CSmtpAdminDL::get_Domain ( BSTR * pstrDomain )
{
	return StdPropertyGet ( m_strDomain, pstrDomain );
}

STDMETHODIMP CSmtpAdminDL::put_Domain ( BSTR strDomain )
{
	return StdPropertyPut ( &m_strDomain, strDomain );
}


STDMETHODIMP CSmtpAdminDL::get_Type ( long * plType )
{
	return StdPropertyGet ( m_lType, plType );
}

STDMETHODIMP CSmtpAdminDL::put_Type ( long lType )
{
	return StdPropertyPut ( &m_lType, lType );
}


STDMETHODIMP CSmtpAdminDL::get_MemberName ( BSTR * pstrMemberName )
{
	return StdPropertyGet ( m_strMemberName, pstrMemberName );
}

STDMETHODIMP CSmtpAdminDL::put_MemberName ( BSTR strMemberName )
{
	return StdPropertyPut ( &m_strMemberName, strMemberName );
}


STDMETHODIMP CSmtpAdminDL::get_MemberDomain ( BSTR * pstrMemberDomain )
{
	return StdPropertyGet ( m_strMemberDomain, pstrMemberDomain );
}

STDMETHODIMP CSmtpAdminDL::put_MemberDomain ( BSTR strMemberDomain )
{
	return StdPropertyPut ( &m_strMemberDomain, strMemberDomain );
}


STDMETHODIMP CSmtpAdminDL::get_MemberType( long * plMemberType )
{
	return StdPropertyGet ( m_lMemberType, plMemberType );
}


// enumeration
STDMETHODIMP CSmtpAdminDL::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_lCount, plCount );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////


STDMETHODIMP CSmtpAdminDL::Create ( )
{
	TraceFunctEnter ( "CSmtpAdminDL::Create" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	WCHAR			szFullName[512];
	wsprintfW( szFullName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );

	dwErr = SmtpCreateDistList( 
				m_iadsImpl.QueryComputer(),
				szFullName,
				m_lType,
				m_iadsImpl.QueryInstance() );

	if ( dwErr != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to create DL: %x", dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminDL::Delete ( )
{
	TraceFunctEnter ( "CSmtpAdminDL::Delete" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	WCHAR			szFullName[512];
	wsprintfW( szFullName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );

	dwErr = SmtpDeleteDistList( 
				m_iadsImpl.QueryComputer(),
				szFullName,
				m_iadsImpl.QueryInstance() );

	if ( dwErr != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to delete DL: %x", dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}



STDMETHODIMP CSmtpAdminDL::AddMember ( )
{
	TraceFunctEnter ( "CSmtpAdminDL::AddMember" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain || !m_strMemberName || !m_strMemberDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	WCHAR			szFullDLName[512];
	WCHAR			szFullMemName[512];

	wsprintfW( szFullDLName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );
	wsprintfW( szFullMemName, L"%s@%s", (LPWSTR) m_strMemberName, (LPWSTR) m_strMemberDomain );

	dwErr = SmtpCreateDistListMember( 
				m_iadsImpl.QueryComputer(),
				szFullDLName,
				szFullMemName,
				m_iadsImpl.QueryInstance() );

	if ( dwErr != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to add DL member: %x", dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminDL::RemoveMember ( )
{
	TraceFunctEnter ( "CSmtpAdminDL::RemoveMember" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain || !m_strMemberName || !m_strMemberDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	WCHAR			szFullDLName[512];
	WCHAR			szFullMemName[512];

	wsprintfW( szFullDLName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );
	wsprintfW( szFullMemName, L"%s@%s", (LPWSTR) m_strMemberName, (LPWSTR) m_strMemberDomain );

	dwErr = SmtpDeleteDistListMember( 
				m_iadsImpl.QueryComputer(),
				szFullDLName,
				szFullMemName,
				m_iadsImpl.QueryInstance() );

	if ( dwErr != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to remove DL member: %x", dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}


STDMETHODIMP CSmtpAdminDL::FindMembers(	BSTR strWildmat,
										long cMaxResults
										)
{
	TraceFunctEnter ( "CSmtpAdminDL::FindMembers" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	// Free the old name list:
	if ( m_pSmtpNameList ) {
		::NetApiBufferFree ( m_pSmtpNameList );
		m_pSmtpNameList		= NULL;
	}
	m_lCount	= 0;

	WCHAR			szFullDLName[512];
	wsprintfW( szFullDLName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );

	dwErr = SmtpGetNameListFromList ( 
					m_iadsImpl.QueryComputer(),  
					szFullDLName,
					strWildmat, 
					NAME_TYPE_ALL,
					cMaxResults, 
					TRUE, 
					&m_pSmtpNameList,
					m_iadsImpl.QueryInstance());

	if ( dwErr != 0 ) {
		ErrorTraceX ( (LPARAM) this, "Failed to find alias: %x", dwErr );
		SetLastError( dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

	m_lCount = m_pSmtpNameList->cEntries;

Exit:
	TraceFunctLeave ();
	return hr;
}


STDMETHODIMP CSmtpAdminDL::GetNthMember	( long lIndex )
{
	TraceFunctEnter ( "CSmtpAdminDL::GetNthMember" );

	WCHAR*					pchStartOfDomain = NULL;
	WCHAR*					p = NULL;
	LPSMTP_NAME_ENTRY		pNameEntry;

	if( !m_pSmtpNameList )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_DIDNT_ENUMERATE);
	}

	if( lIndex < 0 || lIndex >= m_lCount )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_INVALID_INDEX);
	}

	//_ASSERT( CAddr::ValidateEmailName(m_pSmtpNameList[lIndex].lpszName) );

	pNameEntry = &m_pSmtpNameList->aNameEntry[lIndex];
	p = pNameEntry->lpszName;

	while( *p && *p != '@' ) p++;
	_ASSERT( *p );

	if( !*p )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_INVALID_ADDRESS);
	}

	pchStartOfDomain = p+1;

	m_lMemberType = pNameEntry->dwType;

	m_strMemberDomain = (LPCWSTR) pchStartOfDomain;

	*(pchStartOfDomain-1) = '\0';
	m_strMemberName = pNameEntry->lpszName; // converted to UNICODE
	*(pchStartOfDomain-1) = '@';	// turn it back

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\dl.h ===
// dl.h : Declaration of the CSmtpAdminDL


#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminDL : 
	public ISmtpAdminDL,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminDL,&CLSID_CSmtpAdminDL>
{
public:
	CSmtpAdminDL();
	virtual ~CSmtpAdminDL();
BEGIN_COM_MAP(CSmtpAdminDL)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminDL)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminDL) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminDL, _T("Smtpadm.DL.1"), _T("Smtpadm.DL"), IDS_SMTPADMIN_DL_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminDL
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminDL
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:

	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// DL Properties:

	STDMETHODIMP	get_DLName		( BSTR * pstrDLName );
	STDMETHODIMP	put_DLName		( BSTR strDLName );

	STDMETHODIMP	get_Domain		( BSTR * pstrDomain );
	STDMETHODIMP	put_Domain		( BSTR strDomain );

	STDMETHODIMP	get_Type		( long * plType );
	STDMETHODIMP	put_Type		( long lType  );

	STDMETHODIMP	get_MemberName		( BSTR * pstrMemberName );
	STDMETHODIMP	put_MemberName		( BSTR strMemberName );

	STDMETHODIMP	get_MemberDomain		( BSTR * pstrMemberDomain );
	STDMETHODIMP	put_MemberDomain		( BSTR strMemberDomain );

	STDMETHODIMP	get_MemberType		( long * plMemberType );

	// enumeration
	STDMETHODIMP	get_Count		( long* plCount  );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Create			( );

	STDMETHODIMP	Delete			( );

	STDMETHODIMP	AddMember		( );

	STDMETHODIMP	RemoveMember	( );

	STDMETHODIMP	FindMembers		(	BSTR strWildmat,
										long cMaxResults
										);

	STDMETHODIMP	GetNthMember	( long lIndex );


	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	CComBSTR	m_strDLName;
	CComBSTR	m_strDomain;
	long		m_lType;

	CComBSTR	m_strMemberName;
	CComBSTR	m_strMemberDomain;
	long		m_lMemberType;

	LONG		m_lCount;

	// list of members
	LPSMTP_NAME_LIST		m_pSmtpNameList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\metafact.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metafact.h

Abstract:

	Defines the CMetabaseFactory class.  This class deals with creating
	metabase objects, on either the local machine or a remote machine.

	The class provides a simple caching scheme where it will keep the name of
	the server the object was created on.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAFACT_INCLUDED_
#define _METAFACT_INCLUDED_

class CMetabaseFactory
{
public:
	CMetabaseFactory ();
	~CMetabaseFactory ();

	HRESULT	GetMetabaseObject	( LPCWSTR wszServer, IMSAdminBase ** ppMetabase );
	// You must call (*ppMetabase)->Release() after using the metabase object.

private:
	BOOL	IsCachedMetabase	( LPCWSTR wszServer );
	BOOL	SetServerName		( LPCWSTR wszServer );
	void	DestroyMetabaseObject	( );
	
	LPWSTR		m_wszServerName;
	IMSAdminBase *	m_pMetabase;
};

#endif // _METAFACT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\domain.cpp ===
// domain.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "iadm.h"
#include "iiscnfg.h"

#include "smtpadm.h"
#include "domain.h"
#include "oleutil.h"
#include "metautil.h"

#include "listmacr.h"
#include <lmapibuf.h>

#include "smtpcmn.h"
#include "smtpprop.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.Domain.1")
#define THIS_FILE_IID               IID_ISmtpAdminDomain


#define UNASSIGNED_DOMAIN_ID            ( DWORD( -1 ) )

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminDomain, CSmtpAdminDomain, IID_ISmtpAdminDomain)

STDMETHODIMP CSmtpAdminDomain::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_ISmtpAdminDomain,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

CSmtpAdminDomain::CSmtpAdminDomain () 
    // CComBSTR's are initialized to NULL by default.
{
    m_lCount        = 0;
    m_dwActionType    = SMTP_DELIVER;
    m_fAllowEtrn    = FALSE;
    m_dwDomainId    = UNASSIGNED_DOMAIN_ID;

    m_dwMaxDomainId    = 0;
    m_fEnumerated    = FALSE;

    m_pCurrentDomainEntry    = NULL;
    m_pDefaultDomainEntry    = NULL;

    InitializeListHead( &m_list );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Domain") );
    m_iadsImpl.SetClass ( _T("IIsSmtpDomain") );
}

CSmtpAdminDomain::~CSmtpAdminDomain ()
{
    EmptyList();
    // All CComBSTR's are freed automatically.
}

void CSmtpAdminDomain::EmptyList()
{
    PLIST_ENTRY            pHead;
    PLIST_ENTRY            pEntry;
    DomainEntry*        pDomainEntry;

    for( pHead=&m_list, pEntry=pHead->Flink; pEntry!=pHead; pEntry=pHead->Flink )
    {
        pDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
        RemoveEntryList(pEntry);
        delete pDomainEntry;
    }
}


//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminDomain,m_iadsImpl)


//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// enumeration

STDMETHODIMP CSmtpAdminDomain::get_Count ( long * plCount )
{
    return StdPropertyGet ( m_lCount, plCount );
}


// current Domain Properties:

STDMETHODIMP CSmtpAdminDomain::get_DomainName ( BSTR * pstrDomainName )
{
    return StdPropertyGet ( m_strDomainName, pstrDomainName );
}

STDMETHODIMP CSmtpAdminDomain::put_DomainName ( BSTR strDomainName )
{
    return StdPropertyPut ( &m_strDomainName, strDomainName );
}


STDMETHODIMP CSmtpAdminDomain::get_ActionType( long * plActionType )
{
    return StdPropertyGet ( m_dwActionType, plActionType );
}

STDMETHODIMP CSmtpAdminDomain::put_ActionType( long lActionType )
{
    return StdPropertyPut ( &m_dwActionType, lActionType );
}


    // drop IsDefault!!
STDMETHODIMP CSmtpAdminDomain::get_IsDefault ( BOOL * pfIsDefault )
{
    *pfIsDefault = m_dwActionType == SMTP_DEFAULT;
    return NOERROR;
}

STDMETHODIMP CSmtpAdminDomain::put_IsDefault ( BOOL fIsDefault )
{
    return E_NOTIMPL;
}


STDMETHODIMP CSmtpAdminDomain::get_IsLocal ( BOOL * pfIsLocal )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmtpAdminDomain::put_IsLocal ( BOOL fIsLocal )
{
    return E_NOTIMPL;
}

    // if local

STDMETHODIMP CSmtpAdminDomain::get_LDAPServer ( BSTR * pstrLDAPServer )
{
    return E_NOTIMPL;
    //return StdPropertyGet ( m_strLDAPServer, pstrLDAPServer );
}

STDMETHODIMP CSmtpAdminDomain::put_LDAPServer ( BSTR strLDAPServer )
{
    return E_NOTIMPL;
    //return StdPropertyPut ( &m_strLDAPServer, strLDAPServer );
}


STDMETHODIMP CSmtpAdminDomain::get_Account ( BSTR * pstrAccount )
{
    return E_NOTIMPL;
    //return StdPropertyGet ( m_strAccount, pstrAccount );
}

STDMETHODIMP CSmtpAdminDomain::put_Account ( BSTR strAccount )
{
    return E_NOTIMPL;
    //return StdPropertyPut ( &m_strAccount, strAccount );
}


STDMETHODIMP CSmtpAdminDomain::get_Password ( BSTR * pstrPassword )
{
    return E_NOTIMPL;
    //return StdPropertyGet ( m_strPassword, pstrPassword );
}

STDMETHODIMP CSmtpAdminDomain::put_Password ( BSTR strPassword )
{
    return E_NOTIMPL;
    //return StdPropertyPut ( &m_strPassword, strPassword );
}


STDMETHODIMP CSmtpAdminDomain::get_LDAPContainer ( BSTR * pstrLDAPContainer )
{
    return E_NOTIMPL;
    //return StdPropertyGet ( m_strLDAPContainer, pstrLDAPContainer );
}

STDMETHODIMP CSmtpAdminDomain::put_LDAPContainer ( BSTR strLDAPContainer )
{
    return E_NOTIMPL;
    //return StdPropertyPut ( &m_strLDAPContainer, strLDAPContainer );
}

    // if remote

STDMETHODIMP CSmtpAdminDomain::get_UseSSL ( BOOL * pfUseSSL )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmtpAdminDomain::put_UseSSL ( BOOL fUseSSL )
{
    return E_NOTIMPL;
}


STDMETHODIMP CSmtpAdminDomain::get_EnableETRN ( BOOL * pfEnableETRN )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmtpAdminDomain::put_EnableETRN ( BOOL fEnableETRN )
{
    return E_NOTIMPL;
}


STDMETHODIMP CSmtpAdminDomain::get_DropDir ( BSTR * pstrDropDir )
{
    return StdPropertyGet ( m_strActionString, pstrDropDir );
}

STDMETHODIMP CSmtpAdminDomain::put_DropDir ( BSTR strDropDir )
{
    return StdPropertyPut ( &m_strActionString, strDropDir );
}


STDMETHODIMP CSmtpAdminDomain::get_RoutingDomain ( BSTR * pstrRoutingDomain )
{
    return StdPropertyGet ( m_strActionString, pstrRoutingDomain );
}

STDMETHODIMP CSmtpAdminDomain::put_RoutingDomain ( BSTR strRoutingDomain )
{
    return StdPropertyPut ( &m_strActionString, strRoutingDomain );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminDomain::Default ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Default" );

    m_dwActionType    = SMTP_DELIVER;
    m_fAllowEtrn    = FALSE;
    m_dwDomainId    = UNASSIGNED_DOMAIN_ID;

    m_strDomainName.Empty();
    m_strActionString.Empty();

    m_pCurrentDomainEntry    = NULL;

    TraceFunctLeave ();
    return NOERROR;
}

STDMETHODIMP CSmtpAdminDomain::Add ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Add" );

    HRESULT            hr        = NOERROR;
    DomainEntry*    pOldDef = NULL;

    DomainEntry*    pNewDomain = new DomainEntry;
    if( !pNewDomain )
    {
        ErrorTrace ( (LPARAM) this, "Out of memory" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = GetFromMetabase();
    if( FAILED(hr) )
    {
        goto Exit;
    }

    lstrcpyW( pNewDomain-> m_strDomainName, (LPCWSTR)m_strDomainName );
    lstrcpyW( pNewDomain-> m_strActionString, (LPCWSTR)m_strActionString );
    pNewDomain-> m_dwActionType = m_dwActionType;
    pNewDomain-> m_fAllowEtrn = m_fAllowEtrn;

    // deal with default domain
    if( m_dwActionType == SMTP_DEFAULT )
    {
        pOldDef = m_pDefaultDomainEntry;
        pOldDef-> m_dwActionType = pOldDef->m_strActionString[0] ? SMTP_DROP : SMTP_DELIVER;

        InsertHeadList( &m_list, &pNewDomain->list );
        m_pDefaultDomainEntry = pNewDomain;
    }
    else
    {
        InsertTailList( &m_list, &pNewDomain->list );
    }

    hr = SaveToMetabase();
    if( FAILED(hr) )
    {
        RemoveEntryList( &pNewDomain->list );
        ErrorTrace ( (LPARAM) this, "Failed to remove domain: %x", hr );
        delete pNewDomain;
        goto Exit;
    }

    m_pCurrentDomainEntry = pNewDomain;
    m_lCount++;

Exit:
    TraceFunctLeave ();
    return hr;
}



STDMETHODIMP CSmtpAdminDomain::Remove ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Remove" );

    HRESULT            hr        = NOERROR;

    // need to call get() first
    _ASSERT( m_pCurrentDomainEntry );
    _ASSERT( !lstrcmpiW( m_strDomainName, m_pCurrentDomainEntry->m_strDomainName ) );

    if( !m_pCurrentDomainEntry || 
        lstrcmpiW( m_strDomainName, m_pCurrentDomainEntry->m_strDomainName ) )
    {
        hr = SmtpCreateException (IDS_SMTPEXCEPTION_DIDNT_CALL_GET);
        goto Exit;
    }

    //Can't remove default domain
    if( m_pCurrentDomainEntry == m_pDefaultDomainEntry )
    {
        hr = SmtpCreateException (IDS_SMTPEXCEPTION_CANT_DEL_DEFAULT_DOMAIN);
        goto Exit;
    }

    RemoveEntryList( &m_pCurrentDomainEntry->list );
    hr = SaveToMetabase();

Exit:
    TraceFunctLeave ();
    return hr;
}


STDMETHODIMP CSmtpAdminDomain::Get ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Get" );

    HRESULT            hr        = NOERROR;

    hr = GetFromMetabase();
    if( FAILED(hr) )
    {
        goto Exit;
    }

    // given domain name, find the entry
    m_pCurrentDomainEntry = FindDomainEntry( m_strDomainName );

    if( !m_pCurrentDomainEntry )
    {
        hr = SmtpCreateException( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    LoadDomainProperty( m_pCurrentDomainEntry );

Exit:
    TraceFunctLeave ();
    return hr;
}



STDMETHODIMP CSmtpAdminDomain::Set ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Set" );

    HRESULT            hr        = NOERROR;
    DomainEntry*    pOldDef = NULL;

    // need to call get() first
    _ASSERT( m_pCurrentDomainEntry );

    if( !m_pCurrentDomainEntry )
    {
        hr = SmtpCreateException (IDS_SMTPEXCEPTION_DIDNT_CALL_GET);
        goto Exit;
    }

    lstrcpyW( m_pCurrentDomainEntry->m_strDomainName, m_strDomainName );
    lstrcpyW( m_pCurrentDomainEntry->m_strActionString, m_strActionString );
    m_pCurrentDomainEntry-> m_dwActionType = m_dwActionType;
    m_pCurrentDomainEntry-> m_fAllowEtrn = m_fAllowEtrn;

    // deal with default domain
    if( m_dwActionType == SMTP_DEFAULT && m_pDefaultDomainEntry != m_pCurrentDomainEntry )
    {
        pOldDef = m_pDefaultDomainEntry;
        pOldDef-> m_dwActionType = pOldDef->m_strActionString[0] ? SMTP_DROP : SMTP_DELIVER;

        m_pDefaultDomainEntry = m_pCurrentDomainEntry;
        RemoveEntryList( &m_pCurrentDomainEntry->list );
        InsertHeadList( &m_list, &m_pCurrentDomainEntry->list );
    }

    hr = SaveToMetabase();

Exit:
    TraceFunctLeave ();
    return hr;
}



STDMETHODIMP CSmtpAdminDomain::Enumerate ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::EnumDomains" );
    HRESULT        hr = NOERROR;

    hr = GetFromMetabase();
    m_fEnumerated = TRUE;

    TraceFunctLeave ();
    return hr;
}


STDMETHODIMP CSmtpAdminDomain::GetNth( long lIndex )
{
    TraceFunctEnter ( "CSmtpAdminDomain::GetNth" );
    HRESULT        hr = NOERROR;

    PLIST_ENTRY    pEntry;

    if( !m_fEnumerated )
    {
        hr = SmtpCreateException( IDS_SMTPEXCEPTION_DIDNT_ENUMERATE );
        goto Exit;
    }

    if( lIndex < 0 || lIndex >= m_lCount )
    {
        hr = SmtpCreateException( IDS_SMTPEXCEPTION_INVALID_INDEX );
        goto Exit;
    }

    pEntry = m_list.Flink;
    while( lIndex -- )
    {
        pEntry = pEntry-> Flink;
        _ASSERT( pEntry != &m_list );
    }

    m_pCurrentDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
    LoadDomainProperty( m_pCurrentDomainEntry );

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminDomain::GetDefaultDomain ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::GetDefaultDomain" );

    HRESULT        hr = NOERROR;

    if( !m_pDefaultDomainEntry )
    {
        hr = GetFromMetabase();
        if( FAILED(hr) )
        {
            goto Exit;
        }
    }

    LoadDomainProperty( m_pDefaultDomainEntry );

Exit:
    TraceFunctLeave ();
    return hr;
}


DomainEntry* CSmtpAdminDomain::FindDomainEntry( LPCWSTR lpName )
{
    TraceFunctEnter ( "CSmtpAdminDomain::FindDomainEntry" );

    DomainEntry*    pDomainEntry = NULL;
    PLIST_ENTRY        pHead;
    PLIST_ENTRY        pEntry;

    for( pHead=&m_list, pEntry=pHead->Flink; pEntry!=pHead; pEntry=pEntry->Flink )
    {
        pDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
        if( !lstrcmpiW( pDomainEntry->m_strDomainName, lpName ) )
        {
            TraceFunctLeave ();
            return pDomainEntry;
        }
    }

    TraceFunctLeave ();
    return NULL;
}

STDMETHODIMP CSmtpAdminDomain::SetAsDefaultDomain ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::SetAsDefaultDomain" );
    HRESULT        hr = NOERROR;

    if( !m_pDefaultDomainEntry )
    {
        hr = GetFromMetabase();
        if( FAILED(hr) )
        {
            goto Exit;
        }
    }

    // not in the list
    if( m_dwDomainId == UNASSIGNED_DOMAIN_ID )
    {
        hr = Add();
        if( FAILED(hr) )
        {
            goto Exit;
        }
    }

    _ASSERT( m_dwDomainId == m_pCurrentDomainEntry->m_dwDomainId );

    m_pDefaultDomainEntry = m_pCurrentDomainEntry;

    hr = SaveToMetabase();

Exit:
    TraceFunctLeave ();
    return hr;
}

BOOL CSmtpAdminDomain::LoadDomainProperty(DomainEntry* pDomainEntry)
{
    TraceFunctEnter ( "CSmtpAdminDomain::LoadDomainProperty" );
    _ASSERT( pDomainEntry );

    m_strDomainName        = pDomainEntry-> m_strDomainName;
    m_dwActionType        = pDomainEntry-> m_dwActionType;

    m_strActionString    = pDomainEntry-> m_strActionString;
    m_fAllowEtrn        = pDomainEntry-> m_fAllowEtrn;
    m_dwDomainId        = pDomainEntry-> m_dwDomainId;

    m_pCurrentDomainEntry = pDomainEntry;

    TraceFunctLeave ();
    return TRUE;
}


BOOL CSmtpAdminDomain::ConstructListFromMetabaseValues()
{
    TraceFunctEnter ( "CSmtpAdminDomain::ConstructListFromMetabaseValues" );

    DomainEntry*    pDomainEntry;
    TCHAR*            pCh;
    TCHAR*            wszCurrent;

    DWORD            i;
    DWORD            cCount = m_mszDomainRouting.Count( );

    EmptyList();
    m_lCount = 0;

    pCh = (TCHAR*)(LPCWSTR)m_mszDomainRouting;

    for( wszCurrent = pCh, i = 0; 
        i < cCount; 
        i++, wszCurrent += lstrlen (wszCurrent) + 1 ) 
    {
        pDomainEntry = new DomainEntry;
        
        if( NULL == pDomainEntry )
        {
            goto Exit;
        }

        pDomainEntry-> FromString( wszCurrent );
        InsertHeadList( &m_list, &pDomainEntry->list );
    }

    m_lCount += cCount;

    if( !m_strDefaultDomain.m_str || !m_strDefaultDomain.m_str[0] )
    {
        _ASSERT( FALSE );
        goto Exit;
    }

    m_pDefaultDomainEntry = new DomainEntry;
    
    if( NULL == m_pDefaultDomainEntry )
    {
        goto Exit;
    }

    lstrcpy( m_pDefaultDomainEntry-> m_strDomainName, m_strDefaultDomain.m_str );

    if( !m_strDropDir )
    {
        m_pDefaultDomainEntry-> m_strActionString[0] = _T('\0');
    }
    else
    {
        lstrcpy( m_pDefaultDomainEntry-> m_strActionString, m_strDropDir.m_str );
    }

    m_pDefaultDomainEntry-> m_dwActionType = SMTP_DEFAULT;

    InsertHeadList( &m_list, &m_pDefaultDomainEntry->list );
    m_lCount ++;

Exit:
    TraceFunctLeave ();
    return TRUE;
}


BOOL CSmtpAdminDomain::ParseListToMetabaseValues()        // called by SaveData()
{
    TraceFunctEnter ( "CSmtpAdminDomain::ParseListToMetabaseValues" );

    BOOL        fRet = TRUE;

    // change string list to multisz
    DomainEntry*    pDomainEntry = NULL;
    PLIST_ENTRY        pHead;
    PLIST_ENTRY        pEntry;
    DWORD            cb = 0;
    WCHAR*            pBuf;
    WCHAR*            p;

    // the first one is default domain
    _ASSERT( CONTAINING_RECORD( m_list.Flink, DomainEntry, list ) == m_pDefaultDomainEntry );

    for( pHead=&m_list, pEntry=pHead->Flink->Flink; pEntry!=pHead; pEntry=pEntry->Flink )
    {
        pDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
        cb += lstrlenW( pDomainEntry-> m_strDomainName );
        cb += lstrlenW( pDomainEntry-> m_strActionString );
        cb += sizeof(DWORD)*2;
        cb += 10;    // 4 commas and NULL
    }

    // two more NULL's
    cb += 4;
    pBuf = new WCHAR[cb];

    if( !pBuf )
    {
        ErrorTrace ( (LPARAM) this, "Out of memory" );
        fRet = FALSE;
        goto Exit;
    }

    p = pBuf;

    // Note: the first entry is the default domain
    for( pHead=&m_list, pEntry=pHead->Flink->Flink; pEntry!=pHead; pEntry=pEntry->Flink )
    {
        pDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
        pDomainEntry->ToString( p );

        p += lstrlenW(p);
        p ++;
    }

    // add two more NULL
    *p = L'\0';
    *(p+1) = L'\0';

    m_mszDomainRouting.Empty();
    m_mszDomainRouting.Attach( pBuf );

Exit:
    TraceFunctLeave ();
    return fRet;
}


HRESULT CSmtpAdminDomain::GetFromMetabase()
{
    TraceFunctEnter ( "CSmtpAdminDomain::GetFromMetabase" );

    HRESULT    hr    = NOERROR;
    BOOL    fRet = TRUE;
    CComPtr<IMSAdminBase>    pmetabase;

    TCHAR        szPath[METADATA_MAX_NAME_LEN+2] = {0};
    TCHAR        szDropDir[256] = {0};
    TCHAR        szBuf[256] = {0};

    hr = m_mbFactory.GetMetabaseObject ( m_iadsImpl.QueryComputer(), &pmetabase );
    if ( FAILED(hr) ) {
        return hr;
    }

    CMetabaseKey        hMB( pmetabase );
    GetMDInstancePath( szPath, m_iadsImpl.QueryInstance() );

    hr = hMB.Open( szPath, METADATA_PERMISSION_READ );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    m_strDefaultDomain.Empty();
    m_strDropDir.Empty();
    m_mszDomainRouting.Empty();

    fRet = StdGetMetabaseProp ( &hMB, MD_DOMAIN_ROUTING,        DEFAULT_DOMAIN_ROUTING,    &m_mszDomainRouting);
    fRet = StdGetMetabaseProp ( &hMB, MD_DEFAULT_DOMAIN_VALUE,    DEFAULT_DEFAULT_DOMAIN, &m_strDefaultDomain )   && fRet;
    fRet = StdGetMetabaseProp ( &hMB, MD_MAIL_DROP_DIR,            DEFAULT_DROP_DIR,        &m_strDropDir ) && fRet;

    if( !fRet )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    ConstructListFromMetabaseValues();

Exit:
    TraceFunctLeave ();
    return hr;
}

HRESULT CSmtpAdminDomain::SaveToMetabase()
{
    TraceFunctEnter ( "CSmtpAdminDomain::SaveToMetabase" );

    ParseListToMetabaseValues();

    // these two are for default domain,
    // default domain needs special care,
    // by default, it's computed by smtpsvc from TCP/IP configuration,
    // don't set this key if not changed
    BOOL        fDefChanged        = FALSE;
    BOOL        fDropChanged    = FALSE;

    _ASSERT( m_pDefaultDomainEntry && m_pDefaultDomainEntry-> m_dwActionType == SMTP_DEFAULT );
    if( m_pDefaultDomainEntry )
    {
        fDefChanged        = lstrcmpiW( m_strDefaultDomain, m_pDefaultDomainEntry-> m_strDomainName );
        fDropChanged    = lstrcmpiW( m_strActionString, m_pDefaultDomainEntry-> m_strActionString );

        if( fDefChanged )
        {
            m_strDefaultDomain.Empty();
            m_strDefaultDomain    = m_pDefaultDomainEntry-> m_strDomainName;
        }

        if( fDropChanged )
        {
            m_strDropDir.Empty();
            m_strDropDir    = m_pDefaultDomainEntry-> m_strActionString;
        }
    }


    HRESULT    hr    = NOERROR;
    BOOL    fRet = TRUE;

    CComPtr<IMSAdminBase>    pmetabase;

    TCHAR        szPath[METADATA_MAX_NAME_LEN+2] = {0};
    TCHAR        szDropDir[256] = {0};
    TCHAR        szBuf[256] = {0};

    hr = m_mbFactory.GetMetabaseObject ( m_iadsImpl.QueryComputer(), &pmetabase );
    if ( FAILED(hr) ) {
        return hr;
    }

    CMetabaseKey        hMB( pmetabase );
    GetMDInstancePath( szPath, m_iadsImpl.QueryInstance() ); 

    hr = hMB.Open( szPath, METADATA_PERMISSION_WRITE );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    if( fDefChanged )
    {
        fRet = StdPutMetabaseProp ( &hMB, MD_DEFAULT_DOMAIN_VALUE, m_pDefaultDomainEntry-> m_strDomainName ) && fRet;
    }

    if( fDropChanged )
    {
        fRet = StdPutMetabaseProp ( &hMB, MD_MAIL_DROP_DIR,    m_pDefaultDomainEntry-> m_strActionString ) && fRet;
    }

    fRet = StdPutMetabaseProp ( &hMB, MD_DOMAIN_ROUTING,    &m_mszDomainRouting)        && fRet;

    if( !fRet )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    // hr = hMB.Close();
    // BAIL_ON_FAILURE(hr);
    hMB.Close();

    hr = pmetabase-> SaveData();
    BAIL_ON_FAILURE(hr);

Exit:
    TraceFunctLeave ();
    return hr;
}


BOOL DomainEntry::FromString( LPCTSTR lpDomainString )
{
    TraceFunctEnter ( "DomainEntry::FromString" );

    TCHAR       szT[256] = {0};

    WCHAR*      pCh = (WCHAR*)lpDomainString;
    WCHAR*      pT;

    m_dwDomainId = UNASSIGNED_DOMAIN_ID;
    m_fAllowEtrn = FALSE;

    ZeroMemory( szT, sizeof(szT) );
    pT = szT;
    while( *pCh )   //
    {
        if( iswdigit( *pCh ) )
        {
            *pT++ = *pCh;
            pCh ++;
            continue;
        }

        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        return FALSE;
    }

    if( !*pCh )
        return FALSE;

    m_dwActionType = (DWORD) _wtoi( szT );

/*
    if( m_dwActionType >= LAST_SMTP_ACTION )
    {
        _ASSERT( FALSE );
        m_dwActionType = SMTP_DROP;     // assume local drop domain
    }
*/

    ZeroMemory( m_strDomainName, sizeof(m_strDomainName) );
    pT = m_strDomainName;
    while( *pCh )
    {
        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        *pT++ = *pCh++;
    }

    if( !*pCh )
        return FALSE;

    ZeroMemory( m_strActionString, sizeof(m_strActionString) );
    pT = m_strActionString;
    while( *pCh )
    {
        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        *pT++ = *pCh++;
    }

    if( !*pCh )
        return FALSE;

    ZeroMemory( szT, sizeof(szT) );
    pT = szT;
    while( *pCh )   //
    {
        if( iswdigit( *pCh ) )
        {
            *pT++ = *pCh;
            pCh ++;
            continue;
        }

        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        return FALSE;
    }

    m_fAllowEtrn = !! ((DWORD) _wtoi( szT ));

    if( !*pCh )
    {
        return FALSE;
    }

    ZeroMemory( szT, sizeof(szT) );
    pT = szT;
    while( *pCh )   //
    {
        if( iswdigit( *pCh ) )
        {
            *pT++ = *pCh;
            pCh ++;
            continue;
        }

        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        return FALSE;
    }

    m_dwDomainId = (DWORD) _wtoi( szT );

    // ignore any other chars

    TraceFunctLeave ();
    return TRUE;
}


BOOL DomainEntry::ToString( LPTSTR lpDomainString )
{
    TraceFunctEnter ( "DomainEntry::FromString" );

    wsprintfW( lpDomainString, L"%d,%s,%s,%d",m_dwActionType, m_strDomainName,
        m_strActionString, m_fAllowEtrn);

    TraceFunctLeave ();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\domain.h ===
// domain.h : Declaration of the CSmtpAdminDomain


#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"
#include "cmultisz.h"
#include "metafact.h"
#include "smtpadm.h"
#include "listmacr.h"

struct DomainEntry
{
	TCHAR		m_strDomainName[256];	// current domain's name
	DWORD		m_dwActionType;
	TCHAR		m_strActionString[256];
	BOOL		m_fAllowEtrn;
	DWORD		m_dwDomainId;

	LIST_ENTRY	list;

	BOOL		FromString( LPCTSTR lpDomainString );
	BOOL		ToString( LPTSTR lpDomainString );		// big enough to hold the entry

	DomainEntry()
	{
		ZeroMemory( m_strDomainName, sizeof(m_strDomainName) );
		ZeroMemory( m_strActionString, sizeof(m_strActionString) );

		m_dwActionType = SMTP_DELIVER;
		m_fAllowEtrn = FALSE;
		m_dwDomainId = (DWORD)-1;
		InitializeListHead( &list );
	}
};


/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminDomain : 
	public ISmtpAdminDomain,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminDomain,&CLSID_CSmtpAdminDomain>
{
public:
	CSmtpAdminDomain();
	virtual ~CSmtpAdminDomain();
BEGIN_COM_MAP(CSmtpAdminDomain)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminDomain)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminDomain) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminDomain, _T("Smtpadm.Domain.1"), _T("Smtpadm.Domain"), IDS_SMTPADMIN_DOMAIN_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminDomain
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminDomain
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// enumeration
	STDMETHODIMP	get_Count			( long* plCount  );

	// Domain Properties:

	STDMETHODIMP	get_DomainName		( BSTR * pstrDomainName );
	STDMETHODIMP	put_DomainName		( BSTR strDomainName );

	STDMETHODIMP	get_ActionType		( long * plActionType );
	STDMETHODIMP	put_ActionType		( long lActionType );

	// drop IsDefault!!
	STDMETHODIMP	get_IsDefault		( BOOL * pfIsDefault );
	STDMETHODIMP	put_IsDefault		( BOOL fIsDefault );

	STDMETHODIMP	get_IsLocal			( BOOL * pfIsLocal );
	STDMETHODIMP	put_IsLocal			( BOOL fIsLocal );

	// if local
	STDMETHODIMP	get_LDAPServer		( BSTR * pstrLDAPServer );
	STDMETHODIMP	put_LDAPServer		( BSTR strLDAPServer );

	STDMETHODIMP	get_Account			( BSTR * pstrAccount );
	STDMETHODIMP	put_Account			( BSTR strAccount );

	STDMETHODIMP	get_Password		( BSTR * pstrPassword );
	STDMETHODIMP	put_Password		( BSTR strPassword );

	STDMETHODIMP	get_LDAPContainer	( BSTR * pstrLDAPContainer );
	STDMETHODIMP	put_LDAPContainer	( BSTR strLDAPContainer );

	// if remote
	STDMETHODIMP	get_UseSSL			( BOOL * pfUseSSL );
	STDMETHODIMP	put_UseSSL			( BOOL fUseSSL );

	STDMETHODIMP	get_EnableETRN		( BOOL * pfEnableETRN );
	STDMETHODIMP	put_EnableETRN		( BOOL fEnableETRN );

	STDMETHODIMP	get_DropDir			( BSTR * pstrDropDir );
	STDMETHODIMP	put_DropDir			( BSTR strDropDir );

	STDMETHODIMP	get_RoutingDomain	( BSTR * pstrRoutingDomain );
	STDMETHODIMP	put_RoutingDomain	( BSTR strRoutingDomain );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Default		( );

	STDMETHODIMP	Add			( );
	STDMETHODIMP	Remove		( );

	STDMETHODIMP	Get			( );
	STDMETHODIMP	Set			( );

	STDMETHODIMP	Enumerate	( );

	STDMETHODIMP	GetNth		( long lIndex );

	STDMETHODIMP	GetDefaultDomain ( );

	STDMETHODIMP	SetAsDefaultDomain ( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	long		m_lCount;

	// metabase key values, these shouldn't be changed before Set()
	CMultiSz    m_mszDomainRouting;
	CComBSTR	m_strDefaultDomain;
	CComBSTR	m_strDropDir;

	// current domain's property
	CComBSTR	m_strDomainName;	// current domain's name
	DWORD		m_dwActionType;
	CComBSTR	m_strActionString;
	BOOL		m_fAllowEtrn;
	DWORD		m_dwDomainId;

	// if local
	CComBSTR	m_strLDAPServer;
	CComBSTR	m_strAccount;
	CComBSTR	m_strPassword;
	CComBSTR	m_strLDAPContainer;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	// add a list of domains
	LIST_ENTRY	m_list;
	DWORD		m_dwMaxDomainId;

	BOOL		m_fEnumerated;

	// DWORD			m_dwCurrentIndex;	// optimization
	DomainEntry*		m_pCurrentDomainEntry;

	DomainEntry*	m_pDefaultDomainEntry;

	// private method
	HRESULT		SaveData();

	BOOL		LoadDomainProperty(DomainEntry* pDomainEntry);

	DomainEntry*	FindDomainEntry( LPCWSTR lpName );

	BOOL		ConstructListFromMetabaseValues();
	BOOL		ParseListToMetabaseValues();		// called by SaveData()

	HRESULT		GetFromMetabase();
	HRESULT		SaveToMetabase();

	void		EmptyList();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\guids.cpp ===
#include "stdafx.h"

#define INITGUIDS
#include "initguid.h"

// #include "iadm.h"


//
//	SMTP guids
//
#include "smtpadm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\makefile.inc ===
$(O)\smtpadm.h $(O)\smtpadm_i.c : $(STAXINC)\export\smtpadm.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpadm_i.c \
    -header $@ \
    -tlb $(O)\smtpadm.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\ipaccess.h ===
//
//	Dependencies
//

class ADDRESS_CHECK;
class CTcpAccess;
class CTcpAccessExceptions;
class CTcpAccessException;
class CMetabaseKey;

/////////////////////////////////////////////////////////////////////////////
// The TcpAccess Object

class CTcpAccess : 
	public CComDualImpl<ITcpAccess, &IID_ITcpAccess, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccess();
	virtual ~CTcpAccess ();

BEGIN_COM_MAP(CTcpAccess)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccess)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccess) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccess, _T("Smtpadm.TcpAccess.1"), _T("Smtpadm.TcpAccess"), IDS_TCPACCESS_DESC, THREADFLAGS_BOTH)
// Private admin object interface:
public:
	HRESULT			GetFromMetabase ( CMetabaseKey * pMB );
	HRESULT			SendToMetabase ( CMetabaseKey * pMB );

// ITcpAccess
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_GrantedList	( ITcpAccessExceptions ** ppGrantedList );
	STDMETHODIMP	get_DeniedList	( ITcpAccessExceptions ** ppDeniedList );
/*
	STDMETHODIMP	put_GrantedList	( ITcpAccessExceptions * pGrantedList );
	STDMETHODIMP	put_DeniedList	( ITcpAccessExceptions * pDeniedList );
*/
	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComObject<CTcpAccessExceptions> *	m_pGrantList;
	CComObject<CTcpAccessExceptions> *	m_pDenyList;

	HRESULT	GetAddressCheckFromMetabase ( CMetabaseKey * pMB, ADDRESS_CHECK * pAC );
};

/////////////////////////////////////////////////////////////////////////////
// The TcpAccessExceptions Object

class CTcpAccessExceptions : 
	public CComDualImpl<ITcpAccessExceptions, &IID_ITcpAccessExceptions, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccessExceptions();
	virtual ~CTcpAccessExceptions ();

BEGIN_COM_MAP(CTcpAccessExceptions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccessExceptions)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccessExceptions) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccessExceptions, _T("Smtpadm.TcpAccessExceptions.1"), _T("Smtpadm.TcpAccessExceptions"), IDS_TCPACCESSEXCEPTIONS_DESC, THREADFLAGS_BOTH)
//
//	Private admin object interface:
//
	HRESULT FromAddressCheck ( ADDRESS_CHECK * pAC, BOOL fGrant );
	HRESULT ToAddressCheck ( ADDRESS_CHECK * pAC, BOOL fGrant );

// ITcpAccessExceptions
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Count	( long * pcCount );
	STDMETHODIMP	AddDnsName	( BSTR strDnsName );
	STDMETHODIMP	AddIpAddress( long lIpAddress, long lIpMask );
	STDMETHODIMP	Item		( long index, ITcpAccessException ** ppAccessException );
	STDMETHODIMP	Remove		( long index );
	STDMETHODIMP	FindDnsIndex( BSTR strDnsName, long * pIndex );
	STDMETHODIMP	FindIpIndex	( long lIpAddress, long lIpMask, long * pIndex );
	STDMETHODIMP	Clear		( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:
	long							m_cCount;
	CComPtr<ITcpAccessException> *	m_rgItems;

	HRESULT	AddItem ( ITcpAccessException * pNew );
};

class CTcpAccessException : 
	public CComDualImpl<ITcpAccessException, &IID_ITcpAccessException, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccessException();
	virtual ~CTcpAccessException ();

	static HRESULT CreateNew ( LPWSTR strDnsName, ITcpAccessException ** ppNew );
	static HRESULT CreateNew ( DWORD dwIpAddress, DWORD dwIpMask, ITcpAccessException ** ppNew );

BEGIN_COM_MAP(CTcpAccessException)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccessException)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccessException) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccessException, _T("Smtpadm.TcpAccessException.1"), _T("Smtpadm.TcpAccessException"), IDS_TCPACCESSEXCEPTION_DESC, THREADFLAGS_BOTH)
// ITcpAccessException
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_IsDnsName	( BOOL * pfIsDnsName );
	STDMETHODIMP	get_IsIpAddress	( BOOL * pfIsIpAddress );

	STDMETHODIMP	get_DnsName	( BSTR * pstrDnsName );
	STDMETHODIMP	put_DnsName	( BSTR strDnsName );

	STDMETHODIMP	get_IpAddress	( long * plIpAddress );
	STDMETHODIMP	put_IpAddress	( long lIpAddress );

	STDMETHODIMP	get_IpMask	( long * plIpMask );
	STDMETHODIMP	put_IpMask	( long lIpMask );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:
	CComBSTR	m_strDnsName;
	DWORD		m_dwIpAddress;
	DWORD		m_dwIpMask;
	BOOL		m_fIsDnsName;
	BOOL		m_fIsIpAddress;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\ipaccess.cpp ===
// ipaccess.cpp : Implementation of CTcpAccess & CTcpAccessExceptions.

#include "stdafx.h"

#include "pudebug.h"
#define _RDNS_STANDALONE
#include <rdns.hxx>

DECLARE_DEBUG_PRINTS_OBJECT()

#include "smtpadm.h"
#include "smtpcmn.h"
#include "cmultisz.h"
#include "ipaccess.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.TcpAccess.1")
#define THIS_FILE_IID				IID_ITcpAccess

//
//	Useful macros:
//

#define MAKEIPADDRESS(b1,b2,b3,b4) (((DWORD)(b1)<<24) +\
                                    ((DWORD)(b2)<<16) +\
                                    ((DWORD)(b3)<< 8) +\
                                    ((DWORD)(b4)))

#define GETIP_FIRST(x)             ((x>>24) & 0xff)
#define GETIP_SECOND(x)            ((x>>16) & 0xff)
#define GETIP_THIRD(x)             ((x>> 8) & 0xff)
#define GETIP_FOURTH(x)            ((x)     & 0xff)

inline void 
DWORDtoLPBYTE ( 
	IN	DWORD	dw, 
	OUT	LPBYTE	lpBytes 
	)
{
	_ASSERT ( !IsBadWritePtr ( lpBytes, 4 * sizeof ( BYTE ) ) ); 

	lpBytes[0] = (BYTE)GETIP_FIRST(dw);
	lpBytes[1] = (BYTE)GETIP_SECOND(dw);
	lpBytes[2] = (BYTE)GETIP_THIRD(dw);
	lpBytes[3] = (BYTE)GETIP_FOURTH(dw);
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccess::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccess,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccess::CTcpAccess ()
	// CComBSTR's are initialized to NULL by default.
{
	m_pGrantList		= NULL;
	m_pDenyList			= NULL;
}

CTcpAccess::~CTcpAccess ()
{
	// All CComBSTR's are freed automatically.

    if ( m_pGrantList ) {
        m_pGrantList->Release ();
    }
    if ( m_pDenyList ) {
        m_pDenyList->Release ();
    }
}

HRESULT CTcpAccess::GetAddressCheckFromMetabase ( CMetabaseKey * pMB, ADDRESS_CHECK * pAC )
{
	HRESULT				hr		= NOERROR;
	DWORD				dwDummy	= 0;
	DWORD				cbIpSec	= 0;
	BYTE *				pIpSec	= NULL;

	hr = pMB->GetDataSize ( _T(""), MD_IP_SEC, BINARY_METADATA, &cbIpSec, METADATA_INHERIT, IIS_MD_UT_FILE );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		hr = NOERROR;
		cbIpSec = 0;
	}
	BAIL_ON_FAILURE ( hr );

	if ( cbIpSec != 0 ) {
		pIpSec = new BYTE [ cbIpSec ];
		if ( !pIpSec ) {
			BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
		}

		hr = pMB->GetBinary ( MD_IP_SEC, pIpSec, cbIpSec, METADATA_INHERIT, IIS_MD_UT_FILE );
		BAIL_ON_FAILURE (hr);

		pAC->BindCheckList ( pIpSec, cbIpSec );
	}

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Private admin object interface:
//////////////////////////////////////////////////////////////////////

HRESULT CTcpAccess::GetFromMetabase ( CMetabaseKey * pMB )
{
    HRESULT     	hr	= NULL;
	CComObject<CTcpAccessExceptions> *	pGrantList	= NULL;
	CComObject<CTcpAccessExceptions> *	pDenyList	= NULL;

    ADDRESS_CHECK	ac;

	hr = GetAddressCheckFromMetabase ( pMB, &ac );
	BAIL_ON_FAILURE ( hr );

	hr = CComObject<CTcpAccessExceptions>::CreateInstance ( &pGrantList );
	BAIL_ON_FAILURE(hr);

	hr = CComObject<CTcpAccessExceptions>::CreateInstance ( &pDenyList );
	BAIL_ON_FAILURE(hr);

	//
	//	Copy each list into our object:
	//

	hr = pGrantList->FromAddressCheck ( &ac, TRUE );
	BAIL_ON_FAILURE(hr);

	hr = pDenyList->FromAddressCheck ( &ac, FALSE );
	BAIL_ON_FAILURE(hr);

	//
	//	Replace the old grant & deny lists with the new ones:
	//

    if ( m_pGrantList ) {
        m_pGrantList->Release ();
        m_pGrantList = NULL;
    }
    if ( m_pDenyList ) {
        m_pDenyList->Release ();
        m_pDenyList = NULL;
    }

    m_pGrantList    = pGrantList;
    m_pDenyList     = pDenyList;

    m_pGrantList->AddRef ();
    m_pDenyList->AddRef ();

Exit:
	ac.UnbindCheckList ();

	if ( FAILED(hr) ) {
		delete pGrantList;
		delete pDenyList;
	}

	return hr;
}

HRESULT CTcpAccess::SendToMetabase ( CMetabaseKey * pMB )
{
	HRESULT			hr;
	ADDRESS_CHECK	ac;
	BYTE *			pIpSec	= NULL;
	DWORD			cbIpSec	= 0;

	_ASSERT ( m_pGrantList );
	_ASSERT ( m_pDenyList );

	ac.BindCheckList ();

	hr = m_pGrantList->ToAddressCheck ( &ac, TRUE );
	BAIL_ON_FAILURE(hr);

	hr = m_pDenyList->ToAddressCheck ( &ac, FALSE );
	BAIL_ON_FAILURE(hr);

	cbIpSec	= ac.QueryCheckListSize ();
	pIpSec	= ac.QueryCheckListPtr ();

	hr = pMB->SetBinary ( MD_IP_SEC, pIpSec, cbIpSec, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_FILE );

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccess::get_GrantedList ( ITcpAccessExceptions ** ppGrantedList )
{
	return m_pGrantList->QueryInterface ( IID_ITcpAccessExceptions, (void **) ppGrantedList );
}

STDMETHODIMP CTcpAccess::get_DeniedList ( ITcpAccessExceptions ** ppDeniedList )
{
	return m_pDenyList->QueryInterface ( IID_ITcpAccessExceptions, (void **) ppDeniedList );
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccessExceptions::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccessExceptions,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccessExceptions::CTcpAccessExceptions () :
	m_cCount	( 0 ),
	m_rgItems	( NULL )
	// CComBSTR's are initialized to NULL by default.
{
}

CTcpAccessExceptions::~CTcpAccessExceptions ()
{
	// All CComBSTR's are freed automatically.
}

HRESULT 
CTcpAccessExceptions::FromAddressCheck ( 
	ADDRESS_CHECK * pAC, 
	BOOL fGrantList 
	)
{
	HRESULT		hr	= NOERROR;
	DWORD		cNames;
	DWORD		cAddresses;
	DWORD		i;

	cNames		= pAC->GetNbName ( fGrantList );
	cAddresses	= pAC->GetNbAddr ( fGrantList );

	//
	//	Copy the Dns Names:
	//

	for ( i = 0; i < cNames; i++ ) {
		DWORD		dwFlags	= 0;
		LPSTR		lpName	= NULL;
		CComBSTR	strDomain;

		if ( pAC->GetName ( fGrantList, i, &lpName, &dwFlags ) ) {

			if ( !(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN) ) {
				strDomain = _T("*.");

				strDomain.Append ( lpName );
			}
			else {
				strDomain = lpName;
			}

			hr = AddDnsName ( strDomain );
			BAIL_ON_FAILURE(hr);
		}
	}

	//
	//	Copy the IpAddresses:
	//

	for ( i = 0; i < cAddresses; i++ ) {
		DWORD		dwFlags	= 0;
		LPBYTE		lpMask	= NULL;
		LPBYTE		lpAddr	= NULL;
		DWORD		dwIpAddress;
		DWORD		dwIpMask;

		if ( pAC->GetAddr ( fGrantList, i, &dwFlags, &lpMask, &lpAddr ) ) {

			dwIpAddress	= MAKEIPADDRESS( lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3] );
			dwIpMask	= MAKEIPADDRESS( lpMask[0], lpMask[1], lpMask[2], lpMask[3] );

			hr = AddIpAddress ( (long) dwIpAddress, (long) dwIpMask );
			BAIL_ON_FAILURE(hr);
		}
	}

Exit:
	return hr;
}

HRESULT 
CTcpAccessExceptions::ToAddressCheck ( 
	ADDRESS_CHECK * pAC, 
	BOOL fGrantList
	)
{
	HRESULT		hr	= NOERROR;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		BOOL	fIsName	= FALSE;
		BOOL	fIsAddr	= FALSE;

		m_rgItems[i]->get_IsDnsName		( &fIsName );
		m_rgItems[i]->get_IsIpAddress	( &fIsAddr );

		if ( fIsName ) {
			CComBSTR	strDnsName;
			DWORD		cchName		= 0;
			LPSTR		szAnsiName	= NULL;

			DWORD		dwFlags		= 0;
			LPSTR		lpName		= NULL;

			hr = m_rgItems[i]->get_DnsName ( &strDnsName );
			BAIL_ON_FAILURE(hr);

			cchName = strDnsName.Length ( );

			szAnsiName = new char [ cchName + 1 ];
			if ( !szAnsiName ) {
				BAIL_WITH_FAILURE( hr, E_OUTOFMEMORY );
			}

			WideCharToMultiByte ( CP_ACP, 0, strDnsName, -1, szAnsiName, cchName + 1, NULL, NULL );

			if ( strncmp ( szAnsiName, "*.", 2 ) == 0 ) {
				dwFlags	= 0;
				lpName	= szAnsiName + 2;
			}
			else {
				dwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;
				lpName	= szAnsiName;
			}
			pAC->AddName ( fGrantList, lpName, dwFlags );

			delete szAnsiName;
		}
		else if ( fIsAddr ) {
			long	lIpAddress	= 0;
			long	lIpMask		= 0;
			BYTE	bIp[4];
			BYTE	bMask[4];

			m_rgItems[i]->get_IpAddress ( &lIpAddress );
			m_rgItems[i]->get_IpMask	( &lIpMask );

			DWORDtoLPBYTE ( (DWORD) lIpAddress, bIp );
			DWORDtoLPBYTE ( (DWORD) lIpMask, bMask );

			pAC->AddAddr ( fGrantList, AF_INET, bMask, bIp );
		}
	}

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccessExceptions::get_Count ( long * pcCount )
{
	return StdPropertyGet ( m_cCount, pcCount );
}

STDMETHODIMP CTcpAccessExceptions::AddDnsName ( BSTR strDnsName )
{
	HRESULT							hr					= NOERROR;
	CComPtr<ITcpAccessException>	pNew;

	hr = CTcpAccessException::CreateNew ( strDnsName, &pNew );
	BAIL_ON_FAILURE ( hr );

	hr = AddItem ( pNew );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::AddIpAddress ( long lIpAddress, long lIpMask )
{
	HRESULT							hr					= NOERROR;
	CComPtr<ITcpAccessException>	pNew;

	hr = CTcpAccessException::CreateNew ( lIpAddress, lIpMask, &pNew );
	BAIL_ON_FAILURE ( hr );

	hr = AddItem ( pNew );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

HRESULT CTcpAccessExceptions::AddItem ( ITcpAccessException * pNew )
{
	HRESULT							hr			= NOERROR;
	CComPtr<ITcpAccessException> *	rgNewItems	= NULL;
	long							i;

	rgNewItems = new CComPtr<ITcpAccessException> [ m_cCount + 1 ];
	if ( !rgNewItems ) {
		BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
	}

	for ( i = 0; i < m_cCount; i++ ) {
		rgNewItems[i] = m_rgItems[i];
	}
	rgNewItems[m_cCount] = pNew;

	delete [] m_rgItems;
	m_rgItems = rgNewItems;
	m_cCount++;

Exit:
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::Item ( long index, ITcpAccessException ** ppTcpAccessException )
{
	HRESULT		hr;

	if ( index < 0 || index >= m_cCount ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	hr = m_rgItems[index]->QueryInterface ( IID_ITcpAccessException, (void **) ppTcpAccessException );
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::Remove ( long index )
{
	HRESULT					hr		= NOERROR;
	CComPtr<ITcpAccessException>	pTemp;
	long					i;

	if ( index < 0 || index >= m_cCount ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	for ( i = index + 1; i < m_cCount; i++ ) {
		m_rgItems[i - 1] = m_rgItems[i];
	}

	m_rgItems[m_cCount - 1].Release ();
	m_cCount--;

	return hr;
}

STDMETHODIMP 
CTcpAccessExceptions::FindDnsIndex (
	BSTR	strDnsNameToFind,
	long *	pIndex 
	)
{
	long		lResult	= -1;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		HRESULT		hr1;
		CComBSTR	strDnsName;
		BOOL		fIsDnsName	= FALSE;

		hr1 = m_rgItems[i]->get_IsDnsName ( &fIsDnsName );
		if ( !fIsDnsName ) {
			continue;
		}

		hr1 = m_rgItems[i]->get_DnsName ( &strDnsName );

		if ( SUCCEEDED(hr1) &&
			!lstrcmpi ( strDnsName, strDnsNameToFind ) ) {

			lResult = i;
			break;
		}
	}

	*pIndex = lResult;
	return NOERROR;
}

STDMETHODIMP 
CTcpAccessExceptions::FindIpIndex (
	long	lIpAddressToFind,
	long	lIpMaskToFind,
	long *	pIndex 
	)
{
	long		lResult	= -1;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		BOOL		fIsIpAddress	= FALSE;
		long		lIpAddress;
		long		lIpMask;

		m_rgItems[i]->get_IsIpAddress ( &fIsIpAddress );
		if ( !fIsIpAddress ) {
			continue;
		}

		m_rgItems[i]->get_IpAddress ( &lIpAddress );
		m_rgItems[i]->get_IpMask ( &lIpMask );

		if ( lIpAddress == lIpAddressToFind && lIpMask == lIpMaskToFind ) {
			lResult = i;
			break;
		}
	}

	*pIndex = lResult;
	return NOERROR;
}

STDMETHODIMP CTcpAccessExceptions::Clear ( )
{
	delete [] m_rgItems;
	m_rgItems	= NULL;
	m_cCount		= 0;

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccessException::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccessException,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccessException::CTcpAccessException () :
	m_fIsDnsName	( FALSE ),
	m_fIsIpAddress	( FALSE ),
	m_dwIpAddress	( 0 ),
	m_dwIpMask		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
}

CTcpAccessException::~CTcpAccessException ()
{
	// All CComBSTR's are freed automatically.
}

HRESULT 
CTcpAccessException::CreateNew ( 
	LPWSTR strDnsName, 
	ITcpAccessException ** ppNew 
	)
{
	HRESULT		hr;
	CComObject<CTcpAccessException> *	pNew	= NULL;

	hr = CComObject<CTcpAccessException>::CreateInstance ( &pNew );
	BAIL_ON_FAILURE(hr);

	hr = pNew->put_DnsName ( strDnsName );
	BAIL_ON_FAILURE(hr);

	hr = pNew->QueryInterface ( IID_ITcpAccessException, (void **) ppNew );
	BAIL_ON_FAILURE(hr);

Exit:
	if ( FAILED(hr) ) {
		delete pNew;
	}

	return hr;
}

HRESULT 
CTcpAccessException::CreateNew ( 
	DWORD dwIpAddress, 
	DWORD dwIpMask, 
	ITcpAccessException ** ppNew 
	)
{
	HRESULT		hr;
	CComObject<CTcpAccessException> *	pNew	= NULL;

	hr = CComObject<CTcpAccessException>::CreateInstance ( &pNew );
	BAIL_ON_FAILURE(hr);

	hr = pNew->put_IpAddress ( (long) dwIpAddress );
	hr = pNew->put_IpMask ( (long) dwIpMask );

	hr = pNew->QueryInterface ( IID_ITcpAccessException, (void **) ppNew );
	BAIL_ON_FAILURE(hr);

Exit:
	if ( FAILED(hr) ) {
		delete pNew;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccessException::get_IsDnsName ( BOOL * pfIsDnsName )
{
	return StdPropertyGet ( m_fIsDnsName, pfIsDnsName );
}

STDMETHODIMP CTcpAccessException::get_IsIpAddress ( BOOL * pfIsIpAddress )
{
	return StdPropertyGet ( m_fIsIpAddress, pfIsIpAddress );
}

STDMETHODIMP CTcpAccessException::get_DnsName ( BSTR * pstrDnsName )
{
	return StdPropertyGet ( m_strDnsName, pstrDnsName );
}

STDMETHODIMP CTcpAccessException::put_DnsName ( BSTR strDnsName )
{
	HRESULT		hr;

	hr = StdPropertyPut ( &m_strDnsName, strDnsName );
	if ( SUCCEEDED(hr) ) {
		m_fIsDnsName	= TRUE;
		m_fIsIpAddress	= FALSE;
	}
	return hr;
}

STDMETHODIMP CTcpAccessException::get_IpAddress ( long * plIpAddress )
{
	return StdPropertyGet ( m_dwIpAddress, plIpAddress );
}

STDMETHODIMP CTcpAccessException::put_IpAddress ( long lIpAddress )
{
	HRESULT		hr;

	hr = StdPropertyPut ( &m_dwIpAddress, lIpAddress );
	if ( SUCCEEDED(hr) ) {
		m_fIsDnsName	= FALSE;
		m_fIsIpAddress	= TRUE;
	}
	return hr;
}

STDMETHODIMP CTcpAccessException::get_IpMask ( long * plIpMask )
{
	return StdPropertyGet ( m_dwIpMask, plIpMask );
}

STDMETHODIMP CTcpAccessException::put_IpMask ( long lIpMask )
{
	return StdPropertyPut ( &m_dwIpMask, lIpMask );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\oleutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	oleutil.h

Abstract:

	Defines some useful functions for dealing with OLE.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _OLEUTIL_INCLUDED_
#define _OLEUTIL_INCLUDED_

// Dependencies:

class CMultiSz;

// Common Property Operations:

HRESULT StdPropertyGet			( const BSTR strProperty, BSTR * ppstrOut );
HRESULT StdPropertyGet			( long lProperty, long * plOut );
HRESULT StdPropertyGet			( DATE dateProperty, DATE * pdateOut );
inline HRESULT StdPropertyGet	( DWORD lProperty, DWORD * pdwOut );
inline HRESULT StdPropertyGet	( BOOL fProperty, BOOL * plOut );
HRESULT StdPropertyGet			( const CMultiSz * pmszProperty, SAFEARRAY ** ppsaStrings );
HRESULT	StdPropertyGetBit		( DWORD bvBitVector, DWORD dwBit, BOOL * pfOut );

HRESULT StdPropertyPut			( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( long * plProperty, long lNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( DATE * pdateProperty, DATE dateNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
inline HRESULT StdPropertyPut	( DWORD * plProperty, long lNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
inline HRESULT StdPropertyPut	( BOOL * pfProperty, BOOL fNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( CMultiSz * pmszProperty, SAFEARRAY * psaStrings, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT	StdPropertyPutBit		( DWORD * pbvBitVector, DWORD dwBit, BOOL fIn );
inline HRESULT StdPropertyPutServerName	( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );

HRESULT LongArrayToVariantArray ( SAFEARRAY * psaLongs, SAFEARRAY ** ppsaVariants );
HRESULT StringArrayToVariantArray ( SAFEARRAY * psaStrings, SAFEARRAY ** ppsaVariants );
HRESULT VariantArrayToStringArray ( SAFEARRAY * psaVariants, SAFEARRAY ** ppsaStrings );

// Property Field Validation: (based on the mfc DDV_ routines)
// These routines return FALSE if the validation fails.

BOOL PV_MaxChars	( const BSTR strProperty,	DWORD nMaxChars );
BOOL PV_MinMax		( int nProperty,			int nMin,		int nMax );
BOOL PV_MinMax		( DWORD dwProperty,			DWORD dwMin,	DWORD dwMax );
BOOL PV_Boolean		( BOOL fProperty );

// Handing off IDispatch pointers:

template<class T> HRESULT StdPropertyHandoffIDispatch ( 
	REFCLSID clisd, 
	REFIID riid, 
	T ** ppIAdmin, 
	IDispatch ** ppIDispatchResult 
	);

HRESULT StdPropertyGetIDispatch ( REFCLSID clsid, IDispatch ** ppIDispatchResult );

// Internet addresses <-> Strings

BOOL InetAddressToString ( DWORD dwAddress, LPWSTR wszAddress, DWORD cAddress );
BOOL StringToInetAddress ( LPCWSTR wszAddress, DWORD * pdwAddress );

//--------------------------------------------------------------------
// Inlined functions:
//--------------------------------------------------------------------

inline HRESULT StdPropertyGet ( DWORD lProperty, DWORD * pdwOut )
{
	return StdPropertyGet ( (long) lProperty, (long *) pdwOut );
}

inline HRESULT StdPropertyGet ( BOOL fProperty, BOOL * plOut )
{
	// Make sure it's our kind of boolean:
	fProperty = !!fProperty;

	return StdPropertyGet ( (long) fProperty, (long *) plOut );
}

inline HRESULT StdPropertyPut ( DWORD * plProperty, long lNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	return StdPropertyPut ( (long *) plProperty, lNew, pbvChangedProps, dwBitMask );
}

inline HRESULT StdPropertyPut ( BOOL * pfProperty, BOOL fNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	// Make sure it's our kind of boolean:
	fNew = !!fNew;

	return StdPropertyPut ( (long *) pfProperty, (long) fNew, pbvChangedProps, dwBitMask );
}

inline HRESULT StdPropertyPutServerName ( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
    if ( strNew && lstrcmpi ( strNew, _T("localhost") ) == 0 ) {
        // Special case: localhost => ""

        return StdPropertyPut ( pstrProperty, _T(""), pbvChangedProps, dwBitMask );
    }

    return StdPropertyPut ( pstrProperty, strNew, pbvChangedProps, dwBitMask );
}

template<class T>
HRESULT StdPropertyHandoffIDispatch ( REFCLSID clsid, REFIID riid, T ** ppIAdmin, IDispatch ** ppIDispatchResult )
{
	// Validate parameters:
	_ASSERT ( ppIAdmin != NULL );
	_ASSERT ( ppIDispatchResult != NULL );

	if ( ppIAdmin == NULL || ppIDispatchResult == NULL ) {
		return E_POINTER;
	}

	// Variables:
	HRESULT	hr = NOERROR;
	CComPtr<T>	pIAdmin;

	// Zero the out parameters:
	*ppIAdmin 			= NULL;
	*ppIDispatchResult	= NULL;

	// Get the IDispatch pointer to return:
	hr = StdPropertyGetIDispatch ( 
		clsid, 
		ppIDispatchResult
		);
	if ( FAILED (hr) ) {
		goto Error;
	}

	// Get the specific interface pointer:
	hr = (*ppIDispatchResult)->QueryInterface ( riid, (void **) &pIAdmin );
	if ( FAILED (hr) ) {
		goto Error;
	}

	*ppIAdmin = pIAdmin;
	pIAdmin.p->AddRef ();

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatchResult );
	*ppIDispatchResult = NULL;

	return hr;

	// Destructor releases pINntpAdminExpiration
}

#endif // _OLEUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\metautil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metautil.h

Abstract:

	Useful functions for dealing with the metabase.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAUTIL_INCLUDED_
#define _METAUTIL_INCLUDED_

// Dependencies:

#include <iiscnfg.h>	// IIS Metabase Values
class CMultiSz;
class CMetabaseKey;

// Defaults:

#define MD_DEFAULT_TIMEOUT	5000

// Creating a metabase object:

HRESULT CreateMetabaseObject	( LPCWSTR wszMachine, IMSAdminBase ** ppMetabase );

// Metabase property manipulation:

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fDefault, BOOL * pfOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwDefault, DWORD * pdwOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR strDefault, BSTR * pstrOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR mszDefault, CMultiSz * pmszOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BSTR strValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, CMultiSz * pmszValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );

BOOL HasKeyChanged ( IMSAdminBase * pMetabase, METADATA_HANDLE hKey, const FILETIME * pftLastChanged, LPCWSTR wszSubKey = _T("") );

// Metabase lists:

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey );



//
//  Needed by mail
//
inline BOOL StdGetMetabaseProp (CMetabaseKey * pMB, 
                                DWORD dwID, 
                                long lDefault, 
                                long * plOut, 
                                LPCWSTR wszPath = _T(""), 
                                DWORD dwUserType = IIS_MD_UT_SERVER, 
                                DWORD dwFlags = METADATA_INHERIT )
{
    return StdGetMetabaseProp( pMB, dwID, (DWORD)lDefault, (DWORD*)plOut, wszPath, dwUserType,dwFlags);
}


inline BOOL StdPutMetabaseProp (CMetabaseKey * pMB, 
                                DWORD dwID, 
                                long lValue,
                                LPCWSTR wszPath = _T(""), 
                                DWORD dwUserType = IIS_MD_UT_SERVER, 
                                DWORD dwFlags = METADATA_INHERIT )
{
    return StdPutMetabaseProp( pMB, dwID, (DWORD)lValue, wszPath, dwUserType, dwFlags );
}


#endif // _METAUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\metautil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metautil.cpp

Abstract:

	Useful functions for dealing with the metabase

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "smtpcmn.h"

#include "cmultisz.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

// Metabase property manipulation:

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fDefault, BOOL * pfOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp<BOOL>" );

	HRESULT	hr;
	DWORD	dwTemp;

	hr = pMB->GetDword ( wszPath, dwID, &dwTemp, dwFlags, dwUserType );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		// Couldn't find property, use defaults.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );
		dwTemp = fDefault;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	*pfOut = dwTemp;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwDefault, DWORD * pdwOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp<DWORD>" );

	DWORD	dwTemp;
	HRESULT	hr;

	hr = pMB->GetDword ( wszPath, dwID, &dwTemp, dwFlags, dwUserType );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		// Couldn't find property, use defaults.

		DebugTraceX ( 0, "Using default for ID: %d", dwID );
		dwTemp = dwDefault;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	*pdwOut = dwTemp;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR wszDefault, BSTR * pstrOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp <BSTR>" );

	HRESULT	hr			= NOERROR;
	BSTR	strNew 		= NULL;
	DWORD	cbRequired	= 0;
	DWORD	cchRequired	= 0;
	BOOL	fUseDefault	= FALSE;

	// Get the length of the string to retrieve:
	hr = pMB->GetDataSize ( wszPath, dwID, STRING_METADATA, &cbRequired, dwFlags, dwUserType );
	cchRequired	= cbRequired / sizeof ( WCHAR );

	// Is the value there?
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {

		// No, so use the default that was passed in.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		fUseDefault	= TRUE;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	if ( !fUseDefault ) {

		strNew = ::SysAllocStringLen ( NULL, cbRequired );
		if ( !strNew ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		// Get the metabase string:
		hr = pMB->GetString ( wszPath, dwID, strNew, cbRequired, dwFlags, dwUserType );
		BAIL_ON_FAILURE(hr);
	}

	if ( fUseDefault ) {
		// Use the default:
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		strNew = ::SysAllocString ( wszDefault );
		if ( !strNew ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}
	}

	SAFE_FREE_BSTR ( *pstrOut );
	*pstrOut = strNew;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}
	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR mszDefault, CMultiSz * pmszOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp <CMultiSz>" );

	HRESULT	hr			= NOERROR;
	BSTR	strNew 		= NULL;
	DWORD	cbRequired	= 0;
	DWORD	cchRequired	= 0;
	BOOL	fUseDefault	= FALSE;
	LPWSTR	msz			= NULL;

	// Get the length of the string to retrieve:
	hr = pMB->GetDataSize ( wszPath, dwID, MULTISZ_METADATA, &cbRequired, dwFlags, dwUserType );
	cchRequired	= cbRequired / sizeof ( WCHAR );

	// Is the value there?
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {

		// No, so use the default that was passed in.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		fUseDefault	= TRUE;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	if ( !fUseDefault ) {

		msz = new WCHAR [ cchRequired ];
		if ( !msz ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		// Get the metabase string:
		hr = pMB->GetData ( wszPath, dwID, dwUserType, MULTISZ_METADATA, msz, &cbRequired, dwFlags );
		BAIL_ON_FAILURE(hr);

		*pmszOut = msz;
	}

	if ( fUseDefault ) {
		// Use the default:
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		*pmszOut = mszDefault;
	}

	if ( !*pmszOut ) {
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
	}

Exit:
	delete msz;

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}
	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BOOL>" );

	HRESULT		hr;

	hr = pMB->SetDword ( wszPath, dwID, fValue, dwFlags, dwUserType );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <DWORD>" );

	HRESULT		hr;

	hr = pMB->SetDword ( wszPath, dwID, dwValue, dwFlags, dwUserType );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BSTR strValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BSTR>" );

	_ASSERT ( strValue );

	HRESULT		hr;

	if ( !strValue ) {
		// Just skip it, but log the trace.
		FatalTrace ( 0, "strValue should not be NULL here" );
		return TRUE;
	}

	hr = pMB->SetString ( wszPath, dwID, strValue, dwFlags, dwUserType );
	BAIL_ON_FAILURE (hr);

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, CMultiSz * pmszValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BSTR>" );

	_ASSERT ( pmszValue );

	if ( !*pmszValue ) {
		// Just skip it, but log the trace.
		FatalTrace ( 0, "strValue should not be NULL here" );
		return TRUE;
	}

	HRESULT		hr;
	DWORD		cbMultiSz;
	LPCWSTR		wszValue;

	cbMultiSz	= pmszValue->SizeInBytes ();
	wszValue	= *pmszValue;

	hr = pMB->SetData ( wszPath, dwID, dwUserType, MULTISZ_METADATA, (void *) wszValue, cbMultiSz, dwFlags );
	BAIL_ON_FAILURE (hr);

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL HasKeyChanged ( IMSAdminBase * pMetabase, METADATA_HANDLE hKey, const FILETIME * pftLastChanged, LPCWSTR wszSubKey )
{
	TraceFunctEnter ( "HasKeyChanged" );

	FILETIME		ftNew;
	HRESULT			hr		= NOERROR;
	BOOL			fResult	= FALSE;

	if ( pftLastChanged->dwHighDateTime == 0 && pftLastChanged->dwLowDateTime == 0 ) {
		ErrorTrace ( 0, "Last changed time is NULL" );

		// No setting, so say it hasn't changed:
		goto Exit;
	}

	hr = pMetabase->GetLastChangeTime ( hKey, wszSubKey, &ftNew, FALSE );
	if ( FAILED (hr) ) {
		ErrorTrace ( 0, "Failed to get last change time: %x", hr );

		// This is an unexpected error.  Ignore it.
		goto Exit;
	}

	// Has the metabase been changed since last time?

	// Time can't go backwards:
	_ASSERT ( ftNew.dwHighDateTime >= pftLastChanged->dwHighDateTime );
	_ASSERT ( ftNew.dwLowDateTime >= pftLastChanged->dwLowDateTime ||
			ftNew.dwHighDateTime > pftLastChanged->dwHighDateTime );

	if ( ftNew.dwHighDateTime	!= pftLastChanged->dwHighDateTime ||
		 ftNew.dwLowDateTime	!= pftLastChanged->dwLowDateTime ) {

		fResult = TRUE;
	}

Exit:
	TraceFunctLeave ();
	return FALSE;
}

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey )
{
	TraceQuietEnter ( "IsValidIntegerSubKey" );

	WCHAR	wszIntegerKey [ METADATA_MAX_NAME_LEN ];
	DWORD	dwItemValue;

	dwItemValue = _wtoi ( wszSubKey );
	wsprintf ( wszIntegerKey, _T("%d"), dwItemValue );

	// If the key is nonzero AND
	// The key is just the itoa value of the number:
	if ( dwItemValue != 0 &&
		 lstrcmp ( wszIntegerKey, wszSubKey ) == 0 ) {

		 return TRUE;
	}
	else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\oleutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	oleutil.cpp

Abstract:

	Provides Useful functions for dealing with OLE.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "iadm.h"
#include "oleutil.h"
#include "cmultisz.h"
#include "resource.h"

//$-------------------------------------------------------------------
//
//	UpdateChangedMask
//
//	Description:
//
//		Marks a field as changed in the given bit vector
//
//	Parameters:
//
//		pbvChangedProps - points to the bit vector
//		dwBitMask - Bit to turn on. (must have only one bit on)
//
//--------------------------------------------------------------------

static void UpdateChangedMask ( DWORD * pbvChangedProps, DWORD dwBitMask )
{
	if ( pbvChangedProps == NULL ) {
		// Legal, means that the caller doesn't want change tracking.

		return;
	}

	_ASSERT ( dwBitMask != 0 );

	*pbvChangedProps |= dwBitMask;
}

HRESULT LongArrayToVariantArray ( SAFEARRAY * psaLongs, SAFEARRAY ** ppsaVariants )
{
	_ASSERT ( psaLongs );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaVariants;

	*ppsaVariants = NULL;

	_ASSERT ( SafeArrayGetDim ( psaLongs ) == 1 );

	SafeArrayGetLBound ( psaLongs, 1, &lLBound );
	SafeArrayGetUBound ( psaLongs, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaVariants = SafeArrayCreate ( VT_VARIANT, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		long		lTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaLongs, &i, &lTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		V_VT (&var) = VT_I4;
		V_I4 (&var) = lTemp;

		hr = SafeArrayPutElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear ( &var );
	}

	*ppsaVariants	= psaVariants;
Exit:
	return hr;
}

HRESULT StringArrayToVariantArray ( SAFEARRAY * psaStrings, SAFEARRAY ** ppsaVariants )
{
	_ASSERT ( psaStrings );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaVariants;

	*ppsaVariants = NULL;

	_ASSERT ( SafeArrayGetDim ( psaStrings ) == 1 );

	SafeArrayGetLBound ( psaStrings, 1, &lLBound );
	SafeArrayGetUBound ( psaStrings, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaVariants = SafeArrayCreate ( VT_VARIANT, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		CComBSTR	strTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaStrings, &i, &strTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		V_VT (&var) = VT_BSTR;
		V_BSTR (&var) = ::SysAllocString ( strTemp );

		hr = SafeArrayPutElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear ( &var );
	}

	*ppsaVariants	= psaVariants;
Exit:
	return hr;
}

HRESULT VariantArrayToStringArray ( SAFEARRAY * psaVariants, SAFEARRAY ** ppsaStrings )
{
	_ASSERT ( psaVariants );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaStrings;

	_ASSERT ( SafeArrayGetDim ( psaVariants ) == 1 );
	
	*ppsaStrings = NULL;

	SafeArrayGetLBound ( psaVariants, 1, &lLBound );
	SafeArrayGetUBound ( psaVariants, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaStrings = SafeArrayCreate ( VT_BSTR, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		CComBSTR	strTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		strTemp = V_BSTR (&var);

		hr = SafeArrayPutElement ( psaStrings, &i, strTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear (&var);
	}

	*ppsaStrings = psaStrings;
Exit:
	return hr;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGet < BSTR, long, DWORD, DATE >
//
//	Description:
//
//		Performs a default Property Get on a BSTR, long, DWORD or 
//		Ole DATE.
//
//	Parameters:
//
//		Property	- The property to get.
//		pOut		- The resulting copy.
//
//	Returns:
//
//		E_POINTER		- invalid arguments
//		E_OUTOFMEMORY	- Not enough memory to copy
//		NOERROR			- success.
//
//--------------------------------------------------------------------

HRESULT StdPropertyGet ( const BSTR strProperty, BSTR * pstrOut )
{
	TraceQuietEnter ( "StdPropertyGet <BSTR>" );

	_ASSERT ( pstrOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrOut ) );

	if ( pstrOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		return E_POINTER;
	}

	*pstrOut = NULL;

	if ( strProperty == NULL ) {

		// If the property is NULL, use a blank string:
		*pstrOut = ::SysAllocString ( _T("") );
	}
	else {
		_ASSERT ( IS_VALID_STRING ( strProperty ) );

		// Copy the property into the result:
		*pstrOut = ::SysAllocString ( strProperty );
	}

	if ( *pstrOut == NULL ) {

		// Allocation failed.
		FatalTrace ( 0, "Out of memory" );

		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

HRESULT StdPropertyGet ( long lProperty, long * plOut )
{
	TraceQuietEnter ( "StdPropertyGet <long>" );

	_ASSERT ( plOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plOut ) );

	if ( plOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		return E_POINTER;
	}

	*plOut = lProperty;
	return NOERROR;
}

HRESULT StdPropertyGet ( DATE dateProperty, DATE * pdateOut )
{
	TraceQuietEnter ( "StdPropertyGet <DATE>" );

	_ASSERT ( pdateOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pdateOut ) );

	if ( pdateOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		return E_POINTER;
	}
	
	*pdateOut = dateProperty;
	return NOERROR;
}

HRESULT StdPropertyGet ( const CMultiSz * pmszProperty, SAFEARRAY ** ppsaStrings )
{
	TraceFunctEnter ( "StdPropertyGet <MULTI_SZ>" );

	_ASSERT ( pmszProperty );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaStrings ) );

	HRESULT		hr	= NOERROR;

	*ppsaStrings = pmszProperty->ToSafeArray ( );

	if ( *ppsaStrings == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT	StdPropertyGetBit ( DWORD bvBitVector, DWORD dwBit, BOOL * pfOut )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pfOut ) );

	if ( !pfOut ) {
		return E_POINTER;
	}

	*pfOut	= GetBitFlag ( bvBitVector, dwBit );

	return NOERROR;
}

//$-------------------------------------------------------------------
//
//	StdPropertyPut <BSTR, long, DWORD or DATE>
//
//	Description:
//
//		Performs a default Property Put on a BSTR, long, DWORD or
//		Ole date.
//
//	Parameters:
//
//		pProperty	- The property to put.
//		New			- The new value.
//		pbvChangedProps [optional] - Bit Vector which holds which
//				properties have changed.
//		dwBitMask [optional] - This property's bitmask for the 
//				changed bit vector.
//
//	Returns:
//
//		E_POINTER - invalid arguments
//		E_OUTOFMEMORY - Not enough memory to copy
//		NOERROR - success.
//
//--------------------------------------------------------------------

HRESULT StdPropertyPut ( 
	BSTR * pstrProperty, 
	const BSTR strNew, 
	DWORD * pbvChangedProps, // = NULL 
	DWORD dwBitMask // = 0 
	)
{
	TraceQuietEnter ( "StdPropertyPut <BSTR>" );

	// Validate Parameters:
	_ASSERT ( pstrProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrProperty ) );

	_ASSERT ( strNew != NULL );
	_ASSERT ( IS_VALID_STRING ( strNew ) );

	if ( pstrProperty == NULL ) {
		FatalTrace ( 0, "Bad property pointer" );
		return E_POINTER;
	}

	if ( strNew == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	HRESULT	hr	= NOERROR;
	BSTR	strCopy = NULL;

	// Copy the new string:
	strCopy = ::SysAllocString ( strNew );

	if ( strCopy == NULL ) {
		hr = E_OUTOFMEMORY;

		FatalTrace ( 0, "Out of memory" );
		goto Error;
	}

	// Update the changed bit, if necessary:
	if ( *pstrProperty && lstrcmp ( *pstrProperty, strCopy ) != 0 ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	// Replace the old property with the new one.
	SAFE_FREE_BSTR ( *pstrProperty );

	*pstrProperty = strCopy;

Error:
	return hr;
}

HRESULT StdPropertyPut ( 
	long * plProperty, 
	long lNew, 
	DWORD * pbvChangedProps, // = NULL 
	DWORD dwBitMask // = 0
	)
{
	TraceQuietEnter ( "StdPropertyPut <long>" );

	_ASSERT ( plProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plProperty ) );

	if ( plProperty == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	if ( *plProperty != lNew ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	*plProperty = lNew;
	return NOERROR;
}

HRESULT StdPropertyPut ( 
	DATE * pdateProperty, 
	DATE dateNew, 
	DWORD * pbvChangedProps, // = NULL
	DWORD dwBitMask // = 0
	)
{
	TraceQuietEnter ( "StdPropertyPut <DATE>" );

	_ASSERT ( pdateProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pdateProperty ) );

	if ( pdateProperty == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	if ( *pdateProperty != dateNew ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	*pdateProperty = dateNew;
	return NOERROR;
}

HRESULT StdPropertyPut ( CMultiSz * pmszProperty, SAFEARRAY * psaStrings, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	TraceFunctEnter ( "StdPropertyPut <MULTI_SZ>" );

	_ASSERT ( IS_VALID_IN_PARAM ( psaStrings ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( pmszProperty ) );

	if ( psaStrings == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	HRESULT		hr	= NOERROR;

	pmszProperty->FromSafeArray ( psaStrings );

	if ( !*pmszProperty ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Don't want to deal with comparing these properties:
	UpdateChangedMask ( pbvChangedProps, dwBitMask );

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT	StdPropertyPutBit ( DWORD * pbvBitVector, DWORD dwBit, BOOL fIn )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pbvBitVector ) );
	_ASSERT ( dwBit );

	SetBitFlag ( pbvBitVector, dwBit, fIn );

	return NOERROR;
}

//$-------------------------------------------------------------------
//
//	PV_MaxChars
//
//	Description:
//
//		Validates a string to make sure it's not too long.
//
//	Parameters:
//
//		strProperty - the string to check
//		nMaxChars - the maximum number of characters in the string,
//			not including the NULL terminator.
//
//	Returns:
//
//		FALSE if the string is too long.
//
//--------------------------------------------------------------------

BOOL PV_MaxChars ( const BSTR strProperty, DWORD nMaxChars )
{
	TraceQuietEnter ( "PV_MaxChars" );

	_ASSERT ( strProperty != NULL );
	_ASSERT ( IS_VALID_STRING ( strProperty ) );

	_ASSERT ( nMaxChars > 0 );

	if ( strProperty == NULL ) {
		// This error should be caught somewhere else.
		return TRUE;
	}

	if ( (DWORD) lstrlen ( strProperty ) > nMaxChars ) {
		ErrorTrace ( 0, "String too long" );
		return FALSE;
	}

	return TRUE;
}

//$-------------------------------------------------------------------
//
//	PV_MinMax <int, dword>
//
//	Description:
//
//		Makes sure a property is within a given range.
//
//	Parameters:
//
//		nProperty - the value to test
//		nMin - The minimum value the property could have
//		nMax - The maximum value the property could have
//
//	Returns:
//
//		TRUE if the property is in the range (inclusive).
//
//--------------------------------------------------------------------

BOOL PV_MinMax ( int nProperty, int nMin, int nMax )
{
	TraceQuietEnter ( "PV_MinMax" );

	_ASSERT ( nMin <= nMax );

	if ( nProperty < nMin || nProperty > nMax ) {
		ErrorTrace ( 0, "Integer out of range" );
		return FALSE;
	}
	return TRUE;
}

BOOL PV_MinMax ( DWORD dwProperty, DWORD dwMin, DWORD dwMax )
{
	TraceQuietEnter ( "PV_MinMax" );

	_ASSERT ( dwMin <= dwMax );

	if ( dwProperty < dwMin || dwProperty > dwMax ) {

		ErrorTrace ( 0, "Dword out of range" );
		return FALSE;
	}
	return TRUE;
}

BOOL PV_Boolean		( BOOL fProperty )
{
	TraceQuietEnter ( "PV_Boolean" );

	if ( fProperty != TRUE && fProperty != FALSE ) {

		ErrorTrace ( 0, "Boolean property is not true or false" );
		return FALSE;
	}

	return TRUE;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGetIDispatch
//
//	Description:
//
//		Gets a IDispatch pointer for the given cLSID
//
//	Parameters:
//
//		clsid		- OLE CLSID of the object
//		ppIDipsatch	- the IDispatch pointer to that object.
//
//	Returns:
//
//		E_POINTER	- invalid argument
//		NOERROR		- Success
//		Others - defined by CoCreateInstance.
//
//--------------------------------------------------------------------

HRESULT StdPropertyGetIDispatch ( 
	REFCLSID clsid, 
	IDispatch ** ppIDispatch 
	)
{
	TraceFunctEnter ( "StdPropertyGetIDispatch" );

	CComPtr<IDispatch>	pNewIDispatch;
	HRESULT				hr = NOERROR;

	_ASSERT ( ppIDispatch );

	if ( ppIDispatch == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return E_POINTER;
	}

	*ppIDispatch = NULL;

	hr = ::CoCreateInstance ( 
		clsid,
		NULL, 
		CLSCTX_ALL, 
		IID_IDispatch,
		(void **) &pNewIDispatch
		);

	if ( FAILED (hr) ) {
		DebugTraceX ( 0, "CoCreate(IDispatch) failed %x", hr );
		FatalTrace ( 0, "Failed to create IDispatch" );
		goto Exit;
	}

	*ppIDispatch = pNewIDispatch;
	pNewIDispatch.p->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// Destructor releases pNewIDispatch
}

//$-------------------------------------------------------------------
//
//	InetAddressToString
//
//	Description:
//
//		Converts a DWORD with an ip address to a string in the form
//		"xxx.xxx.xxx.xxx"
//
//	Parameters:
//
//		dwAddress	- The address to convert
//		wszAddress	- The resulting string
//		cAddress	- The maximum size of the resulting string
//
//	Returns:
//
//		TRUE if succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL InetAddressToString ( DWORD dwAddress, LPWSTR wszAddress, DWORD cAddress )
{
	TraceFunctEnter ( "InetAddressToString" );

	_ASSERT ( wszAddress );

	if ( wszAddress == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	struct in_addr	addr;
	LPSTR			szAnsiAddress;
	DWORD			cchCopied;

	addr.s_addr = dwAddress;

	szAnsiAddress = inet_ntoa ( addr );

	if ( szAnsiAddress == NULL ) {
		ErrorTraceX ( 0, "inet_ntoa failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	cchCopied = MultiByteToWideChar ( 
		CP_ACP, 
		MB_PRECOMPOSED,
		szAnsiAddress,
		-1,
		wszAddress,
		cAddress
		);

	if ( cchCopied == 0 ) {
		ErrorTraceX ( 0, "MultiByteToWideChar failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	TraceFunctLeave ();
	return TRUE;
}

//$-------------------------------------------------------------------
//
//	StringToInetAddress
//
//	Description:
//
//		Converts a string in the form "xxx.xxx.xxx.xxx" to a DWORD
//		IP Address.
//
//	Parameters:
//
//		wszAddress	- The string to convert
//		pdwAddress	- The resulting address
//
//	Returns:
//
//		TRUE if succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL StringToInetAddress ( LPCWSTR wszAddress, DWORD * pdwAddress )
{
	TraceFunctEnter ( "StringToInetAddress" );

	_ASSERT ( wszAddress );
	_ASSERT ( pdwAddress );

	if ( wszAddress == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	if ( pdwAddress == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	char	szAnsiAddress[100];
	DWORD	cchCopied;

	*pdwAddress = 0;

	cchCopied = WideCharToMultiByte ( 
		CP_ACP, 
		0, 
		wszAddress, 
		-1, 
		szAnsiAddress, 
		sizeof ( szAnsiAddress ),
		NULL,
		NULL
		);

	if ( cchCopied == 0 ) {
		ErrorTraceX ( 0, "MultiByteToWideChar failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	*pdwAddress = inet_addr ( szAnsiAddress );

	if ( !*pdwAddress ) {
		ErrorTraceX ( 0, "inet_addr failed: %x", GetLastError () );
	}

	TraceFunctLeave ();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\metafact.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metafact.cpp

Abstract:

	The CMetabaseFactory class.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "oleutil.h"

#include "metautil.h"
#include "metafact.h"

CMetabaseFactory::CMetabaseFactory ( ) :
	m_wszServerName	( NULL ),
	m_pMetabase		( NULL )
{
}

CMetabaseFactory::~CMetabaseFactory ()
{
	if ( m_wszServerName ) {
		delete m_wszServerName;
		m_wszServerName = NULL;
	}

	DestroyMetabaseObject ( );
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::DestroyMetabaseObject
//
//	Description:
//
//		Destroys the current metabase object.  This includes calling
//		the terminate routine on the metabase.
//
//--------------------------------------------------------------------

void CMetabaseFactory::DestroyMetabaseObject ( )
{
	TraceQuietEnter ( "CMetabaseFactory::DestroyMetabaseObject" );
	
	if ( m_pMetabase ) {
		_VERIFY ( m_pMetabase->Release () == 0 );
		m_pMetabase = NULL;
	}
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::GetMetabaseObject
//
//	Description:
//
//		Returns an interface to the metabase.  If the metabase object
//		hasn't been created on the same machine, it is created.
//
//	Parameters:
//
//		wszServer - remote machine to create object on, or NULL for local machine.
//		ppMetabaseResult - returns the interface pointer if successful.
//			client has the responsibility to Release this pointer.
//
//	Returns:
//
//		hresult.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseFactory::GetMetabaseObject	( LPCWSTR wszServer, IMSAdminBase ** ppMetabaseResult )
{
	TraceFunctEnter ( "CMetabaseFactory::GetMetabaseObject" );

	// Validate parameters:
	_ASSERT ( ppMetabaseResult != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppMetabaseResult ) );

	if ( ppMetabaseResult == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad Return Pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}
	
	// Variables:
	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pNewMetabase;

	// Zero the out parameter:
	*ppMetabaseResult = NULL;

	// A server name of "" should be NULL:
	if ( wszServer && (*wszServer == NULL || !lstrcmpi(wszServer, _T("localhost")) ) ) {
		wszServer = NULL;
	}

	if ( IsCachedMetabase ( wszServer ) ) {
		// We've already got this metabase pointer.  Just return it.

		DebugTrace ( (LPARAM) this, "Returning Cached metabase" );
		_ASSERT ( m_pMetabase );

		*ppMetabaseResult = m_pMetabase;
		m_pMetabase->AddRef ();

		hr = NOERROR;
		goto Exit;
	}

	// We have to create the metabase object:
	StateTrace ( (LPARAM) this, "Creating new metabase" );

	// Destroy the old metabase object:
	DestroyMetabaseObject ( );

	// Setup the server name field:
	if ( !SetServerName ( wszServer ) ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// m_wszServer = NULL is valid, it means the local machine.

	hr = CreateMetabaseObject ( m_wszServerName, &pNewMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Save the metabase pointer:
	m_pMetabase	= pNewMetabase;
	pNewMetabase.p->AddRef ();

	// Return the interface pointer:
	*ppMetabaseResult = pNewMetabase;
	pNewMetabase.p->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// pMetabase will be released automatically.
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::IsCachedMetabase
//
//	Description:
//
//		Returns TRUE if we have a metabase for the given server
//
//	Parameters:
//
//		wszServer - remote machine or NULL
//
//	Returns:
//
//		TRUE if we have a pointer already, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL CMetabaseFactory::IsCachedMetabase ( LPCWSTR wszServer )
{
	if ( !m_pMetabase ) {
		// We don't even have a cached metabase object.
		return FALSE;
	}

	if (
		// Both are the local machine OR
		( m_wszServerName == NULL && wszServer == NULL ) ||
		// Both are the same remote machine
		( m_wszServerName && wszServer && !lstrcmpi ( m_wszServerName, wszServer ) ) ) {

		// It's a match
		return TRUE;
	}

	// No dice...
	return FALSE;
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::SetServerName
//
//	Description:
//
//		Sets the m_wszServerName string.
//
//	Parameters:
//
//		wszServer - The new servername.  Can be NULL.
//
//	Returns:
//
//		FALSE on failure due to lack of memory.
//
//--------------------------------------------------------------------

BOOL CMetabaseFactory::SetServerName ( LPCWSTR wszServer ) 
{
	TraceQuietEnter ( "CMetabaseFactory::SetServerName" );

	delete m_wszServerName;
	m_wszServerName = NULL;

	if ( wszServer != NULL ) {
		_ASSERT ( IS_VALID_STRING ( wszServer ) );

		m_wszServerName = new WCHAR [ lstrlen ( wszServer ) + 1 ];

		if ( m_wszServerName == NULL ) {
			FatalTrace ( (LPARAM) this, "Out of Memory" );
			return FALSE;
		}

		lstrcpy ( m_wszServerName, wszServer );
	}
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smtpadm.rc
//
#define IDS_SMTPADMIN_DESC              1
#define IDS_SMTPADMIN_SERVICE_DESC      2
#define IDS_SMTPADMIN_VIRTUALSERVER_DESC 3
#define IDS_SMTPADMIN_VIRTUALDIRECTORY_DESC 4
#define IDS_SMTPADMIN_SESSIONS_DESC     5
#define IDS_SMTPADMIN_ALIAS_DESC        6
#define IDS_SMTPADMIN_USER_DESC         7
#define IDS_SMTPADMIN_DL_DESC           8
#define IDS_SMTPADMIN_DOMAIN_DESC       9
#define IDS_TCPACCESS_DESC              10
#define IDS_TCPACCESSEXCEPTIONS_DESC    11
#define IDS_TCPACCESSEXCEPTION_DESC     12
#define IDS_SMTPEXCEPTION_DIDNT_ENUMERATE 200
#define IDS_SMTPEXCEPTION_DIDNT_SET_CURSOR 201
#define IDS_SMTPEXCEPTION_INVALID_INDEX 202
#define IDS_SMTPEXCEPTION_MUST_SUPPLY_USERNAME_OR_IPADDRESS 203
#define IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO 204
#define IDS_SMTPEXCEPTION_DIDNT_CALL_GET 205
#define IDS_SMTPEXCEPTION_STRING_TOO_LONG 206
#define IDS_SMTPEXCEPTION_PROPERTY_OUT_OF_RANGE 207
#define IDS_SMTPEXCEPTION_DIDNT_FIND    208
#define LANGID_US                       0409
#define IDS_UNKNOWN_ERROR               500
#define IDS_SMTPEXCEPTION_INVALID_ADDRESS 501
#define IDS_SMTPEXCEPTION_CANT_DEL_DEFAULT_DOMAIN 502

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\rtsrc.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

        rtsrc.h

Abstract:

        Implementation of IRoutingSource interface

Author:

        Fei Su (feisu)       9/22/97    Created.

Revision History:

--*/


#include "stdafx.h"
#include "smtpadm.h"
#include "smtpprop.h"
#include "rtsrc.h"
#include "oleutil.h"
#include "metautil.h"


// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_IRoutingSource


#define RS_RELATIVE_NAME            _T("RoutingSources")


#define ID_DS_TYPE                      0
#define ID_DS_DATA_DIRECTORY            1
#define ID_DS_DEFAULT_MAIL_ROOT         2
#define ID_DS_BIND_TYPE                 3
#define ID_DS_SCHEMA_TYPE               4
#define ID_DS_HOST                      5
#define ID_DS_NAMING_CONTEXT            6
#define ID_DS_ACCOUNT                   7
#define ID_DS_PASSWORD                  8

#define DEFAULT_DS_TYPE                 _T("LDAP")
#define DEFAULT_DS_DATA_DIRECTORY       _T("")
#define DEFAULT_DS_DEFAULT_MAIL_ROOT    _T("/Mailbox")
#define DEFAULT_DS_BIND_TYPE            _T("None")
#define DEFAULT_DS_SCHEMA_TYPE          _T("Exchange5")
#define DEFAULT_DS_HOST                 _T("")
#define DEFAULT_DS_NAMING_CONTEXT       _T("")
#define DEFAULT_DS_ACCOUNT              _T("")
#define DEFAULT_DS_PASSWORD             _T("")


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CRoutingSource::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IRoutingSource,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CRoutingSource::get_Type( BSTR * pstrType )
{
    return StdPropertyGet ( m_strType, pstrType );
}

STDMETHODIMP CRoutingSource::put_Type( BSTR strType )
{
    return StdPropertyPut ( &m_strType, strType, &m_dwFC, BitMask(ID_DS_TYPE));
}


STDMETHODIMP CRoutingSource::get_DataDirectory( BSTR * pstrDataDirectory )
{
    return StdPropertyGet ( m_strDataDirectory, pstrDataDirectory );
}

STDMETHODIMP CRoutingSource::put_DataDirectory( BSTR strDataDirectory )
{
    return StdPropertyPut ( &m_strDataDirectory, strDataDirectory, &m_dwFC, BitMask(ID_DS_DATA_DIRECTORY) );
}


STDMETHODIMP CRoutingSource::get_DefaultMailRoot( BSTR * pstrDefaultMailRoot )
{
    return StdPropertyGet ( m_strDefaultMailroot, pstrDefaultMailRoot );
}

STDMETHODIMP CRoutingSource::put_DefaultMailRoot( BSTR strDefaultMailRoot )
{
    return StdPropertyPut ( &m_strDefaultMailroot, strDefaultMailRoot, &m_dwFC, BitMask(ID_DS_DEFAULT_MAIL_ROOT) );
}


STDMETHODIMP CRoutingSource::get_BindType( BSTR * pstrBindType )
{
    return StdPropertyGet ( m_strBindType, pstrBindType );
}

STDMETHODIMP CRoutingSource::put_BindType( BSTR strBindType )
{
    return StdPropertyPut ( &m_strBindType, strBindType, &m_dwFC, BitMask(ID_DS_BIND_TYPE) );
}


STDMETHODIMP CRoutingSource::get_SchemaType( BSTR * pstrSchemaType )
{
    return StdPropertyGet ( m_strSchemaType, pstrSchemaType );
}

STDMETHODIMP CRoutingSource::put_SchemaType( BSTR strSchemaType )
{
    return StdPropertyPut ( &m_strSchemaType, strSchemaType, &m_dwFC, BitMask(ID_DS_SCHEMA_TYPE) );
}


STDMETHODIMP CRoutingSource::get_Host( BSTR * pstrHost )
{
    return StdPropertyGet ( m_strHost, pstrHost );
}

STDMETHODIMP CRoutingSource::put_Host( BSTR strHost )
{
    return StdPropertyPut ( &m_strHost, strHost, &m_dwFC, BitMask(ID_DS_HOST) );
}



STDMETHODIMP CRoutingSource::get_NamingContext( BSTR * pstrNamingContext )
{
    return StdPropertyGet ( m_strNamingContext, pstrNamingContext );
}

STDMETHODIMP CRoutingSource::put_NamingContext( BSTR strNamingContext )
{
    return StdPropertyPut ( &m_strNamingContext, strNamingContext, &m_dwFC, BitMask(ID_DS_NAMING_CONTEXT) );
}


STDMETHODIMP CRoutingSource::get_Account( BSTR * pstrAccount )
{
    return StdPropertyGet ( m_strAccount, pstrAccount );
}

STDMETHODIMP CRoutingSource::put_Account( BSTR strAccount )
{
    return StdPropertyPut ( &m_strAccount, strAccount, &m_dwFC, BitMask(ID_DS_ACCOUNT) );
}


STDMETHODIMP CRoutingSource::get_Password( BSTR * pstrPassword )
{
    return StdPropertyGet ( m_strPassword, pstrPassword );
}

STDMETHODIMP CRoutingSource::put_Password( BSTR strPassword )
{
    return StdPropertyPut ( &m_strPassword, strPassword, &m_dwFC, BitMask(ID_DS_PASSWORD) );
}


///////////////////////////////////////////////////////////////////
//  Get / Set methods (internal)
///////////////////////////////////////////////////////////////////

HRESULT CRoutingSource::Get(CMetabaseKey * pMBVirtualServer)
{
    TraceFunctEnter ( "CRoutingSource::Get" );
    HRESULT hr = NOERROR;

    if( !pMBVirtualServer )
        BAIL_WITH_FAILURE(hr, E_POINTER);

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_TYPE, DEFAULT_DS_TYPE, &m_strType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_DATA_DIRECTORY, DEFAULT_DS_DATA_DIRECTORY, &m_strDataDirectory, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_DEFAULT_MAIL_ROOT, DEFAULT_DS_DEFAULT_MAIL_ROOT, &m_strDefaultMailroot, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_BIND_TYPE, DEFAULT_DS_BIND_TYPE, &m_strBindType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_SCHEMA_TYPE, DEFAULT_DS_SCHEMA_TYPE, &m_strSchemaType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_HOST, DEFAULT_DS_HOST, &m_strHost, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_NAMING_CONTEXT, DEFAULT_DS_NAMING_CONTEXT, &m_strNamingContext, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_ACCOUNT, DEFAULT_DS_ACCOUNT, &m_strAccount, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_PASSWORD, DEFAULT_DS_PASSWORD, &m_strPassword, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());


Exit:
    TraceFunctLeave ();
    return hr;
}


HRESULT CRoutingSource::Set(CMetabaseKey * pMBVirtualServer)
{
    TraceFunctEnter ( "CRoutingSource::Set" );
    HRESULT hr = NOERROR;

    if( !pMBVirtualServer )
        BAIL_WITH_FAILURE(hr, E_POINTER);

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_TYPE)) && 
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_TYPE, m_strType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_DATA_DIRECTORY)) && 
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_DATA_DIRECTORY, m_strDataDirectory, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_DEFAULT_MAIL_ROOT)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_DEFAULT_MAIL_ROOT, m_strDefaultMailroot, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_BIND_TYPE)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_BIND_TYPE, m_strBindType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_SCHEMA_TYPE)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_SCHEMA_TYPE, m_strSchemaType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_HOST)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_HOST, m_strHost, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_NAMING_CONTEXT)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_NAMING_CONTEXT, m_strNamingContext, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_ACCOUNT)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_ACCOUNT, m_strAccount, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_PASSWORD)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_PASSWORD, m_strPassword, RS_RELATIVE_NAME, IIS_MD_UT_SERVER, METADATA_SECURE | METADATA_INHERIT) )
        BAIL_WITH_FAILURE(hr, GetLastError());


Exit:
    TraceFunctLeave ();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\service.h ===
// expire.h : Declaration of the CSmtpAdminService


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Dependencies
/////////////////////////////////////////////////////////////////////////////

#include "metafact.h"
#include "cmultisz.h"

struct IMSAdminBase;

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminService : 
	public CComDualImpl<ISmtpAdminService, &IID_ISmtpAdminService, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminService,&CLSID_CSmtpAdminService>
{
public:
	CSmtpAdminService();
	virtual ~CSmtpAdminService ();
BEGIN_COM_MAP(CSmtpAdminService)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmtpAdminService)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminService) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminService, _T("Smtpadm.Service.1"), _T("Smtpadm.Service"), IDS_SMTPADMIN_SERVICE_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISmtpAdminService
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which Server to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	// No instance for the server interface

	// Server Properties:

	STDMETHODIMP	get_ServerBindings	( SAFEARRAY ** ppsastrServerBindings );
	STDMETHODIMP	put_ServerBindings	( SAFEARRAY * pstrServerBindings );

	STDMETHODIMP	get_ServerBindingsVariant	( SAFEARRAY ** ppsastrServerBindings );
	STDMETHODIMP	put_ServerBindingsVariant	( SAFEARRAY * pstrServerBindings );

	STDMETHODIMP	get_SecureBindings	( SAFEARRAY ** ppsastrSecureBindings );
	STDMETHODIMP	put_SecureBindings	( SAFEARRAY * pstrSecureBindings );

	STDMETHODIMP	get_SecureBindingsVariant	( SAFEARRAY ** ppsastrSecureBindings );
	STDMETHODIMP	put_SecureBindingsVariant	( SAFEARRAY * pstrSecureBindings );

	STDMETHODIMP	get_Port			( long * lPort );
	STDMETHODIMP	put_Port			( long lPort );

	STDMETHODIMP	get_SSLPort			( long * lSSLPort );
	STDMETHODIMP	put_SSLPort			( long lSSLPort );

	STDMETHODIMP	get_OutboundPort	( long * lOutboundPort );
	STDMETHODIMP	put_OutboundPort	( long lOutboundPort );

	STDMETHODIMP	get_HopCount		( long * lHopCount );
	STDMETHODIMP	put_HopCount		( long lHopCount );

	STDMETHODIMP	get_SmartHost		( BSTR * pstrSmartHost );
	STDMETHODIMP	put_SmartHost		( BSTR strSmartHost );

	STDMETHODIMP	get_EnableDNSLookup	( BOOL * pfEnableDNSLookup );
	STDMETHODIMP	put_EnableDNSLookup	( BOOL fEnableDNSLookup );

	STDMETHODIMP	get_PostmasterEmail	( BSTR * pstrPostmasterEmail );
	STDMETHODIMP	put_PostmasterEmail	( BSTR strPostmasterEmail );

	STDMETHODIMP	get_PostmasterName	( BSTR * pstrPostmasterName );
	STDMETHODIMP	put_PostmasterName	( BSTR strPostmasterName );

	STDMETHODIMP	get_DefaultDomain	( BSTR * pstrDefaultDomainName );
	STDMETHODIMP	put_DefaultDomain	( BSTR strDefaultDomainName );

	STDMETHODIMP	get_FQDN			( BSTR * pstrFQDN );
	STDMETHODIMP	put_FQDN			( BSTR strFQDN );

	STDMETHODIMP	get_DropDir			( BSTR * pstrDropDir );
	STDMETHODIMP	put_DropDir			( BSTR strDropDir );

	STDMETHODIMP	get_BadMailDir		( BSTR * pstrBadMailDir );
	STDMETHODIMP	put_BadMailDir		( BSTR strBadMailDir );

	STDMETHODIMP	get_PickupDir		( BSTR * pstrPickupDir );
	STDMETHODIMP	put_PickupDir		( BSTR strPickupDir );

	STDMETHODIMP	get_QueueDir		( BSTR * pstrQueueDir );
	STDMETHODIMP	put_QueueDir		( BSTR strQueueDir );

	STDMETHODIMP	get_MaxInConnection		( long * lMaxInConnection );
	STDMETHODIMP	put_MaxInConnection		( long lMaxInConnection );

	STDMETHODIMP	get_MaxOutConnection	( long * lMaxOutConnection );
	STDMETHODIMP	put_MaxOutConnection	( long lMaxOutConnection );

	STDMETHODIMP	get_InConnectionTimeout	( long * lInConnectionTimeout );
	STDMETHODIMP	put_InConnectionTimeout	( long lInConnectionTimeout );

	STDMETHODIMP	get_OutConnectionTimeout( long * lOutConnectionTimeout );
	STDMETHODIMP	put_OutConnectionTimeout( long lOutConnectionTimeout );

	STDMETHODIMP	get_MaxMessageSize		( long * lMaxMessageSize );
	STDMETHODIMP	put_MaxMessageSize		( long lMaxMessageSize );

	STDMETHODIMP	get_MaxSessionSize		( long * lMaxSessionSize );
	STDMETHODIMP	put_MaxSessionSize		( long lMaxSessionSize );

	STDMETHODIMP	get_MaxMessageRecipients	( long * lMaxMessageRecipients );
	STDMETHODIMP	put_MaxMessageRecipients	( long lMaxMessageRecipients );

	STDMETHODIMP	get_LocalRetries		( long * lLocalRetries );
	STDMETHODIMP	put_LocalRetries		( long lLocalRetries );

	STDMETHODIMP	get_LocalRetryTime		( long * lLocalRetryTime );
	STDMETHODIMP	put_LocalRetryTime		( long lLocalRetryTime );

	STDMETHODIMP	get_RemoteRetries		( long * lRemoteRetries );
	STDMETHODIMP	put_RemoteRetries		( long lRemoteRetries );

	STDMETHODIMP	get_RemoteRetryTime		( long * lRemoteRetryTime );
	STDMETHODIMP	put_RemoteRetryTime		( long lRemoteRetryTime );

	STDMETHODIMP	get_ETRNDays			( long * lETRNDays );
	STDMETHODIMP	put_ETRNDays			( long lETRNDays );

	STDMETHODIMP	get_SendDNRToPostmaster	( BOOL * pfSendDNRToPostmaster );
	STDMETHODIMP	put_SendDNRToPostmaster	( BOOL fSendDNRToPostmaster );

	STDMETHODIMP	get_SendBadmailToPostmaster		( BOOL * pfSendBadmailToPostmaster);
	STDMETHODIMP	put_SendBadmailToPostmaster		( BOOL fSendBadmailToPostmaster );

	STDMETHODIMP	get_RoutingDLL			( BSTR * pstrRoutingDLL );
	STDMETHODIMP	put_RoutingDLL			( BSTR strRoutingDLL );


	STDMETHODIMP	get_RoutingSources		( SAFEARRAY ** ppsastrRoutingSources );
	STDMETHODIMP	put_RoutingSources		( SAFEARRAY * pstrRoutingSources );

	STDMETHODIMP	get_RoutingSourcesVariant	( SAFEARRAY ** ppsastrRoutingSources );
	STDMETHODIMP	put_RoutingSourcesVariant	( SAFEARRAY * pstrRoutingSources );

	STDMETHODIMP	get_LocalDomains		( SAFEARRAY ** ppsastrLocalDomains );
	STDMETHODIMP	put_LocalDomains		( SAFEARRAY * pstrLocalDomains );

	STDMETHODIMP	get_DomainRouting		( SAFEARRAY ** ppsastrDomainRouting );
	STDMETHODIMP	put_DomainRouting		( SAFEARRAY * pstrDomainRouting );

	STDMETHODIMP	get_DomainRoutingVariant	( SAFEARRAY ** ppsastrDomainRouting );
	STDMETHODIMP	put_DomainRoutingVariant	( SAFEARRAY * pstrDomainRouting );

	STDMETHODIMP	get_MasqueradeDomain	( BSTR * pstrMasqueradeDomain );
	STDMETHODIMP	put_MasqueradeDomain	( BSTR strMasqueradeDomain );


	STDMETHODIMP	get_SendNdrTo			( BSTR * pstrAddr );
	STDMETHODIMP	put_SendNdrTo			( BSTR strAddr );

	STDMETHODIMP	get_SendBadTo			( BSTR * pstrAddr );
	STDMETHODIMP	put_SendBadTo			( BSTR strAddr );
	
	STDMETHODIMP	get_RemoteSecurePort	( long * plRemoteSecurePort );
	STDMETHODIMP	put_RemoteSecurePort	( long lRemoteSecurePort );

	STDMETHODIMP	get_ShouldDeliver		( BOOL * pfShouldDeliver );
	STDMETHODIMP	put_ShouldDeliver		( BOOL fShouldDeliver );

	STDMETHODIMP	get_AlwaysUseSsl			( BOOL * pfAlwaysUseSsl );
	STDMETHODIMP	put_AlwaysUseSsl			( BOOL fAlwaysUseSsl );

	STDMETHODIMP	get_LimitRemoteConnections	( BOOL * pfLimitRemoteConnections );
	STDMETHODIMP	put_LimitRemoteConnections	( BOOL fLimitRemoteConnections );

	STDMETHODIMP	get_MaxOutConnPerDomain		( long * plMaxOutConnPerDomain );
	STDMETHODIMP	put_MaxOutConnPerDomain		( long lMaxOutConnPerDomain );

	STDMETHODIMP	get_AllowVerify				( BOOL * pfAllowVerify );
	STDMETHODIMP	put_AllowVerify				( BOOL fAllowVerify	);

	STDMETHODIMP	get_AllowExpand				( BOOL * pfAllowExpand );
	STDMETHODIMP	put_AllowExpand				( BOOL fAllowExpand );

	STDMETHODIMP	get_SmartHostType			( long * plSmartHostType );
	STDMETHODIMP	put_SmartHostType			( long lSmartHostType );

	STDMETHODIMP	get_BatchMessages			( BOOL * pfBatchMessages );
	STDMETHODIMP	put_BatchMessages			( BOOL fBatchMessages );

	STDMETHODIMP	get_BatchMessageLimit		( long * plBatchMessageLimit );
	STDMETHODIMP	put_BatchMessageLimit		( long lBatchMessageLimit );

	STDMETHODIMP	get_DoMasquerade			( BOOL * pfDoMasquerade );
	STDMETHODIMP	put_DoMasquerade			( BOOL fDoMasquerade );

	STDMETHODIMP	get_Administrators			( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_Administrators			( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_AdministratorsVariant	( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_AdministratorsVariant	( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_LogFileDirectory	( BSTR * pstrLogFileDirectory );
	STDMETHODIMP	put_LogFileDirectory	( BSTR strLogFileDirectory );

	STDMETHODIMP	get_LogFilePeriod		( long * lLogFilePeriod );
	STDMETHODIMP	put_LogFilePeriod		( long lLogFilePeriod );

	STDMETHODIMP	get_LogFileTruncateSize	( long * lLogFileTruncateSize );
	STDMETHODIMP	put_LogFileTruncateSize	( long lLogFileTruncateSize );

	STDMETHODIMP	get_LogMethod			( long * lLogMethod );
	STDMETHODIMP	put_LogMethod			( long lLogMethod );

	STDMETHODIMP	get_LogType				( long * lLogType );
	STDMETHODIMP	put_LogType				( long lLogType );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Get ( );
	STDMETHODIMP	Set ( BOOL fFailIfChanged );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;

	long		m_lPort;					// obselete, use server bindings
	CMultiSz    m_mszServerBindings;		// MultiString
	CMultiSz    m_mszSecureBindings;		// MultiString

	long		m_lSSLPort;
	long		m_lOutboundPort;
	long		m_lRemoteSecurePort;

	CComBSTR	m_strSmartHost;
	BOOL		m_fEnableDNSLookup;
	CComBSTR	m_strPostmasterEmail;
	CComBSTR	m_strPostmasterName;

	CComBSTR	m_strFQDN;
	CComBSTR	m_strDefaultDomain;

	CComBSTR	m_strDropDir;
	CComBSTR	m_strBadMailDir;
	CComBSTR	m_strPickupDir;
	CComBSTR	m_strQueueDir;

	long		m_lHopCount;
	long		m_lMaxInConnection;
	long		m_lMaxOutConnection;
	long		m_lInConnectionTimeout;
	long		m_lOutConnectionTimeout;

	long		m_lMaxMessageSize;
	long		m_lMaxSessionSize;
	long		m_lMaxMessageRecipients;

	long		m_lLocalRetries;
	long		m_lLocalRetryTime;
	long		m_lRemoteRetries;
	long		m_lRemoteRetryTime;

	long		m_lETRNDays;

	BOOL		m_fSendDNRToPostmaster;
	BOOL		m_fSendBadmailToPostmaster;

	CComBSTR	m_strRoutingDLL;
	CMultiSz	m_mszRoutingSources;	// MultiString

	CMultiSz    m_mszLocalDomains;		// MultiString
	CMultiSz    m_mszDomainRouting;		// MultiString

	BOOL		m_fDoMasquerade;
	CComBSTR	m_strMasqueradeDomain;

	CComBSTR	m_strNdrAddr;
	CComBSTR	m_strBadAddr;

	BOOL		m_fShouldDeliver;
	BOOL		m_fAlwaysUseSsl;
	BOOL		m_fLimitRemoteConnections;
	long		m_lMaxOutConnPerDomain;

	BOOL		m_fAllowVerify;
	BOOL		m_fAllowExpand;
	long		m_lSmartHostType;

	BOOL		m_fBtachMsgs;
	long		m_lBatchMsgLimit;

	SAFEARRAY *	m_psaAdmins;

	CComBSTR	m_strLogFileDirectory;
	long		m_lLogFilePeriod;
	long		m_lLogFileTruncateSize;
	long		m_lLogMethod;
	long		m_lLogType;

	// Status:
	BOOL		m_fGotProperties;
	DWORD   	m_bvChangedFields;
	FILETIME	m_ftLastChanged;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT 	GetPropertiesFromMetabase	( IMSAdminBase * pMetabase );
	HRESULT 	SendPropertiesToMetabase	( BOOL fFailIfChanged, IMSAdminBase * pMetabase );

	// Validation:
	BOOL		ValidateStrings ( ) const;
	BOOL		ValidateProperties ( ) const;
	void		CorrectProperties ( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\rtsrc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

        rtsrc.h

Abstract:

        Header file for IRoutingSource interface

Author:

        Fei Su (feisu)       9/22/97    Created.

Revision History:

--*/

class CRoutingSource : 
    public CComDualImpl<IRoutingSource, &IID_IRoutingSource, &LIBID_SMTPADMLib>, 
    public ISupportErrorInfo,
    public CComObjectRoot
{
public:
    CRoutingSource() : m_dwFC(0) {}
    virtual ~CRoutingSource(){}

BEGIN_COM_MAP(CRoutingSource)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IRoutingSource)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

/*
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj) ;
*/

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // IRoutingSource properties:
    STDMETHODIMP    get_Type            ( BSTR * pstrType );
    STDMETHODIMP    put_Type            ( BSTR strType );

    STDMETHODIMP    get_DataDirectory   ( BSTR * pstrDataDirectory );
    STDMETHODIMP    put_DataDirectory   ( BSTR strDataDirectory );

    STDMETHODIMP    get_DefaultMailRoot ( BSTR * pstrDefaultMailRoot );
    STDMETHODIMP    put_DefaultMailRoot ( BSTR strDefaultMailRoot );

    STDMETHODIMP    get_BindType        ( BSTR * pstrBindType );
    STDMETHODIMP    put_BindType        ( BSTR strBindType );

    STDMETHODIMP    get_SchemaType      ( BSTR * pstrSchemaType );
    STDMETHODIMP    put_SchemaType      ( BSTR strSchemaType );

    STDMETHODIMP    get_Host            ( BSTR * pstrHost );
    STDMETHODIMP    put_Host            ( BSTR strHost );

    STDMETHODIMP    get_NamingContext   ( BSTR * pstrNamingContext );
    STDMETHODIMP    put_NamingContext   ( BSTR strNamingContext );

    STDMETHODIMP    get_Account         ( BSTR * pstrAccount );
    STDMETHODIMP    put_Account         ( BSTR strAccount );

    STDMETHODIMP    get_Password        ( BSTR * pstrPassword );
    STDMETHODIMP    put_Password        ( BSTR strPassword );

    // Internal methods
    HRESULT         Get(CMetabaseKey * pMBVirtualServer);
    HRESULT         Set(CMetabaseKey * pMBVirtualServer);

private:
    CComBSTR        m_strType;
    CComBSTR        m_strDataDirectory;
    CComBSTR        m_strDefaultMailroot;
    CComBSTR        m_strBindType;
    CComBSTR        m_strSchemaType;
    CComBSTR        m_strHost;
    CComBSTR        m_strNamingContext;
    CComBSTR        m_strAccount;
    CComBSTR        m_strPassword;

    DWORD           m_dwFC;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\sessions.h ===
// sessions.h : Declaration of the CSmtpAdminSessions


#include "resource.h"       // main symbols

/*
typedef SMTP_CONN_USER_ENTRY _SMTP_CONN_USER_ENTRY;
typedef _SMTP_CONN_USER_ENTRY   SMTP_CONN_USER_ENTRY;
typedef _SMTP_CONN_USER_ENTRY * LPSMTP_CONN_USER_ENTRY;
*/

#define MAX_USER_NAME_LENGTH	256

#include "smtpapi.h"

/*
typedef struct _SMTP_CONN_USER_ENTRY {

    FILETIME        SessionStartTime;
    DWORD           IPAddress;          // ipaddress
    DWORD           PortConnected;      // port connected to
    CHAR            UserName[MAX_USER_NAME_LENGTH+1]; // logged on user

} SMTP_CONN_USER_ENTRY, *LPSMTP_CONN_USER_ENTRY;
*/


/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminSessions : 
	public ISmtpAdminSessions,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminSessions,&CLSID_CSmtpAdminSessions>
{
public:
	CSmtpAdminSessions();
	virtual ~CSmtpAdminSessions ();
BEGIN_COM_MAP(CSmtpAdminSessions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminSessions)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminSessions) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminSessions, _T("Smtpadm.Sessions.1"), _T("Smtpadm.Sessions"), IDS_SMTPADMIN_SESSIONS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminSessions
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminSessions
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server			( BSTR * pstrServer );
	STDMETHODIMP	put_Server			( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	STDMETHODIMP	get_Count			( long * plCount );

	STDMETHODIMP	get_UserName		( BSTR * pstrUsername );
	STDMETHODIMP	get_Host			( BSTR * pstrHost );

	STDMETHODIMP	get_UserId				( long * plId );
	STDMETHODIMP	put_UserId				( long lId );

	STDMETHODIMP	get_ConnectTime		( long * plConnectTime );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Enumerate		(  );
	STDMETHODIMP	GetNth			( long lIndex );
	STDMETHODIMP	Terminate		(  );
	STDMETHODIMP	TerminateAll	(  );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	// Property variables:
	DWORD		m_cCount;

	DWORD		m_dwId;

	CComBSTR	m_strUsername;
	CComBSTR	m_strHost;

	DWORD		m_dwConnectTime;
	//DWORD		m_dwPort;	// not used yet

	// Service variables:
	BOOL		m_fSetCursor;

	LPSMTP_CONN_USER_LIST		m_pSessionInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\sessions.cpp ===
// sessions.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "smtpadm.h"
#include "sessions.h"
#include "oleutil.h"
#include "smtpcmn.h"

#include "smtptype.h"
#include "smtpapi.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.Sessions.1")
#define THIS_FILE_IID				IID_ISmtpAdminSessions

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminSessions, CSmtpAdminSessions, IID_ISmtpAdminSessions)

STDMETHODIMP CSmtpAdminSessions::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdminSessions,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CSmtpAdminSessions::CSmtpAdminSessions () :
	m_cCount				( 0 ),
	m_dwId					( 0 ),
	m_dwConnectTime			( 0 ),
	m_pSessionInfo			( NULL ),
	m_fSetCursor			( FALSE )
	// CComBSTR's are initialized to NULL by default.
{
    InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Sessions") );
    m_iadsImpl.SetClass ( _T("IIsSmtpSessions") );
}

CSmtpAdminSessions::~CSmtpAdminSessions ()
{
	if ( m_pSessionInfo ) {
		NetApiBufferFree ( m_pSessionInfo );
	}

	// All CComBSTR's are freed automatically.
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminSessions,m_iadsImpl)


//
//  enum props
//
STDMETHODIMP CSmtpAdminSessions::get_Count ( long * plCount )
{
	// Count should check to be sure the client enumerated.

	return StdPropertyGet ( m_cCount, plCount );
}

STDMETHODIMP CSmtpAdminSessions::get_UserName ( BSTR * pstrUsername )
{
	return StdPropertyGet ( m_strUsername, pstrUsername );
}

STDMETHODIMP CSmtpAdminSessions::get_Host( BSTR * pstrHost )
{
	return StdPropertyGet ( m_strHost, pstrHost );
}

STDMETHODIMP CSmtpAdminSessions::get_UserId ( long * plId )
{
	return StdPropertyGet ( m_dwId, plId );
}

STDMETHODIMP CSmtpAdminSessions::put_UserId ( long lId )
{
	return StdPropertyPut ( &m_dwId, lId );
}

STDMETHODIMP CSmtpAdminSessions::get_ConnectTime ( long * plConnectTime )
{
	return StdPropertyGet ( m_dwConnectTime, plConnectTime );
}



//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminSessions::Enumerate (  )
{
	// Variables:
	HRESULT					hr			= NOERROR;
	NET_API_STATUS			err;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Enumerating loses the cursor:
	m_fSetCursor = FALSE;

	if ( m_pSessionInfo ) {
		NetApiBufferFree ( m_pSessionInfo );
		m_cCount = 0;
	}

	// Call the enumerate sessions RPC:

	err = SmtpGetConnectedUserList (
		m_iadsImpl.QueryComputer(),
		&m_pSessionInfo,
		m_iadsImpl.QueryInstance()
		);

	if( err == NO_ERROR )
	{
		m_cCount = m_pSessionInfo->cEntries;
	}
	else
	{
		hr = SmtpCreateExceptionFromWin32Error ( err );
		goto Exit;
	}

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}
	return hr;
}

STDMETHODIMP CSmtpAdminSessions::GetNth ( long lIndex )
{
	HRESULT		hr	= NOERROR;

	// Did we enumerate first?
	if ( m_pSessionInfo == NULL ) {

		return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_ENUMERATE );
	}
	
	// Is the index valid?
	if ( lIndex < 0 || (DWORD) lIndex >= m_cCount ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	//
	// Copy the properties from m_pSessionInfo [ lIndex ] to member variables:
	//

	// ( CComBSTR handles free-ing of old properties )

	m_dwId			= m_pSessionInfo->aConnUserEntry[ lIndex ].dwUserId;
	m_dwConnectTime	= m_pSessionInfo->aConnUserEntry[ lIndex ].dwConnectTime;

	m_strUsername = m_pSessionInfo->aConnUserEntry[ lIndex ].lpszName;
	if ( m_strUsername == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	m_strHost = m_pSessionInfo->aConnUserEntry[ lIndex ].lpszHost;

	if ( m_strHost == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// GetNth sets the cursor:
	m_fSetCursor = TRUE;

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}
	return hr;
}

STDMETHODIMP CSmtpAdminSessions::Terminate (  )
{
	HRESULT	hr = NOERROR;
	DWORD	err;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Call the TerminateSession RPC:
	err = SmtpDisconnectUser ( 
		m_iadsImpl.QueryComputer(), 
		m_dwId,
		m_iadsImpl.QueryInstance()
		);

	if(  err != NOERROR ) {
		hr = SmtpCreateExceptionFromWin32Error ( err );
		goto Exit;
	}

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}
	return hr;
}

STDMETHODIMP CSmtpAdminSessions::TerminateAll (  )
{

	// Did we enumerate first?
	HRESULT				hr = NOERROR;
	DWORD				ErrResult = 0;
	DWORD				Err;
	DWORD				i;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Make sure the user has enumerated:
	if ( m_pSessionInfo == NULL ) {

		return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_ENUMERATE );
	}

	// For Each Session:
	for ( i = 0; i < m_cCount; i++ ) {

		// Call the terminate session RPC:
		Err = SmtpDisconnectUser ( 
			m_iadsImpl.QueryComputer(), 
			m_pSessionInfo->aConnUserEntry[ i ].dwUserId,
			m_iadsImpl.QueryInstance()
			);

		if ( Err != 0 && ErrResult == 0 ) {
			ErrResult = Err;
		}
	}

	if(  ErrResult != NOERROR ) {
		hr = SmtpCreateExceptionFromWin32Error ( ErrResult );
		goto Exit;
	}

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\service.cpp ===
// server.cpp : Implementation of CSmtpAdminService

#include "stdafx.h"
#include "IADM.h"
#include "imd.h"

#include "smtpadm.h"
#include "ipaccess.h"
#include "oleutil.h"
#include "metautil.h"
#include "smtpcmn.h"
#include "service.h"
#include "virsvr.h"

#include "smtpprop.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.Service.1")
#define THIS_FILE_IID               IID_ISmtpAdminService




/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CSmtpAdminService::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ISmtpAdminService,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

CSmtpAdminService::CSmtpAdminService () :
    m_lPort         ( 25 ),
    m_lLogMethod    ( 0  )
    // CComBSTR's are initialized to NULL by default.
{
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    m_psaAdmins = NULL;
    InitAsyncTrace ( );
}

CSmtpAdminService::~CSmtpAdminService ()
{
    // All CComBSTR's are freed automatically.
    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
    }

    TermAsyncTrace ( );
}

// Which Server to configure:

STDMETHODIMP CSmtpAdminService::get_Server ( BSTR * pstrServer )
{
    return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CSmtpAdminService::put_Server ( BSTR strServer )
{
    // If the server name changes, that means the client will have to
    // call Get again:

    // I assume this here:
    _ASSERT ( sizeof (DWORD) == sizeof (int) );

    return StdPropertyPutServerName ( &m_strServer, strServer, (DWORD *) &m_fGotProperties, 1 );
}

// Server Properties:

STDMETHODIMP CSmtpAdminService::get_ServerBindings( SAFEARRAY ** ppsastrServerBindings )
{
    return StdPropertyGet ( &m_mszServerBindings, ppsastrServerBindings );
}

STDMETHODIMP CSmtpAdminService::put_ServerBindings( SAFEARRAY * pstrServerBindings )
{
    return StdPropertyPut ( &m_mszServerBindings, pstrServerBindings, &m_bvChangedFields, BitMask(ID_SERVER_BINDINGS));
}

STDMETHODIMP CSmtpAdminService::get_ServerBindingsVariant( SAFEARRAY ** ppsavarServerBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrServerBindings        = NULL;

    hr = get_ServerBindings ( &psastrServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrServerBindings, ppsavarServerBindings );

Exit:
    if ( psastrServerBindings ) {
        SafeArrayDestroy ( psastrServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_ServerBindingsVariant( SAFEARRAY * psavarServerBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrServerBindings        = NULL;

    hr = VariantArrayToStringArray ( psavarServerBindings, &psastrServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_ServerBindings ( psastrServerBindings );

Exit:
    if ( psastrServerBindings ) {
        SafeArrayDestroy ( psastrServerBindings );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminService::get_SecureBindings( SAFEARRAY ** ppsastrSecureBindings )
{
    return StdPropertyGet ( &m_mszSecureBindings, ppsastrSecureBindings );
}

STDMETHODIMP CSmtpAdminService::put_SecureBindings( SAFEARRAY * pstrSecureBindings )
{
    return StdPropertyPut ( &m_mszSecureBindings, pstrSecureBindings, &m_bvChangedFields, BitMask(ID_SECURE_BINDINGS));
}

STDMETHODIMP CSmtpAdminService::get_SecureBindingsVariant( SAFEARRAY ** ppsavarSecureBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrSecureServerBindings        = NULL;

    hr = get_SecureBindings ( &psastrSecureServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrSecureServerBindings, ppsavarSecureBindings );

Exit:
    if ( psastrSecureServerBindings ) {
        SafeArrayDestroy ( psastrSecureServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_SecureBindingsVariant( SAFEARRAY * psavarSecureBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrSecureServerBindings        = NULL;

    hr = VariantArrayToStringArray ( psavarSecureBindings, &psastrSecureServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_SecureBindings ( psastrSecureServerBindings );

Exit:
    if ( psastrSecureServerBindings ) {
        SafeArrayDestroy ( psastrSecureServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::get_Port( long * plPort )
{
    return StdPropertyGet ( m_lPort, plPort );
}

STDMETHODIMP CSmtpAdminService::put_Port( long lPort )
{
    return StdPropertyPut ( &m_lPort, lPort, &m_bvChangedFields, BitMask(ID_PORT));
}

STDMETHODIMP CSmtpAdminService::get_SSLPort( long * plSSLPort )
{
    return StdPropertyGet ( m_lSSLPort, plSSLPort );
}

STDMETHODIMP CSmtpAdminService::put_SSLPort( long lSSLPort )
{
    return StdPropertyPut ( &m_lSSLPort, lSSLPort, &m_bvChangedFields, BitMask(ID_SSLPORT));
}

STDMETHODIMP CSmtpAdminService::get_OutboundPort( long * plOutboundPort )
{
    return StdPropertyGet ( m_lOutboundPort, plOutboundPort );
}

STDMETHODIMP CSmtpAdminService::put_OutboundPort( long lOutboundPort )
{
    return StdPropertyPut ( &m_lOutboundPort, lOutboundPort, &m_bvChangedFields, BitMask(ID_OUTBOUNDPORT));
}


STDMETHODIMP CSmtpAdminService::get_HopCount( long * plHopCount )
{
    return StdPropertyGet ( m_lHopCount, plHopCount );
}

STDMETHODIMP CSmtpAdminService::put_HopCount( long lHopCount )
{
    return StdPropertyPut ( &m_lHopCount, lHopCount, &m_bvChangedFields, BitMask(ID_HOP_COUNT));
}

STDMETHODIMP CSmtpAdminService::get_SmartHost( BSTR * pstrSmartHost )
{
    return StdPropertyGet ( m_strSmartHost, pstrSmartHost );
}

STDMETHODIMP CSmtpAdminService::put_SmartHost( BSTR strSmartHost )
{
    return StdPropertyPut ( &m_strSmartHost, strSmartHost, &m_bvChangedFields, BitMask(ID_SMARTHOST));
}

STDMETHODIMP CSmtpAdminService::get_EnableDNSLookup( BOOL * pfEnableDNSLookup )
{
    return StdPropertyGet ( m_fEnableDNSLookup, pfEnableDNSLookup );
}

STDMETHODIMP CSmtpAdminService::put_EnableDNSLookup( BOOL fEnableDNSLookup )
{
    return StdPropertyPut ( &m_fEnableDNSLookup, fEnableDNSLookup, &m_bvChangedFields, BitMask(ID_ENABLEDNSLOOKUP));
}

STDMETHODIMP CSmtpAdminService::get_PostmasterEmail( BSTR * pstrPostmasterEmail )
{
    return StdPropertyGet ( m_strPostmasterEmail, pstrPostmasterEmail );
}

STDMETHODIMP CSmtpAdminService::put_PostmasterEmail( BSTR strPostmasterEmail )
{
    return StdPropertyPut ( &m_strPostmasterEmail, strPostmasterEmail, &m_bvChangedFields, BitMask(ID_POSTMASTEREMAIL));
}

STDMETHODIMP CSmtpAdminService::get_PostmasterName( BSTR * pstrPostmasterName )
{
    return StdPropertyGet ( m_strPostmasterName, pstrPostmasterName );
}

STDMETHODIMP CSmtpAdminService::put_PostmasterName( BSTR strPostmasterName )
{
    return StdPropertyPut ( &m_strPostmasterName, strPostmasterName, &m_bvChangedFields, BitMask(ID_POSTMASTERNAME));
}


STDMETHODIMP CSmtpAdminService::get_DefaultDomain( BSTR * pstrDefaultDomain )
{
    return StdPropertyGet ( m_strDefaultDomain, pstrDefaultDomain );
}

STDMETHODIMP CSmtpAdminService::put_DefaultDomain( BSTR strDefaultDomain )
{
    return StdPropertyPut ( &m_strDefaultDomain, strDefaultDomain, &m_bvChangedFields, BitMask(ID_DEFAULTDOMAIN));
}

STDMETHODIMP CSmtpAdminService::get_FQDN( BSTR * pstrFQDN )
{
    return StdPropertyGet ( m_strFQDN, pstrFQDN );
}

STDMETHODIMP CSmtpAdminService::put_FQDN( BSTR strFQDN )
{
    return StdPropertyPut ( &m_strFQDN, strFQDN, &m_bvChangedFields, BitMask(ID_FQDN));
}

STDMETHODIMP CSmtpAdminService::get_DropDir( BSTR * pstrDropDir )
{
    return StdPropertyGet ( m_strDropDir, pstrDropDir );
}

STDMETHODIMP CSmtpAdminService::put_DropDir( BSTR strDropDir )
{
    return StdPropertyPut ( &m_strDropDir, strDropDir, &m_bvChangedFields, BitMask(ID_DROPDIR));
}


STDMETHODIMP CSmtpAdminService::get_BadMailDir( BSTR * pstrBadMailDir )
{
    return StdPropertyGet ( m_strBadMailDir, pstrBadMailDir );
}

STDMETHODIMP CSmtpAdminService::put_BadMailDir( BSTR strBadMailDir )
{
    return StdPropertyPut ( &m_strBadMailDir, strBadMailDir, &m_bvChangedFields, BitMask(ID_BADMAILDIR));
}

STDMETHODIMP CSmtpAdminService::get_PickupDir( BSTR * pstrPickupDir )
{
    return StdPropertyGet ( m_strPickupDir, pstrPickupDir );
}

STDMETHODIMP CSmtpAdminService::put_PickupDir( BSTR strPickupDir )
{
    return StdPropertyPut ( &m_strPickupDir, strPickupDir, &m_bvChangedFields, BitMask(ID_PICKUPDIR));
}

STDMETHODIMP CSmtpAdminService::get_QueueDir( BSTR * pstrQueueDir )
{
    return StdPropertyGet ( m_strQueueDir, pstrQueueDir );
}

STDMETHODIMP CSmtpAdminService::put_QueueDir( BSTR strQueueDir )
{
    return StdPropertyPut ( &m_strQueueDir, strQueueDir, &m_bvChangedFields, BitMask(ID_QUEUEDIR));
}

STDMETHODIMP CSmtpAdminService::get_MaxInConnection( long * plMaxInConnection )
{
    return StdPropertyGet ( m_lMaxInConnection, plMaxInConnection );
}

STDMETHODIMP CSmtpAdminService::put_MaxInConnection( long lMaxInConnection )
{
    return StdPropertyPut ( &m_lMaxInConnection, lMaxInConnection, &m_bvChangedFields, BitMask(ID_MAXINCONNECTION));
}

STDMETHODIMP CSmtpAdminService::get_MaxOutConnection( long * plMaxOutConnection )
{
    return StdPropertyGet ( m_lMaxOutConnection, plMaxOutConnection );
}

STDMETHODIMP CSmtpAdminService::put_MaxOutConnection( long lMaxOutConnection )
{
    return StdPropertyPut ( &m_lMaxOutConnection, lMaxOutConnection, &m_bvChangedFields, BitMask(ID_MAXOUTCONNECTION));
}

STDMETHODIMP CSmtpAdminService::get_InConnectionTimeout( long * plInConnectionTimeout )
{
    return StdPropertyGet ( m_lInConnectionTimeout, plInConnectionTimeout );
}

STDMETHODIMP CSmtpAdminService::put_InConnectionTimeout( long lInConnectionTimeout )
{
    return StdPropertyPut ( &m_lInConnectionTimeout, lInConnectionTimeout, &m_bvChangedFields, BitMask(ID_INCONNECTIONTIMEOUT));
}

STDMETHODIMP CSmtpAdminService::get_OutConnectionTimeout( long * plOutConnectionTimeout )
{
    return StdPropertyGet ( m_lOutConnectionTimeout, plOutConnectionTimeout );
}

STDMETHODIMP CSmtpAdminService::put_OutConnectionTimeout( long lOutConnectionTimeout )
{
    return StdPropertyPut ( &m_lOutConnectionTimeout, lOutConnectionTimeout, &m_bvChangedFields, BitMask(ID_OUTCONNECTIONTIMEOUT));
}

STDMETHODIMP CSmtpAdminService::get_MaxMessageSize( long * plMaxMessageSize )
{
    return StdPropertyGet ( m_lMaxMessageSize, plMaxMessageSize );
}

STDMETHODIMP CSmtpAdminService::put_MaxMessageSize( long lMaxMessageSize )
{
    return StdPropertyPut ( &m_lMaxMessageSize, lMaxMessageSize, &m_bvChangedFields, BitMask(ID_MAXMESSAGESIZE));
}

STDMETHODIMP CSmtpAdminService::get_MaxSessionSize( long * plMaxSessionSize )
{
    return StdPropertyGet ( m_lMaxSessionSize, plMaxSessionSize );
}

STDMETHODIMP CSmtpAdminService::put_MaxSessionSize( long lMaxSessionSize )
{
    return StdPropertyPut ( &m_lMaxSessionSize, lMaxSessionSize, &m_bvChangedFields, BitMask(ID_MAXSESSIONSIZE));
}
STDMETHODIMP CSmtpAdminService::get_MaxMessageRecipients( long * plMaxMessageRecipients )
{
    return StdPropertyGet ( m_lMaxMessageRecipients, plMaxMessageRecipients );
}

STDMETHODIMP CSmtpAdminService::put_MaxMessageRecipients( long lMaxMessageRecipients )
{
    return StdPropertyPut ( &m_lMaxMessageRecipients, lMaxMessageRecipients, &m_bvChangedFields, BitMask(ID_MAXMESSAGERECIPIENTS));
}

STDMETHODIMP CSmtpAdminService::get_LocalRetries( long * plLocalRetries )
{
    return StdPropertyGet ( m_lLocalRetries, plLocalRetries );
}

STDMETHODIMP CSmtpAdminService::put_LocalRetries( long lLocalRetries )
{
    return StdPropertyPut ( &m_lLocalRetries, lLocalRetries, &m_bvChangedFields, BitMask(ID_LOCALRETRIES));
}

STDMETHODIMP CSmtpAdminService::get_LocalRetryTime( long * plLocalRetryTime )
{
    return StdPropertyGet ( m_lLocalRetryTime, plLocalRetryTime );
}

STDMETHODIMP CSmtpAdminService::put_LocalRetryTime( long lLocalRetryTime )
{
    return StdPropertyPut ( &m_lLocalRetryTime, lLocalRetryTime, &m_bvChangedFields, BitMask(ID_LOCALRETRYTIME));
}

STDMETHODIMP CSmtpAdminService::get_RemoteRetries( long * plRemoteRetries )
{
    return StdPropertyGet ( m_lRemoteRetries, plRemoteRetries );
}

STDMETHODIMP CSmtpAdminService::put_RemoteRetries( long lRemoteRetries )
{
    return StdPropertyPut ( &m_lRemoteRetries, lRemoteRetries, &m_bvChangedFields, BitMask(ID_REMOTERETRIES));
}

STDMETHODIMP CSmtpAdminService::get_RemoteRetryTime( long * plRemoteRetryTime )
{
    return StdPropertyGet ( m_lRemoteRetryTime, plRemoteRetryTime );
}

STDMETHODIMP CSmtpAdminService::put_RemoteRetryTime( long lRemoteRetryTime )
{
    return StdPropertyPut ( &m_lRemoteRetryTime, lRemoteRetryTime, &m_bvChangedFields, BitMask(ID_REMOTERETRYTIME));
}

STDMETHODIMP CSmtpAdminService::get_ETRNDays( long * plETRNDays )
{
    return StdPropertyGet ( m_lETRNDays, plETRNDays );
}

STDMETHODIMP CSmtpAdminService::put_ETRNDays( long lETRNDays )
{
    return StdPropertyPut ( &m_lETRNDays, lETRNDays, &m_bvChangedFields, BitMask(ID_ETRNDAYS));
}

STDMETHODIMP CSmtpAdminService::get_SendDNRToPostmaster( BOOL * pfSendDNRToPostmaster )
{
    return StdPropertyGet ( m_fSendDNRToPostmaster, pfSendDNRToPostmaster );
}

STDMETHODIMP CSmtpAdminService::put_SendDNRToPostmaster( BOOL fSendDNRToPostmaster )
{
    return StdPropertyPut ( &m_fSendDNRToPostmaster, fSendDNRToPostmaster, &m_bvChangedFields, BitMask(ID_SENDDNRTOPOSTMASTER));
}

STDMETHODIMP CSmtpAdminService::get_SendBadmailToPostmaster( BOOL * pfSendBadmailToPostmaster)
{
    return StdPropertyGet ( m_fSendBadmailToPostmaster, pfSendBadmailToPostmaster );
}

STDMETHODIMP CSmtpAdminService::put_SendBadmailToPostmaster( BOOL fSendBadmailToPostmaster )
{
    return StdPropertyPut ( &m_fSendBadmailToPostmaster, fSendBadmailToPostmaster, &m_bvChangedFields, BitMask(ID_SENDBADMAILTOPOSTMASTER));
}

STDMETHODIMP CSmtpAdminService::get_RoutingDLL( BSTR * pstrRoutingDLL )
{
    return StdPropertyGet ( m_strRoutingDLL, pstrRoutingDLL );
}

STDMETHODIMP CSmtpAdminService::put_RoutingDLL( BSTR strRoutingDLL  )
{
    return StdPropertyPut ( &m_strRoutingDLL, strRoutingDLL, &m_bvChangedFields, BitMask(ID_ROUTINGDLL));
}


STDMETHODIMP CSmtpAdminService::get_RoutingSources  ( SAFEARRAY ** ppsastrRoutingSources )
{
    return StdPropertyGet ( &m_mszRoutingSources, ppsastrRoutingSources );
}
STDMETHODIMP CSmtpAdminService::put_RoutingSources  ( SAFEARRAY * psastrRoutingSources )
{
    return StdPropertyPut ( &m_mszRoutingSources, psastrRoutingSources, &m_bvChangedFields, BitMask(ID_ROUTINGSOURCES) );
}


STDMETHODIMP CSmtpAdminService::get_RoutingSourcesVariant( SAFEARRAY ** ppsavarRoutingSources )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrRoutingSources        = NULL;

    hr = get_RoutingSources ( &psastrRoutingSources );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrRoutingSources, ppsavarRoutingSources );

Exit:
    if ( psastrRoutingSources ) {
        SafeArrayDestroy ( psastrRoutingSources );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_RoutingSourcesVariant( SAFEARRAY * psavarRoutingSources )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrRoutingSources        = NULL;

    hr = VariantArrayToStringArray ( psavarRoutingSources, &psastrRoutingSources );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_RoutingSources ( psastrRoutingSources );

Exit:
    if ( psastrRoutingSources ) {
        SafeArrayDestroy ( psastrRoutingSources );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::get_LocalDomains    ( SAFEARRAY ** ppsastrLocalDomains )
{
    return StdPropertyGet ( &m_mszLocalDomains, ppsastrLocalDomains );
}

STDMETHODIMP CSmtpAdminService::put_LocalDomains    ( SAFEARRAY * psastrLocalDomains )
{
    return StdPropertyPut ( &m_mszLocalDomains, psastrLocalDomains, &m_bvChangedFields, BitMask(ID_LOCALDOMAINS) );
}

STDMETHODIMP CSmtpAdminService::get_DomainRouting   ( SAFEARRAY ** ppsastrDomainRouting )
{
    return StdPropertyGet ( &m_mszDomainRouting, ppsastrDomainRouting );
}
STDMETHODIMP CSmtpAdminService::put_DomainRouting   ( SAFEARRAY * psastrDomainRouting )
{
    return StdPropertyPut ( &m_mszDomainRouting, psastrDomainRouting, &m_bvChangedFields, BitMask(ID_DOMAINROUTING) );
}

STDMETHODIMP CSmtpAdminService::get_DomainRoutingVariant( SAFEARRAY ** ppsastrDomainRouting )
{
    HRESULT                 hr;
    SAFEARRAY *             pstrDomainRouting        = NULL;

    hr = get_DomainRouting ( &pstrDomainRouting );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( pstrDomainRouting, ppsastrDomainRouting );

Exit:
    if ( pstrDomainRouting ) {
        SafeArrayDestroy ( pstrDomainRouting );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_DomainRoutingVariant( SAFEARRAY * psastrDomainRouting )
{
    HRESULT                 hr;
    SAFEARRAY *             pstrDomainRouting        = NULL;

    hr = VariantArrayToStringArray ( psastrDomainRouting, &pstrDomainRouting );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_DomainRouting ( pstrDomainRouting );

Exit:
    if ( pstrDomainRouting ) {
        SafeArrayDestroy ( pstrDomainRouting );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminService::get_MasqueradeDomain( BSTR * pstrMasqueradeDomain )
{
    return StdPropertyGet ( m_strMasqueradeDomain, pstrMasqueradeDomain );
}

STDMETHODIMP CSmtpAdminService::put_MasqueradeDomain( BSTR strMasqueradeDomain )
{
    return StdPropertyPut ( &m_strMasqueradeDomain, strMasqueradeDomain, &m_bvChangedFields, BitMask(ID_MASQUERADE));
}

STDMETHODIMP CSmtpAdminService::get_SendNdrTo( BSTR * pstrAddr )
{
    return StdPropertyGet( m_strNdrAddr, pstrAddr );
}

STDMETHODIMP CSmtpAdminService::put_SendNdrTo( BSTR strAddr )
{
    return StdPropertyPut ( &m_strNdrAddr, strAddr, &m_bvChangedFields, BitMask(ID_SENDNDRTO));
}

STDMETHODIMP CSmtpAdminService::get_SendBadTo( BSTR * pstrAddr )
{
    return StdPropertyGet( m_strBadAddr, pstrAddr );
}

STDMETHODIMP CSmtpAdminService::put_SendBadTo( BSTR strAddr )
{
    return StdPropertyPut ( &m_strBadAddr, strAddr, &m_bvChangedFields, BitMask(ID_SENDBADTO));
}

STDMETHODIMP CSmtpAdminService::get_RemoteSecurePort( long * plRemoteSecurePort )
{
    return StdPropertyGet( m_lRemoteSecurePort, plRemoteSecurePort );
}

STDMETHODIMP CSmtpAdminService::put_RemoteSecurePort( long lRemoteSecurePort )
{
    return StdPropertyPut ( &m_lRemoteSecurePort, lRemoteSecurePort, &m_bvChangedFields, BitMask(ID_REMOTE_SECURE_PORT));
}

STDMETHODIMP CSmtpAdminService::get_ShouldDeliver( BOOL * pfShouldDeliver )
{
    return StdPropertyGet( m_fShouldDeliver, pfShouldDeliver );
}

STDMETHODIMP CSmtpAdminService::put_ShouldDeliver( BOOL fShouldDeliver )
{
    return StdPropertyPut ( &m_fShouldDeliver, fShouldDeliver, &m_bvChangedFields, BitMask(ID_SHOULD_DELIVER));
}


STDMETHODIMP CSmtpAdminService::get_AlwaysUseSsl( BOOL * pfAlwaysUseSsl )
{
    return StdPropertyGet( m_fAlwaysUseSsl, pfAlwaysUseSsl );
}

STDMETHODIMP CSmtpAdminService::put_AlwaysUseSsl( BOOL fAlwaysUseSsl )
{
    return StdPropertyPut ( &m_fAlwaysUseSsl, fAlwaysUseSsl, &m_bvChangedFields, BitMask(ID_ALWAYS_USE_SSL));
}

STDMETHODIMP CSmtpAdminService::get_LimitRemoteConnections( BOOL * pfLimitRemoteConnections )
{
    return StdPropertyGet( m_fLimitRemoteConnections, pfLimitRemoteConnections );
}

STDMETHODIMP CSmtpAdminService::put_LimitRemoteConnections( BOOL fLimitRemoteConnections )
{
    return StdPropertyPut ( &m_fLimitRemoteConnections, fLimitRemoteConnections, &m_bvChangedFields, BitMask(ID_LIMIT_REMOTE_CONNECTIONS));
}

STDMETHODIMP CSmtpAdminService::get_MaxOutConnPerDomain( long * plMaxOutConnPerDomain )
{
    return StdPropertyGet( m_lMaxOutConnPerDomain, plMaxOutConnPerDomain );
}

STDMETHODIMP CSmtpAdminService::put_MaxOutConnPerDomain( long lMaxOutConnPerDomain )
{
    return StdPropertyPut ( &m_lMaxOutConnPerDomain, lMaxOutConnPerDomain, &m_bvChangedFields, BitMask(ID_MAX_OUT_CONN_PER_DOMAIN));
}


STDMETHODIMP CSmtpAdminService::get_AllowVerify( BOOL * pfAllowVerify )
{
    return StdPropertyGet( m_fAllowVerify, pfAllowVerify );
}

STDMETHODIMP CSmtpAdminService::put_AllowVerify( BOOL fAllowVerify )
{
    return StdPropertyPut ( &m_fAllowVerify, fAllowVerify, &m_bvChangedFields, BitMask(ID_ALLOW_VERIFY));
}


STDMETHODIMP CSmtpAdminService::get_AllowExpand( BOOL * pfAllowExpand )
{
    return StdPropertyGet( m_fAllowExpand, pfAllowExpand);
}

STDMETHODIMP CSmtpAdminService::put_AllowExpand( BOOL fAllowExpand )
{
    return StdPropertyPut ( &m_fAllowExpand, fAllowExpand, &m_bvChangedFields, BitMask(ID_ALLOW_EXPAND));
}


STDMETHODIMP CSmtpAdminService::get_SmartHostType( long * plSmartHostType )
{
    return StdPropertyGet( m_lSmartHostType, plSmartHostType );
}

STDMETHODIMP CSmtpAdminService::put_SmartHostType( long lSmartHostType )
{
    return StdPropertyPut ( &m_lSmartHostType, lSmartHostType, &m_bvChangedFields, BitMask(ID_SMART_HOST_TYPE));
}


STDMETHODIMP CSmtpAdminService::get_BatchMessages( BOOL * pfBatchMessages )
{
    return StdPropertyGet( m_fBtachMsgs, pfBatchMessages );
}

STDMETHODIMP CSmtpAdminService::put_BatchMessages( BOOL fBatchMessages )
{
    return StdPropertyPut ( &m_fBtachMsgs, fBatchMessages, &m_bvChangedFields, BitMask(ID_BATCH_MSGS));
}


STDMETHODIMP CSmtpAdminService::get_BatchMessageLimit( long * plBatchMessageLimit )
{
    return StdPropertyGet( m_lBatchMsgLimit, plBatchMessageLimit );
}

STDMETHODIMP CSmtpAdminService::put_BatchMessageLimit( long lBatchMessageLimit )
{
    return StdPropertyPut ( &m_lBatchMsgLimit, lBatchMessageLimit, &m_bvChangedFields, BitMask(ID_BATCH_MSG_LIMIT));
}


STDMETHODIMP CSmtpAdminService::get_DoMasquerade( BOOL * pfDoMasquerade )
{
    return StdPropertyGet( m_fDoMasquerade, pfDoMasquerade );
}

STDMETHODIMP CSmtpAdminService::put_DoMasquerade( BOOL fDoMasquerade )
{
    return StdPropertyPut ( &m_fDoMasquerade, fDoMasquerade, &m_bvChangedFields, BitMask(ID_DO_MASQUERADE));
}


STDMETHODIMP CSmtpAdminService::get_Administrators ( SAFEARRAY ** ppsastrAdmins )
{
    TraceFunctEnter ( "CSmtpAdminService::get_Administrators" );

    HRESULT     hr  = NOERROR;

    if ( m_psaAdmins ) {
        hr = SafeArrayCopy ( m_psaAdmins, ppsastrAdmins );
    }
    else {
        *ppsastrAdmins = NULL;
        hr = NOERROR;
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminService::put_Administrators ( SAFEARRAY * psastrAdmins )
{
    TraceFunctEnter ( "CSmtpAdminService::put_Administrators" );

    HRESULT     hr  = NOERROR;

    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
    }

    if ( psastrAdmins ) {
        hr = SafeArrayCopy ( psastrAdmins, &m_psaAdmins );
    }
    else {
        m_psaAdmins = NULL;
        hr = NOERROR;
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminService::get_AdministratorsVariant( SAFEARRAY ** ppsavarAdmins )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrAdmins        = NULL;

    hr = get_Administrators ( &psastrAdmins );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrAdmins, ppsavarAdmins );

Exit:
    if ( psastrAdmins ) {
        SafeArrayDestroy ( psastrAdmins );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_AdministratorsVariant( SAFEARRAY * psavarAdmins )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrAdmins        = NULL;

    hr = VariantArrayToStringArray ( psavarAdmins, &psastrAdmins );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_Administrators ( psastrAdmins );

Exit:
    if ( psastrAdmins ) {
        SafeArrayDestroy ( psastrAdmins );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::get_LogFileDirectory( BSTR * pstrLogFileDirectory )
{
    return StdPropertyGet ( m_strLogFileDirectory, pstrLogFileDirectory );
}

STDMETHODIMP CSmtpAdminService::put_LogFileDirectory( BSTR strLogFileDirectory )
{
    return StdPropertyPut ( &m_strLogFileDirectory, strLogFileDirectory, &m_bvChangedFields, BitMask(ID_LOGFILEDIRECTORY));
}

STDMETHODIMP CSmtpAdminService::get_LogFilePeriod( long * plLogFilePeriod )
{
    return StdPropertyGet ( m_lLogFilePeriod, plLogFilePeriod );
}

STDMETHODIMP CSmtpAdminService::put_LogFilePeriod( long lLogFilePeriod )
{
    return StdPropertyPut ( &m_lLogFilePeriod, lLogFilePeriod, &m_bvChangedFields, BitMask(ID_LOGFILEPERIOD));
}

STDMETHODIMP CSmtpAdminService::get_LogFileTruncateSize( long * plLogFileTruncateSize )
{
    return StdPropertyGet ( m_lLogFileTruncateSize, plLogFileTruncateSize );
}

STDMETHODIMP CSmtpAdminService::put_LogFileTruncateSize( long lLogFileTruncateSize )
{
    return StdPropertyPut ( &m_lLogFileTruncateSize, lLogFileTruncateSize, &m_bvChangedFields, BitMask(ID_LOGFILETRUNCATESIZE));
}

STDMETHODIMP CSmtpAdminService::get_LogMethod( long * plLogMethod )
{
    return StdPropertyGet ( m_lLogMethod, plLogMethod );
}

STDMETHODIMP CSmtpAdminService::put_LogMethod( long lLogMethod )
{
    return StdPropertyPut ( &m_lLogMethod, lLogMethod, &m_bvChangedFields, BitMask(ID_LOGMETHOD));
}

STDMETHODIMP CSmtpAdminService::get_LogType( long * plLogType )
{
    return StdPropertyGet ( m_lLogType, plLogType );
}

STDMETHODIMP CSmtpAdminService::put_LogType( long lLogType )
{
    return StdPropertyPut ( &m_lLogType, lLogType, &m_bvChangedFields, BitMask(ID_LOGTYPE));
}



//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::Get
//
//  Description:
//
//      Gets server properties from the metabase.
//
//  Parameters:
//
//      (property) m_strServer
//
//  Returns:
//
//      E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdminService::Get ( )
{
    TraceFunctEnter ( "CSmtpAdminService::Get" );

    HRESULT             hr          = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    // Validate Server & Service Instance:

    // Talk to the metabase:
    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = GetPropertiesFromMetabase ( pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    StateTrace ( 0, "Successfully got server properties" );
    m_fGotProperties    = TRUE;
    m_bvChangedFields   = 0;

Exit:
    TraceFunctLeave ();

    return hr;

    // CComPtr automatically releases the metabase handle.
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::Set
//
//  Description:
//
//      Sends server properties to the metabase.
//
//  Parameters:
//
//      (property) m_strServer
//      fFailIfChanged - return an error if the metabase has changed?
//
//  Returns:
//
//      E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdminService::Set ( BOOL fFailIfChanged )
{
    TraceFunctEnter ( "CSmtpAdminService::Set" );

    HRESULT hr  = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;
    
    // Make sure the client call Get first:
    if ( !m_fGotProperties ) {
        ErrorTrace ( 0, "Didn't call get first" );

        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_CALL_GET );
        goto Exit;
    }

    // nothing has been changed
    if( m_bvChangedFields == 0 )
    {
        hr = NOERROR;
        goto Exit;
    }

    // Validate data members:
    if ( !ValidateStrings () ) {
        // !!!magnush - what about the case when any strings are NULL?
        hr = E_FAIL;
        goto Exit;
    }

    if ( !ValidateProperties ( ) ) {
        hr = SmtpCreateExceptionFromWin32Error ( ERROR_INVALID_PARAMETER );;
        goto Exit;
    }

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = SendPropertiesToMetabase ( fFailIfChanged, pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    StateTrace ( 0, "Successfully set server properties" );

    // successfully saved, reset change field bitmap
    m_bvChangedFields = 0;

Exit:
    TraceFunctLeave ();
    return hr;
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::GetPropertiesFromMetabase
//
//  Description:
//
//      Asks the metabase for each property in this class.
//      This class's properties come from /LM/SmtpSvc/
//
//  Parameters:
//
//      pMetabase - The metabase object
//
//  Returns:
//
//      E_OUTOFMEMORY and others.
//
//--------------------------------------------------------------------

HRESULT CSmtpAdminService::GetPropertiesFromMetabase ( IMSAdminBase * pMetabase )
{
    TraceFunctEnter ( "CSmtpAdminService::GetPropertiesFromMetabase" );

    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;

    PSECURITY_DESCRIPTOR        pSD = NULL;
    DWORD                       cbSD    = 0;

    hr = metabase.Open ( SMTP_MD_ROOT_PATH );

    if ( FAILED(hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to open SmtpSvc key, %x", GetLastError() );

        // Return some kind of error code here:
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
        goto Exit;
    }

    fRet = TRUE;
#if 0
    fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_PORT,      DEFAULT_SSLPORT,                &m_lSSLPort )           && fRet;
#endif
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT, DEFAULT_OUTBOND_PORT,           &m_lOutboundPort )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   DEFAULT_SMART_HOST,             &m_strSmartHost )       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_HOP_COUNT,        DEFAULT_HOP_COUNT,              &m_lHopCount )      && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,DEFAULT_ENABLE_DNS_LOOKUP,    &m_fEnableDNSLookup )   && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, DEFAULT_POSTMASTER_EMAIL,       &m_strPostmasterEmail ) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  DEFAULT_POSTMASTER_NAME,        &m_strPostmasterName )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_FQDN_VALUE,           DEFAULT_FQDN,               &m_strFQDN )            && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, DEFAULT_DEFAULT_DOMAIN,     &m_strDefaultDomain )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_DROP_DIR,        DEFAULT_DROP_DIR,           &m_strDropDir )         && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     DEFAULT_BADMAIL_DIR,            &m_strBadMailDir )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  DEFAULT_PICKUP_DIR,             &m_strPickupDir )       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   DEFAULT_QUEUE_DIR,              &m_strQueueDir )        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  DEFAULT_MAX_OUT_CONNECTION,     &m_lMaxOutConnection )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,       DEFAULT_OUT_CONNECTION_TIMEOUT, &m_lOutConnectionTimeout )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,             DEFAULT_MAX_MESSAGE_SIZE,       &m_lMaxMessageSize )        && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    DEFAULT_MAX_SESSION_SIZE,       &m_lMaxSessionSize )        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,           DEFAULT_MAX_MESSAGE_RECIPIENTS,     &m_lMaxMessageRecipients )  && fRet;


    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     DEFAULT_LOCAL_RETRIES,      &m_lLocalRetries)       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      DEFAULT_LOCAL_RETRY_TIME,   &m_lLocalRetryTime)     && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_RETRY_ATTEMPTS,    DEFAULT_REMOTE_RETRIES,     &m_lRemoteRetries)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     DEFAULT_REMOTE_RETRY_TIME,  &m_lRemoteRetryTime)    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ETRN_DAYS,                DEFAULT_ETRN_DAYS,          &m_lETRNDays)           && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTING_DLL,          DEFAULT_ROUTING_DLL,            &m_strRoutingDLL)       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      DEFAULT_ROUTING_SOURCES,            &m_mszRoutingSources)   && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_DOMAINS,        DEFAULT_LOCAL_DOMAINS,          &m_mszLocalDomains)     && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_DOMAIN_ROUTING,       DEFAULT_DOMAIN_ROUTING,         &m_mszDomainRouting)    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MASQUERADE_NAME,          DEFAULT_MASQUERADE_DOMAIN,  &m_strMasqueradeDomain) && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SEND_NDR_TO,          DEFAULT_SENDNDRTO,  &m_strNdrAddr)  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SEND_BAD_TO,          DEFAULT_SENDBADTO,  &m_strBadAddr)  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_SECURE_PORT,   DEFAULT_REMOTE_SECURE_PORT, &m_lRemoteSecurePort)   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SHOULD_DELIVER,       DEFAULT_SHOULD_DELIVER, &m_fShouldDeliver  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ALWAYS_USE_SSL,           DEFAULT_ALWAYS_USE_SSL,             &m_fAlwaysUseSsl  ) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LIMIT_REMOTE_CONNECTIONS, DEFAULT_LIMIT_REMOTE_CONNECTIONS,   &m_fLimitRemoteConnections  )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_OUT_CONN_PER_DOMAIN,  DEFAULT_MAX_OUT_CONN_PER_DOMAIN,    &m_lMaxOutConnPerDomain  )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SMARTHOST_TYPE,           DEFAULT_SMART_HOST_TYPE,        &m_lSmartHostType  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_BATCH_MSG_LIMIT,          DEFAULT_BATCH_MSG_LIMIT,        &m_lBatchMsgLimit  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_DO_MASQUERADE,            DEFAULT_DO_MASQUERADE,          &m_fDoMasquerade  ) && fRet;

    // the following properties are set on smtpsvc/<instance-id> level for virtual server

    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_BINDINGS,  DEFAULT_SERVER_BINDINGS,        &m_mszServerBindings )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_BINDINGS,  DEFAULT_SECURE_BINDINGS,        &m_mszSecureBindings )  && fRet;
//  fRet = StdGetMetabaseProp ( &metabase, MD_PORT,             DEFAULT_PORT,                   &m_lPort )              && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,      DEFAULT_MAX_IN_CONNECTION,      &m_lMaxInConnection )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,   DEFAULT_IN_CONNECTION_TIMEOUT,  &m_lInConnectionTimeout )   && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,    DEFAULT_LOGFILE_DIRECTORY,          &m_strLogFileDirectory)     && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       DEFAULT_LOGFILE_PERIOD,             &m_lLogFilePeriod)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,DEFAULT_LOGFILE_TRUNCATE_SIZE,      &m_lLogFileTruncateSize)        && fRet;
//  fRet = StdGetMetabaseProp ( &metabase, MD_LOG_METHOD,       DEFAULT_LOG_METHOD,                 &m_lLogMethod)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOG_TYPE,     DEFAULT_LOG_TYPE,                   &m_lLogType)        && fRet;


    //  Get the admin ACL
    DWORD   dwDummy;

    pSD = NULL;
    cbSD    = 0;

    metabase.GetData ( _T(""), MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA, &dwDummy, &cbSD, METADATA_INHERIT);
    if ( cbSD != 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {
        pSD = (PSECURITY_DESCRIPTOR) new char [ cbSD ];
        
        if( NULL == pSD )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
            
        fRet = metabase.GetData ( _T(""), MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA, pSD, &cbSD,METADATA_INHERIT );
    }

    // Check all property strings:
    // If any string is NULL, it is because we failed to allocate memory:
    if ( !ValidateStrings () ) {

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // We can only fail from memory allocations:
    _ASSERT ( fRet );

    // Save the last changed time for this key:
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
        // Ignore this error.
        hr = NOERROR;
    }

    // Validate the data received from the metabase:
    _ASSERT ( ValidateStrings () );
    _ASSERT ( ValidateProperties( ) );

    // Extract the Administrator list:
    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
        m_psaAdmins = NULL;
    }
    if ( pSD ) {
        hr = AclToAdministrators ( m_strServer, pSD, &m_psaAdmins );
        BAIL_ON_FAILURE(hr);
    }

    if ( !ValidateProperties( ) ) {
        CorrectProperties ();
    }

Exit:
    delete (char*) pSD;

    TraceFunctLeave ();
    return hr;

    // CMetabaseKey automatically closes its handle
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::SendPropertiesToMetabase
//
//  Description:
//
//      Saves each property to the metabase.
//      This class's properties go into /LM/SmtpSvc/
//
//  Parameters:
//
//      fFailIfChanged  - Return a failure code if the metabase
//          has changed since last get.
//      pMetabase - the metabase object.
//
//  Returns:
//
//      E_OUTOFMEMORY and others.
//
//--------------------------------------------------------------------

HRESULT CSmtpAdminService::SendPropertiesToMetabase ( 
    BOOL fFailIfChanged, 
    IMSAdminBase * pMetabase
    )
{
    TraceFunctEnter ( "CSmtpAdminService::SendPropertiesToMetabase" );

    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;

    //
    //  Set the admin acl:
    //

    PSECURITY_DESCRIPTOR    pSD     = NULL;
    DWORD                   cbSD    = 0;

//  if ( m_bvChangedFields & CHNG_ADMINACL ) {
        if ( m_psaAdmins ) {
            hr = AdministratorsToAcl ( m_strServer, m_psaAdmins, &pSD, &cbSD );
            BAIL_ON_FAILURE(hr);
        }
//  }


    hr = metabase.Open ( SMTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );
    if ( FAILED(hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to open SmtpSvc key, %x", GetLastError() );

        // !!!magnush - Should we return a simple Service doesn't exist error code?
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
        goto Exit;
    }

    // Does the client care if the key has changed?
    if ( fFailIfChanged ) {

        //  Did the key change?
        if ( HasKeyChanged ( pMetabase, metabase.QueryHandle(), &m_ftLastChanged ) ) {

            StateTrace ( (LPARAM) this, "Metabase has changed, not setting properties" );
            // !!!magnush - Return the appropriate error code:
            hr = E_FAIL;
            goto Exit;
        }
    }

    //
    //  The general procedure here is to keep setting metabase properties
    //  as long as nothing has gone wrong.  This is done by short-circuiting
    //  the statement by ANDing it with the status code.  This makes the code
    //  much more concise.
    //

    fRet = TRUE;
#if 0
    if ( m_bvChangedFields & BitMask(ID_SSLPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_PORT,          m_lSSLPort )        && fRet;
    }
#endif
    if ( m_bvChangedFields & BitMask(ID_OUTBOUNDPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT,     m_lOutboundPort )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_HOP_COUNT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_HOP_COUNT,    m_lHopCount )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SMARTHOST) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   m_strSmartHost )        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ENABLEDNSLOOKUP) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,m_fEnableDNSLookup )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTEREMAIL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, m_strPostmasterEmail )  && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTERNAME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  m_strPostmasterName )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_FQDN) ) 
    {
        // need to set the UPDATED flag
        if( m_strFQDN.m_str && m_strFQDN.m_str[0] )
        {
            fRet = StdPutMetabaseProp ( &metabase, MD_UPDATED_FQDN, 1 )         && fRet;
            fRet = StdPutMetabaseProp ( &metabase, MD_FQDN_VALUE,   m_strFQDN )         && fRet;
        }
        else
        {
            // empty string indicating using TCP/IP setting
            fRet = StdPutMetabaseProp ( &metabase, MD_UPDATED_FQDN, 0 )         && fRet;
        }
    }

    if ( m_bvChangedFields & BitMask(ID_DEFAULTDOMAIN) ) 
    {
        // need to set the UPDATE flag
        fRet = StdPutMetabaseProp ( &metabase, MD_UPDATED_DEFAULT_DOMAIN,   1 )         && fRet;
        fRet = StdPutMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, m_strDefaultDomain )            && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DROPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_DROP_DIR,    m_strDropDir )          && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BADMAILDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     m_strBadMailDir )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_PICKUPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  m_strPickupDir )        && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_QUEUEDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   m_strQueueDir )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXOUTCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  m_lMaxOutConnection )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_OUTCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,   m_lOutConnectionTimeout )   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,     m_lMaxMessageSize )     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_MAXSESSIONSIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    m_lMaxSessionSize )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGERECIPIENTS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,       m_lMaxMessageRecipients )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALRETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      m_lLocalRetryTime)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_REMOTERETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     m_lRemoteRetryTime)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ETRNDAYS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ETRN_DAYS,                m_lETRNDays)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ROUTINGDLL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_DLL,          m_strRoutingDLL)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ROUTINGSOURCES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      &m_mszRoutingSources)   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALDOMAINS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_DOMAINS,        &m_mszLocalDomains)     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DOMAINROUTING) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DOMAIN_ROUTING,       &m_mszDomainRouting)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALRETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     m_lLocalRetries)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_REMOTERETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_ATTEMPTS,    m_lRemoteRetries)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MASQUERADE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MASQUERADE_NAME,  m_strMasqueradeDomain)      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDNDRTO) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_NDR_TO,  m_strNdrAddr)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDBADTO) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_BAD_TO,  m_strBadAddr)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_REMOTE_SECURE_PORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SECURE_PORT,   m_lRemoteSecurePort)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SHOULD_DELIVER) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SHOULD_DELIVER,   m_fShouldDeliver)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ALWAYS_USE_SSL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ALWAYS_USE_SSL,   m_fAlwaysUseSsl)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LIMIT_REMOTE_CONNECTIONS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LIMIT_REMOTE_CONNECTIONS, m_fLimitRemoteConnections)      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAX_OUT_CONN_PER_DOMAIN) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUT_CONN_PER_DOMAIN,  m_lMaxOutConnPerDomain)     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SMART_HOST_TYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_TYPE,   m_lSmartHostType)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BATCH_MSG_LIMIT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BATCH_MSG_LIMIT,  m_lBatchMsgLimit)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DO_MASQUERADE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DO_MASQUERADE,    m_fDoMasquerade)        && fRet;
    }

    // the following properties are set on smtpsvc/<instance-id> level for virtual server

    if ( m_bvChangedFields & BitMask(ID_SERVER_BINDINGS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SERVER_BINDINGS,      &m_mszServerBindings )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SECURE_BINDINGS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_BINDINGS,      &m_mszSecureBindings )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_PORT) ) 
    {
//      fRet = StdPutMetabaseProp ( &metabase, MD_PORT,             m_lPort )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXINCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,  m_lMaxInConnection )    && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_INCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,m_lInConnectionTimeout )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOGFILEDIRECTORY) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,        m_strLogFileDirectory)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILEPERIOD) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       m_lLogFilePeriod)       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILETRUNCATESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,    m_lLogFileTruncateSize)     && fRet;
    }
//  if ( m_bvChangedFields & BitMask(ID_LOGMETHOD) ) 
//  {
//      fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogMethod)       && fRet;
//  }
    if ( m_bvChangedFields & BitMask(ID_LOGTYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogType)     && fRet;
    }

//  if ( m_bvChangedFields & CHNG_ADMINACL ) {
        if ( pSD ) {
            fRet = fRet && metabase.SetData ( _T(""), MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA, pSD, cbSD, METADATA_INHERIT | METADATA_REFERENCE);
        }
        else {
            pMetabase->DeleteData ( metabase.QueryHandle(), _T(""), MD_ADMIN_ACL, BINARY_METADATA );
        }
//  }


    // Save the data to the metabase:
    // hr = metabase.Close();
    // BAIL_ON_FAILURE(hr);
    metabase.Close();

    hr = pMetabase->SaveData ();
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed SaveData call (%x)", hr );
        goto Exit;
    }

    // Save the last changed time for this key:
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
        // Ignore this error.
        hr = NOERROR;
    }

Exit:
    delete (char*) pSD;

    if( SUCCEEDED(hr) && !fRet )
    {
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
    }

    TraceFunctLeave ();
    return hr;

    // CMetabaseKey automatically closes its handle
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::ValidateStrings
//
//  Description:
//
//      Checks to make sure each string property is non-null.
//
//  Returns:
//
//      FALSE if any string property is NULL.
//
//--------------------------------------------------------------------

BOOL CSmtpAdminService::ValidateStrings ( ) const
{
    TraceFunctEnter ( "CSmtpAdminService::ValidateStrings" );

    // Check all property strings:
    // If any string is NULL, return FALSE:
    if ( 
        !m_strSmartHost ||
        !m_strPostmasterEmail ||
        !m_strPostmasterName ||
        !m_strDefaultDomain ||
        !m_strBadMailDir ||
        !m_strPickupDir ||
        !m_strQueueDir ||
        !m_strRoutingDLL ||
        !m_strLogFileDirectory
        ) {

        ErrorTrace ( (LPARAM) this, "String validation failed" );

        TraceFunctLeave ();
        return FALSE;
    }

    _ASSERT ( IS_VALID_STRING ( m_strSmartHost ) );
    _ASSERT ( IS_VALID_STRING ( m_strPostmasterEmail ) );
    _ASSERT ( IS_VALID_STRING ( m_strPostmasterName ) );

    _ASSERT ( IS_VALID_STRING ( m_strDefaultDomain ) );

    _ASSERT ( IS_VALID_STRING ( m_strBadMailDir ) );
    _ASSERT ( IS_VALID_STRING ( m_strPickupDir ) );
    _ASSERT ( IS_VALID_STRING ( m_strQueueDir ) );

    _ASSERT ( IS_VALID_STRING ( m_strRoutingDLL ) );

    _ASSERT ( IS_VALID_STRING ( m_strLogFileDirectory ) );

    TraceFunctLeave ();
    return TRUE;
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::ValidateProperties
//
//  Description:
//
//      Checks to make sure all parameters are valid.
//
//  Parameters:
//
//
//  Returns:
//
//      FALSE if any property was not valid.  
//
//--------------------------------------------------------------------

BOOL CSmtpAdminService::ValidateProperties (  ) const
{
    BOOL    fRet    = TRUE;
    
    _ASSERT ( ValidateStrings () );
/*
    fRet = fRet && PV_MinMax    ( m_lPort, MIN_PORT, MAX_PORT );
    fRet = fRet && PV_MinMax    ( m_lSSLPort, MIN_SSLPORT, MAX_SSLPORT );
    fRet = fRet && PV_MinMax    ( m_lOutboundPort, MIN_OUTBOND_PORT, MAX_OUTBOND_PORT );

    fRet = fRet && PV_MinMax    ( m_lMaxInConnection, MIN_MAX_IN_CONNECTION, MAX_MAX_IN_CONNECTION );
    fRet = fRet && PV_MinMax    ( m_lMaxOutConnection, MIN_MAX_OUT_CONNECTION, MAX_MAX_OUT_CONNECTION );
    fRet = fRet && PV_MinMax    ( m_lInConnectionTimeout, MIN_IN_CONNECTION_TIMEOUT, MAX_IN_CONNECTION_TIMEOUT );
    fRet = fRet && PV_MinMax    ( m_lOutConnectionTimeout, MIN_OUT_CONNECTION_TIMEOUT, MAX_OUT_CONNECTION_TIMEOUT );

    fRet = fRet && PV_MinMax    ( m_lMaxMessageSize, MIN_MAX_MESSAGE_SIZE, MAX_MAX_MESSAGE_SIZE );
    fRet = fRet && PV_MinMax    ( m_lMaxSessionSize, MIN_MAX_SESSION_SIZE, MAX_MAX_SESSION_SIZE );
    fRet = fRet && PV_MinMax    ( m_lMaxMessageRecipients, MIN_MAX_MESSAGE_RECIPIENTS, MAX_MAX_MESSAGE_RECIPIENTS );

    fRet = fRet && PV_MinMax    ( m_lLocalRetries, MIN_LOCAL_RETRIES, MAX_LOCAL_RETRIES );
    fRet = fRet && PV_MinMax    ( m_lLocalRetryTime, MIN_LOCAL_RETRY_TIME, MAX_LOCAL_RETRY_TIME );
    fRet = fRet && PV_MinMax    ( m_lRemoteRetries, MIN_REMOTE_RETRIES, MAX_REMOTE_RETRIES );
    fRet = fRet && PV_MinMax    ( m_lRemoteRetryTime, MIN_REMOTE_RETRY_TIME, MAX_REMOTE_RETRY_TIME );
    fRet = fRet && PV_MinMax    ( m_lETRNDays, MIN_ETRN_DAYS, MAX_ETRN_DAYS );

    fRet = fRet && PV_MinMax    ( m_lLogFilePeriod, MIN_LOGFILE_PERIOD, MAX_LOGFILE_PERIOD );
    fRet = fRet && PV_MinMax    ( m_lLogFileTruncateSize, MIN_LOGFILE_TRUNCATE_SIZE, MAX_LOGFILE_TRUNCATE_SIZE );
    fRet = fRet && PV_MinMax    ( m_lLogMethod, MIN_LOG_METHOD, MAX_LOG_METHOD );
    fRet = fRet && PV_MinMax    ( m_lLogType, MIN_LOG_TYPE, MAX_LOG_TYPE );

    fRet = fRet && PV_Boolean   ( m_fEnableDNSLookup );
    fRet = fRet && PV_Boolean   ( m_fSendDNRToPostmaster );
    fRet = fRet && PV_Boolean   ( m_fSendBadmailToPostmaster );
*/
    return fRet;
}

void CSmtpAdminService::CorrectProperties ( )
{
/*
    if ( m_strServer && !PV_MaxChars    ( m_strServer, MAXLEN_SERVER ) ) {
        m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
    }
    if ( !PV_MinMax ( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT ) ) {
        m_dwArticleTimeLimit    = DEFAULT_ARTICLETIMELIMIT;
    }
    if ( !PV_MinMax ( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION ) ) {
        m_dwHistoryExpiration   = DEFAULT_HISTORYEXPIRATION;
    }
    if ( !PV_Boolean    ( m_fHonorClientMsgIDs ) ) {
        m_fHonorClientMsgIDs    = !!m_fHonorClientMsgIDs;
    }
    if ( !PV_MaxChars   ( m_strSmtpServer, MAXLEN_SMTPSERVER ) ) {
        m_strSmtpServer[ MAXLEN_SMTPSERVER - 1 ] = NULL;
    }
    if ( !PV_Boolean    ( m_fAllowClientPosts ) ) {
        m_fAllowClientPosts = !!m_fAllowClientPosts;
    }
    if ( !PV_Boolean    ( m_fAllowFeedPosts ) ) {
        m_fAllowFeedPosts   = !!m_fAllowFeedPosts;
    }
    if ( !PV_Boolean    ( m_fAllowControlMsgs ) ) {
        m_fAllowControlMsgs = !!m_fAllowControlMsgs;
    }
    if ( !PV_MaxChars   ( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN ) ) {
        m_strDefaultModeratorDomain[ MAXLEN_DEFAULTMODERATORDOMAIN - 1] = NULL;
    }
    if ( !PV_MinMax ( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK ) ) {
        m_dwCommandLogMask  = DEFAULT_COMMANDLOGMASK;
    }
    if ( !PV_Boolean    ( m_fDisableNewnews ) ) {
        m_fDisableNewnews   = !!m_fDisableNewnews;
    }
    if ( !PV_MinMax ( m_dwExpireRunFrequency, MIN_EXPIRERUNFREQUENCY, MAX_EXPIRERUNFREQUENCY ) ) {
        m_dwExpireRunFrequency  = DEFAULT_EXPIRERUNFREQUENCY;
    }
    if ( !PV_MinMax ( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY ) ) {
        m_dwShutdownLatency     = DEFAULT_SHUTDOWNLATENCY;
    }


  

---------
    if ( m_bvChangedFields & BitMask(ID_PORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_PORT,             m_lPort )       && fRet;
    }
#if 0
    if ( m_bvChangedFields & BitMask(ID_SSLPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_PORT,          m_lSSLPort )        && fRet;
    }
#endif
    if ( m_bvChangedFields & BitMask(ID_OUTBOUNDPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT,     m_lOutboundPort )       && fRet;
    }


    if ( m_strServer && !PV_MaxChars    ( m_strServer, MAXLEN_SERVER ) ) {
        m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
    }
    if ( m_bvChangedFields & BitMask(ID_SMARTHOST) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   m_strSmartHost )        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ENABLEDNSLOOKUP) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,m_fEnableDNSLookup )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTEREMAIL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, m_strPostmasterEmail )  && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTERNAME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  m_strPostmasterName )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DEFAULTDOMAIN) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, m_strDefaultDomain )            && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BADMAILDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     m_strBadMailDir )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_PICKUPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  m_strPickupDir )        && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_QUEUEDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   m_strQueueDir )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXINCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,  m_lMaxInConnection )    && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_MAXOUTCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  m_lMaxOutConnection )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_INCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,m_lInConnectionTimeout )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_OUTCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,   m_lOutConnectionTimeout )   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,     m_lMaxMessageSize )     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_MAXSESSIONSIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    m_lMaxSessionSize )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGERECIPIENTS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,       m_lMaxMessageRecipients )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXRETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     m_lMaxRetries )     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOCALRETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      m_lLocalRetryTime)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_REMOTERETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     m_lRemoteRetryTime)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ETRNDAYS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ETRN_DAYS,                m_lETRNDays)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDDNRTOPOSTMASTER) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_NDR_TO_ADMIN,        m_fSendDNRToPostmaster)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_SENDBADMAILTOPOSTMASTER) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_BAD_TO_ADMIN,        m_fSendBadmailToPostmaster)     && fRet;
    }

//  if ( m_bvChangedFields & BitMask(ID_RTTYPE) ) 
//  {
//      fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      m_lRTType)      && fRet;
//  }
    if ( m_bvChangedFields & BitMask(ID_ROUTINGSOURCES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      m_strRoutingSources)        && fRet;
    }


    if ( m_bvChangedFields & BitMask(ID_LOGFILEDIRECTORY) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,        m_strLogFileDirectory)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILEPERIOD) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       m_lLogFilePeriod)       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILETRUNCATESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,    m_lLogFileTruncateSize)     && fRet;
    }
//  if ( m_bvChangedFields & BitMask(ID_LOGMETHOD) ) 
//  {
//      fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogMethod)       && fRet;
//  }
    if ( m_bvChangedFields & BitMask(ID_LOGTYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogType)     && fRet;
    }


*/
    _ASSERT ( ValidateProperties ( ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\smtpadm.cpp ===
// smtpadm.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f smtpadmps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "adsiid.h"
#include "smtpadm.h"

#include "admin.h"
#include "service.h"
#include "virsvr.h"
#include "sessions.h"
#include "vdir.h"

#include "alias.h"
#include "user.h"
#include "dl.h"
#include "domain.h"

#include "regmacro.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CSmtpAdmin, CSmtpAdmin)
	OBJECT_ENTRY(CLSID_CSmtpAdminService, CSmtpAdminService)
	OBJECT_ENTRY(CLSID_CSmtpAdminVirtualServer, CSmtpAdminVirtualServer)
	OBJECT_ENTRY(CLSID_CSmtpAdminSessions, CSmtpAdminSessions)
	OBJECT_ENTRY(CLSID_CSmtpAdminVirtualDirectory, CSmtpAdminVirtualDirectory)
	OBJECT_ENTRY(CLSID_CSmtpAdminAlias, CSmtpAdminAlias)
	OBJECT_ENTRY(CLSID_CSmtpAdminUser, CSmtpAdminUser)
	OBJECT_ENTRY(CLSID_CSmtpAdminDL, CSmtpAdminDL)
	OBJECT_ENTRY(CLSID_CSmtpAdminDomain, CSmtpAdminDomain)
END_OBJECT_MAP()

BEGIN_EXTENSION_REGISTRATION_MAP
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpAlias, SmtpAdminAlias)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpDomain, SmtpAdminDomain)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpDL, SmtpAdminDL)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpSessions, SmtpAdminSessions)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpUser, SmtpAdminUser)
END_EXTENSION_REGISTRATION_MAP

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
//		InitAsyncTrace ();
		
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
//		TermAsyncTrace ();
		
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// register extensions
	RegisterExtensions();

	// registers object, typelib and all interfaces in typelib
	return(_Module.RegisterServer(TRUE));
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	// register extensions
	UnregisterExtensions();

	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\smtpcmn.h ===
// Common header file for the Smtp administration objects.

// Dependencies: please include stdafx.h" first
//
#include "resource.h"

// Constants:

#define HELP_FILE_NAME		_T("smtpadm.hlp")

// Exception creation:

#define SmtpCreateException(nDescriptionId) 	\
	CreateException ( 						\
		_Module.GetResourceInstance(), 		\
		THIS_FILE_IID, 						\
		HELP_FILE_NAME,						\
		THIS_FILE_HELP_CONTEXT,				\
		THIS_FILE_PROG_ID,					\
		(nDescriptionId) 					\
		)

#define SmtpCreateExceptionFromHresult(hr)	\
	CreateExceptionFromHresult (			\
		_Module.GetResourceInstance(),		\
		THIS_FILE_IID,						\
		HELP_FILE_NAME,						\
		THIS_FILE_HELP_CONTEXT,				\
		THIS_FILE_PROG_ID,					\
		(hr)								\
		)

#define SmtpCreateExceptionFromWin32Error(error)	\
	CreateExceptionFromWin32Error (					\
		_Module.GetResourceInstance(),				\
		THIS_FILE_IID,								\
		HELP_FILE_NAME,								\
		THIS_FILE_HELP_CONTEXT,						\
		THIS_FILE_PROG_ID,							\
		(error)										\
		)

// Property validation:

#define VALIDATE_STRING(string, maxlen) \
	if ( !PV_MaxChars ( (string), (maxlen) ) ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_STRING_TOO_LONG );	\
	}

#define VALIDATE_DWORD(dw, dwMin, dwMax)	\
	if ( !PV_MinMax ( (DWORD) (dw), (DWORD) (dwMin), (DWORD) (dwMax) ) ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_PROPERTY_OUT_OF_RANGE );	\
	}

#define VALIDATE_LONG(l, lMin, lMax)	\
	if ( !PV_MinMax ( (l), (lMin), (lMax) ) ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_PROPERTY_OUT_OF_RANGE );	\
	}

#define CHECK_FOR_SET_CURSOR(fEnumerated,fSetCursor)	\
{							\
	if ( !fEnumerated ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_ENUMERATE );	\
	}						\
							\
	if ( !fSetCursor ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_SET_CURSOR );	\
	}						\
}

// Metabase paths:

inline void GetMDInstancePath ( TCHAR * szInstancePath, DWORD dwServiceInstance )
{
	wsprintf ( szInstancePath, SMTP_MD_ROOT_PATH _T("%d/"), dwServiceInstance );
}


inline void GetMDParamPath ( TCHAR * szParamPath, DWORD dwServiceInstance )
{
	wsprintf ( szParamPath, SMTP_MD_ROOT_PATH _T("%d/"), dwServiceInstance );
}

inline void GetMDRootPath ( TCHAR * szRootPath, DWORD dwServiceInstance )
{
	wsprintf ( szRootPath, SMTP_MD_ROOT_PATH _T("%d/Root/"), dwServiceInstance );
}

inline void GetMDVDirPath ( TCHAR * szVDirPath, DWORD dwServiceInstance, TCHAR * szName )
{
	wsprintf ( szVDirPath, SMTP_MD_ROOT_PATH _T("%d/Root/%s"), dwServiceInstance, szName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\version.h ===
#include "exver.h"

#define makeString(x) #x

#define BUILD_NUM    atoi(makeString(rmm))

const int HIGH_VERSION = 1;
const int LOW_VERSION = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\smtpprop.h ===
#ifndef _SMTP_PROP_H__
#define _SMTP_PROP_H__

// const
#define TSTR_POSTMASTR_NAME         _T("Postmaster")

// Bitmasks for changed fields:

#define ID_SERVER_BINDINGS			0
#define ID_PORT						0

#define ID_SSLPORT					1
#define ID_SECURE_BINDINGS			1

#define ID_OUTBOUNDPORT				2
#define ID_REMOTE_SECURE_PORT		2

#define ID_SMARTHOST				3
#define ID_SMART_HOST_TYPE			3
#define ID_SHOULD_DELIVER			3

#define ID_ENABLEDNSLOOKUP			4
#define ID_POSTMASTEREMAIL			5
#define ID_POSTMASTERNAME			5

#define ID_HOP_COUNT				6

#define ID_AUTH_PACKAGES            7
#define ID_CLEARTEXT_AUTH_PACKAGE   7
#define ID_AUTH_METHOD              7
#define ID_DEFAULT_LOGON_DOMAIN     7

#define ID_DROPDIR					8
#define ID_BADMAILDIR				8
#define ID_PICKUPDIR				8
#define ID_QUEUEDIR					8

#define ID_ALLOW_VERIFY				9
#define ID_ALLOW_EXPAND				9

#define ID_ROUTE_ACTION             10
#define ID_ROUTE_USER_NAME          10
#define ID_ROUTE_PASSWORD           10

#define ID_ALWAYS_USE_SSL			11
#define ID_MAX_OUT_CONN_PER_DOMAIN	11

#define ID_LIMIT_REMOTE_CONNECTIONS	11

#define ID_MAXINCONNECTION			11
#define ID_MAXOUTCONNECTION			11
#define ID_INCONNECTIONTIMEOUT		11
#define ID_OUTCONNECTIONTIMEOUT		11

#define ID_BATCH_MSGS				12
#define ID_BATCH_MSG_LIMIT			12

// these two must be unique
#define ID_FQDN						13
#define ID_DEFAULTDOMAIN			14

#define ID_MAXMESSAGESIZE			15
#define ID_MAXSESSIONSIZE			15
#define ID_MAXMESSAGERECIPIENTS		15

#define ID_LOCALRETRIES				18
#define ID_REMOTERETRIES			18

#define ID_LOCALRETRYTIME			18
#define ID_REMOTERETRYTIME			18

#define ID_DO_MASQUERADE			19
#define ID_MASQUERADE				19

#define ID_ETRNDAYS					21

#define ID_SENDDNRTOPOSTMASTER		22
#define ID_SENDBADMAILTOPOSTMASTER	22
#define ID_SENDNDRTO				22
#define ID_SENDBADTO				22

#define ID_ROUTINGDLL				24
#define ID_ROUTINGSOURCES			24

#define ID_LOGFILEDIRECTORY			25
#define ID_LOGFILEPERIOD			25
#define ID_LOGFILETRUNCATESIZE		25
#define ID_LOGMETHOD				25
#define ID_LOGTYPE					25

#define ID_LOCALDOMAINS				26
#define ID_DOMAINROUTING			27

#define ID_AUTOSTART				28
#define ID_COMMENT					29


inline DWORD BitMask(DWORD dwId)
{
	_ASSERT(dwId < 32);
	return ( ((DWORD)1) << dwId );
}


// Default Values:
#define UNLIMITED                       ( 0xffffffff )

#define MAX_LONG						UNLIMITED

#define DEFAULT_SERVER_BINDINGS			( ( L":25:\0\0" ) )				// multisz
#define DEFAULT_SECURE_BINDINGS			( ( L":465:\0\0" ) )				// multisz

#define DEFAULT_COMMENT					(_T( "" ))

#define DEFAULT_SMART_HOST				(_T( "" ))
#define DEFAULT_SMART_HOST_TYPE			( 0 )

#define DEFAULT_SHOULD_DELIVER			( TRUE )
#define DEFAULT_ALLOW_EXPAND			( FALSE )
#define DEFAULT_ALLOW_VERIFY			( FALSE )

#define DEFAULT_POSTMASTER_EMAIL		(_T( "Postmaster" ))
#define DEFAULT_POSTMASTER_NAME			(_T( "Postmaster" ))

#define DEFAULT_SENDNDRTO				(_T( "" ))
#define DEFAULT_SENDBADTO				(_T( "" ))

#define DEFAULT_FQDN					(_T( "" ))
#define DEFAULT_DEFAULT_DOMAIN			(_T( "" ))

#define DEFAULT_DO_MASQUERADE			( FALSE )
#define DEFAULT_MASQUERADE_DOMAIN		(_T( "" ))

#define DEFAULT_DROP_DIR				(_T( "" ))
#define DEFAULT_BADMAIL_DIR				(_T( "" ))
#define DEFAULT_PICKUP_DIR				(_T( "" ))
#define DEFAULT_QUEUE_DIR				(_T( "" ))

#define DEFAULT_ROUTING_SOUCES			(_T( "" ))
#define DEFAULT_LOGFILE_DIRECTORY		(_T( "" ))

#define DEFAULT_AUTH_PACKAGES           (_T("NTLM"))
#define DEFAULT_CLEARTEXT_AUTH_PACKAGE  (_T(""))
#define DEFAULT_AUTHENTICATION          (MD_AUTH_ANONYMOUS | MD_AUTH_BASIC | MD_AUTH_NT)
#define DEFAULT_LOGON_DOMAIN            (_T(""))

#define DEFAULT_PORT					( 25  )
#define DEFAULT_SSLPORT					( 465 )
#define DEFAULT_OUTBOND_PORT			( 25  )
#define DEFAULT_REMOTE_SECURE_PORT		( 465  )

#define DEFAULT_HOP_COUNT				( 10  )

#define DEFAULT_ALWAYS_USE_SSL			( FALSE )
#define DEFAULT_LIMIT_REMOTE_CONNECTIONS ( TRUE )
#define DEFAULT_MAX_OUT_CONN_PER_DOMAIN	( 0 )

#define DEFAULT_MAX_IN_CONNECTION		( 1000 )
#define DEFAULT_MAX_OUT_CONNECTION		( 1000 )
#define DEFAULT_IN_CONNECTION_TIMEOUT	( 60 )
#define DEFAULT_OUT_CONNECTION_TIMEOUT	( 60 )

#define DEFAULT_BATCH_MSGS				( TRUE )
#define DEFAULT_BATCH_MSG_LIMIT			( 0 )

#define DEFAULT_MAX_MESSAGE_SIZE		( 2048 * 1024 )
#define DEFAULT_MAX_SESSION_SIZE		( 10240 * 1024 )
#define DEFAULT_MAX_MESSAGE_RECIPIENTS	( 100 )

#define DEFAULT_LOCAL_RETRIES			( 48 )
#define DEFAULT_LOCAL_RETRY_TIME		( 60 )
#define DEFAULT_REMOTE_RETRIES			( 48 )
#define DEFAULT_REMOTE_RETRY_TIME		( 60 )
#define DEFAULT_ETRN_DAYS				( 10 )


#define DEFAULT_ROUTING_DLL				( ( L"routeldp.dll" ) )

#define DEFAULT_ROUTING_SOURCES			( ( L"\0\0" ) )				// multisz

#define DEFAULT_LOCAL_DOMAINS			( ( L"corp.com\0\0" ) )		// multisz
#define DEFAULT_DOMAIN_ROUTING			( ( L"\0\0" ) )				// multisz

#define DEFAULT_ROUTE_ACTION            ( SMTP_SMARTHOST )
#define DEFAULT_ROUTE_USER_NAME         (_T("")) 
#define DEFAULT_ROUTE_PASSWORD          (_T("")) 

#define DEFAULT_LOGFILE_PERIOD			( 1 )
#define DEFAULT_LOGFILE_TRUNCATE_SIZE	( 1388000 )
#define DEFAULT_LOG_METHOD				( 0 )
#define DEFAULT_LOG_TYPE				( 1 )

#define DEFAULT_ENABLE_DNS_LOOKUP		( FALSE )
#define DEFAULT_SEND_DNR_TO_POSTMASTER	( FALSE )
#define DEFAULT_SEND_BAD_TO_POSTMASTER	( FALSE )

#define DEFAULT_AUTOSTART				( TRUE )

// Parameter ranges:
#define MIN_PORT						( 0 )
#define MIN_SSLPORT						( 0 )
#define MIN_OUTBOND_PORT				( 0 )

#define MIN_MAX_IN_CONNECTION			( 0 )
#define MIN_MAX_OUT_CONNECTION			( 0 )
#define MIN_IN_CONNECTION_TIMEOUT		( 0 )
#define MIN_OUT_CONNECTION_TIMEOUT		( 0 )

#define MIN_MAX_MESSAGE_SIZE			( 0 )
#define MIN_MAX_SESSION_SIZE			( 0 )
#define MIN_MAX_MESSAGE_RECIPIENTS		( 0 )

#define MIN_LOCAL_RETRIES				( 0 )
#define MIN_REMOTE_RETRIES				( 0 )

#define MIN_LOCAL_RETRY_TIME			( 0 )
#define MIN_REMOTE_RETRY_TIME			( 0 )
#define MIN_ETRN_DAYS					( 0 )

#define MIN_LOGFILE_PERIOD				( 0 )
#define MIN_LOGFILE_TRUNCATE_SIZE		( 0 )
#define MIN_LOG_METHOD					( 0 )
#define MIN_LOG_TYPE					( 0 )

#define MAX_PORT						( MAX_LONG )
#define MAX_SSLPORT						( MAX_LONG )
#define MAX_OUTBOND_PORT				( MAX_LONG )

#define MAX_MAX_IN_CONNECTION			( MAX_LONG )
#define MAX_MAX_OUT_CONNECTION			( MAX_LONG )
#define MAX_IN_CONNECTION_TIMEOUT		( MAX_LONG )
#define MAX_OUT_CONNECTION_TIMEOUT		( MAX_LONG )

#define MAX_MAX_MESSAGE_SIZE			( MAX_LONG )
#define MAX_MAX_SESSION_SIZE			( MAX_LONG )
#define MAX_MAX_MESSAGE_RECIPIENTS		( MAX_LONG )

#define MAX_LOCAL_RETRIES				( MAX_LONG )
#define MAX_REMOTE_RETRIES				( MAX_LONG )

#define MAX_LOCAL_RETRY_TIME			( MAX_LONG )
#define MAX_REMOTE_RETRY_TIME			( MAX_LONG )
#define MAX_ETRN_DAYS					( MAX_LONG )

#define MAX_LOGFILE_PERIOD				( MAX_LONG )
#define MAX_LOGFILE_TRUNCATE_SIZE		( MAX_LONG )
#define MAX_LOG_METHOD					( MAX_LONG )
#define MAX_LOG_TYPE					( MAX_LONG )


// string length
#define MAXLEN_SERVER					( 256 )

#define MAXLEN_SMART_HOST				( 256 )

#define MAXLEN_POSTMASTER_EMAIL			( 256 )
#define MAXLEN_POSTMASTER_NAME			( 256 )

#define MAXLEN_DEFAULT_DOMAIN			( 256 )

#define MAXLEN_BADMAIL_DIR				( 256 )
#define MAXLEN_PICKUP_DIR				( 256 )
#define MAXLEN_QUEUE_DIR				( 256 )

#define MAXLEN_ROUTING_SOUCES			( 256 )
#define MAXLEN_LOGFILE_DIRECTORY		( 256 )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\vdir.h ===
// vdir.h : Declaration of the CSmtpAdminVirtualDirectory

#ifndef _VDIR_H_
#define _VDIR_H_

#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"
#include "metafact.h"

class CMetabaseKey;

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminVirtualDirectory : 
	public CComDualImpl<ISmtpAdminVirtualDirectory, &IID_ISmtpAdminVirtualDirectory, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminVirtualDirectory,&CLSID_CSmtpAdminVirtualDirectory>
{
public:
	CSmtpAdminVirtualDirectory();
	virtual ~CSmtpAdminVirtualDirectory();
BEGIN_COM_MAP(CSmtpAdminVirtualDirectory)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmtpAdminVirtualDirectory)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminVirtualDirectory) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminVirtualDirectory, _T("Smtpadm.VirtualDirectory.1"), _T("Smtpadm.VirtualDirectory"), IDS_SMTPADMIN_VIRTUALDIRECTORY_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISmtpAdminVirtualDirectory
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:

	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );


	// Enumeration properties:
	STDMETHODIMP	get_Count	( long * plCount );


	// The current virtual directory's properties:

	STDMETHODIMP	get_VirtualName		( BSTR * pstrName );
	STDMETHODIMP	put_VirtualName		( BSTR strName );


	STDMETHODIMP	get_Directory		( BSTR * pstrPath );
	STDMETHODIMP	put_Directory		( BSTR strPath );


	STDMETHODIMP	get_User			( BSTR * pstrUserName );
	STDMETHODIMP	put_User			( BSTR strUserName );


	STDMETHODIMP	get_Password		( BSTR * pstrPassword );
	STDMETHODIMP	put_Password		( BSTR strPassword );

	STDMETHODIMP	get_LogAccess		( BOOL* pfLogAccess );
	STDMETHODIMP	put_LogAccess		( BOOL fLogAccess );

	STDMETHODIMP	get_AccessPermission( long* plAccessPermission );
	STDMETHODIMP	put_AccessPermission( long lAccessPermission );

	STDMETHODIMP	get_SslAccessPermission( long* plSslAccessPermission );
	STDMETHODIMP	put_SslAccessPermission( long lSslAccessPermission );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	// home directory "/"
	STDMETHODIMP GetHomeDirectory ( );
	STDMETHODIMP SetHomeDirectory ( );

	// create / delete entry
	STDMETHODIMP	Create			( );
	STDMETHODIMP	Delete			( );

	// get /set property for current vdir
	STDMETHODIMP	Get				( );
	STDMETHODIMP	Set				( );

	// enumeration
	STDMETHODIMP	Enumerate		( );
	STDMETHODIMP	GetNth			( long lIndex );


	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	long		m_lCount;

	CComBSTR	m_strName;
	CComBSTR	m_strDirectory;
	CComBSTR	m_strUser;
	CComBSTR	m_strPassword;
	BOOL		m_fLogAccess;

    DWORD		m_dwAccess;
    DWORD		m_dwSslAccess;


	BOOL		m_fEnumerateCalled;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	// Todo: add a list
	//PVDIR_ENTRY		m_pVdir[];

	LIST_ENTRY		m_list;


	// private methods
	void Clear();	// reset the state

	BOOL		GetVRootPropertyFromMetabase( CMetabaseKey* hMB, const TCHAR* szName, 
		TCHAR* szDirectory, TCHAR* szUser, TCHAR* szPassword, DWORD* pdwAccess,
        DWORD* pdwSslAccess, BOOL* pfLogAccess);

	BOOL		SetVRootPropertyToMetabase( CMetabaseKey* hMB, const TCHAR* szName, 
		const TCHAR* szDirectory, const TCHAR* szUser, const TCHAR* szPassword, 
		DWORD dwAccess, DWORD dwSslAccess, BOOL fLogAccess);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#pragma warning( disable : 4511 )
#include <ctype.h>
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <winsock2.h>

//  Pull in the common admin object code:
#include <admcmn.h>

#include "smtpinet.h"

#undef SMTP_MD_ROOT_PATH
#define SMTP_MD_ROOT_PATH           _T("/LM/SmtpSvc/")

#undef MD_SERVICE_NAME
#define MD_SERVICE_NAME      _T("SmtpSvc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\user.h ===
// user.h : Declaration of the CSmtpAdminUser


#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminUser : 
	public ISmtpAdminUser,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminUser,&CLSID_CSmtpAdminUser>
{
public:
	CSmtpAdminUser();
	virtual ~CSmtpAdminUser();
BEGIN_COM_MAP(CSmtpAdminUser)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminUser)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminUser) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminUser, _T("Smtpadm.User.1"), _T("Smtpadm.User"), IDS_SMTPADMIN_USER_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminUser
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminUser
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// User Properties:

	STDMETHODIMP	get_EmailId	( BSTR * pstrEmailId );
	STDMETHODIMP	put_EmailId	( BSTR strEmailId );

	STDMETHODIMP	get_Domain	( BSTR * pstrDomain );
	STDMETHODIMP	put_Domain	( BSTR strDomain );

	STDMETHODIMP	get_MailRoot	( BSTR * pstrMailRoot );
	STDMETHODIMP	put_MailRoot	( BSTR strMailRoot );

	STDMETHODIMP	get_InboxSizeInMemory	( long * plInboxSizeInMemory );
	STDMETHODIMP	put_InboxSizeInMemory	( long   lInboxSizeInMemory );

	STDMETHODIMP	get_InboxSizeInMsgNumber( long * plInboxSizeInMsgNumber );
	STDMETHODIMP	put_InboxSizeInMsgNumber( long   lInboxSizeInMsgNumber );

	STDMETHODIMP	get_AutoForward	( BOOL * pfAutoForward );
	STDMETHODIMP	put_AutoForward ( BOOL fAutoForward );

	STDMETHODIMP	get_ForwardEmail	( BSTR * pstrForwardEmail );
	STDMETHODIMP	put_ForwardEmail	( BSTR strForwardEmail );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////
	STDMETHODIMP	Default	( );

	STDMETHODIMP	Create	( );
	STDMETHODIMP	Delete	( );

	STDMETHODIMP	Get		( );
	STDMETHODIMP	Set		( );


	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	BOOL		m_fLocal;
	CComBSTR	m_strEmailId;
	CComBSTR	m_strDomain;

	CComBSTR	m_strMailRoot;

	long		m_lInboxSizeInMemory;
	long		m_lInboxSizeInMsgNumber;

	BOOL		m_fAutoForward;
	CComBSTR	m_strForwardEmail;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\virsvr.cpp ===
// service.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include <lmcons.h>
#include "IADM.h"
#include "imd.h"
#include "mdmsg.h"
#include "iisinfo.h"
#include "iiscnfgp.h"

#include "smtpprop.h"
#include "smtpadm.h"
#include "ipaccess.h"
#include "oleutil.h"
#include "metautil.h"
#include "smtpcmn.h"
#include "smtpapi.h"

#include "virsvr.h"


// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.VirtualServer.1")
#define THIS_FILE_IID               IID_ISmtpAdminVirtualServer


/////////////////////////////////////////////////////////////////////////////
//

CSmtpAdminVirtualServer::CSmtpAdminVirtualServer () :
    m_lPort         (25 ),
    m_lLogMethod    ( 0 ),
    m_dwServerState ( MD_SERVER_STATE_STOPPED ),
    m_pPrivateIpAccess          ( NULL ),
    m_dwWin32ErrorCode          ( NOERROR ),
    m_pPrivateBindings          ( NULL ),
    m_lRouteAction              ( 0 )
    // CComBSTR's are initialized to NULL by default.
{
    m_psaAdmins = NULL;
    InitAsyncTrace ( );

    // Create the Ip Access collection:
    CComObject<CTcpAccess> *    pIpAccess;

    CComObject<CTcpAccess>::CreateInstance ( &pIpAccess );
    pIpAccess->QueryInterface ( IID_ITcpAccess, (void **) &m_pIpAccess );
    m_pPrivateIpAccess = pIpAccess;
}

CSmtpAdminVirtualServer::~CSmtpAdminVirtualServer ()
{
    // All CComBSTR's are freed automatically.
    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
    }

    TermAsyncTrace ( );
}

STDMETHODIMP CSmtpAdminVirtualServer::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ISmtpAdminVirtualServer,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

// Which service to configure:
    
STDMETHODIMP CSmtpAdminVirtualServer::get_Server ( BSTR * pstrServer )
{
    return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_Server ( BSTR strServer )
{
    VALIDATE_STRING ( strServer, MAXLEN_SERVER );

    // If the server name changes, that means the client will have to
    // call Get again:

    // I assume this here:
    _ASSERT ( sizeof (DWORD) == sizeof (int) );

    return StdPropertyPutServerName ( &m_strServer, strServer, (DWORD *) &m_fGotProperties, 1);
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ServiceInstance ( long * plServiceInstance )
{
    return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ServiceInstance ( long lServiceInstance )
{
    // If the service instance changes, that means the client will have to
    // call Get again:

    // I assume this here:
    _ASSERT ( sizeof (DWORD) == sizeof (int) );
    
    return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance, (DWORD *) &m_fGotProperties, 1 );
}


STDMETHODIMP CSmtpAdminVirtualServer::get_TcpAccess ( ITcpAccess ** ppTcpAccess )
{
    return m_pIpAccess->QueryInterface ( IID_ITcpAccess, (void **) ppTcpAccess );
}


STDMETHODIMP CSmtpAdminVirtualServer::get_Bindings ( IServerBindings ** ppBindings )
{
    TraceQuietEnter ( "CSmtpAdminVirtualServer::get_Bindings" );

    HRESULT     hr = NOERROR;

    if ( !m_pBindings ) {
        ErrorTrace ( 0, "Didn't call get first" );
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_CALL_GET );
        goto Exit;
    }
    else {
        hr = m_pBindings->QueryInterface ( IID_IServerBindings, (void **) ppBindings );
        _ASSERT ( SUCCEEDED(hr) );
    }

Exit:
    if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
        hr = SmtpCreateExceptionFromHresult ( hr );
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_BindingsDispatch ( IDispatch ** ppBindings )
{
    HRESULT                         hr  = NOERROR;
    CComPtr<IServerBindings>    pBindings;

    hr = get_Bindings ( &pBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = pBindings->QueryInterface ( IID_IDispatch, (void **) ppBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

Exit:
    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingSource ( IRoutingSource ** ppRoutingSource )
{
    TraceQuietEnter ( "CSmtpAdminVirtualServer::get_RoutingSource" );

    HRESULT     hr = NOERROR;

    hr = m_RoutingSource.QueryInterface ( IID_IRoutingSource, (void **) ppRoutingSource );
    BAIL_ON_FAILURE(hr);

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingSourceDispatch ( IDispatch ** ppRoutingSource )
{
    TraceQuietEnter ( "CSmtpAdminVirtualServer::get_RoutingSourceDispatch" );

    HRESULT                 hr = NOERROR;

    hr = m_RoutingSource.QueryInterface ( IID_IDispatch, (void **) ppRoutingSource );
    BAIL_ON_FAILURE(hr);

Exit:
    TraceFunctLeave ();
    return hr;
}



// Server overridable Properties:

STDMETHODIMP CSmtpAdminVirtualServer::get_ServerBindings( SAFEARRAY ** ppsastrServerBindings )
{
    return StdPropertyGet ( &m_mszServerBindings, ppsastrServerBindings );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ServerBindings( SAFEARRAY * pstrServerBindings )
{
    return StdPropertyPut ( &m_mszServerBindings, pstrServerBindings, &m_bvChangedFields, BitMask(ID_SERVER_BINDINGS));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_ServerBindingsVariant( SAFEARRAY ** ppsavarServerBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrServerBindings        = NULL;

    hr = get_ServerBindings ( &psastrServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrServerBindings, ppsavarServerBindings );

Exit:
    if ( psastrServerBindings ) {
        SafeArrayDestroy ( psastrServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ServerBindingsVariant( SAFEARRAY * psavarServerBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrServerBindings        = NULL;

    hr = VariantArrayToStringArray ( psavarServerBindings, &psastrServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_ServerBindings ( psastrServerBindings );

Exit:
    if ( psastrServerBindings ) {
        SafeArrayDestroy ( psastrServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SecureBindings( SAFEARRAY ** ppsastrSecureBindings )
{
    return StdPropertyGet ( &m_mszSecureBindings, ppsastrSecureBindings );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SecureBindings( SAFEARRAY * pstrSecureBindings )
{
    return StdPropertyPut ( &m_mszSecureBindings, pstrSecureBindings, &m_bvChangedFields, BitMask(ID_SECURE_BINDINGS));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_SecureBindingsVariant( SAFEARRAY ** ppsavarSecureBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrSecureServerBindings        = NULL;

    hr = get_SecureBindings ( &psastrSecureServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrSecureServerBindings, ppsavarSecureBindings );

Exit:
    if ( psastrSecureServerBindings ) {
        SafeArrayDestroy ( psastrSecureServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SecureBindingsVariant( SAFEARRAY * psavarSecureBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrSecureServerBindings        = NULL;

    hr = VariantArrayToStringArray ( psavarSecureBindings, &psastrSecureServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_SecureBindings ( psastrSecureServerBindings );

Exit:
    if ( psastrSecureServerBindings ) {
        SafeArrayDestroy ( psastrSecureServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_Port( long * plPort )
{
    return StdPropertyGet ( m_lPort, plPort );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_Port( long lPort )
{
    return StdPropertyPut ( &m_lPort, lPort, &m_bvChangedFields, BitMask(ID_PORT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SSLPort( long * plSSLPort )
{
    return StdPropertyGet ( m_lSSLPort, plSSLPort );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SSLPort( long lSSLPort )
{
    return StdPropertyPut ( &m_lSSLPort, lSSLPort, &m_bvChangedFields, BitMask(ID_SSLPORT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_OutboundPort( long * plOutboundPort )
{
    return StdPropertyGet ( m_lOutboundPort, plOutboundPort );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_OutboundPort( long lOutboundPort )
{
    return StdPropertyPut ( &m_lOutboundPort, lOutboundPort, &m_bvChangedFields, BitMask(ID_OUTBOUNDPORT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_HopCount( long * plHopCount )
{
    return StdPropertyGet ( m_lHopCount, plHopCount );
}


STDMETHODIMP CSmtpAdminVirtualServer::put_HopCount( long lHopCount )
{
    return StdPropertyPut ( &m_lHopCount, lHopCount, &m_bvChangedFields, BitMask(ID_HOP_COUNT));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_SmartHost( BSTR * pstrSmartHost )
{
    return StdPropertyGet ( m_strSmartHost, pstrSmartHost );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SmartHost( BSTR strSmartHost )
{
    return StdPropertyPut ( &m_strSmartHost, strSmartHost, &m_bvChangedFields, BitMask(ID_SMARTHOST));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_EnableDNSLookup( BOOL * pfEnableDNSLookup )
{
    return StdPropertyGet ( m_fEnableDNSLookup, pfEnableDNSLookup );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_EnableDNSLookup( BOOL fEnableDNSLookup )
{
    return StdPropertyPut ( &m_fEnableDNSLookup, fEnableDNSLookup, &m_bvChangedFields, BitMask(ID_ENABLEDNSLOOKUP));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_PostmasterEmail( BSTR * pstrPostmasterEmail )
{
    return StdPropertyGet ( m_strPostmasterEmail, pstrPostmasterEmail );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_PostmasterEmail( BSTR strPostmasterEmail )
{
    return StdPropertyPut ( &m_strPostmasterEmail, strPostmasterEmail, &m_bvChangedFields, BitMask(ID_POSTMASTEREMAIL));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_PostmasterName( BSTR * pstrPostmasterName )
{
    return StdPropertyGet ( m_strPostmasterName, pstrPostmasterName );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_PostmasterName( BSTR strPostmasterName )
{
    return StdPropertyPut ( &m_strPostmasterName, strPostmasterName, &m_bvChangedFields, BitMask(ID_POSTMASTERNAME));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_DefaultDomain( BSTR * pstrDefaultDomain )
{
    return StdPropertyGet ( m_strDefaultDomain, pstrDefaultDomain );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DefaultDomain( BSTR strDefaultDomain )
{
    return StdPropertyPut ( &m_strDefaultDomain, strDefaultDomain, &m_bvChangedFields, BitMask(ID_DEFAULTDOMAIN));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_FQDN( BSTR * pstrFQDN )
{
    return StdPropertyGet ( m_strFQDN, pstrFQDN );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_FQDN( BSTR strFQDN )
{
    return StdPropertyPut ( &m_strFQDN, strFQDN, &m_bvChangedFields, BitMask(ID_FQDN));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_DropDir( BSTR * pstrDropDir )
{
    return StdPropertyGet ( m_strDropDir, pstrDropDir );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DropDir( BSTR strDropDir )
{
    return StdPropertyPut ( &m_strDropDir, strDropDir, &m_bvChangedFields, BitMask(ID_DROPDIR));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_BadMailDir( BSTR * pstrBadMailDir )
{
    return StdPropertyGet ( m_strBadMailDir, pstrBadMailDir );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_BadMailDir( BSTR strBadMailDir )
{
    return StdPropertyPut ( &m_strBadMailDir, strBadMailDir, &m_bvChangedFields, BitMask(ID_BADMAILDIR));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_PickupDir( BSTR * pstrPickupDir )
{
    return StdPropertyGet ( m_strPickupDir, pstrPickupDir );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_PickupDir( BSTR strPickupDir )
{
    return StdPropertyPut ( &m_strPickupDir, strPickupDir, &m_bvChangedFields, BitMask(ID_PICKUPDIR));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_QueueDir( BSTR * pstrQueueDir )
{
    return StdPropertyGet ( m_strQueueDir, pstrQueueDir );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_QueueDir( BSTR strQueueDir )
{
    return StdPropertyPut ( &m_strQueueDir, strQueueDir, &m_bvChangedFields, BitMask(ID_QUEUEDIR));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxInConnection( long * plMaxInConnection )
{
    return StdPropertyGet ( m_lMaxInConnection, plMaxInConnection );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxInConnection( long lMaxInConnection )
{
    return StdPropertyPut ( &m_lMaxInConnection, lMaxInConnection, &m_bvChangedFields, BitMask(ID_MAXINCONNECTION));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxOutConnection( long * plMaxOutConnection )
{
    return StdPropertyGet ( m_lMaxOutConnection, plMaxOutConnection );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxOutConnection( long lMaxOutConnection )
{
    return StdPropertyPut ( &m_lMaxOutConnection, lMaxOutConnection, &m_bvChangedFields, BitMask(ID_MAXOUTCONNECTION));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_InConnectionTimeout( long * plInConnectionTimeout )
{
    return StdPropertyGet ( m_lInConnectionTimeout, plInConnectionTimeout );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_InConnectionTimeout( long lInConnectionTimeout )
{
    return StdPropertyPut ( &m_lInConnectionTimeout, lInConnectionTimeout, &m_bvChangedFields, BitMask(ID_INCONNECTIONTIMEOUT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_OutConnectionTimeout( long * plOutConnectionTimeout )
{
    return StdPropertyGet ( m_lOutConnectionTimeout, plOutConnectionTimeout );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_OutConnectionTimeout( long lOutConnectionTimeout )
{
    return StdPropertyPut ( &m_lOutConnectionTimeout, lOutConnectionTimeout, &m_bvChangedFields, BitMask(ID_OUTCONNECTIONTIMEOUT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxMessageSize( long * plMaxMessageSize )
{
    return StdPropertyGet ( m_lMaxMessageSize, plMaxMessageSize );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxMessageSize( long lMaxMessageSize )
{
    return StdPropertyPut ( &m_lMaxMessageSize, lMaxMessageSize, &m_bvChangedFields, BitMask(ID_MAXMESSAGESIZE));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxSessionSize( long * plMaxSessionSize )
{
    return StdPropertyGet ( m_lMaxSessionSize, plMaxSessionSize );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxSessionSize( long lMaxSessionSize )
{
    return StdPropertyPut ( &m_lMaxSessionSize, lMaxSessionSize, &m_bvChangedFields, BitMask(ID_MAXSESSIONSIZE));
}
STDMETHODIMP CSmtpAdminVirtualServer::get_MaxMessageRecipients( long * plMaxMessageRecipients )
{
    return StdPropertyGet ( m_lMaxMessageRecipients, plMaxMessageRecipients );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxMessageRecipients( long lMaxMessageRecipients )
{
    return StdPropertyPut ( &m_lMaxMessageRecipients, lMaxMessageRecipients, &m_bvChangedFields, BitMask(ID_MAXMESSAGERECIPIENTS));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LocalRetries( long * plLocalRetries )
{
    return StdPropertyGet ( m_lLocalRetries, plLocalRetries );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LocalRetries( long lLocalRetries )
{
    return StdPropertyPut ( &m_lLocalRetries, lLocalRetries, &m_bvChangedFields, BitMask(ID_LOCALRETRIES));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LocalRetryTime( long * plLocalRetryTime )
{
    return StdPropertyGet ( m_lLocalRetryTime, plLocalRetryTime );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LocalRetryTime( long lLocalRetryTime )
{
    return StdPropertyPut ( &m_lLocalRetryTime, lLocalRetryTime, &m_bvChangedFields, BitMask(ID_LOCALRETRYTIME));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RemoteRetries( long * plRemoteRetries )
{
    return StdPropertyGet ( m_lRemoteRetries, plRemoteRetries );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RemoteRetries( long lRemoteRetries )
{
    return StdPropertyPut ( &m_lRemoteRetries, lRemoteRetries, &m_bvChangedFields, BitMask(ID_REMOTERETRIES));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RemoteRetryTime( long * plRemoteRetryTime )
{
    return StdPropertyGet ( m_lRemoteRetryTime, plRemoteRetryTime );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RemoteRetryTime( long lRemoteRetryTime )
{
    return StdPropertyPut ( &m_lRemoteRetryTime, lRemoteRetryTime, &m_bvChangedFields, BitMask(ID_REMOTERETRYTIME));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ETRNDays( long * plETRNDays )
{
    return StdPropertyGet ( m_lETRNDays, plETRNDays );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ETRNDays( long lETRNDays )
{
    return StdPropertyPut ( &m_lETRNDays, lETRNDays, &m_bvChangedFields, BitMask(ID_ETRNDAYS));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SendDNRToPostmaster( BOOL * pfSendDNRToPostmaster )
{
    return StdPropertyGet ( m_fSendDNRToPostmaster, pfSendDNRToPostmaster );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SendDNRToPostmaster( BOOL fSendDNRToPostmaster )
{
    return StdPropertyPut ( &m_fSendDNRToPostmaster, fSendDNRToPostmaster, &m_bvChangedFields, BitMask(ID_SENDDNRTOPOSTMASTER));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SendBadmailToPostmaster( BOOL * pfSendBadmailToPostmaster)
{
    return StdPropertyGet ( m_fSendBadmailToPostmaster, pfSendBadmailToPostmaster );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SendBadmailToPostmaster( BOOL fSendBadmailToPostmaster )
{
    return StdPropertyPut ( &m_fSendBadmailToPostmaster, fSendBadmailToPostmaster, &m_bvChangedFields, BitMask(ID_SENDBADMAILTOPOSTMASTER));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingDLL( BSTR * pstrRoutingDLL )
{
    return StdPropertyGet ( m_strRoutingDLL, pstrRoutingDLL );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RoutingDLL( BSTR strRoutingDLL )
{
    return StdPropertyPut ( &m_strRoutingDLL, strRoutingDLL, &m_bvChangedFields, BitMask(ID_ROUTINGDLL));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingSources    ( SAFEARRAY ** ppsastrRoutingSources )
{
    return StdPropertyGet ( &m_mszRoutingSources, ppsastrRoutingSources );
}
STDMETHODIMP CSmtpAdminVirtualServer::put_RoutingSources    ( SAFEARRAY * psastrRoutingSources )
{
    return StdPropertyPut ( &m_mszRoutingSources, psastrRoutingSources, &m_bvChangedFields, BitMask(ID_ROUTINGSOURCES) );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingSourcesVariant( SAFEARRAY ** ppsavarRoutingSources )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrRoutingSources        = NULL;

    hr = get_RoutingSources ( &psastrRoutingSources );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrRoutingSources, ppsavarRoutingSources );

Exit:
    if ( psastrRoutingSources ) {
        SafeArrayDestroy ( psastrRoutingSources );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RoutingSourcesVariant( SAFEARRAY * psavarRoutingSources )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrRoutingSources        = NULL;

    hr = VariantArrayToStringArray ( psavarRoutingSources, &psastrRoutingSources );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_RoutingSources ( psastrRoutingSources );

Exit:
    if ( psastrRoutingSources ) {
        SafeArrayDestroy ( psastrRoutingSources );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::get_LocalDomains  ( SAFEARRAY ** ppsastrLocalDomains )
{
    return StdPropertyGet ( &m_mszLocalDomains, ppsastrLocalDomains );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LocalDomains  ( SAFEARRAY * psastrLocalDomains )
{
    return StdPropertyPut ( &m_mszLocalDomains, psastrLocalDomains, &m_bvChangedFields, BitMask(ID_LOCALDOMAINS) );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_DomainRouting ( SAFEARRAY ** ppsastrDomainRouting )
{
    return StdPropertyGet ( &m_mszDomainRouting, ppsastrDomainRouting );
}
STDMETHODIMP CSmtpAdminVirtualServer::put_DomainRouting ( SAFEARRAY * psastrDomainRouting )
{
    return StdPropertyPut ( &m_mszDomainRouting, psastrDomainRouting, &m_bvChangedFields, BitMask(ID_DOMAINROUTING) );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_DomainRoutingVariant( SAFEARRAY ** ppsavarDomainRouting )
{
    HRESULT                 hr;
    SAFEARRAY *             pstrDomainRouting        = NULL;

    hr = get_DomainRouting ( &pstrDomainRouting );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( pstrDomainRouting, ppsavarDomainRouting );

Exit:
    if ( pstrDomainRouting ) {
        SafeArrayDestroy ( pstrDomainRouting );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DomainRoutingVariant( SAFEARRAY * psastrDomainRouting )
{
    HRESULT                 hr;
    SAFEARRAY *             pstrDomainRouting        = NULL;

    hr = VariantArrayToStringArray ( psastrDomainRouting, &pstrDomainRouting );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_DomainRouting ( pstrDomainRouting );

Exit:
    if ( pstrDomainRouting ) {
        SafeArrayDestroy ( pstrDomainRouting );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::get_MasqueradeDomain( BSTR * pstrMasqueradeDomain )
{
    return StdPropertyGet ( m_strMasqueradeDomain, pstrMasqueradeDomain );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MasqueradeDomain( BSTR strMasqueradeDomain )
{
    return StdPropertyPut ( &m_strMasqueradeDomain, strMasqueradeDomain, &m_bvChangedFields, BitMask(ID_MASQUERADE));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SendNdrTo( BSTR * pstrAddr )
{
    return StdPropertyGet( m_strNdrAddr, pstrAddr );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SendNdrTo( BSTR strAddr )
{
    return StdPropertyPut ( &m_strNdrAddr, strAddr, &m_bvChangedFields, BitMask(ID_SENDNDRTO));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SendBadTo( BSTR * pstrAddr )
{
    return StdPropertyGet( m_strBadAddr, pstrAddr );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SendBadTo( BSTR strAddr )
{
    return StdPropertyPut ( &m_strBadAddr, strAddr, &m_bvChangedFields, BitMask(ID_SENDBADTO));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RemoteSecurePort( long * plRemoteSecurePort )
{
    return StdPropertyGet( m_lRemoteSecurePort, plRemoteSecurePort );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RemoteSecurePort( long lRemoteSecurePort )
{
    return StdPropertyPut ( &m_lRemoteSecurePort, lRemoteSecurePort, &m_bvChangedFields, BitMask(ID_REMOTE_SECURE_PORT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ShouldDeliver( BOOL * pfShouldDeliver )
{
    return StdPropertyGet( m_fShouldDeliver, pfShouldDeliver );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ShouldDeliver( BOOL fShouldDeliver )
{
    return StdPropertyPut ( &m_fShouldDeliver, fShouldDeliver, &m_bvChangedFields, BitMask(ID_SHOULD_DELIVER));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_AlwaysUseSsl( BOOL * pfAlwaysUseSsl )
{
    return StdPropertyGet( m_fAlwaysUseSsl, pfAlwaysUseSsl );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AlwaysUseSsl( BOOL fAlwaysUseSsl )
{
    return StdPropertyPut ( &m_fAlwaysUseSsl, fAlwaysUseSsl, &m_bvChangedFields, BitMask(ID_ALWAYS_USE_SSL));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LimitRemoteConnections( BOOL * pfLimitRemoteConnections )
{
    return StdPropertyGet( m_fLimitRemoteConnections, pfLimitRemoteConnections );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LimitRemoteConnections( BOOL fLimitRemoteConnections )
{
    return StdPropertyPut ( &m_fLimitRemoteConnections, fLimitRemoteConnections, &m_bvChangedFields, BitMask(ID_LIMIT_REMOTE_CONNECTIONS));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxOutConnPerDomain( long * plMaxOutConnPerDomain )
{
    return StdPropertyGet( m_lMaxOutConnPerDomain, plMaxOutConnPerDomain );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxOutConnPerDomain( long lMaxOutConnPerDomain )
{
    return StdPropertyPut ( &m_lMaxOutConnPerDomain, lMaxOutConnPerDomain, &m_bvChangedFields, BitMask(ID_MAX_OUT_CONN_PER_DOMAIN));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_AllowVerify( BOOL * pfAllowVerify )
{
    return StdPropertyGet( m_fAllowVerify, pfAllowVerify );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AllowVerify( BOOL fAllowVerify )
{
    return StdPropertyPut ( &m_fAllowVerify, fAllowVerify, &m_bvChangedFields, BitMask(ID_ALLOW_VERIFY));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_AllowExpand( BOOL * pfAllowExpand )
{
    return StdPropertyGet( m_fAllowExpand, pfAllowExpand);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AllowExpand( BOOL fAllowExpand )
{
    return StdPropertyPut ( &m_fAllowExpand, fAllowExpand, &m_bvChangedFields, BitMask(ID_ALLOW_EXPAND));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_SmartHostType( long * plSmartHostType )
{
    return StdPropertyGet( m_lSmartHostType, plSmartHostType );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SmartHostType( long lSmartHostType )
{
    return StdPropertyPut ( &m_lSmartHostType, lSmartHostType, &m_bvChangedFields, BitMask(ID_SMART_HOST_TYPE));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_BatchMessages( BOOL * pfBatchMessages )
{
    return StdPropertyGet( m_fBtachMsgs, pfBatchMessages );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_BatchMessages( BOOL fBatchMessages )
{
    return StdPropertyPut ( &m_fBtachMsgs, fBatchMessages, &m_bvChangedFields, BitMask(ID_BATCH_MSGS));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_BatchMessageLimit( long * plBatchMessageLimit )
{
    return StdPropertyGet( m_lBatchMsgLimit, plBatchMessageLimit );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_BatchMessageLimit( long lBatchMessageLimit )
{
    return StdPropertyPut ( &m_lBatchMsgLimit, lBatchMessageLimit, &m_bvChangedFields, BitMask(ID_BATCH_MSG_LIMIT));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_DoMasquerade( BOOL * pfDoMasquerade )
{
    return StdPropertyGet( m_fDoMasquerade, pfDoMasquerade );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DoMasquerade( BOOL fDoMasquerade )
{
    return StdPropertyPut ( &m_fDoMasquerade, fDoMasquerade, &m_bvChangedFields, BitMask(ID_DO_MASQUERADE));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_Administrators ( SAFEARRAY ** ppsastrAdmins )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::get_Administrators" );

    HRESULT     hr  = NOERROR;

    if ( m_psaAdmins ) {
        hr = SafeArrayCopy ( m_psaAdmins, ppsastrAdmins );
    }
    else {
        *ppsastrAdmins = NULL;
        hr = NOERROR;
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_Administrators ( SAFEARRAY * psastrAdmins )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::put_Administrators" );

    HRESULT     hr  = NOERROR;

    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
    }

    if ( psastrAdmins ) {
        hr = SafeArrayCopy ( psastrAdmins, &m_psaAdmins );
    }
    else {
        m_psaAdmins = NULL;
        hr = NOERROR;
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_AdministratorsVariant( SAFEARRAY ** ppsavarAdmins )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrAdmins        = NULL;

    hr = get_Administrators ( &psastrAdmins );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrAdmins, ppsavarAdmins );

Exit:
    if ( psastrAdmins ) {
        SafeArrayDestroy ( psastrAdmins );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AdministratorsVariant( SAFEARRAY * psavarAdmins )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrAdmins        = NULL;

    hr = VariantArrayToStringArray ( psavarAdmins, &psastrAdmins );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_Administrators ( psastrAdmins );

Exit:
    if ( psastrAdmins ) {
        SafeArrayDestroy ( psastrAdmins );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::get_AuthenticationPackages(BSTR *pstrAuthPackages)
{
    return StdPropertyGet(m_strAuthPackages, pstrAuthPackages);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AuthenticationPackages(BSTR strAuthPackages)
{
    return StdPropertyPut(&m_strAuthPackages, strAuthPackages, &m_bvChangedFields,
        BitMask(ID_AUTH_PACKAGES));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ClearTextAuthPackage(BSTR *pstrAuthPackages)
{
    return StdPropertyGet(m_strClearTextAuthPackage, pstrAuthPackages);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ClearTextAuthPackage(BSTR strAuthPackages)
{
    return StdPropertyPut(&m_strClearTextAuthPackage, strAuthPackages, &m_bvChangedFields,
        BitMask(ID_CLEARTEXT_AUTH_PACKAGE));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_AuthenticationMethod(long *plAuthMethod)
{
    return StdPropertyGet(m_lAuthMethod, plAuthMethod);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AuthenticationMethod(long lAuthMethod)
{
    return StdPropertyPut(&m_lAuthMethod, lAuthMethod, &m_bvChangedFields,
        BitMask(ID_AUTH_METHOD));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_DefaultLogonDomain(BSTR *pstrLogonDomain)
{
    return StdPropertyGet(m_strDefaultLogonDomain, pstrLogonDomain);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DefaultLogonDomain(BSTR strLogonDomain)
{
    return StdPropertyPut(&m_strDefaultLogonDomain, strLogonDomain, &m_bvChangedFields,
        BitMask(ID_DEFAULT_LOGON_DOMAIN));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RouteAction(long *plRouteAction)
{
    return StdPropertyGet(m_lRouteAction, plRouteAction);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RouteAction(long lRouteAction)
{
    return StdPropertyPut(&m_lRouteAction, lRouteAction, &m_bvChangedFields,
        BitMask(ID_ROUTE_ACTION));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RouteUserName(BSTR *pstrRouteUserName)
{
    return StdPropertyGet(m_strRouteUserName, pstrRouteUserName);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RouteUserName(BSTR strRouteUserName)
{
    return StdPropertyPut(&m_strRouteUserName, strRouteUserName, &m_bvChangedFields,
        BitMask(ID_ROUTE_USER_NAME));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RoutePassword(BSTR *pstrRoutePassword)
{
    return StdPropertyGet(m_strRoutePassword, pstrRoutePassword);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RoutePassword(BSTR strRoutePassword)
{
    return StdPropertyPut(&m_strRoutePassword, strRoutePassword, &m_bvChangedFields,
        BitMask(ID_ROUTE_PASSWORD));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_LogFileDirectory( BSTR * pstrLogFileDirectory )
{
    return StdPropertyGet ( m_strLogFileDirectory, pstrLogFileDirectory );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogFileDirectory( BSTR strLogFileDirectory )
{
    return StdPropertyPut ( &m_strLogFileDirectory, strLogFileDirectory, &m_bvChangedFields, BitMask(ID_LOGFILEDIRECTORY));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LogFilePeriod( long * plLogFilePeriod )
{
    return StdPropertyGet ( m_lLogFilePeriod, plLogFilePeriod );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogFilePeriod( long lLogFilePeriod )
{
    return StdPropertyPut ( &m_lLogFilePeriod, lLogFilePeriod, &m_bvChangedFields, BitMask(ID_LOGFILEPERIOD));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LogFileTruncateSize( long * plLogFileTruncateSize )
{
    return StdPropertyGet ( m_lLogFileTruncateSize, plLogFileTruncateSize );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogFileTruncateSize( long lLogFileTruncateSize )
{
    return StdPropertyPut ( &m_lLogFileTruncateSize, lLogFileTruncateSize, &m_bvChangedFields, BitMask(ID_LOGFILETRUNCATESIZE));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LogMethod( long * plLogMethod )
{
    return StdPropertyGet ( m_lLogMethod, plLogMethod );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogMethod( long lLogMethod )
{
    return StdPropertyPut ( &m_lLogMethod, lLogMethod, &m_bvChangedFields, BitMask(ID_LOGMETHOD));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LogType( long * plLogType )
{
    return StdPropertyGet ( m_lLogType, plLogType );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogType( long lLogType )
{
    return StdPropertyPut ( &m_lLogType, lLogType, &m_bvChangedFields, BitMask(ID_LOGTYPE));
}


//
//  Service State Properties:
//
STDMETHODIMP CSmtpAdminVirtualServer::get_AutoStart ( BOOL * pfAutoStart )
{
    return StdPropertyGet ( m_fAutoStart, pfAutoStart );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AutoStart ( BOOL fAutoStart )
{
    return StdPropertyPut ( &m_fAutoStart, fAutoStart, &m_bvChangedFields, BitMask(ID_AUTOSTART) );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ServerState ( DWORD * pdwServerState )
{
    return StdPropertyGet ( (long)m_dwServerState, (long *)pdwServerState );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_Win32ErrorCode ( long * plWin32ErrorCode )
{
    return StdPropertyGet ( m_dwWin32ErrorCode, plWin32ErrorCode );
}


// Service-specific properties:

STDMETHODIMP CSmtpAdminVirtualServer::get_Comment( BSTR * pstrComment )
{
    return StdPropertyGet ( m_strComment, pstrComment );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_Comment( BSTR strComment )
{
    return StdPropertyPut ( &m_strComment, strComment, &m_bvChangedFields, BitMask(ID_COMMENT));
}

/*
STDMETHODIMP CSmtpAdminVirtualServer::get_ErrorControl ( BOOL * pfErrorControl )
{
    return StdPropertyGet ( m_fErrorControl, pfErrorControl );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ErrorControl ( BOOL fErrorControl )
{
    return StdPropertyPut ( &m_fErrorControl, fErrorControl );
}
*/

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminVirtualServer::BackupRoutingTable( BSTR strPath )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::BackupRoutingTable" );

    HRESULT         hr      = NOERROR;
    DWORD           dwErr   = NOERROR;

    dwErr = SmtpBackupRoutingTable ( 
                    (LPWSTR) m_strServer,  
                    (LPWSTR) strPath,
                    (int)m_dwServiceInstance );

    if ( dwErr != 0 ) {
        ErrorTraceX ( (LPARAM) this, "Failed to backup routing table: %x", dwErr );
        SetLastError( dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

Exit:
    TraceFunctLeave ();
    return hr;
}


//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::Get
//
//  Description:
//
//      Gets server properties from the metabase.
//
//  Parameters:
//
//      (property) m_strServer
//      (property) m_dwServiceInstance - which SMTP to talk to.
//
//  Returns:
//
//      E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdminVirtualServer::Get ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Get" );

    HRESULT                             hr = NOERROR;
    CComPtr<IMSAdminBase>              pmetabase;
    CComObject<CServerBindings> *       pBindings = NULL;

    // Create the bindings collection:
    m_pBindings.Release ();

    hr = CComObject<CServerBindings>::CreateInstance ( &pBindings );
    if ( FAILED(hr) ) {
        FatalTrace ( (LPARAM) this, "Could not create bindings collection" );
        goto Exit;
    }

    hr = pBindings->QueryInterface ( IID_IServerBindings, (void **) &m_pBindings );
    _ASSERT ( SUCCEEDED(hr) );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    m_pPrivateBindings  = pBindings;


    // Validate Server & Service Instance:

    // Talk to the metabase:
    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = GetPropertiesFromMetabase ( pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    StateTrace ( 0, "Successfully got service properties" );
    m_fGotProperties    = TRUE;
    m_bvChangedFields   = 0;

Exit:
    TraceFunctLeave ();

    return hr;

    // CComPtr automatically releases the metabase handle.
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::Set
//
//  Description:
//
//      Sends server properties to the metabase.
//
//  Parameters:
//
//      (property) m_strServer
//      fFailIfChanged - return an error if the metabase has changed?
//
//  Returns:
//
//      E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdminVirtualServer::Set ( BOOL fFailIfChanged )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Set" );

    HRESULT hr  = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;
    

    // Make sure the client call Get first:
    if ( !m_fGotProperties ) {
        ErrorTrace ( 0, "Didn't call get first" );

        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_CALL_GET );
        goto Exit;
    }

    // Validate Server & Service Instance:
    if ( m_dwServiceInstance == 0 ) {
        return SmtpCreateException ( IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
    }

    if ( !m_fGotProperties ) {
        return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_CALL_GET );
    }

    // Validate data members:
    if ( !ValidateStrings () ) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if ( !ValidateProperties ( ) ) {
        hr = SmtpCreateExceptionFromWin32Error ( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = SendPropertiesToMetabase ( fFailIfChanged, pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    StateTrace ( 0, "Successfully set service properties" );

    // successfully saved, reset change field bitmap
    m_bvChangedFields = 0;

Exit:
    TraceFunctLeave ();
    return hr;
}


#define MAX_SLEEP_INST      30000
#define SLEEP_INTERVAL      500

HRESULT CSmtpAdminVirtualServer::ControlService (
    IMSAdminBase *  pMetabase,
    DWORD           ControlCode,
    DWORD           dwDesiredState,
    DWORD           dwPendingState
    )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::ControlService" );

    HRESULT hr              = NOERROR;
    DWORD   dwCurrentState  = dwPendingState;
    DWORD   dwOldState      = dwPendingState;
    DWORD   dwSleepTotal    = 0;

    hr = CheckServiceState ( pMetabase, &dwCurrentState );
    BAIL_ON_FAILURE(hr);

    if ( dwCurrentState == dwDesiredState ) {
        // Nothing to do...
        goto Exit;
    }

    dwOldState  = dwCurrentState;

    //
    //  Special case: trying to start a paused service:
    //

    if ( dwDesiredState == MD_SERVER_STATE_STARTED &&
        dwCurrentState == MD_SERVER_STATE_PAUSED ) {

        ControlCode     = MD_SERVER_COMMAND_CONTINUE;
        dwPendingState  = MD_SERVER_STATE_CONTINUING;
    }
    
    hr = WriteStateCommand ( pMetabase, ControlCode );
    BAIL_ON_FAILURE(hr);

    for(dwSleepTotal = 0, dwCurrentState = dwPendingState;
        (dwCurrentState == dwPendingState || dwCurrentState == dwOldState) && (dwSleepTotal < MAX_SLEEP_INST); 
        dwSleepTotal += SLEEP_INTERVAL
        ) 
    {
        Sleep ( SLEEP_INTERVAL );

        hr = CheckServiceState ( pMetabase, &dwCurrentState );
        BAIL_ON_FAILURE(hr);

        if ( m_dwWin32ErrorCode != NOERROR ) {
            //
            // The service gave an error code.
            //

            break;
        }
    }

    if ( dwSleepTotal >= MAX_SLEEP_INST ) {
        hr = HRESULT_FROM_WIN32 ( ERROR_SERVICE_REQUEST_TIMEOUT );
        goto Exit;
    }

Exit:
    // m_State = TranslateServerState ( dwCurrentState );

    m_dwServerState = dwCurrentState;

    TraceFunctLeave ();
    return hr;
}

HRESULT CSmtpAdminVirtualServer::WriteStateCommand ( IMSAdminBase * pMetabase, DWORD ControlCode )
{
    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;
    TCHAR   szInstancePath [ METADATA_MAX_NAME_LEN ];

    GetMDInstancePath ( szInstancePath, m_dwServiceInstance );

    hr = metabase.Open ( szInstancePath, METADATA_PERMISSION_WRITE );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    fRet = fRet && StdPutMetabaseProp ( &metabase, MD_WIN32_ERROR, NOERROR, _T(""), IIS_MD_UT_SERVER, METADATA_VOLATILE );
    fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_COMMAND, ControlCode );
    if ( !fRet ) {
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CSmtpAdminVirtualServer::CheckServiceState ( IMSAdminBase * pMetabase, DWORD * pdwState )
{
    HRESULT     hr  = NOERROR;
    CMetabaseKey            metabase ( pMetabase );
    TCHAR       szInstancePath [ METADATA_MAX_NAME_LEN ];
    BOOL        fRet = TRUE;

    *pdwState   = MD_SERVER_STATE_INVALID;

    GetMDInstancePath ( szInstancePath, m_dwServiceInstance );
    hr = metabase.Open ( szInstancePath );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    fRet = metabase.GetDword ( MD_WIN32_ERROR, &m_dwWin32ErrorCode );
    fRet = metabase.GetDword ( MD_SERVER_STATE, pdwState );

Exit:
    if ( !fRet ) {
        hr = HRESULT_FROM_WIN32( GetLastError () );
    }
    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::Start ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Start" );

    HRESULT                 hr      = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = ControlService ( 
        pmetabase, 
        MD_SERVER_COMMAND_START, 
        MD_SERVER_STATE_STARTED, 
        MD_SERVER_STATE_STARTING 
        );

Exit:
    TraceFunctLeave ();
    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::Pause ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Pause" );

    HRESULT                 hr      = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = ControlService ( 
        pmetabase, 
        MD_SERVER_COMMAND_PAUSE, 
        MD_SERVER_STATE_PAUSED, 
        MD_SERVER_STATE_PAUSING 
        );

Exit:
    TraceFunctLeave ();
    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::Continue ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Pause" );

    HRESULT                 hr      = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = ControlService ( 
        pmetabase, 
        MD_SERVER_COMMAND_CONTINUE, 
        MD_SERVER_STATE_STARTED, 
        MD_SERVER_STATE_CONTINUING 
        );

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::Stop ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Start" );

    HRESULT                 hr      = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = ControlService ( 
        pmetabase, 
        MD_SERVER_COMMAND_STOP, 
        MD_SERVER_STATE_STOPPED, 
        MD_SERVER_STATE_STOPPING 
        );

Exit:
    TraceFunctLeave ();
    return hr;
}


//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::GetPropertiesFromMetabase
//
//  Description:
//
//      Asks the metabase for each property in this class.
//      This class's properties come from /LM/SmtpSvc/
//
//  Parameters:
//
//      pMetabase - The metabase object
//
//  Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdminVirtualServer::GetPropertiesFromMetabase ( IMSAdminBase * pMetabase )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::GetPropertiesFromMetabase" );

    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;

    TCHAR   szInstancePath [ METADATA_MAX_NAME_LEN ];
    WCHAR   wszDefaultComment[128]={0};

    PSECURITY_DESCRIPTOR        pSD = NULL;
    DWORD                       cbSD    = 0;

    GetMDInstancePath ( szInstancePath, m_dwServiceInstance );
    wsprintfW( wszDefaultComment, L"[SMTP Virtual Server #%d]", m_dwServiceInstance );

    hr = metabase.Open ( szInstancePath );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    // Overridable server properties:

    hr = m_RoutingSource.Get(&metabase);
    BAIL_ON_FAILURE(hr);
#if 0
    fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_PORT,          DEFAULT_SSLPORT,            &m_lSSLPort )           && fRet;
#endif
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT,     DEFAULT_OUTBOND_PORT,       &m_lOutboundPort )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   DEFAULT_SMART_HOST,             &m_strSmartHost )       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_HOP_COUNT,        DEFAULT_HOP_COUNT,              &m_lHopCount )      && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,DEFAULT_ENABLE_DNS_LOOKUP,    &m_fEnableDNSLookup )   && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, DEFAULT_POSTMASTER_EMAIL,       &m_strPostmasterEmail ) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  DEFAULT_POSTMASTER_NAME,        &m_strPostmasterName )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_FQDN_VALUE,           DEFAULT_FQDN,               &m_strFQDN )            && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, DEFAULT_DEFAULT_DOMAIN,     &m_strDefaultDomain )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_DROP_DIR,        DEFAULT_DROP_DIR,           &m_strDropDir )         && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     DEFAULT_BADMAIL_DIR,            &m_strBadMailDir )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  DEFAULT_PICKUP_DIR,             &m_strPickupDir )       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   DEFAULT_QUEUE_DIR,              &m_strQueueDir )        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  DEFAULT_MAX_OUT_CONNECTION,     &m_lMaxOutConnection )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,   DEFAULT_OUT_CONNECTION_TIMEOUT, &m_lOutConnectionTimeout )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,     DEFAULT_MAX_MESSAGE_SIZE,       &m_lMaxMessageSize )        && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    DEFAULT_MAX_SESSION_SIZE,       &m_lMaxSessionSize )        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,       DEFAULT_MAX_MESSAGE_RECIPIENTS,     &m_lMaxMessageRecipients )      && fRet;


    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     DEFAULT_LOCAL_RETRIES,      &m_lLocalRetries)       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      DEFAULT_LOCAL_RETRY_TIME,   &m_lLocalRetryTime)     && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_RETRY_ATTEMPTS,    DEFAULT_REMOTE_RETRIES,     &m_lRemoteRetries)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     DEFAULT_REMOTE_RETRY_TIME,  &m_lRemoteRetryTime)        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ETRN_DAYS,                DEFAULT_ETRN_DAYS,          &m_lETRNDays)       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTING_DLL,          DEFAULT_ROUTING_DLL,            &m_strRoutingDLL)       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      DEFAULT_ROUTING_SOURCES,            &m_mszRoutingSources)       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_DOMAINS,        DEFAULT_LOCAL_DOMAINS,          &m_mszLocalDomains)     && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_DOMAIN_ROUTING,       DEFAULT_DOMAIN_ROUTING,         &m_mszDomainRouting)        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MASQUERADE_NAME,          DEFAULT_MASQUERADE_DOMAIN,  &m_strMasqueradeDomain) && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SEND_NDR_TO,          DEFAULT_SENDNDRTO,  &m_strNdrAddr)  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SEND_BAD_TO,          DEFAULT_SENDBADTO,  &m_strBadAddr)  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_SECURE_PORT,   DEFAULT_REMOTE_SECURE_PORT, &m_lRemoteSecurePort)   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SHOULD_DELIVER,       DEFAULT_SHOULD_DELIVER, &m_fShouldDeliver  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ALWAYS_USE_SSL,           DEFAULT_ALWAYS_USE_SSL,             &m_fAlwaysUseSsl  ) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LIMIT_REMOTE_CONNECTIONS, DEFAULT_LIMIT_REMOTE_CONNECTIONS,   &m_fLimitRemoteConnections  )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_OUT_CONN_PER_DOMAIN,  DEFAULT_MAX_OUT_CONN_PER_DOMAIN,    &m_lMaxOutConnPerDomain  )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SMARTHOST_TYPE,           DEFAULT_SMART_HOST_TYPE,        &m_lSmartHostType  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_BATCH_MSG_LIMIT,          DEFAULT_BATCH_MSG_LIMIT,        &m_lBatchMsgLimit  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_DO_MASQUERADE,            DEFAULT_DO_MASQUERADE,          &m_fDoMasquerade  ) && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTE_ACTION,             DEFAULT_ROUTE_ACTION,           &m_lRouteAction  )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTE_USER_NAME,          DEFAULT_ROUTE_USER_NAME,        &m_strRouteUserName  )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTE_PASSWORD,           DEFAULT_ROUTE_PASSWORD,         &m_strRoutePassword  )  && fRet;

    //
    //  IIS common propperties
    //
    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_BINDINGS,  DEFAULT_SERVER_BINDINGS,        &m_mszServerBindings )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_BINDINGS,  DEFAULT_SECURE_BINDINGS,        &m_mszSecureBindings )  && fRet;
//  fRet = StdGetMetabaseProp ( &metabase, MD_PORT,             DEFAULT_PORT,                   &m_lPort )              && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,  DEFAULT_MAX_IN_CONNECTION,      &m_lMaxInConnection )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,DEFAULT_IN_CONNECTION_TIMEOUT, &m_lInConnectionTimeout )       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_NTAUTHENTICATION_PROVIDERS, DEFAULT_AUTH_PACKAGES,    &m_strAuthPackages) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, DEFAULT_CLEARTEXT_AUTH_PACKAGE, &m_strClearTextAuthPackage) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_AUTHORIZATION, DEFAULT_AUTHENTICATION, &m_lAuthMethod) && fRet; 
    fRet = StdGetMetabaseProp ( &metabase, MD_SASL_LOGON_DOMAIN, DEFAULT_LOGON_DOMAIN,  &m_strDefaultLogonDomain) && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,    DEFAULT_LOGFILE_DIRECTORY,          &m_strLogFileDirectory)     && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       DEFAULT_LOGFILE_PERIOD,             &m_lLogFilePeriod)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,DEFAULT_LOGFILE_TRUNCATE_SIZE,      &m_lLogFileTruncateSize)        && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOG_TYPE,             DEFAULT_LOG_TYPE,                   &m_lLogType)        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_AUTOSTART,     DEFAULT_AUTOSTART,              &m_fAutoStart )             && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_COMMENT,       wszDefaultComment,              &m_strComment )         && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_STATE,         MD_SERVER_STATE_STOPPED,        &m_dwServerState )          && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_WIN32_ERROR,          NOERROR,                        &m_dwWin32ErrorCode )       && fRet;

    //  Get the admin ACL
    pSD = NULL;
    cbSD    = 0;

    hr = metabase.GetDataSize ( _T(""), MD_ADMIN_ACL, BINARY_METADATA, &cbSD );
    if( SUCCEEDED(hr) ) 
    {
        _ASSERT ( cbSD != 0 );
        pSD = (PSECURITY_DESCRIPTOR) new char [ cbSD ];
        
        if( NULL == pSD )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        
        hr = NOERROR;
        hr = metabase.GetBinary ( MD_ADMIN_ACL, pSD, cbSD );
        BAIL_ON_FAILURE(hr);
    }

    //
    //  Get the tcp access restrictions:
    //

    hr = m_pPrivateIpAccess->GetFromMetabase ( &metabase );
    BAIL_ON_FAILURE(hr);

    // Check all property strings:
    // If any string is NULL, it is because we failed to allocate memory:
    if ( !ValidateStrings () ) {

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // We can only fail from memory allocations:
    _ASSERT ( fRet );

    // Save the last changed time for this key:
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
        // Ignore this error.
        hr = NOERROR;
    }

    // Extract the bindings:
    hr = MDBindingsToIBindings ( &m_mszServerBindings, TRUE, m_pBindings );
    BAIL_ON_FAILURE(hr);

    hr = MDBindingsToIBindings ( &m_mszSecureBindings, FALSE, m_pBindings );
    BAIL_ON_FAILURE(hr);

    // Extract the Administrator list:
    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
        m_psaAdmins = NULL;
    }
    if ( pSD ) {
        hr = AclToAdministrators ( m_strServer, pSD, &m_psaAdmins );
        BAIL_ON_FAILURE(hr);
    }

    // Validate the data received from the metabase:
    _ASSERT ( ValidateStrings () );
    _ASSERT ( ValidateProperties( ) );

    if ( !ValidateProperties(  ) ) {
        CorrectProperties ();
    }

Exit:
    delete (char*) pSD;

    TraceFunctLeave ();
    return hr;

    // CMetabaseKey automatically closes its handle
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::SendPropertiesToMetabase
//
//  Description:
//
//      Saves each property to the metabase.
//      This class's properties go into /LM/SmtpSvc/
//
//  Parameters:
//
//      fFailIfChanged  - Return a failure code if the metabase
//          has changed since last get.
//      pMetabase - the metabase object.
//
//  Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdminVirtualServer::SendPropertiesToMetabase ( 
    BOOL fFailIfChanged, 
    IMSAdminBase * pMetabase
    )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::SendPropertiesToMetabase" );

    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;
    TCHAR   szInstancePath [ METADATA_MAX_NAME_LEN ];

    //
    //  Set the admin acl:
    //

    PSECURITY_DESCRIPTOR    pSD     = NULL;
    DWORD                   cbSD    = 0;

//  if ( m_bvChangedFields & CHNG_ADMINACL ) {
        if ( m_psaAdmins ) {
            hr = AdministratorsToAcl ( m_strServer, m_psaAdmins, &pSD, &cbSD );
            BAIL_ON_FAILURE(hr);
        }
//  }


    // Open metabase key
    GetMDInstancePath ( szInstancePath, m_dwServiceInstance );
    hr = metabase.Open ( szInstancePath, METADATA_PERMISSION_WRITE );
    if ( FAILED(hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to open instance key, %x", GetLastError() );

        // !!!magnush - Should we return a simple Service doesn't exist error code?
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
        goto Exit;
    }

    // Does the client care if the key has changed?
    if ( fFailIfChanged ) {

        //  Did the key change?
        if ( HasKeyChanged ( pMetabase, metabase.QueryHandle(), &m_ftLastChanged ) ) {

            StateTrace ( (LPARAM) this, "Metabase has changed, not setting properties" );
            // !!!magnush - Return the appropriate error code:
            hr = E_FAIL;
            goto Exit;
        }
    }

    // Extract the bindings:
    if( !(m_bvChangedFields & BitMask(ID_SERVER_BINDINGS)) )
    {
        hr = IBindingsToMDBindings ( m_pBindings, TRUE, &m_mszServerBindings );
        BAIL_ON_FAILURE(hr);
        m_bvChangedFields |= BitMask(ID_SERVER_BINDINGS);
    }

    if( !(m_bvChangedFields & BitMask(ID_SECURE_BINDINGS)) )
    {
        hr = IBindingsToMDBindings ( m_pBindings, FALSE, &m_mszSecureBindings );
        BAIL_ON_FAILURE(hr);
        m_bvChangedFields |= BitMask(ID_SECURE_BINDINGS);
    }

    //
    //  The general procedure here is to keep setting metabase properties
    //  as long as nothing has gone wrong.  This is done by short-circuiting
    //  the statement by ANDing it with the status code.  This makes the code
    //  much more concise.
    //

    fRet = TRUE;

    // Overridable server properties:
    hr = m_RoutingSource.Set(&metabase);
    BAIL_ON_FAILURE(hr);
#if 0
    if ( m_bvChangedFields & BitMask(ID_SSLPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_PORT,          m_lSSLPort )        && fRet;
    }
#endif
    if ( m_bvChangedFields & BitMask(ID_OUTBOUNDPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT,     m_lOutboundPort )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_HOP_COUNT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_HOP_COUNT,    m_lHopCount )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SMARTHOST) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   m_strSmartHost )        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ENABLEDNSLOOKUP) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,m_fEnableDNSLookup )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTEREMAIL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, m_strPostmasterEmail )  && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTERNAME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  m_strPostmasterName )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_FQDN) ) 
    {
        if( m_strFQDN.m_str && m_strFQDN.m_str[0] )
        {
            fRet = StdPutMetabaseProp ( &metabase, MD_FQDN_VALUE,   m_strFQDN )         && fRet;
        }
        else
        {
            if( !metabase.DeleteData( _T(""), MD_FQDN_VALUE, STRING_METADATA ) )
            {
                // not an error if data not exists on the instance level
                fRet = fRet && ( GetLastError() == MD_ERROR_DATA_NOT_FOUND );
            }
        }
    }

    if ( m_bvChangedFields & BitMask(ID_DEFAULTDOMAIN) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, m_strDefaultDomain )            && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DROPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_DROP_DIR,    m_strDropDir )          && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BADMAILDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     m_strBadMailDir )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_PICKUPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  m_strPickupDir )        && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_QUEUEDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   m_strQueueDir )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXOUTCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  m_lMaxOutConnection )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_OUTCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,   m_lOutConnectionTimeout )   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,     m_lMaxMessageSize )     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_MAXSESSIONSIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    m_lMaxSessionSize )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGERECIPIENTS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,       m_lMaxMessageRecipients )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALRETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      m_lLocalRetryTime)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_REMOTERETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     m_lRemoteRetryTime)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ETRNDAYS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ETRN_DAYS,                m_lETRNDays)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ROUTINGDLL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_DLL,          m_strRoutingDLL)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ROUTINGSOURCES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      &m_mszRoutingSources)   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALDOMAINS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_DOMAINS,        &m_mszLocalDomains)     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DOMAINROUTING) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DOMAIN_ROUTING,       &m_mszDomainRouting)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALRETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     m_lLocalRetries)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_REMOTERETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_ATTEMPTS,    m_lRemoteRetries)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MASQUERADE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MASQUERADE_NAME,  m_strMasqueradeDomain)      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDNDRTO) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_NDR_TO,  m_strNdrAddr)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDBADTO) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_BAD_TO,  m_strBadAddr)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_REMOTE_SECURE_PORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SECURE_PORT,   m_lRemoteSecurePort)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SHOULD_DELIVER) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SHOULD_DELIVER,   m_fShouldDeliver)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ALWAYS_USE_SSL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ALWAYS_USE_SSL,   m_fAlwaysUseSsl)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LIMIT_REMOTE_CONNECTIONS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LIMIT_REMOTE_CONNECTIONS, m_fLimitRemoteConnections)      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAX_OUT_CONN_PER_DOMAIN) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUT_CONN_PER_DOMAIN,  m_lMaxOutConnPerDomain)     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SMART_HOST_TYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_TYPE,   m_lSmartHostType)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BATCH_MSG_LIMIT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BATCH_MSG_LIMIT,  m_lBatchMsgLimit)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DO_MASQUERADE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DO_MASQUERADE,    m_fDoMasquerade)        && fRet;
    }

    // outbound security
    if ( m_bvChangedFields & BitMask(ID_ROUTE_ACTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTE_ACTION, m_lRouteAction)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ROUTE_USER_NAME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTE_USER_NAME,  m_strRouteUserName)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ROUTE_PASSWORD) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTE_PASSWORD,   m_strRoutePassword)     && fRet;
    }

    //
    //  IIS common properties
    //
    if ( m_bvChangedFields & BitMask(ID_SERVER_BINDINGS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SERVER_BINDINGS,      &m_mszServerBindings )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SECURE_BINDINGS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_BINDINGS,      &m_mszSecureBindings )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXINCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,  m_lMaxInConnection )    && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_INCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,m_lInConnectionTimeout )       && fRet;
    }

    if (m_bvChangedFields & BitMask(ID_AUTH_PACKAGES)) 
    {
        fRet = fRet && StdPutMetabaseProp(&metabase, MD_NTAUTHENTICATION_PROVIDERS, m_strAuthPackages);
    }

    if (m_bvChangedFields & BitMask(ID_CLEARTEXT_AUTH_PACKAGE)) 
    {
        fRet = fRet && StdPutMetabaseProp(&metabase, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, m_strClearTextAuthPackage);
    }

    if (m_bvChangedFields & BitMask(ID_AUTH_METHOD)) 
    {
        fRet = fRet && StdPutMetabaseProp(&metabase, MD_AUTHORIZATION, m_lAuthMethod);
    }

    if (m_bvChangedFields & BitMask(ID_DEFAULT_LOGON_DOMAIN)) 
    {
        fRet = fRet && StdPutMetabaseProp(&metabase, MD_SASL_LOGON_DOMAIN, m_strDefaultLogonDomain);
    }

    if ( m_bvChangedFields & BitMask(ID_LOGFILEDIRECTORY) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,        m_strLogFileDirectory)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILEPERIOD) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       m_lLogFilePeriod)       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILETRUNCATESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,    m_lLogFileTruncateSize)     && fRet;
    }
//  if ( m_bvChangedFields & BitMask(ID_LOGMETHOD) ) 
//  {
//      fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogMethod)       && fRet;
//  }
    if ( m_bvChangedFields & BitMask(ID_LOGTYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogType)     && fRet;
    }


    if ( m_bvChangedFields & BitMask(ID_AUTOSTART) ) {
        fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_AUTOSTART,     m_fAutoStart );
    }

    if ( m_bvChangedFields & BitMask(ID_COMMENT) ) {
        fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_COMMENT,       m_strComment );
    }

#if 0
//  if ( m_bvChangedFields & CHNG_ADMINACL ) {
        if ( pSD ) {
            hr = metabase.SetData ( _T(""), MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA, pSD, cbSD, METADATA_INHERIT | METADATA_REFERENCE);
            BAIL_ON_FAILURE(hr);
        }
        else {
            pMetabase->DeleteData ( metabase.QueryHandle(), _T(""), MD_ADMIN_ACL, BINARY_METADATA );
        }
//  }
#endif

//  if ( m_bvChangedFields & CHNG_IPACCESS ) {
        hr = m_pPrivateIpAccess->SendToMetabase ( &metabase );
        BAIL_ON_FAILURE(hr);
//  }

    // Save the data to the metabase:
    // hr = metabase.Close();
    // BAIL_ON_FAILURE(hr);
    metabase.Close();

    hr = pMetabase->SaveData ();
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed SaveData call (%x)", hr );
    }

    // Save the last changed time for this key:
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
        // Ignore this error.
        hr = NOERROR;
    }

Exit:
    delete (char*) pSD;

    if( SUCCEEDED(hr) && !fRet )
    {
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
    }

    TraceFunctLeave ();
    return hr;

    // CMetabaseKey automatically closes its handle
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::ValidateStrings
//
//  Description:
//
//      Checks to make sure each string property is non-null.
//
//  Returns:
//
//      FALSE if any string property is NULL.
//
//--------------------------------------------------------------------

BOOL CSmtpAdminVirtualServer::ValidateStrings ( ) const
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::ValidateStrings" );

    // Check all property strings:
    // If any string is NULL, return FALSE:

    if ( 
        !m_strSmartHost ||
        !m_strPostmasterEmail ||
        !m_strPostmasterName ||
        !m_strDefaultDomain ||
        !m_strBadMailDir ||
        !m_strPickupDir ||
        !m_strQueueDir ||
        !m_strRoutingDLL ||
        !m_strLogFileDirectory
        ) {

        ErrorTrace ( (LPARAM) this, "String validation failed" );

        TraceFunctLeave ();
        return FALSE;
    }

    _ASSERT ( IS_VALID_STRING ( m_strSmartHost ) );
    _ASSERT ( IS_VALID_STRING ( m_strPostmasterEmail ) );
    _ASSERT ( IS_VALID_STRING ( m_strPostmasterName ) );

    _ASSERT ( IS_VALID_STRING ( m_strDefaultDomain ) );

    _ASSERT ( IS_VALID_STRING ( m_strBadMailDir ) );
    _ASSERT ( IS_VALID_STRING ( m_strPickupDir ) );
    _ASSERT ( IS_VALID_STRING ( m_strQueueDir ) );

    _ASSERT ( IS_VALID_STRING ( m_strRoutingDLL ) );

    _ASSERT ( IS_VALID_STRING ( m_strLogFileDirectory ) );

    TraceFunctLeave ();
    return TRUE;
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::ValidateProperties
//
//  Description:
//
//      Checks to make sure all parameters are valid.
//
//  Parameters:
//
//
//  Returns:
//
//
//--------------------------------------------------------------------

BOOL CSmtpAdminVirtualServer::ValidateProperties ( ) const
{
    BOOL    fRet    = TRUE;
    
    _ASSERT ( ValidateStrings () );

/*
    fRet = fRet && PV_MinMax    ( m_lPort, MIN_PORT, MAX_PORT );
    fRet = fRet && PV_MinMax    ( m_lSSLPort, MIN_SSLPORT, MAX_SSLPORT );
    fRet = fRet && PV_MinMax    ( m_lOutboundPort, MIN_OUTBOND_PORT, MAX_OUTBOND_PORT );

    fRet = fRet && PV_MinMax    ( m_lMaxInConnection, MIN_MAX_IN_CONNECTION, MAX_MAX_IN_CONNECTION );
    fRet = fRet && PV_MinMax    ( m_lMaxOutConnection, MIN_MAX_OUT_CONNECTION, MAX_MAX_OUT_CONNECTION );
    fRet = fRet && PV_MinMax    ( m_lInConnectionTimeout, MIN_IN_CONNECTION_TIMEOUT, MAX_IN_CONNECTION_TIMEOUT );
    fRet = fRet && PV_MinMax    ( m_lOutConnectionTimeout, MIN_OUT_CONNECTION_TIMEOUT, MAX_OUT_CONNECTION_TIMEOUT );

    fRet = fRet && PV_MinMax    ( m_lMaxMessageSize, MIN_MAX_MESSAGE_SIZE, MAX_MAX_MESSAGE_SIZE );
    fRet = fRet && PV_MinMax    ( m_lMaxSessionSize, MIN_MAX_SESSION_SIZE, MAX_MAX_SESSION_SIZE );
    fRet = fRet && PV_MinMax    ( m_lMaxMessageRecipients, MIN_MAX_MESSAGE_RECIPIENTS, MAX_MAX_MESSAGE_RECIPIENTS );

    fRet = fRet && PV_MinMax    ( m_lLocalRetries, MIN_LOCAL_RETRIES, MAX_LOCAL_RETRIES );
    fRet = fRet && PV_MinMax    ( m_lLocalRetryTime, MIN_LOCAL_RETRY_TIME, MAX_LOCAL_RETRY_TIME );
    fRet = fRet && PV_MinMax    ( m_lRemoteRetries, MIN_REMOTE_RETRIES, MAX_REMOTE_RETRIES );
    fRet = fRet && PV_MinMax    ( m_lRemoteRetryTime, MIN_REMOTE_RETRY_TIME, MAX_REMOTE_RETRY_TIME );
    fRet = fRet && PV_MinMax    ( m_lETRNDays, MIN_ETRN_DAYS, MAX_ETRN_DAYS );

//  fRet = fRet && PV_MinMax    ( m_lRTType, MIN_RTTYPE, MAX_RTTYPE );

    fRet = fRet && PV_MinMax    ( m_lLogFilePeriod, MIN_LOGFILE_PERIOD, MAX_LOGFILE_PERIOD );
    fRet = fRet && PV_MinMax    ( m_lLogFileTruncateSize, MIN_LOGFILE_TRUNCATE_SIZE, MAX_LOGFILE_TRUNCATE_SIZE );
    fRet = fRet && PV_MinMax    ( m_lLogMethod, MIN_LOG_METHOD, MAX_LOG_METHOD );
    fRet = fRet && PV_MinMax    ( m_lLogType, MIN_LOG_TYPE, MAX_LOG_TYPE );

    fRet = fRet && PV_Boolean   ( m_fEnableDNSLookup );
    fRet = fRet && PV_Boolean   ( m_fSendDNRToPostmaster );
    fRet = fRet && PV_Boolean   ( m_fSendBadmailToPostmaster );
    fRet = fRet && PV_Boolean   ( m_fAutoStart );
*/
    return fRet;
}

void CSmtpAdminVirtualServer::CorrectProperties ( )
{
    /*
    if ( m_strServer && !PV_MaxChars    ( m_strServer, MAXLEN_SERVER ) ) {
        m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
    }
    if ( !PV_MinMax ( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT ) ) {
        m_dwArticleTimeLimit    = DEFAULT_ARTICLETIMELIMIT;
    }
    if ( !PV_MinMax ( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION ) ) {
        m_dwHistoryExpiration   = DEFAULT_HISTORYEXPIRATION;
    }
    if ( !PV_Boolean    ( m_fHonorClientMsgIDs ) ) {
        m_fHonorClientMsgIDs    = !!m_fHonorClientMsgIDs;
    }
    if ( !PV_MaxChars   ( m_strSmtpServer, MAXLEN_SMTPSERVER ) ) {
        m_strSmtpServer[ MAXLEN_SMTPSERVER - 1 ] = NULL;
    }
    if ( !PV_Boolean    ( m_fAllowClientPosts ) ) {
        m_fAllowClientPosts = !!m_fAllowClientPosts;
    }
    if ( !PV_Boolean    ( m_fAllowFeedPosts ) ) {
        m_fAllowFeedPosts   = !!m_fAllowFeedPosts;
    }
    if ( !PV_Boolean    ( m_fAllowControlMsgs ) ) {
        m_fAllowControlMsgs = !!m_fAllowControlMsgs;
    }
    if ( !PV_MaxChars   ( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN ) ) {
        m_strDefaultModeratorDomain[ MAXLEN_DEFAULTMODERATORDOMAIN - 1] = NULL;
    }
    if ( !PV_MinMax ( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK ) ) {
        m_dwCommandLogMask  = DEFAULT_COMMANDLOGMASK;
    }
    if ( !PV_Boolean    ( m_fDisableNewnews ) ) {
        m_fDisableNewnews   = !!m_fDisableNewnews;
    }
    if ( !PV_MinMax ( m_dwExpireRunFrequency, MIN_EXPIRERUNFREQUENCY, MAX_EXPIRERUNFREQUENCY ) ) {
        m_dwExpireRunFrequency  = DEFAULT_EXPIRERUNFREQUENCY;
    }
    if ( !PV_MinMax ( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY ) ) {
        m_dwShutdownLatency     = DEFAULT_SHUTDOWNLATENCY;
    }
*/

    _ASSERT ( ValidateProperties (  ) );
}


HRESULT AclToAdministrators ( LPCTSTR strServer, PSECURITY_DESCRIPTOR pSDRelative, SAFEARRAY ** ppsaAdmins )
{
    HRESULT         hr          = NOERROR;
    SAFEARRAY *     psaResult   = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    DWORD           cbAcl;
    long            cAdmins;
    long            i;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pAcl;
    BOOL fDaclPresent;
    BOOL fDaclDef;

    pSD = (PSECURITY_DESCRIPTOR)pSDRelative;
    if (pSD == NULL)
    {
        //
        // Empty...
        //
        return ERROR_SUCCESS;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        return GetLastError();
    }

    _VERIFY(GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pAcl, &fDaclDef));
    if (!fDaclPresent || pAcl == NULL)
    {
        return ERROR_SUCCESS;
    }

    if (!IsValidAcl(pAcl))
    {
        return GetLastError();
    }

    cAdmins = pAcl->AceCount;
    cbAcl   = pAcl->AclSize;

    rgsaBound[0].lLbound    = 0;
    rgsaBound[0].cElements  = cAdmins;
    psaResult = SafeArrayCreate ( VT_BSTR, 1, rgsaBound );

    if ( !psaResult ) {
        BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

    for ( i = 0; i < cAdmins; i++ ) {
        PVOID           pAce;
        PACE_HEADER     pAceHeader;
        PSID            pSID;

        if ( GetAce(pAcl, i, &pAce) ) {
            pAceHeader = (PACE_HEADER)pAce;

            if ( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ) {
                CComBSTR    str;

                pSID = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;

                hr = SidToString ( pSID, &str );
                BAIL_ON_FAILURE(hr);

                hr = SafeArrayPutElement ( psaResult, &i, (PVOID) str );
                BAIL_ON_FAILURE(hr);
            }
        }
    }

    if ( *ppsaAdmins ) {
        SafeArrayDestroy ( *ppsaAdmins );
    }
    *ppsaAdmins = psaResult;

Exit:
    return hr;
}


PSID
GetOwnerSID()
/*++

Routine Description:

Arguments:

Return Value:

    Owner sid

--*/
{
    PSID pSID = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pSID))
    {
        _ASSERT( 0 );
        //TRACEEOLID("Unable to get primary SID " << ::GetLastError());
    }

    return pSID;
}


HRESULT AdministratorsToAcl ( 
    LPCTSTR     strServer,
    SAFEARRAY * psaAdmins, 
    PSECURITY_DESCRIPTOR* ppSD, 
    DWORD * pcbSD 
    )
{
    HRESULT     hr  = NOERROR;
    long        lBound;
    long        uBound;
    long        i;
    BOOL        fRet;
    DWORD       cbAcl;
    PACL        pAclResult  = NULL;
    PSID        pSID;

    *ppSD   = NULL;
    *pcbSD  = 0;

    if ( psaAdmins == NULL ) {
        lBound = 0;
        uBound = -1;
    }
    else {
        SafeArrayGetLBound ( psaAdmins, 1, &lBound );
        SafeArrayGetUBound ( psaAdmins, 1, &uBound );
    }

    // Do we have an array of Domain\Usernames?
    if ( lBound > uBound ) {
        // Nothing in the array, so the ACL is NULL.
        goto Exit;
    }

    //
    // Calculate ACL size:
    //
    cbAcl = sizeof (ACL);

    for ( i = lBound; i <= uBound ; i++ ) {
        CComBSTR    str;

        pSID = NULL;

        SafeArrayGetElement ( psaAdmins, &i, &str );

        hr = StringToSid ( strServer, str, &pSID );

        if ( SUCCEEDED(hr) && pSID) {
            cbAcl += GetLengthSid ( pSID );
            cbAcl += sizeof ( ACCESS_ALLOWED_ACE );
            cbAcl -= sizeof (DWORD);
            delete pSID;
        }
        hr = NOERROR;

    }

    pAclResult = (PACL) new char [ cbAcl ];
    if ( !pAclResult ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    fRet = InitializeAcl ( pAclResult, cbAcl, ACL_REVISION );
    _ASSERT ( fRet );
    if ( !fRet ) {
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError() ) );
    }

    //
    //  Create ACL:
    //
    for ( i = lBound; i <= uBound; i++ ) {
        CComBSTR    str;
        PSID        pSID;

        pSID = NULL;

        SafeArrayGetElement ( psaAdmins, &i, &str );

        hr = StringToSid ( strServer, str, &pSID );
        if ( SUCCEEDED(hr) ) {
            fRet = AddAccessAllowedAce ( 
                pAclResult, 
                ACL_REVISION, 
                FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
                pSID
                );

            delete pSID;
            if ( !fRet ) {
                BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError() ) );
            }
        }
        hr = NOERROR;

    }

    //
    // Build the security descriptor
    //
    PSECURITY_DESCRIPTOR pSD;
    pSD = new char[SECURITY_DESCRIPTOR_MIN_LENGTH];
    
    if( NULL == pSD )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
        
    _VERIFY(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
    _VERIFY(SetSecurityDescriptorDacl(pSD, TRUE, pAclResult, FALSE));

    //
    // Set owner and primary group
    //
    pSID = GetOwnerSID();
    _ASSERT(pSID);
    _VERIFY(SetSecurityDescriptorOwner(pSD, pSID, TRUE));
    _VERIFY(SetSecurityDescriptorGroup(pSD, pSID, TRUE));

    //
    // Convert to self-relative
    //
    PSECURITY_DESCRIPTOR pSDSelfRelative;
    pSDSelfRelative = NULL;
    DWORD dwSize;
    dwSize = 0L;
    MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);
    pSDSelfRelative = new char[dwSize];
    
    if( NULL == pSDSelfRelative )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);

    //
    // Clean up
    //
    delete (char*)pSD;
    FreeSid( pSID );


    _ASSERT ( SUCCEEDED(hr) );
    *ppSD   = pSDSelfRelative;
    *pcbSD  = dwSize;

Exit:
    if ( FAILED(hr) ) {
        delete pAclResult;
    }
    return hr;
}

HRESULT SidToString ( PSID pSID, BSTR * pStr )
{
    HRESULT         hr              = NOERROR;
    BOOL            fLookup;
    SID_NAME_USE    SidToNameUse;
    WCHAR           wszUsername [ PATHLEN ];
    DWORD           cbUsername      = sizeof ( wszUsername );
    WCHAR           wszDomain [ PATHLEN ];
    DWORD           cbDomain        = sizeof ( wszDomain );
    WCHAR           wszResult [ 2 * PATHLEN + 2 ];

    fLookup = LookupAccountSid ( 
//      wszSearchDomain,
        NULL,
        pSID,
        wszUsername,
        &cbUsername,
        wszDomain,
        &cbDomain,
        &SidToNameUse
        );
        
    if ( !fLookup ) {
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT (GetLastError ()) );
    }

    wsprintf ( wszResult, _T("%s\\%s"), wszDomain, wszUsername );

    *pStr = ::SysAllocString ( wszResult );

Exit:
    if ( *pStr ) {
        return NOERROR;
    }
    else {
        return E_OUTOFMEMORY;
    }
}

//-------------------------------------------------------------------------
//  Description:
//      Returns the SID for a an account (given as a COMPUTER/USER)
//  Parameters:
//      strSystemName - Name of "computer" on which account is
//      str - Name of user account to look up
//      ppSID - Out parameter; This function allocates a SID for the
//          accountand returns a pointer to it .
//  Returns:
//      S_OK on success. Caller frees *ppSID using delete.
//      Error HRESULT otherwise. *ppSID will be NULL.
//-------------------------------------------------------------------------
HRESULT StringToSid ( LPCWSTR strSystemName, LPWSTR str, PSID * ppSID )
{
    HRESULT         hr  = NOERROR;
    BOOL            fLookup;
    WCHAR           wszRefDomain[PATHLEN];
    DWORD           cbRefDomain = sizeof ( wszRefDomain );
    DWORD           cbSid = 0;
    SID_NAME_USE    SidNameUse;

    *ppSID = NULL;

    if ( str[0] == '\\' ) {
        //
        //  Skip the initial \, this is for BUILTIN usernames:
        //

        str++;
    }

    _ASSERT ( str[0] != '\\' );

    fLookup = LookupAccountName (
        strSystemName,
        str,
        *ppSID,
        &cbSid,
        wszRefDomain,
        &cbRefDomain,
        &SidNameUse
        );

    // First lookup will fail, but the size will be right:
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        DWORD   dw;

        dw = GetLastError ();
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT ( GetLastError () ) );
    }

    *ppSID = (LPVOID) new char [ cbSid ];
    if ( !*ppSID ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    fLookup = LookupAccountName (
        strSystemName,
        str,
        *ppSID,
        &cbSid,
        wszRefDomain,
        &cbRefDomain,
        &SidNameUse
        );

    if ( !fLookup ) {
        DWORD   dw;

        dw = GetLastError ();
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT ( GetLastError () ) );
    }

Exit:
    if(FAILED(hr) && *ppSID != NULL) {
        delete (*ppSID);
        *ppSID = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\user.cpp ===
// user.cpp : Implementation of CSmtpadmApp and UserL registration.

#include "stdafx.h"
#include "smtpadm.h"
#include "user.h"
#include "oleutil.h"

#include <lmapibuf.h>

#include "smtpcmn.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.User.1")
#define THIS_FILE_IID               IID_ISmtpAdminUser

#define DEFAULT_NEWSGROUP_NAME          _T("")
#define DEFAULT_NEWSGROUP_DESCRIPTION   _T("")
#define DEFAULT_NEWSGROUP_MODERATOR     _T("")
#define DEFAULT_NEWSGROUP_READONLY      FALSE

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminUser, CSmtpAdminUser, IID_ISmtpAdminUser)

STDMETHODIMP CSmtpAdminUser::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_ISmtpAdminUser,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

CSmtpAdminUser::CSmtpAdminUser ()
    // CComBSTR's are initialized to NULL by default.
{
    m_lInboxSizeInMemory    = 0;
    m_lInboxSizeInMsgNumber = 0;
    m_fAutoForward          = FALSE;
    m_fLocal                = TRUE;


    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("User") );
    m_iadsImpl.SetClass ( _T("IIsSmtpUser") );
}

CSmtpAdminUser::~CSmtpAdminUser ()
{
    // All CComBSTR's are freed automatically.
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminUser,m_iadsImpl)

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// user property

STDMETHODIMP CSmtpAdminUser::get_EmailId ( BSTR * pstrEmailId )
{
    return StdPropertyGet ( m_strEmailId, pstrEmailId );
}

STDMETHODIMP CSmtpAdminUser::put_EmailId ( BSTR strEmailId )
{
    return StdPropertyPut ( &m_strEmailId, strEmailId );
}

STDMETHODIMP CSmtpAdminUser::get_Domain ( BSTR * pstrDomain )
{
    return StdPropertyGet ( m_strDomain, pstrDomain );
}

STDMETHODIMP CSmtpAdminUser::put_Domain ( BSTR strDomain )
{
    return StdPropertyPut ( &m_strDomain, strDomain );
}


STDMETHODIMP CSmtpAdminUser::get_MailRoot ( BSTR * pstrMailRoot )
{
    return StdPropertyGet ( m_strMailRoot, pstrMailRoot );
}
STDMETHODIMP CSmtpAdminUser::put_MailRoot ( BSTR strMailRoot )
{
    return StdPropertyPut ( &m_strMailRoot, strMailRoot );
}


STDMETHODIMP CSmtpAdminUser::get_InboxSizeInMemory ( long * plInboxSizeInMemory )
{
    return StdPropertyGet ( m_lInboxSizeInMemory, plInboxSizeInMemory );
}
STDMETHODIMP CSmtpAdminUser::put_InboxSizeInMemory ( long   lInboxSizeInMemory )
{
    return StdPropertyPut ( &m_lInboxSizeInMemory, lInboxSizeInMemory );
}


STDMETHODIMP CSmtpAdminUser::get_InboxSizeInMsgNumber ( long * plInboxSizeInMsgNumber )
{
    return StdPropertyGet ( m_lInboxSizeInMsgNumber, plInboxSizeInMsgNumber );
}
STDMETHODIMP CSmtpAdminUser::put_InboxSizeInMsgNumber ( long   lInboxSizeInMsgNumber )
{
    return StdPropertyPut ( &m_lInboxSizeInMsgNumber, lInboxSizeInMsgNumber );
}


STDMETHODIMP CSmtpAdminUser::get_AutoForward ( BOOL * pfAutoForward )
{
    return StdPropertyGet ( m_fAutoForward, pfAutoForward );
}

STDMETHODIMP CSmtpAdminUser::put_AutoForward ( BOOL fAutoForward )
{
    return StdPropertyPut ( &m_fAutoForward, fAutoForward );
}


STDMETHODIMP CSmtpAdminUser::get_ForwardEmail ( BSTR * pstrForwardEmail )
{
    return StdPropertyGet ( m_strForwardEmail, pstrForwardEmail );
}

STDMETHODIMP CSmtpAdminUser::put_ForwardEmail ( BSTR strForwardEmail )
{
    return StdPropertyPut ( &m_strForwardEmail, strForwardEmail );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////


STDMETHODIMP CSmtpAdminUser::Default ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Default" );

/*
    m_strNewsgroup      = DEFAULT_NEWSGROUP_NAME;
    m_strDescription    = DEFAULT_NEWSGROUP_DESCRIPTION;
    m_strModerator      = DEFAULT_NEWSGROUP_MODERATOR;
    m_fReadOnly         = DEFAULT_NEWSGROUP_READONLY;

    if (
        !m_strNewsgroup ||
        !m_strDescription ||
        !m_strModerator
        ) {

        FatalTrace ( (LPARAM) this, "Out of memory" );
        return E_OUTOFMEMORY;
    }
*/
    TraceFunctLeave ();
    return NOERROR;
}

STDMETHODIMP CSmtpAdminUser::Create ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Create" );

    HRESULT         hr      = NOERROR;
    DWORD           dwErr   = NOERROR;

    if( !m_strEmailId || !m_strDomain )
    {
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    WCHAR           szUserName[512];
    WCHAR*          lpForward;
    wsprintfW( szUserName, L"%s@%s", (LPWSTR) m_strEmailId, (LPWSTR) m_strDomain );

    if( m_strForwardEmail && m_strForwardEmail[0] )
    {
        lpForward = m_strForwardEmail;
    }
    else
    {
        lpForward = NULL;
    }

    dwErr = SmtpCreateUser(
                m_iadsImpl.QueryComputer(),
                szUserName,
                lpForward,
                m_fLocal,
                m_lInboxSizeInMemory,
                m_lInboxSizeInMsgNumber,
                m_strMailRoot,
                m_iadsImpl.QueryInstance() );

    if ( dwErr != NOERROR ) {
        ErrorTrace ( (LPARAM) this, "Failed to add user: %x", dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminUser::Delete ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Delete" );

    HRESULT         hr      = NOERROR;
    DWORD           dwErr   = NOERROR;

    if( !m_strEmailId || !m_strDomain )
    {
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    WCHAR           szUserName[512];
    wsprintfW( szUserName, L"%s@%s", (LPWSTR) m_strEmailId, (LPWSTR) m_strDomain );

    dwErr = SmtpDeleteUser(
                m_iadsImpl.QueryComputer(),
                szUserName,
                m_iadsImpl.QueryInstance() );

    if ( dwErr != NOERROR ) {
        ErrorTrace ( (LPARAM) this, "Failed to delete user: %x", dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminUser::Get ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Get" );

    HRESULT             hr      = NOERROR;
    DWORD               dwErr   = NOERROR;
    LPSMTP_USER_PROPS   pUserProps = NULL;

    if( !m_strEmailId || !m_strDomain )
    {
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    WCHAR           szUserName[512];
    wsprintfW( szUserName, L"%s@%s", (LPWSTR) m_strEmailId, (LPWSTR) m_strDomain );


    dwErr = SmtpGetUserProps(
                m_iadsImpl.QueryComputer(),
                szUserName,
                &pUserProps,
                m_iadsImpl.QueryInstance() );

    if ( dwErr != NOERROR ) {
        ErrorTrace ( (LPARAM) this, "Failed to get user prop: %x", dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

    // free old entry
    m_strMailRoot.Empty();
    m_strForwardEmail.Empty();

    m_strMailRoot = pUserProps->wszVRoot;

    m_strForwardEmail = pUserProps->wszForward;
    m_fAutoForward = (!m_strForwardEmail || !m_strForwardEmail.Length()) ? FALSE : TRUE;

    m_lInboxSizeInMemory = pUserProps->dwMailboxMax;
    m_lInboxSizeInMsgNumber = pUserProps->dwMailboxMessageMax;
    m_fLocal = !!pUserProps->dwLocal;

    // free pUserProps
    if ( pUserProps )
    {
        ::NetApiBufferFree ( pUserProps );
    }

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminUser::Set ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Set" );

    HRESULT             hr      = NOERROR;
    DWORD               dwErr   = NOERROR;
    SMTP_USER_PROPS     UserProps;

    if( !m_strEmailId || !m_strDomain )
    {
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    WCHAR               szUserName[512];
    wsprintfW( szUserName, L"%s@%s", (LPWSTR) m_strEmailId, (LPWSTR) m_strDomain );

    UserProps.fc            = FC_SMTP_USER_PROPS_ALL;

    if( !m_strForwardEmail || !m_strForwardEmail.Length() )
    {
        UserProps.wszForward    = NULL;
        UserProps.fc            -= FC_SMTP_USER_PROPS_FORWARD;
    }
    else
    {
        UserProps.wszForward    = (LPWSTR)m_strForwardEmail;
    }

    UserProps.wszVRoot      = (LPWSTR)m_strMailRoot;

    UserProps.dwMailboxMax          = m_lInboxSizeInMemory;
    UserProps.dwMailboxMessageMax   = m_lInboxSizeInMsgNumber;
    UserProps.dwLocal               = m_fLocal;


    dwErr = SmtpSetUserProps(
                m_iadsImpl.QueryComputer(),
                szUserName,
                &UserProps,
                m_iadsImpl.QueryInstance() );

    if ( dwErr != NOERROR ) {
        ErrorTrace ( (LPARAM) this, "Failed to set user prop: %x", dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

Exit:
    TraceFunctLeave ();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\vdir.cpp ===
// vdir.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include <listmacr.h>

#include "IADM.h"
#include "imd.h"
#include "inetcom.h"

#include "smtpadm.h"
#include "vdir.h"
#include "oleutil.h"
#include "metafact.h"
#include "metautil.h"

#include "smtpcmn.h"
#include "smtpprop.h"


// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.VirtualDirectory.1")
#define THIS_FILE_IID				IID_ISmtpAdminVirtualDirectory


typedef struct _VDIR_ENTRY {
	TCHAR            szName[METADATA_MAX_NAME_LEN+2];
	TCHAR            szDirectory[MAX_PATH + UNLEN + 3];

	TCHAR            szUser[UNLEN+1];
	TCHAR            szPassword[PWLEN+1];

	DWORD			dwAccess;
	DWORD			dwSslAccess;
	BOOL			fLogAccess;

	LIST_ENTRY		list;
} VDIR_ENTRY, * PVDIR_ENTRY;


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CSmtpAdminVirtualDirectory::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdminVirtualDirectory,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CSmtpAdminVirtualDirectory::CSmtpAdminVirtualDirectory () :
	m_dwServiceInstance		( 0 ),
	m_lCount				( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	m_dwAccess      = MD_ACCESS_READ | MD_ACCESS_WRITE;
    m_dwSslAccess   = 0;

	InitializeListHead( &m_list );
}

CSmtpAdminVirtualDirectory::~CSmtpAdminVirtualDirectory ()
{
	Clear();

	// All CComBSTR's are freed automatically.
}

void CSmtpAdminVirtualDirectory::Clear()
{
	m_lCount = 0;
	m_fEnumerateCalled = FALSE;
	m_strName.Empty();
	m_strDirectory.Empty();
	m_strUser.Empty();
	m_strPassword.Empty();
	m_dwAccess      = MD_ACCESS_READ | MD_ACCESS_WRITE;
    m_dwSslAccess   = 0;

	// release memory
	PLIST_ENTRY		pHead;
	PLIST_ENTRY		pEntry;
	PLIST_ENTRY		pTemp;
	PVDIR_ENTRY		pCurVDir=NULL;

	for( pHead=&m_list, pEntry=pHead->Flink; pEntry!=pHead; )
	{
		pTemp = pEntry;
		pEntry= pEntry->Flink;

		pCurVDir = CONTAINING_RECORD(pTemp, VDIR_ENTRY, list);
		RemoveEntryList( pTemp );
		delete pCurVDir;
	}

	_ASSERT( IsListEmpty(&m_list) );
}


//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Which service to configure:
	
STDMETHODIMP CSmtpAdminVirtualDirectory::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_Server ( BSTR strServer )
{
	return StdPropertyPutServerName ( &m_strServer, strServer );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_ServiceInstance ( long lServiceInstance )
{
	return StdPropertyPut ( (long *) &m_dwServiceInstance, lServiceInstance );
}


// enumeration
STDMETHODIMP CSmtpAdminVirtualDirectory::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_lCount, plCount );
}


// VirtualDirectory property

STDMETHODIMP CSmtpAdminVirtualDirectory::get_VirtualName ( BSTR * pstrName )
{
	return StdPropertyGet ( m_strName, pstrName );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_VirtualName ( BSTR strName )
{
	return StdPropertyPut ( &m_strName, strName );
}


STDMETHODIMP CSmtpAdminVirtualDirectory::get_Directory ( BSTR * pstrPath )
{
	return StdPropertyGet ( m_strDirectory, pstrPath );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_Directory ( BSTR strPath )
{
	return StdPropertyPut ( &m_strDirectory, strPath );
}


STDMETHODIMP CSmtpAdminVirtualDirectory::get_User ( BSTR * pstrUserName )
{
	return StdPropertyGet ( m_strUser, pstrUserName );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_User ( BSTR strUserName )
{
	return StdPropertyPut ( &m_strUser, strUserName );
}


STDMETHODIMP CSmtpAdminVirtualDirectory::get_Password ( BSTR * pstrPassword )
{
	return StdPropertyGet ( m_strPassword, pstrPassword );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_Password ( BSTR strPassword )
{
	return StdPropertyPut ( &m_strPassword, strPassword );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::get_LogAccess( BOOL* pfLogAccess )
{
	return StdPropertyGet ( m_fLogAccess, pfLogAccess );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_LogAccess( BOOL fLogAccess )
{
	return StdPropertyPut ( &m_fLogAccess, fLogAccess );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::get_AccessPermission( long* plAccessPermission )
{
	return StdPropertyGet ( m_dwAccess, plAccessPermission );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_AccessPermission( long lAccessPermission )
{
	return StdPropertyPut ( &m_dwAccess, lAccessPermission );
}


STDMETHODIMP CSmtpAdminVirtualDirectory::get_SslAccessPermission( long* plSslAccessPermission )
{
    return StdPropertyGet ( m_dwSslAccess, plSslAccessPermission );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_SslAccessPermission( long lSslAccessPermission )
{
    return StdPropertyPut ( &m_dwSslAccess, lSslAccessPermission );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////


// get /set property for current vdir
STDMETHODIMP CSmtpAdminVirtualDirectory::GetHomeDirectory( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::GetHomeDirectory" );
    m_strName.Empty();
    m_strName = _T("");
    return Get();
}

STDMETHODIMP CSmtpAdminVirtualDirectory::SetHomeDirectory( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::SetHomeDirectory" );
    m_strName.Empty();
    m_strName = _T("");
    return Set();
}


STDMETHODIMP CSmtpAdminVirtualDirectory::Create ( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Create" );

	HRESULT	hr = NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};

	if( !m_strName || !m_strDirectory )
	{
		FatalTrace ( (LPARAM) this, "No virtual directory to create!" );
		hr = E_POINTER;
		return hr;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return SmtpCreateExceptionFromHresult(hr);
	}

	CMetabaseKey		hMB( pmetabase );

    GetMDRootPath( szPath, m_dwServiceInstance );
    hr = hMB.Open( szPath, METADATA_PERMISSION_WRITE );
    BAIL_ON_FAILURE(hr);

    hr = hMB.CreateChild(m_strName);
    BAIL_ON_FAILURE(hr);

	if( !SetVRootPropertyToMetabase( &hMB, m_strName, m_strDirectory, m_strUser, m_strPassword, m_dwAccess, m_dwSslAccess, m_fLogAccess) )
	{
		hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
		goto Exit;
	}

    hr = hMB.Save();
    BAIL_ON_FAILURE(hr);

Exit:
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromHresult(hr);
    }

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminVirtualDirectory::Delete ( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Delete" );

	HRESULT	hr = NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};

	if ( !m_strName ) {
		FatalTrace ( (LPARAM) this, "Bad dir name to delete" );
		return E_POINTER;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

    GetMDRootPath( szPath, m_dwServiceInstance );

	CMetabaseKey		hMB( pmetabase );
    hr = hMB.Open( szPath, METADATA_PERMISSION_WRITE);
    BAIL_ON_FAILURE(hr);

    hr = hMB.DestroyChild(m_strName);
    BAIL_ON_FAILURE(hr);

    hr = hMB.Save();
    BAIL_ON_FAILURE(hr);

Exit:
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromHresult(hr);
    }

    TraceFunctLeave ();
    return hr;
}

// get /set property for current vdir
STDMETHODIMP CSmtpAdminVirtualDirectory::Get( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Get" );

	HRESULT	hr = NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};
	TCHAR	szDirectory[MAX_PATH + UNLEN + 3] = {0};
	TCHAR	szUser[UNLEN+1] = {0};
	TCHAR	szPassword[PWLEN+1] = {0};

	// zero out
	m_strDirectory = (BSTR)NULL;
	m_strUser = (BSTR)NULL;
	m_strPassword = (BSTR)NULL;

	if( !m_strName )
	{
		FatalTrace ( (LPARAM) this, "No virtual directory to create!" );
		hr = E_POINTER;
		return hr;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey		hMB( pmetabase );

    GetMDVDirPath( szPath, m_dwServiceInstance, m_strName );
    hr = hMB.Open( szPath );
	if( FAILED(hr) )
	{
		hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
		goto Exit;
	}

	if( !GetVRootPropertyFromMetabase( &hMB, _T(""), szDirectory, szUser, szPassword, &m_dwAccess, &m_dwSslAccess, &m_fLogAccess) )
	{
		hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
		goto Exit;
	}

	m_strDirectory = szDirectory;
	m_strUser = szUser;
	m_strPassword = szPassword;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminVirtualDirectory::Set( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Set" );

	HRESULT	hr = NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};

	if( !m_strName || !m_strDirectory )
	{
		ErrorTrace ( (LPARAM) this, "No virtual directory to create!" );
		hr = E_POINTER;
		return hr;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey		hMB( pmetabase );

    GetMDVDirPath( szPath, m_dwServiceInstance, m_strName );
	hr = hMB.Open( szPath,METADATA_PERMISSION_WRITE );
    BAIL_ON_FAILURE(hr);

	if( !SetVRootPropertyToMetabase( &hMB, _T(""), m_strDirectory, m_strUser, m_strPassword, m_dwAccess, m_dwSslAccess, m_fLogAccess) )
	{
		hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
		return hr;
	}

    hr = hMB.Save();

Exit:
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromHresult(hr);
    }

	TraceFunctLeave ();
	return hr;
}


STDMETHODIMP CSmtpAdminVirtualDirectory::Enumerate( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Enumerate" );

	HRESULT	hr	= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};

	DWORD	dwAccess;
	DWORD	dwSslAccess;
	BOOL	fLogAccess;

	TCHAR	szName[METADATA_MAX_NAME_LEN+2];
	TCHAR	szDirectory[MAX_PATH + UNLEN + 3];

	TCHAR	szUser[UNLEN+1];
	TCHAR	szPassword[PWLEN+1];

	INT		i;

	PVDIR_ENTRY		pCurVDir=NULL;


	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return hr;;
	}

    GetMDRootPath( szPath, m_dwServiceInstance );

	CMetabaseKey		hMB( pmetabase );
    hr = hMB.Open( szPath );
	if( FAILED(hr) )
	{
		hr = SmtpCreateExceptionFromHresult( hr );
		goto Exit;
	}


	Clear();	// reset state, m_lCount = 0

	i = 0;

	while( SUCCEEDED( hMB.EnumObjects(_T(""), szName, i ++) ) )
	{
		if ( !GetVRootPropertyFromMetabase( &hMB, szName, szDirectory, szUser, szPassword, &dwAccess, &dwSslAccess, &fLogAccess) )
		{
			continue;
		}

		pCurVDir = new VDIR_ENTRY;
		if( !pCurVDir )
		{
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		lstrcpy( pCurVDir->szName, szName);
		lstrcpy( pCurVDir->szDirectory, szDirectory);
		lstrcpy( pCurVDir->szUser, szUser);
		lstrcpy( pCurVDir->szPassword, szPassword);
		pCurVDir-> dwAccess = dwAccess;
		pCurVDir-> dwSslAccess = dwSslAccess;
		pCurVDir-> fLogAccess = fLogAccess;

		InsertHeadList( &m_list, &(pCurVDir->list) );
		m_lCount ++;
	}

	// _ASSERT( GetLastError() == ERROR_NO_MORE_ITEMS );

	m_fEnumerateCalled = TRUE;

Exit:
	TraceFunctLeave ();
	return hr;
}


STDMETHODIMP CSmtpAdminVirtualDirectory::GetNth	( long lIndex )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::GetNth" );

	if( lIndex < 0 || lIndex >= m_lCount )
	{
		TraceFunctLeave ();
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	PLIST_ENTRY     pEntry;
	PVDIR_ENTRY		pVdir;
	INT				i;

	if( !m_fEnumerateCalled )
	{
		TraceFunctLeave ();
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	// zero out
	m_strName = (BSTR)NULL;
	m_strDirectory = (BSTR)NULL;
	m_strUser = (BSTR)NULL;
	m_strPassword = (BSTR)NULL;

	pEntry = &m_list;
	for( i=0; i<=lIndex; i++ )
	{
		pEntry=pEntry->Flink;
		_ASSERT( pEntry != & m_list);

		if( pEntry == & m_list )
		{
			TraceFunctLeave ();
			return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
		}
	}

	pVdir = CONTAINING_RECORD(pEntry, VDIR_ENTRY, list);

	// automatically changed to UNICODE
	m_strName = pVdir->szName;
	m_strDirectory = pVdir->szDirectory;
	m_strUser = pVdir->szUser;
	m_strPassword = pVdir->szPassword;

	TraceFunctLeave ();
	return NOERROR;
}


BOOL CSmtpAdminVirtualDirectory::GetVRootPropertyFromMetabase( 
        CMetabaseKey*         hMB, 
        const TCHAR* szName, 
		TCHAR*       szDirectory, 
        TCHAR*       szUser, 
        TCHAR*       szPassword, 
        DWORD*      pdwAccess, 
        DWORD*      pdwSslAccess, 
        BOOL*       pfLogAccess
        )

{
    DWORD		cb;
    DWORD       dwDontLog = DEFAULT_LOG_TYPE;
    HRESULT     hr = NOERROR;

	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::GetVRootPropertyFromMetabase" );

    cb = (MAX_PATH + UNLEN + 3) * sizeof(TCHAR);
    hr = hMB->GetString( szName, MD_VR_PATH, szDirectory,cb,0 );
    if( FAILED(hr) )
    {
        szDirectory[0] = _T('\0');
    }

    StdGetMetabaseProp( hMB, MD_ACCESS_PERM, MD_ACCESS_READ | MD_ACCESS_WRITE, 
        pdwAccess, szName );

    StdGetMetabaseProp( hMB, MD_SSL_ACCESS_PERM, 0, 
        pdwSslAccess, szName );

    StdGetMetabaseProp( hMB, MD_DONT_LOG, DEFAULT_LOG_TYPE, 
        &dwDontLog, szName );
    *pfLogAccess = !dwDontLog;

    cb = sizeof(TCHAR) * (UNLEN+1);
    hr = hMB->GetString(szName,MD_VR_USERNAME,szUser,cb);
    if( FAILED(hr) )
	{
		szUser[0] = _T('\0');
	}

	cb = sizeof(TCHAR) * (PWLEN+1);
	if ( (szUser[0] != _T('\0')) &&
		 (szDirectory[0] == _T('\\')) && 
		 (szDirectory[1] == _T('\\')) )
	{
		hr = hMB->GetString(szName,MD_VR_PASSWORD,szPassword,cb,METADATA_NO_ATTRIBUTES);
        if( FAILED(hr) )
		{
			DebugTrace( (LPARAM)this, "Error %d reading path from %s\n", GetLastError(), szName);
			szPassword[0] = _T('\0');
		}
	}

	return TRUE;
}

BOOL CSmtpAdminVirtualDirectory::SetVRootPropertyToMetabase( 
        CMetabaseKey*             hMB, 
        const TCHAR*     szName, 
		const TCHAR*     szDirectory, 
        const TCHAR*     szUser, 
        const TCHAR*     szPassword, 
        DWORD           dwAccess, 
        DWORD           dwSslAccess, 
        BOOL            fLogAccess
        )
{
    DWORD		dwDontLog = fLogAccess ? 0 : 1;
    HRESULT     hr = NOERROR;

	hr = hMB->SetString( szName,MD_VR_PATH, szDirectory );
    BAIL_ON_FAILURE(hr);

    hr = hMB->SetDword( szName,	MD_DONT_LOG, dwDontLog);
    BAIL_ON_FAILURE(hr);

    hr = hMB->SetDword( szName, MD_ACCESS_PERM, dwAccess );
    BAIL_ON_FAILURE(hr);

    hr = hMB->SetDword( szName, MD_SSL_ACCESS_PERM, dwSslAccess);
    BAIL_ON_FAILURE(hr);

    if( szUser[0] )
    {
        hr = hMB->SetString( szName, MD_VR_USERNAME, szUser);
    }

	if( szPassword[0] )
    {
        hr = hMB->SetString( szName, MD_VR_PASSWORD, szPassword, METADATA_INHERIT | METADATA_SECURE );
    }

Exit:
    if( FAILED(hr) )
    {
        SetLastError(hr);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqueue.inc ===
# Global settings for SMTP AQueue subprojects

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

!IFNDEF SMTPDIR
SMTPDIR=smtp
!ENDIF

!INCLUDE $(IISBASEDIR)\svcs\$(SMTPDIR)\smtp.inc

STAXAQUEUE=$(STAXSMTP)\aqueue

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqadmsvr.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadmsvr.cpp
//
//  Description:  Implements the IAdvQueueAdmin interface for the CAQSvrInst
//      object.  Also contains implementations of helper functions and classes.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      11/30/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqadmsvr.h"
#include "mailadmq.h"
#include <intrnlqa_i.c>

#define QA_DMT_CONTEXT_SIG 'CDAQ'

//
//  Order of recipient address types to check
//
const DWORD g_rgdwQAPIRecipPropIDs[] = {
                IMMPID_RP_ADDRESS_SMTP,
                IMMPID_RP_ADDRESS_X400,
                IMMPID_RP_LEGACY_EX_DN,
                IMMPID_RP_ADDRESS_X500,
                IMMPID_RP_ADDRESS_OTHER};

const DWORD   g_rgdwQAPISenderPropIDs[] = {
                IMMPID_MP_SENDER_ADDRESS_SMTP,
                IMMPID_MP_SENDER_ADDRESS_X400,
                IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN,
                IMMPID_MP_SENDER_ADDRESS_X500,
                IMMPID_MP_SENDER_ADDRESS_OTHER};

const DWORD g_cQAPIAddressTypes = 5;

#define         QAPI_SMTP_ADDRESS_TYPE  L"SMTP:"
#define         QAPI_X400_ADDRESS_TYPE  L"X400:"
#define         QAPI_EX_ADDRESS_TYPE    L"EX:"
#define         QAPI_X500_ADDRESS_TYPE  L"X500:"
#define         QAPI_OTHER_ADDRESS_TYPE L"X-UNKNOWN:"

const WCHAR *g_rgwszQAPIAddressTypes[] = {
                QAPI_SMTP_ADDRESS_TYPE,
                QAPI_X400_ADDRESS_TYPE,
                QAPI_EX_ADDRESS_TYPE,
                QAPI_X500_ADDRESS_TYPE,
                QAPI_OTHER_ADDRESS_TYPE};

const DWORD g_rgcbQAPIAddressTypes[] =  {
                sizeof(QAPI_SMTP_ADDRESS_TYPE),
                sizeof(QAPI_X400_ADDRESS_TYPE),
                sizeof(QAPI_EX_ADDRESS_TYPE),
                sizeof(QAPI_X500_ADDRESS_TYPE),
                sizeof(QAPI_OTHER_ADDRESS_TYPE)};



//---[ fVerifyQAPIAddressTypes ]-----------------------------------------------
//
//
//  Description:
//      Validates that the above global structures are in synch
//  Parameters:
//      -
//  Returns:
//      TRUE on success
//      FALSE on failure
//  History:
//      2/19/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline BOOL  fVerifyQAPIAddressTypes()
{
    static BOOL fVerificationDone = FALSE;

    if (!fVerificationDone)
    {
        //
        //  Loop through all recipiences
        //
        for (DWORD i = 0; i < g_cQAPIAddressTypes; i++)
        {
            DWORD cbAddressType = (wcslen(g_rgwszQAPIAddressTypes[i])+1)*sizeof(WCHAR);
            if (g_rgcbQAPIAddressTypes[i] != cbAddressType)
                return FALSE;
        }
        fVerificationDone = TRUE;
    }
    return TRUE;
}


//Used to check *client* supplied structures against versions.  RPC supplied
//structures are not checked.
inline BOOL fCheckCurrentVersion(DWORD dwVersion)
{
    return (((DWORD)CURRENT_QUEUE_ADMIN_VERSION) == dwVersion);
}

//---[ QueueAdminDNTIteratorContext ]------------------------------------------
//
//
//  Description:
//      Context passed to QueueAdmin DMT iterator functions.
//  Hungarian:
//      qadntc, pqadntc
//
//-----------------------------------------------------------------------------
class QueueAdminDMTIteratorContext
{
public:
    QueueAdminDMTIteratorContext()
    {
        ZeroMemory(this, sizeof(QueueAdminDMTIteratorContext));
        m_dwSignature = QA_DMT_CONTEXT_SIG;
    };
    DWORD                   m_dwSignature;
    DWORD                   m_cItemsToReturn;
    DWORD                   m_cItemsFound;
    HRESULT                 m_hrResult;
    QUEUELINK_ID           *m_rgLinkIDs;
    QUEUELINK_ID           *m_pCurrentLinkID;
    QueueAdminMapFn         m_pfn;
    CAQAdminMessageFilter  *m_paqmf;
    IQueueAdminMessageFilter *m_pIQueueAdminMessageFilter;
};


//---[ SanitizeCountAndVolume ]------------------------------------------------
//
//
//  Description:
//      Make queue count and volume sutable for user consumption.  There are
//      intended timing windows where the internal versions of these counts
//      may drop to zero.  Rather than redesign this, we just display zero
//      to the admin.
//  Parameters:
//      IN OUT  pcCount     Count to check and update
//      IN OUT  puliVolume  Queue volume to check and update
//  Returns:
//      -
//  History:
//      1/28/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID SanitizeCountAndVolume(IN OUT DWORD *pcCount,
                            IN OUT ULARGE_INTEGER *puliVolume)
{
    TraceFunctEnterEx(0, "SanitizeCountAndVolume");
    _ASSERT(pcCount);
    _ASSERT(puliVolume);

    //
    // If we are negative sanitize to size zero
    //
    if (*pcCount > 0xFFFFF000)
    {
        DebugTrace(0, "Sanitizing msg count of %d", *pcCount);
        *pcCount = 0;
        puliVolume->QuadPart = 0;
    }
    TraceFunctLeave();
}

//---[ IterateDMTAndGetLinkIDs ]------------------------------------------------
//
//
//  Description:
//      Iterator function used to walk the DMT and generate the perf counters
//      we are interested in.
//  Parameters:
//          IN  pvContext   - pointer to QueueAdminDMTIteratorContext
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      12/3/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID IterateDMTAndGetLinkIDs(PVOID pvContext, PVOID pvData,
                             BOOL fWildcard, BOOL *pfContinue,
                             BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) NULL, "IterateDMTAndGetLinkIDs");
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    QueueAdminDMTIteratorContext *paqdntc = (QueueAdminDMTIteratorContext *)pvContext;
    CLinkMsgQueue *plmq = NULL;
    CDomainEntryLinkIterator delit;
    HRESULT hr = S_OK;

    _ASSERT(pvContext);
    _ASSERT(pvData);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);

    *pfContinue = TRUE;
    *pfDelete = FALSE;

    //Iterate of all links for this domain entry
    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to enumerate domain entry for link IDs - 0x%08X", hr);
        goto Exit;
    }

    do
    {
        plmq = delit.plmqGetNextLinkMsgQueue(plmq);
        if (!plmq)
            break;

        //See if we are running out of room to return data
        if (paqdntc->m_cItemsToReturn <= paqdntc->m_cItemsFound)
        {
            paqdntc->m_hrResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        //Have link fill out link info struct
        paqdntc->m_hrResult = plmq->HrGetLinkID(paqdntc->m_pCurrentLinkID);
        if (FAILED(paqdntc->m_hrResult))
            goto Exit;


        //Point to next info in array
        paqdntc->m_pCurrentLinkID++;
        paqdntc->m_cItemsFound++;

    } while (plmq);

  Exit:

    if (plmq)
        plmq->Release();

    //If we have encountered a failure... do not continue
    if (FAILED(paqdntc->m_hrResult))
        *pfContinue = FALSE;

    TraceFunctLeave();
}

//---[ IterateDMTAndApplyQueueAdminFunction ]----------------------------------
//
//
//  Description:
//      Iterator function used to walk the DMT and generate the perf counters
//      we are interested in.
//  Parameters:
//          IN  pvContext   - pointer to QueueAdminDMTIteratorContext
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      12/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID IterateDMTAndApplyQueueAdminFunction(PVOID pvContext, PVOID pvData,
                             BOOL fWildcard, BOOL *pfContinue,
                             BOOL *pfDelete)
{
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    QueueAdminDMTIteratorContext *paqdntc = (QueueAdminDMTIteratorContext *)pvContext;
    CDestMsgQueue *pdmq = NULL;
    HRESULT hr = S_OK;
    CDomainEntryQueueIterator deqit;

    _ASSERT(pvContext);
    _ASSERT(pvData);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(paqdntc->m_paqmf);
    _ASSERT(paqdntc->m_pIQueueAdminMessageFilter);

    *pfContinue = TRUE;
    *pfDelete = FALSE;


    //Iterate of all links for this domain entry
    hr = deqit.HrInitialize(pdentry);
    if (FAILED(hr))
        return;

    do
    {
        pdmq = deqit.pdmqGetNextDestMsgQueue(pdmq);
        if (!pdmq)
            break;

        paqdntc->m_hrResult = pdmq->HrApplyQueueAdminFunction(
                                        paqdntc->m_pIQueueAdminMessageFilter);

        paqdntc->m_cItemsFound++;

    } while (pdmq && SUCCEEDED(paqdntc->m_hrResult));

    if (pdmq)
        pdmq->Release();

    //If we have encountered a failure... do not continue
    if (FAILED(paqdntc->m_hrResult))
        *pfContinue = FALSE;

}


//---[ QueueAdminApplyActionToMessages ]---------------------------------------
//
//
//  Description:
//      FifoQ map function that is used to apply actions to messages.
//  Parameters:
//      IN  pmsgref     ptr to data on queue
//      IN  pvContext   CAQAdminMessageFilter used
//      OUT pfContinue  TRUE if we should continue
//      OUT pfDelete    TRUE if item should be deleted
//  Returns:
//      S_OK on sucess
//  History:
//      12/7/98 - MikeSwa Created
//      2/21/99 - MikeSwa Updated to support new IQueueAdmin* interfaces
//
//-----------------------------------------------------------------------------
HRESULT QueueAdminApplyActionToMessages(IN CMsgRef *pmsgref, IN PVOID pvContext,
                                 OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    _ASSERT(pmsgref);
    _ASSERT(pvContext);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);

    IQueueAdminMessageFilter *pIQueueAdminMessageFilter =
                                (IQueueAdminMessageFilter *) pvContext;
    HRESULT hr = S_OK;
    IUnknown *pIUnknownMsg = NULL;

    hr = pmsgref->QueryInterface(IID_IUnknown, (void **) &pIUnknownMsg);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IUnknown failed");
    if (FAILED(hr))
    {
        *pfContinue = FALSE;
        goto Exit;
    }

    hr = pIQueueAdminMessageFilter->HrProcessMessage(pIUnknownMsg,
                                        pfContinue, pfDelete);

    if (FAILED(hr))
    {
        *pfContinue = FALSE;
        goto Exit;
    }

  Exit:

    if (pIUnknownMsg)
        pIUnknownMsg->Release();

    return hr;
}

//---[ CAQAdminMessageFilter::HrProcessMessage ]-------------------------------
//
//
//  Description:
//      Processes a single message during an iterator funtion
//  Parameters:
//      IN  pIUnknownMsg        IUnknown ptr for message
//      OUT pfContinue          TRUE if iterator should continue
//      OUT pfDelete            TRUE if iterator should delete from the queue
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created
//      8/9/00 - t-toddc modifed to support IMailMsgProperties as well
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::HrProcessMessage(
            IUnknown *pIUnknownMsg,
            BOOL     *pfContinue,
            BOOL     *pfDelete)
{
    TraceFunctEnterEx((LPARAM) this, "CAQAdminMessageFilter::HrProcessMessage");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;
    IMailMsgProperties* pIMailMsgProperties = NULL;
    BOOL fMsgTypeIsCMsgRef = FALSE;
    BOOL fMatchesFilter = FALSE;

    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(pIUnknownMsg);
    _ASSERT(m_pIQueueAdminAction);

    if (!pfContinue || !pfDelete || !pIUnknownMsg)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (!m_pIQueueAdminAction)
    {
        hr = E_FAIL;
        goto Exit;
    }

    *pfContinue = TRUE;
    *pfDelete = FALSE;

    if (fFoundEnoughMsgs())
    {
        *pfContinue = FALSE;
        goto Exit;
    }

    //Check and see if we should skip this message (paging functionality)
    if ((AQ_MSG_FILTER_ENUMERATION & m_dwFilterFlags) && fSkipMsg())
        goto Exit;

    //Get CMsgRef "interface", or IMailMsgProperties interface
    hr = pIUnknownMsg->QueryInterface(IID_CMsgRef, (void **) &pmsgref);
    if (SUCCEEDED(hr))
    {
        fMsgTypeIsCMsgRef = TRUE;
    }
    else
    {
        //
        //  If it is not a CMsgRef... then it must be an IMailMsgProperties
        //
        hr = pIUnknownMsg->QueryInterface(IID_IMailMsgProperties,
                                          (void **) &pIMailMsgProperties);
        if (FAILED(hr))
        {
            _ASSERT(FALSE && "Unable to QI for msgref or IMailMsgProperties");
            ErrorTrace((LPARAM) this,
                "Unable to QI for msgref or mailmsg 0x%08X", hr);
            goto Exit;
        }

    }

    if (fMsgTypeIsCMsgRef)
        fMatchesFilter = pmsgref->fMatchesQueueAdminFilter(this);
    else
        fMatchesFilter = CAsyncAdminMailMsgQueue::fMatchesQueueAdminFilter(
                        pIMailMsgProperties, this);

    if (fMatchesFilter)
    {
        if (AQ_MSG_FILTER_ACTION & m_dwFilterFlags)
        {
            //Apply action & say that we found another that matches filter
            hr = m_pIQueueAdminAction->HrApplyActionToMessage(pIUnknownMsg,
                                                            m_dwMessageAction,
                                                            m_pvUserContext,
                                                            pfDelete);
            if (FAILED(hr))
                goto Exit;
        }
        else if (AQ_MSG_FILTER_ENUMERATION & m_dwFilterFlags)
        {
            //$$TODO - Handle slightly more complex filters like
            // - N largest
            // - N oldest
            //that may require matching, sorting, and throwing away previous matches.

            if (pmfGetMsgInfo())
            {
                if (fMsgTypeIsCMsgRef)
                    hr = pmsgref->HrGetQueueAdminMsgInfo(pmfGetMsgInfo(),
                                                         m_pIQueueAdminAction);
                else
                    hr = CAsyncAdminMailMsgQueue::HrGetQueueAdminMsgInfo(
                                pIMailMsgProperties, pmfGetMsgInfo(), m_pvUserContext);
            }

        }
        else
            _ASSERT(0 && "Unknown message enumeration");

        //Mark as found and see if we should continue
        if (SUCCEEDED(hr) && fFoundMsg())
            *pfContinue = FALSE;

    }

  Exit:

    if (pmsgref)
        pmsgref->Release();

    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    //See if backing store for message has been deleted
    if (AQUEUE_E_MESSAGE_HANDLED == hr)
    {
        DebugTrace((LPARAM) this, "Found handled message in queue enumeration");
        hr = S_OK; //do not fail out of enumeration for a handled message
    }
    TraceFunctLeave();
    return hr;
}



//---[ CAQAdminMessageFilter::HrSetQueueAdminAction ]--------------------------
//
//
//  Description:
//      Sets the IQueueAdminAction interface for filter
//  Parameters:
//      IN  pIQueueAdminAction        Interface for filter
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::HrSetQueueAdminAction(
            IQueueAdminAction *pIQueueAdminAction)
{
    _ASSERT(pIQueueAdminAction);

    if (!pIQueueAdminAction)
        return E_POINTER;

    if (m_pIQueueAdminAction)
        m_pIQueueAdminAction->Release();

    m_pIQueueAdminAction = pIQueueAdminAction;
    m_pIQueueAdminAction->AddRef();

    return S_OK;
}

//---[ CAQAdminMessageFilter::HrSetCurrentUserContext ]-------------------------
//
//
//  Description:
//      Sets a context that is distinct from the pIQueueAdminAction interface
//      and is passed to the IQueueAdminAction interface.  This can be used
//      by a IQueueAdminAction interface to allow per-session state so
//      multiple threads can act on a single IQueueAdminAction.
//
//      The actual content of the context is left to the implementation of
//      IQueueAdminAction.
//  Parameters:
//      IN  pvContext       The context passed in
//  Returns:
//      S_OK always
//  History:
//      4/2/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::HrSetCurrentUserContext(
            PVOID	pvContext)
{
    m_pvUserContext = pvContext;
    return S_OK;
};

//---[ CAQAdminMessageFilter::HrGetCurrentUserContext ]-------------------------
//
//
//  Description:
//      Returns the context previously set by HrSetCurrentUserContext
//  Parameters:
//      OUT  ppvContext       The context previously set
//  Returns:
//      S_OK if ppvContext is non-NULL
//      E_POINTER if ppvContext is NULL
//  History:
//      4/2/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::HrGetCurrentUserContext(
            PVOID	*ppvContext)
{

    if (!ppvContext)
        return E_POINTER;

    *ppvContext = m_pvUserContext;
    return S_OK;
};

//---[ CAQAdminMessageFilter::QueryInterface ]--------------------------------
//
//
//  Description:
//      QueryInterface for CDestMsgQueue that supports:
//          - IQueueAdminMessageFilter
//          - IUnknown
//  Parameters:
//
//  Returns:
//
//  History:
//      2/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminMessageFilter *>(this);
    }
    else if (IID_IQueueAdminMessageFilter == riid)
    {
        *ppvObj = static_cast<IQueueAdminMessageFilter *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}


//---[ HrLinkFromLinkID ]------------------------------------------------------
//
//
//  Description:
//      Utility function used to get the IQueueAdminLink for a giben QUEUELINK_ID
//  Parameters:
//      IN  pdmq        CDomainMappingTable for this virtual server instance
//      IN  pqlLinkID   QUEUELINK_ID for link we are trying to find
//      OUT pIQueueAdminLink link interface returned
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pqlLinkID is invalid
//      Error codes from HrGetDomainEntry and HrGetLinkMsgQueue on failure
//  History:
//      12/4/98 - MikeSwa Created
//      2/23/99 - MikeSwa Updated for IQueueAdmin* interfaces
//      12/11/2000 - MikeSwa Added presubmission link (from t-toddc's work)
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrLinkFromLinkID(QUEUELINK_ID *pqlLinkID,
                         IQueueAdminLink **ppIQueueAdminLink)
{
    _ASSERT(pqlLinkID);
    _ASSERT(ppIQueueAdminLink);
    _ASSERT(QLT_LINK == pqlLinkID->qltType);
    _ASSERT(pqlLinkID->szName);

    HRESULT hr = S_OK;
    LPSTR   szDomain = NULL;
    DWORD   cbDomain = 0;
    CDomainEntry *pdentry = NULL;
    CLinkMsgQueue *plmq = NULL;
    CMailMsgAdminLink *pmmaq = NULL;

    CAQScheduleID aqsched(pqlLinkID->uuid, pqlLinkID->dwId);
    BOOL flinkmatched = FALSE;

    *ppIQueueAdminLink = NULL;

    if ((QLT_LINK != pqlLinkID->qltType) || !pqlLinkID->szName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    szDomain = szUnicodeToAscii(pqlLinkID->szName);
    if (!szDomain)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Get the domain entry that we are interesting in
    cbDomain = lstrlen(szDomain);
    hr = m_dmt.HrGetDomainEntry(cbDomain, szDomain,
                                &pdentry);
    if (SUCCEEDED(hr))
    {
        //Search domain entry to link with corresponding router id/schedule id
        hr = pdentry->HrGetLinkMsgQueue(&aqsched, &plmq);

        if (FAILED(hr))
            goto Exit;

        flinkmatched = TRUE;    //found a link for this domain
    }
    else
        flinkmatched = FALSE;

    //Try special links
    //check local link
    if (!flinkmatched)
    {
        if(plmq = m_dmt.plmqGetLocalLink())
        {
            if (plmq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
             }
             else
            {
                flinkmatched = FALSE;
                plmq->Release();
                plmq = NULL;
            }
        }
    }

    //unable to find local link, check currently unreachable link
    if (!flinkmatched)
    {
        if(plmq = m_dmt.plmqGetCurrentlyUnreachable())
        {
            if (plmq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
            }
            else
            {
                flinkmatched = FALSE;
                plmq->Release();
                plmq = NULL;
            }
        }
    }

    //unable to find currently unreachable link, check precat link
    if (!flinkmatched)
    {
        if(pmmaq =  m_dmt.pmmaqGetPreCategorized())
        {
            if (pmmaq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
            }
            else
            {
                flinkmatched = FALSE;
                pmmaq->Release();
                pmmaq = NULL;
            }
        }
    }

    //unable to find currently unreachable link, check prerouting link
    if (!flinkmatched)
    {
        if(pmmaq =  m_dmt.pmmaqGetPreRouting())
        {
            if (pmmaq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
            }
            else
            {
                flinkmatched = FALSE;
                pmmaq->Release();
                pmmaq = NULL;
            }
        }
    }

    //unable to find currently prerouting link, check presubmission link
    if (!flinkmatched)
    {
        if(pmmaq =  m_dmt.pmmaqGetPreSubmission())
        {
            if (pmmaq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
            }
            else
            {
                flinkmatched = FALSE;
                pmmaq->Release();
                pmmaq = NULL;
            }
        }
    }

    //unable to find any matching link
    if (!flinkmatched)
        goto Exit;

    if (plmq)
    {
        hr = plmq->QueryInterface(IID_IQueueAdminLink, (void **)ppIQueueAdminLink);
    }
    else if (pmmaq)
    {
        hr = pmmaq->QueryInterface(IID_IQueueAdminLink, (void **)ppIQueueAdminLink);
    }

    _ASSERT(SUCCEEDED(hr) && "QI for LMQ->IQueueAdminLink failed!!!");

    if (FAILED(hr))
        goto Exit;

Exit:

    if (pdentry)
        pdentry->Release();

    if (plmq)
        plmq->Release();

    if (pmmaq)
        pmmaq->Release();

    if (szDomain)
        FreePv(szDomain);

    return hr;
}

//---[ HrQueueFromQueueID ]-----------------------------------------------------
//
//
//  Description:
//      Queue Admin utility function that is used to look up a IQueueAdminQueue
//      given a QUEUELINK_ID.
//  Parameters:
//      IN  pdmq              CDomainMappingTable for this virtual server instance
//      IN  pqlLinkID         QUEUELINK_ID for queue we are trying to find
//      OUT ppIQueueAdminQueue DestMsgQueue we are searching for
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pqlLinkID is invalid
//      Error codes from HrGetDomainEntry and HrGetLinkMsgQueue on failure
//  History:
//      12/7/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to return IQueueAdminQueue interface
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrQueueFromQueueID(QUEUELINK_ID *pqlQueueId,
                           IQueueAdminQueue **ppIQueueAdminQueue)
{
    _ASSERT(pqlQueueId);
    _ASSERT(ppIQueueAdminQueue);
    _ASSERT(QLT_QUEUE == pqlQueueId->qltType);
    _ASSERT(pqlQueueId->szName);

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    LPSTR   szDomain = NULL;
    DWORD   cbDomain = 0;
    CDomainEntry *pdentry = NULL;
    CDestMsgQueue *pdmq = NULL;
    CAQMessageType aqmt(pqlQueueId->uuid, pqlQueueId->dwId);
    IQueueAdminAction  *pIQueueAdminAction = NULL;

    *ppIQueueAdminQueue = NULL;
    if ((QLT_QUEUE != pqlQueueId->qltType) || !pqlQueueId->szName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    szDomain = szUnicodeToAscii(pqlQueueId->szName);
    if (!szDomain)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Get the domain entry that we are interested in
    cbDomain = lstrlen(szDomain);
    hr = m_dmt.HrGetDomainEntry(cbDomain, szDomain,
                                &pdentry);
    if (FAILED(hr))
    {
        //
        // If it is not in the DMT... try our internal queues
        //
        hr = HrInternalQueueFromQueueID(pqlQueueId,
                                        ppIQueueAdminQueue);
        // either way, failure or success, head to exit.
        goto Exit;
    }

    //Search domain entry to link with corresponding router id/schedule id
    _ASSERT(pdentry);
    hr = pdentry->HrGetDestMsgQueue(&aqmt, &pdmq);

    if (FAILED(hr))
        goto Exit;

    _ASSERT(pdmq);
    hr = pdmq->QueryInterface(IID_IQueueAdminQueue,
                             (void **) ppIQueueAdminQueue);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (FAILED(hr) && (*ppIQueueAdminQueue))
    {
        (*ppIQueueAdminQueue)->Release();
        *ppIQueueAdminQueue = NULL;
    }

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    if (pdentry)
        pdentry->Release();

    if (pdmq)
        pdmq->Release();

    if (szDomain)
        FreePv(szDomain);

    return hr;
}

//---[ HrInternalQueueFromQueueID ]--------------------------------------------
//
//
//  Description:
//      Queue Admin utility function that is used to look up an internal
//      IQueueAdminQueue  given a QUEUELINK_ID.
//  Parameters:
//      IN  pqlQueueID         QUEUELINK_ID for queue we are trying to find
//      OUT ppIQueueAdminQueue Internal queue we are searching for
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pqlLinkID is invalid
//      AQUEUE_E_INVALID_DOMAIN if the queue was not found among our internal queues
//  History:
//
//      8/9/00 - t-toddc created
//      12/11/2000 - MikeSwa Modified for Hg checkin
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrInternalQueueFromQueueID(QUEUELINK_ID *pqlQueueId,
                                               IQueueAdminQueue **ppIQueueAdminQueue)
{
    HRESULT hr = S_OK;
    IQueueAdminQueue*  pIQueueAdminQueue = NULL;
    IQueueAdminAction* pIQueueAdminAction = NULL;
    DWORD i = 0;
    BOOL fMatch = FALSE;
    IQueueAdminQueue* ppInternalQueues[] =
        { &m_asyncqPreLocalDeliveryQueue,
          &m_asyncqPreSubmissionQueue,
          &m_asyncqPreCatQueue,
          &m_asyncqPreRoutingQueue
        };

    _ASSERT(pqlQueueId);
    _ASSERT(ppIQueueAdminQueue);

    //
    //  Loop over all of our internal queues and see if they match
    //
    for(i = 0; i < sizeof(ppInternalQueues)/sizeof(IQueueAdminQueue*); i++)
    {
        hr = ppInternalQueues[i]->QueryInterface(IID_IQueueAdminQueue,
                                                 (void **) &pIQueueAdminQueue);
        if (FAILED(hr))
            goto Cleanup;

        _ASSERT(pIQueueAdminQueue);
        hr = pIQueueAdminQueue->QueryInterface(IID_IQueueAdminAction,
                                               (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI for IQueueAdminAction failed on internal queue!!");
        if (FAILED(hr))
            goto Cleanup;

        _ASSERT(pIQueueAdminAction);
        fMatch = pIQueueAdminAction->fMatchesID(pqlQueueId);
        // now release the IQueueAdminAction interface.
        pIQueueAdminAction->Release();
        pIQueueAdminAction = NULL;

        if (fMatch)
        {
            // set the output to the matching interface
            *ppIQueueAdminQueue = pIQueueAdminQueue;
            // set to null so it won't be released on cleanup
            pIQueueAdminQueue = NULL;

            goto Cleanup;
        }
        else
        {
            // release the IQueueAdminQueue - this is not a match
            pIQueueAdminQueue->Release();
            // set to null so it won't be released again on cleanup
            pIQueueAdminQueue = NULL;
        }
    }

    // If we reach this point we did not find the queue
    hr = AQUEUE_E_INVALID_DOMAIN;

Cleanup:
    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();
    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();
    return hr;
}


//---[ CAQAdminMessageFilter::~CAQAdminMessageFilter ]-------------------------
//
//
//  Description:
//      Descructor for CAQAdminMessageFilter
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/7/99 - MikeSwa Moved from inline function
//
//-----------------------------------------------------------------------------
CAQAdminMessageFilter::~CAQAdminMessageFilter()
{
	if (m_pIQueueAdminAction)
	    m_pIQueueAdminAction->Release();

    if (m_szMessageId)
        FreePv(m_szMessageId);

    if (m_szMessageSender)
        FreePv(m_szMessageSender);

    if (m_szMessageRecipient)
        FreePv(m_szMessageRecipient);

}


//---[ fStripAddressType ]-----------------------------------------------------
//
//
//  Description:
//      Strips the address type from an address.  For example, removes "SMTP:"
//      from "SMTP:user@example.net".
//  Parameters:
//      IN  wszAddress       Address to strip
//      OUT *pwszBareAddress Pointer inside szAddress that skips type prefix.
//                          This will be szAddress if there is nothing to strip
//      OUT *piAddressType  Index of address type in global array.
//                          This will be 0, if there is nothing to strip
//
//  Returns:
//      TRUE if there was an address type specified
//      FALSE if there was no address type specified
//  History:
//      3/15/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fStripAddressType(LPCWSTR wszAddress, OUT LPCWSTR *pwszBareAddress, OUT DWORD *piAddressType)
{
    TraceFunctEnterEx((LPARAM) wszAddress, "StripAddressType");
    BOOL    fAddressTypeSpecified = FALSE;

    _ASSERT(pwszBareAddress);
    _ASSERT(piAddressType);

    *pwszBareAddress = wszAddress;
    *piAddressType = 0;

    if (!wszAddress)
        goto Exit;

    //
    //  See if the filter has specified an address type... strip it off and
    //  remember it.  Skip that last address type because the actual address type
    //  is stored as part of the recipient property.
    //
    for (DWORD iCurrentAddressType = 0;
         iCurrentAddressType < g_cQAPIAddressTypes-1;
         iCurrentAddressType++)
    {
        if (!_wcsnicmp(wszAddress, g_rgwszQAPIAddressTypes[iCurrentAddressType],
                       (g_rgcbQAPIAddressTypes[iCurrentAddressType]/sizeof(WCHAR))-1))
        {
            //
            //  Set our string pointer to be the first character after the
            //
            *piAddressType = iCurrentAddressType;
            *pwszBareAddress += (g_rgcbQAPIAddressTypes[iCurrentAddressType]/sizeof(WCHAR))-1;
            fAddressTypeSpecified = TRUE;
            break;
        }
    }

    DebugTrace((LPARAM) wszAddress,
        "Address %S has an stripped address of %S",
        wszAddress, *pwszBareAddress);

  Exit:
    TraceFunctLeave();
    return fAddressTypeSpecified;
}

//---[ CAQAdminMessageFilter::InitFromMsgFilter ]------------------------------
//
//
//  Description:
//      Initializes a CAQAdminMessageFilter from a MESSAGE_FILTER structure.
//  Parameters:
//      IN pmf      Ptr to MESSAGE_FILTER to initialize from
//  Returns:
//      -
//  History:
//      12/3/98 - MikeSwa Created
//      3/15/2001 - MikeSwa Modified to strip off address type
//
//-----------------------------------------------------------------------------
void CAQAdminMessageFilter::InitFromMsgFilter(PMESSAGE_FILTER pmf)
{
    _ASSERT(pmf);
    LPCWSTR wszAddress = NULL;

    if (pmf->fFlags & MF_MESSAGEID)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_MESSAGEID;
        m_szMessageId = szUnicodeToAscii(pmf->szMessageId);
        m_dwMsgIdHash = dwQueueAdminHash(m_szMessageId);
    }

    if (pmf->fFlags & MF_SENDER)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_SENDER;

        m_fSenderAddressTypeSpecified = fStripAddressType(
                pmf->szMessageSender, &wszAddress,
                &m_dwSenderAddressType);

        m_szMessageSender = szUnicodeToAscii(wszAddress);


    }

    if (pmf->fFlags & MF_RECIPIENT)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_RECIPIENT;
        m_fRecipientAddressTypeSpecified = fStripAddressType(
                pmf->szMessageRecipient, &wszAddress,
                &m_dwRecipientAddressType);
        m_szMessageRecipient = szUnicodeToAscii(wszAddress);
    }

    //It doens not make sense to create a filter with a size of 0
    if ((pmf->fFlags & MF_SIZE) && pmf->dwLargerThanSize)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_LARGER_THAN;
        m_dwThresholdSize = pmf->dwLargerThanSize;
    }

    if (pmf->fFlags & MF_TIME)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_OLDER_THAN;
        SystemTimeToFileTime(&pmf->stOlderThan, &m_ftThresholdTime);
    }

    if (MF_FROZEN & pmf->fFlags)
        m_dwFilterFlags |= AQ_MSG_FILTER_FROZEN;

    if (MF_ALL & pmf->fFlags)
        m_dwFilterFlags |= AQ_MSG_FILTER_ALL;

    if (MF_INVERTSENSE & pmf->fFlags)
        m_dwFilterFlags |= AQ_MSG_FILTER_INVERTSENSE;

    if (MF_FAILED & pmf->fFlags)
        m_dwFilterFlags |= AQ_MSG_FILTER_FAILED;

    m_dwFilterFlags |= AQ_MSG_FILTER_ACTION;

}

//---[ CAQAdminMessageFilter::InitFromMsgEnumFilter ]--------------------------
//
//
//  Description:
//      Initializes a CAQAdminMessageFilter from a MESSAGE_ENUM_FILTER struct.
//  Parameters:
//      IN pmef     Ptr to MESSAGE_ENUM_FILTER to initialize from
//  Returns:
//      -
//  History:
//      12/3/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQAdminMessageFilter::InitFromMsgEnumFilter(PMESSAGE_ENUM_FILTER pemf)
{
    LPCWSTR wszAddress = NULL;
    _ASSERT(pemf);

    //only one of MEF_FIRST_N_MESSAGES, MEF_N_LARGEST_MESSAGES, and
    //MEF_N_OLDEST_MESSAGES make sense
    if (MEF_FIRST_N_MESSAGES & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_FIRST_N_MESSAGES;
    else if (MEF_N_LARGEST_MESSAGES & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_N_LARGEST_MESSAGES;
    else if (MEF_N_OLDEST_MESSAGES & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_N_OLDEST_MESSAGES;

    //Check how many messages we should skip (for "paged" results)
    m_cMessagesToSkip = pemf->cSkipMessages;

    if ((AQ_MSG_FILTER_FIRST_N_MESSAGES |
         AQ_MSG_FILTER_N_LARGEST_MESSAGES |
         AQ_MSG_FILTER_N_OLDEST_MESSAGES) & m_dwFilterFlags)
    {
        m_cMessagesToFind = pemf->cMessages;
    }

    if (MEF_OLDER_THAN & pemf->mefType)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_OLDER_THAN;
        SystemTimeToFileTime(&pemf->stDate, &m_ftThresholdTime);
    }

    if (MEF_LARGER_THAN & pemf->mefType)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_LARGER_THAN;
        m_dwThresholdSize = pemf->cbSize;
    }

    if (pemf->mefType & MEF_SENDER)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_SENDER;
        m_fSenderAddressTypeSpecified = fStripAddressType(
                        pemf->szMessageSender, &wszAddress,
                        &m_dwSenderAddressType);

        m_szMessageSender = szUnicodeToAscii(wszAddress);
    }

    if (pemf->mefType & MEF_RECIPIENT)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_RECIPIENT;
        m_fRecipientAddressTypeSpecified = fStripAddressType(
                         pemf->szMessageRecipient, &wszAddress,
                         &m_dwRecipientAddressType);
        m_szMessageRecipient = szUnicodeToAscii(wszAddress);
    }

    if (MEF_FROZEN & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_FROZEN;

    if (MEF_ALL & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_ALL;

    if (MEF_INVERTSENSE & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_INVERTSENSE;

    if (MEF_FAILED & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_FAILED;

    m_dwFilterFlags |= AQ_MSG_FILTER_ENUMERATION;

}

//---[ CAQAdminMessageFilter::SetSearchContext ]--------------------------------
//
//
//  Description:
//      Sets the search context which describes how many results are needed,
//      and where to store the results
//  Parameters:
//      IN  cMessagesToFind     Number of results there is room to store
//      IN  rgMsgInfo           Array of cMessagesToFind MESSAGE_INFO structs
//                              to store data
//  Returns:
//      -
//  History:
//      12/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQAdminMessageFilter::SetSearchContext(DWORD cMessagesToFind,
                                             MESSAGE_INFO *rgMsgInfo)
{
    if (!m_cMessagesToFind || (m_cMessagesToFind > cMessagesToFind))
        m_cMessagesToFind = cMessagesToFind;

    m_rgMsgInfo = rgMsgInfo;
    m_pCurrentMsgInfo = rgMsgInfo;
};

//---[ CAQAdminMessageFilter::SetMessageAction ]-------------------------------
//
//
//  Description:
//      Sets the action to apply to messages
//  Parameters:
//      IN  maMessageAction
//  Returns:
//      -
//  History:
//      12/10/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQAdminMessageFilter::SetMessageAction(MESSAGE_ACTION maMessageAction)
{
    m_dwMessageAction = maMessageAction;
}

//---[ CAQAdminMessageFilter::fFoundEnoughMsgs ]-------------------------------
//
//
//  Description:
//      Determines if we have found enough messages for this filter.
//  Parameters:
//      -
//  Returns:
//      TRUE if we have found enough messages to fill this filter
//      FALSE if we haven't
//  History:
//      12/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fFoundEnoughMsgs()
{
    //See if we are unlimited or if we've hit our limit
    if (!m_cMessagesToFind) //no limit
        return FALSE;
    else
        return (m_cMessagesFound >= m_cMessagesToFind);
};

//---[ CAQAdminMessageFilter::fFoundMsg ]--------------------------------------
//
//
//  Description:
//      Used to by the message enumeration code to record finding a message,
//      so internal pointers and counters can be updated
//  Parameters:
//      -
//  Returns:
//      TRUE if we have found enough messages
//      FALSE if we need to find more messages
//  History:
//      12/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fFoundMsg()
{
    m_cMessagesFound++;
    if (m_pCurrentMsgInfo)
        m_pCurrentMsgInfo++;
    return fFoundEnoughMsgs();
};


//---[ CAQAdminMessageFilter::fMatchesId ]-------------------------------------
//
//
//  Description:
//      Returns TRUE if ID matches
//  Parameters:
//      szMessageId     String to check
//  Returns:
//      TRUE if match
//  History:
//      12/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesId(LPCSTR szMessageId)
{
    BOOL fStrCmp = FALSE;

    if (szMessageId && m_szMessageId)
        fStrCmp = (0 == lstrcmpi(szMessageId, m_szMessageId));
    else if (!szMessageId && !m_szMessageId)
        fStrCmp = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fStrCmp = !fStrCmp;

    return fStrCmp;
}

//---[ CAQAdminMessageFilter::fMatchesSender ]---------------------------------
//
//
//  Description:
//      Checks if the sender of the message matches the sender of filter
//  Parameters:
//      szMessageSender     The 822 sender of the message
//  Returns:
//      TRUE on match
//  History:
//      12/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesSender(LPCSTR szMessageSender)
{
    BOOL fStrCmp = FALSE;

    if (szMessageSender && m_szMessageSender)
    {
        fStrCmp = CAddr::IsRecipientInRFC822AddressList(
                                                (LPSTR) szMessageSender,
                                                (LPSTR) m_szMessageSender);
    }
    else if (!szMessageSender && !m_szMessageSender)
        fStrCmp = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fStrCmp = !fStrCmp;

    return fStrCmp;
}

//---[ CAQAdminMessageFilter::fMatchesRecipient ]-------------------------------
//
//
//  Description:
//      Used to check if the messages recipients match the filters
//  Parameters:
//      szMessageRecipient      Recipient list to check
//  Returns:
//      TRUE if matches
//  History:
//      12/9/98 - MikeSwa Created
//      2/17/99 - MikeSwa Updated to use smtpaddr lib
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesRecipient(LPCSTR szMessageRecipient)
{
    BOOL fStrCmp = FALSE;

    if (szMessageRecipient && m_szMessageRecipient)
    {
        fStrCmp = CAddr::IsRecipientInRFC822AddressList(
                                                (LPSTR) szMessageRecipient,
                                                (LPSTR) m_szMessageRecipient);
    }
    else if (!szMessageRecipient && !m_szMessageRecipient)
        fStrCmp = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fStrCmp = !fStrCmp;

    return fStrCmp;
}

//---[ CAQAdminMessageFilter::fMatchesP1Recipient ]----------------------------
//
//
//  Description:
//
//  Parameters:
//
//  Returns:
//
//  History:
//      2/17/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesP1Recipient(
                                      IMailMsgProperties *pIMailMsgProperties)
{
    BOOL fStrCmp = FALSE;

    if (pIMailMsgProperties && m_szMessageRecipient)
    {
        fStrCmp = fQueueAdminIsP1Recip(pIMailMsgProperties);
    }
    else if (!pIMailMsgProperties && !m_szMessageRecipient)
        fStrCmp = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fStrCmp = !fStrCmp;

    return fStrCmp;
}

//---[ CAQAdminMessageFilter::fMatchesSize ]-----------------------------------
//
//
//  Description:
//      Used to check if the message size matches the filter
//  Parameters:
//      dwSize      Size of message to check
//  Returns:
//      TRUE if matches filter
//  History:
//      12/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesSize(DWORD dwSize)
{
    BOOL fMatch = FALSE;
    if (!(AQ_MSG_FILTER_LARGER_THAN & m_dwFilterFlags))
        fMatch = TRUE;
    else if (dwSize > m_dwThresholdSize)
        fMatch = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fMatch = !fMatch;

    return fMatch;
}

//---[ CAQAdminMessageFilter::fMatchesTime ]-----------------------------------
//
//
//  Description:
//      Determines if the recieved time of this message matches the filter.
//  Parameters:
//      pftTime     Pointer to filetime structure.
//  Returns:
//      TRUE on success
//  History:
//      12/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesTime(FILETIME *pftTime)
{
    BOOL fMatch = FALSE;

    if (!(AQ_MSG_FILTER_OLDER_THAN & m_dwFilterFlags))
        fMatch = TRUE;
    else if (0 > CompareFileTime(pftTime, &m_ftThresholdTime))
        fMatch = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fMatch = !fMatch;

    return fMatch;
}

//---[ CAQAdminMessageFilter::fMatchesMailMsgSender ]--------------------------
//
//
//  Description:
//      Checks to see if this filter matches the given mailmsg
//  Parameters:
//      pIMailMsgProperties     Mailmsg pointer to check
//  Returns:
//      TRUE if it matches the filter
//      FALSE otherwise
//  History:
//      3/16/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesMailMsgSender(IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQAdminMessageFilter::fMatchesMailMsgSender");
    HRESULT hr = S_OK;
    BOOL    fMatch = FALSE;
    LPSTR   szSender = NULL;
    DWORD   cbSender = 0;
    DWORD   iSenderAddressType = 0;

    _ASSERT(pIMailMsgProperties);

    if (AQ_MSG_FILTER_SENDER & m_dwFilterFlags)
    {
        hr = HrQueueAdminGetStringProp(pIMailMsgProperties, IMMPID_MP_RFC822_FROM_ADDRESS,
                                       &szSender);

        if (FAILED(hr))
            szSender = NULL;

        fMatch = fMatchesSender(szSender);

        //
        //  Always check P1 if P2 does not match
        //
        if (!fMatch)
        {
            if (szSender)
            {
                QueueAdminFree(szSender);
                szSender = NULL;
            }

            hr = HrQueueAdminGetP1Sender(pIMailMsgProperties, &szSender,
                                         &cbSender, &iSenderAddressType,
                                         m_dwSenderAddressType,
                                         m_fSenderAddressTypeSpecified);

            if (FAILED(hr))
                szSender = NULL;
            else
            {
                DebugTrace((LPARAM) this,
                    "QAPI: Found P1 sender address of type %i:%s",
                    iSenderAddressType,
                    szSender);
            }

            fMatch = fMatchesSender(szSender);

        }

        if (!fMatch)
            goto Exit;
    }

  Exit:
    if (szSender)
        QueueAdminFree(szSender);

    TraceFunctLeave();
    return fMatch;
}

//---[ CAQAdminMessageFilter::fMatchesMailMsgRecipient ]-----------------------
//
//
//  Description:
//      Checks to see if this filter matches the given mailmsg recipient
//  Parameters:
//      pIMailMsgProperties     Mailmsg pointer to check
//  Returns:
//      TRUE if it matches the filter
//      FALSE otherwise
//  History:
//      3/16/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesMailMsgRecipient(IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQAdminMessageFilter::fMatchesMailMsgRecipient");
    HRESULT hr = S_OK;
    LPSTR   szRecip = NULL;
    BOOL    fMatch = FALSE;

    _ASSERT(pIMailMsgProperties);

    if (AQ_MSG_FILTER_RECIPIENT & m_dwFilterFlags)
    {
        //Check To, CC, and BCC recipients (if present)
        hr = HrQueueAdminGetStringProp(pIMailMsgProperties,
                    IMMPID_MP_RFC822_TO_ADDRESS, &szRecip);

        if (SUCCEEDED(hr) && szRecip)
        {
            fMatch = fMatchesRecipient(szRecip);
            QueueAdminFree(szRecip);
            szRecip = NULL;
        }

        _ASSERT(szRecip == NULL);

        //Check CC recip props if no match was found
        if (!fMatch)
        {
            hr = HrQueueAdminGetStringProp(pIMailMsgProperties,
                    IMMPID_MP_RFC822_CC_ADDRESS, &szRecip);
            if (SUCCEEDED(hr) && szRecip)
            {
                fMatch = fMatchesRecipient(szRecip);
                QueueAdminFree(szRecip);
                szRecip = NULL;
            }
        }

        _ASSERT(szRecip == NULL);

        //Check BCC recip props if no match was found
        if (!fMatch)
        {
            hr = HrQueueAdminGetStringProp(pIMailMsgProperties,
                    IMMPID_MP_RFC822_BCC_ADDRESS, &szRecip);
            if (SUCCEEDED(hr) && szRecip)
            {
                fMatch = fMatchesRecipient(szRecip);
                QueueAdminFree(szRecip);
                szRecip = NULL;
            }
        }

        _ASSERT(szRecip == NULL);

        //Check P1 recips if no P2 match
        if (!fMatch)
            fMatch = fMatchesP1Recipient(pIMailMsgProperties);
    }

    _ASSERT(szRecip == NULL);
    TraceFunctLeave();
    return fMatch;
}

//---[ CAQSvrInst::ApplyActionToLinks ]----------------------------------------
//
//
//  Description:
//      Used to start or stop all outgoing connections on the links.
//  Parameters:
//      laAction - describes what action to take on the links.
//                  LA_FREEZE     - Stop all outbound connections
//                  LA_THAW       - Restart after a previous LA_STOP
//                  LA_INTERNAL   - checks state of links
//  Returns:
//      S_OK on success
//      S_FALSE on LA_INTERNAL and if links are frozen
//  History:
//      11/30/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ApplyActionToLinks(LINK_ACTION laAction)
{
    TraceFunctEnter("CAQSvrInst::ApplyActionToLinks");
    HRESULT hr = S_OK;
    if (fTryShutdownLock())
    {
        if (m_pConnMgr)
        {
            switch(laAction)
            {
                case LA_FREEZE:
                    m_pConnMgr->QueueAdminStopConnections();
                    break;
                case LA_THAW:
                    m_pConnMgr->QueueAdminStartConnections();
                    break;
                case LA_INTERNAL: //use to query state
                    if (m_pConnMgr->fConnectionsStoppedByAdmin())
                        hr = S_FALSE;
                    break;
                default:
                    _ASSERT(0 && "Undefined LinkAction");
                    hr = E_INVALIDARG;
            }
        }
        ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::ApplyActionToMessages ]-------------------------------------
//
//
//  Description:
//      Applies a specified action to the set of messages described by the
//      queueid and message filter
//  Parameters:
//      IN     pqlQueueLinkId   Struct that identifies Queue/Link of interest
//      IN     pmfMessageFilter Struct that describes the messages of interest
//      IN     maMessageAction  Action to take on message
//                  MA_DELETE           Delete and NDR message
//                  MA_DELETE_SILENT    Delete message without NDRing
//                  MA_FREEZE_GLOBAL    "Freeze" message and prevent delivery
//                  MA_THAW_GLOBAL      "Thaw" a previously frozen message
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//  History:
//      11/30/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ApplyActionToMessages(QUEUELINK_ID    *pqlQueueLinkId,
                                          MESSAGE_FILTER  *pmfMessageFilter,
                                          MESSAGE_ACTION  maMessageAction,
                                          DWORD           *pcMsgs)
{
    TraceFunctEnter("CAQSvrInst::ApplyActionToMessages");
    HRESULT hr = S_OK;
    IQueueAdminQueue *pIQueueAdminQueue = NULL;
    IQueueAdminLink *pIQueueAdminLink = NULL;
    IQueueAdminAction *pIQueueAdminAction = NULL;
    IQueueAdminMessageFilter *pIQueueAdminMessageFilter = NULL;
    CAQAdminMessageFilter *paqmf = new CAQAdminMessageFilter();

    if (!paqmf)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!pmfMessageFilter || !pcMsgs ||
        !fCheckCurrentVersion(pmfMessageFilter->dwVersion))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }


    paqmf->InitFromMsgFilter(pmfMessageFilter);
    paqmf->SetMessageAction(maMessageAction);

    hr = paqmf->QueryInterface(IID_IQueueAdminMessageFilter,
                       (void **) &pIQueueAdminMessageFilter);

    _ASSERT(SUCCEEDED(hr) && "QI for IID_IQueueAdminMessageFilter failed!!!");
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminMessageFilter);

    if (QLT_NONE == pqlQueueLinkId->qltType)
    {
        //This is a global action.. iterate over all queues
        QueueAdminDMTIteratorContext aqdntc;
        aqdntc.m_pfn = QueueAdminApplyActionToMessages;
        aqdntc.m_paqmf = paqmf;
        aqdntc.m_pIQueueAdminMessageFilter = pIQueueAdminMessageFilter;

        hr = m_dmt.HrIterateOverSubDomains(NULL,
                    IterateDMTAndApplyQueueAdminFunction, &aqdntc);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            {
                hr = S_OK;
                *pcMsgs = 0;
            }
            goto Exit;
        }
    }
    else if (QLT_LINK == pqlQueueLinkId->qltType)
    {
        //Apply action to link
        hr = HrLinkFromLinkID(pqlQueueLinkId, &pIQueueAdminLink);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            {
                hr = S_OK;
                *pcMsgs = 0;
            }
            goto Exit;
        }

        //Query Interface for IQueueAdminAction
        hr = pIQueueAdminLink->QueryInterface(IID_IQueueAdminAction,
                                  (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI failed for LMQ->IQueueAdminAction");
        if (FAILED(hr))
            goto Exit;

        hr = pIQueueAdminAction->HrApplyQueueAdminFunction(
                                        pIQueueAdminMessageFilter);
        if (FAILED(hr))
            goto Exit;

    }
    else if (QLT_QUEUE == pqlQueueLinkId->qltType)
    {
        //Apply action to queue
        hr = HrQueueFromQueueID(pqlQueueLinkId, &pIQueueAdminQueue);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            {
                hr = S_OK;
                *pcMsgs = 0;
            }
            goto Exit;
        }

        _ASSERT(pIQueueAdminQueue);

        //Query Interface for IQueueAdminAction
        hr = pIQueueAdminQueue->QueryInterface(IID_IQueueAdminAction,
                                  (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI failed for DMQ->IQueueAdminAction");
        if (FAILED(hr))
            goto Exit;

        hr = pIQueueAdminAction->HrApplyQueueAdminFunction(
                                        pIQueueAdminMessageFilter);

        if (FAILED(hr))
            goto Exit;

    }
    else
    {
        //Bogus parameter
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pcMsgs = paqmf->cMessagesFound();
  Exit:

    if (paqmf)
        paqmf->Release();

    if (pIQueueAdminMessageFilter)
        pIQueueAdminMessageFilter->Release();

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetQueueInfo ]----------------------------------------------
//
//
//  Description:
//      Returns the relevant info for the specified queue
//  Parameters:
//      IN     pqlQueueId       Struct that identifies Queue of interest
//      IN OUT pqiQueueInfo     Struct to dump info into
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//  History:
//      11/30/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to use IQueueAdminQueue interface
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::GetQueueInfo(QUEUELINK_ID    *pqlQueueId,
                                 QUEUE_INFO      *pqiQueueInfo)
{
    TraceFunctEnter("CAQSvrInst::GetQueueInfo");
    HRESULT hr = S_OK;
    IQueueAdminQueue *pIQueueAdminQueue = NULL;
    DWORD   dwMsgType = 0;

    _ASSERT(pqlQueueId);
    _ASSERT(pqiQueueInfo);
    _ASSERT(pqlQueueId->szName);

    if (!pqiQueueInfo || !pqlQueueId ||
        (QLT_QUEUE != pqlQueueId->qltType) || !pqlQueueId->szName ||
        !fCheckCurrentVersion(pqiQueueInfo->dwVersion))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = HrQueueFromQueueID(pqlQueueId, &pIQueueAdminQueue);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminQueue);
    hr = pIQueueAdminQueue->HrGetQueueInfo(pqiQueueInfo);

    SanitizeCountAndVolume(&(pqiQueueInfo->cMessages),
                           &(pqiQueueInfo->cbQueueVolume));
  Exit:
    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetLinkInfo ]-----------------------------------------------
//
//
//  Description:
//      Returns the relevant info for the specified link
//  Parameters:
//      IN     pqlLinkId        Struct that identifies link of interest
//      IN OUT pqiLinkInfo      Struct to dump info into
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//      E_INVALIDARG if bogus properties are submitted.
//  History:
//      11/30/98 - MikeSwa Created
//      7/1/99 - MikeSwa Added LinkDiagnostic
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetLinkInfo(QUEUELINK_ID    *pqlLinkId,
                                     LINK_INFO       *pliLinkInfo,
                                     HRESULT         *phrLinkDiagnostic)
{
    TraceFunctEnter("CAQSvrInst::GetLinkInfo");
    HRESULT hr = S_OK;
    IQueueAdminLink *pIQueueAdminLink = NULL;

    if (!pliLinkInfo || !pqlLinkId || !phrLinkDiagnostic)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = HrLinkFromLinkID(pqlLinkId, &pIQueueAdminLink);
    if (FAILED(hr))
        goto Exit;

    hr = pIQueueAdminLink->HrGetLinkInfo(pliLinkInfo, phrLinkDiagnostic);

    SanitizeCountAndVolume(&(pliLinkInfo->cMessages),
                           &(pliLinkInfo->cbLinkVolume));
  Exit:
    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::SetLinkState ]-----------------------------------------------
//
//
//  Description:
//      Used to mark a link as stopped/started by admin
//  Parameters:
//      IN     pqlLinkId       Struct that identifies link of interest
//      IN     la              describes action for link
//  Returns:
//      S_OK on success
//      E_INVALIDARG    if action is not supported
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//  History:
//      11/30/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to use IQueueAdminLink
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SetLinkState(QUEUELINK_ID    *pqlLinkId,
                                      LINK_ACTION     la)
{
    TraceFunctEnter("CAQSvrInst::SetLinkInfo");
    HRESULT hr = S_OK;
    IQueueAdminLink *pIQueueAdminLink = NULL;

    if (!pqlLinkId)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = HrLinkFromLinkID(pqlLinkId, &pIQueueAdminLink);
    if (FAILED(hr))
        goto Exit;

    hr = pIQueueAdminLink->HrApplyActionToLink(la);
    if (FAILED(hr))
        goto Exit;

    //Try kicking the connection manager
    if (fTryShutdownLock())
    {
        if (m_pConnMgr)
            m_pConnMgr->KickConnections();
        ShutdownUnlock();
    }

  Exit:
    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetLinkIDs ]------------------------------------------------
//
//
//  Description:
//      Returns a list all the link IDs on this virtual server
//  Parameters:
//      IN OUT pcLinks      Number of links found (sizeof array on IN)
//                          If value is 0, then returns total #
//      IN OUT rgLinks      Array of QUEUELINK_ID structs
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//      E_INVALIDARG for bad combinations of arguments
//  History:
//      11/30/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetLinkIDs(DWORD           *pcLinks,
                                    QUEUELINK_ID    *rgLinks)
{
    TraceFunctEnter("CAQSvrInst::GetLinkIDs");
    HRESULT hr = S_OK;
    QueueAdminDMTIteratorContext aqdmtc;
    CLinkMsgQueue *plmqLocal = NULL;
    CLinkMsgQueue *plmqCurrentlyUnreachable = NULL;
    CMailMsgAdminLink *pmmaqPreCategorized = NULL;
    CMailMsgAdminLink *pmmaqPreRouting = NULL;
    CMailMsgAdminLink *pmmaqPreSubmission = NULL;

    if (!pcLinks || (*pcLinks && !rgLinks))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!*pcLinks)
    {
        //Return total number of links if they request it
        //number of links +3 for precat and prerouting
        //note that this may be one more than the number
        //of links actually returned in a subsequent call
        //since currently  unreachable may or may not have
        //queues on it and we do not return it if it does
        //not have queues.

        *pcLinks = m_cCurrentRemoteNextHops+3;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    aqdmtc.m_cItemsToReturn = *pcLinks;
    aqdmtc.m_rgLinkIDs = rgLinks;
    aqdmtc.m_pCurrentLinkID = rgLinks;
    aqdmtc.m_cItemsFound = 0;

    //Get local Link
    plmqLocal = m_dmt.plmqGetLocalLink();
    if (plmqLocal)
    {
        hr = plmqLocal->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
        if (SUCCEEDED(hr))
        {
            aqdmtc.m_pCurrentLinkID++;
            aqdmtc.m_cItemsFound++;
        }
        plmqLocal->Release();
    }

    //Get currently unreachable link.
    plmqCurrentlyUnreachable = m_dmt.plmqGetCurrentlyUnreachable();
    if (plmqCurrentlyUnreachable)
    {
        //return this link only if there are queues in it
        if (plmqCurrentlyUnreachable->cGetNumQueues() > 0)
        {
            hr = plmqCurrentlyUnreachable->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
            if (SUCCEEDED(hr))
            {
                aqdmtc.m_pCurrentLinkID++;
                aqdmtc.m_cItemsFound++;
            }
        }
        plmqCurrentlyUnreachable->Release();
    }

    //Get presubmit queue
    pmmaqPreSubmission = m_dmt.pmmaqGetPreSubmission();
    if (pmmaqPreSubmission)
    {
        hr = pmmaqPreSubmission->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
        if (SUCCEEDED(hr))
        {
            aqdmtc.m_pCurrentLinkID++;
            aqdmtc.m_cItemsFound++;
        }
        pmmaqPreSubmission->Release();
    }

    //Get precat queue
    pmmaqPreCategorized = m_dmt.pmmaqGetPreCategorized();
    if (pmmaqPreCategorized)
    {
        hr = pmmaqPreCategorized->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
        if (SUCCEEDED(hr))
        {
            aqdmtc.m_pCurrentLinkID++;
            aqdmtc.m_cItemsFound++;
        }
        pmmaqPreCategorized->Release();
    }

    //Get prerouting queue
    pmmaqPreRouting = m_dmt.pmmaqGetPreRouting();
    if (pmmaqPreRouting)
    {
        hr = pmmaqPreRouting->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
        if (SUCCEEDED(hr))
        {
            aqdmtc.m_pCurrentLinkID++;
            aqdmtc.m_cItemsFound++;
        }
        pmmaqPreRouting->Release();
    }

    //Get links for remote domains.
    hr = m_dmt.HrIterateOverSubDomains(NULL, IterateDMTAndGetLinkIDs,
                                       &aqdmtc);

    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
        {
            //If the call to get remote domains fails with ERROR_NO_SUCH_DOMAIN
            //we must return only the special links --- local, currently unreachable,
            //precat and prerouting.

            hr = S_OK;
            *pcLinks = aqdmtc.m_cItemsFound;
        }
        goto Exit;
    }

    hr = aqdmtc.m_hrResult;

    if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        *pcLinks = m_cCurrentRemoteNextHops+2;  //+2 for precat, prerouting which are not
    else                                        //counted in m_cCurrentRemoteNextHops.
        *pcLinks = aqdmtc.m_cItemsFound;

  Exit:

    //make sure we don't return ERROR_INSUFFICIENT_BUFFER if there are no links
    if ((HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr) && !*pcLinks)
        hr = S_OK;

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetQueueIDs ]-----------------------------------------------
//
//
//  Description:
//      Gets all the queue (DMQ) IDs associated with a given link
//  Parameters:
//      IN     pqlLinkId    ID of link to get queues for
//      IN OUT pcQueues     Sizeof array/ number of queues found
//      IN OUT rgQueues     Array to dump queue info into
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//      E_INVALIDARG for bad combinations of arguments
//  History:
//      11/30/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetQueueIDs(QUEUELINK_ID    *pqlLinkId,
                                     DWORD           *pcQueues,
                                     QUEUELINK_ID    *rgQueues)
{
    TraceFunctEnter("CAQSvrInst::GetQueueIDs");
    HRESULT hr = S_OK;
    IQueueAdminLink *pIQueueAdminLink = NULL;
    DWORD   cQueues = 0;

    //Verify args
    if (!pqlLinkId || !pcQueues || (*pcQueues && !rgQueues))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Verify QUEUELINK_ID identifying the link of interest
    if (!pqlLinkId->szName || (pqlLinkId->qltType != QLT_LINK))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = HrLinkFromLinkID(pqlLinkId, &pIQueueAdminLink);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminLink);
    hr = pIQueueAdminLink->HrGetNumQueues(&cQueues);
    if (FAILED(hr))
        goto Exit;

    if ((cQueues > *pcQueues) || (!*pcQueues))
    {
        *pcQueues = cQueues;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    hr = pIQueueAdminLink->HrGetQueueIDs(pcQueues, rgQueues);
    if (FAILED(hr))
        goto Exit;

  Exit:
    //make sure we don't return ERROR_INSUFFICIENT_BUFFER if there are no queues
    if ((HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr) && !*pcQueues)
        hr = S_OK;

    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetMessageProperties ]--------------------------------------
//
//
//  Description:
//      Gets the message info for messages described by the filter
//  Parameters:
//      IN     pqlQueueLinkId           Struct that identifies Queue/Link of interest
//      IN     pmfMessageEnumFilter     Filter that describes messages of interest
//      IN OUT pcMsgs                   sizeof array / number of messages found
//      IN OUT rgMsgs                   array of message info structures
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//      E_INVALIDARG if bogus args are passed in.
//  History:
//      11/30/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to use IQueueAdmin* interface
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetMessageProperties(QUEUELINK_ID        *pqlQueueLinkId,
                                         MESSAGE_ENUM_FILTER *pmfMessageEnumFilter,
                                         DWORD               *pcMsgs,
                                         MESSAGE_INFO        *rgMsgs)
{
    TraceFunctEnter("CAQSvrInst::GetMessageProperties");
    HRESULT hr = S_OK;
    IQueueAdminQueue *pIQueueAdminQueue = NULL;
    IQueueAdminAction  *pIQueueAdminAction = NULL;
    IQueueAdminMessageFilter *pIQueueAdminMessageFilter = NULL;
    MESSAGE_INFO  *pMsgInfo = rgMsgs;
    DWORD          i = 0;
    CAQAdminMessageFilter *paqmf = new CAQAdminMessageFilter();

    if (!paqmf)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Do some parameter checking
    if (!pqlQueueLinkId || !pmfMessageEnumFilter || !pcMsgs ||
        !pqlQueueLinkId->szName ||
        !fCheckCurrentVersion(pmfMessageEnumFilter->dwVersion))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (*pcMsgs && !rgMsgs)
    {
        //If we are specifying messages, we should have space to return data
        hr = E_INVALIDARG;
        goto Exit;
    }

    _ASSERT(QLT_QUEUE == pqlQueueLinkId->qltType);
    if (QLT_QUEUE != pqlQueueLinkId->qltType)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    paqmf->InitFromMsgEnumFilter(pmfMessageEnumFilter);
    paqmf->SetSearchContext(*pcMsgs, rgMsgs);

    hr = HrQueueFromQueueID(pqlQueueLinkId, &pIQueueAdminQueue);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminQueue);
    hr = pIQueueAdminQueue->QueryInterface(IID_IQueueAdminAction,
                             (void **) &pIQueueAdminAction);
    _ASSERT(SUCCEEDED(hr) && "QI for IID_IQueueAdminAction failed!!!");
    if (FAILED(hr))
        goto Exit;

    hr = paqmf->QueryInterface(IID_IQueueAdminMessageFilter,
                             (void **) &pIQueueAdminMessageFilter);

    _ASSERT(SUCCEEDED(hr) && "QI for IID_IQueueAdminMessageFilter failed!!!");
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminAction);
    hr = pIQueueAdminAction->HrApplyQueueAdminFunction(
                                    pIQueueAdminMessageFilter);

    if (FAILED(hr))
        goto Exit;

    if (!*pcMsgs && paqmf->cMessagesFound())
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    *pcMsgs = paqmf->cMessagesFound();

  Exit:

    if (paqmf)
        paqmf->Release();

    if (pIQueueAdminMessageFilter)
        pIQueueAdminMessageFilter->Release();

    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::QuerySupportedActions ]-------------------------------------
//
//
//  Description:
//      Returns the supported actions and filters for a given queue
//  Parameters:
//      IN  pqlQueueLinkId          The queue/link we are interested in
//      OUT pdwSupportedActions     The MESSAGE_ACTION flags supported
//      OUT pdwSupportedFilterFlags The supported filter flags
//  Returns:
//      S_OK on success
//  History:
//      6/15/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::QuerySupportedActions(
                                QUEUELINK_ID        *pqlQueueLinkId,
                                DWORD               *pdwSupportedActions,
                                DWORD               *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::QuerySupportedActions");
    HRESULT hr = S_OK;
    IQueueAdminAction *pIQueueAdminAction = NULL;
    IQueueAdminQueue *pIQueueAdminQueue = NULL;
    IQueueAdminLink *pIQueueAdminLink = NULL;

    _ASSERT(pqlQueueLinkId);
    _ASSERT(pdwSupportedActions);
    _ASSERT(pdwSupportedFilterFlags);

    if (QLT_LINK == pqlQueueLinkId->qltType)
    {
        //Apply action to link
        hr = HrLinkFromLinkID(pqlQueueLinkId, &pIQueueAdminLink);
        if (FAILED(hr))
            goto Exit;

        //Query Interface for IQueueAdminAction
        hr = pIQueueAdminLink->QueryInterface(IID_IQueueAdminAction,
                                  (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI failed for LMQ->IQueueAdminAction");
        if (FAILED(hr))
            goto Exit;

    }
    else if (QLT_QUEUE == pqlQueueLinkId->qltType)
    {
        //Apply action to queue
        hr = HrQueueFromQueueID(pqlQueueLinkId, &pIQueueAdminQueue);
        if (FAILED(hr))
            goto Exit;

        _ASSERT(pIQueueAdminQueue);

        //Query Interface for IQueueAdminAction
        hr = pIQueueAdminQueue->QueryInterface(IID_IQueueAdminAction,
                                  (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI failed for DMQ->IQueueAdminAction");
        if (FAILED(hr))
            goto Exit;

    }

    //
    //  If we do not find an action for this ID, then return the default
    //  implementation (most likely is a server level search)...
    //  otherwise ask our action interface what is supported
    //
    if (!pIQueueAdminAction)
    {
        hr = QueryDefaultSupportedActions(pdwSupportedActions,
                                          pdwSupportedFilterFlags);
    }
    else
    {
        hr = pIQueueAdminAction->QuerySupportedActions(
                                        pdwSupportedActions,
                                        pdwSupportedFilterFlags);
    }

  Exit:
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            hr = S_OK;  //eat this error

        *pdwSupportedActions = 0;
        *pdwSupportedFilterFlags = 0;
    }

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();

    TraceFunctLeave();
    return hr;
}

//---[ QueryDefaultSupportedActions ]------------------------------------------
//
//
//  Description:
//      Returns the default supported actions.
//  Parameters:
//      OUT pdwSupportedActions     The MESSAGE_ACTION flags supported
//      OUT pdwSupportedFilterFlags The supported filter flags
//  Returns:
//      S_OK always
//  History:
//      1/27/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT QueryDefaultSupportedActions(DWORD  *pdwSupportedActions,
                                     DWORD  *pdwSupportedFilterFlags)
{
    //Currently all of a single type of queue supports the same actions and
    //filters.  The only special cases are the precat and prerouting queue
    *pdwSupportedActions =  MA_DELETE |\
                            MA_DELETE_SILENT |\
                            MA_FREEZE_GLOBAL |\
            		        MA_THAW_GLOBAL |\
                            MA_COUNT;

    *pdwSupportedFilterFlags =  MF_MESSAGEID |\
                                MF_SENDER |\
                                MF_RECIPIENT |\
                                MF_SIZE |\
                                MF_TIME |\
                                MF_FROZEN |\
                                MF_FAILED |\
                                MF_ALL |\
                                MF_INVERTSENSE;

    return S_OK;
}

//---[ CAQSvrInst::HrGetLocalQueueAdminQueue ]---------------------------------
//
//
//  Description:
//      Returns an interface for the local queue.
//  Parameters:
//       ppIQueueAdminQueue     Interface returned
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetLocalQueueAdminQueue(
                                      IQueueAdminQueue **ppIQueueAdminQueue)
{
    return m_asyncqPreLocalDeliveryQueue.QueryInterface(IID_IQueueAdminQueue,
                                            (void **) ppIQueueAdminQueue);
}

//---[ HrQueueAdminGetStringProp ]---------------------------------------------
//
//
//  Description:
//      Wrapper function to handle getting a string property for queue admin
//  Parameters:
//      IN     pIMailMsgProperties  Ptr to IMailMsgProperties interface
//      IN     dwPropID             PropID of interest
//      OUT    pszProp              String allocated for QueueAdmin
//      OUT    pcbProp              Size out param (including
//                                      terminating NULL(s)).
//  Returns:
//      S_OK on success (even if property is not found)
//      E_OUTOFMEMORY if allocation fails.
//  History:
//      12/8/98 - MikeSwa Created
//      2/9/99  - MikeSwa Added string size OUT param & changed code to use
//                buffer size returned by GetProperty.
//
//-----------------------------------------------------------------------------
HRESULT HrQueueAdminGetStringProp(IMailMsgProperties *pIMailMsgProperties,
                                DWORD dwPropID, LPSTR *pszProp, DWORD *pcbProp)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrQueueAdminGetStringProp");
    BYTE  pbBuffer[4];
    HRESULT hr              = S_OK;
    DWORD   cbIntBuffSize   = sizeof(pbBuffer);
    LPSTR   pszIntBuff      = NULL;

    _ASSERT(pszProp);

    // Init the OUT params
    if(pcbProp)
        *pcbProp = 0;
    *pszProp = NULL;

    //Use GetProperty instead of GetStringA, because it returns the size as well
    hr = pIMailMsgProperties->GetProperty(dwPropID, sizeof(pbBuffer),
                                          &cbIntBuffSize, pbBuffer);
    if (FAILED(hr))
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
        {
            hr = S_OK;
            goto Exit;
        }
        else if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {
            //Our stack buffer is not big enough (which we expected)...
            //we will have to do a get property directory into out return buffer
            hr = S_OK;
        }
        else
        {
            goto Exit;
        }
    }

    //Allocate enough space for our string plus an extra terminating \0, so
    //we can munge it into a multivalue prop if needed.
    pszIntBuff = (LPSTR) pvQueueAdminAlloc(cbIntBuffSize+sizeof(CHAR));
    if (!pszIntBuff)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Now get the property with our property-sized buffer
    hr = pIMailMsgProperties->GetProperty(dwPropID, cbIntBuffSize, &cbIntBuffSize,
                                        (BYTE *) pszIntBuff);
    if (FAILED(hr))
        goto Exit;

    //Set extra terminating NULL.
    pszIntBuff[cbIntBuffSize/sizeof(CHAR)] = '\0';

    // Set the OUT params
    if(pcbProp)
        *pcbProp = cbIntBuffSize + sizeof(CHAR);
    *pszProp = pszIntBuff;
    pszIntBuff = NULL;

  Exit:
    if (pszIntBuff)
        QueueAdminFree(pszIntBuff);

    TraceFunctLeave();
    return hr;
}

//---[ HrQueueAdminGetUnicodeStringProp ]--------------------------------------
//
//
//  Description:
//      Wrapper function to handle getting a string property for queue admin
//  Parameters:
//      IN     pIMailMsgProperties  Ptr to IMailMsgProperties interface
//      IN     dwPropID             PropID of interest
//      OUT    pwszProp             UNICODE String allocated for QueueAdmin
//      OUT    pcbProp              Size out param (including
//                                      terminating NULL(s)).
//  Returns:
//      S_OK on success (even if property is not found)
//      E_OUTOFMEMORY if allocation fails.
//  History:
//      12/8/98 - MikeSwa Created
//      2/9/99  - MikeSwa Added string size OUT param & changed code to use
//                buffer size returned by GetProperty.
//
//-----------------------------------------------------------------------------
HRESULT HrQueueAdminGetUnicodeStringProp(
                             IMailMsgProperties *pIMailMsgProperties,
                             DWORD dwPropID, LPWSTR *pwszProp, DWORD *pcbProp)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrQueueAdminGetUnicodeStringProp");
    HRESULT hr = S_OK;
    LPSTR   szProp = NULL;

    _ASSERT(pwszProp);
    *pwszProp = NULL;

    hr = HrQueueAdminGetStringProp(pIMailMsgProperties, dwPropID, &szProp,
                                   pcbProp);
    if (SUCCEEDED(hr) && szProp)
    {
        BOOL fUTF8 = (dwPropID == IMMPID_MP_RFC822_MSG_SUBJECT);
        *pwszProp = wszQueueAdminConvertToUnicode(szProp,
                                                  pcbProp ? *pcbProp : 0,
                                                  fUTF8);
        QueueAdminFree(szProp);
        if (pcbProp)
            *pcbProp *= sizeof(WCHAR)/sizeof(CHAR);
    }

    TraceFunctLeave();
    return hr;
}

//---[ cGetNumRecipsFromRFC822 ]-----------------------------------------------
//
//
//  Description:
//      Utility function that extracts the number of recipients from a RFC822
//      header.  Input values should be as returned by HrQueueAdminGetStringProp
//  Parameters:
//      IN  szHeader            String of header to parse (can be NULL)
//      IN  cbHeader            Size of string header to parse
//  Returns:
//      Number of recipients found in header
//  History:
//      12/8/98 - MikeSwa Created
//      2/9/99  - MikeSwa Modified to handle all RFC822 address formats
//
//-----------------------------------------------------------------------------
DWORD cQueueAdminGetNumRecipsFromRFC822(LPSTR szHeader, DWORD cbHeader)
{
    //Call through to handy smtpaddr library
    return CAddr::GetRFC822AddressCount(szHeader);
}


//---[ QueueAdminGetRecipListFromP1 ]------------------------------------------
//
//
//  Description:
//      Creates a list of recipients from the P1.
//
//  Parameters:
//      IN     pIMailMsgProperties
//      IN OUT pMsgInfo (modified following)
//                  cEnvRecipients
//                  cbEnvRecipients
//                  mszEnvRecipients
//
//      The mszEnvRecipients field is a multi-string UNICODE buffer containing
//  a NULL-terminated string for each recipient.  The buffer itself is
//  terminated by an additional NULL.  Each recipient string will be formatted
//  in the proxy address style format of 'addr-type ":" address'.  The
//  addr-type should match DS proxy type (i.e. "SMTP" for SMTP).  The address
//  should be returned in it's native format.
//
//  Returns:
//      -
//  History:
//      2/17/99 - MikeSwa Created
//      6/10/99 - MikeSwa Modified - P1 recipeints are now always reported
//          as separate fields in the MESSAGE_INFO structure.
//      2/19/2001 - MikeSwa Modified - Added support for address types other
//          than SMTP.
//
//-----------------------------------------------------------------------------
void QueueAdminGetRecipListFromP1(IMailMsgProperties *pIMailMsgProperties,
                                       MESSAGE_INFO *pMsgInfo)
{
    TraceFunctEnterEx((LPARAM) NULL, "QueueAdminGetRecipListFromP1IfNecessary");
    LPWSTR      wszRecipBuffer = NULL;
    LPWSTR      wszPrevPlace = NULL;
    LPWSTR      wszCurrentPlace = NULL;
    LPWSTR      wszTmpBuffer = NULL;
    CHAR        szPropBuffer[QUEUE_ADMIN_MAX_BUFFER_REQUIRED] = "";
    HRESULT     hr = S_OK;
    const WCHAR wszDelimiter[]  = L"";
    DWORD       cbPropSize = 0;
    DWORD       cbSpaceLeft = 0;
    DWORD       cbGrowBuffer = 0;
    DWORD       cWCharsWritten = 0;
    DWORD       cRecips = 0;
    DWORD       iCurrentRecip = 0;
    DWORD       cbBufferSize = sizeof(WCHAR)*QUEUE_ADMIN_MAX_BUFFER_REQUIRED;
    BOOL        fContinueToNextRecip = TRUE;
    DWORD       iCurrentAddressType = 0;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    const DWORD MAX_RECIP_RETURN_BUFFER = (1024*50);
    DWORD       cbPrefixAndDelimiter = 0;


    _ASSERT(pIMailMsgProperties);
    _ASSERT(fVerifyQAPIAddressTypes());

    if (!pMsgInfo || !pIMailMsgProperties)
        return;

    wszRecipBuffer = (LPWSTR) pvQueueAdminAlloc(cbBufferSize);

    //Don't try to write prop if we couldn't allocate
    if (!wszRecipBuffer)
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to alloc %d size buffer", cbBufferSize);
        goto Exit;
    }

    cbSpaceLeft = cbBufferSize;
    wszCurrentPlace = wszRecipBuffer;

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients,
                                            (void **) &pIMailMsgRecipients);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IMailMsgRecipients failed");
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIMailMsgRecipients);
    hr = pIMailMsgRecipients->Count(&cRecips);
    if (FAILED(hr))
        goto Exit;

    if (!cRecips)
        goto Exit;

    //Start string as double-terminated
    wcscpy(wszCurrentPlace, wszDelimiter);

    //Loop over recipients and dump them to string
    for (iCurrentRecip = 0; iCurrentRecip < cRecips; iCurrentRecip++)
    {
        //
        //  Loop over the possible address types
        //
        fContinueToNextRecip = FALSE;
        for (iCurrentAddressType = 0;
             (iCurrentAddressType < g_cQAPIAddressTypes) && !fContinueToNextRecip;
              iCurrentAddressType++)
        {
            //
            //  Unless we specifically know we need to check the next
            //  next prop id, we will default to skipping this recipient
            //
            fContinueToNextRecip = TRUE;

            //
            //  Compute Extra space required per-recipient
            //
            cbPrefixAndDelimiter =
                g_rgcbQAPIAddressTypes[iCurrentAddressType] +
                sizeof(wszDelimiter) -
                sizeof(WCHAR);
            _ASSERT(cbPrefixAndDelimiter);
            DebugTrace((LPARAM) pIMailMsgProperties,
                "Prefix and delimiter size for %S is %d",
                        g_rgwszQAPIAddressTypes[iCurrentAddressType],
                        cbPrefixAndDelimiter);

            cbPropSize = sizeof(szPropBuffer);
            hr = pIMailMsgRecipients->GetProperty(iCurrentRecip,
                        g_rgdwQAPIRecipPropIDs[iCurrentAddressType],
                        sizeof(szPropBuffer), &cbPropSize, (BYTE *) szPropBuffer);

            if (FAILED(hr))
            {
                if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
                {
                    //
                    //  If this recip is larger than
                    //  QUEUE_ADMIN_MAX_BUFFER_REQUIRED
                    //  Go to the next one
                    hr = S_OK;
                    DebugTrace((LPARAM) pIMailMsgProperties,
                        "Message recipient %d (propid %d) larger than %d",
                        iCurrentRecip, g_rgdwQAPIRecipPropIDs[iCurrentAddressType],
                        sizeof(szPropBuffer));
                    continue;
                }
                else if (MAILMSG_E_PROPNOTFOUND == hr)
                {
                    //
                    //  Try the next address type
                    //
                    fContinueToNextRecip = FALSE;
                    continue;
                }
                ErrorTrace((LPARAM) NULL,
                    "pIMailMsgRecipients->GetProperty failed with hr - 0x%08X", hr);
                goto Exit;
            }

            _ASSERT(cbPropSize); //This doesn't make sense.. GetProp should have failed
            if (!cbPropSize)
                continue;

            if ((cbSpaceLeft <= cbPrefixAndDelimiter) ||
                (cbPropSize*sizeof(WCHAR) > cbSpaceLeft - cbPrefixAndDelimiter))
            {
                //We do not have enough space left to process this recip
                //and include the prefix and terminating NULLs

                //
                //  Pick a new size... how many recips have we processed vs.
                //  how many are there
                //
                cbGrowBuffer = (cbBufferSize*(cRecips-iCurrentRecip))/(iCurrentRecip+1);

                DebugTrace((LPARAM) pIMailMsgProperties,
                    "Growbuffer is %d, %d recips of %d - Current Buffers is %d",
                    cbGrowBuffer, iCurrentRecip+1, cRecips, cbBufferSize);

                //
                // Sanity check our size... we want to return a reasonable number of
                // recips, but we don't want to kill the machine with the default
                // enumeration filter
                //
                if (cbBufferSize >= MAX_RECIP_RETURN_BUFFER)
                    goto Exit;

                if (cbBufferSize+cbGrowBuffer >= MAX_RECIP_RETURN_BUFFER)
                    cbGrowBuffer = MAX_RECIP_RETURN_BUFFER-cbBufferSize;

                //
                //  Sanity check minimum size
                //
                if (cbGrowBuffer < (sizeof(WCHAR)*QUEUE_ADMIN_MAX_BUFFER_REQUIRED))
                    cbGrowBuffer = sizeof(WCHAR)*QUEUE_ADMIN_MAX_BUFFER_REQUIRED;

                cbSpaceLeft += cbGrowBuffer;
                cbBufferSize += cbGrowBuffer;


                DebugTrace((LPARAM) pIMailMsgProperties,
                    "Attempting to Grow recip buffer %d to %d", cbGrowBuffer, cbBufferSize);

                wszTmpBuffer = (LPWSTR) pvQueueAdminReAlloc(wszRecipBuffer, cbBufferSize);
                if (!wszTmpBuffer)
                {
                    DebugTrace((LPARAM) pIMailMsgProperties,
                        "Unable to realloc %p to size %d", wszRecipBuffer, cbBufferSize);
                    goto Exit; //bail
                }
                wszCurrentPlace = wszTmpBuffer + (wszCurrentPlace-wszRecipBuffer);
                wszRecipBuffer = wszTmpBuffer;
            }

            //Copy address type prefix
            wcscpy(wszCurrentPlace, g_rgwszQAPIAddressTypes[iCurrentAddressType]);
            wszPrevPlace = wszCurrentPlace;
            wszCurrentPlace += (g_rgcbQAPIAddressTypes[iCurrentAddressType]/sizeof(WCHAR) - 1);

            //We need to convert this to UNICODE in place
            cWCharsWritten = MultiByteToWideChar(CP_ACP,
                            0,
                            szPropBuffer,
                            -1,
                            wszCurrentPlace,
                            (cbSpaceLeft - sizeof(wszDelimiter))/sizeof(WCHAR));

            if (!cWCharsWritten)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                //If this failed because of the buffer size, then my calculations
                //were off.
                ASSERT (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr);
                ErrorTrace((LPARAM) NULL,
                    "MultiByteToWideChar failed with hr - 0x%08X", hr);
                wszCurrentPlace = wszPrevPlace;
                wcscpy(wszCurrentPlace, wszDelimiter); //backout prefix
                continue;
            }

            DebugTrace((LPARAM) pIMailMsgProperties,
                "Adding recip %S to buffer", wszCurrentPlace);

            //Write double terminating NULL
            wszCurrentPlace += cWCharsWritten;

            wcscpy(wszCurrentPlace, wszDelimiter);

            //Set current place to the 2nd terminating NULL
            //If there are no more recips... we are already terminated... if
            //there are, they will overwrite the 2nd terminating NULL.
            _ASSERT(L'\0' == *wszCurrentPlace);
            _ASSERT(L'\0' == *(wszCurrentPlace-1));

            cbSpaceLeft -= (DWORD)((wszCurrentPlace-wszPrevPlace)*sizeof(WCHAR));
        }
    }

  Exit:

    if (FAILED(hr) || !cRecips)
    {
        if (wszRecipBuffer)
            QueueAdminFree(wszRecipBuffer);
    }
    else
    {
        if (pMsgInfo)
        {
            _ASSERT(wszPrevPlace >= wszRecipBuffer);
            pMsgInfo->cEnvRecipients = cRecips;
            pMsgInfo->cbEnvRecipients = (DWORD) ((1+wszCurrentPlace-wszRecipBuffer)*sizeof(WCHAR));
            pMsgInfo->mszEnvRecipients = wszRecipBuffer;
        }
    }

    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    TraceFunctLeave();
}


//---[ fQueueAdminIsP1Recip ]--------------------------------------------------
//
//
//  Description:
//      Determines if a given recipient is a P1 recipient.
//  Parameters:
//      IN  pIMailMsgProperties     Msg to check recips for
//      IN  szRecip                 Recipient to check for
//      IN  iStartAddressType       Address type to start check with
//  Returns:
//      TRUE if the recipient is a P1 recipient for this message
//      FALSE if the recipient is not a P1 recipient for this message
//  History:
//      2/17/99 - MikeSwa Created
//      3/16/2001 - MikeSwa Modified - Made a member of CAQAdminMessageFilter
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fQueueAdminIsP1Recip(
                          IMailMsgProperties *pIMailMsgProperties)
{
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    HRESULT hr = S_OK;
    DWORD   cRecips = 0;
    BOOL    fFound = FALSE;
    LPSTR   szRecipBuffer = NULL;
    DWORD   cbRecipBuffer = 0;
    DWORD   cbProp = 0;
    DWORD   iCurrentRecip = 0;
    DWORD   iCurrentRecipType = 0;
    DWORD   iStartAddressType = m_dwRecipientAddressType;
    DWORD   iEndAddressType = g_cQAPIAddressTypes;
    LPSTR   szRecip = m_szMessageRecipient;

    if (!szRecip || !pIMailMsgProperties)
        goto Exit;

    //
    //  IF we have an address type, then only check one address type
    //
    if (m_fRecipientAddressTypeSpecified && (iStartAddressType < g_cQAPIAddressTypes))
        iEndAddressType = iStartAddressType+1;

    //cleanup leading whitespace from recipient
    while (*szRecip && isspace((UCHAR)*szRecip))
        szRecip++;

    if (!*szRecip)
        goto Exit;

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients,
                                            (void **) &pIMailMsgRecipients);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IMailMsgRecipients failed");
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIMailMsgRecipients);
    hr = pIMailMsgRecipients->Count(&cRecips);
    if (FAILED(hr))
        goto Exit;

    if (!cRecips)
        goto Exit;

    cbRecipBuffer = strlen(szRecip)*sizeof(CHAR) + sizeof(CHAR);
    szRecipBuffer = (LPSTR) pvMalloc(cbRecipBuffer);

    if (!szRecipBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Loop over recips and look for a match... this will be slooow
    //(see comment above).
    for (iCurrentRecip = 0; iCurrentRecip < cRecips; iCurrentRecip++)
    {
        //
        //  Loop over all the possible recipient types
        //
        for (iCurrentRecipType = iStartAddressType ;
             iCurrentRecipType < iEndAddressType;
             iCurrentRecipType++)
        {
            hr = pIMailMsgRecipients->GetProperty(iCurrentRecip,
                        g_rgdwQAPIRecipPropIDs[iCurrentRecipType],
                        cbRecipBuffer, &cbProp, (BYTE *) szRecipBuffer);

            if (FAILED(hr))
                continue;

            if (!lstrcmpi(szRecipBuffer, szRecip))
            {
                fFound = TRUE;
                goto Exit;
            }

            //
            //  If we found an address of this type... don't bother checking the others
            //
            break;
        }
    }

  Exit:
    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    if (szRecipBuffer)
        FreePv(szRecipBuffer);

    return fFound;
}


//---[ wszQueueAdminConvertToUnicode ]-----------------------------------------
//
//
//  Description:
//      Allocates and "upgrades" string to UNICODE.  New String is Allocated
//      with pvQueueAdminAlloc, so it can be passed out the queue admin
//      interface.
//  Parameters:
//      szSrc     Source string
//      cSrc      Strlen of sources string
//  Returns:
//      Pointer to UNICODE version of string (if successful)
//  History:
//      6/7/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
LPWSTR wszQueueAdminConvertToUnicode(LPSTR szSrc, DWORD cSrc, BOOL fUTF8)
{
    LPWSTR  wszDest = NULL;
    if (!szSrc)
        return NULL;

    if (!cSrc)
        cSrc = strlen(szSrc);
    else
    {
        //if a count of bytes is provided... it should be NULL terminated
        _ASSERT(strlen(szSrc) <= cSrc);
    }


    wszDest = (LPWSTR) pvQueueAdminAlloc((cSrc+1)*sizeof(WCHAR));
    if (!wszDest)
        return NULL;

    MultiByteToWideChar(fUTF8 ? CP_UTF8 : CP_ACP,
                        0,
                        szSrc,
                        -1,
                        wszDest,
                        cSrc+1);

    return wszDest;
}

//---[ fBiStrcmpi ]------------------------------------------------------------
//
//
//  Description:
//      Compares UNICODE to ASCII
//  Parameters:
//      IN  sz      ASCII string to compare
//      IN  wsz
//  Returns:
//      TRUE if strings match
//      FALSE otherwise
//  History:
//      6/7/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fBiStrcmpi(LPSTR sz, LPWSTR wsz)
{
    CHAR ch;
    if (!sz && !wsz)
        return TRUE;

    if (!sz || !wsz)
        return FALSE;

    //Loop through strings.. conver UNICODE chars to ASCII and compare
    while (*sz && *wsz)
    {
        wctomb(&ch, *wsz);
        if (ch != *sz)
            return FALSE;
        sz++;
        wsz++;
    }

    return TRUE; //they matched
}


//---[ szUnicodeToAscii ]------------------------------------------------------
//
//
//  Description:
//      Convert QueueAdmin parameter to UNICODE. Strings are alloced with
//      Exchmem and are the responsability of the caller to free.
//  Parameters:
//      IN  wszSrc      Source string to contert
//  Returns:
//      Pointer to ASCII string on success
//      NULL on failure
//  History:
//      6/7/99 - MikeSwa Created
//      4/3/2000 - MikeSwa Modified to make loc safe
//
//-----------------------------------------------------------------------------
LPSTR  szUnicodeToAscii(LPCWSTR wszSrc)
{
    TraceFunctEnterEx((LPARAM) NULL, "szUnicodeToAscii");
    LPSTR  szDest = NULL;
    DWORD  dwErr  = ERROR_SUCCESS;
    DWORD  cSrc   = NULL;
    if (!wszSrc)
        return NULL;

    //
    //  Call into WideCharToMultiByte to get length
    //
    cSrc = WideCharToMultiByte(CP_ACP,
                        0,
                        wszSrc,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);

    cSrc++;

    szDest = (LPSTR) pvMalloc((cSrc+1)*sizeof(CHAR));
    if (!szDest)
    {
        ErrorTrace(0, "Unable to allocate conversion buffer of size %d", cSrc);
        goto Exit;
    }

    //
    //  WideCharToMultiByte a second time to do the actual conversion
    //
    if (!WideCharToMultiByte(CP_ACP,
                        0,
                        wszSrc,
                        -1,
                        szDest,
                        cSrc+1,
                        NULL,
                        NULL))
    {
        FreePv(szDest);
        szDest = NULL;
        dwErr = GetLastError();
        ErrorTrace((LPARAM) NULL, "Error convert from UNICODE to ASCII - %lu", dwErr);
        _ASSERT(0 && "Conversion from UNICODE failed");
    }
    else
    {
        DebugTrace(0, "Converted %S to %s", wszSrc, szDest);
    }

  Exit:
    return szDest;
}


//---[ HrQADMApplyActionToIMailMessages ]-----------------------------------------
//
//
//  Description:
//      Convert QueueAdmin parameter to UNICODE. Strings are alloced with
//      Exchmem and are the responsability of the caller to free.
//  Parameters:
//      IN pIMailMsgProperties   mail msg object to apply action on
//      IN pvContext             CAQAdminMessageFilter used
//      OUT pfContinue           TRUE if we should continue
//      OUT pfDelete             TRUE if item should be deleted
//  Returns:
//      S_OK on sucess
//  History:
//      8/8/00 - t-toddc created
//
//-----------------------------------------------------------------------------

HRESULT HrQADMApplyActionToIMailMessages(IN IMailMsgProperties *pIMailMsgProperties,
                                         IN PVOID pvContext,
                                         OUT BOOL *pfContinue,
                                         OUT BOOL *pfDelete)
{
    _ASSERT(pIMailMsgProperties);
    _ASSERT(pvContext);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);

    IQueueAdminMessageFilter *pIQueueAdminMessageFilter =
        (IQueueAdminMessageFilter *) pvContext;
    HRESULT hr = S_OK;
    IUnknown *pIUnknownMsg = NULL;

    hr = pIMailMsgProperties->QueryInterface(IID_IUnknown, (void **) &pIUnknownMsg);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IUnknown failed");
    if (FAILED(hr))
    {
        *pfContinue = FALSE;
        goto Cleanup;
    }

    hr = pIQueueAdminMessageFilter->HrProcessMessage(pIUnknownMsg,
                                                     pfContinue,
                                                     pfDelete);
    if (FAILED(hr))
    {
        *pfContinue = FALSE;
        goto Cleanup;
    }

Cleanup:

    if (pIUnknownMsg)
        pIUnknownMsg->Release();

    return hr;
}

//---[ HrGetMsgInfoFromIMailMsgProperty ]--------------------------------------
//
//  Description:
//      Fills out a queue admin MESSAGE_INFO structure.  This function
//      performs all action common to both IMailMsgProperties and CMsgRefs.
//  Parameters:
//      IN pIMailMsgProperties   mail msg object to get info from
//      IN OUT pMsgInfo          MESSAGE_INFO struct to dump data to
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if an allocation failure
//  History:
//      8/9/00 - t-toddc created
//      12/11/2000 - MikeSwa Merged code for Hg
//
//-----------------------------------------------------------------------------
HRESULT HrGetMsgInfoFromIMailMsgProperty(IMailMsgProperties* pIMailMsgProperties,
                                         MESSAGE_INFO* pMsgInfo,
                                         LINK_INFO_FLAGS flags)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrGetMsgInfoFromIMailMsgProperty");
    HRESULT hr = S_OK;
    LPSTR   szSender = NULL;
    LPWSTR   wszAddressType = NULL;
    DWORD   cbSender = 0;
    DWORD   iSenderAddressType = 0;
    DWORD   cbProp = 0;
    DWORD   i = 0;

    _ASSERT(pIMailMsgProperties);
    _ASSERT(pMsgInfo);

    //Get Sender
    hr = HrQueueAdminGetUnicodeStringProp(pIMailMsgProperties,
                                          IMMPID_MP_RFC822_FROM_ADDRESS,
                                          &pMsgInfo->szSender);
    if (FAILED(hr))
        goto Exit;

    //If no P2 sender... use the P1
    if (!pMsgInfo->szSender)
    {
        hr = HrQueueAdminGetP1Sender(pIMailMsgProperties, &szSender,
                                     &cbSender, &iSenderAddressType);
        if (FAILED(hr))
            goto Exit;

        if (szSender)
        {
            //
            //  Copy just the UNICODE address into the buffer.  One could
            //  argue that the address type should be included, but I have
            //  decided not to, because:
            //      - It is of marginal use.  The users of this API can determine
            //        what type of address it is.
            //      - If a message has been categorized we'll use the SMTP addr
            //      - If it comes from another machine (or the store driver has
            //        set the IMMPID_MP_RFC822_FROM_ADDRESS property),
            //        we will use the RFC822 From.
            //      - It changes the behavior from the previous versions.
            //      - It will involce adding some complexity/extra allocations
            //          to support it.
            //
            pMsgInfo->szSender = wszQueueAdminConvertToUnicode(szSender,
                                      cbSender, FALSE);
        }
    }

    hr = HrQueueAdminGetUnicodeStringProp(pIMailMsgProperties,
                                          IMMPID_MP_RFC822_MSG_SUBJECT,
                                          &pMsgInfo->szSubject);
    if (FAILED(hr))
        goto Exit;

    //See X5:113280 for details.  Basically, the P2 recipients are broken for
    //any messages that go over BDAT.... hence we are not displaying them until
    //the underlying SMTP bug is fixed
    pMsgInfo->cRecipients = -1;
    pMsgInfo->cCCRecipients = -1;
    pMsgInfo->cBCCRecipients = -1;

    //Get MsgID
    hr = HrQueueAdminGetUnicodeStringProp(pIMailMsgProperties,
                                          IMMPID_MP_RFC822_MSG_ID,
                                          &pMsgInfo->szMessageId);
    if (FAILED(hr))
        goto Exit;

    QueueAdminGetRecipListFromP1(pIMailMsgProperties, pMsgInfo);

Exit:

    if (szSender)
        QueueAdminFree(szSender);

    TraceFunctLeave();
    return hr;
}


//---[ HrQueueAdminGetP1Sender ]-----------------------------------------------
//
//
//  Description:
//      Handles getting the P1 sender and type... based on the
//  Parameters:
//      IN  pIMailMsgProperties IMailMsgProperties to get sender from
//      OUT pszSender           Address of sender (including type) - must be
//                              free'd using QueueAdminFree()
//      OUT pcbSender           Size of sender (including NULLS)
//      OUT piAddressType       Returns the matching address type
//  OPT IN  iStartAddressType   Address type to start with.  Can be used to
//                              skip higher priority address types if we are
//                              are comparing against a given address.  With
//                              the default value of 0, we will check all
//                              addresses in priority order.  This is OPTIONAL
//  OPT IN  fRequireAddressTypeMatch    Requires that the address type found
//                              matches the iStartAddressType
//  Returns:
//      S_OK on success
//  History:
//      3/1/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrQueueAdminGetP1Sender(IMailMsgProperties *pIMailMsgProperties,
                                              LPSTR *pszSender,
                                              DWORD *pcbSender,
                                              DWORD *piAddressType,
                                              DWORD  iStartAddressType,
                                              BOOL   fRequireAddressTypeMatch)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrQueueAdminGetP1Sender");
    HRESULT hr = S_OK;
    DWORD   i = iStartAddressType;
    DWORD   iStopAddressType = g_cQAPIAddressTypes;

    _ASSERT(pszSender);
    _ASSERT(pcbSender);
    _ASSERT(pIMailMsgProperties);
    _ASSERT(piAddressType);

    if (!pIMailMsgProperties || !pszSender || !pcbSender || !piAddressType)
    {
        hr = E_POINTER;
        goto Exit;
    }

    _ASSERT(iStartAddressType < g_cQAPIAddressTypes);
    *pszSender = NULL;
    *pcbSender = 0;
    *piAddressType = 0;

    if (fRequireAddressTypeMatch && (iStartAddressType < g_cQAPIAddressTypes))
        iStopAddressType = iStartAddressType+1;

    for (i = iStartAddressType; i < iStopAddressType; i++)
    {
        *pszSender = NULL;
        *pcbSender = 0;
        *piAddressType = i;
        hr = HrQueueAdminGetStringProp(pIMailMsgProperties,
                                              g_rgdwQAPISenderPropIDs[i],
                                              pszSender, pcbSender);

        //
        //  If we have found a match... bail
        //  If we have a real failure... bail
        //
        if (SUCCEEDED(hr))
        {
            //
            //  HrQueueAdminGetStringProp attempts to hide non-fatal errors
            //  from the UI and can succeed if no property is found
            //
            if (*pszSender)
                break;
        }
        else if (MAILMSG_E_PROPNOTFOUND != hr)
            goto Exit;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}


//---[ HrQADMGetMsgSize ]------------------------------------------------------
//
//  Description:
//      obtains the size of an IMailMsgProperties Object
//  Parameters:
//      IN pIMailMsgProperties   mail msg object to get info from
//      OUT pcbMsgSize           size info
//  Returns:
//      S_OK on success
//  History:
//      8/10/00 - t-toddc created
//      12/11/2000 - MikeSwa Merged code for Hg
//
//-----------------------------------------------------------------------------
HRESULT HrQADMGetMsgSize(IMailMsgProperties* pIMailMsgProperties,
                         DWORD* pcbMsgSize)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrQADMGetMsgSize");
    HRESULT hr = S_OK;
    DWORD cbMsgSize= 0;

    _ASSERT(pIMailMsgProperties);
    _ASSERT(pcbMsgSize);

    //Get the size of the message
    hr = pIMailMsgProperties->GetDWORD(IMMPID_MP_MSG_SIZE_HINT, &cbMsgSize);
    if (FAILED(hr))
    {
        if (MAILMSG_E_PROPNOTFOUND != hr)
        {
            ErrorTrace((LPARAM) pIMailMsgProperties,
                "Failed to get message size hint 0x%08X", hr);
            cbMsgSize = 0;
            goto Exit;
        }
        else
        {
            hr = S_OK;
            cbMsgSize = DEFAULT_MSG_HINT_SIZE;
            DebugTrace((LPARAM) pIMailMsgProperties,
                "Unable to get size.. using default size");
        }
    }

  Exit:
    if (pcbMsgSize)
        *pcbMsgSize = cbMsgSize;
    TraceFunctLeave();
    return hr;
}


//---[ UpdateCountersForLinkType ]----------------------------------------------------
//
//
//  Description:
//      Updates the VSI perf counters based on the link type passed in.
//  Parameters:
//      paqinst         Ptr to server instance object
//      dwLinkType      Type of queue
//  Returns:
//      -
//  History:
//      1/10/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID UpdateCountersForLinkType(CAQSvrInst *paqinst, DWORD dwLinkType)
{
    _ASSERT(paqinst);
    if (!paqinst)
        return;

    if (LI_TYPE_LOCAL_DELIVERY & dwLinkType)
        paqinst->DecPendingLocal();
    else if (LI_TYPE_PENDING_ROUTING & dwLinkType)
        paqinst->DecPendingRouting();
    else if (LI_TYPE_PENDING_CAT & dwLinkType)
        paqinst->DecPendingCat();
    else if (LI_TYPE_PENDING_SUBMIT & dwLinkType)
        paqinst->DecPendingSubmit();
}


//---[ QueueAdminFileTimeToSystemTime ]----------------------------------------
//
//
//  Description:
//      Converts a filetime to a system time.  Checks to see if the FILETIME
//      is zero first, so we don't end up with a date of 1/1/1601
//  Parameters:
//
//  Returns:
//
//  History:
//      1/11/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID QueueAdminFileTimeToSystemTime(FILETIME *pft, SYSTEMTIME *pst)
{
    BOOL fConverted = FALSE;
    _ASSERT(pft);
    _ASSERT(pst);


    if (pft->dwHighDateTime && pft->dwLowDateTime)
        fConverted = FileTimeToSystemTime(pft, pst);

    if (!fConverted)
        ZeroMemory(pst, sizeof(SYSTEMTIME));
}


//---[ CAQSvrInst::fIsLocalQueueAdminAction ]----------------------------------
//
//
//  Description:
//      Determines if the IQueueAdminAction interface being passed in is local.
//      Used so the same code can provide MESSAGE_INFO for local and remote
//      queues
//  Parameters:
//      pIQueueAdminAction
//  Returns:
//      TRUE if local
//      FALSE otherwise
//  History:
//      1/11/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fIsLocalQueueAdminAction(IQueueAdminAction *pIQueueAdminAction)
{
    HRESULT hr = S_OK;
    BOOL    fMatch = FALSE;
    IQueueAdminAction *pIQueueAdminActionLocal = NULL;

    hr = m_asyncqPreLocalDeliveryQueue.QueryInterface(
                                            IID_IQueueAdminAction,
                                            (void **) &pIQueueAdminActionLocal);
    _ASSERT(SUCCEEDED(hr) && "QI for IQueueAdminAction failed on internal queue!!");
    if (FAILED(hr))
        goto Exit;

    fMatch = (pIQueueAdminActionLocal == pIQueueAdminAction);
  Exit:
    if (pIQueueAdminActionLocal)
        pIQueueAdminActionLocal->Release();

    return fMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\adminsso\virsvr.h ===
// virsvr.h : Declaration of the CSmtpAdminVirtualServer


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "metafact.h"
#include "cmultisz.h"
#include "binding.h"
#include "rtsrc.h"

class CTcpAccess;


// Administrator ACL:
HRESULT		AclToAdministrators ( LPCTSTR strServer, PSECURITY_DESCRIPTOR pSDRelative, SAFEARRAY ** ppsaAdmins );
HRESULT		AdministratorsToAcl ( LPCTSTR strServer, SAFEARRAY * psaAdmins, PSECURITY_DESCRIPTOR* ppSD, DWORD * pcbSD );


static HRESULT SidToString ( PSID pSID, BSTR * pStr );
static HRESULT StringToSid ( LPCWSTR strSystemName, LPWSTR str, PSID * ppSID );


/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminVirtualServer : 
	public CComDualImpl<ISmtpAdminVirtualServer, &IID_ISmtpAdminVirtualServer, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminVirtualServer,&CLSID_CSmtpAdminVirtualServer>
{
public:
	CSmtpAdminVirtualServer();
	virtual ~CSmtpAdminVirtualServer ();
	
BEGIN_COM_MAP(CSmtpAdminVirtualServer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmtpAdminVirtualServer)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminVirtualServer) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminVirtualServer, _T("Smtpadm.VirtualServer.1"), _T("Smtpadm.VirtualServer"), IDS_SMTPADMIN_VIRTUALSERVER_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISmtpAdminVirtualServer
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// other interfaces supported by virtual server
	STDMETHODIMP	get_TcpAccess ( ITcpAccess ** ppTcpAccess );

	STDMETHODIMP	get_Comment		( BSTR * pstrComment );
	STDMETHODIMP	put_Comment		( BSTR strComment );

    STDMETHODIMP    get_Bindings         ( IServerBindings ** ppBindings );
    STDMETHODIMP    get_BindingsDispatch ( IDispatch ** ppDispatch );

    STDMETHODIMP    get_RoutingSource   ( IRoutingSource ** ppRoutingSource );
    STDMETHODIMP    get_RoutingSourceDispatch ( IDispatch ** ppRoutingSource );

	// Overridable server properties:

	STDMETHODIMP	get_ServerBindings	( SAFEARRAY ** ppsastrServerBindings );
	STDMETHODIMP	put_ServerBindings	( SAFEARRAY * pstrServerBindings );

	STDMETHODIMP	get_ServerBindingsVariant	( SAFEARRAY ** ppsastrServerBindings );
	STDMETHODIMP	put_ServerBindingsVariant	( SAFEARRAY * pstrServerBindings );

	STDMETHODIMP	get_SecureBindings	( SAFEARRAY ** ppsastrSecureBindings );
	STDMETHODIMP	put_SecureBindings	( SAFEARRAY * pstrSecureBindings );

	STDMETHODIMP	get_SecureBindingsVariant	( SAFEARRAY ** ppsastrSecureBindings );
	STDMETHODIMP	put_SecureBindingsVariant	( SAFEARRAY * pstrSecureBindings );

	STDMETHODIMP	get_Port			( long * lPort );
	STDMETHODIMP	put_Port			( long lPort );

	STDMETHODIMP	get_SSLPort			( long * lSSLPort );
	STDMETHODIMP	put_SSLPort			( long lSSLPort );

	STDMETHODIMP	get_OutboundPort	( long * lOutboundPort );
	STDMETHODIMP	put_OutboundPort	( long lOutboundPort );

	STDMETHODIMP	get_HopCount		( long * lHopCount );
	STDMETHODIMP	put_HopCount		( long lHopCount );

	STDMETHODIMP	get_SmartHost		( BSTR * pstrSmartHost );
	STDMETHODIMP	put_SmartHost		( BSTR   pstrSmartHost );

	STDMETHODIMP	get_EnableDNSLookup	( BOOL * pfEnableDNSLookup );
	STDMETHODIMP	put_EnableDNSLookup	( BOOL fEnableDNSLookup );

	STDMETHODIMP	get_PostmasterEmail	( BSTR * pstrPostmasterEmail );
	STDMETHODIMP	put_PostmasterEmail	( BSTR strPostmasterEmail );

	STDMETHODIMP	get_PostmasterName	( BSTR * pstrPostmasterName );
	STDMETHODIMP	put_PostmasterName	( BSTR strPostmasterName );

	STDMETHODIMP	get_DefaultDomain	( BSTR * pstrDefaultDomainName );
	STDMETHODIMP	put_DefaultDomain	( BSTR strDefaultDomainName );

	STDMETHODIMP	get_FQDN			( BSTR * pstrFQDN );
	STDMETHODIMP	put_FQDN			( BSTR strFQDN );

	STDMETHODIMP	get_DropDir			( BSTR * pstrDropDir );
	STDMETHODIMP	put_DropDir			( BSTR strDropDir );

	STDMETHODIMP	get_BadMailDir		( BSTR * pstrBadMailDir );
	STDMETHODIMP	put_BadMailDir		( BSTR strBadMailDir );

	STDMETHODIMP	get_PickupDir		( BSTR * pstrPickupDir );
	STDMETHODIMP	put_PickupDir		( BSTR strPickupDir );

	STDMETHODIMP	get_QueueDir		( BSTR * pstrQueueDir );
	STDMETHODIMP	put_QueueDir		( BSTR strQueueDir );

	STDMETHODIMP	get_MaxInConnection	( long * lMaxInConnection );
	STDMETHODIMP	put_MaxInConnection	( long lMaxInConnection );

	STDMETHODIMP	get_MaxOutConnection( long * lMaxOutConnection );
	STDMETHODIMP	put_MaxOutConnection( long lMaxOutConnection );

	STDMETHODIMP	get_InConnectionTimeout	( long * lInConnectionTimeout );
	STDMETHODIMP	put_InConnectionTimeout	( long lInConnectionTimeout );

	STDMETHODIMP	get_OutConnectionTimeout( long * lOutConnectionTimeout );
	STDMETHODIMP	put_OutConnectionTimeout( long lOutConnectionTimeout );

	STDMETHODIMP	get_MaxMessageSize	( long * lMaxMessageSize );
	STDMETHODIMP	put_MaxMessageSize	( long lMaxMessageSize );

	STDMETHODIMP	get_MaxSessionSize	( long * lMaxSessionSize );
	STDMETHODIMP	put_MaxSessionSize	( long lMaxSessionSize );

	STDMETHODIMP	get_MaxMessageRecipients	( long * lMaxMessageRecipients );
	STDMETHODIMP	put_MaxMessageRecipients	( long lMaxMessageRecipients );

	STDMETHODIMP	get_LocalRetries	( long * lLocalRetries );
	STDMETHODIMP	put_LocalRetries	( long lLocalRetries );

	STDMETHODIMP	get_LocalRetryTime	( long * lLocalRetryTime );
	STDMETHODIMP	put_LocalRetryTime	( long lLocalRetryTime );

	STDMETHODIMP	get_RemoteRetries	( long * lRemoteRetries );
	STDMETHODIMP	put_RemoteRetries	( long lRemoteRetries );

	STDMETHODIMP	get_RemoteRetryTime	( long * lRemoteRetryTime );
	STDMETHODIMP	put_RemoteRetryTime	( long lRemoteRetryTime );

	STDMETHODIMP	get_ETRNDays		( long * lETRNDays );
	STDMETHODIMP	put_ETRNDays		( long lETRNDays );

	STDMETHODIMP	get_SendDNRToPostmaster	( BOOL * pfSendDNRToPostmaster );
	STDMETHODIMP	put_SendDNRToPostmaster	( BOOL fSendDNRToPostmaster );

	STDMETHODIMP	get_SendBadmailToPostmaster		( BOOL * pfSendBadmailToPostmaster);
	STDMETHODIMP	put_SendBadmailToPostmaster		( BOOL fSendBadmailToPostmaster );

	STDMETHODIMP	get_RoutingDLL			( BSTR * pstrRoutingDLL );
	STDMETHODIMP	put_RoutingDLL			( BSTR strRoutingDLL );


	STDMETHODIMP	get_RoutingSources	( SAFEARRAY ** ppsastrRoutingSources );
	STDMETHODIMP	put_RoutingSources	( SAFEARRAY * pstrRoutingSources );

	STDMETHODIMP	get_RoutingSourcesVariant	( SAFEARRAY ** ppsavarRoutingSources );
	STDMETHODIMP	put_RoutingSourcesVariant	( SAFEARRAY * psavarRoutingSources );

	STDMETHODIMP	get_LocalDomains	( SAFEARRAY ** ppsastrLocalDomains );
	STDMETHODIMP	put_LocalDomains	( SAFEARRAY * pstrLocalDomains );
	
	STDMETHODIMP	get_DomainRouting	( SAFEARRAY ** ppsastrDomainRouting );
	STDMETHODIMP	put_DomainRouting	( SAFEARRAY * pstrDomainRouting );

	STDMETHODIMP	get_DomainRoutingVariant	( SAFEARRAY ** ppsastrDomainRouting );
	STDMETHODIMP	put_DomainRoutingVariant	( SAFEARRAY * pstrDomainRouting );

	STDMETHODIMP	get_MasqueradeDomain	( BSTR * pstrMasqueradeDomain );
	STDMETHODIMP	put_MasqueradeDomain	( BSTR strMasqueradeDomain );

	STDMETHODIMP	get_SendNdrTo			( BSTR * pstrAddr );
	STDMETHODIMP	put_SendNdrTo			( BSTR strAddr );

	STDMETHODIMP	get_SendBadTo			( BSTR * pstrAddr );
	STDMETHODIMP	put_SendBadTo			( BSTR strAddr );
	
	STDMETHODIMP	get_RemoteSecurePort	( long * plRemoteSecurePort );
	STDMETHODIMP	put_RemoteSecurePort	( long lRemoteSecurePort );

	STDMETHODIMP	get_ShouldDeliver		( BOOL * pfShouldDeliver );
	STDMETHODIMP	put_ShouldDeliver		( BOOL fShouldDeliver );

	STDMETHODIMP	get_AlwaysUseSsl			( BOOL * pfAlwaysUseSsl );
	STDMETHODIMP	put_AlwaysUseSsl			( BOOL fAlwaysUseSsl );

	STDMETHODIMP	get_LimitRemoteConnections	( BOOL * pfLimitRemoteConnections );
	STDMETHODIMP	put_LimitRemoteConnections	( BOOL fLimitRemoteConnections );

	STDMETHODIMP	get_MaxOutConnPerDomain		( long * plMaxOutConnPerDomain );
	STDMETHODIMP	put_MaxOutConnPerDomain		( long lMaxOutConnPerDomain );

	STDMETHODIMP	get_AllowVerify				( BOOL * pfAllowVerify );
	STDMETHODIMP	put_AllowVerify				( BOOL fAllowVerify	);

	STDMETHODIMP	get_AllowExpand				( BOOL * pfAllowExpand );
	STDMETHODIMP	put_AllowExpand				( BOOL fAllowExpand );

	STDMETHODIMP	get_SmartHostType			( long * plSmartHostType );
	STDMETHODIMP	put_SmartHostType			( long lSmartHostType );

	STDMETHODIMP	get_BatchMessages			( BOOL * pfBatchMessages );
	STDMETHODIMP	put_BatchMessages			( BOOL fBatchMessages );

	STDMETHODIMP	get_BatchMessageLimit		( long * plBatchMessageLimit );
	STDMETHODIMP	put_BatchMessageLimit		( long lBatchMessageLimit );

	STDMETHODIMP	get_DoMasquerade			( BOOL * pfDoMasquerade );
	STDMETHODIMP	put_DoMasquerade			( BOOL fDoMasquerade );

	STDMETHODIMP	get_Administrators			( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_Administrators			( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_AdministratorsVariant	( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_AdministratorsVariant	( SAFEARRAY * psastrAdmins );

    STDMETHODIMP	get_AuthenticationPackages	( BSTR * pstrAuthenticationPackages );
    STDMETHODIMP	put_AuthenticationPackages	( BSTR strAuthenticationPackages );

    STDMETHODIMP	get_ClearTextAuthPackage	( BSTR * pstrClearTextAuthPackage );
    STDMETHODIMP	put_ClearTextAuthPackage	( BSTR strClearTextAuthPackage );

    STDMETHODIMP    get_AuthenticationMethod    (long *plAuthMethod);
    STDMETHODIMP    put_AuthenticationMethod    (long lAuthMethod);

    STDMETHODIMP    get_DefaultLogonDomain      (BSTR *pstrLogonDomain);
    STDMETHODIMP    put_DefaultLogonDomain      (BSTR strLogonDomain);

    STDMETHODIMP    get_RouteAction             (long *plRouteAction);
    STDMETHODIMP    put_RouteAction             (long lRouteAction);

    STDMETHODIMP    get_RouteUserName           (BSTR *pstrRouteUserName);
    STDMETHODIMP    put_RouteUserName           (BSTR strRouteUserName);

    STDMETHODIMP    get_RoutePassword           (BSTR *pstrRoutePassword);
    STDMETHODIMP    put_RoutePassword           (BSTR strRoutePassword);

	STDMETHODIMP	get_LogFileDirectory		( BSTR * pstrLogFileDirectory );
	STDMETHODIMP	put_LogFileDirectory		( BSTR strLogFileDirectory );

	STDMETHODIMP	get_LogFilePeriod			( long * lLogFilePeriod );
	STDMETHODIMP	put_LogFilePeriod			( long lLogFilePeriod );

	STDMETHODIMP	get_LogFileTruncateSize		( long * lLogFileTruncateSize );
	STDMETHODIMP	put_LogFileTruncateSize		( long lLogFileTruncateSize );

	STDMETHODIMP	get_LogMethod				( long * lLogMethod );
	STDMETHODIMP	put_LogMethod				( long lLogMethod );

	STDMETHODIMP	get_LogType					( long * lLogType );
	STDMETHODIMP	put_LogType					( long lLogType );

/*
	STDMETHODIMP	get_DisplayName	( BSTR * pstrDisplayName );
	STDMETHODIMP	put_DisplayName	( BSTR strDisplayName );
*/
	//
	//	Service State Properties:
	//
	STDMETHODIMP	get_AutoStart	( BOOL * pfAutoStart );
	STDMETHODIMP	put_AutoStart	( BOOL fAutoStart );

    STDMETHODIMP	get_ServerState	( DWORD * pdwServerState );
    STDMETHODIMP    get_Win32ErrorCode      ( long * plWin32ErrorCode );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Get ( );
	STDMETHODIMP	Set ( BOOL fFailIfChanged );
	STDMETHODIMP	BackupRoutingTable( BSTR strPath );

	STDMETHODIMP	Start		( );
	STDMETHODIMP	Pause		( );
	STDMETHODIMP	Continue	( );
	STDMETHODIMP	Stop		( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Properties:
	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	long		m_lPort;
	CMultiSz    m_mszServerBindings;		// MultiString
	CMultiSz    m_mszSecureBindings;		// MultiString

	long		m_lSSLPort;
	long		m_lOutboundPort;
	long		m_lRemoteSecurePort;

	CComBSTR	m_strSmartHost;
	BOOL		m_fEnableDNSLookup;
	CComBSTR	m_strPostmasterEmail;
	CComBSTR	m_strPostmasterName;

	CComBSTR	m_strFQDN;
	CComBSTR	m_strDefaultDomain;
	CComBSTR	m_strDropDir;

	CComBSTR	m_strBadMailDir;
	CComBSTR	m_strPickupDir;
	CComBSTR	m_strQueueDir;

	long		m_lHopCount;
	long		m_lMaxInConnection;
	long		m_lMaxOutConnection;
	long		m_lInConnectionTimeout;
	long		m_lOutConnectionTimeout;

	long		m_lMaxMessageSize;
	long		m_lMaxSessionSize;
	long		m_lMaxMessageRecipients;

	long		m_lLocalRetries;
	long		m_lLocalRetryTime;
	long		m_lRemoteRetries;
	long		m_lRemoteRetryTime;

	long		m_lETRNDays;

	BOOL		m_fSendDNRToPostmaster;
	BOOL		m_fSendBadmailToPostmaster;

	CComBSTR	m_strRoutingDLL;
	CMultiSz	m_mszRoutingSources;	// MultiString

	CMultiSz    m_mszLocalDomains;		// MultiString
	CMultiSz    m_mszDomainRouting;		// MultiString

	BOOL		m_fDoMasquerade;
	CComBSTR	m_strMasqueradeDomain;

	CComBSTR	m_strNdrAddr;
	CComBSTR	m_strBadAddr;

	BOOL		m_fShouldDeliver;
	BOOL		m_fAlwaysUseSsl;
	BOOL		m_fLimitRemoteConnections;
	long		m_lMaxOutConnPerDomain;

	BOOL		m_fAllowVerify;
	BOOL		m_fAllowExpand;
	long		m_lSmartHostType;

	BOOL		m_fBtachMsgs;
	long		m_lBatchMsgLimit;

	SAFEARRAY *	m_psaAdmins;

    long        m_lAuthMethod;
    CComBSTR    m_strAuthPackages;
    CComBSTR    m_strClearTextAuthPackage;
    CComBSTR    m_strDefaultLogonDomain;

    // outbound security
    long        m_lRouteAction;
    CComBSTR    m_strRouteUserName;
    CComBSTR    m_strRoutePassword;

	CComBSTR	m_strLogFileDirectory;
	long		m_lLogFilePeriod;
	long		m_lLogFileTruncateSize;
	long		m_lLogMethod;
	long		m_lLogType;

	BOOL		m_fAutoStart;

	//service specific
	CComBSTR	m_strComment;

	// Service State:
    DWORD       m_dwServerState;
    DWORD       m_dwWin32ErrorCode;

	// Unused so far:
	CComBSTR	m_strDisplayName;

	// Tcp restrictions:
	CComPtr<ITcpAccess>		m_pIpAccess;
	CTcpAccess *			m_pPrivateIpAccess;

    // Bindings:
    CComPtr<IServerBindings>    m_pBindings;
    CServerBindings *           m_pPrivateBindings;

    CComObject<CRoutingSource>  m_RoutingSource;

	// Status:
	BOOL		m_fGotProperties;
	DWORD		m_bvChangedFields;
	FILETIME	m_ftLastChanged;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT 	GetPropertiesFromMetabase	( IMSAdminBase * pMetabase );
	HRESULT 	SendPropertiesToMetabase	( BOOL fFailIfChanged, IMSAdminBase * pMetabase );

	// State:
	HRESULT		ControlService 				( 
					IMSAdminBase *	pMetabase, 
					DWORD			ControlCode,
					DWORD			dwDesiredState,
					DWORD			dwPendingState
					);
	HRESULT		WriteStateCommand	( IMSAdminBase * pMetabase, DWORD dwCommand );
	HRESULT		CheckServiceState	( IMSAdminBase * pMetabase, DWORD * pdwState );
	//NNTP_SERVER_STATE	TranslateServerState	( DWORD dwState );

	// Validation:
	BOOL		ValidateStrings ( ) const;
	BOOL		ValidateProperties ( ) const;
	void		CorrectProperties ( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqinst.h ===
//-----------------------------------------------------------------------------
//
//
//    File: aqinst.h
//
//    Description:
//      CAQSvrInst is a central dispatcher class for Advanced Queuing.  It
//      coordinates shutdown and exposes the following COM interfaces:
//          - IAdvQueue
//          - IAdvQueueConfig
//
//    Owner: mikeswa
//
//    History:
//      9/3/98 - MikeSwa - changed from legacy name catmsgq.h & CCatMsgQueue
//
//    Copyright (C) 1997, 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQINST_H__
#define __AQINST_H__

#include "cmt.h"
#include <rwnew.h>
#include "baseobj.h"
#include "aqueue.h"
#include "domcfg.h"
#include "domain.h"
#include "smtpseo.h"
#include "smproute.h"
#include "qwiktime.h"
#include "dsnsink.h"
#include "asyncq.h"
#include "msgrefadm.h"
#include "mailadmq.h"
#include "shutdown.h"
#include "refstr.h"
#include "msgguid.h"
#include "aqdbgcnt.h"
#include "aqnotify.h"
#include "defdlvrq.h"
#include "failmsgq.h"
#include "asncwrkq.h"
#include "tran_evntlog.h"
#include "aqreg.h"
#include "..\aqdisp\seomgr.h"

//-- *** LOCKS IN AQUEUE *** --------------------------------------------------
//
// NOTE: General comment on locks in aqueue.
//
//   In general, we use CShareLockNH as our locking mechanism.  These locks are
//  Reader/Writer locks with TryEnter semantics and the performance feature
//  that they use less than 1 handle per lock (~1 handle per thread).
//
//   Shutdown is handled by using these locks.  Each class that serves as an
//  entrypoint for external threads (CAsyncQueue & CConnMgr) inherits from
//  CSyncShutdown.  At shutdown, this classes lock is aquired EXCLUSIVE, and
//  to protect operations from shutdown, a this classes lock is aquired SHARED
//  for the duration of the opertaion.  Getting the shutdown sharelock either
//  success or fails without blocking (aquiring the EXCLUSIVE shutdown lock is
//  the only blocking call).
//
//   The only other global lock is the virtual server instance routing lock.
//  This is acquired shared for all operations at the same level the exclusive
//  lock is aquired.  This is acquired exlusively *only* for router changes
//  caused by IRouterReset::ResetRoutes.
//
//   If other classes have data which needs to be protected, they will have a
//  m_slPrivateData sharelock.  Any operation that needs to read data in a
//  thread-safe manner, should aquire the m_slPrivateData SHARED.  Any
//  operation that needs to write data that is accessable by multiple threads
//  should aquire that object's m_slPrivateData lock EXCLUSIVE.
//
//   Some objects (CFifoQueue for example) require more than one lock to avoid
//  contention.  These objects will have locks that are descriptive of that
//  particular locks functions.  CFifoQueue, for example, uses m_slHead and
//  m_slTail to respectively protect the head and tail of the queue.
//
//-----------------------------------------------------------------------------

// forward declarations to avoid #include nightmares
class    CLinkMsgQueue;
class    CConnMgr;
class    CAQStats;
class    CDSNParams;
class    CMsgRef;

#define MEMBER_OK(pStruct, Member) \
    (((LONG) (pStruct)->cbVersion) >= ( ((BYTE *) &((pStruct)->Member)) - ((BYTE *) pStruct)))

//For Service callback function
typedef void (*PSRVFN)(PVOID);

//CatMsgQueue Signature
#define CATMSGQ_SIG ' QMC'

//Total number of IMsgs in the system (all virtual servers)
_declspec(selectany) DWORD g_cIMsgInSystem = 0;

//List of virtual servers used by debugger extensions
_declspec(selectany) LIST_ENTRY g_liVirtualServers = {&g_liVirtualServers, &g_liVirtualServers};

//Sharelock used to access global virtual servers
_declspec(selectany) CShareLockNH *g_pslGlobals = NULL;

//Setup defaults
const DWORD g_cMaxConnections = 10000;  //Maximum # of total connections allocated
const DWORD g_cMaxLinkConnections = 10; //Maximum # of connections per link
const DWORD g_cMinMessagesPerConnection = 20; //There must be this many messages
                                             //per addional connection that is
                                             //allocated for a link
const DWORD g_cMaxMessagesPerConnection = 20; //We server atmost these many messages per connection
const DWORD g_dwConnectionWaitMilliseconds = 3600000;

const DWORD g_dwRetryThreshold  = 3;    // Till 3 consecutive failures we treat it as glitch;

const DWORD g_dwFirstTierRetrySeconds = (15 * 60);   // retry a failure in 15 minutes
const DWORD g_dwSecondTierRetrySeconds = (60 * 60);   // retry a failure in 60 minutes
const DWORD g_dwThirdTierRetrySeconds = (12 * 60 * 60); // retry a failure in 12 hrs
const DWORD g_dwFourthTierRetrySeconds = (24 * 60 * 60); // retry a failure in 24 hrs

const DWORD g_dwRetriesBeforeDelay = 5;
const DWORD g_dwDelayIntervalsBeforeNDR = 2;
const DWORD g_dwDelayExpireMinutes = g_dwRetriesBeforeDelay*g_dwFirstTierRetrySeconds/(60);
const DWORD g_dwNDRExpireMinutes = g_dwDelayIntervalsBeforeNDR*g_dwDelayExpireMinutes;


//
//  Additional message failure codes that should move to aqueue.idl.
//
#define MESSAGE_FAILURE_CAT (MESSAGE_FAILURE_BAD_PICKUP_DIR_FILE+1)

//---[ eAQFailure ]-------------------------------------------------------------
//
//
//  Description:
//      Enum used to desribe failure scenarios that will require special handling
//  Hungarian:
//      eaqf
//
//-----------------------------------------------------------------------------
typedef enum eAQFailure_
{
    AQ_FAILURE_CANNOT_NDR_UNRESOLVED_RECIPS = 0,
    AQ_FAILURE_PREROUTING_FAILED,
    AQ_FAILURE_PRECAT_RETRY,
    AQ_FAILURE_POSTCAT_EVENT,
    AQ_FAILURE_NO_RESOURCES,
    AQ_FAILURE_NDR_OF_DSN,
    AQ_FAILURE_NO_RECIPS,
    AQ_FAILURE_PENDING_DEFERRED_DELIVERY,
    AQ_FAILURE_PROCESSING_DEFERRED_DELIVERY,
    AQ_FAILURE_MSGREF_RETRY,
    AQ_FAILURE_FREE_TO_RESUSE,
    AQ_FAILURE_INTERNAL_ASYNCQ,
    AQ_FAILURE_NUM_SITUATIONS //always keep this as last
} eAQFailure;

_declspec(selectany) DWORD g_cTotalAQFailures = 0;
_declspec(selectany) DWORD g_cAQFailureSituations = AQ_FAILURE_NUM_SITUATIONS;
_declspec(selectany) DWORD g_rgcAQFailures[AQ_FAILURE_NUM_SITUATIONS] = {0};

//---[ CAQSvrInst ]------------------------------------------------------------
//
//
//  Hungarian: aqinst, paqinst
//
//  Legacy Hungarian: cmq, pcmq (from old CCatMsgQueue object)
//
//  Provides an interface definition for the enqueuing/acking categorized
//  messages Also provides an interface for creating link queues.
//
//  Only one of these objects exist per virtual server... it is used a
//  co-ordinating object used to handle an orderly shutdown.
//
//-----------------------------------------------------------------------------
class CAQSvrInst :
    public CBaseObject,
    public CSyncShutdown,
    public IAdvQueue,
    public IAdvQueueConfig,
    public IAdvQueueAdmin,
    public IMailTransportRoutingEngine,
    public IMailTransportRouterReset,
    public IAdvQueueDomainType,
    public IAQNotify,
    public IMailTransportRouterSetLinkState,
    public IAQServerEvent
{
protected:
    DWORD                   m_dwSignature;
    LIST_ENTRY              m_liVirtualServers;
    DWORD                   m_dwServerInstance; //Virtual server instance

    //Useful signatures that include flavor and verision information
    DWORD                   m_cbClasses;
    DWORD                   m_dwFlavorSignature;

    //Total counts used for counting totals of messages that have passed
    //through the system.  Very useful for determing which component has
    //dropped a message after a stress run.
    LONG                    m_cTotalMsgsQueued; //Total # of messages on dest queues (after fanout)
    LONG                    m_cMsgsAcked;       //Total # of messages that have been acknowledged
    LONG                    m_cMsgsAckedRetry;  //Total # of messages acked with retry all
    LONG                    m_cMsgsDeliveredLocal; //Total # of messages delivered to local store
    DWORD                   m_cMsgsAckedRetryLocal; //Total # of messages msgs that have been ack'd retry

    //Current system state counters
    DWORD                   m_cCurrentMsgsSubmitted; //# total msgs in system
    DWORD                   m_cCurrentMsgsPendingCat; //# Msgs that have not be categorized
    DWORD                   m_cCurrentMsgsPendingRouting; //# Msgs that have not been routed.
    DWORD                   m_cCurrentMsgsPendingDelivery; //# Msgs pending remote delivery
    DWORD                   m_cCurrentMsgsPendingLocal; //# Msgs pending local delivery
    DWORD                   m_cCurrentMsgsPendingLocalRetry; //# Msgs pending local retries
    DWORD                   m_cCurrentMsgsPendingRetry; //# Msgs with unsuccessful attempts
    DWORD                   m_cCurrentQueueMsgInstances;  //# of msgs instances pending
                                                    //remote deliver (>= #msgs)
    DWORD                   m_cCurrentRemoteDestQueues; //# of DestMsgQueues created
    DWORD                   m_cCurrentRemoteNextHops; //# of Next Hop links created
    DWORD                   m_cCurrentRemoteNextHopsEnabled; //# of links that can have connections
    DWORD                   m_cCurrentRemoteNextHopsPendingRetry; //# of links pending retry
    DWORD                   m_cCurrentRemoteNextHopsPendingSchedule; //# of links pending schedule
    DWORD                   m_cCurrentRemoteNextHopsFrozenByAdmin; //# of links frozen by admin
    DWORD                   m_cTotalMsgsSubmitted; //# of messages submitted to AQ
    DWORD                   m_cTotalExternalMsgsSubmitted; //# of messages submitted to AQ externally
    DWORD                   m_cCurrentMsgsPendingSubmitEvent; //# of messages in submission event
    DWORD                   m_cCurrentMsgsPendingPreCatEvent; //# of messages in PreCat event
    DWORD                   m_cCurrentMsgsPendingPostCatEvent; //# of messages in PostCat event
    DWORD                   m_cDelayedDSNs; //# of DSN's that contain action:delayed
    DWORD                   m_cNDRs;        //# of DSN's that contain action:failed
    DWORD                   m_cDeliveredDSNs; //# of DSN's that contain action:delivered
    DWORD                   m_cRelayedDSNs; //# of DSN's that contain action:relayed
    DWORD                   m_cExpandedDSNs; //# of DSN's that contain action:expanded
    DWORD                   m_cDMTRetries;
    DWORD                   m_cSupersededMsgs;
    DWORD                   m_cTotalMsgsTURNETRNDelivered;
    DWORD                   m_cTotalMsgsBadmailed;
    DWORD                   m_cCatMsgCalled;
    DWORD                   m_cCatCompletionCalled;
    DWORD                   m_cBadmailNoRecipients;
    DWORD                   m_cBadmailHopCountExceeded;
    DWORD                   m_cBadmailFailureGeneral;
    DWORD                   m_cBadmailBadPickupFile;
    DWORD                   m_cBadmailEvent;
    DWORD                   m_cBadmailNdrOfDsn;
    DWORD                   m_cTotalDSNFailures;
    DWORD                   m_cCurrentMsgsInLocalDelivery;
    DWORD                   m_cTotalResetRoutes;
    DWORD                   m_cCurrentPendingResetRoutes;
    DWORD                   m_cCurrentMsgsPendingSubmit;
    CAQMsgGuidList          m_mglSupersedeIDs;

    CShareLockInst          m_slPrivateData; //read/write lock for global config into

    CDomainMappingTable     m_dmt;  //ptr to domain mapping table
    CConnMgr               *m_pConnMgr;
    CDomainConfigTable      m_dct;
    ISMTPServer            *m_pISMTPServer;
    ISMTPServerEx          *m_pISMTPServerEx;
    ISMTPServerAsync	   *m_pISMTPServerAsync;
    HANDLE                  m_hCat;
    CAQQuickTime            m_qtTime; //exposes interfaces for getting expire times
    CDSNGenerator           m_dsnsink;

    //Global config data
    DWORD                   m_cMinMessagesPerConnection;
    DWORD                   m_cMaxMessagesPerConnection;
    DWORD                   m_dwConnectionWaitMilliseconds;
    //retry related
    DWORD                   m_dwFirstTierRetrySeconds; //Threshold failure retry interval
    DWORD                   m_dwDelayExpireMinutes;
    DWORD                   m_dwNDRExpireMinutes;
    DWORD                   m_dwLocalDelayExpireMinutes;
    DWORD                   m_dwLocalNDRExpireMinutes;

    //Counters used to for local and cat retry
    DWORD                   m_cLocalRetriesPending;
    DWORD                   m_cCatRetriesPending;
    DWORD                   m_cRoutingRetriesPending;
    DWORD                   m_cSubmitRetriesPending;


    DWORD                   m_dwInitMask; //used to keep track of who has been init'd
    IMessageRouter          *m_pIMessageRouterDefault;
    CRefCountedString       *m_prstrDefaultDomain;
    CRefCountedString       *m_prstrBadMailDir;
    CRefCountedString       *m_prstrCopyNDRTo;
    CRefCountedString       *m_prstrServerFQDN;

    //DSN Options
    DWORD                   m_dwDSNOptions;
    DWORD                   m_dwDSNLanguageID;

    CAsyncAdminMailMsgQueue m_asyncqPreCatQueue;

    CAsyncAdminMsgRefQueue  m_asyncqPreLocalDeliveryQueue;
    CAsyncAdminMailMsgQueue m_asyncqPostDSNQueue;
    CAsyncAdminMailMsgQueue m_asyncqPreRoutingQueue;
    CAsyncAdminMailMsgQueue m_asyncqPreSubmissionQueue;
    CDebugCountdown         m_dbgcnt;
    //Flags used to describe what has been initialized

    IMailTransportRouterReset *m_pIRouterReset;  //pointer to router reset implementation

    //Queue and counter for deferred delivery
    CAQDeferredDeliveryQueue m_defq;
    DWORD                    m_cCurrentMsgsPendingDeferredDelivery;

    //Failed Msg Queue
    CFailedMsgQueue          m_fmq;
    DWORD                    m_cCurrentResourceFailedMsgsPendingRetry;

    //Work queue used to do async work items
    CAsyncWorkQueue          m_aqwWorkQueue;

    BOOL                     m_fMailMsgReportsNumHandles;

    typedef enum _eCMQInitFlags
    {
        CMQ_INIT_OK             = 0x80000000,
        CMQ_INIT_DMT            = 0x00000001,
        CMQ_INIT_DCT            = 0x00000002,
        CMQ_INIT_CONMGR         = 0x00000004,
        CMQ_INIT_LINKQ          = 0x00000008,
        CMQ_INIT_DSN            = 0x00000010,
        CMQ_INIT_PRECATQ        = 0x00000020,
        CMQ_INIT_PRELOCQ        = 0x00000040,
        CMQ_INIT_POSTDSNQ       = 0x00000080,
        CMQ_INIT_ROUTER_RESET   = 0x00000100,
        CMQ_INIT_ROUTINGQ       = 0x00000200,
        CMQ_INIT_WORKQ          = 0x00000400,
        CMQ_INIT_SUBMISSIONQ    = 0x00000800,
        CMQ_INIT_MSGQ           = 0x80000000,
    } eCMQInitFlags;

    CSMTPSeoMgr m_CSMTPSeoMgr;

public:

    CAQSvrInst(DWORD dwServerInstance,
                 ISMTPServer *pISMTPServer);
    ~CAQSvrInst();

    HRESULT HrInitialize(
                    IN  LPSTR   szUserName = NULL,
                    IN  LPSTR   szDomainName = NULL,
                    IN  LPSTR   szPassword = NULL,
                    IN  PSRVFN  pServiceStatusFn = NULL,
                    IN  PVOID   pvServiceContext = NULL);

    HRESULT HrDeinitialize();

    //publicly accessable member values
    //MUST wrap in fTryShutdownLock - ShutdownUnlock
    CDomainMappingTable    *pdmtGetDMT() {AssertShutdownLockAquired();return &m_dmt;};
    CAQMsgGuidList         *pmglGetMsgGuidList() {AssertShutdownLockAquired(); return &m_mglSupersedeIDs;};

    HRESULT HrGetIConnectionManager(OUT IConnectionManager **ppIConnectionManager);

    //Public Methods exposed through events (or some other mechanism)
    // This function queues a categorized message for remote/local delivery
    BOOL fRouteAndQueueMsg(IN IMailMsgProperties *pIMailMsg);

    //Acknowledge the message ref.
    //There should be one Ack for every dequeue from a link.
    HRESULT HrAckMsg(MessageAck *pMsgAck, BOOL fLocal = FALSE);

    //methods to (un)map domain names to ids.
    HRESULT HrGetDomainMapping(
                IN LPSTR szDomainName, //Domain name
                OUT CDomainMapping *pdmap); //resulting domain mapping
    HRESULT HrGetDomainName(
                IN CDomainMapping *pdmap, //Domain mapping
                OUT LPSTR *pszDomainName);  //resolved domain name

    //Pass notifications off to Connection Manager
    HRESULT HrNotify(IN CAQStats *paqstats, BOOL fAdd);

    //Expose ability to get internal Domain Info to internal components
    HRESULT HrGetInternalDomainInfo(IN  DWORD cbDomainNameLength,
                                    IN  LPSTR szDomainName,
                                    OUT CInternalDomainInfo **ppDomainInfo);

    HRESULT HrGetDefaultDomainInfo(OUT CInternalDomainInfo **ppDomainInfo);

    //Get Domain Entry from DMT
    HRESULT HrGetDomainEntry(IN  DWORD cbDomainNameLength,
                             IN  LPSTR szDomainName,
                             OUT CDomainEntry **ppdentry);

    // jstamerj 980607 21:41:25: The completion routine of the
    // submission event trigger
    HRESULT SubmissionEventCompletion(
        HRESULT hrStatus,
        PEVENTPARAMS_SUBMISSION pParams);

    // jstamerj 1998/11/24 19:53:24: Fire off the PreCat event
    VOID    TriggerPreCategorizeEvent(IN IMailMsgProperties *pIMailMsgProperties);

    // jstamerj 1998/11/24 19:54:23: Completion routine of the pre-cat event
    HRESULT PreCatEventCompletion(IN HRESULT hrStatus, IN PEVENTPARAMS_PRECATEGORIZE pParams);

    // jstamerj 980610 12:24:29: Called from HrPreCatEventCompletion
    HRESULT SubmitMessageToCategorizer(IN IMailMsgProperties *pIMailMsgProperties);

    // jstamerj 980616 22:06:45: Called from CatCompletion
    void    TriggerPostCategorizeEvent(IUnknown *pIMsg, IUnknown **rgpIMsg);

    // jstamerj 980616 22:07:18: triggers a post-cat event for one message
    HRESULT TriggerPostCategorizeEventOneMsg(IUnknown *pIMsg);

    // jstamerj 980616 22:07:54: Handles post-cat event completions
    HRESULT PostCategorizationEventCompletion(HRESULT hrStatus, PEVENTPARAMS_POSTCATEGORIZE pParams);

    // 11/17/98 - MikeSwa added for CDO badmail/abort delivery
    //  returns S_FALSE if message has been completely handled.
    HRESULT SetNextMsgStatus(IN  DWORD dwCurrentStatus,
                             IN  IMailMsgProperties *pIMailMsgProperties);

    //Called by async completion to PreCat Queue
    BOOL    fPreCatQueueCompletion(IMailMsgProperties *pIMailMsgProperties);

    //Called by async completion to PreCat Queue
    BOOL    fPreLocalDeliveryQueueCompletion(CMsgRef *pmsgref);

    //Used to restart async queues after failures
    void    AsyncQueueRetry(DWORD dwQueueID);

    //Called to Set message submission time duing SubmitMessage and HrInternalSubmitMessage
    HRESULT HrSetSubmissionTimeIfNecessary(IMailMsgProperties *pIMailMsgProperties);

    //Called to calculate expire times for messages that are not stamped (most messages)
    void    CalcExpireTimeNDR(FILETIME ftSubmission, BOOL fLocal, FILETIME *pftExpire);
    void    CalcExpireTimeDelay(FILETIME ftSubmission, BOOL fLocal, FILETIME *pftExpire);

    //API to keep counters in sync
    inline DWORD cIncMsgsInSystem(); //returns total of all virtual servers
    inline void DecMsgsInSystem(BOOL fWasRetriedRemote = FALSE, BOOL fWasRemote = FALSE,
                                BOOL fWasRetriedLocal = FALSE);

    //Called by Msgref on first message retry
    inline void IncRetryCount(BOOL fLocal);

    //Called by DestMsgQueue to describe message fanout
    inline void IncQueueMsgInstances();
    inline void DecQueueMsgInstances();

    //Used to keep track of the number of queues/next hops
    inline void  IncDestQueueCount();
    inline void  DecDestQueueCount();
    inline DWORD cGetDestQueueCount();
    inline void  IncNextHopCount();
    inline void  DecNextHopCount();

    //Called by functions walk pre-local queue for NDRs
    inline void DecPendingLocal();
    inline void DecPendingSubmit()
        {InterlockedDecrement((PLONG)&m_cCurrentMsgsPendingSubmit);};
    inline void DecPendingCat()
        {InterlockedDecrement((PLONG)&m_cCurrentMsgsPendingCat);};
    inline void DecPendingRouting()
        {InterlockedDecrement((PLONG)&m_cCurrentMsgsPendingRouting);};

    inline void IncTURNETRNDelivered();

    //aszafer 1/28/00
    //used to decide start/stop throttling handles
    DWORD cCountMsgsForHandleThrottling(IN IMailMsgProperties *pIMailMsgProperties);

    //Functions to call into the specifc hash tables to iterate over subdomains
    //
    HRESULT HrIterateDMTSubDomains(IN LPSTR szDomainName,
                                   IN DWORD cbDomainNameLength,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext) ;
    HRESULT HrIterateDCTSubDomains(IN LPSTR szDomainName,
                                   IN DWORD cbDomainNameLength,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext);

    //Calls that allow access to time objects
    inline void GetExpireTime(
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime,
                IN OUT DWORD *pdwExpireContext); //if non-zero, will use last time

    inline BOOL fInPast(IN FILETIME *pftExpireTime, IN OUT DWORD *pdwExpireContext);

    HRESULT HrTriggerDSNGenerationEvent(CDSNParams *pdsnparams, BOOL fHasRoutingLock);

    HRESULT HrNDRUnresolvedRecipients(IMailMsgProperties *pIMailMsgProperties,
                                      IMailMsgRecipients *pIMailMsgRecipients);

    //friend functions that can be used as completion functions
    friend HRESULT CatCompletion(HRESULT hrCatResult, PVOID pContext, IUnknown *pIMsg,
                      IUnknown **rgpIMsg);

    //Expose server start/stop hint functions
    inline VOID ServerStartHintFunction();
    inline VOID ServerStopHintFunction();

    //function used to handle badmail
    void HandleBadMail(IN IMailMsgProperties *pIMailMsgProperties,
                       IN BOOL fUseIMailMsgProperties,
                       IN LPSTR szFileName,
                       IN HRESULT hrReason,
                       BOOL fHasRoutingLock);

    //Function to handle some sort of system failure that would cause
    //messages/data to be lost if unhandled
    void HandleAQFailure(eAQFailure eaqfFailureSituation,
                         HRESULT hr, IMailMsgProperties *pIMailMsgProperties);


    //Stub call for logging an event
    void LogAQEvent(HRESULT hrEventReason, CMsgRef *pmsgref,
                    IMailMsgProperties *pIMailMsgProperties,
                    LPSTR szFileName);

    //Routing lock should be grabbed before accessing queues (after shutdown)
    void RoutingShareLock() {m_slPrivateData.ShareLock();};
    BOOL fTryRoutingShareLock() {return m_slPrivateData.TryShareLock();};
    void RoutingShareUnlock() {m_slPrivateData.ShareUnlock();};

    HRESULT SetCallbackTime(IN PSRVFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN DWORD    dwCallbackMinutes);

    HRESULT SetCallbackTime(IN PSRVFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN FILETIME *pft);

    void DecPendingDeferred()
        {InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingDeferredDelivery);};

    void DecPendingFailed()
        {InterlockedDecrement((PLONG) &m_cCurrentResourceFailedMsgsPendingRetry);};

    void QueueMsgForLocalDelivery(CMsgRef *pmsgref, BOOL fLocalLink);

    HRESULT HrInternalSubmitMessage(IMailMsgProperties *pIMailMsgProperties);


    //Get string for default domain
    CRefCountedString *prstrGetDefaultDomain();

    //Completion Function called by MsgCat
    static HRESULT CatCompletion(HRESULT hrCatResult, PVOID pContext,
                                 IUnknown *pImsg, IUnknown **rgpImsg);

#define AQLD_SIG 'LDAQ'

    // completion object called by local delivery
    class CAQLocalDeliveryNotify :
        public IMailMsgNotify,
        public CBaseObject
    {
        public:
            CAQLocalDeliveryNotify(PVOID pContext, CMsgRef *pmsgref) {
                TraceFunctEnter("CAQLocalDeliveryNotify::CAQLocalDeliveryNotify");
                m_hr = E_FAIL;
                m_fCalledCompletion = FALSE;
                m_pContext = pContext;
                _ASSERT(pmsgref);
                m_pmsgref = pmsgref;
                m_pmsgref->AddRef();
                m_pIMsg = pmsgref ? pmsgref->pimsgGetIMsg() : NULL;
                ZeroMemory(&m_msgack, sizeof(MessageAck));
                m_msgack.dwMsgStatus = MESSAGE_STATUS_ALL_DELIVERED;
                m_msgack.pvMsgContext = (DWORD *) &m_dcntxtLocal;
                DebugTrace(0, "new(this=0x%x)\n", this);
            }
            ~CAQLocalDeliveryNotify() {
                TraceFunctEnter("CAQLocalDeliveryNotify::~CAQLocalDeliveryNotify");

                DebugTrace(0, "delete(this=0x%x)\n", this);
                if (m_pIMsg) {
                    m_pIMsg->Release();
                    m_pIMsg = NULL;
                }

                if (m_pmsgref) {
                    m_pmsgref->Release();
                    m_pmsgref = NULL;
                }
            }

            // allocators
            void *operator new(size_t stIgnored) {
                return s_pool.Alloc();
            }
            void operator delete(void *p, size_t size) {
                s_pool.Free(p);
            }

            // IMailMsgNotify
            HRESULT __stdcall Notify(HRESULT hr) {
                m_hr = hr;
                CAQSvrInst::LDCompletion(m_hr, m_pContext, m_pmsgref, this);
                m_fCalledCompletion = TRUE;
                return S_OK;
            }

            // IUnknown
            HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
            {
                if ( iid == IID_IUnknown ) {
                    *ppv = static_cast<IMailMsgNotify*>(this);
                } else if ( iid == IID_IMailMsgNotify ) {
                    *ppv = static_cast<IMailMsgNotify*>(this);
                } else {
                    *ppv = NULL;
                    return E_NOINTERFACE;
                }
                reinterpret_cast<IUnknown*>(*ppv)->AddRef();
                return S_OK;
            }
            STDMETHOD_(ULONG, AddRef)(void) {
                TraceFunctEnter("CAQLocalDeliveryNotify::AddRef");
                DebugTrace(0, "add(this=0x%x)\n", this);
                TraceFunctLeave();
                return CBaseObject::AddRef();
            };
            STDMETHOD_(ULONG, Release)(void) {
                TraceFunctEnter("CAQLocalDeliveryNotify::Release");
                DebugTrace(0, "rel(this=0x%x)\n", this);
                TraceFunctLeave();
                return CBaseObject::Release();
            };

            // accessors
            CDeliveryContext *pdcntxtGetDeliveryContext() {
                return &m_dcntxtLocal;
            }
            MessageAck *pmsgackGetMsgAck() {
                return &m_msgack;
            }
            IMailMsgProperties *pimsgGetIMsg() {
                return m_pIMsg;
            }
            CMsgRef *pmsgrefGetMsgRef() {
                return m_pmsgref;
            }
            BOOL fNotCalledCompletion() {
                return !m_fCalledCompletion;
            }
        private:
            IMailMsgProperties *m_pIMsg;
            HRESULT m_hr;
            PVOID m_pContext;
            CMsgRef *m_pmsgref;
            CDeliveryContext m_dcntxtLocal;
            MessageAck m_msgack;
            BOOL m_fCalledCompletion;
        public:
            static CPool s_pool;
    };

    void UpdateLDCounters(CMsgRef *pmsgref);

    // local delivery completion function
    static void LDCompletion(HRESULT hrLDResult,
                             PVOID pContext,
                             CMsgRef *pmsgref,
                             CAQLocalDeliveryNotify *pLDNotify);

    //Handle the details of retrying after local delivery failure
    void    HandleLocalRetry(CMsgRef *pmsgref);

    //Handles details of post-cat DSN generation
    void    HandleCatFailure(IUnknown *pIUnknown, HRESULT hrCatResult);

    //Handle the details of retrying after cat failure
    void    HandleCatRetryOneMessage(IUnknown *pIUnknown);

    HRESULT HrGetLocalQueueAdminQueue(IQueueAdminQueue **ppIQueueAdminQueue);

    HRESULT HrQueueFromQueueID(QUEUELINK_ID *pqlQueueId,
                            IQueueAdminQueue **ppIQueueAdminQueue);

    HRESULT HrLinkFromLinkID(QUEUELINK_ID *pqlLinkID,
                            IQueueAdminLink **ppIQueueAdminLink);

    BOOL fIsLocalQueueAdminAction(IQueueAdminAction *pIQueueAdminAction);

    inline HRESULT HrQueueWorkItem(PVOID pvData,
                            PASYNC_WORK_QUEUE_FN pfnCompletion);

    static BOOL fResetRoutesNextHopCompletion(PVOID pvThis, DWORD dwStatus);

    static BOOL fPreSubmissionQueueCompletionWrapper(
                                    IMailMsgProperties *pIMailMsgProperties,
                                    PVOID pvContext);

    BOOL  fShouldRetryMessage(IMailMsgProperties *pIMailMsgProperties,
                              BOOL fShouldBounceUsageIfRetry = TRUE);

    VOID ScheduleInternalRetry(DWORD dwLinkType);

    STDMETHOD(TriggerServerEvent) (
        DWORD dwEventID, 
        PVOID pvContext) 
    {
        return m_CSMTPSeoMgr.HrTriggerServerEvent(dwEventID, pvContext);
    }

    void LogResetRouteEvent( DWORD dwObainLock,
        DWORD dwWaitLock,
        DWORD dwQueue);

    HRESULT HrInternalQueueFromQueueID(QUEUELINK_ID *pqlQueueId,
                                       IQueueAdminQueue **ppIQueueAdminQueue);


    // DSN Submission methods
    HRESULT HrAllocBoundMessage(
        OUT IMailMsgProperties **ppMsg,
        OUT PFIO_CONTEXT *phContext);

    HRESULT HrSubmitDSN(
        IN  CDSNParams *pdsnparams,
        IN  DWORD dwDSNAction,
        IN  DWORD cRecipsDSNd,
        IN  IMailMsgProperties *pDSNMsg);

    //Routing interface used internal to AQ components
public:
    //Fires MAIL_TRANSPORT_ON_GET_ROUTER_FOR_MESSAGE_EVENT
    HRESULT HrTriggerGetMessageRouter(
            IN  IMailMsgProperties *pIMailMsg,
            OUT IMessageRouter     **pIMessageRouter);
    HRESULT HrTriggerLogEvent(
                IN DWORD                    idMessage,
                IN WORD                     idCategory,
                IN WORD                     cSubstrings,
                IN LPCSTR                   *rgszSubstrings,
                IN WORD                     wType,
                IN DWORD                    errCode,
                IN WORD                     iDebugLevel,
                IN LPCSTR                   szKey,
                IN DWORD                    dwOptions,
                IN DWORD                    iMessageString = 0xffffffff,
                IN HMODULE                  hModule = NULL);

private:
    HRESULT HrTriggerInitRouter();

    //IUnknown
public:
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

    //IAdvQueue
public:
    STDMETHOD(SubmitMessage)(IN IMailMsgProperties *pIMailMsgProperties);

    STDMETHOD(HandleFailedMessage)(IN IMailMsgProperties *pIMailMsgProperties,
                                   IN BOOL fUseIMailMsgProperties,
                                   IN LPSTR szFileName,
                                   IN DWORD dwFailureReason,
                                   IN HRESULT hrFailureCode);

    //IAdvQueueConfig
public:
    STDMETHOD(SetConfigInfo)(IN AQConfigInfo *pAQConfigInfo);
    STDMETHOD(SetDomainInfo)(IN DomainInfo *pDomainInfo);
    STDMETHOD(GetDomainInfo)(IN     DWORD cbDomainNameLength,
                             IN     CHAR szDomainName[],
                             IN OUT DomainInfo *pDomainInfo,
                             OUT    DWORD **ppvDomainContext);
    STDMETHOD(ReleaseDomainInfo)(IN DWORD *pvDomainContext);
    STDMETHOD(GetPerfCounters)(OUT AQPerfCounters *pAQPerfCounters,
                               OUT CATPERFBLOCK   *pCatPerfCounters);
    STDMETHOD(ResetPerfCounters)();
    STDMETHOD(StartConfigUpdate)();
    STDMETHOD(FinishConfigUpdate)();

    //IMailTransportRoutingEngine
public:
    STDMETHOD(GetMessageRouter)(
        IN  IMailMsgProperties      *pIMailMsg,
        IN  IMessageRouter          *pICurrentMessageRouter,
        OUT IMessageRouter          **ppIMessageRouter);

    //IMailTransportRouterReset
public:
    STDMETHOD(ResetRoutes)(
        IN  DWORD                   dwResetType);

    //IAdvQueueDomainType
public:
    STDMETHOD(GetDomainInfoFlags)(
        IN  LPSTR szDomainName,
        DWORD *pdwDomainInfoFlags);

    // IAdvQueueAdmin
public:
    STDMETHOD(ApplyActionToLinks)(
        LINK_ACTION     laAction);

    STDMETHOD(ApplyActionToMessages)(
        QUEUELINK_ID    *pqlQueueLinkId,
        MESSAGE_FILTER  *pmfMessageFilter,
        MESSAGE_ACTION  maMessageAction,
        DWORD           *pcMsgs);

    STDMETHOD(GetQueueInfo)(
        QUEUELINK_ID    *pqlQueueId,
        QUEUE_INFO      *pqiQueueInfo);

    STDMETHOD(GetLinkInfo)(
        QUEUELINK_ID    *pqlLinkId,
        LINK_INFO       *pliLinkInfo,
        HRESULT         *phrLinkDiagnostic);

    STDMETHOD(SetLinkState)(
        QUEUELINK_ID    *pqlLinkId,
        LINK_ACTION     la);

    STDMETHOD(GetLinkIDs)(
        DWORD           *pcLinks,
        QUEUELINK_ID    *rgLinks);

    STDMETHOD(GetQueueIDs)(
        QUEUELINK_ID    *pqlLinkId,
        DWORD           *pcQueues,
        QUEUELINK_ID    *rgQueues);

    STDMETHOD(GetMessageProperties)(
        QUEUELINK_ID        *pqlQueueLinkId,
        MESSAGE_ENUM_FILTER *pmfMessageEnumFilter,
        DWORD               *pcMsgs,
        MESSAGE_INFO        *rgMsgs);

    STDMETHOD(QuerySupportedActions)(
        QUEUELINK_ID        *pqlQueueLinkId,
        DWORD               *pdwSupportedActions,
        DWORD               *pdwSupportedFilterFlags);


  public: //IMailTransportRouterSetLinkState
    STDMETHOD(SetLinkState)(
        IN LPSTR                   szLinkDomainName,
        IN GUID                    guidRouterGUID,
        IN DWORD                   dwScheduleID,
        IN LPSTR                   szConnectorName,
        IN DWORD                   dwSetLinkState,
        IN DWORD                   dwUnSetLinkState,
        IN FILETIME               *pftNextScheduledConnection,
        IN IMessageRouter         *pMessageRouter);

};


//*** inline counter functions

//---[ CAQSvrInst::cIncMsgsInSystem ]----------------------------------------
//
//
//  Description:
//      Used to increment the global and virtual server msg counts.  Returns
//      the global count for resource management purposes.
//  Parameters:
//      -
//  Returns:
//      DWORD - Global # of Msgs in system
//
//-----------------------------------------------------------------------------
DWORD CAQSvrInst::cIncMsgsInSystem()
{
    InterlockedIncrement((PLONG) &m_cCurrentMsgsSubmitted);
    return (InterlockedIncrement((PLONG) &g_cIMsgInSystem));
};

//---[ CAQSvrInst::DecMsgsInSystem ]-----------------------------------------
//
//
//  Description:
//      Decrements the global and virtual server message counts.  Also
//      decrements the pending retry count if needed.
//  Parameters:
//      fWasRetriedRemote - TRUE if msg was retried remotely and retry count needs
//          to be decremented.
//      fWasRemote - TRUE if message was being delivered remotely
//      fWasRetriedLocal - TRUE if counted towards m_cCurrentMsgsPendingLocalRetry
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CAQSvrInst::DecMsgsInSystem(BOOL fWasRetriedRemote, BOOL fWasRemote,
                                   BOOL fWasRetriedLocal)
{
    InterlockedDecrement((PLONG) &g_cIMsgInSystem);
    InterlockedDecrement((PLONG) &m_cCurrentMsgsSubmitted);

    if (fWasRetriedRemote)
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingRetry);

    if (fWasRemote)
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingDelivery);

    if (fWasRetriedLocal)
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingLocalRetry);

};

//---[ CAQSvrInst::IncRetryCount ]-------------------------------------------
//
//
//  Description:
//      Used by MsgRef the first time a Message is ack'd with a non-success
//      code.
//  Parameters:
//      BOOL    fLocal  TRUE if message is local
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CAQSvrInst::IncRetryCount(BOOL fLocal)
{
    if (fLocal)
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingLocalRetry);
    else
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingRetry);
};

//---[ CAQSvrInst::[Inc|Dec]QueueMsgInstances ]------------------------------
//
//
//  Description:
//      Increments/decrements a count of the total number of message instances
//      queued for remote delivery.  Because a message may be put in more than
//      one queue, the steady state of this count will be at least as large as
//      the number of messages.  However, this count reflects messages that
//      are currently on the queues and does *not* count messages that are
//      currently being attempted by SMTP (which m_cCurrentMsgsPendingDelivery)
//      *does* count.
//
//      Used by DestMsgQueues.
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CAQSvrInst::IncQueueMsgInstances()
{
    InterlockedIncrement((PLONG) &m_cCurrentQueueMsgInstances);
};

void CAQSvrInst::DecQueueMsgInstances()
{
    InterlockedDecrement((PLONG) &m_cCurrentQueueMsgInstances);
};

//---[ Queue/NextHop Counter API ]---------------------------------------------
//
//
//  Description:
//      Used to increment/decrement Queue and NextHop counters
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
void CAQSvrInst::IncDestQueueCount()
{
    InterlockedIncrement((PLONG) &m_cCurrentRemoteDestQueues);
};

void CAQSvrInst::DecDestQueueCount()
{
    InterlockedDecrement((PLONG) &m_cCurrentRemoteDestQueues);
};

DWORD CAQSvrInst::cGetDestQueueCount()
{
    return m_cCurrentRemoteDestQueues;
}

void CAQSvrInst::IncNextHopCount()
{
    InterlockedIncrement((PLONG) &m_cCurrentRemoteNextHops);
};

void CAQSvrInst::DecNextHopCount()
{
    InterlockedDecrement((PLONG) &m_cCurrentRemoteNextHops);
};


//---[ CAQSvrInst::DecPendingLocal ]-----------------------------------------
//
//
//  Description:
//      Called by function walking pre-local delivery queue when a message
//      is being expired.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      8/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::DecPendingLocal()
{
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingLocal);
};


//---[ CAQSvrInst::IncTURNETRNDelivered ]--------------------------------------
//
//
//  Description:
//      Used to keep track of the # of TURN/ETRN messages delivered.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/27/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::IncTURNETRNDelivered()
{
    InterlockedIncrement((PLONG) &m_cTotalMsgsTURNETRNDelivered);
}

//---[ CAQSvrInst::GetExpireTime ]-------------------------------------------
//
//
//  Description:
//      Get the expriation time for cMinutesExpireTime from now.
//  Parameters:
//      IN     cMinutesExpireTime   # of minutes in future to set time
//      IN OUT pftExpireTime        Filetime to store new expire time
//      IN OUT pdwExpireContext     If non-zero will use the same tick count
//                                  as previous calls (saves call to GetTickCount)
//  Returns:
//      -
//  History:
//      7/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::GetExpireTime(
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime,
                IN OUT DWORD *pdwExpireContext)
{
    m_qtTime.GetExpireTime(cMinutesExpireTime, pftExpireTime,  pdwExpireContext);
}

//---[ CAQSvrInst::fInPast ]-------------------------------------------------
//
//
//  Description:
//      Determines if a given file time has already happened
//  Parameters:
//      IN     pftExpireTime        FILETIME with expiration
//      IN OUT pdwExpireContext     If non-zero will use the same tick count
//                                  as previous calls (saves call to GetTickCount)
//  Returns:
//      TRUE if expire time is in the past
//      FALSE if expire time is in the future
//  History:
//      7/11/98 - MikeSwa Created
//  Note:
//      You should NOT use the same context used to get the FILETIME, because
//      it will always return FALSE
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fInPast(IN FILETIME *pftExpireTime,
                           IN OUT DWORD *pdwExpireContext)
{
    return m_qtTime.fInPast(pftExpireTime, pdwExpireContext);
}

//---[ ServerStartHintFunction & ServerStartHintFunction ]---------------------
//
//
//  Description:
//      Functions for telling the Service control manager that we are
//      starting/stopping the service.
//
//      These functions are often called by functions that have been passed
//      the CAQSvrInst ptr as a PVOID context, so it makes sense to check
//      and assert on our signature here.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/22/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CAQSvrInst::ServerStartHintFunction()
{
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    if (m_pISMTPServer)
        m_pISMTPServer->ServerStartHintFunction();
}

VOID CAQSvrInst::ServerStopHintFunction()
{
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    if (fShutdownSignaled())
    {
        m_dbgcnt.ResetCountdown();
        //Only call stop hint if shutdown has been signalled
        if (m_pISMTPServer)
            m_pISMTPServer->ServerStopHintFunction();
    }
}

//---[ CAQSvrInst::HrQueueWorkItem ]-------------------------------------------
//
//
//  Description:
//      Thin wrapper to queue item to async work queue
//  Parameters:
//      pvData          Data to pass to completion function
//      pfnCompletion   Completion function
//  Returns:
//      S_OK on success
//      failure code from CAsyncWorkQueue
//  History:
//      3/9/99 - MikeSwa Created
//      7/7/99 - MikeSwa - will work during shutdown to allow multithreaded
//               shutdown work.
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrQueueWorkItem(PVOID pvData,
                                    PASYNC_WORK_QUEUE_FN pfnCompletion)
{
    return m_aqwWorkQueue.HrQueueWorkItem(pvData, pfnCompletion);
}

#endif // __AQINST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqadmsvr.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadmsvr.h
//
//  Description: Contains definitions for internal structures, classes and
//      enums that are needed by to handle the Queue Admin functionality
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/3/98 - MikeSwa Created
//      2/21/98 - MikeSwa added support for IQueueAdmin* interfaces
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQADMSVR_H__
#define __AQADMSVR_H__

#include <aqueue.h>
#include <intrnlqa.h>
#include <aqnotify.h>

#define AQ_MSG_FILTER_SIG   'FMQA'

//Assumed default msg size (if no hint is present)
#define DEFAULT_MSG_HINT_SIZE 1000

//enum describing internal flags
typedef enum tagAQ_MSG_FILTER
{
    AQ_MSG_FILTER_MESSAGEID                = 0x00000001,
    AQ_MSG_FILTER_SENDER                   = 0x00000002,
    AQ_MSG_FILTER_RECIPIENT                = 0x00000004,
    AQ_MSG_FILTER_OLDER_THAN               = 0x00000008,
    AQ_MSG_FILTER_LARGER_THAN              = 0x00000010,
    AQ_MSG_FILTER_FROZEN                   = 0x00000020,
    AQ_MSG_FILTER_FIRST_N_MESSAGES         = 0x00000040,
    AQ_MSG_FILTER_N_LARGEST_MESSAGES       = 0x00000080,
    AQ_MSG_FILTER_N_OLDEST_MESSAGES        = 0x00000100,
    AQ_MSG_FILTER_FAILED                   = 0x00000200,
    AQ_MSG_FILTER_ENUMERATION              = 0x10000000,
    AQ_MSG_FILTER_ACTION                   = 0x20000000,
    AQ_MSG_FILTER_ALL                      = 0x40000000,
    AQ_MSG_FILTER_INVERTSENSE              = 0x80000000,
} AQ_MSG_FILTER;

#define AQUEUE_DEFAULT_SUPPORTED_ENUM_FILTERS  (\
            MEF_FIRST_N_MESSAGES | \
            MEF_SENDER | \
            MEF_RECIPIENT | \
            MEF_LARGER_THAN | \
            MEF_OLDER_THAN | \
            MEF_FROZEN | \
            MEF_FAILED | \
            MEF_ALL | \
            MEF_INVERTSENSE)

HRESULT QueryDefaultSupportedActions(DWORD  *pdwSupportedActions,
                                     DWORD  *pdwSupportedFilterFlags);

//QueueAdmin Map function (can be used on CFifoQueue).
typedef HRESULT (* QueueAdminMapFn)(CMsgRef *, PVOID, BOOL *, BOOL *);

//---[ CAQAdminMessageFilter ]-------------------------------------------------
//
//
//  Description:
//      Internal representation for the MESSAGE_FILTER and MESSAGE_ENUM_FILETER
//      structures.  Provides helper functions to help maintain search lists
//      and allow a CMsgRef to complare itself to the filter description in an
//      efficient manner.
//
//      The idea is that a CMsgRef will query for the properties requested
//      in this filter by calling dwGetMsgFilterFlags() and calling the
//      specialize compare functions (which will handle the mechanics of
//      AQ_MSG_FILTER_INVERTSENSE).
//  Hungarian:
//      aqmf, paqmf
//
//-----------------------------------------------------------------------------
class CAQAdminMessageFilter :
    public IQueueAdminMessageFilter,
    public CBaseObject
{
  private:
    DWORD           m_dwSignature;
    DWORD           m_cMessagesToFind; //0 => find as many as possible
    DWORD           m_cMessagesToSkip;
    DWORD           m_cMessagesFound;
    DWORD           m_dwFilterFlags;
    MESSAGE_ACTION  m_dwMessageAction;
    LPSTR           m_szMessageId;
    LPSTR           m_szMessageSender;
    LPSTR           m_szMessageRecipient;
    DWORD           m_dwSenderAddressType;
    DWORD           m_dwRecipientAddressType;
    DWORD           m_dwThresholdSize;
    BOOL            m_fSenderAddressTypeSpecified;
    BOOL            m_fRecipientAddressTypeSpecified;
    FILETIME        m_ftThresholdTime;
    MESSAGE_INFO   *m_rgMsgInfo;
    MESSAGE_INFO   *m_pCurrentMsgInfo;
    DWORD           m_dwMsgIdHash;
    IQueueAdminAction *m_pIQueueAdminAction;
    PVOID           m_pvUserContext;

  public:
    CAQAdminMessageFilter()
    {
        //Don't zero vtable :)
        ZeroMemory(((BYTE *)this)+
                    FIELD_OFFSET(CAQAdminMessageFilter, m_dwSignature),
                    sizeof(CAQAdminMessageFilter) -
                    FIELD_OFFSET(CAQAdminMessageFilter, m_dwSignature));
        m_dwSignature = AQ_MSG_FILTER_SIG;
    };

    ~CAQAdminMessageFilter();

    void    InitFromMsgFilter(PMESSAGE_FILTER pmf);
    void    InitFromMsgEnumFilter(PMESSAGE_ENUM_FILTER pemf);
    void    SetSearchContext(DWORD cMessagesToFind, MESSAGE_INFO *rgMsgInfo);
    void    SetMessageAction(MESSAGE_ACTION MessageAction);

    DWORD   dwGetMsgFilterFlags() {return m_dwFilterFlags;};
    BOOL    fFoundEnoughMsgs();
    BOOL    fFoundMsg();
    BOOL    fSkipMsg()
    {
        if (m_cMessagesToSkip)
        {
            m_cMessagesToSkip--;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    //Returns true if hash matches or is value NULL string & fMatchesId
    //should be called
    BOOL    fMatchesIdHash(DWORD dwMsgIdHash)
        {return dwMsgIdHash ? (dwMsgIdHash == m_dwMsgIdHash) : TRUE;};

    DWORD   cMessagesFound() {return m_cMessagesFound;};
    MESSAGE_INFO *pmfGetMsgInfo() {return m_pCurrentMsgInfo;};
    MESSAGE_INFO *pmfGetMsgInfoAtIndex(DWORD iMsgInfo)
    {
        _ASSERT(iMsgInfo < m_cMessagesFound);
        _ASSERT(iMsgInfo < m_cMessagesToFind);
        return &(m_rgMsgInfo[iMsgInfo]);
    };

    BOOL    fMatchesId(LPCSTR szMessageId);
    BOOL    fMatchesSize(DWORD dwSize);
    BOOL    fMatchesTime(FILETIME *pftTime);

    BOOL    fMatchesMailMsgSender(IMailMsgProperties *pIMailMsgProperties);
    BOOL    fMatchesMailMsgRecipient(IMailMsgProperties *pIMailMsgProperties);

  protected: //These functions are now worker functions
    BOOL    fMatchesSender(LPCSTR szMessageSender);
    BOOL    fMatchesRecipient(LPCSTR szMessageRecipient);
    BOOL    fMatchesP1Recipient(IMailMsgProperties *pIMailMsgProperties);
    BOOL    fQueueAdminIsP1Recip(IMailMsgProperties *pIMailMsgProperties);

  public: //IUnknown
    //CBaseObject handles addref and release
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

  public: //IQueueAdminMessageFilter
    STDMETHOD(HrProcessMessage)(
            IUnknown *pIUnknownMsg,
            BOOL     *pfContinue,
            BOOL     *pfDelete);

    STDMETHOD(HrSetQueueAdminAction)(
            IQueueAdminAction *pIQueueAdminAction);

    STDMETHOD(HrSetCurrentUserContext)(
            PVOID	pvContext);

    STDMETHOD(HrGetCurrentUserContext)(
            PVOID	*ppvContext);
};

#define ASYNCQ_ADMIN_CONTEXT_SIG       'CASQ'
#define ASYNCQ_ADMIN_CONTEXT_SIG_FREE  '!ASQ'

//---[ CQueueAdminContext ]----------------------------------------------------
//
//
//  Description:
//      Context set on filter object when enumeration/applying actions to
//      to messages.
//  Hungarian:
//      qapictx, pqapictx
//
//-----------------------------------------------------------------------------
class CQueueAdminContext
{
  protected:
    DWORD           m_dwSignature;
    IAQNotify      *m_pAQNotify;
    LINK_INFO_FLAGS m_lfQueueState; // Is currnetfrozen / retry ?
    DWORD           m_cMsgsThawed;
    CAQSvrInst     *m_paqinst;


  public:
    CQueueAdminContext(IAQNotify *pAQNotify, CAQSvrInst *paqinst)
    {
        m_dwSignature = ASYNCQ_ADMIN_CONTEXT_SIG;
        m_pAQNotify = pAQNotify;
        m_cMsgsThawed = 0;
        m_lfQueueState = LI_READY;
        m_paqinst = paqinst;
    };

    ~CQueueAdminContext()
    {
        m_dwSignature = ASYNCQ_ADMIN_CONTEXT_SIG_FREE;
        m_pAQNotify = NULL;
        m_paqinst = NULL;
    };

    //
    //  This context is thrown around as a PVOID... make sure it is valid
    //
    inline BOOL fIsValid() {return(ASYNCQ_ADMIN_CONTEXT_SIG == m_dwSignature);};

    //
    //  In some cases... the state of the queue determines the state
    //  of the message (messages on the retry queue are in retry).
    //  the following can be used to get and set this state
    //
    inline void SetQueueState(LINK_INFO_FLAGS lfQueueType)
        { m_lfQueueState = lfQueueType;};

    inline LINK_INFO_FLAGS lfGetQueueState() {return m_lfQueueState;};

    //
    //  Used to update stats when a message is removed from the queue
    //
    void NotifyMessageRemoved(CAQStats *paqstats)
    {
        _ASSERT(fIsValid());

        if (m_pAQNotify)
            m_pAQNotify->HrNotify(paqstats, FALSE);
    };

    //
    //  Used to keep track of if we had to thaw messages
    //
    inline void IncThawedMsgs() {m_cMsgsThawed++;};
    inline DWORD cGetNumThawedMsgs() {return m_cMsgsThawed;};

    inline CAQSvrInst * paqinstGetAQ() {return m_paqinst;};
};

//---[ CQueueAdminRetryNotify ]---------------------------------------------------
//
//
//  Description:
//      Pure virtual class that defines an "interface" to update the next
//      retry time
//  Hungarian:
//      qapiret, pqapiret
//
//-----------------------------------------------------------------------------
class CQueueAdminRetryNotify : public IUnknown
{
    public:
        virtual void SetNextRetry(FILETIME *pft) = 0;
};

//Allocator funcations that are safe for the required RPC calls made by QueueAdmin
inline PVOID pvQueueAdminAlloc(size_t cbSize)
{
    return LocalAlloc(0, cbSize);
}

inline PVOID pvQueueAdminReAlloc(PVOID pvSrc, size_t cbSize)
{
    return LocalReAlloc(pvSrc, cbSize, LMEM_MOVEABLE);
}

inline void QueueAdminFree(PVOID pvFree)
{
    LocalFree(pvFree);
}

//Convert internal AQ config into to exportable UNICODE
LPWSTR wszQueueAdminConvertToUnicode(LPSTR szSrc, DWORD cSrc, BOOL fUTF8 = FALSE);

//Convert QueueAdmin parameter to UNICODE
LPSTR  szUnicodeToAscii(LPCWSTR szSrc);

BOOL fBiStrcmpi(LPSTR sz, LPWSTR wsz); //compares UNICODE to ASCII string

HRESULT HrQueueAdminGetStringProp(IMailMsgProperties *pIMailMsgProperties,
                                  DWORD dwPropID, LPSTR *pszProp,
                                  DWORD *pcbProp = NULL);

HRESULT HrQueueAdminGetUnicodeStringProp(
                                  IMailMsgProperties *pIMailMsgProperties,
                                  DWORD dwPropID, LPWSTR *pwszProp,
                                  DWORD *pcbProp = NULL);

DWORD   cQueueAdminGetNumRecipsFromRFC822(LPSTR szHeader, DWORD cbHeader);

void QueueAdminGetRecipListFromP1(
                                       IMailMsgProperties *pIMailMsgProperties,
                                       MESSAGE_INFO *pMsgInfo);

HRESULT HrQueueAdminGetP1Sender(IMailMsgProperties *pIMailMsgProperties,
                                LPSTR *pszSender,
                                DWORD *pcbSender,
                                DWORD *piAddressType,
                                DWORD  iStartAddressType = 0,
                                BOOL   fRequireAddressTypeMatch = FALSE);


//---[ dwQueueAdminHash ]------------------------------------------------------
//
//
//  Description:
//      Function To Hash Queue Admin Strings.  Specifically designed for MSGIDs
//      so we do not have to open the property stream to check the MSGID during
//      QueueAdmin operations.
//  Parameters:
//      IN  szString        String to Hash
//  Returns:
//      DWORD hash
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline DWORD dwQueueAdminHash(LPCSTR szString)
{
    DWORD dwHash = 0;

    if (szString)
    {
        while (szString && *szString)
        {
            //Use Hash from Domhash.lib
            dwHash *= 131;  //First prime after ASCII character codes
            dwHash += *szString;
            szString++;
        }
    }
    return dwHash;
}

//FifoQ Map function used to implement a majority of queue admin functionality
//pvContext should be a pointer to a IQueueAdminMessageFilter interface
HRESULT QueueAdminApplyActionToMessages(IN CMsgRef *pmsgref, IN PVOID pvContext,
                                    OUT BOOL *pfContinue, OUT BOOL *pfDelete);

HRESULT HrQADMApplyActionToIMailMessages(IN IMailMsgProperties *pIMailMsgProperties,
                                         IN PVOID pvContext,
                                         OUT BOOL *pfContinue,
                                         OUT BOOL *pfDelete);

//
//  Common QAPI functinoality that both CMsgRef and IMailMsgProperties QAPI
//  providers will need.
//
HRESULT HrGetMsgInfoFromIMailMsgProperty(IMailMsgProperties* pIMailMsgProperties,
                                         MESSAGE_INFO* pMsgInfo,
                                         LINK_INFO_FLAGS flags = LI_TYPE_REMOTE_DELIVERY);

HRESULT HrQADMGetMsgSize(IMailMsgProperties* pIMailMsgProperties,
                         DWORD* pcbMsgSize);

VOID UpdateCountersForLinkType(CAQSvrInst *paqinst, DWORD dwLinkType);

VOID QueueAdminFileTimeToSystemTime(FILETIME *pft, SYSTEMTIME *pst);

#endif //__AQADMSVR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqdbgcnt.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdbgcnt.cpp
//
//  Description:  Implementation of CDeubgCountdown object
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/28/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqdbgcnt.h"

//---[ CDebugCountdown::ThreadStartRoutine ]-----------------------------------
//
//
//  Description: 
//      This is the main worker routine for the class it keeps on calling 
//      WaitForSingleObject... and will assert if it times out.
//  Parameters:
//      pvThis      The "this" ptr for this object
//  Returns:
//      Always 0
//  History:
//      10/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CDebugCountdown::ThreadStartRoutine(PVOID pvThis)
{
    _ASSERT(pvThis);
    DWORD dwWaitResult = 0;
    DWORD dwTick1 = 0;
    DWORD dwTick2 = 0;
    CDebugCountdown *pdbgcntThis = (CDebugCountdown *) pvThis;

    _ASSERT(DEBUG_COUNTDOWN_SIG == pdbgcntThis->m_dwSignature);

    while (DEBUG_COUNTDOWN_ENDED != pdbgcntThis->m_dwFlags)
    {
        _ASSERT(pdbgcntThis->m_hEvent);
        dwTick1 = GetTickCount();
        dwWaitResult = WaitForSingleObject(pdbgcntThis->m_hEvent, 
                                pdbgcntThis->m_dwMilliseconds);

        dwTick2 = GetTickCount();
        if (DEBUG_COUNTDOWN_SUSPENDED != pdbgcntThis->m_dwFlags)
        {
            //This assert is the whole reason for the existance of this object
            _ASSERT((WAIT_TIMEOUT != dwWaitResult) && "Failure to call stop hints... check threads");
        }
      
    }
    return 0;
}

CDebugCountdown::CDebugCountdown()
{
    m_dwSignature = DEBUG_COUNTDOWN_SIG;
    m_hEvent = NULL;
    m_dwMilliseconds = DEBUG_COUNTDOWN_DEFAULT_WAIT;
    m_hThread = NULL;
    m_dwFlags = 0;
}

CDebugCountdown::~CDebugCountdown()
{
    if (m_hEvent)
        _VERIFY(CloseHandle(m_hEvent));

    if (m_hThread)
        _VERIFY(CloseHandle(m_hThread));
}

//The following group of functions are defined as inline NULL-ops in retail 
//builds.  Below are there debug implementations
#ifdef DEBUG

//---[ CDebugCountdown::StartCountdown ]---------------------------------------
//
//
//  Description: 
//      Starts the countdown timer... will create an event and a thread to 
//      wait on that event.
//  Parameters:
//      dwMilliseconds      Milliseconds to wait before ASSERTING
//  Returns:
//      -
//  History:
//      10/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDebugCountdown::StartCountdown(DWORD dwMilliseconds)
{
    DWORD dwThreadId = 0;

    m_dwMilliseconds = dwMilliseconds;

    if (!m_hEvent)
        m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hEvent && !m_hThread)
    {
        m_hThread = CreateThread (NULL, 0, CDebugCountdown::ThreadStartRoutine, 
                                  this, 0, &dwThreadId);
    }
}

//---[ CDebugCountdown::SuspendCountdown ]-------------------------------------
//
//
//  Description: 
//      Suspends the countdown until the Next ResetCountdown().  Designed to 
//      be used when another component's shutdown routine is called (like cat),
//      and it is expected that they will provide there own stop hints.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDebugCountdown::SuspendCountdown()
{
    m_dwFlags = DEBUG_COUNTDOWN_SUSPENDED;
}

//---[ CDebugCountdown::ResetCountdown ]---------------------------------------
//
//
//  Description: 
//      Causes thread to wake up and start waiting again.  Will also reset a 
//      suspended countdown.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDebugCountdown::ResetCountdown()
{
    m_dwFlags = 0;
    if (m_hEvent)
        _VERIFY(SetEvent(m_hEvent));
}

//---[ CDebugCountdown::EndCountdown ]-----------------------------------------
//
//
//  Description: 
//      Terminates the countdown and waits for the waiting thread to exit.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDebugCountdown::EndCountdown()
{
    m_dwFlags = DEBUG_COUNTDOWN_ENDED;

    if (m_hEvent)
    {
        _VERIFY(SetEvent(m_hEvent));

        //Wait for thread to exit
        if (m_hThread)
        {
            WaitForSingleObject(m_hThread, INFINITE);
            _VERIFY(CloseHandle(m_hThread));
            m_hThread = NULL;
        }
    }
}


#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqnotify.h ===
//-----------------------------------------------------------------------------
//
//
//  File: AQNotify.h
//
//  Description:  Contains definitions for the notification interface used 
//      within Advanced Queuing..
//
//  Author: mikeswa
//
//  History:
//      11/2/98 - MikeSwa. Added IAQNotification 
//
//  Copyright (C) 1997, 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _AQNOTIFY_H_
#define _AQNOTIFY_H_

#include "aqincs.h"
class CAQStats;

//---[ IAQNotify ]-------------------------------------------------------
//
//
//  Description: 
//      Internal AQ Interface that is used to pass dynamic updates about 
//      queue size, volume, priority, etc...
//  Hungarian: 
//      pIAQNotify
//  
//-----------------------------------------------------------------------------
class IAQNotify
{
  public:
    virtual HRESULT HrNotify(CAQStats *paqstats, BOOL fAdd) = 0;
};


#endif //_AQNOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqdbgcnt.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdbgcnt.h
//
//  Description:  Provides a per-virtual server mechanism for ensuring that
//      the service stops and gives the proper stop hints while stopping. This
//      object creates a thread that will ASSERT if stop hints are not called
//      often enough.  This will allow you to access the debugger while the 
//      guilty function is taking so much time.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/27/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQDBGCOUNT_H__
#define __AQDBGCOUNT_H__


#define DEBUG_COUNTDOWN_SIG 'tnCD'
#define DEBUG_COUNTDOWN_DEFAULT_WAIT 20000

//define empty retail functions... to retail ops compile out
#ifdef DEBUG
#define EMPTY_RETAIL_VOID_FUNC
#else //retail
#define EMPTY_RETAIL_VOID_FUNC {}
#endif //DEBUG

//---[ CDebugCountdown ]-------------------------------------------------------
//
//
//  Description: 
//      Class that encapsulates functionality to ensure that stop hints are
//      called often enough
//  Hungarian: 
//      dbgcnt, pdbgcnt
//  
//-----------------------------------------------------------------------------
class CDebugCountdown
{
  protected:
    DWORD       m_dwSignature;
    HANDLE      m_hEvent;
    HANDLE      m_hThread;
    DWORD       m_dwMilliseconds;
    DWORD       m_dwFlags;

    enum //flags
    {
        DEBUG_COUNTDOWN_SUSPENDED = 0x00000001,
        DEBUG_COUNTDOWN_ENDED     = 0x00000002,
    };

    static DWORD ThreadStartRoutine(PVOID pThis);
  public:
    CDebugCountdown();
    ~CDebugCountdown();

    void StartCountdown(DWORD dwMilliseconds = DEBUG_COUNTDOWN_DEFAULT_WAIT) EMPTY_RETAIL_VOID_FUNC;
    void SuspendCountdown() EMPTY_RETAIL_VOID_FUNC;
    void ResetCountdown() EMPTY_RETAIL_VOID_FUNC;
    void EndCountdown() EMPTY_RETAIL_VOID_FUNC;
};

#endif //__AQDBGCOUNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqprecmp.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqprecmp.h
//
//  Description:  Precompiled CPP phatq\advqueue
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/19/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <aqprecmp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqinst.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqinst.cpp
//
//  Description: Implementation of the Advanced Queueing Server Instance
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <aqprecmp.h>
#include "dcontext.h"
#include "connmgr.h"
#include <smtpseo.h>
#include <cat.h>
#include "dsnevent.h"
#include "asyncq.inl"
#include "aqutil.h"
#include "smtpconn.h"
#include "aqrpcsvr.h"
#include "aqsize.h"
#include "propstrm.h"
#include "tran_evntlog.h"
#include "asyncadm.inl"

#define PRELOCAL_QUEUE_ID   0x00000001
#define PRECAT_QUEUE_ID     0x00000002
#define PREROUTING_QUEUE_ID 0x00000004
#define PRESUBMIT_QUEUE_ID  0x00000008

// externs defined in blockmgr and cmmprops to control debug code
DWORD g_fFillPropertyPages = 0;
DWORD g_fValidateSignatures = 0;
DWORD g_fForceCrashOnError = 0;

HRESULT MailTransport_Completion_SubmitMessage(HRESULT hrStatus, PVOID pvContext);
HRESULT MailTransport_Completion_PreCategorization(HRESULT hrStatus, PVOID pvContext);
HRESULT MailTransport_Completion_PostCategorization(HRESULT hrStatus, PVOID pvContext);

const CLSID CLSID_ExchangeStoreDriver       = {0x7BD80399,0xE37E,0x11d1,{0x9B,0xE2,0x00,0xA0,0xC9,0x5E,0x61,0x43}};

CPool CAQSvrInst::CAQLocalDeliveryNotify::s_pool(AQLD_SIG);

//---[ CAQSvrInst::fShouldRetryMessage ]---------------------------------------
//
//
//  Description:
//      Attempts to determine if the message has hit a hard failure (like the
//      backing store has been deleted).  This uses GetBinding to determine
//      The error returned by the store driver.  if it is FILE_NOT_FOUND,
//      then the backing store for the message has been deleted... or is no
//      longer valid (i.e. - the store restarting).
//  Parameters:
//      pIMailMsgProperties
//      fShouldBounceUsageIfRetry   TRUE - Should bounce usage on retry
//                                  FALSE - Never bounce usage
//          If the message is alreade associated with a msgref, this
//          should always be FALSE since bouncing the usage count
//          is done through the CMsgRef.
//  Returns:
//      TRUE    If we think we should retry the message
//      FALSE   If new *know* that the message should be dropped.  If unsure,
//              we will return TRUE.
//  History:
//      1/4/2000 - MikeSwa Created
//      4/10/2000 - MikeSwa Modified to better detect store shutdown/failure
//
//-----------------------------------------------------------------------------
BOOL  CAQSvrInst::fShouldRetryMessage(IMailMsgProperties *pIMailMsgProperties,
                                      BOOL fShouldBounceUsageIfRetry)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "fShouldRetryMessage");

    BOOL                fShouldRetry        = TRUE;
    BOOL                fHasShutdownLock    = FALSE;
    HRESULT             hr                  = S_OK;
    IMailMsgQueueMgmt   *pIMailMsgQueueMgmt = NULL;
    IMailMsgValidateContext *pIMailMsgValidateContext = NULL;

    _ASSERT(pIMailMsgProperties);

    if (!fTryShutdownLock())
        goto Exit;

    fHasShutdownLock = TRUE;

    //
    //  First check and see if the message context is still OK - if that
    //  doesn't work, we use the  HrValidateMessageConteNt call below
    //  and force a RFC822 rendering of the message (which can be a
    //  huge perf hit).
    //

    // QI for validation interface
    hr = pIMailMsgProperties->QueryInterface(
            IID_IMailMsgValidateContext,
            (LPVOID *)&pIMailMsgValidateContext);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to QI for IMailMsgValidateContext 0x%08X",hr);
        goto Exit;
    }

    // Validate the message context
    hr = pIMailMsgValidateContext->ValidateContext();

    DebugTrace((LPARAM) this,
        "ValidateContext returned 0x%08X", hr);

    if (hr == S_OK) //this message is fine
        goto Exit;
    else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        fShouldRetry = FALSE;
        goto Exit;
    }

    //
    //  If the above didn't work... try harder by verifying content.  This
    //  will open the handles... so we need to close them
    //
    hr = HrValidateMessageContent(pIMailMsgProperties);
    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        //The mailmsg has been deleted... we can just drop it.
        DebugTrace((LPARAM) pIMailMsgProperties,
            "WARNING: Backing store for mailmsg has been deleted.");
        fShouldRetry = FALSE;
        goto Exit;
    }
    else if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "GetBinding failed with hr - 0x%08X", hr);
        goto Exit;
    }

  Exit:

    //
    //  Bounce usage count if we have are sticking it back in the queue
    //  and the caller does not object
    //
    if (fShouldRetry && fShouldBounceUsageIfRetry)
    {
        hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt,
                                                (void **) &pIMailMsgQueueMgmt);
        if (SUCCEEDED(hr) && pIMailMsgQueueMgmt)
        {
            pIMailMsgQueueMgmt->ReleaseUsage();
            pIMailMsgQueueMgmt->AddUsage();
            pIMailMsgQueueMgmt->Release();
        }
    }

    if (pIMailMsgValidateContext)
        pIMailMsgValidateContext->Release();

    if (fHasShutdownLock)
        ShutdownUnlock();

    TraceFunctLeave();
    return fShouldRetry;
}

//thin wrapper for CAQSvrInst::fPreCatQueueCompletion member
BOOL  fPreCatQueueCompletionWrapper(IMailMsgProperties *pIMailMsgProperties,
                                    PVOID pvContext)
{
    // Testing : Cause intermittent failures in this queue
    if (fShouldFail(g_cPreCatQueueFailurePercent))
    {
        ((CAQSvrInst *)pvContext)->ScheduleInternalRetry(LI_TYPE_PENDING_CAT);
        return FALSE;
    }

    if (!((CAQSvrInst *)pvContext)->fPreCatQueueCompletion(pIMailMsgProperties))
        return !((CAQSvrInst *)pvContext)->fShouldRetryMessage(pIMailMsgProperties);
    else
        return TRUE;
}

//thin wrapper for CAQSvrInst::fPreLocalDeliveryCompletion
BOOL  fPreLocalDeliveryQueueCompletionWrapper(CMsgRef *pmsgref,
                                              PVOID pvContext)
{
    if (!((CAQSvrInst *)pvContext)->fPreLocalDeliveryQueueCompletion(pmsgref))
        return !(pmsgref->fShouldRetry());
    else
        return TRUE;
}

//thin wrapper for CAQSvrInst::fPostDSNQueueCompletion member
BOOL  fPostDSNQueueCompletionWrapper(IMailMsgProperties *pIMailMsgProperties,
                                    PVOID pvContext)
{
    return (SUCCEEDED(((CAQSvrInst *)pvContext)->HrInternalSubmitMessage(pIMailMsgProperties)));
}

//thin wrapper for CAQSvrInst::fPreRoutingQueueCompletion
BOOL  fPreRoutingQueueCompletionWrapper(IMailMsgProperties *pIMailMsgProperties,
                                        PVOID pvContext)
{
    // Testing : Cause intermittent failures in this queue
    if (fShouldFail(g_cPreRoutingQueueFailurePercent))
    {
        ((CAQSvrInst *)pvContext)->ScheduleInternalRetry(LI_TYPE_PENDING_ROUTING);
        return FALSE;
    }

    if (!((CAQSvrInst *)pvContext)->fRouteAndQueueMsg(pIMailMsgProperties))
        return !((CAQSvrInst *)pvContext)->fShouldRetryMessage(pIMailMsgProperties);
    else
        return TRUE;
}

//thin wrappers for handling internal asyncq queue failures
BOOL  fAsyncQHandleFailedMailMsg(IMailMsgProperties *pIMailMsgProperties,
                                        PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->HandleAQFailure(AQ_FAILURE_INTERNAL_ASYNCQ,
                        E_OUTOFMEMORY, pIMailMsgProperties);
    return TRUE;
}

BOOL  fAsyncQHandleFailedMsgRef(CMsgRef *pmsgref, PVOID pvContext)
{
    _ASSERT(pmsgref);
    if (pmsgref)
        pmsgref->RetryOnDelete();
    return TRUE;
}

//Thin wrapper(s) for AsyncQueueRetry - kick starting queues
void LocalDeliveryRetry(PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->AsyncQueueRetry(PRELOCAL_QUEUE_ID);
}

void CatRetry(PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->AsyncQueueRetry(PRECAT_QUEUE_ID);
}

void RoutingRetry(PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->AsyncQueueRetry(PREROUTING_QUEUE_ID);
}

void SubmitRetry(PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->AsyncQueueRetry(PRESUBMIT_QUEUE_ID);
}

//---[ CAQSvrInst::fPreSubmissionQueueCompletionWrapper ]----------------------
//
//
//  Description:
//      Completion function for PreSubmit Queue
//  Parameters:
//      pIMailMsgPropeties      IMailMsg to submit
//      pvContext               Ptr to CAQSvrInst
//  Returns:
//      TRUE    completed successfully
//      FALSE   message needs to be retried
//  History:
//      10/8/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL  CAQSvrInst::fPreSubmissionQueueCompletionWrapper(
                                    IMailMsgProperties *pIMailMsgProperties,
                                    PVOID pvContext)
{
    BOOL    fRetry = FALSE;
    HRESULT hr = S_OK;
    CAQSvrInst *paqinst = (CAQSvrInst *)pvContext;

    _ASSERT(paqinst);

    // Testing : Cause intermittent failures in this queue
    if (fShouldFail(g_cPreSubmitQueueFailurePercent))
    {
        paqinst->ScheduleInternalRetry(LI_TYPE_PENDING_SUBMIT);
        return FALSE;
    }

    InterlockedDecrement((PLONG) &(paqinst->m_cCurrentMsgsPendingSubmit));
    hr = (paqinst->HrInternalSubmitMessage(pIMailMsgProperties));
    if (FAILED(hr))
    {
        if (paqinst->fShouldRetryMessage(pIMailMsgProperties))
        {
            fRetry = TRUE;
            InterlockedIncrement((PLONG) &(paqinst->m_cCurrentMsgsPendingSubmit));

            //
            //  We need to kick off a retry as well for the presubmit queue
            //
            paqinst->ScheduleInternalRetry(LI_TYPE_PENDING_SUBMIT);

        }
    }

    SleepForPerfAnalysis(g_dwSubmitQueueSleepMilliseconds);
    return (!fRetry);
}


DEBUG_DO_IT(CAQSvrInst *g_paqinstLastDeleted = NULL;); //used to find the last deleted in CDB

#define TRACE_COUNTERS \
{\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs pending submission event for server 0x%08X", m_cCurrentMsgsPendingSubmitEvent, this); \
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs pending pre-cat event for server 0x%08X", m_cCurrentMsgsPendingPreCatEvent, this); \
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs pending post-cat event for server 0x%08X", m_cCurrentMsgsPendingPostCatEvent, this); \
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs submited (total post cat) for delivery on server 0x%08X", m_cTotalMsgsQueued, this);\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs pending categorization for server 0x%08X", m_cCurrentMsgsPendingCat, this);\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs ack'd on server 0x%08X", m_cMsgsAcked, this);\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs ack'd for retry on server 0x%08X", m_cMsgsAckedRetry, this);\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs delivered local on server 0x%08X", m_cMsgsDeliveredLocal, this);\
}

// {407525AC-62B5-11d2-A694-00C04FA3490A}
static const GUID g_guidDefaultRouter =
{ 0x407525ac, 0x62b5, 0x11d2, { 0xa6, 0x94, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

//GUID for local queue
// {34E2DCCC-C91A-11d2-A6B1-00C04FA3490A}
static const GUID g_guidLocalQueue =
{ 0x34e2dccc, 0xc91a, 0x11d2, { 0xa6, 0xb1, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

// GUID for presubmission queue
// {D99AAC44-BEE9-4f9f-8D47-FB12E1443B9A}
static const GUID g_guidPreSubmissionQueue =
{ 0xd99aac44, 0xbee9, 0x4f9f, { 0x8d, 0x47, 0xfb, 0x12, 0xe1, 0x44, 0x3b, 0x9a } };

// GUID for precat queue
// {B608067E-85DB-4f4e-9FE9-008A4072CCDC}
static const GUID g_guidPreCatQueue =
{ 0xb608067e, 0x85db, 0x4f4e, { 0x9f, 0xe9, 0x0, 0x8a, 0x40, 0x72, 0xcc, 0xdc } };

// GUID for prerouting queue
// {F1B4C8FD-2928-427d-AC0D-23AF0DCFC31F}
static const GUID g_guidPreRoutingQueue =
{ 0xf1b4c8fd, 0x2928, 0x427d, { 0xac, 0xd, 0x23, 0xaf, 0xd, 0xcf, 0xc3, 0x1f } };

// GUID for post-DSN generation queue
// {D076B629-6030-405f-ADC9-D888703E072E}
static const GUID g_guidPostDSNGenerationQueue =
{ 0xd076b629, 0x6030, 0x405f, { 0xad, 0xc9, 0xd8, 0x88, 0x70, 0x3e, 0x7, 0x2e } };

//---[ CAQSvrInst::CAQSvrInst ]------------------------------------------------
//
//
//  Description:
//      Class constuctor
//  Parameters:
//      SMTP_SERVER_INSTANCE *pssi - ptr to SMTP server instance object
//      pISMTPServer - interface used to handle local deliverys
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CAQSvrInst::CAQSvrInst(DWORD dwServerInstance,
                       ISMTPServer *pISMTPServer)
                       : m_mglSupersedeIDs(&m_cSupersededMsgs),
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4355)

                         m_asyncqPreLocalDeliveryQueue("LocalAsyncQueue", LOCAL_LINK_NAME,
                                                       &g_guidLocalQueue, 0, this),

                        m_asyncqPreSubmissionQueue("PreSubmissionQueue",
                               PRESUBMISSION_QUEUE_NAME,
                               &g_guidPreSubmissionQueue,
                               0,
                               this),
                        m_asyncqPreCatQueue("PreCatQueue",
                                PRECAT_QUEUE_NAME,
                                &g_guidPreCatQueue,
                                0,
                                this),
                        m_asyncqPreRoutingQueue("PreRoutingQueue",
                                PREROUTING_QUEUE_NAME,
                                &g_guidPreRoutingQueue,
                                0,
                                this),
                        m_asyncqPostDSNQueue("PostDSNGenerationQueue",
                                POSTDSN_QUEUE_NAME,
                                &g_guidPostDSNGenerationQueue,
                                0,
                                this),
                        m_dsnsink((IUnknown *)(IAQServerEvent *)this),
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif
                         m_slPrivateData("CAQSvrInst",
                                         SHARE_LOCK_INST_TRACK_DEFAULTS |
                                         SHARE_LOCK_INST_TRACK_SHARED_THREADS |
                                         SHARE_LOCK_INST_TRACK_CONTENTION, 500)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::CAQSvrInst");
    _ASSERT(pISMTPServer);

    m_dwSignature = CATMSGQ_SIG;
    m_dwFlavorSignature = g_dwFlavorSignature;
    m_cbClasses = g_cbClasses;

    //Init counters
    m_cTotalMsgsQueued = 0;        //# of messages on dest queues (after fanout)
    m_cMsgsAcked = 0;         //# of messages that have been acknowledged
    m_cMsgsAckedRetry = 0;    //# of messages acked with retry all
    m_cMsgsDeliveredLocal= 0; //# of messages delivered to local store
    m_cCurrentMsgsPendingSubmitEvent = 0; //current # of messages in
                                          //submission event
    m_cCurrentMsgsPendingPreCatEvent = 0; // current # of messages in
                                          // precat event
    m_cCurrentMsgsPendingPostCatEvent = 0; //current # of messages in
                                           //post-categorization event
    m_cCurrentMsgsSubmitted = 0; //# total msgs in system
    m_cCurrentMsgsPendingCat = 0; //# Msgs that have not be categorized
    m_cCurrentMsgsPendingRouting = 0; //# Msgs that have been cat.
                                //but have not been completely queued
    m_cCurrentMsgsPendingDelivery = 0; //# Msgs pending remote delivery
    m_cCurrentMsgsPendingLocal = 0; //# Msgs pending local delivery
    m_cCurrentMsgsPendingRetry = 0; //# Msgs with unsuccessful attempts
    m_cCurrentQueueMsgInstances = 0;  //# of msgs instances pending
                                //remote deliver (>= #msgs)
    m_cCurrentRemoteDestQueues = 0; //# of DestMsgQueues created
    m_cCurrentRemoteNextHops = 0; //# of Next Hop links created
    m_cCurrentRemoteNextHopsEnabled = 0; //# of links that can have connections
    m_cCurrentRemoteNextHopsPendingRetry = 0; //# of links pending retry
    m_cCurrentRemoteNextHopsPendingSchedule = 0; //# of links pending schedule
    m_cCurrentRemoteNextHopsFrozenByAdmin = 0; //# of links frozen by admin
    m_cTotalMsgsSubmitted = 0; //total # of messages submitted to AQ
    m_cTotalExternalMsgsSubmitted = 0; //Sumitted via an external interface
    m_cMsgsAckedRetryLocal = 0;
    m_cCurrentMsgsPendingLocalRetry = 0;
    m_cDMTRetries  = 0;
    m_cTotalMsgsTURNETRNDelivered = 0;
    m_cCurrentMsgsPendingDeferredDelivery = 0;
    m_cCurrentResourceFailedMsgsPendingRetry = 0;
    m_cTotalMsgsBadmailed = 0;
    m_cBadmailNoRecipients = 0;
    m_cBadmailHopCountExceeded = 0;
    m_cBadmailFailureGeneral = 0;
    m_cBadmailBadPickupFile = 0;
    m_cBadmailEvent = 0;
    m_cBadmailNdrOfDsn = 0;
    m_cTotalDSNFailures = 0;
    m_cCurrentMsgsInLocalDelivery = 0;
    m_cTotalResetRoutes = 0;
    m_cCurrentPendingResetRoutes = 0;
    m_cCurrentMsgsPendingSubmit = 0;


    //Counters to keep track of the number of messages in Cat
    m_cCatMsgCalled = 0;
    m_cCatCompletionCalled = 0;

    //DSN Related counters
    m_cDelayedDSNs = 0;
    m_cNDRs = 0;
    m_cDeliveredDSNs = 0;
    m_cRelayedDSNs = 0;
    m_cExpandedDSNs = 0;

    m_cSupersededMsgs = 0; //number of messages superseded

    m_dwDelayExpireMinutes = g_dwDelayExpireMinutes;
    m_dwNDRExpireMinutes = g_dwNDRExpireMinutes;
    m_dwLocalDelayExpireMinutes = g_dwDelayExpireMinutes;
    m_dwLocalNDRExpireMinutes = g_dwNDRExpireMinutes;


    m_dwInitMask = 0;
    m_prstrDefaultDomain = NULL;
    m_prstrBadMailDir = NULL;
    m_prstrCopyNDRTo = NULL;
    m_prstrServerFQDN = NULL;

    m_dwDSNLanguageID = 0;
    m_dwDSNOptions = DSN_OPTIONS_DEFAULT;

    if (pISMTPServer)
        pISMTPServer->AddRef();

    m_pISMTPServer = pISMTPServer;

    // Get the ISMTPServerEx interface
    {
        HRESULT     hr;

        m_pISMTPServerEx = NULL;
        hr = m_pISMTPServer->QueryInterface(
                IID_ISMTPServerEx,
                (LPVOID *)&m_pISMTPServerEx);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) m_pISMTPServer,
                "Unable to QI for ISMTPServerEx 0x%08X",hr);

            m_pISMTPServerEx = NULL;
        }

        m_pISMTPServerAsync = NULL;
        hr = m_pISMTPServer->QueryInterface(
                IID_ISMTPServerAsync,
                (LPVOID *)&m_pISMTPServerAsync);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) m_pISMTPServer,
                "Unable to QI for ISMTPServerAsync 0x%08X",hr);

            m_pISMTPServerAsync = NULL;
        }
    }

    m_hCat = INVALID_HANDLE_VALUE;
    m_dwServerInstance = dwServerInstance;
    m_pConnMgr = NULL;
    m_pIMessageRouterDefault = NULL;

    //Retry stuff
    m_dwFirstTierRetrySeconds = g_dwFirstTierRetrySeconds;

    m_cLocalRetriesPending = 0;  //used for moderating local retries
    m_cCatRetriesPending = 0; //used for moderating cat retires
    m_cRoutingRetriesPending = 0; //used for moderating routing retries
    m_cSubmitRetriesPending = 0; //used for moderating submit retries

    m_pIRouterReset = NULL;

    //Add to global list of virtual servers
    m_liVirtualServers.Blink = &g_liVirtualServers;
    g_pslGlobals->ExclusiveLock();
    m_liVirtualServers.Flink = g_liVirtualServers.Flink;
    g_liVirtualServers.Flink->Blink = &m_liVirtualServers;
    g_liVirtualServers.Flink = &m_liVirtualServers;
    g_pslGlobals->ExclusiveUnlock();

    //
    //  Assume (until proven otherwise) mailmsg returns the handle count
    //
    m_fMailMsgReportsNumHandles = TRUE;

    m_defq.Initialize(this);

    TraceFunctLeave();

}

//---[ CAQSvrInst::~CAQSvrInst ]--------------------------------------------
//
//
//  Description:
//      Class destuctor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CAQSvrInst::~CAQSvrInst()
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::~CAQSvrInst");

    //make sure that all cleanup was done
    HrDeinitialize();  //can be called multiple times

    if (m_pISMTPServer)
        m_pISMTPServer->Release();

    if (m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    if (m_pISMTPServerAsync)
        m_pISMTPServerAsync->Release();

    if (m_pConnMgr)
    {
        m_pConnMgr->Release();
        m_pConnMgr = NULL;
    }

    if (m_prstrDefaultDomain)
        m_prstrDefaultDomain->Release();

    if (m_prstrBadMailDir)
        m_prstrBadMailDir->Release();

    if (m_prstrCopyNDRTo)
        m_prstrCopyNDRTo->Release();

    if (m_prstrServerFQDN)
        m_prstrServerFQDN->Release();

    //Take out of list of global list
    g_pslGlobals->ExclusiveLock();
    m_liVirtualServers.Flink->Blink = m_liVirtualServers.Blink;
    m_liVirtualServers.Blink->Flink = m_liVirtualServers.Flink;
    g_pslGlobals->ExclusiveUnlock();
    m_liVirtualServers.Flink = NULL;
    m_liVirtualServers.Flink = NULL;

    MARK_SIG_AS_DELETED(m_dwSignature);
    DEBUG_DO_IT(g_paqinstLastDeleted = this;);
    TraceFunctLeave();

}


//---[ CAQSvrInst::HrInitialize ]--------------------------------------------
//
//
//  Description:
//      Initialization of CAQSvrInst virtual server instance object.
//  Parameters:
//      IN  szUserName           User name to log on DS with
//      IN  szDomainName         Domain name to log on to DS with
//      IN  szPassword           Password to authenticate to DS with
//      IN  pServiceStatusFn     Server status callback function
//      IN  pvServiceContext     Context to pass back for callback function
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrInitialize(
                    IN  LPSTR   szUserName,
                    IN  LPSTR   szDomainName,
                    IN  LPSTR   szPassword,
                    IN  PSRVFN  pServiceStatusFn,
                    IN  PVOID   pvServiceContext)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrInitialize");
    HRESULT hr = S_OK;
    IMailTransportSetRouterReset *pISetRouterReset = NULL;

    //
    // init SEO
    //
    hr = m_CSMTPSeoMgr.HrInit(m_dwServerInstance);
    if (FAILED(hr)) {
        goto Exit;
    }

    m_pIMessageRouterDefault = new CAQDefaultMessageRouter(
                                (GUID *) &g_guidDefaultRouter, this);
    if (!m_pIMessageRouterDefault)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    m_fmq.Initialize(this);

    hr = CAQRpcSvrInst::HrInitializeAQServerInstanceRPC(this,
                                                        m_dwServerInstance,
                                                        m_pISMTPServer);
    if (FAILED(hr))
        goto Exit;

    //Initialize Message Categorization
    hr = CatInit(
        NULL,
        pServiceStatusFn,
        pvServiceContext,
        m_pISMTPServer,
        (IAdvQueueDomainType *) this,
        m_dwServerInstance,
        &m_hCat);

    if (FAILED(hr))
    {
        m_hCat = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    //Pass RouterReset Interface to ISMTPServer
    if (m_pISMTPServer)
    {
        hr = m_pISMTPServer->QueryInterface(IID_IMailTransportSetRouterReset,
                                            (void **) &pISetRouterReset);
        if (SUCCEEDED(hr))
        {
            m_dwInitMask |= CMQ_INIT_ROUTER_RESET;
            _ASSERT(pISetRouterReset);
            hr = pISetRouterReset->RegisterResetInterface(m_dwServerInstance,
                                (IMailTransportRouterReset *) this);
            _ASSERT(SUCCEEDED(hr)); //something is wrong if this failed
            pISetRouterReset->Release();
            pISetRouterReset = NULL;
        }

        hr = m_pISMTPServer->QueryInterface(IID_IMailTransportRouterReset,
                                            (void **) &m_pIRouterReset);
        if (FAILED(hr))
            m_pIRouterReset = NULL;
    }

    hr = m_dmt.HrInitialize(this, &m_asyncqPreLocalDeliveryQueue,
                        &m_asyncqPreCatQueue, &m_asyncqPreRoutingQueue,
                        &m_asyncqPreSubmissionQueue);
    if (FAILED(hr))
        goto Exit;

    m_dwInitMask |= CMQ_INIT_DMT;

    hr = m_dct.HrInit();
    if (FAILED(hr))
        goto Exit;

    m_dwInitMask |= CMQ_INIT_DCT;

    m_pConnMgr = new CConnMgr;
    if (NULL == m_pConnMgr)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = m_pConnMgr->HrInitialize(this);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_CONMGR;

    hr = m_dsnsink.HrInitialize();
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_DSN;

    hr = m_asyncqPreCatQueue.HrInitialize(g_cMaxSyncCatQThreads,
                                          g_cItemsPerCatQAsyncThread,
                                          g_cItemsPerCatQSyncThread,
                                          this,
                                          fPreCatQueueCompletionWrapper,
                                          fAsyncQHandleFailedMailMsg,
                                          NULL,
                                          g_cMaxPendingCat);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_PRECATQ;

    hr = m_asyncqPreLocalDeliveryQueue.HrInitialize(g_cMaxSyncLocalQThreads,
                                                    g_cItemsPerLocalQAsyncThread,
                                                    g_cItemsPerLocalQSyncThread,
                                                    this,
                                                    fPreLocalDeliveryQueueCompletionWrapper,
                                                    fAsyncQHandleFailedMsgRef,
                                                    HrWalkPreLocalQueueForDSN,
                                                    g_cMaxPendingLocal);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_PRELOCQ;

    hr = m_asyncqPostDSNQueue.HrInitialize(g_cMaxSyncPostDSNQThreads,
                                          g_cItemsPerPostDSNQAsyncThread,
                                          g_cItemsPerPostDSNQSyncThread,
                                          this,
                                          fPostDSNQueueCompletionWrapper,
                                          fAsyncQHandleFailedMailMsg,
                                          NULL);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_POSTDSNQ;

    hr = m_asyncqPreRoutingQueue.HrInitialize(g_cMaxSyncRoutingQThreads,
                                          g_cItemsPerRoutingQAsyncThread,
                                          g_cItemsPerRoutingQSyncThread,
                                          this,
                                          fPreRoutingQueueCompletionWrapper,
                                          fAsyncQHandleFailedMailMsg,
                                          NULL);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_ROUTINGQ;

    hr = m_asyncqPreSubmissionQueue.HrInitialize(g_cMaxSyncSubmitQThreads,
                                          g_cItemsPerSubmitQAsyncThread,
                                          g_cItemsPerSubmitQSyncThread,
                                          this,
                                          fPreSubmissionQueueCompletionWrapper,
                                          fAsyncQHandleFailedMailMsg,
                                          NULL);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_SUBMISSIONQ;

    hr = m_aqwWorkQueue.HrInitialize(g_cItemsPerWorkQAsyncThread);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_WORKQ;

    m_dwInitMask |= CMQ_INIT_OK;  //everything was initialized

    // create the router object
    hr = HrTriggerInitRouter();


  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::HrDeinitialize() ]----------------------------------------
//
//
//  Description:
//      Signals server shutdown
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      Whatever error codes are generated during the shutdown process
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrDeinitialize");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    DWORD   i  = 0;
    IMailTransportSetRouterReset *pISetRouterReset = NULL;
#ifdef DEBUG
    DWORD   cLocalDeliveryShutdownSeconds = 60;
#endif

    //
    // Tell categorizer to stop categorizing before we block on the
    // shutdown lock.
    //
    if (INVALID_HANDLE_VALUE != m_hCat)
    {
        CatPrepareForShutdown(m_hCat);
    }

    //
    //  We have hit this assert a few times due to NT stress failures.
    //  This is only really useful if at least one messsage has been
    //  sent.  The assert is basically useless if we hit it in KD during
    //  NT stress runs.
    //
    if (m_cTotalMsgsSubmitted)
        m_dbgcnt.StartCountdown();

    ServerStopHintFunction();
    //Get Exclusive shutdown lock
    SignalShutdown();

    ServerStopHintFunction();
    //Turn off RPC for this instance
    hrTmp = CAQRpcSvrInst::HrDeinitializeAQServerInstanceRPC(this, m_dwServerInstance);
    if (FAILED(hrTmp))
    {
        ErrorTrace((LPARAM) this,
            "Error shutting down Aqueue RPC hr - 0x%08X", hrTmp);
        if (SUCCEEDED(hr))
            hr = hrTmp;
    }

    // wait for all outstanding local deliveries to complete
    while (!(m_asyncqPreLocalDeliveryQueue.fNoPendingAsyncCompletions())) {
        _ASSERT(--cLocalDeliveryShutdownSeconds > 0);
        ServerStopHintFunction();
        Sleep(1000);
    }

    ServerStopHintFunction();
    m_fmq.Deinitialize();
    ServerStopHintFunction();
    m_defq.Deinitialize();

    m_dwInitMask &= ~CMQ_INIT_DCT; //no de-initialize function to call

    //stop any pending categorization
    ServerStopHintFunction();
    if (INVALID_HANDLE_VALUE != m_hCat)
    {
        m_dbgcnt.SuspendCountdown();
        hrTmp  = CatCancel(m_hCat);
        if FAILED(hrTmp)
        {
            ErrorTrace((LPARAM) this,
                "ERROR:  Categorization shutdown error hr - 0x%08X", hrTmp);
            if (SUCCEEDED(hr))
                hr = hrTmp;
        }

        //shutdow message categorization
        CatTerm(m_hCat);

        m_dbgcnt.ResetCountdown();

        m_hCat = INVALID_HANDLE_VALUE;
    }

    //Tell ISMTPServer to set RouterReset Interface to NULL
    ServerStopHintFunction();
    if (m_pISMTPServer)
    {
        hr = m_pISMTPServer->QueryInterface(IID_IMailTransportSetRouterReset,
                                            (void **) &pISetRouterReset);
        if (SUCCEEDED(hr))
        {
            m_dwInitMask &= ~CMQ_INIT_ROUTER_RESET;
            _ASSERT(pISetRouterReset);
            hr = pISetRouterReset->RegisterResetInterface(m_dwServerInstance,
                                NULL);
            _ASSERT(SUCCEEDED(hr)); //something is wrong if this failed
            pISetRouterReset->Release();
            pISetRouterReset = NULL;
        }
    }

    ServerStopHintFunction();
    if (m_pIRouterReset)
    {
        m_pIRouterReset->Release();
        m_pIRouterReset = NULL;
    }

    ServerStopHintFunction();
    if (CMQ_INIT_DMT & m_dwInitMask)
    {
        m_dwInitMask ^= CMQ_INIT_DMT;
        hrTmp = m_dmt.HrDeinitialize();
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
    }

    //Deinitializing the connection manager will also release the retry
    //sink to make all it's callbacks.
    ServerStopHintFunction();
    if (NULL != m_pConnMgr)
    {
        if (CMQ_INIT_CONMGR & m_dwInitMask)
        {
            _ASSERT(m_pISMTPServer);
            m_dwInitMask ^= CMQ_INIT_CONMGR;
            hrTmp = m_pConnMgr->HrDeinitialize();
            if (FAILED(hrTmp) && SUCCEEDED(hr))
                hr = hrTmp;
        }

        m_pConnMgr->Release();
        m_pConnMgr = NULL;
    }

    //deinitialize pre-local delivery queue
    ServerStopHintFunction();
    if (CMQ_INIT_PRELOCQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPreLocalDeliveryQueue.HrDeinitialize(
            HrWalkMsgRefQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_PRELOCQ;
    }

    //deinitialize pre-cat delivery queue
    ServerStopHintFunction();
    if (CMQ_INIT_PRECATQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPreCatQueue.HrDeinitialize(
            HrWalkMailMsgQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_PRECATQ;
    }

    //deinitialize post DNS queue
    ServerStopHintFunction();
    if (CMQ_INIT_POSTDSNQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPostDSNQueue.HrDeinitialize(
            HrWalkMailMsgQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_POSTDSNQ;
    }

    //deinitialize pre-routing  queue
    ServerStopHintFunction();
    if (CMQ_INIT_ROUTINGQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPreRoutingQueue.HrDeinitialize(
            HrWalkMailMsgQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_ROUTINGQ;
    }

    //deinitialize pre-submit queue
    ServerStopHintFunction();
    if (CMQ_INIT_SUBMISSIONQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPreSubmissionQueue.HrDeinitialize(
            HrWalkMailMsgQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_SUBMISSIONQ;
    }

    ServerStopHintFunction();
    m_mglSupersedeIDs.Deinitialize(this);

    ServerStopHintFunction();
    if (CMQ_INIT_WORKQ & m_dwInitMask)
    {
        hrTmp = m_aqwWorkQueue.HrDeinitialize(this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_WORKQ;
    }

    //the following bits don't have specific delinitialize functions
    m_dwInitMask &= ~(CMQ_INIT_DSN | CMQ_INIT_OK);

    ServerStopHintFunction();
    if (m_pIMessageRouterDefault)
    {
        m_pIMessageRouterDefault->Release();
        m_pIMessageRouterDefault = NULL;
    }


    // let SEO do it's cleanup
    m_CSMTPSeoMgr.Deinit();

    m_dbgcnt.EndCountdown();
    _ASSERT((!m_dwInitMask) || FAILED(hr));

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::HrGetIConnectionManager ]---------------------------------
//
//
//  Description:
//      Returns the IConnectionManager interface for this AdvancedQueuing instance
//  Parameters:
//      OUT ppIConnectionManger     Returned interface
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetIConnectionManager(
               OUT IConnectionManager **ppIConnectionManager)
{
    HRESULT hr = S_OK;
    _ASSERT(ppIConnectionManager);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    m_pConnMgr->AddRef();
    *ppIConnectionManager = m_pConnMgr;

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::cCountMsgsForHandleThrottling ]-----------------------------
//
//
//  Description:
//      returns the number of messages in the system that
//      is used elsewhere to decide to start/stop handle throttling
//
//
//  Parameters:
//      pIMailMsgProperties     pointer to MailMsg interface to query
//
//  Returns:
//      DWORD returned is:
//
//      - With Windows2000 RTM mailmsg.dll:
//        count of all messages in the system
//
//      - With Windows2000 SP1 mailmsg.dll:
//        count of open property stream handles
//        OR
//        count of all messages in the system
//        if the former can't be obtained
//
//  History:
//      1/28/00 aszafer Created
//-----------------------------------------------------------------------------

#ifndef IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES
#define IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES   0x3004
#endif

DWORD CAQSvrInst::cCountMsgsForHandleThrottling(IN IMailMsgProperties *pIMailMsgProperties)
{
    HRESULT hr = MAILMSG_E_PROPNOTFOUND;  //Count as failure if we do not call
    DWORD dwStreamOpenHandlesCount = 0;


    TraceFunctEnterEx((LPARAM) this, "Entering CAQSvrInst::cCountMsgsForHandleThrottling");

    //
    //  We should never call into mailmsg if we know we do not have the correct version.
    //  This will load the property stream and cause us to potentially access the
    //  properties in an unsafe way.
    //
    if (m_fMailMsgReportsNumHandles && pIMailMsgProperties)
    {
        hr = pIMailMsgProperties->GetDWORD(
            IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES,
            &dwStreamOpenHandlesCount);

        if(FAILED(hr))
        {
            m_fMailMsgReportsNumHandles = FALSE;
            //must be RTM version of mailmsg.dll
            DebugTrace((LPARAM) this, "GetDWORD(IMMPID*OPEN_PROPERTY_STREAM_HANDLES) failed hr %08lx", hr);
            DebugTrace((LPARAM) this, "returning g_cIMsgInSystem + m_cCurrentMsgsPendingSubmit");
        }
    }



    TraceFunctLeaveEx((LPARAM) this);

    return SUCCEEDED(hr) ? dwStreamOpenHandlesCount : g_cIMsgInSystem + m_cCurrentMsgsPendingSubmit ;
}


//---[ CAQSvrInst::QueueMsgForLocalDelivery ]----------------------------------
//
//
//  Description:
//      Queues a single message for local delivery
//  Parameters:
//      IN  pmsgref     Message Ref to deliver locally
//  Returns:
//      -
//  History:
//      1/26/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::QueueMsgForLocalDelivery(CMsgRef *pmsgref, BOOL fLocalLink)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::QueueMsgForLocalDelivery");
    HRESULT hr = S_OK;
    CAQStats aqstat;
    CLinkMsgQueue *plmq = NULL;

    //
    // Get the stats from the msgref
    //
    pmsgref->GetStatsForMsg(&aqstat);

    //
    //  Get the local link and update the stats
    //
    plmq = m_dmt.plmqGetLocalLink();
    if (plmq)
    {
        hr = plmq->HrNotify(&aqstat, TRUE);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "HrNotify failed... local stats innaccurate 0x%08X", hr);
            hr = S_OK;
        }
    }

    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingLocal);
    hr = m_asyncqPreLocalDeliveryQueue.HrQueueRequest(pmsgref);
    if (FAILED(hr))
    {
        hr = plmq->HrNotify(&aqstat, FALSE);
        pmsgref->RetryOnDelete();
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingLocal);
    }

    //
    //  Make sure we release the local link if we got it
    //
    if (plmq)
        plmq->Release();

    TraceFunctLeave();
}

//---[ CAQSvrInst::fRouteAndQueueMsg ]-----------------------------------------
//
//
//  Description:
//      Add a Categorized Message to the CMT to be queue for delivery
//  Parameters:
//      IN pIMailMsgProperties      Msg to routing and queue for delivery
//  Returns:
//      TRUE if message has been successfully routed and queued for delivery
//              (or if errors have been handled internally)
//      FALSE if message needs to be requeued for a later retry
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fRouteAndQueueMsg(IN IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::fRouteAndQueueMsg");
    HRESULT       hr        = S_OK;
    HRESULT       hrTmp     = S_OK;
    DWORD         cDomains  = 0; //number of domains message will be deliver to
    DWORD         cQueues   = 0; //number of queues for the message
    DWORD         i         = 0; //loop counter
    DWORD         cLocalRecips = 0;
    DWORD         cRemoteRecips = 0;
    DWORD         dwDMTVersion = 0;
    CMsgRef       *pmsgref  = NULL;
    CDestMsgQueue **rgpdmq  = NULL;
    BOOL          fLocked   = FALSE;
    BOOL          fRoutingLock = FALSE;
    BOOL          fLocal    = FALSE;
    BOOL          fRemote   = FALSE;
    BOOL          fOnDMQ    = FALSE;
    BOOL          fDMTLocked = FALSE;
    BOOL          fKeepTrying = TRUE;
    BOOL          fGotMsgType = FALSE;
    BOOL          fReturn = TRUE;
    DWORD         dwMessageType = 0;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    IMailMsgRecipients *pIRecipList = NULL;
    IMessageRouter *pIMessageRouter = NULL;

    _ASSERT(CATMSGQ_SIG == m_dwSignature);


    _ASSERT(pIMailMsgProperties);
    if (NULL == pIMailMsgProperties)
    {
        hr = E_INVALIDARG;
        ErrorTrace((LPARAM) this, "NULL pIMailMsgProperties");
        goto Exit;
    }

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt, (PVOID *) &pIMailMsgQueueMgmt);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to QI for IID_IMailMsgQueueMgmt");
        goto Exit;
    }

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients, (PVOID *) &pIRecipList);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to QI for IID_IMailMsgRecipients");
        goto Exit;
    }


    //get a shared lock to guard against shutdown.
    if (!fTryShutdownLock())
    {
        DebugTrace((LPARAM) pIMailMsgProperties,
            "Shutdown detecting while routing a message... bailing");
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    hr = pIRecipList->DomainCount(&cDomains);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to get a domain count from the message - hr 0x08X", hr);
        goto Exit;
    }

    if (!cDomains) //and hence no recipients
    {
        DebugTrace((LPARAM) pIMailMsgProperties,
            "No domains on message - turfing message");
        //This could be a completely valid case (like an empty DL)
        //In this case we just turf the message and act as if everything is fine
        DecMsgsInSystem(); //update our counters
        HandleBadMail(pIMailMsgProperties, TRUE, NULL, AQUEUE_E_NO_RECIPIENTS, FALSE);
        InterlockedIncrement((PLONG) &m_cBadmailNoRecipients);

        //Delete the message
        HrDeleteIMailMsg(pIMailMsgProperties);
        hr = S_OK;
        goto Exit;
    }

    //Check Message to see if there are unresolved recipients to NDR
    hr = HrNDRUnresolvedRecipients(pIMailMsgProperties, pIRecipList);
    if (FAILED(hr))
    {
        HandleAQFailure(AQ_FAILURE_CANNOT_NDR_UNRESOLVED_RECIPS, hr, pIMailMsgProperties);
        ErrorTrace((LPARAM) this, "ERROR: Unable to NDR message - hr 0x%08X", hr);
        //just drop message for now... we cannot let it continue until this succeeds
        hr = S_OK;
        goto Exit;
    }

    if (S_FALSE == hr)
    {
        //There is no work to be done for this message - delete it
        HrDeleteIMailMsg(pIMailMsgProperties);
        DebugTrace((LPARAM) pIMailMsgProperties,
                  "INFO: Deleting message after NDRing all unresolved recips");
        hr = S_OK;
        DecMsgsInSystem(); //update our counters
        goto Exit;
    }

    rgpdmq = (CDestMsgQueue **) pvMalloc(cDomains * sizeof(CDestMsgQueue *));
    if (NULL == rgpdmq)
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to alloc array of %d Queues", cDomains);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    RoutingShareLock();
    fRoutingLock = TRUE;

    hr = HrTriggerGetMessageRouter(pIMailMsgProperties, &pIMessageRouter);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to get message router - HR 0x%08X", hr);
        goto Exit;
    }

    hr = pIMessageRouter->GetMessageType(pIMailMsgProperties, &dwMessageType);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to get message type - HR 0x%08X", hr);
        goto Exit;
    }

    //We own a reference to the message type now
    fGotMsgType = TRUE;

    pmsgref = new((DWORD) cDomains) CMsgRef(cDomains, pIMailMsgQueueMgmt, pIMailMsgProperties,
                this, dwMessageType, pIMessageRouter->GetTransportSinkID());

    if (NULL == pmsgref)
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to allocate CMsgRef for %d domains", cDomains);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Loop until we get consistant info on where to queue message (based on
    //DMT version number).
    while (fKeepTrying)
    {
        dwDMTVersion = m_dmt.dwGetDMTVersion();
        hr = pmsgref->HrInitialize(pIRecipList, pIMessageRouter, dwMessageType,
                            &cLocalRecips, &cRemoteRecips, &cQueues, rgpdmq);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr)
            {
                //Some sort of config/routing change... we need to retry the
                //message
                fGotMsgType = FALSE;
                hr = HrReGetMessageType(pIMailMsgProperties,
                                    pIMessageRouter, &dwMessageType);
                if (FAILED(hr))
                {
                    ErrorTrace((LPARAM) pIMailMsgProperties,
                        "HrReGetMessageType failed with hr - 0x%08X", hr);
                    goto Exit;
                }
                fGotMsgType = TRUE;

            }
            else  //It was a genuine error... bail
            {
                ErrorTrace((LPARAM) pIMailMsgProperties,
                    "CMsgRef::HrInitialze failed with hr 0x%08X", hr);
                goto Exit;
            }
        }

        //Before Enqueuing Messages or firing off local delivery... throttle usage count
        if (g_cMaxIMsgHandlesThreshold < cCountMsgsForHandleThrottling(pIMailMsgProperties))
        {
            DebugTrace((LPARAM) 0xC0DEC0DE, "INFO: Closing IMsg Content - %d messsages in queue", cCountMsgsForHandleThrottling(pIMailMsgProperties));
            //bounce usage count off of zero
            pIMailMsgQueueMgmt->ReleaseUsage();
            pIMailMsgQueueMgmt->AddUsage();
        }

        m_dmt.AquireDMTShareLock();
        if (m_dmt.dwGetDMTVersion() != dwDMTVersion)
        {
            DebugTrace((LPARAM) this,
                "DMT version change: was %d, now %d",
                dwDMTVersion, m_dmt.dwGetDMTVersion());
            //DMT Version changed... that means that our queues may have been
            //removed from the DMT.  Time to retry
            m_dmt.ReleaseDMTShareLock();
            _ASSERT(fKeepTrying);

            InterlockedIncrement((PLONG) &m_cDMTRetries);

            fGotMsgType = FALSE;
            hr = HrReGetMessageType(pIMailMsgProperties, pIMessageRouter,
                            &dwMessageType);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) pIMailMsgProperties,
                    "HrReGetMessageType failed with hr - 0x%08X", hr);
                goto Exit;
            }
            fGotMsgType = TRUE;

            continue;  //Try again
        }

        fKeepTrying = FALSE;
        fDMTLocked = TRUE;

        //enqueue the message reference for each destination it is going to
        for (i = 0; i < cQueues; i++)
        {
            if (NULL != rgpdmq[i])
            {
                InterlockedIncrement(&m_cTotalMsgsQueued);

                //enqueue message and assign message type to first enqueue
                hr = rgpdmq[i]->HrEnqueueMsg(pmsgref, !fOnDMQ);
                if (FAILED(hr))
                {
                    ErrorTrace((LPARAM) pIMailMsgProperties,
                        "HrEnqueueMsg failed - 0x%08X", hr);
                    InterlockedDecrement(&m_cTotalMsgsQueued);
                    goto Exit;
                }
                fOnDMQ = TRUE;

                //
                //  Check and see if this queue is explicitly routed remote.
                //  It may be a gateway delivery queue.
                //
                if (!fRemote)
                    fRemote = rgpdmq[i]->fIsRemote();
            }
            else
            {
                fLocal = TRUE;
            }
        }


        _ASSERT(fDMTLocked);
        m_dmt.ReleaseDMTShareLock();
        fDMTLocked = FALSE;

        if (fLocal) //kick off local delivery
        {
            QueueMsgForLocalDelivery(pmsgref, FALSE);
        }
    }

  Exit:

    if (fDMTLocked)
    {
        m_dmt.ReleaseDMTShareLock();
        fDMTLocked = FALSE;
    }

    // Check and process any special queues in the DMT
    if (fRoutingLock && fLocked)
        m_dmt.ProcessSpecialLinks(m_dwDelayExpireMinutes, TRUE);

    //
    // Must Release IMessageRouter before starting shutdown since the
    // IMessageRouter sink may have a reference to us (via
    // IRouterReset)
    //
    if (NULL != pIMessageRouter)
    {
        if (!fOnDMQ && fGotMsgType) //we have a reference to this message type
        {
            hrTmp = pIMessageRouter->ReleaseMessageType(dwMessageType, 1);
            _ASSERT(SUCCEEDED(hrTmp));
        }
        pIMessageRouter->Release();
    }

    if (fRoutingLock)
        RoutingShareUnlock();

    if (fLocked)
        ShutdownUnlock();

    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    if (pIRecipList)
        pIRecipList->Release();

    if (NULL != rgpdmq)
        FreePv(rgpdmq);

    if (fRemote && pmsgref)
    {
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingDelivery);
        //msgref needs to decrement the remote count when it is released
        pmsgref->CountMessageInRemoteTotals();
    }

    if (NULL != pmsgref)
    {
        if (FAILED(hr) && (fOnDMQ || fLocal))
        {
            //If we have a msgref and it has been queued, we must
            //wait until all other references are released to retry it
            pmsgref->RetryOnDelete();
            hr = S_OK; //don't let caller retry
        }
        pmsgref->Release();
    }

    //if we did not succeed, msgs is still in pre-routing queue
    if (FAILED(hr))
    {
        fReturn = FALSE;
        //kick off retry if necessary
        ScheduleInternalRetry(LI_TYPE_PENDING_ROUTING);
    }
    else
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingRouting);


    TRACE_COUNTERS;

    SleepForPerfAnalysis(g_dwRoutingQueueSleepMilliseconds);

    TraceFunctLeave();
    return fReturn;
}

//---[ CAQSvrInst::HrAckMsg ]------------------------------------------------
//
//
//  Description:
//      Acknowledge the (un)delivery of a message.  Will call the msgref AckMsg,
//      which will requeue it to the appropriate queues
//  Parameters:
//      pMsgAck     Pointer to Message Ack structure
//      fLocal      TRUE if this is an ack for a local delivery
//  Returns:
//      S_OK on success
//      ERROR_INVALID_HANDLE if the context handle was invalid
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrAckMsg(IN MessageAck *pMsgAck, BOOL fLocal)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrAckMsg");
    HRESULT         hr      = S_OK;
    DWORD           i       = 0; //loop counter
    CDeliveryContext    *pdcntxt = NULL;

    _ASSERT(pMsgAck);
    _ASSERT(pMsgAck->pvMsgContext);

    pdcntxt = (CDeliveryContext *) pMsgAck->pvMsgContext;
    if ((NULL == pdcntxt) || !(pdcntxt->FVerifyHandle(pMsgAck->pIMailMsgProperties)))
    {
        hr = ERROR_INVALID_HANDLE;
        goto Exit;
    }


    if (!fLocal)
    {
        InterlockedIncrement(&m_cMsgsAcked);
        if (MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus)
            InterlockedIncrement((PLONG) &m_cMsgsAckedRetry);
    }
    else //local
    {
        if (MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus)
            InterlockedIncrement((PLONG) &m_cMsgsAckedRetryLocal);
    }

    hr = pdcntxt->HrAckMessage(pMsgAck);
    if (FAILED(hr))
        goto Exit;

  Exit:
    //clean up all the things we have used here
    if (pdcntxt)
        pdcntxt->Recycle();

    TRACE_COUNTERS;
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::HrNotify ]------------------------------------------------------------
//
//
//  Description:
//      Passes notification off to Connection Mangaer
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrNotify(IN CAQStats *paqstats, BOOL fAdd)
{
    HRESULT hr = S_OK;
    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    hr = m_pConnMgr->HrNotify(paqstats, fAdd);

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::HrGetInternalDomainInfo ]----------------------------------
//
//
//  Description:
//    Expose ability to get internal Domain Info to internal components
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      OUT     ppIntDomainInfo         Domain info returned (must be released)
//  Returns:
//      S_OK    if match is found
//      AQUEUE_E_INVALID_DOMAIN if no match is found
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetInternalDomainInfo(
                                    IN  DWORD cbDomainNameLength,
                                    IN  LPSTR szDomainName,
                                    OUT CInternalDomainInfo **ppDomainInfo)
{
    HRESULT hr = S_OK;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    _ASSERT(CMQ_INIT_DCT & m_dwInitMask);

    hr = m_dct.HrGetInternalDomainInfo(cbDomainNameLength, szDomainName, ppDomainInfo);

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::HrGetDefaultDomainInfo ]----------------------------
//
//
//  Description:
//    Expose ability to get internal default Domain Info to internal components
//  Parameters:
//      OUT     ppIntDomainInfo         Domain info returned (must be released)
//  Returns:
//      S_OK    if found
//      AQUEUE_E_INVALID_DOMAIN if not found
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetDefaultDomainInfo(
                                    OUT CInternalDomainInfo **ppDomainInfo)
{
    HRESULT hr = S_OK;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    _ASSERT(CMQ_INIT_DCT & m_dwInitMask);

    hr = m_dct.HrGetDefaultDomainInfo(ppDomainInfo);

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::HrGetDomainEntry ]----------------------------------------
//
//
//  Description:
//      Get Domain Entry
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      OUT     ppdentry                Domain Entry for domain (from DMT)
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain is not found
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetDomainEntry(IN  DWORD cbDomainNameLength,
                             IN  LPSTR szDomainName,
                             OUT CDomainEntry **ppdentry)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(ppdentry);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    hr = m_dmt.HrGetDomainEntry(cbDomainNameLength, szDomainName, ppdentry);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (fLocked)
        ShutdownUnlock();

    return hr;
}

//---[ CAQSvrInst::HrIterateDMTSubDomains ]----------------------------------------
//
//
//  Description:
//      Get Domain Entry
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      IN      pfn                     Iterator function
//      IN      pvcontext               Context passed to each call
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain is not found
//
//--------------------------------------------------------------------------------

HRESULT CAQSvrInst::HrIterateDMTSubDomains(IN LPSTR szDomainName,
                                   IN DWORD cbDomainNameLength,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    DOMAIN_STRING strDomain;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(pfn);
    _ASSERT(pvContext);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    strDomain.Length = (USHORT) cbDomainNameLength;
    strDomain.MaximumLength = (USHORT) cbDomainNameLength;
    strDomain.Buffer = szDomainName;

    hr = m_dmt.HrIterateOverSubDomains(&strDomain, pfn,pvContext);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (fLocked)
        ShutdownUnlock();

    return hr;
}

//---[ CAQSvrInst::HrIterateDMTSubDomains ]----------------------------------------
//
//
//  Description:
//      Get Domain Entry
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      IN      pfn                     Iterator function
//      IN      pvcontext               Context passed to each call
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain is not found
//
//--------------------------------------------------------------------------------
HRESULT CAQSvrInst::HrIterateDCTSubDomains(IN LPSTR szDomainName,
                                   IN DWORD cbDomainNameLength,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    DOMAIN_STRING strDomain;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(pfn);
    _ASSERT(pvContext);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    strDomain.Length = (USHORT) cbDomainNameLength;
    strDomain.MaximumLength = (USHORT) cbDomainNameLength;
    strDomain.Buffer = szDomainName;

    hr = m_dct.HrIterateOverSubDomains(&strDomain, pfn,pvContext);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (fLocked)
        ShutdownUnlock();

    return hr;
}


//---[ CAQSvrInst::HrTriggerGetMessageRouter ]--------------------------------------
//
//
//  Description:
//      Wrapper function that signals the MAIL_TRANSPORT_ON_GET_ROUTER_EVENT
//  Parameters:
//      IN  pIMailMsgProperties       - IMailMsgProperties to get
//      OUT pIMessageRouter
//
//  Returns:
//
//  History:
//      5/20/98 - MikeSwa Created
//      jstamerj 1998/07/10 18:30:41: Implemented Server event
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrTriggerGetMessageRouter(
            IN  IMailMsgProperties *pIMailMsgProperties,
            OUT IMessageRouter     **ppIMessageRouter)
{
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::HrTriggerGetMessageRouter");
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    _ASSERT(ppIMessageRouter);
    _ASSERT(pIMailMsgProperties);
    _ASSERT(m_pIMessageRouterDefault);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    if(m_pISMTPServer) {

        EVENTPARAMS_ROUTER EventParams;
        //
        // Initialiez EventParams
        //
        EventParams.dwVirtualServerID = m_dwServerInstance;
        EventParams.pIMailMsgProperties = pIMailMsgProperties;
        EventParams.pIMessageRouter = NULL;
        EventParams.pIRouterReset = m_pIRouterReset;
        EventParams.pIRoutingEngineDefault = this;

        hr = TriggerServerEvent(
            SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT,
            &EventParams);
        if(SUCCEEDED(hr)) {
            if(EventParams.pIMessageRouter) {
                //
                // The implementor of GetMessageRouter returned
                // IMessageRouter with a refcount of one for us
                //
                *ppIMessageRouter = EventParams.pIMessageRouter;
            } else {
                //
                // The server event succeeded, but no sink supplied an
                // IMessageRouter (including default functionality)
                //
                hr = E_FAIL;
            }
        }
    } else {

        ErrorTrace((LPARAM)this, "Unable to trigger event to GetMessageRouter; using default");
        //
        // Try calling our default (builtin) GetMessageRouter
        //
        hr = GetMessageRouter(
            pIMailMsgProperties,          //IN  IMsg
            NULL,               //IN  pIMessageRouter (Current)
            ppIMessageRouter);  //OUT ppIMessageRouter (New)
    }

  Exit:

    if (fLocked)
        ShutdownUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//---[ CAQSvrInst::HrTriggerLogEvent ]-----------------------------------------
//
//
//  Description:
//      Wrapper function that signals the SMTP_LOG_EVENT event
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrTriggerLogEvent(
        IN DWORD                    idMessage,
        IN WORD                     idCategory,
        IN WORD                     cSubstrings,
        IN LPCSTR                   *rgszSubstrings,
        IN WORD                     wType,
        IN DWORD                    errCode,
        IN WORD                     iDebugLevel,
        IN LPCSTR                   szKey,
        IN DWORD                    dwOptions,
        IN DWORD                    iMessageString,
        IN HMODULE                  hModule)
{
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::HrTriggerLogEvent");
    HRESULT hr = S_OK;
    if (m_pISMTPServerEx) {
        hr = m_pISMTPServerEx->TriggerLogEvent(
                                    idMessage,
                                    idCategory,
                                    cSubstrings,
                                    rgszSubstrings,
                                    wType,
                                    errCode,
                                    iDebugLevel,
                                    szKey,
                                    dwOptions,
                                    iMessageString,
                                    hModule);
    } else {
      //
      //  If we do not have at least W2K SP2... we will not have this
      //  interface.
      //
      ErrorTrace((LPARAM) this,
        "Need W2KSP2: Unable to log event %d with erCode %d");
    }
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//---[ CAQSvrInst::HrTriggerInitRouter ]---------------------------------------
//
//
//  Description:
//      Wrapper function that signals the MAIL_TRANSPORT_ON_GET_ROUTER_EVENT
//      but only has it create a new router object
//  Parameters:
//      none
//
//  Returns:
//
//  History:
//      5/20/98 - MikeSwa Created
//      jstamerj 1998/07/10 18:30:41: Implemented Server event
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrTriggerInitRouter() {
    TraceFunctEnter("CAQSvrInst::HrTriggerInitRouter");
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    if (m_pISMTPServer) {

        EVENTPARAMS_ROUTER EventParams;
        //
        // Initialiez EventParams
        //
        EventParams.dwVirtualServerID = m_dwServerInstance;
        EventParams.pIMailMsgProperties = NULL;
        EventParams.pIMessageRouter = NULL;
        EventParams.pIRouterReset = m_pIRouterReset;
        EventParams.pIRoutingEngineDefault = NULL;

        hr = TriggerServerEvent(
            SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT,
            &EventParams);
    } else {
        hr = S_OK;
    }

  Exit:

    if (fLocked)
        ShutdownUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//---[ CAQSvrInst::QueryInterface ]------------------------------------------
//
//
//  Description:
//      QueryInterface for IAdvQueue
//  Parameters:
//
//  Returns:
//      S_OK on success
//
//  Notes:
//      This implementation makes it possible for any server component to get
//      the IAdvQueueConfig interface.
//
//  History:
//      7/29/98 - MikeSwa Modified (added IAdvQueueDomainType)
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IAdvQueue *>(this);
    }
    else if (IID_IAdvQueue == riid)
    {
        *ppvObj = static_cast<IAdvQueue *>(this);
    }
    else if (IID_IAdvQueueConfig == riid)
    {
        *ppvObj = static_cast<IAdvQueueConfig *>(this);
    }
    else if (IID_IAdvQueueDomainType == riid)
    {
        *ppvObj = static_cast<IAdvQueueDomainType *>(this);
    }
    else if (IID_IAdvQueueAdmin == riid)
    {
        *ppvObj = static_cast<IAdvQueueAdmin *>(this);
    }
    else if (IID_IMailTransportRouterSetLinkState == riid)
    {
        *ppvObj = static_cast<IMailTransportRouterSetLinkState *>(this);
    }
    else if (IID_IAQServerEvent == riid)
    {
        *ppvObj = static_cast<IAQServerEvent*>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CAQSvrInst::SubmitMessage ]---------------------------------------------
//
//
//  Description:
//      External function to submit messages for delivery
//  Parameters:
//      pIMailMsgProperties         Msg to submit for delivery
//  Returns:
//      S_OK always
//  History:
//      10/7/1999 - MikeSwa Moved from inline function
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SubmitMessage(IN IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::SubmitMessage");
    HRESULT hr = S_OK;

    if (NULL == pIMailMsgProperties)
    {
        ErrorTrace((LPARAM)NULL,
                    "SubmitMessage called with NULL pIMailMsgProperties");
        return E_INVALIDARG;
    }

    InterlockedIncrement((PLONG) &m_cTotalExternalMsgsSubmitted);
    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingSubmit);

    // Before we queue this message, stamp the message submission time
    hr = HrSetSubmissionTimeIfNecessary(pIMailMsgProperties);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
                   "ERROR: Unable to stamp submission time on message - hr 0x%08x", hr);
        goto Error_Exit;
    }


    hr = m_asyncqPreSubmissionQueue.HrQueueRequest(
                                pIMailMsgProperties, FALSE,
                                cCountMsgsForHandleThrottling(pIMailMsgProperties));

    if (FAILED(hr))
    {
        goto Error_Exit;
    }

Exit:
    TraceFunctLeave();
    return S_OK;

Error_Exit:
    InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingSubmit);
    HandleAQFailure(AQ_FAILURE_INTERNAL_ASYNCQ, hr, pIMailMsgProperties);
    goto Exit;
}

//---[ CAQSvrInst::HrInternalSubmitMessage ]-----------------------------------
//
//
//  Description:
//      Implements IAdvQueue::SubmitMessage
//  Parameters:
//      pIMailMsgProperties... Messaage to queue
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrInternalSubmitMessage(
                      IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties,
                      "CAQSvrInst::SubmitMessage");
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    HRESULT hr = S_OK;
    DWORD dwMsgStatus = MP_STATUS_SUCCESS;
    EVENTPARAMS_SUBMISSION Params;
    FILETIME ftDeferred;
    DWORD   cbProp = 0;
    DWORD   dwContext = 0;

    _ASSERT(pIMailMsgProperties);

    if (NULL == pIMailMsgProperties)
    {
        ErrorTrace((LPARAM)NULL,
                   "SubmitMessage called with NULL pIMailMsgProperties");
        return E_INVALIDARG;
    }

    //Check and see if we need to request a retry for failed msgs
    m_fmq.StartProcessingIfNecessary();

    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_DEFERRED_DELIVERY_FILETIME,
                                          sizeof(FILETIME), &cbProp,
                                          (BYTE *) &ftDeferred);

    if (SUCCEEDED(hr) && !fInPast(&ftDeferred, &dwContext))
    {
        //Defer delivery until a later time if deferred delivery time is
        //present, and in the past
        hr = S_OK;
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingDeferredDelivery);
        m_defq.Enqueue(pIMailMsgProperties, &ftDeferred);
        goto Exit;
    }

    // Set submission time for this message
    hr = HrSetSubmissionTimeIfNecessary(pIMailMsgProperties);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
                   "ERROR: Unable to stamp submission time on message - hr 0x%08x",
                   hr);
        return hr;
    }

    InterlockedIncrement((PLONG) &m_cTotalMsgsSubmitted);

    //
    // Set the message status (if currently unset)
    //
    hr = pIMailMsgProperties->GetDWORD(
        IMMPID_MP_MESSAGE_STATUS,
        &dwMsgStatus);

    if( (hr == MAILMSG_E_PROPNOTFOUND) ||
        (g_fResetMessageStatus) )
    {
        //
        // Initialize the message status
        //
        hr = pIMailMsgProperties->PutDWORD(
            IMMPID_MP_MESSAGE_STATUS,
            MP_STATUS_SUCCESS);

        dwMsgStatus = MP_STATUS_SUCCESS;
    }

    //
    //$$TODO: Jump from here to whatever state dwMsgStatus indicates
    //
        MSG_TRACK_INFO msgTrackInfo;
        ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
        msgTrackInfo.dwEventId = MTE_BEGIN_SUBMIT_MESSAGE;
        m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    //
    // AddRef this object here; release in completion
    //
    AddRef();

    Params.pIMailMsgProperties = pIMailMsgProperties;
    Params.pfnCompletion = MailTransport_Completion_SubmitMessage;
    Params.pCCatMsgQueue = this;

    pIMailMsgProperties->AddRef();

    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingSubmitEvent);
    TRACE_COUNTERS;

    //
    // Call server event if we can and if dwMsgStatus does not
    // indicate the mssage has already been submitted
    //
    if(SUCCEEDED(hr) &&
       (m_pISMTPServer) &&
       (dwMsgStatus < MP_STATUS_SUBMITTED))
    {
        hr = TriggerServerEvent(
            SMTP_MAILTRANSPORT_SUBMISSION_EVENT,
            &Params);

        DebugTrace((LPARAM)pIMailMsgProperties,
                   "TriggerServerEvent returned hr %08lx", hr);
    }

    //
    // If TriggerServerEvent returned an error OR m_pISMTPServer is
    // null, or the message was already submitted, call the event
    // completion routine directly
    //
    if((m_pISMTPServer == NULL) ||
       FAILED(hr) ||
       (dwMsgStatus >= MP_STATUS_SUBMITTED))
    {
        DebugTrace((LPARAM)this, "Skipping the submission event");

        // Call the SEO Dispatcher completion routine directly so we
        // don't loose this mail...
        hr = SubmissionEventCompletion(S_OK, &Params);
    }

    //
    // SEO dispatcher will call the completion routine
    // (MailTransport_Completion_SubmitMessage) regardless wether or
    // not all the sinks work synchronously or async.  Because of
    // this, this function is now done.
    //

  Exit:
    TraceFunctLeaveEx((LPARAM) pIMailMsgProperties);
    return hr;
}

//---[ CAQSvrInst::HandleFailedMessage ]--------------------------------------
//
//
//  Description:
//      Handles a failed message from SMTP... usually by NDRing the message or
//      by treating the message as badmail.
//
//      NOTE: Message or input file will be deleted by this operation.
//  Parameters:
//      pIMailMsgProperties     MailMsg that needs to be handles
//      fUseIMailMsgProperties  Use the IMailMsg if set, else use the szFilename,
//      szFileName              use the filename if no msg
//      dwFailureReasons        One of the failure reasons described in aqueue.idl
//      hrFailureCode           Additional information that describes a failure
//                              code encountered by SMTP.
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pIMailMsgProperties is NULL
//  History:
//      7/28/98 - MikeSwa Created
//      10/14/98 - MikeSwa Added filename string for badmail
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::HandleFailedMessage(
                                   IN IMailMsgProperties *pIMailMsgProperties,
                                   IN BOOL fUseIMailMsgProperties,
                                   IN LPSTR szFileName,
                                   IN DWORD dwFailureReason,
                                   IN HRESULT hrFailureCode)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HandleFailedMessage");
    HRESULT hr = S_OK;
    HRESULT hrBadMail = hrFailureCode;
    DWORD iCurrentDomain = 0;
    DWORD cDomains = 0;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    CDSNParams  dsnparams;
    BOOL  fNDR = TRUE; //FALSE -> Badmail handling

    SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
    dsnparams.dwStartDomain = 0;
    dsnparams.dwDSNActions = DSN_ACTION_FAILURE_ALL;
    dsnparams.pIMailMsgProperties = pIMailMsgProperties;
    dsnparams.hrStatus = hrFailureCode;

    MSG_TRACK_INFO msgTrackInfo;
    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_AQ_FAILED_MESSAGE;
    msgTrackInfo.dwRcptReportStatus = dwFailureReason;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    //
    //  Switch over the various general failure reasons and handle them as
    //  appropriate.
    //
    switch(dwFailureReason)
    {
      case MESSAGE_FAILURE_HOP_COUNT_EXCEEDED:
        //
        //  Attempt to NDR
        //
        _ASSERT(pIMailMsgProperties);
        dsnparams.hrStatus = AQUEUE_E_MAX_HOP_COUNT_EXCEEDED;
        fNDR = TRUE;
        break;

      case MESSAGE_FAILURE_GENERAL:
        //
        //  Attempt to NDR
        //
        fNDR = TRUE;
        break;

      case MESSAGE_FAILURE_CAT:
        //
        //  Attempt to NDR... set DSN context to CAT
        //
        dsnparams.dwDSNActions |= DSN_ACTION_CONTEXT_CAT;
        fNDR = TRUE;
        break;

      case MESSAGE_FAILURE_BAD_PICKUP_DIR_FILE:
        //
        //  Badmail, since we do not have the P1 information needed to badmail
        //
        _ASSERT(szFileName);
        hrBadMail = AQUEUE_E_PICKUP_DIR;
        fNDR = FALSE; //This should be handled as badmail
        break;
      default:
        _ASSERT(0 && "Unhandled failed msg case!");
    }

    if (fNDR && pIMailMsgProperties && fUseIMailMsgProperties)
    {
        hr = HrLinkAllDomains(pIMailMsgProperties);
        if (FAILED(hr))
            goto Exit;

        //Fire DSN Generation event
        hr = HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
        {
            HandleBadMail(pIMailMsgProperties, fUseIMailMsgProperties,
                          szFileName, hrBadMail, FALSE);
            if (dwFailureReason == MESSAGE_FAILURE_GENERAL) {
                InterlockedIncrement((PLONG) &m_cBadmailFailureGeneral);
            } else {
                _ASSERT(dwFailureReason == MESSAGE_FAILURE_HOP_COUNT_EXCEEDED);
                InterlockedIncrement((PLONG) &m_cBadmailHopCountExceeded);
            }
            hr = S_OK; //handled error internally
            ErrorTrace((LPARAM) this, "ERROR: Unable to NDR failed mail - hr 0x%08X", hr);
            goto Exit;
        }
    }
    else
    {
        //Handle as badmail
        HandleBadMail(pIMailMsgProperties, fUseIMailMsgProperties,
                      szFileName, hrBadMail, FALSE);
        InterlockedIncrement((PLONG) &m_cBadmailBadPickupFile);
        _ASSERT(dwFailureReason == MESSAGE_FAILURE_BAD_PICKUP_DIR_FILE);
    }

    if ( fUseIMailMsgProperties && pIMailMsgProperties)
    {
        //Now that we are done... delete mailmsg from system
        hr = HrDeleteIMailMsg(pIMailMsgProperties);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to delete message hr0x%08X", hr);
            //message was actually NDR'd/bad mailed correctly
            hr = S_OK;
        }
    }

  Exit:
    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Completion_SubmitMessage
//
// Synopsis: SEO will call this routine after all sinks for
// SubmitMessage have been handeled
//
// Arguments:
//   pvContext: Context passed into TriggerServerEvent
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980609 16:13:40: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Completion_SubmitMessage(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnter("MailTransport_Completion_SubmitMessage");

    PEVENTPARAMS_SUBMISSION pParams = (PEVENTPARAMS_SUBMISSION) pvContext;
    CAQSvrInst *paqinst = (CAQSvrInst *) pParams->pCCatMsgQueue;

    TraceFunctLeave();
    return paqinst->SubmissionEventCompletion(
        hrStatus,
        pParams);
}

//+------------------------------------------------------------
//
// Function: CAQSvrInst::SubmissionEventCompletion
//
// Synopsis: Completion routine called when the submission event is
// done.
//
// Arguments:
//   hrStatus: Status of server event
//   pParams: Context passed into TriggerServereEvent
//
// Returns:
//   Nothing
//
// History:
// jstamerj 980610 12:26:18: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::SubmissionEventCompletion(
    HRESULT hrStatus,
    PEVENTPARAMS_SUBMISSION pParams)
{
    TraceFunctEnterEx((LPARAM)pParams->pIMailMsgProperties,
                      "CAQSvrInst::SubmissionEventCompletion");
    _ASSERT(pParams);
    HRESULT hr;

    DebugTrace((LPARAM)pParams->pIMailMsgProperties,
               "Status of event completion: %08lx", hrStatus);

    InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingSubmitEvent);

    //
    // Update the message status
    //
    hr = SetNextMsgStatus(MP_STATUS_SUBMITTED, pParams->pIMailMsgProperties);
    if (hr == S_OK) //anything else implies that the message has been handled
    {
        // Only trigger the precat event if message was not turfed.
        TriggerPreCategorizeEvent(pParams->pIMailMsgProperties);
    }

    //
    // Release refernce added in SubmitMessage
    //
    Release();

    pParams->pIMailMsgProperties->Release();

    //
    // pParams is part of a larger allocation that will be released by
    // SEO Dispatcher code
    //

    TraceFunctLeave();
    return S_OK;
}


//---[ CAQSvrInst::SubmitMessageToCategorizer ]-------------------------------------------
//
//
//  Description:
//      Implements IAdvQueue::SubmitMessageToCategorizer
//  Parameters:
//      pIMailMsgProperties... Messaage to queue
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::SubmitMessageToCategorizer(
          IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "CAQSvrInst::SubmitMessageToCategorizer");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    BOOL fLocked = FALSE;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    MSG_TRACK_INFO msgTrackInfo;
    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_SUBMIT_MESSAGE_TO_CAT;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    fLocked = TRUE;

    cIncMsgsInSystem();

    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingCat);
    TRACE_COUNTERS;

    hr = m_asyncqPreCatQueue.HrQueueRequest(pIMailMsgProperties, FALSE,
                                            cCountMsgsForHandleThrottling(pIMailMsgProperties));
    if (FAILED(hr))
    {
        HandleAQFailure(AQ_FAILURE_PRECAT_RETRY, E_FAIL, pIMailMsgProperties);
        goto Exit;
    }

  Exit:
    if(fLocked)
    {
        ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::SetNextMsgStatus ]------------------------------------------
//
//
//  Description:
//      Used by the event glue code to set the next message status.  Will turf
//      or badmail a message if the status indicates that is the requested
//      action.
//  Parameters:
//      IN  dwCurrentStatus         The current status (according to *current*
//                                  place in event pipeline).  Valid values are
//                                      MP_STATUS_SUBMITTED
//                                      MP_STATUS_CATEGORIZED
//      IN  pIMailMsgProperties     The message
//      OUT pdwNewStatus            The new status
//  Returns:
//      S_OK    Success
//      S_FALSE Success, but message has been handled.
//  History:
//      11/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::SetNextMsgStatus(
                             IN  DWORD dwCurrentStatus,
                             IN  IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::SetNextMsgStatus");
    HRESULT hr = S_OK;
    DWORD   dwActualStatus = 0;
    DWORD   dwNewStatus = 0;
    BOOL    fHandled = FALSE;

    _ASSERT(pIMailMsgProperties);
    _ASSERT((MP_STATUS_SUBMITTED == dwCurrentStatus) || (MP_STATUS_CATEGORIZED == dwCurrentStatus));

    hr = pIMailMsgProperties->GetDWORD(IMMPID_MP_MESSAGE_STATUS, &dwActualStatus);

    if (FAILED(hr))
        dwActualStatus = dwCurrentStatus;

    if (MP_STATUS_SUCCESS == dwActualStatus)
        dwActualStatus = dwCurrentStatus;

    switch(dwActualStatus)
    {
        case MP_STATUS_BAD_MAIL:
            HandleBadMail(pIMailMsgProperties, TRUE, NULL, E_FAIL, FALSE);
            InterlockedIncrement((PLONG) &m_cBadmailEvent);
            //OK... now continue as if message was aborted
        case MP_STATUS_ABORT_DELIVERY:
            fHandled = TRUE;
            HrDeleteIMailMsg(pIMailMsgProperties);
            break;

        case MP_STATUS_ABANDON_DELIVERY:
            //In this case, we will leave the message in the queue directory
            //until restart & reset the state so it goes through the entire
            //pipeline.   The idea is that someone can write a sink to detect
            //a non-supported state (like CAT disabled in an Exchange install)
            //that will abandon delivery of the messages and log an event.
            //The admin can fix the problem and restart smtpsvc.  Once
            //the service is restarted... the messages are magically submitted
            //and re-categorized.

            fHandled = TRUE;
            pIMailMsgProperties->PutDWORD(IMMPID_MP_MESSAGE_STATUS,
                                          MP_STATUS_SUCCESS);
            break;

        case MP_STATUS_CATEGORIZED:
            //Don't change status from categorized to something else
            dwNewStatus = dwActualStatus;
            DebugTrace((LPARAM) this, "Message 0x%x  has already been categorized",
                        pIMailMsgProperties);
            break;

        default:  //simply move on to the next expected status
            dwNewStatus = dwCurrentStatus;
    }

    if (!fHandled)
    {
        pIMailMsgProperties->PutDWORD(IMMPID_MP_MESSAGE_STATUS, dwNewStatus);

        //callers will not be able to do anything about a failure to write status
        hr = S_OK;
    }
    else
    {
        DecMsgsInSystem();
        hr = S_FALSE;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::fPreCatQueueCompletion ]-----------------------------------
//
//
//  Description:
//      Completion routine for Pre-Categorization queue
//  Parameters:
//      pIMailMsgProperties - MailMsg to give to categorization
//  Returns:
//      TRUE    if successful
//      FALSE   if message needs to be re-requeue
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fPreCatQueueCompletion(IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::fPreCatQueueCompletion");
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    HRESULT hr = S_OK;
    HRESULT hrCatCompletion;
    IUnknown *pIUnknown = NULL;
    BOOL fRet = TRUE;
    BOOL fLocked = FALSE;

    if (!fTryShutdownLock())
    {
        hr = S_OK; //we cannot retry on shutdown
        goto Exit;
    }

    fLocked = TRUE;

    hr = pIMailMsgProperties->QueryInterface(IID_IUnknown, (PVOID *) &pIUnknown);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IUknown Failed!");
    _ASSERT(pIUnknown);

    InterlockedIncrement((PLONG) &m_cCatMsgCalled);
    m_asyncqPreCatQueue.IncPendingAsyncCompletions();
    hr = CatMsg(m_hCat, pIUnknown,(PFNCAT_COMPLETION)CAQSvrInst::CatCompletion,
                       (LPVOID) this);

    if (FAILED(hr))
    {
        if(hr == CAT_E_RETRY)
        {
            //
            // Return false so that this message will be re-queued
            //
            fRet =  FALSE;
            InterlockedDecrement((PLONG) &m_cCatMsgCalled);
            m_asyncqPreCatQueue.DecPendingAsyncCompletions();

            //
            // Schedule a time to retry the messages
            //
            ScheduleInternalRetry(LI_TYPE_PENDING_CAT);
        }
        else
        {
            //
            // Return true since this is not a retryable error
            // Call CatCompletion to handle the non-retryable error (log an event, etc)
            //
            hrCatCompletion = CatCompletion(
                hr,                 // hrCatResult
                (LPVOID) this,      // pContext
                pIUnknown,          // pIMsg
                NULL);              // rgpIMsg

            _ASSERT(SUCCEEDED(hrCatCompletion));
        }
    }

  Exit:
    if (pIUnknown)
        pIUnknown->Release();

    if(fLocked)
    {
        ShutdownUnlock();
    }

    SleepForPerfAnalysis(g_dwCatQueueSleepMilliseconds);

    TraceFunctLeave();
    return fRet;
}

//---[ CAQSvrInst::SetConfigInfo ]--------------------------------------------
//
//
//  Description:
//      Implements IAdvQueueConfig::SetConfigInfo
//  Parameters:
//      IN  pAQConfigInfo   Ptr to config info structure
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SetConfigInfo(IN AQConfigInfo *pAQConfigInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::SetConfigInfo");
    HRESULT hr = S_OK;

    if (!pAQConfigInfo)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //check version of structure
    if (!pAQConfigInfo->cbVersion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }


    //we must be setting something
    if (!(pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_ALL))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }


    m_slPrivateData.ExclusiveLock();


    //Retry related config data
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwFirstRetrySeconds))
    {
        m_dwFirstTierRetrySeconds = pAQConfigInfo->dwFirstRetrySeconds;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_EXPIRE_DELAY &&
        MEMBER_OK(pAQConfigInfo, dwDelayExpireMinutes))
    {
        m_dwDelayExpireMinutes = pAQConfigInfo->dwDelayExpireMinutes;
        if (m_dwDelayExpireMinutes == 0) {
            //Default to g_dwRetriesBeforeDelay* retry interval
            m_dwDelayExpireMinutes =
                g_dwRetriesBeforeDelay*m_dwFirstTierRetrySeconds/60;
        }
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_EXPIRE_NDR &&
        MEMBER_OK(pAQConfigInfo, dwNDRExpireMinutes))
    {
        m_dwNDRExpireMinutes = pAQConfigInfo->dwNDRExpireMinutes;
        if (m_dwNDRExpireMinutes == 0) {
            //Default to g_dwDelayIntervalsBeforeNDR* delay expiration
            m_dwNDRExpireMinutes =
                g_dwDelayIntervalsBeforeNDR*m_dwDelayExpireMinutes;
        }
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_LOCAL_EXPIRE_DELAY &&
        MEMBER_OK(pAQConfigInfo, dwLocalDelayExpireMinutes))
    {
        DWORD dwOldLocalDelayExpire = m_dwLocalDelayExpireMinutes;
        m_dwLocalDelayExpireMinutes = pAQConfigInfo->dwLocalDelayExpireMinutes;
        if (m_dwLocalDelayExpireMinutes == 0) {
            //Default to g_dwRetriesBeforeDelay* retry interval
            m_dwLocalDelayExpireMinutes =
                g_dwRetriesBeforeDelay*m_dwFirstTierRetrySeconds/60;
        }

    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_LOCAL_EXPIRE_NDR &&
        MEMBER_OK(pAQConfigInfo, dwLocalNDRExpireMinutes))
    {
        m_dwLocalNDRExpireMinutes = pAQConfigInfo->dwLocalNDRExpireMinutes;
        if (m_dwLocalNDRExpireMinutes == 0) {
            //Default to g_dwDelayIntervalsBeforeNDR* delay expiration
            m_dwLocalNDRExpireMinutes =
                g_dwDelayIntervalsBeforeNDR*m_dwLocalDelayExpireMinutes;
        }
    }

    //Handle default local domain
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_DEFAULT_DOMAIN &&
        MEMBER_OK(pAQConfigInfo, szDefaultLocalDomain))
    {
        hr = HrUpdateRefCountedString(&m_prstrDefaultDomain,
                                      pAQConfigInfo->szDefaultLocalDomain);
    }

    //Handle Server FQDN
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_SERVER_FQDN &&
        MEMBER_OK(pAQConfigInfo, szServerFQDN))
    {
        hr = HrUpdateRefCountedString(&m_prstrServerFQDN,
                                      pAQConfigInfo->szServerFQDN);
    }

    //Handle Copy NDR To Address
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_SEND_DSN_TO &&
        MEMBER_OK(pAQConfigInfo, szSendCopyOfNDRToAddress))
    {
        hr = HrUpdateRefCountedString(&m_prstrCopyNDRTo,
                                      pAQConfigInfo->szSendCopyOfNDRToAddress);
    }

    //Handle BadMail config
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_BADMAIL_DIR &&
        MEMBER_OK(pAQConfigInfo, szBadMailDir))
    {
        hr = HrUpdateRefCountedString(&m_prstrBadMailDir,
                                      pAQConfigInfo->szBadMailDir);
    }


    //Get DSN options
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_USE_DSN_OPTIONS &&
        MEMBER_OK(pAQConfigInfo, dwDSNOptions))
    {
        m_dwDSNOptions = pAQConfigInfo->dwDSNOptions;
    }

    //Get Default DSN Language
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_USE_DSN_LANGUAGE &&
        MEMBER_OK(pAQConfigInfo, dwDSNLanguageID))
    {
        m_dwDSNLanguageID = pAQConfigInfo->dwDSNLanguageID;
    }

    m_slPrivateData.ExclusiveUnlock();

    m_pConnMgr->UpdateConfigData(pAQConfigInfo);

    if (INVALID_HANDLE_VALUE != m_hCat)
    {
        HRESULT hrTmp = CatChangeConfig(m_hCat, pAQConfigInfo, m_pISMTPServer, (IAdvQueueDomainType *) this);
        if (SUCCEEDED(hr))
            hr = hrTmp;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::SetDomainInfo ]-------------------------------------------
//
//
//  Description:
//      Implements IAdvQueueConfig::SetDomainInfo
//  Parameters:
//      IN pDomainInfo  Per domain config info to store
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SetDomainInfo(IN DomainInfo *pDomainInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::SetDomainInfo");
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = NULL;
    BOOL    fLocked = FALSE;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    pIntDomainInfo = new CInternalDomainInfo(m_dct.dwGetCurrentVersion());
    if (!pIntDomainInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Create internal Domain Info struct
    hr = pIntDomainInfo->HrInit(pDomainInfo);
    if (FAILED(hr))
        goto Exit;

    hr = m_dct.HrSetInternalDomainInfo(pIntDomainInfo);
    if (FAILED(hr))
        goto Exit;

    DebugTrace((LPARAM) this, "INFO: Setting domain info flags 0x%08X for domain %s",
        pDomainInfo->dwDomainInfoFlags, pDomainInfo->szDomainName);

  Exit:

    if (fLocked)
        ShutdownUnlock();

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetDomainInfo ]-------------------------------------------
//
//
//  Description:
//      Implements IAdvQueue::GetDomainInfo... returns information about a
//      requested domain.  To keep from leaking memory, all calls must be paired
//      with a call to ReleaseDomainInfo.  Will handle wildcard matches
//  Parameters:
//      IN     cbDomainNameLength   Length of domain name string
//      IN     szDomainName         Domain Name to look for
//      IN OUT pDomainInfo          Ptr to Domain info structure to fill
//      OUT    ppvDomainContext     Ptr to Domain context used to release mem
//  Returns:
//      S_OK on success
//  History:
//      7/29/98 - MikeSwa Modified (fixed leak of domain info struct)
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetDomainInfo(
                             IN     DWORD cbDomainNameLength,
                             IN     CHAR szDomainName[],
                             IN OUT DomainInfo *pDomainInfo,
                             OUT    DWORD **ppvDomainContext)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = NULL;
    BOOL    fLocked = FALSE;

    if (!cbDomainNameLength || !szDomainName || !pDomainInfo || !ppvDomainContext)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    _ASSERT(pDomainInfo->cbVersion >= sizeof(DomainInfo));

    *ppvDomainContext = NULL;


    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    hr = m_dct.HrGetInternalDomainInfo(cbDomainNameLength, szDomainName, &pIntDomainInfo);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIntDomainInfo);

    //copy domain info struct
    memcpy(pDomainInfo, &(pIntDomainInfo->m_DomainInfo), sizeof(DomainInfo));
    *ppvDomainContext = (DWORD *) pIntDomainInfo;

    goto Exit;

  Exit:
    if (fLocked)
        ShutdownUnlock();

    return hr;
}

//---[ CAQSvrInst::ReleaseDomainInfo ]---------------------------------------
//
//
//  Description:
//      Implements IAdvQueueConfig ReleaseDomainInfo... releases data
//      associated with the DomainInfo struct returned by GetDomainInfo.
//  Parameters:
//      IN  pvDomainContext     Context passed
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pvDomainContext is NULL
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ReleaseDomainInfo(IN DWORD *pvDomainContext)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = (CInternalDomainInfo *) pvDomainContext;


    if (!pIntDomainInfo)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pIntDomainInfo->Release();

  Exit:
    return hr;
}

//---[ CAQSvrInst::GetPerfCounters ]---------------------------------------
//
//
//  Description:
//      Method to retrieve AQ perf counters.
//  Parameters:
//      OUT  pAQPerfCounters     Struct to return counters in.
//      OUT  pCatPerfCouneters   Struct to return counters in. (optinal)
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pAQPerfCounters is NULL
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetPerfCounters(
    OUT AQPerfCounters *pAQPerfCounters,
    OUT PCATPERFBLOCK   pCatPerfCounters)
{
    HRESULT hr = S_OK;
    if (!pAQPerfCounters)
        return( E_INVALIDARG );

    _ASSERT((sizeof(AQPerfCounters) == pAQPerfCounters->cbVersion) && "aqueue/smtpsvc dll version mismatch");

    if (sizeof(AQPerfCounters) != pAQPerfCounters->cbVersion)
        return( E_INVALIDARG );

    pAQPerfCounters->cMsgsDeliveredLocal = m_cMsgsDeliveredLocal;
    pAQPerfCounters->cCurrentMsgsPendingCat = m_cCurrentMsgsPendingCat;
    pAQPerfCounters->cCurrentMsgsPendingRemoteDelivery = m_cCurrentMsgsPendingDelivery;
    pAQPerfCounters->cCurrentMsgsPendingLocalDelivery = m_cCurrentMsgsPendingLocal;
    pAQPerfCounters->cCurrentQueueMsgInstances = m_cCurrentQueueMsgInstances;
    pAQPerfCounters->cTotalMsgRemoteSendRetries = m_cMsgsAckedRetry;
    pAQPerfCounters->cTotalMsgLocalRetries = m_cMsgsAckedRetryLocal;
    pAQPerfCounters->cCurrentMsgsPendingLocalRetry = m_cCurrentMsgsPendingLocalRetry;

    //DSN counters
    pAQPerfCounters->cNDRsGenerated = m_cNDRs;
    pAQPerfCounters->cDelayedDSNsGenerated = m_cDelayedDSNs;
    pAQPerfCounters->cDeliveredDSNsGenerated = m_cDeliveredDSNs;
    pAQPerfCounters->cRelayedDSNsGenerated = m_cRelayedDSNs;
    pAQPerfCounters->cExpandedDSNsGenerated = m_cExpandedDSNs;
    pAQPerfCounters->cTotalMsgsTURNETRN = m_cTotalMsgsTURNETRNDelivered;

    //Queue/Link related counters
    pAQPerfCounters->cCurrentRemoteDestQueues = m_cCurrentRemoteDestQueues;
    pAQPerfCounters->cCurrentRemoteNextHopLinks = m_cCurrentRemoteNextHops;

    pAQPerfCounters->cTotalMsgsBadmailNoRecipients = m_cBadmailNoRecipients;
    pAQPerfCounters->cTotalMsgsBadmailHopCountExceeded = m_cBadmailHopCountExceeded;
    pAQPerfCounters->cTotalMsgsBadmailFailureGeneral = m_cBadmailFailureGeneral;
    pAQPerfCounters->cTotalMsgsBadmailBadPickupFile = m_cBadmailBadPickupFile;
    pAQPerfCounters->cTotalMsgsBadmailEvent = m_cBadmailEvent;
    pAQPerfCounters->cTotalMsgsBadmailNdrOfDsn = m_cBadmailNdrOfDsn;
    pAQPerfCounters->cCurrentMsgsPendingRouting = m_cCurrentMsgsPendingRouting;
    pAQPerfCounters->cTotalDSNFailures = m_cTotalDSNFailures;
    pAQPerfCounters->cCurrentMsgsInLocalDelivery = m_cCurrentMsgsInLocalDelivery;

    //
    // The m_cTotalMsgsSubmitted counter counts the number of times
    // HrInternalSubmit msg has been called.  This does not include the
    // presubmission queue, so me need to manually add this count in.
    //
    pAQPerfCounters->cTotalMsgsSubmitted = m_cTotalMsgsSubmitted +
                                           m_cCurrentMsgsPendingSubmit;

    if (fTryShutdownLock()) {
        pAQPerfCounters->cCurrentMsgsPendingUnreachableLink =
            m_dmt.GetCurrentlyUnreachableTotalMsgCount();
        ShutdownUnlock();
    }

    //For now, these counters will be calculated by walking the DMT (same
    //function that determines msgs pending retry).
    pAQPerfCounters->cCurrentRemoteNextHopLinksEnabled = 0;
    pAQPerfCounters->cCurrentRemoteNextHopLinksPendingRetry = 0;
    pAQPerfCounters->cCurrentRemoteNextHopLinksPendingScheduling = 0;
    pAQPerfCounters->cCurrentRemoteNextHopLinksPendingTURNETRN = 0;
    pAQPerfCounters->cCurrentRemoteNextHopLinksFrozenByAdmin = 0;


    //Get Retry remote retry and DSN counters
    pAQPerfCounters->cCurrentMsgsPendingRemoteRetry = 0;
    if (fTryShutdownLock())
    {
        hr = m_dmt.HrIterateOverSubDomains(NULL, CalcDMTPerfCountersIteratorFn,
                                           pAQPerfCounters);

        //will not generate transient errors (we expect success or an empty table
        _ASSERT(SUCCEEDED(hr) || (DOMHASH_E_NO_SUCH_DOMAIN == hr));

        if((m_hCat != INVALID_HANDLE_VALUE) && (pCatPerfCounters))
            hr = CatGetPerfCounters(m_hCat, pCatPerfCounters);

        _ASSERT(SUCCEEDED(hr));

        ShutdownUnlock();
    }

    //save values in CAQSvrInst, so we can dump them in the debugger
    m_cCurrentRemoteNextHopsEnabled = pAQPerfCounters->cCurrentRemoteNextHopLinksEnabled;
    m_cCurrentRemoteNextHopsPendingRetry = pAQPerfCounters->cCurrentRemoteNextHopLinksPendingRetry;
    m_cCurrentRemoteNextHopsPendingSchedule = pAQPerfCounters->cCurrentRemoteNextHopLinksPendingScheduling;
    m_cCurrentRemoteNextHopsFrozenByAdmin = pAQPerfCounters->cCurrentRemoteNextHopLinksFrozenByAdmin;

    return( S_OK );
}

//---[ CAQSvrInst::ResetPerfCounters ]---------------------------------------
//
//
//  Description:
//      Method to reset AQ perf counters to 0.
//  Parameters:
//      None
//  Returns:
//      S_OK on success
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ResetPerfCounters()
{
    m_cTotalMsgsQueued = 0;
    m_cTotalMsgsSubmitted = 0;
    m_cMsgsAcked = 0;
    m_cMsgsAckedRetry = 0;
    m_cMsgsDeliveredLocal = 0;
    m_cMsgsAckedRetryLocal = 0;
    m_cTotalMsgsTURNETRNDelivered = 0;

    //clear DSN counters
    m_cDelayedDSNs = 0;
    m_cNDRs = 0;
    m_cDeliveredDSNs = 0;
    m_cRelayedDSNs = 0;
    m_cExpandedDSNs = 0;

    return( S_OK );
}


//---[ CAQSvrInst::StartConfigUpdate() ]---------------------------------------
//
//
//  Description:
//      Implements IAQConfig::StartConfigUpdate() which is used to signal that
//      all of the domain information is about to be updated.
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN on shutdown
//  History:
//      9/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::StartConfigUpdate()
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::StartConfigUpdate");
    HRESULT hr = S_OK;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
    }
    else
    {
        m_dct.StartConfigUpdate();
        ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::FinishConfigUpdate ]----------------------------------------
//
//
//  Description:
//      Implements IAQConfig::FinishConfigUpdate() which is used to signal that
//      signal that all of the domain information has been updated.  This will
//      cause us to walk through the DomainConfigTable and remove any domain
//      config info that has not been updated (ie - a domain that has been
//      deleted).
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if called while shutdown is in progress.
//  History:
//      9/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::FinishConfigUpdate()
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::FinishConfigUpdate");
    HRESULT hr = S_OK;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
    }
    else
    {
        m_dct.FinishConfigUpdate();

        //Reroute everything
        //$$REVIEW - should we re-route on metabase changes?
        ResetRoutes(RESET_NEXT_HOPS);

        //Important configuration data may have changed... kick connmgr
        m_pConnMgr->KickConnections();

        ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CAQSvrInst::TriggerPostCategorizeEvent
//
// Synopsis: Triggers post categorization event
//
// Arguments:
//   pIMsg: MailMsg for event or NULL
//   rgpIMsg: NULL or a null terminated array of mailmsg pointers
//
//   NOTE: pIMsg or rgpIMsg must be NULL, but neither can be null
//   (exclusive OR)
//
// Returns:
//    -
//
// History:
// jstamerj 980616 20:43:08: Created.
//      8/25/98 - MikeSwa Modified - removed return code
//
//-------------------------------------------------------------
void CAQSvrInst::TriggerPostCategorizeEvent(
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    TraceFunctEnterEx((LPARAM)this,
                      "CAQSvrInst::TriggerPostCategorizeEvent");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    IMailMsgProperties *pIMailMsgProperties = NULL;

    if(pIMsg)
    {
        hr = TriggerPostCategorizeEventOneMsg(pIMsg);
        if (FAILED(hr))
        {
            hrTmp = pIMsg->QueryInterface(IID_IMailMsgProperties,
                                      (void **) &pIMailMsgProperties);
            _ASSERT(SUCCEEDED(hrTmp) && "Could not QI for IMailMsgProperties");
            if (FAILED(hrTmp))
                LogAQEvent(AQ_FAILURE_POSTCAT_EVENT, NULL, NULL, NULL);
            else
            {
                HandleAQFailure(AQ_FAILURE_POSTCAT_EVENT, hr,
                                pIMailMsgProperties);
                pIMailMsgProperties->Release();
                pIMailMsgProperties = NULL;
            }
            DecMsgsInSystem(FALSE, FALSE);
            hr = S_OK;
        }
    }
    else
    {
        _ASSERT(rgpIMsg);
        IUnknown **ppIMsgCurrent = rgpIMsg;
        DecMsgsInSystem(FALSE, FALSE);

        while(SUCCEEDED(hr) && (*ppIMsgCurrent))
        {
            hr = TriggerPostCategorizeEventOneMsg(
                *ppIMsgCurrent);
            ppIMsgCurrent++;
            if (FAILED(hr))
            {
                hrTmp = (*ppIMsgCurrent)->QueryInterface(IID_IMailMsgProperties,
                                          (void **) &pIMailMsgProperties);
                _ASSERT(SUCCEEDED(hrTmp) && "Could not QI for IMailMsgProperties");
                if (FAILED(hrTmp))
                    LogAQEvent(AQ_FAILURE_POSTCAT_EVENT, NULL, NULL, NULL);
                else
                {
                    HandleAQFailure(AQ_FAILURE_POSTCAT_EVENT, hr,
                                    pIMailMsgProperties);
                    pIMailMsgProperties->Release();
                    pIMailMsgProperties = NULL;
                }
                hr = S_OK;
            }
            else
            {
                cIncMsgsInSystem();
            }
        }
    }
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CAQSvrInst::TriggerPostCategorizeEventOneMsg
//
// Synopsis: Triggers ONE server event for one mailmsg
//
// Arguments:
//   pIMsg - mailmsg
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980616 21:26:30: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::TriggerPostCategorizeEventOneMsg(
    IUnknown *pIMsg)
{
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::TriggerPostCategorizeEventOneMsg");
    HRESULT hr;

    //
    // trigger one event
    // this is an async event
    //
    EVENTPARAMS_POSTCATEGORIZE Params;

    // Setup pParams
    hr = pIMsg->QueryInterface(IID_IMailMsgProperties,
                               (PVOID *)&(Params.pIMailMsgProperties));
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "QI failed with error %08lx",
                   hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }
    Params.pfnCompletion = MailTransport_Completion_PostCategorization;
    Params.pCCatMsgQueue = (PVOID) this;

    //
    // Addref here, release in completion
    //
    AddRef();

    //
    // keep a count of messages in the post-cat event
    //
    InterlockedIncrement((LPLONG) &m_cCurrentMsgsPendingPostCatEvent);

    if(m_pISMTPServer) {
        hr = TriggerServerEvent(
            SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT,
            &Params);
        DebugTrace((LPARAM)this, "TriggerServerEvent returned hr %08lx", hr);

    }

    if((m_pISMTPServer == NULL) || (FAILED(hr))) {

        ErrorTrace((LPARAM)this,
                   "Unable to dispatch server event; calling completion routine directly");
        //
        // Call completion routine directly
        //
        TraceFunctLeaveEx((LPARAM)this);
        return PostCategorizationEventCompletion(S_OK, &Params);
    }
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Completion_PostCategorization
//
// Synopsis: SEO will call this routine after all sinks for
// OnPostCategoriztion have been handeled
//
// Arguments:
//   pvContext: Context passed into TriggerServerEvent
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980609 16:13:40: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Completion_PostCategorization(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnter("MailTransport_Completion_PostCategorization");

    PEVENTPARAMS_POSTCATEGORIZE pParams = (PEVENTPARAMS_POSTCATEGORIZE) pvContext;
    CAQSvrInst *paqinst = (CAQSvrInst *) pParams->pCCatMsgQueue;

    TraceFunctLeave();
    return paqinst->PostCategorizationEventCompletion(
        hrStatus,
        pParams);
}


//+------------------------------------------------------------
//
// Function: CAQSvrInst::PostCategorizationEventCompletion
//
// Synopsis: Called on the completion side of OnPostCategorization
//
// Arguments:
//   hrStatus: status of server event
//   pParams: context structure passed into TriggerServerEvent
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980616 21:33:05: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::PostCategorizationEventCompletion(
    HRESULT hrStatus,
    PEVENTPARAMS_POSTCATEGORIZE pParams)
{
    TraceFunctEnterEx((LPARAM)this,
                      "CAQSvrInst::PostCategorizationEventCompletion");
    DebugTrace((LPARAM)this, "hrStatus is %08lx", hrStatus);

    HRESULT hr;

    //
    // Decrease count of msgs in post-cat event
    //
    InterlockedDecrement((LPLONG) &m_cCurrentMsgsPendingPostCatEvent);


    hr = SetNextMsgStatus(MP_STATUS_CATEGORIZED, pParams->pIMailMsgProperties);
    //See if this message has been "handled"
    if (S_FALSE == hr)
    {
        //Message has been "handled"... do not try to route it
        hr = S_OK;
    }
    else
    {

        //Increment counters and put msg into the pre-routing queue
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingRouting);
        hr = m_asyncqPreRoutingQueue.HrQueueRequest(pParams->pIMailMsgProperties,
                              FALSE, cCountMsgsForHandleThrottling(pParams->pIMailMsgProperties));
        if (FAILED(hr))
        {
            HandleAQFailure(AQ_FAILURE_PREROUTING_FAILED, hr, pParams->pIMailMsgProperties);
            ErrorTrace((LPARAM)this, "fRouteAndQueueMsg failed with hr %08lx", hr);
            DecMsgsInSystem(FALSE, FALSE);

            //don't passback shutdown errors in completions routines
            if (AQUEUE_E_SHUTDOWN == hr)
                hr = S_OK;
        }
    }

    //
    // Release mailmsg reference added in TriggerPostCategorizerEventOneMsg
    //
    pParams->pIMailMsgProperties->Release();

    //
    // Release reference to this object added in
    // TriggerPostCategorizerEventOneMsg
    //
    Release();
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK; //we should always handle failures internally here
}

//---[ CatCompletion ]---------------------------------------------------------
//
//
//  Description:
//      Message Categoriztion Completion function
//  Parameters:
//      hrCatResult     HRESULT of categorization attempt
//      pContext        Context as passed into MsgCat
//      pIMsg           Single categorized IMsg (if not bifurcated)
//      rgpIMsg         NULL terminated array of IMsg's (bifurcated)
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::CatCompletion(HRESULT hrCatResult, PVOID pContext,
                      IUnknown *pIMsg,
                      IUnknown **rgpIMsg)
{
    TraceFunctEnterEx((LPARAM) pIMsg, "CatCompletion");
    HRESULT hr = S_OK;
    CAQSvrInst *paqinst = (CAQSvrInst *) pContext;
    IMailMsgProperties *pIMailMsg = NULL;
    IMailMsgQueueMgmt  *pIMailMsgQM = NULL;
    _ASSERT(paqinst);
    _ASSERT(CATMSGQ_SIG == paqinst->m_dwSignature);

    //Increment count of times CatCompletion called
    InterlockedIncrement((PLONG) &(paqinst->m_cCatCompletionCalled));
    paqinst->m_asyncqPreCatQueue.DecPendingAsyncCompletions();


    //make sure Cat is returning an HRESULT
    _ASSERT(!hrCatResult || (hrCatResult & 0xFFFF0000));

    if (SUCCEEDED(hrCatResult))
    {
        //
        // Kick off post categorize event
        //
        InterlockedDecrement((PLONG) &(paqinst->m_cCurrentMsgsPendingCat));
        paqinst->TriggerPostCategorizeEvent(pIMsg, rgpIMsg);
    }
    else if (FAILED(hrCatResult) &&
             (CAT_E_RETRY == hrCatResult))
    {
        //MsgCat has some re-tryable error...
        //stick it back in the queue and retry later
        DebugTrace((LPARAM) paqinst, "INFO: MsgCat had tmp failure - hr 0x%08X", hr);

        //
        //  Adjust counters... they we be adjusted correctly per msg in
        //  HandleCatRetryOneMessage
        //
        InterlockedDecrement((PLONG) &(paqinst->m_cCurrentMsgsPendingCat));
        paqinst->DecMsgsInSystem(FALSE, FALSE);

        if(pIMsg)
        {
            paqinst->HandleCatRetryOneMessage(pIMsg);
        }
        else
        {
            _ASSERT(rgpIMsg);
            IUnknown **ppIMsgCurrent = rgpIMsg;

            while(*ppIMsgCurrent)
            {
                paqinst->HandleCatRetryOneMessage(*ppIMsgCurrent);
                ppIMsgCurrent++;
            }
        }
    }
    else
    {
        _ASSERT(pIMsg && rgpIMsg == NULL && "Message bifurcated inspite of non-retryable cat error");
        paqinst->HandleCatFailure(pIMsg, hrCatResult);
    }   // Non retryable error

    TraceFunctLeaveEx((LPARAM)paqinst);
    return S_OK; //all errors should be handled internally
}



//---[ CAQSvrInst::HandleCatRetryOneMessage ]----------------------------------
//
//
//  Description:
//      Handles cat retry for a single message
//  Parameters:
//      pIUnknown        IUnknown for the message to retry
//  Returns:
//      -
//  History:
//      4/13/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleCatRetryOneMessage(IUnknown *pIUnknown)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HandleCatRetryOneMessage");
    IMailMsgProperties *pIMailMsgProperties = NULL;
    HRESULT hr = S_OK;

    hr = pIUnknown->QueryInterface(IID_IMailMsgProperties,
                                   (void **) &pIMailMsgProperties);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgProperties FAILED");
    if (FAILED(hr))
        goto Exit;

    //
    //  Check and see if the message is still valid
    //
    if (!fShouldRetryMessage(pIMailMsgProperties))
        goto Exit;

    //
    //  Queue it to the pre-cat queue
    //
    hr = m_asyncqPreCatQueue.HrQueueRequest(pIMailMsgProperties,
                TRUE, cCountMsgsForHandleThrottling(pIMailMsgProperties));
    if (FAILED(hr))
    {
        HandleAQFailure(AQ_FAILURE_PRECAT_RETRY, hr, pIMailMsgProperties);
        goto Exit;
    }

    //
    //  Adjust counters as appropriate
    //
    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingCat);
    cIncMsgsInSystem();

    //
    // Kick off cat retry if needed
    //
    ScheduleInternalRetry(LI_TYPE_PENDING_CAT);

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    TraceFunctLeave();
}

//---[ CAQSvrInst::HandleCatFailure ]------------------------------------------
//
//
//  Description:
//      Handles the details of post cat DSN generation.  Will put the
//      message in the failed queue if DSN generation fails
//  Parameters:
//      pIUnknown           IUnkown for mailmsg
//      hrCatResult         Error code returned by cat
//  Returns:
//      -
//  History:
//      11/11/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleCatFailure(IUnknown *pIUnknown, HRESULT hrCatResult)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HandleCatFailure");
    HRESULT hr = S_OK;
    IMailMsgProperties *pIMailMsgProperties = NULL;
    BOOL    fHasShutdownLock = FALSE;

    ErrorTrace((LPARAM) this,
        "ERROR: MsgCat failed, will try to NDR message - hr 0x%08X",
        hrCatResult);

    InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingCat);
    DecMsgsInSystem(FALSE, FALSE);

    const char *rgszStrings[1] = { NULL };

    if(!pIUnknown)
        goto Exit;

    //If we are shutting down, this error could be caused by a shutdown being
    //signaled.  If this is the case, we do not want to log an error or
    //generate an NDR.
    if (!fTryShutdownLock())
        goto Exit;

    fHasShutdownLock = TRUE;

    HrTriggerLogEvent(
        AQUEUE_CAT_FAILED,              // Message ID
        TRAN_CAT_QUEUE_ENGINE,          // Category
        1,                              // Word count of substring
        rgszStrings,                    // Substring
        EVENTLOG_WARNING_TYPE,          // Type of the message
        hrCatResult,                    // error code
        LOGEVENT_LEVEL_MEDIUM,          // Logging level
        "phatq",                        // key to this event
        LOGEVENT_FLAG_PERIODIC,         // Logging option
        0,                              // index of format message string in rgszStrings
        GetModuleHandle(AQ_MODULE_NAME)        // module handle to format a message
    );

    hr = pIUnknown->QueryInterface(IID_IMailMsgProperties,
                                   (void **) &pIMailMsgProperties);

    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgProperties FAILED");
    if (FAILED(hr))
        goto Exit;

    // we ignore errors on this since it is only to help debug
    // cat failures
    pIMailMsgProperties->PutDWORD(IMMPID_MP_HR_CAT_STATUS,
                                  hrCatResult);


    hr = HandleFailedMessage(pIMailMsgProperties,
                             TRUE,
                             NULL,
                             MESSAGE_FAILURE_CAT,
                             hrCatResult);

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    if (fHasShutdownLock)
        ShutdownUnlock();

    TraceFunctLeave();
}

//+------------------------------------------------------------
//
// Function: CAQSvrInst::ResetRoutes
//
// Synopsis: This is a sink callback function; sinks will call this
// function when they wish to reset next hop routes or message types.
//
// Arguments:
//  dwResetType: Must be either RESET_NEXT_HOPS or RESET_MESSAGE_TYPES
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: bogus dwResetType
//
// History:
// jstamerj 1998/07/10 19:27:45: Created.
//      3/9/99 - MikeSwa Added async reset
//
//-------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ResetRoutes(
    IN  DWORD dwResetType)
{
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::ResetRoutes");
    HRESULT hr = S_OK;
    InterlockedIncrement((PLONG) &m_cTotalResetRoutes);

    if(dwResetType == RESET_NEXT_HOPS) {

        DebugTrace((LPARAM)this, "ResetNextHops called");

        if (1 == InterlockedIncrement((PLONG) &m_cCurrentPendingResetRoutes))
        {
            DebugTrace((LPARAM) this, "Adding ResetRoutes operation to work queue");
            AddRef(); //released in completion function
            hr = HrQueueWorkItem(this, CAQSvrInst::fResetRoutesNextHopCompletion);
            //Failure will still call completion function, so we should not release
        }
        else
        {
            DebugTrace((LPARAM) this, "Other ResetRoutes pending... only one pending allowed");
            InterlockedDecrement((PLONG) &m_cCurrentPendingResetRoutes);
        }

    } else if(dwResetType == RESET_MESSAGE_TYPES) {

        DebugTrace((LPARAM)this, "ResetMessageTypes called");
        //$$TODO: Reset message types

    } else {

        ErrorTrace((LPARAM)this, "ResetRoutes called with bogus dwResetType %08lx",
                   dwResetType);
        hr =  E_INVALIDARG;

    }
    return hr;
}

//---[ CAQSvrInst::LogResetRouteEvent ]----------------------------------------
//
//
//  Description:
//      Log statistics on resetroute
//  Parameters:
//      dwObtainLock    time spend on obtaining exclusive lock
//      dwWaitLock      time spend on waiting for the lock
//      dwQueue         queue length at the moment
//  History:
//      11/10/2000 haozhang created
//
//-----------------------------------------------------------------------------

void CAQSvrInst::LogResetRouteEvent( DWORD dwObtainLock,
                    DWORD dwWaitLock,
                    DWORD dwQueue)
{

    LPSTR lpstr[3];

    char subStrings[3][13];

    sprintf (subStrings[0],"%d",dwObtainLock);
    sprintf (subStrings[1],"%d",dwWaitLock);
    sprintf (subStrings[2],"%d",dwQueue);

    lpstr[0] = subStrings[0];
    lpstr[1] = subStrings[1];
    lpstr[2] = subStrings[2];

    HrTriggerLogEvent(
        AQUEUE_RESETROUTE_DIAGNOSTIC,          // Message ID
        TRAN_CAT_QUEUE_ENGINE,                 // Category ID
        3,                                     // Word count of substring
        (LPCSTR *) lpstr,                      // Substring
        EVENTLOG_INFORMATION_TYPE,             // Type of the message
        0,                                     // No error code
        LOGEVENT_LEVEL_MEDIUM,                 // Debug level
        NULL,                                  // Key to identify this event
        LOGEVENT_FLAG_ALWAYS
      );
}


//---[ CAQSvrInst::fResetRoutesNextHopCompletion ]-----------------------------
//
//
//  Description:
//      Completion function that handles async reset routes
//  Parameters:
//      pvThis      Ptr to CAQSvrInst
//      dwStatus    Status returned by
//  Returns:
//      TRUE always
//  History:
//      3/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fResetRoutesNextHopCompletion(PVOID pvThis, DWORD dwStatus)
{
    TraceFunctEnterEx((LPARAM) pvThis, "CAQSvrInst::fResetRoutesNextHopCompletion");
    CAQSvrInst *paqinst = (CAQSvrInst *) pvThis;
    DWORD       cCurrentPendingResetRoutes = 0;
    DWORD       dwPreLock;
    DWORD       dwObtainLock;
    DWORD       dwReleaseLock;
    DWORD       dwQueue;
    HRESULT     hr  =   S_OK;

    _ASSERT(paqinst);

    if (ASYNC_WORK_QUEUE_NORMAL == dwStatus)
    {
        if (paqinst && paqinst->fTryShutdownLock())
        {
            DebugTrace((LPARAM) paqinst, "Rerouting domains");

            dwPreLock = GetTickCount();

            paqinst->m_slPrivateData.ExclusiveLock();

            dwObtainLock = GetTickCount();

            dwQueue = paqinst->m_cCurrentRemoteDestQueues;

            //Drop pending reset routes count here.  We should do it after
            //we grab the lock to prevent too many threads from
            //trying to grab it exclusively.  We also need to do it
            //before we actual update any routing info in case a ResetRoutes
            //is requested midway through this update.
            cCurrentPendingResetRoutes = InterlockedDecrement((PLONG)
                                &(paqinst->m_cCurrentPendingResetRoutes));

            //Make sure the count hasn't gone negative
            _ASSERT(cCurrentPendingResetRoutes < 0xFFFFFF00);

            //With the lock held, call HrBeginRerouteDomains.  This function
            //will flag a reroute in progress and will move all domains to
            //the currently unreachable queue.
            hr = paqinst->m_dmt.HrBeginRerouteDomains();
            paqinst->m_slPrivateData.ExclusiveUnlock();

            dwReleaseLock = GetTickCount();

            // If the first part failed, we don't do the second part
            if(SUCCEEDED(hr))
            {
                //Now, having released the lock, call HrCompleteRerouteDomains.
                //This function will reroute the contents of the currently
                //unreachable queue and will then unflag the reroute in progress.
                paqinst->m_dmt.HrCompleteRerouteDomains();
            }

            //If things have been re-routing to a special link... we should
            //process them as well.
            paqinst->m_dmt.ProcessSpecialLinks(paqinst->m_dwDelayExpireMinutes,
                                           FALSE);

            paqinst->ShutdownUnlock();

            //
            // Log Event of ResetRoute
            //
            paqinst->LogResetRouteEvent(
                                dwObtainLock - dwPreLock,     // time to obtain the exclusive lock
                                dwReleaseLock - dwObtainLock, // time waiting on the lock
                                dwQueue                       // number of queues
                                );
        }
    }
    else
    {
        if (paqinst)
        {
            cCurrentPendingResetRoutes = InterlockedDecrement((PLONG)
                                    &(paqinst->m_cCurrentPendingResetRoutes));

            //Make sure the count hasn't gone negative
            _ASSERT(cCurrentPendingResetRoutes < 0xFFFFFF00);
        }

        if (ASYNC_WORK_QUEUE_FAILURE & dwStatus)
            ErrorTrace((LPARAM) paqinst, "ResetRoutes completion failure");
    }

    if (paqinst)
        paqinst->Release();

    TraceFunctLeave();
    return TRUE;
}

//---[ CAQSvrInst::GetDomainInfoFlags ]--------------------------------------
//
//
//  Description:
//      Determines if a domain is local (has DOMAIN_INFO_LOCAL_MAILBOX set)
//  Parameters:
//      IN  szDomainName        Name of domain to check for
//      OUT pdwDomainInfoFlags  DomainInfo flags for this domain
//  Returns:
//      S_OK on success
//      E_INVALIDARG if szDomainName or pdwDomainInfoFlags is NULL
//  History:
//      7/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetDomainInfoFlags(
                IN  LPSTR szDomainName,
                OUT DWORD *pdwDomainInfoFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::GetDomainInfoFlags");
    BOOL    fLocked         = FALSE;
    HRESULT hr              = S_OK;
    DWORD   cbDomainName    = 0;
    CInternalDomainInfo              *pIntDomainInfo = NULL;
    ISMTPServerGetAuxDomainInfoFlags *pISMTPServerGetAuxDomainInfoFlags = NULL;
    DWORD                             dwSinkDomainFlags = 0;

    _ASSERT(pdwDomainInfoFlags && "Invalid Param");
    _ASSERT(szDomainName && "Invalid Param");

    if (!pdwDomainInfoFlags || !szDomainName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    cbDomainName = lstrlen(szDomainName);
    hr = m_dct.HrGetInternalDomainInfo(cbDomainName, szDomainName,
                                        &pIntDomainInfo);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIntDomainInfo);

    // Aux Domain info not found, use the config we got from our own tables
    *pdwDomainInfoFlags = pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags;

    // We should have gotten back domain config even if it is only
    // the default config - now we need to see if we can get more
    // specific data from an event sink
    if (!cbDomainName || pIntDomainInfo->m_DomainInfo.szDomainName[0] == '*')
    {
        // QI for ISMTPServerGetAuxDomainInfoFlags interface
        hr = m_pISMTPServer->QueryInterface(
            IID_ISMTPServerGetAuxDomainInfoFlags,
            (LPVOID *)&pISMTPServerGetAuxDomainInfoFlags);

        if (FAILED(hr)) {
            ErrorTrace((LPARAM) this,
                "Unable to QI for ISMTPServerGetAuxDomainInfoFlags 0x%08X",hr);

            // Drop this error, this isn't fatal
            hr = S_OK;
            goto Exit;
        }

        // Check for domain info
        hr = pISMTPServerGetAuxDomainInfoFlags->HrTriggerGetAuxDomainInfoFlagsEvent(
                    szDomainName,
                    &dwSinkDomainFlags);

        if (FAILED(hr)) {
            ErrorTrace((LPARAM) this,
                "Failed calling HrTriggerGetAuxDomainInfoFlags 0x%08X",hr);

            // Drop this error, this isn't fatal
            hr = S_OK;
            goto Exit;
        }

        if (dwSinkDomainFlags & DOMAIN_INFO_INVALID) {
            // Domain info not found from event sink
            hr = S_OK;
            goto Exit;
        }

        // Ok, we got Aux Domain info, use it
        *pdwDomainInfoFlags = dwSinkDomainFlags;
    }

  Exit:

    if (pISMTPServerGetAuxDomainInfoFlags)
        pISMTPServerGetAuxDomainInfoFlags->Release();

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    if (fLocked)
        ShutdownUnlock();

    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CAQSvrInst::GetMessageRouter
//
// Synopsis: Default functionality of GetMessageRouter
//           If there is no current IMessageRouter, provide the
//           default IMessageRouter
//
// Arguments:
//  pIMailMsgProperties: MailMsg that needs a router
//  pICurrentRouter: current sink provided router
//  ppIMessageRouter: out param for new IMessageRouter
//
// Returns:
//  S_OK: Success, provided IMessageRouter
//  E_NOTIMPL: Didn't provide an IMessageRouter
//
// History:
// jstamerj 1998/07/10 19:33:41: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetMessageRouter(
    IN  IMailMsgProperties      *pIMailMsgProperties,
    IN  IMessageRouter          *pICurrentMessageRouter,
    OUT IMessageRouter          **ppIMessageRouter)
{
    _ASSERT(ppIMessageRouter);

    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::GetMessageRouter");
    if((pICurrentMessageRouter == NULL) &&
       (m_pIMessageRouterDefault)) {

        //
        // Return our default IMessageRouter and AddRef for the caller
        //
        *ppIMessageRouter = m_pIMessageRouterDefault;
        m_pIMessageRouterDefault->AddRef();

        DebugTrace((LPARAM)this, "Supplying default IMessageRouter");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;

    } else {

        TraceFunctLeaveEx((LPARAM)this);
        return E_NOTIMPL;
    }
}


//---[ CAQSvrInst::HrTriggerDSNGenerationEvent ]-----------------------------
//
//
//  Description:
//      Triggers DSN Generation event
//  Parameters:
//      pdsnparams      A CDSNParams that will be used to trigger event
//      fHasRoutingLock TRUE if routing lock is current held by this thread
//  Returns:
//      S_OK on success (and DSN was generated)
//      S_FALSE on success, but no DSN generated
//      AQUEUE_E_NOT_INITIALIZED if not initialized correctly
//  History:
//      7/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrTriggerDSNGenerationEvent(CDSNParams *pdsnparams,
                                                BOOL fHasRoutingLock)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrTriggerDSNGenerationEvent");
    HRESULT hr = S_OK;
    DWORD cCurrent = 0;
    CRefCountedString *prstrDefaultDomain = NULL;
    LPSTR szDefaultDomain = NULL;
    CRefCountedString *prstrCopyNDRTo = NULL;
    LPSTR szCopyNDRTo = NULL;
    CRefCountedString *prstrFQDN = NULL;
    LPSTR szFQDN = NULL;
    DWORD cCurrentDSNsGenerated = 0;
    DWORD cbCurrentSize = 0;
    FILETIME *pftExpireTime = NULL;
    FILETIME ftExpireTime;

    if (!(m_dwInitMask & CMQ_INIT_DSN) || !m_pISMTPServer)
    {
        hr = AQUEUE_E_NOT_INITIALIZED;
        goto Exit;
    }

    //Get config string from ref-counted objects
    if (!fHasRoutingLock)
        m_slPrivateData.ShareLock();
    else
        m_slPrivateData.AssertIsLocked();

    if (m_prstrDefaultDomain)
    {
        prstrDefaultDomain = m_prstrDefaultDomain;
        prstrDefaultDomain->AddRef();
        szDefaultDomain = prstrDefaultDomain->szStr();
    }
    else
    {
        //we need to have something as our default domain
        szDefaultDomain = "localhost";
    }

    if (m_prstrCopyNDRTo)
    {
        prstrCopyNDRTo = m_prstrCopyNDRTo;
        prstrCopyNDRTo->AddRef();
        szCopyNDRTo = prstrCopyNDRTo->szStr();
    }

    if (m_prstrServerFQDN)
    {
        prstrFQDN = m_prstrServerFQDN;
        prstrFQDN->AddRef();
        szFQDN = prstrFQDN->szStr();
    }

    if (!fHasRoutingLock)
        m_slPrivateData.ShareUnlock();
    //
    // Get the expire time
    //
    hr = pdsnparams->pIMailMsgProperties->GetProperty(
        IMMPID_MP_EXPIRE_NDR,
        sizeof(FILETIME),
        &cbCurrentSize,
        (BYTE *) &ftExpireTime);
    if (SUCCEEDED(hr))
    {
        _ASSERT(sizeof(FILETIME) == cbCurrentSize);
        pftExpireTime = &ftExpireTime;
    }
    else if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //
        // Calculate the expire time based on the arrival time
        //
        hr = pdsnparams->pIMailMsgProperties->GetProperty(
            IMMPID_MP_ARRIVAL_FILETIME,
            sizeof(FILETIME),
            &cbCurrentSize,
            (BYTE *) &ftExpireTime);
        if(SUCCEEDED(hr))
        {
            CalcExpireTimeNDR(ftExpireTime, FALSE, &ftExpireTime);
            pftExpireTime = &ftExpireTime;
        }
        else if(hr == MAILMSG_E_PROPNOTFOUND)
            hr = S_OK;
        else
            goto Exit;
    }
    else
        goto Exit;

    //
    // Set the CDSNParam's paqinst pointer so that
    // CDSNParams::HrSubmitDSN call call back into this CAQSvrInst
    // object.
    //
    pdsnparams->paqinst = this;

    hr = m_dsnsink.GenerateDSN(
        this,
        m_dwServerInstance,
        m_pISMTPServer,
        pdsnparams->pIMailMsgProperties,
        pdsnparams->dwStartDomain,
        pdsnparams->dwDSNActions,
        pdsnparams->dwRFC821Status,
        pdsnparams->hrStatus,
        szDefaultDomain,
        szFQDN,
        (CHAR *) DEFAULT_MTA_TYPE,
        pdsnparams->szDebugContext,
        m_dwDSNLanguageID,
        m_dwDSNOptions,
        szCopyNDRTo,
        pftExpireTime,
        pdsnparams,
        g_dwMaxDSNSize);

    if (SUCCEEDED(hr))
    {
        if(pdsnparams->dwDSNTypesGenerated)
        {
            // A DSN was generated
            hr = S_OK;
        }
        else
        {
            // No DSN was generated
            hr = S_FALSE;
        }
    }
    else if (AQUEUE_E_NDR_OF_DSN == hr)
    {
        hr = S_FALSE;  //report as no DSN generated

        //original message is badmail
        HandleBadMail(pdsnparams->pIMailMsgProperties, TRUE, NULL,
                      AQUEUE_E_NDR_OF_DSN, fHasRoutingLock);
        InterlockedIncrement((PLONG) &m_cBadmailNdrOfDsn);
    }
    else
    {
        //bail out on failure
        InterlockedIncrement((PLONG) &m_cTotalDSNFailures);

        //
        //  Check to see if the message has been deleted... store driver
        //  has been gone away.
        //
        if (!fShouldRetryMessage(pdsnparams->pIMailMsgProperties, FALSE))
        {
            DebugTrace((LPARAM) this, "Msg no longer valid... abandoning");
            hr = S_FALSE;
        }
        goto Exit;
    }

  Exit:
    if (prstrDefaultDomain)
        prstrDefaultDomain->Release();

    if (prstrCopyNDRTo)
        prstrCopyNDRTo->Release();

    if (prstrFQDN)
        prstrFQDN->Release();

    TraceFunctLeave();
    return hr;

}

//---[ CAQSvrInst::HrNDRUnresolvedRecipients ]-------------------------------
//
//
//  Description:
//      NDR any unresolved recipients for a given IMailMsgProperties.  Also
//      generates a expanded DSNs
//  Parameters:
//      IN  pIMailMsgProperties     IMailMsgProperties to generate NDR for
//      IN  pIMailMsgRecipients     Recipients interface for message
//  Returns:
//      S_OK on success and message should continue through transport
//      S_FALSE on success, but message should not be queued for delivery
//  History:
//      7/21/98 - MikeSwa Created
//      10/14/98 - MikeSwa Modified to use common utility functions
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrNDRUnresolvedRecipients(
                                      IMailMsgProperties *pIMailMsgProperties,
                                      IMailMsgRecipients *pIMailMsgRecipients)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrNDRUnresolvedRecipients");
    HRESULT hr = S_OK;
    HRESULT hrCat = S_OK;  //cat HRESULT
    DWORD   cbProp = 0;
    DWORD   iCurrentDomain = 0;
    DWORD   cRecips = 0;

    _ASSERT(pIMailMsgProperties);

    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_HR_CAT_STATUS, sizeof(HRESULT),
                    &cbProp, (BYTE *) &hrCat);
    if (FAILED(hr))
    {
        if (MAILMSG_E_PROPNOTFOUND == hr) //no result... don't generate DSN
            hr = S_OK; //not really an error
        goto Exit;
    }

    if (CAT_W_SOME_UNDELIVERABLE_MSGS == hrCat)
    {
        //There was an error resolving recipients
        //We need to NDR all recipients with hard errors (like RP_UNRESOLVED)
        //and expand any recipient marked expanded.
        CDSNParams  dsnparams;
        dsnparams.dwStartDomain = 0;
        dsnparams.dwDSNActions = DSN_ACTION_FAILURE | DSN_ACTION_EXPANDED;
        dsnparams.pIMailMsgProperties = pIMailMsgProperties;
        dsnparams.hrStatus = CAT_W_SOME_UNDELIVERABLE_MSGS;

        hr = HrLinkAllDomains(pIMailMsgProperties);
        if (FAILED(hr))
            goto Exit;

        //Fire DSN Generation event
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        hr = HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;

        //Check to see how many recipients have been NDRd
        hr = pIMailMsgRecipients->Count(&cRecips);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                       "ERROR: IMailMsgRecipients::Count() FAILED - hr 0x%08X", hr);
            goto Exit;
        }

        //If all recipients have been handled... return S_FALSE
        if (dsnparams.cRecips == cRecips)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }

    }
    else
    {
        hr = S_OK;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::fPreLocalDeliveryQueueCompletion ]------------------------
//
//
//  Description:
//      Completion function for PerLocal delivery queue
//  Parameters:
//      pmsgref - Msgref to attempt delivery for
//  Returns:
//      TRUE    If Delivery attempt was handled (delivered or NDR'd)
//      FALSE   If MsgRef needs to be requeued
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fPreLocalDeliveryQueueCompletion(CMsgRef *pmsgref)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::fPreLocalDeliveryQueueCompletion");
    HRESULT hr = S_OK;
    BOOL    fMsgHandled = TRUE;
    BOOL    fLocked = FALSE;  //TRUE if locked for shutdown
    DWORD         cRecips   = 0;
    DWORD        *rgdwRecips= 0;
    CAQStats aqstat;
    CLinkMsgQueue *plmq = NULL;
    BOOL    fReleaseLDNotify = FALSE;
    CAQLocalDeliveryNotify *pLDNotify = NULL;
    BOOL    fUpdateCounters = TRUE;

    if (NULL == m_pISMTPServer) {
        ErrorTrace((LPARAM) this,
                   "ERROR: Local Delivery not configured properly");
        goto Exit;
    }

    if (NULL == pmsgref) {
        ErrorTrace((LPARAM) this,
                   "ERROR: Local Delivery not configured properly, msgref=NULL");
        goto Exit;
    }

    if (!fTryShutdownLock()) {
        goto Exit;
    }

    pLDNotify = new CAQLocalDeliveryNotify(this, pmsgref);
    if (!pLDNotify) {
        ErrorTrace((LPARAM) this,
                   "ERROR: new CAQLocalDeliveryNotify failed");
        fMsgHandled = FALSE;
        goto Exit;
    }
    fReleaseLDNotify = TRUE;

    fLocked = TRUE;

    if (pmsgref->fIsMsgFrozen())
    {
        //Message is frozen... requeue message
        fMsgHandled = FALSE;
        goto Exit;
    }

    hr = m_dmt.HrPrepareForLocalDelivery(pmsgref,
                                         FALSE,
                                         pLDNotify->pdcntxtGetDeliveryContext(),
                                         &cRecips,
                                         &rgdwRecips);
    if (FAILED(hr))
    {
        if ((AQUEUE_E_MESSAGE_HANDLED != hr) && (AQUEUE_E_MESSAGE_PENDING != hr))
        {
            //message will be retried when last reference is released.
            pmsgref->RetryOnDelete();
            ErrorTrace((LPARAM) this, "ERROR: HrPrepareLocalDelivery FAILED - hr 0x%08X", hr);
        }
        fMsgHandled = TRUE;
        hr = S_OK;
        goto Exit;
    }

    //Increase Ref count for message ref (as if it was actually queued)
    pmsgref->AddRef();

    //Send off for local delivery
    InterlockedIncrement((PLONG) &m_cCurrentMsgsInLocalDelivery);

    MSG_TRACK_INFO msgTrackInfo;
    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_LOCAL_DELIVERY;
    msgTrackInfo.cRcpts = cRecips;
    m_pISMTPServer->WriteLog(&msgTrackInfo,
                             pLDNotify->pimsgGetIMsg(),
                             NULL,
                             NULL);
    // from here on we will end up calling LDCompletion, and they will
    // release it
    fReleaseLDNotify = FALSE;

    m_asyncqPreLocalDeliveryQueue.IncPendingAsyncCompletions();

    // we need to hold a reference on pLDNotify to be able to call
    // into fNotCalledCompletion
    pLDNotify->AddRef();

    fUpdateCounters = FALSE;

    if (m_pISMTPServerAsync) {
        hr = m_pISMTPServerAsync->TriggerLocalDeliveryAsync(
                                  pLDNotify->pimsgGetIMsg(),
                                  cRecips,
                                  rgdwRecips,
                                  pLDNotify);
    } else {
        hr = m_pISMTPServer->TriggerLocalDelivery(
                                  pLDNotify->pimsgGetIMsg(),
                                  cRecips,
                                  rgdwRecips);
    }

    // if we get back any error code besides MAILMSG_S_PENDING then
    // the dispatcher completed sync.  We need to see if the
    // completion function was called, and if not then we need to call
    // it ourselves.
    if (hr != MAILMSG_S_PENDING && pLDNotify->fNotCalledCompletion()) {
        LDCompletion(hr, this, pmsgref, pLDNotify);
    }

    // after this point we can't call pLDNotify
    pLDNotify->Release();

  Exit:
    if (fUpdateCounters && fMsgHandled) {
        UpdateLDCounters(pmsgref);
    }

    if (fReleaseLDNotify) {
        pLDNotify->Release();
    }

    if (fLocked)
        ShutdownUnlock();

    TraceFunctLeave();
    return fMsgHandled;
}

//---[ CAQSvrInst::LDCompletion ]----------------------------------------------
//
//
//  Description:
//      Completion function local delivery
//  Parameters:
//      hrLDResult - local delivery status
//      pContext - this
//      pmsgref - msgref that we were delivering.
//  History:
//      10/30/2000 - AWetmore Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::LDCompletion(HRESULT hr,
                              PVOID pContext,
                              CMsgRef *pmsgref,
                              CAQLocalDeliveryNotify *pLDNotify)
{
    TraceFunctEnter("CAQSvrInst::LDCompletion");

    BOOL    fMsgHandled = TRUE;
    MessageAck *pMsgAck = pLDNotify->pmsgackGetMsgAck();
    CAQSvrInst *pThis = (CAQSvrInst *) pContext;

    InterlockedDecrement((PLONG) &(pThis->m_cCurrentMsgsInLocalDelivery));
    pThis->m_asyncqPreLocalDeliveryQueue.DecPendingAsyncCompletions();

    if (FAILED(hr)) {
        //We will need to handle in one of 2 ways:
        //  - set fMsgHandled to FALSE (on STOREDRV_E_RETRY)
        //  - NDR the message (on other errors)
        if (STOREDRV_E_RETRY == hr) {
            //try... try again
            DebugTrace((LPARAM) pmsgref, "INFO: Msg queued for local retry");
            fMsgHandled = FALSE;
            pMsgAck->dwMsgStatus = MESSAGE_STATUS_RETRY;

            pThis->ScheduleInternalRetry(LI_TYPE_LOCAL_DELIVERY);
        } else {
            ErrorTrace((LPARAM) pmsgref, "ERROR: Local delivery failed. - hr 0x%08X", hr);
            pMsgAck->dwMsgStatus = MESSAGE_STATUS_NDR_ALL;
        }
    } else {
        InterlockedIncrement(&(pThis->m_cMsgsDeliveredLocal));
    }

    pMsgAck->pIMailMsgProperties = pLDNotify->pimsgGetIMsg();
    pMsgAck->pvMsgContext = (DWORD *) pLDNotify->pdcntxtGetDeliveryContext();
    pMsgAck->dwMsgStatus |= MESSAGE_STATUS_LOCAL_DELIVERY;

    //
    //  Make sure we should retry the message.  We want to do this before we
    //  ACK the message so that we do not reopen the P1 stream if we *are*
    //  retrying it.
    //
    if (!fMsgHandled)
        fMsgHandled = !pmsgref->fShouldRetry();

    hr = pThis->HrAckMsg(pMsgAck, TRUE);
    if (FAILED(hr)) {
        ErrorTrace((LPARAM) pThis, "ERROR: Local MsgAck failed - hr 0x%08X", hr);
        goto Exit;
    }

  Exit:
    if (fMsgHandled) //we aren't retrying message
    {
        pThis->UpdateLDCounters(pmsgref);
    } else {
        // retry this message
        pThis->HandleLocalRetry(pLDNotify->pmsgrefGetMsgRef());
    }

    // clean up after ourselves
    pLDNotify->Release();

    SleepForPerfAnalysis(g_dwLocalQueueSleepMilliseconds);
    TraceFunctLeave();
}


//---[ CAQSvrInst::UpdateLDCounters ]------------------------------------------
//
//
//  Description:
//      Update the local delivery queue counters
//  Parameters:
//      pmsgref - msgref that we were delivering.
//  History:
//      05/11/2001 - AWetmore Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::UpdateLDCounters(CMsgRef *pmsgref) {
    TraceFunctEnter("CAQSvrInst::UpdateLDCounters");

    CAQStats aqstat;
    CLinkMsgQueue *plmq = NULL;
    HRESULT hr;

    InterlockedDecrement((PLONG) &(m_cCurrentMsgsPendingLocal));

    //
    // Update stats for the local link
    //
    pmsgref->GetStatsForMsg(&aqstat);
    plmq = m_dmt.plmqGetLocalLink();
    if (plmq)
    {
        hr = plmq->HrNotify(&aqstat, FALSE);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "HrNotify failed... local stats innaccurate 0x%08X", hr);
            hr = S_OK;
        }
        plmq->Release();
        plmq = NULL;
    }

    TraceFunctLeave();
}

//---[ CAQSvrInst::HandleLocalRetry ]------------------------------------------
//
//
//  Description:
//      Handles LD retry for a single message
//  Parameters:
//      pIUnknown        IUnknown for the message to retry
//  Returns:
//      -
//  History:
//      10/30/2000 - AWetmore Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleLocalRetry(CMsgRef *pmsgref)
{
    TraceFunctEnter("CAQSvrInst::HandleLocalRetry");
    IMailMsgProperties *pIMailMsgProperties = pmsgref->pimsgGetIMsg();
    HRESULT hr = S_OK;

    if (pIMailMsgProperties == NULL) {
        _ASSERT(pIMailMsgProperties && "pimsgGetIMsg() failed!!");
        hr = E_POINTER;
        goto Exit;
    }

    //
    //  Check and see if the message is still valid
    //
    if (!pmsgref->fShouldRetry())
        goto Exit;

    //
    //  Queue it to the local delivery queue
    //
    hr = m_asyncqPreLocalDeliveryQueue.HrQueueRequest(pmsgref, TRUE);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Enqueue to local delivery queue failed, 0x%08X", hr);
        pmsgref->RetryOnDelete();
        goto Exit;
    }

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    TraceFunctLeave();
}

//---[ CAQSvrInst::HrSetSubmissionTimeIfNecessary ]----------------------------
//
//
//  Description:
//      Sets the submission time on the message if it is not already set.
//
//  Parameters:
//      IN  pIMailMsgProperties     message to stamp
//  Returns:
//      S_OK on success
//  History:
//      8/13/98 - MikeSwa Created
//      10/9/98 - MikeSwa  - Changed behavior to that any pre-existing
//                  properties will be maintained.
//      5/16/2001 - dbraun changed to only set submission time
//                  (was SetMessageExpiry)
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrSetSubmissionTimeIfNecessary(IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrSetSubmissionTimeIfNecessary");
    HRESULT hr              = S_OK;
    DWORD   dwTimeContext   = 0;
    DWORD   cbProp          = 0;
    FILETIME ftSubmitTime;

    _ASSERT(pIMailMsgProperties);

    //Set arrival time
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_ARRIVAL_FILETIME,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftSubmitTime);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //Prop not set... we can set it
        m_qtTime.GetExpireTime(0, &ftSubmitTime, &dwTimeContext);
        hr = pIMailMsgProperties->PutProperty(IMMPID_MP_ARRIVAL_FILETIME,
            sizeof(FILETIME), (BYTE *) &ftSubmitTime);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to write arrival time to msg");
            goto Exit;
        }
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::CalcExpireTimeNDR ]-----------------------------------------
//
//
//  Description:
//      Calculates the message's NDR expire time
//
//  Parameters:
//      IN  ftSubmission            time the message was submitted
//      IN  fLocal                  Bool TRUE if we want local time,
//                                   otherwise returns remote
//      OUT pftExpire               Used to return expire time
//  Returns:
//      -
//  History:
//      5/16/2001 - dbraun created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::CalcExpireTimeNDR(FILETIME ftSubmission, BOOL fLocal, FILETIME *pftExpire)
{
    if (fLocal)
        m_qtTime.GetExpireTime(ftSubmission, m_dwLocalNDRExpireMinutes, pftExpire);
    else
        m_qtTime.GetExpireTime(ftSubmission, m_dwNDRExpireMinutes, pftExpire);
}

//---[ CAQSvrInst::CalcExpireTimeDelay ]---------------------------------------
//
//
//  Description:
//      Calculates the message's delay expire time
//
//  Parameters:
//      IN  ftSubmission            time the message was submitted
//      IN  fLocal                  Bool TRUE if we want local time,
//                                   otherwise returns remote
//      OUT pftExpire               Used to return expire time
//  Returns:
//      -
//  History:
//      5/16/2001 - dbraun created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::CalcExpireTimeDelay(FILETIME ftSubmission, BOOL fLocal, FILETIME *pftExpire)
{
    if (fLocal)
        m_qtTime.GetExpireTime(ftSubmission, m_dwLocalDelayExpireMinutes, pftExpire);
    else
        m_qtTime.GetExpireTime(ftSubmission, m_dwDelayExpireMinutes, pftExpire);
}


//---[ CAQSvrInst::AsyncQueueRetry ]-----------------------------------------
//
//
//  Description:
//      Restarts an async queue after a failure.
//  Parameters:
//      dwQueueID       Tells which queue to kick
//          PRELOCAL_QUEUE_ID   Retries pre-local queue
//          PRECAT_QUEUE_ID     Retries pre-cat queue
//          PREROUTING_QUEUE_ID Retries pre-routing queue
//          PRESUBMIT_QUEUE_ID  Retries pre-submit queue
//  Returns:
//      -
//  History:
//      8/17/98 - MikeSwa Created
//      3/3/2000 - MikeSwa Modified to add presubmit queue
//
//-----------------------------------------------------------------------------
void CAQSvrInst::AsyncQueueRetry(DWORD dwQueueID)
{
    _ASSERT(CATMSGQ_SIG == m_dwSignature);

    if (fTryShutdownLock())
    {
        if (PRELOCAL_QUEUE_ID == dwQueueID)
        {
            InterlockedDecrement((PLONG) &m_cLocalRetriesPending);
            m_asyncqPreLocalDeliveryQueue.StartRetry();
        }
        else if (PRECAT_QUEUE_ID == dwQueueID)
        {
            InterlockedDecrement((PLONG) &m_cCatRetriesPending);
            m_asyncqPreCatQueue.StartRetry();
        }
        else if (PREROUTING_QUEUE_ID == dwQueueID)
        {
            InterlockedDecrement((PLONG) &m_cRoutingRetriesPending);
            m_asyncqPreRoutingQueue.StartRetry();
        }
        else if (PRESUBMIT_QUEUE_ID == dwQueueID)
        {
            InterlockedDecrement((PLONG) &m_cSubmitRetriesPending);
            m_asyncqPreSubmissionQueue.StartRetry();
        }
        else
        {
            _ASSERT(0 && "Invalid Queue ID");
        }
        ShutdownUnlock();
    }
}

//---[ HrCreateBadMailPropertyFile ]------------------------------------------
//
//
//  Description:
//      Creates a property stream for the given message.  The property
//      stream file is given name the .BDP extension.
//  Parameters:
//      szDestFileBase      The filename of the actual badmail file
//      pIMailMsgProperties The original message that is being badmailed
//                          (may be NULL if it is a pickup dir file)
//  Returns:
//      S_OK on success
//      E_POINTER if szDestFileBase is NULL
//  History:
//      8/17/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrCreateBadMailPropertyFile(LPSTR szDestFileBase,
                                    IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrCreateBadMailPropertyFile");
    HRESULT hr = S_OK;
    CHAR    szOldExt[] = "123";
    CHAR    szNewExt[] = "BDP";
    LPSTR   szBadMailFileNameExt = NULL;
    DWORD   cbBadMailFileName = 0;
    BOOL    fShouldRestoreExtension = FALSE;
    CFilePropertyStream fstrm;
    IMailMsgBind *pIMailMsgBind = NULL;
    IMailMsgPropertyStream *pIMailMsgPropertyStream = NULL;

    _ASSERT(szDestFileBase);

    if (!szDestFileBase)
    {
        hr = E_POINTER;
        ErrorTrace((LPARAM) NULL, "Error NULL badmail filename passed in");
        goto Exit;
    }

    if (!pIMailMsgProperties) //no-op
        goto Exit;

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgBind,
                                             (void **) &pIMailMsgBind);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to QI for IMailMsgBind - 0x%08X", hr);
        goto Exit;
    }

    _ASSERT(pIMailMsgBind);

    //Create the filename & file
    cbBadMailFileName = strlen(szDestFileBase);
    _ASSERT(cbBadMailFileName > 4); //must at least have . extenstion
    szBadMailFileNameExt = szDestFileBase + cbBadMailFileName-3;

    //szBadMailFileNameExt now points to the first character of the 3 char ext
    _ASSERT('.' == *(szBadMailFileNameExt-1));
    _ASSERT(sizeof(szNewExt) == sizeof(szOldExt));
    memcpy(szOldExt, szBadMailFileNameExt, sizeof(szOldExt));
    memcpy(szBadMailFileNameExt, szNewExt, sizeof(szNewExt));
    fShouldRestoreExtension = TRUE;

    hr = fstrm.HrInitialize(szDestFileBase);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to create badmail property stream - 0x%08X", hr);
        goto Exit;
    }

    hr = fstrm.QueryInterface(IID_IMailMsgPropertyStream,
                              (void **) &pIMailMsgPropertyStream);
    _ASSERT(SUCCEEDED(hr)); //we control this totally
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to QI for IID_IMailMsgPropertyStream - 0x%08X", hr);
        goto Exit;
    }

    hr = pIMailMsgBind->GetProperties(pIMailMsgPropertyStream,
                                      MAILMSG_GETPROPS_COMPLETE, NULL);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "GetProperties failed with 0x%08X", hr);
        goto Exit;
    }

  Exit:
    if (fShouldRestoreExtension)
    {
        _ASSERT(szBadMailFileNameExt);
        memcpy(szBadMailFileNameExt, szOldExt, sizeof(szOldExt));
    }

    if (pIMailMsgBind)
        pIMailMsgBind->Release();

    if (pIMailMsgPropertyStream)
        pIMailMsgPropertyStream->Release();

    TraceFunctLeave();
    return hr;
}
//---[ HrCreateBadMailReasonFile ]---------------------------------------------
//
//
//  Description:
//      Creates a file in the badmail directory that expains why the given
//      message was badmailed, and dump the sender and recipient as well.  Uses
//      the extension BMR (BadMailReason) to differentiate from the content.
//  Parameters:
//      szDestFileBase      The filename of the actual badmail file
//      hrReason            The reason the badmail is being created
//      pIMailMsgProperties The original message that is being badmailed
//                          (may be NULL if it is a pickup dir file)
//  Returns:
//      S_OK on success
//      E_POINTER if szDestFileBase is NULL
//  History:
//      8/16/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrCreateBadMailReasonFile(IN LPSTR szDestFileBase,
                        IN HRESULT  hrReason,
                        IN IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrCreateBadMailReasonFile");
    HRESULT hr = S_OK;
    HRESULT hrErrorLogged = hrReason;
    WCHAR   wszBadmailReason[1000] = L"";  //Localized hrReason string
    WCHAR   wszReasonBuffer[2000] = L"";
    WCHAR   wszErrorCode[] = L"0x12345678 ";
    WCHAR   wszErrorCodeMessage[200] = L"";
    CHAR    szPropBuffer[1000] = "";
    DWORD   dwErr = 0;
    BOOL    fWriteBadmailReason = FALSE;
    BOOL    fShouldRestoreExtension = FALSE;
    DWORD   cReasonBuffer = 0;
    LPSTR   szBadMailFileNameExt = NULL;
    CHAR    szOldExt[] = "123";
    CHAR    szNewExt[] = "BDR";
    DWORD   cbBadMailFileName = 0;
    HANDLE  hBadMailFile = NULL;
    DWORD   cbBytesWritten = 0;
    DWORD   dwFacility = 0;
    LPWSTR  rgwszArgList[32];
    const   WCHAR wcszBlankLine[] = L"\r\n";
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    DWORD   cRecips = 0;
    DWORD   iCurrentRecip = 0;

    _ASSERT(szDestFileBase);
    if (!szDestFileBase)
    {
        ErrorTrace((LPARAM) NULL, "Invalid destination file for badmail");
        hr = E_POINTER;
        goto Exit;
    }

    if (!g_hAQInstance)
    {
        _ASSERT(g_hAQInstance && "This should always be set in DLL main");
        ErrorTrace((LPARAM) NULL, "Error, g_hAQInstance is NULL");
        hr = E_FAIL;
        goto Exit;
    }

    //Create the filename & file
    cbBadMailFileName = strlen(szDestFileBase);
    _ASSERT(cbBadMailFileName > 4); //must at least have . extenstion
    szBadMailFileNameExt = szDestFileBase + cbBadMailFileName-3;

    //szBadMailFileNameExt now points to the first character of the 3 char ext
    _ASSERT('.' == *(szBadMailFileNameExt-1));
    _ASSERT(sizeof(szNewExt) == sizeof(szOldExt));
    memcpy(szOldExt, szBadMailFileNameExt, sizeof(szOldExt));
    memcpy(szBadMailFileNameExt, szNewExt, sizeof(szNewExt));
    fShouldRestoreExtension = TRUE;

    hBadMailFile = CreateFile(szDestFileBase,
                              GENERIC_WRITE,
                              0,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);

    if (INVALID_HANDLE_VALUE ==hBadMailFile )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL,
            "Unable to create badmail reason file - err 0x%08X - file %s",
            hr, szDestFileBase);
        goto Exit;
    }

    //Figure out the reason for the failure
    if (SUCCEEDED(hrErrorLogged))
    {
        //someone is being lazy about setting the error reason
        _ASSERT(0 && "No badmail reason given");
        ErrorTrace((LPARAM) NULL, "Non-failing badmail HRESULT given 0x%08X",
                   hrErrorLogged);

        //Substitute a generic error so we don't have something obnoxious like
        //"The operation completed succesfully" appear in the badmail file
        hrErrorLogged = E_FAIL;
    }

    //Write the error code in "0x00000000" format
    wsprintfW(wszErrorCode, L"0x%08X", hrErrorLogged);

    dwFacility = ((0x0FFF0000 & hrErrorLogged) >> 16);

    //If it is not ours... then "un-HRESULT" it
    if (dwFacility != FACILITY_ITF)
        hrErrorLogged &= 0x0000FFFF;

    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       g_hAQInstance,
                       hrErrorLogged,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       wszBadmailReason,
                       sizeof(wszBadmailReason)/sizeof(WCHAR), NULL);

    if (!dwErr)
    {
        //We should fall back on a numeric error that we were given
        ErrorTrace((LPARAM) NULL,
            "Error: unable to format badmail message 0x%08X,  error is %d",
            hrErrorLogged, GetLastError());

        wcscpy(wszBadmailReason, wszErrorCode);
    }
    else
    {
        //Get rid of trailing newline
        cReasonBuffer = wcslen(wszBadmailReason);
        cReasonBuffer--;
        while(iswspace(wszBadmailReason[cReasonBuffer]))
        {
            wszBadmailReason[cReasonBuffer] = '\0';
            cReasonBuffer--;
        }
        cReasonBuffer = 0;
    }

    ErrorTrace((LPARAM) NULL,
        "Generating badmail because: %S", wszBadmailReason);

    rgwszArgList[0] = wszBadmailReason;
    rgwszArgList[1] = NULL;
    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       g_hAQInstance,
                       PHATQ_BADMAIL_REASON,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       wszReasonBuffer,
                       sizeof(wszReasonBuffer)/sizeof(WCHAR),
                       (va_list *) rgwszArgList);
    if (!dwErr)
    {
        ErrorTrace((LPARAM) NULL,
            "Error: unable to format PHATQ_BADMAIL_REASON,  error is %d",
            GetLastError());
        hr = HRESULT_FROM_WIN32(GetLastError());
        wcscpy(wszReasonBuffer, wszBadmailReason);
    }

    cReasonBuffer = wcslen(wszReasonBuffer);
    if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                   cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL,
            "Error writing to badmail reason file - erro 0x%08X - file %s",
            hr, szDestFileBase);
        goto Exit;
    }

    //Write the actual error code in 0x00000000 form so tools can parse it out
    rgwszArgList[0] = wszErrorCode;
    rgwszArgList[1] = NULL;
    wcscpy(wszReasonBuffer, wcszBlankLine);
    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       g_hAQInstance,
                       PHATQ_BADMAIL_ERROR_CODE,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       wszReasonBuffer+(sizeof(wcszBlankLine)-1)/sizeof(WCHAR),
                       (sizeof(wszReasonBuffer)-sizeof(wcszBlankLine))/sizeof(WCHAR),
                       (va_list *) rgwszArgList);

    wcscat(wszReasonBuffer, wcszBlankLine);
    cReasonBuffer = wcslen(wszReasonBuffer);
    if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                   cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL,
            "Error writing to badmail reason file - erro 0x%08X - file %s",
            hr, szDestFileBase);
        goto Exit;
    }

    //All the rest requries access to an actual message... if we don't
    //have one, bail
    if (!pIMailMsgProperties)
        goto Exit;

    //Write Sender of message
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_SENDER_ADDRESS_SMTP,
        sizeof(szPropBuffer), szPropBuffer);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "ERROR: Unable to get sender of IMailMsg 0x%08X",
            pIMailMsgProperties);
        hr = S_OK; //just don't display sender
    }
    else
    {
        rgwszArgList[0] = (LPWSTR) szPropBuffer;
        rgwszArgList[1] = NULL;
        wcscpy(wszReasonBuffer, wcszBlankLine);
        dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                           FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           g_hAQInstance,
                           PHATQ_BADMAIL_SENDER,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           wszReasonBuffer+(sizeof(wcszBlankLine)-1)/sizeof(WCHAR),
                           (sizeof(wszReasonBuffer)-sizeof(wcszBlankLine))/sizeof(WCHAR),
                           (va_list *) rgwszArgList);

        wcscat(wszReasonBuffer, wcszBlankLine);
        cReasonBuffer = wcslen(wszReasonBuffer);
        if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                       cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM) NULL,
                "Error writing to badmail reason file - erro 0x%08X - file %s",
                hr, szDestFileBase);
            goto Exit;
        }
    }


    //Write Message recipients
    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients,
                                    (PVOID *) &pIMailMsgRecipients);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to query interface for recip interface - 0x%08X", hr);
        goto Exit;
    }

    hr = pIMailMsgRecipients->Count(&cRecips);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to get recipient count - 0x%08X", hr);
        goto Exit;
    }

    //If we don't have any recipients, bail
    if (!cRecips)
        goto Exit;

    //Write the localized text
    wcscpy(wszReasonBuffer, wcszBlankLine);
    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       g_hAQInstance,
                       PHATQ_BADMAIL_RECIPIENTS,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       wszReasonBuffer+(sizeof(wcszBlankLine)-1)/sizeof(WCHAR),
                       (sizeof(wszReasonBuffer)-sizeof(wcszBlankLine))/sizeof(WCHAR),
                       NULL);
    cReasonBuffer = wcslen(wszReasonBuffer);
    if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                   cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL,
            "Error writing to badmail reason file - erro 0x%08X - file %s",
            hr, szDestFileBase);
        goto Exit;
    }


    //Loop over SMTP recips and dump them in the file
    for (iCurrentRecip = 0; iCurrentRecip < cRecips; iCurrentRecip++)
    {
        hr = pIMailMsgRecipients->GetStringA(iCurrentRecip,
                IMMPID_RP_ADDRESS_SMTP, sizeof(szPropBuffer), szPropBuffer);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL,
                "Unable to get SMTP address for recip %d - 0x%08X",
                iCurrentRecip, hr);
            hr = S_OK;
            continue;
        }

        cReasonBuffer = wsprintfW(wszReasonBuffer, L"\t%S%s",
                  szPropBuffer, wcszBlankLine);
        if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                       cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM) NULL,
                "Error writing to badmail reason file - error 0x%08X - file %s",
                hr, szDestFileBase);
            goto Exit;
        }
    }

  Exit:
    if (fShouldRestoreExtension)
    {
        _ASSERT(szBadMailFileNameExt);
        memcpy(szBadMailFileNameExt, szOldExt, sizeof(szOldExt));
    }

    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    if (hBadMailFile != INVALID_HANDLE_VALUE)
        _VERIFY(CloseHandle(hBadMailFile));

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::HandleBadMail ]---------------------------------------------
//
//
//  Description:
//      Handles mail that needs to be placed in the badmail directory (or
//      equivalent).
//  Parameters:
//      IN      pIMailMsgProperties that needs to be badmail'd
//      IN      fUseIMailMsgPropeties -- use IMAilMsgProps if set else use szFilename
//      IN      szFileName  Name of badmail file (if no msg can be supplied)
//      IN      hrReason - HRESULT (defined in aqerr) that describes reason
//                  Eventually, we may log this information to the badmail
//                  file (or recipient)
//      IN      fHasRoutingLock - TRUE if this thread holds routing lock
//  Returns:
//      -
//  History:
//      10/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleBadMail(IN IMailMsgProperties *pIMailMsgProperties,
                               IN BOOL fUseIMailMsgProperties,
                               IN LPSTR szOriginalFileName,
                               IN HRESULT hrReason,
                               IN BOOL fHasRoutingLock)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HandleBadMail");
    HRESULT hr = S_OK;
    LPSTR szFullPathName = NULL;
    LPSTR szFileName = NULL;
    BOOL  fDataLocked = FALSE;
    BOOL  fDone = TRUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PFIO_CONTEXT pFIOContext = NULL;
    FILETIME ftCurrent;
    CRefCountedString *prstrBadMailDir = NULL;

    MSG_TRACK_INFO msgTrackInfo;
    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_BADMAIL;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    InterlockedIncrement((PLONG) &m_cTotalMsgsBadmailed);

    if (!fHasRoutingLock)
    {
        m_slPrivateData.ShareLock();
        fDataLocked = TRUE;
    }
    else
    {
        m_slPrivateData.AssertIsLocked();
    }


    if (m_prstrBadMailDir)
    {
        prstrBadMailDir = m_prstrBadMailDir;
        prstrBadMailDir->AddRef();
    }
    else
    {
        LogAQEvent(AQUEUE_E_NO_BADMAIL_DIR, NULL, pIMailMsgProperties, NULL);
        goto Exit;
    }

    if (fDataLocked)
    {
        m_slPrivateData.ShareUnlock();
        fDataLocked = FALSE;
    }

    szFullPathName = (LPSTR) pvMalloc(sizeof(CHAR) *
                         (UNIQUEUE_FILENAME_BUFFER_SIZE +
                         prstrBadMailDir->cbStrlen()));

    if (!szFullPathName)
    {
        LogAQEvent(AQUEUE_E_BADMAIL, NULL, pIMailMsgProperties, NULL);
        goto Exit;
    }

    memcpy(szFullPathName, prstrBadMailDir->szStr(),
            prstrBadMailDir->cbStrlen());

    if (szFullPathName[prstrBadMailDir->cbStrlen()-1] != '\\')
    {
        _ASSERT(0 && "Malformed badmail config");
        LogAQEvent(AQUEUE_E_NO_BADMAIL_DIR, NULL, pIMailMsgProperties, NULL);
        goto Exit;
    }

    szFileName = szFullPathName + prstrBadMailDir->cbStrlen();

    //If we have a msg use it
    if (pIMailMsgProperties && fUseIMailMsgProperties)
    {
        //Loop while trying to generate a unique file name
        do
        {
            fDone = TRUE;

            GetExpireTime(0, &ftCurrent, NULL);
            GetUniqueFileName(&ftCurrent, szFileName, "BAD");

            //Create file and write MsgContent to it
            hFile = CreateFile( szFullPathName,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_NEW,
                        FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED,
                        NULL);

            if (INVALID_HANDLE_VALUE == hFile)
            {
                if (ERROR_ALREADY_EXISTS == GetLastError())
                {
                    //Try a new file name
                    fDone = FALSE;
                    continue;
                }

                //Other we are hosed... log an event
                LogAQEvent(AQUEUE_E_BADMAIL, NULL, pIMailMsgProperties, NULL);
                goto Exit;
            }

            _ASSERT(hFile);  //should return INVALID_HANDLE_VALUE on failure
        } while (!fDone);

        if (hFile != INVALID_HANDLE_VALUE)
            pFIOContext = AssociateFile(hFile);

        if (!pFIOContext ||
            FAILED(pIMailMsgProperties->CopyContentToFile(pFIOContext, NULL)))
        {
            //Copy failed log event
            LogAQEvent(AQUEUE_E_BADMAIL, NULL, pIMailMsgProperties, NULL);
        }
    }
    else if (szOriginalFileName)
    {
        //Otherwise (no msg)... just do a movefile
        _ASSERT(szFullPathName[prstrBadMailDir->cbStrlen()-1] == '\\');
        szFullPathName[prstrBadMailDir->cbStrlen()-1] = '\0';
        if (!MoveFileEx(szOriginalFileName, szFullPathName,
                MOVEFILE_COPY_ALLOWED))
        {
            //MoveFile failed... try renaming with a unique file name
            szFullPathName[prstrBadMailDir->cbStrlen()-1] = '\\';
            GetExpireTime(0, &ftCurrent, NULL);
            GetUniqueFileName(&ftCurrent, szFileName, "BAD");
            if (rename(szOriginalFileName, szFullPathName))
                LogAQEvent(AQUEUE_E_BADMAIL, NULL, NULL, szOriginalFileName);
        }
    }

    hr = HrCreateBadMailReasonFile(szFullPathName, hrReason, pIMailMsgProperties);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to make badmail reason file - hr 0x%08X", hr);
    }

    hr = HrCreateBadMailPropertyFile(szFullPathName, pIMailMsgProperties);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to make badmail property file - hr 0x%08X", hr);
    }

  Exit:
    if (fDataLocked)
        m_slPrivateData.ShareUnlock();

    if (prstrBadMailDir)
        prstrBadMailDir->Release();

    if (szFullPathName)
        FreePv(szFullPathName);

    if (NULL != pFIOContext)
        ReleaseContext(pFIOContext);

    TraceFunctLeave();
}

//---[ HandleAQFailure ]--------------------------------------------------------
//
//
//  Description:
//      Function to handle AQ failures that would result in loss of data
//      or messages if unhandled.  Meant to be a substitute for
//      _ASSERT(SUCCEEDED(hr)).
//
//      Note: Msgs are still Turfed for M2
//  Parameters:
//      eaqfFailureSituation        Enum that describes the failure situation
//                                  as well as what the context is.
//      hr                          HRSULT that triggered failure condition
//      pIMailMsgProperties         MailMsgProperties
//  Returns:
//      -
//  History:
//      8/25/98 - MikeSwa Created
//      10/8/98 - MikeSwa Moved to CAQSvrInst
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleAQFailure(eAQFailure eaqfFailureSituation,
                                 HRESULT hr,
                                 IMailMsgProperties *pIMailMsgProperties)
{
    _ASSERT(eaqfFailureSituation < AQ_FAILURE_NUM_SITUATIONS);
    InterlockedIncrement((PLONG) &g_cTotalAQFailures);
    InterlockedIncrement((PLONG) &(g_rgcAQFailures[eaqfFailureSituation]));
    BOOL    fCanRetry = fShouldRetryMessage(pIMailMsgProperties);
    MSG_TRACK_INFO msgTrackInfo;

    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_AQ_FAILURE;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    switch(eaqfFailureSituation)
    {
      case(AQ_FAILURE_CANNOT_NDR_UNRESOLVED_RECIPS):
        LogAQEvent(AQUEUE_E_DSN_FAILURE, NULL, pIMailMsgProperties, NULL);
        //drop through to default case
      default:
        //
        //  Throw the message in the last-ditch retry queue if the following are true:
        //      - We had a failure
        //      - We are not shutting down
        //      - We can retry the message (e.g., it has not been deleted)
        //
        if (FAILED(hr) && (AQUEUE_E_SHUTDOWN != hr) && fCanRetry)
        {
            InterlockedIncrement((PLONG) &m_cCurrentResourceFailedMsgsPendingRetry);
            m_fmq.HandleFailedMailMsg(pIMailMsgProperties);
        }
    }
}

//---[ CAQSvrInst::LogAQEvent ]------------------------------------------------
//
//
//  Description:
//      General event logging mechanism for AQ
//  Parameters:
//      hrEventReason       AQUEUE HRESULT describing event
//      pmsgref             CMsgRef of msg for event (can be NULL)
//      pIMailMsgProperties pIMailMsgProperties for event (can be NULL)
//      szFileName          Filename if no msgs provided (can be NULL)
//  Returns:
//      -
//  History:
//      10/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::LogAQEvent(HRESULT hrEventReason, CMsgRef *pmsgref,
                            IMailMsgProperties *pIMailMsgProperties,
                            LPSTR szFileName)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::LogAQEvent");

    switch (hrEventReason)
    {
      //$$TODO - Add actual event callouts here
      case (S_OK): //Added to remove switch compile warnings
      default:
        ErrorTrace((LPARAM) this, "EVENT: Generic AQueue event - 0x%08X", hrEventReason);
    }
    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CAQSvrInst::TriggerPreCategorizeEvent
//
// Synopsis: Fire the pre-cat server event
//
// Arguments:
//  pIMailMsgProperties: the IMailMsgProperties interface of the mailmsg
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/11/24 20:07:58: Created.
//
//-------------------------------------------------------------
VOID CAQSvrInst::TriggerPreCategorizeEvent(
    IN  IMailMsgProperties *pIMailMsgProperties)
{
    HRESULT hr;
    EVENTPARAMS_PRECATEGORIZE Params;

    TraceFunctEnterEx((LPARAM)pIMailMsgProperties,
                      "CAQSvrInst::TriggerPreCategorizeEvent");

    _ASSERT(pIMailMsgProperties);

    Params.pfnCompletion = MailTransport_Completion_PreCategorization;
    Params.pCCatMsgQueue = (PVOID) this;
    Params.pIMailMsgProperties = pIMailMsgProperties;

    //
    // Addref here, release in completion
    //
    pIMailMsgProperties->AddRef();
    AddRef();

    //
    // keep a count of messages in the pre-cat event
    //
    InterlockedIncrement((LPLONG) &m_cCurrentMsgsPendingPreCatEvent);

    if(m_pISMTPServer) {
        hr = TriggerServerEvent(
            SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT,
            &Params);
        DebugTrace((LPARAM)this, "TriggerServerEvent returned hr %08lx", hr);

    }

    if((m_pISMTPServer == NULL) || (FAILED(hr))) {

        ErrorTrace((LPARAM)this,
                   "Unable to dispatch server event; calling completion routine directly");

        DebugTrace((LPARAM)this, "hr is %08lx", hr);
        //
        // Call completion routine directly
        //
        _VERIFY(SUCCEEDED(PreCatEventCompletion(S_OK, &Params)));
    }
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CAQSvrInst::PreCatEventCompletion
//
// Synopsis: Called by SEO upon completipon of the precat event
//
// Arguments:
//  pIMailMsgProperties: the IMailMsgProperties interface of the mailmsg
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/11/24 20:17:44: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::PreCatEventCompletion(
    IN  HRESULT hrStatus,
    IN  PEVENTPARAMS_PRECATEGORIZE pParams)
{
    HRESULT hr;

    _ASSERT(pParams);
    _ASSERT(pParams->pIMailMsgProperties);

    TraceFunctEnterEx((LPARAM)pParams->pIMailMsgProperties,
                      "CAQSvrInst::PreCatEventCompletion");

    DebugTrace((LPARAM)pParams->pIMailMsgProperties, "hrStatus is %08lx", hrStatus);

    //
    // Decrease count of msgs in pre-cat event
    //
    InterlockedDecrement((LPLONG) &m_cCurrentMsgsPendingPreCatEvent);

    //
    // Update the message status and check for abort/badmail
    //
    hr = SetNextMsgStatus(MP_STATUS_SUBMITTED, pParams->pIMailMsgProperties);
    if (hr == S_OK) //anything else implies that the message has been handled
    {
        //Only submit to categorizer if things message was not turfed.

        hr = SubmitMessageToCategorizer(pParams->pIMailMsgProperties);

        if(FAILED(hr))
        {
            _ASSERT((hr == AQUEUE_E_SHUTDOWN) && "SubmitMessageToCategorizer failed.");
            ErrorTrace((LPARAM)pParams->pIMailMsgProperties,
                       "SubmitMessageToCategorizer returned hr %08lx",
                       hr);
        }
    }
    //
    // Release references added in TriggerPreCategorizeEvent
    //
    pParams->pIMailMsgProperties->Release();
    Release();

    TraceFunctLeaveEx((LPARAM)pParams->pIMailMsgProperties);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Completion_PreCategorization
//
// Synopsis: SEO will call this routine after all sinks for
// OnPreCategoriztion have been handeled
//
// Arguments:
//   pvContext: Context passed into TriggerServerEvent
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/11/24 20:26:51: Created
//
//-------------------------------------------------------------
HRESULT MailTransport_Completion_PreCategorization(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnter("MailTransport_Completion_PreCategorization");

    PEVENTPARAMS_PRECATEGORIZE pParams = (PEVENTPARAMS_PRECATEGORIZE) pvContext;
    CAQSvrInst *paqinst = (CAQSvrInst *) pParams->pCCatMsgQueue;

    TraceFunctLeave();
    return paqinst->PreCatEventCompletion(
        hrStatus,
        pParams);
}


//---[ CAQSvrInst::SetCallbackTime ]-------------------------------------------
//
//
//  Description:
//      Set a callback time based on a number of minutes.
//  Parameters:
//      IN  pCallbackFn         Ptr to a callback function
//      IN  pvContext           Context pass to callback function
//      IN  dwCallbackMinutes   Minutes to wait before calling callback
//                              function.
//  Returns:
//
//  History:
//      12/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::SetCallbackTime(IN PSRVFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN DWORD    dwCallbackMinutes)
{
    HRESULT hr = S_OK;
    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    _ASSERT(m_pConnMgr);
    if (m_pConnMgr)
        hr = m_pConnMgr->SetCallbackTime(pCallbackFn, pvContext,
                                         dwCallbackMinutes);

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::SetCallbackTime ]-------------------------------------------
//
//
//  Description:
//      Set a callback time based on a filetime.
//  Parameters:
//
//  Returns:
//
//  History:
//      12/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::SetCallbackTime(IN PSRVFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN FILETIME *pft)
{
    HRESULT hr = S_OK;
    DWORD   dwCallbackMinutes = 0;
    DWORD   dwTimeContext = 0;
    FILETIME ftCurrentTime;
    LARGE_INTEGER *pLargeIntCurrentTime = (LARGE_INTEGER *) &ftCurrentTime;
    LARGE_INTEGER *pLargeIntCallbackTime = (LARGE_INTEGER *) pft;

    _ASSERT(pCallbackFn);
    _ASSERT(pvContext);
    _ASSERT(pft);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    if (!fInPast(pft, &dwTimeContext))
    {
        //Get current time using previous context (so current time is the same)
        GetExpireTime(0, &ftCurrentTime, &dwTimeContext);

        //the current time must be less than the callback time
        _ASSERT(pLargeIntCurrentTime->QuadPart < pLargeIntCallbackTime->QuadPart);

        pLargeIntCurrentTime->QuadPart = pLargeIntCallbackTime->QuadPart -
                                         pLargeIntCurrentTime->QuadPart;

        pLargeIntCurrentTime->QuadPart /= (LONGLONG) 600000000;

        //If the callback time is > 2 billion minutes... I'd
        //like to know about it in debug builds
        _ASSERT(!pLargeIntCurrentTime->HighPart);

        dwCallbackMinutes = pLargeIntCurrentTime->LowPart;

        //The only current application is for deferred delivery... I would like
        //to see the internal test situations that result in a deferred delivery
        _ASSERT(dwCallbackMinutes < (60*24*7));

        //
        //  If we have rounded down to 0 minutes, we should call back in 1
        //  otherwise we can end up in a tight loop.  If the call merely wants
        //  another thread, they should use the AsyncWorkQueue
        //
        if (!dwCallbackMinutes)
            dwCallbackMinutes = 1;
    }
    else
    {
        //If in past... callback as soon as possible, but don't use this thread, in
        //case there are locking complications (CShareLockNH is non-reentrant).
        dwCallbackMinutes = 1;
    }

    _ASSERT(m_pConnMgr);
    if (m_pConnMgr)
        hr = m_pConnMgr->SetCallbackTime(pCallbackFn, pvContext,
                                         dwCallbackMinutes);

    ShutdownUnlock();
  Exit:
    return hr;
}


//---[ CAQSvrInst::SetLinkState ]----------------------------------------------
//
//
//  Description:
//      Implements IMailTransportRouterSetLinkState::SetLinkState
//  Parameters:
//      IN  szLinkDomainName        The Domain Name of the link (next hop)
//      IN  guidRouterGUID          The GUID ID of the router
//      IN  dwScheduleID            The schedule ID link
//      IN  szConnectorName         The connector name given by the router
//      IN  dwFlagsToSet            Link State Flags to set
//      IN  dwFlagsToUnset          Link State Flags to unset
//      IN  pftNextScheduledConnection   Next scheduled connection time.
//  Returns:
//      S_OK on success
//      E_INVALIDARG if szLinkDomainName is NULL
//      AQUEUE_E_SHUTDOWN if shutting down.
//  History:
//      1/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SetLinkState(
        IN LPSTR                   szLinkDomainName,
        IN GUID                    guidRouterGUID,
        IN DWORD                   dwScheduleID,
        IN LPSTR                   szConnectorName,
        IN DWORD                   dwSetLinkState,
        IN DWORD                   dwUnsetLinkState,
        IN FILETIME               *pftNextScheduledConnection,
        IN IMessageRouter         *pMessageRouter)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    DWORD   cbLinkDomainName = 0;
    CDomainEntry *pdentry = NULL;
    CLinkMsgQueue *plmq = NULL;
    CAQScheduleID aqsched(guidRouterGUID, dwScheduleID);
    BOOL fRemoveOwnedSchedule = TRUE;

    if (!szLinkDomainName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    cbLinkDomainName = lstrlen(szLinkDomainName);

    // see if they want to create a new link
    if (dwSetLinkState & LINK_STATE_CREATE_IF_NECESSARY) {
        // creating a link requires a pmessagerouter
        if (pMessageRouter == NULL) {
            hr = E_POINTER;
        } else {
            LinkFlags lf;

            if (dwSetLinkState & LINK_STATE_TYPE_INTERNAL_SMTP) {
                lf = eLinkFlagsInternalSMTPLinkInfo;
            } else {
                _ASSERT(dwSetLinkState & LINK_STATE_TYPE_EXTERNAL_SMTP);
                lf = eLinkFlagsExternalSMTPLinkInfo;
            }

            dwSetLinkState &=
                ~(LINK_STATE_TYPE_INTERNAL_SMTP |
                  LINK_STATE_TYPE_EXTERNAL_SMTP);

            // get the link, and create it if it doesn't exist and they want to
            // have a new link created
            hr = m_dmt.HrGetOrCreateLink(szLinkDomainName,
                                         cbLinkDomainName,
                                         dwScheduleID,
                                         szConnectorName,
                                         pMessageRouter,
                                         TRUE,
                                         lf,
                                         &plmq,
                                         &fRemoveOwnedSchedule);
        }
    } else {
        cbLinkDomainName = lstrlen(szLinkDomainName);

        hr = HrGetDomainEntry(cbLinkDomainName, szLinkDomainName, &pdentry);

        if (SUCCEEDED(hr))
            hr = pdentry->HrGetLinkMsgQueue(&aqsched, &plmq);
    }
    if (FAILED(hr))
        goto Exit;

    // this bit is only used above, so remove it
    dwSetLinkState &= ~LINK_STATE_CREATE_IF_NECESSARY;
    dwUnsetLinkState &= ~LINK_STATE_CREATE_IF_NECESSARY;

    _ASSERT(plmq);

    //
    //  If this operation is dis-allowing scheduled connections... we should
    //  record when the next scheduled attempt will be.  We should also do
    //  this before we modify the link state, so that the queue admin does
    //  not display a scheduled queue without a next connection time.
    //
    if (pftNextScheduledConnection &&
        (pftNextScheduledConnection->dwLowDateTime ||
         pftNextScheduledConnection->dwHighDateTime))
    {
        plmq->SetNextScheduledConnection(pftNextScheduledConnection);
    }

    //filter out the reserved bits for this "public" API
    plmq->dwModifyLinkState(~LINK_STATE_RESERVED & dwSetLinkState,
                            ~LINK_STATE_RESERVED & dwUnsetLinkState);

    // schedule a callback if one was requested
    if (pftNextScheduledConnection->dwLowDateTime != 0 ||
        pftNextScheduledConnection->dwHighDateTime != 0)
    {
        //callback with next attempt
        plmq->AddRef(); //Addref self as context
        hr = SetCallbackTime(
                CLinkMsgQueue::ScheduledCallback,
                plmq,
                pftNextScheduledConnection);
        if (FAILED(hr))
            plmq->Release(); //callback will not happen... release context
    }

  Exit:
    if (fLocked)
        ShutdownUnlock();

    if (pdentry)
        pdentry->Release();

    if (plmq)
        plmq->Release();

    //
    //  If we have not passed ownership of the shedule ID to a link,
    //  then we are responsible for releasing it.
    //
    if (fRemoveOwnedSchedule) {

        IMessageRouterLinkStateNotification *pILinkStateNotify = NULL;

        HRESULT hrLinkStateNotify =
            pMessageRouter->QueryInterface(IID_IMessageRouterLinkStateNotification,
                (VOID **) &pILinkStateNotify);

        _ASSERT( SUCCEEDED( hrLinkStateNotify));

        FILETIME ftNotUsed = {0,0};
        DWORD    dwSetNotUsed = LINK_STATE_NO_ACTION;
        DWORD    dwUnsetNotUsed = LINK_STATE_NO_ACTION;

        hrLinkStateNotify =
            pILinkStateNotify->LinkStateNotify(
                szLinkDomainName,
                guidRouterGUID,
                dwScheduleID,
                szConnectorName,
                LINK_STATE_LINK_NO_LONGER_USED,
                0, //consecutive failures
                &ftNotUsed,
                &dwSetNotUsed,
                &dwUnsetNotUsed);

        _ASSERT( SUCCEEDED( hrLinkStateNotify));

        if ( NULL != pILinkStateNotify) {
            pILinkStateNotify->Release();
        }
    }

    return hr;
}


//---[ CAQSvrInst::prstrGetDefaultDomain ]-------------------------------------
//
//
//  Description:
//      Returns the ref-counted string for the default domain
//  Parameters:
//      -
//  Returns:
//      See above
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CRefCountedString *CAQSvrInst::prstrGetDefaultDomain()
{
    CRefCountedString *prstrDefaultDomain = NULL;
    m_slPrivateData.ShareLock();
    if (m_prstrDefaultDomain)
        m_prstrDefaultDomain->AddRef();

    prstrDefaultDomain = m_prstrDefaultDomain;
    m_slPrivateData.ShareUnlock();
    return prstrDefaultDomain;
}

//+------------------------------------------------------------
//
// Function: ScheduleInternalRetry
//
// Synopsis: Schedule categorizer retry if necessary
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 2000/06/08 17:31:30: Created.
//      1/16/2001 - MikeSwa Modified to handle all internal retries
//
//-------------------------------------------------------------
VOID CAQSvrInst::ScheduleInternalRetry(DWORD dwLinkType)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::ScheduleInternalRetry");
    DWORD   *pcRetriesPending = NULL;
    PSRVFN   pCallbackFn = NULL;
    DWORD    cCallbackMinutes = 0;
    FILETIME ftCallback = {0,0};
    BOOL    fHasLock = FALSE;
    CQueueAdminRetryNotify *pqapiret = NULL;

    //
    //  First try to get the shutdown lock before accessing
    //  anything that may go away during deinitialization (like m_pConnMgr)
    //
    if (!fTryShutdownLock())
        goto Exit;

    fHasLock = TRUE;

    switch (dwLinkType) {
      case LI_TYPE_PENDING_ROUTING:
        pcRetriesPending = &m_cRoutingRetriesPending;
        pCallbackFn = RoutingRetry;
        cCallbackMinutes = g_cRoutingRetryMinutes;
        pqapiret = (CQueueAdminRetryNotify *) m_dmt.pmmaqGetPreRouting();
        break;
      case LI_TYPE_LOCAL_DELIVERY:
        pcRetriesPending = &m_cLocalRetriesPending;
        pCallbackFn = LocalDeliveryRetry;
        cCallbackMinutes = g_cLocalRetryMinutes;
        pqapiret = (CQueueAdminRetryNotify *) m_dmt.plmqGetLocalLink();
        break;
      case LI_TYPE_PENDING_CAT:
        pcRetriesPending = &m_cCatRetriesPending;
        pCallbackFn = CatRetry;
        cCallbackMinutes = g_cCatRetryMinutes;
        pqapiret = (CQueueAdminRetryNotify *) m_dmt.pmmaqGetPreCategorized();
        break;
      case LI_TYPE_PENDING_SUBMIT:
        pcRetriesPending = &m_cSubmitRetriesPending;
        pCallbackFn = SubmitRetry;
        cCallbackMinutes = g_cSubmissionRetryMinutes;
        pqapiret = (CQueueAdminRetryNotify *) m_dmt.pmmaqGetPreSubmission();
        break;
      default:
        //
        //  Someone has called with a bogus callback
        //
        _ASSERT(0 && "Unspecified callback for internal retry");
        ErrorTrace((LPARAM) this,
            "Unspecified callback for internal retry 0x%08X", dwLinkType);
        goto Exit;
    }

    _ASSERT(pcRetriesPending);

    if (pcRetriesPending && !*pcRetriesPending)
    {
        _ASSERT(pCallbackFn);
        _ASSERT(cCallbackMinutes);

        //
        //  Say that we are requesting a callback
        //
        InterlockedIncrement((PLONG) pcRetriesPending);

        m_pConnMgr->SetCallbackTime(pCallbackFn, this, cCallbackMinutes);

        //
        //  Get the expire time... so we can update our retry time
        //
        m_qtTime.GetExpireTime(cCallbackMinutes, &ftCallback, NULL);


        //
        //  Update retry time
        //
        if (pqapiret)
            pqapiret->SetNextRetry(&ftCallback);
    }

  Exit:

    if (pqapiret)
        pqapiret->Release();

    if (fHasLock)
        ShutdownUnlock();

    TraceFunctLeave();
} // CAQSvrInst::ScheduleInternalRetry


//+------------------------------------------------------------
//
// Function: CAQSvrInst::HrAllocBoundMessage
//
// Synopsis:
//  Allocates a bound message
//
// Arguments:
//  ppMsg: Out param for Allocated mailmsg
//  phContent: Out param for content handle.  Handle is managed by mailmsg
//
// Returns:
//  S_OK: Success
//  E_FAIL: No ISMTPServer is available
//  error from SMTP
//
// History:
// jstamerj 2001/05/11 15:39:16: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::HrAllocBoundMessage(
    OUT IMailMsgProperties **ppMsg,
    OUT PFIO_CONTEXT *phContent)
{
    HRESULT hr = S_OK;
    ISMTPServerInternal *pISMTPInternal = NULL;
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::HrAllocBoundMessage");

    if(m_pISMTPServer == NULL)
    {
        hr = E_FAIL;
        goto CLEANUP;
    }
    hr = m_pISMTPServer->QueryInterface(
        IID_ISMTPServerInternal,
        (LPVOID *) &pISMTPInternal);
    if(FAILED(hr))
        goto CLEANUP;

    hr = pISMTPInternal->AllocBoundMessage(
        ppMsg,
        phContent);

 CLEANUP:
    if(pISMTPInternal)
        pISMTPInternal->Release();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CAQSvrInst::HrAllocBoundMessage


//+------------------------------------------------------------
//
// Function: CAQSvrInst::HrSubmitDSN
//
// Synopsis: Acceps a message submitted by a DSN sink
//
// Arguments:
//  pIMsgOrig: Original message (for which a DSN is being generated)
//  dwDSNAction: Indicates the type of DSN
//  cRecipsDSNd: Number of recipients in the DSN.
//  pDSNMsg: The DSN mailmsg object
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/12/08 13:42:17: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::HrSubmitDSN(
    CDSNParams *pdsnparams,
    DWORD dwDSNAction,
    DWORD cRecipsDSNd,
    IMailMsgProperties *pDSNMsg)
{
    HRESULT hr = S_OK;
    DWORD cCurrent = 0;

    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::HrSubmitDSN");

    DebugTrace((LPARAM)this, "dwDSNAction: %08lx", dwDSNAction);
    DebugTrace((LPARAM)this, "cRecipsDSNd: %ld", cRecipsDSNd);

    if(pDSNMsg == NULL)
    {
        hr = E_INVALIDARG;
        goto CLEANUP;
    }
    if ((DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL) & dwDSNAction)
    {
        MSG_TRACK_INFO msgTrackInfo;

        cCurrent = InterlockedIncrement((PLONG) &m_cNDRs);
        DebugTrace((LPARAM) this, "INFO: NDR Generated - total %d", cCurrent);

        ZeroMemory(&msgTrackInfo, sizeof(MSG_TRACK_INFO));
        msgTrackInfo.dwEventId = MTE_NDR_ALL;
        msgTrackInfo.pszPartnerName = "aqueue";
        msgTrackInfo.dwRcptReportStatus = MP_STATUS_ABORT_DELIVERY;
        m_pISMTPServer->WriteLog(&msgTrackInfo,
                                 pdsnparams->pIMailMsgProperties,
                                 NULL,
                                 NULL);
    }
    if (DSN_ACTION_DELAYED & dwDSNAction)
    {
        cCurrent = InterlockedIncrement((PLONG) &m_cDelayedDSNs);
        DebugTrace((LPARAM) this, "INFO: Delayed DSN Generated - total %d", cCurrent);
    }
    if (DSN_ACTION_RELAYED & dwDSNAction)
    {
        cCurrent = InterlockedIncrement((PLONG) &m_cRelayedDSNs);
        DebugTrace((LPARAM) this, "INFO: Relayed DSN Generated - total %d", cCurrent);
    }
    if (DSN_ACTION_DELIVERED & dwDSNAction)
    {
        cCurrent = InterlockedIncrement((PLONG) &m_cDeliveredDSNs);
        DebugTrace((LPARAM) this, "INFO: Delivery DSN Generated - total %d", cCurrent);
    }
    if (DSN_ACTION_EXPANDED & dwDSNAction)
    {
        cCurrent = InterlockedIncrement((PLONG) &m_cExpandedDSNs);
        DebugTrace((LPARAM) this, "INFO: Expanded DSN Generated - total %d", cCurrent);
    }

    //Queue request to post DSN generation queue
    hr = m_asyncqPostDSNQueue.HrQueueRequest(
        pDSNMsg,
        FALSE,
        cCountMsgsForHandleThrottling(pDSNMsg));

    if (SUCCEEDED(hr))
        hr = S_OK;

    pdsnparams->dwDSNTypesGenerated |= dwDSNAction;
    pdsnparams->cRecips += cRecipsDSNd;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CAQSvrInst::HrSubmitDSN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqprecmp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqprecmp.h
//
//  Description:  Precompiled header for aqueue\advqueue
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/15/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQPRECMP_H__
#define __AQPRECMP_H__

//Includes from external directories
#include <aqincs.h>
#include <rwnew.h>
#include <aqueue.h>
#include <mailmsgprops.h>
#include <address.hxx>
#include <mailmsg.h>
#include <mailmsgi.h>
#include <baseobj.h>
#include <tran_evntlog.h>
#include <listmacr.h>
#include <smtpevent.h>
#include <aqmem.h>
#include <aqadmtyp.h>
#include <aqadmin.h>
#include <blockmgr.h>

#ifdef PLATINUM
#include <phatqmsg.h>
#include <ptntdefs.h>
#include <ptntintf.h>
#include <linkstate.h>
#include <exdrv.h>
#include <ptrwinst.h>
#include <exaqadm.h>
#define  AQ_MODULE_NAME "phatq"
#else  //NOT PLATINUM
#include <aqmsg.h>
#include <rwinst.h>
#define  AQ_MODULE_NAME "aqueue"
#endif //PLATINUM


//Internal AdvQueue headers
#include "cmt.h"
#include "aqintrnl.h"
#include "aqinst.h"
#include "connmgr.h"
#include "aqadmsvr.h"
#include "linkmsgq.h"
#include "destmsgq.h"
#include "domain.h"
#include "msgref.h"
#include "dcontext.h"
#include "connmgr.h"
#include "aqnotify.h"
#include "smproute.h"
#include "qwiktime.h"
#include "shutdown.h"
#include "refstr.h"
#include "msgguid.h"
#include "aqdbgcnt.h"
#include "aqnotify.h"
#include "defdlvrq.h"
#include "failmsgq.h"
#include "asncwrkq.h"
#include "aqevents.h"

#endif //__AQPRECMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqroute.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqroute.h
//
//  Description:  AQ Routing helper classes.  Defines AQ concepts of message
//      type (CAQMessageType) and ScheduleID (CAQScheduleID).
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      5/21/98 - MikeSwa Created 
//      6/9/98 - MikeSwa Modified constructors
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQROUTE_H__
#define __AQROUTE_H__
#include <smproute.h>

//---[ CAQMessageType ]--------------------------------------------------------
//
//
//  Description: 
//      Encapsulates message type returned by IMessageRouter as well as the 
//      GUID id of the message router itself
//  Hungarian: 
//      aqmt, paqmt
//  
//-----------------------------------------------------------------------------
class CAQMessageType
{
public:
    inline CAQMessageType(GUID guidRouter, DWORD dwMessageType);
    inline CAQMessageType(CAQMessageType *paqmt);
    inline BOOL    fIsEqual(CAQMessageType *paqmt);
    inline BOOL    fSameMessageRouter(CAQMessageType *paqmt);
    DWORD  dwGetMessageType() {return m_dwMessageType;};
    inline void    GetGUID(IN OUT GUID *pguid);

    //Used to update message type when changed befored msg is queued
    void   SetMessageType(DWORD dwMessageType) {m_dwMessageType = dwMessageType;};
protected:
    GUID    m_guidRouter;
    DWORD   m_dwMessageType;
};

//---[ CAQScheduleID ]---------------------------------------------------------
//
//
//  Description: 
//      Encapsulates schedule id returned by IMessageRouter as well as the
//      GUID id of the message router itseld
//  Hungarian: 
//      aqsched, paqsched
//  
//-----------------------------------------------------------------------------
class CAQScheduleID
{
public:
    inline CAQScheduleID();
    inline CAQScheduleID(IMessageRouter *pIMessageRouter, DWORD dwScheduleID);
    inline CAQScheduleID(GUID guidRouter, DWORD dwScheduleID);
    inline void Init(IMessageRouter *pIMessageRouter, DWORD dwScheduleID);
    inline BOOL    fIsEqual(CAQScheduleID *paqsched);
    inline BOOL    fSameMessageRouter(CAQScheduleID *paqsched);
    inline DWORD   dwGetScheduleID() {return m_dwScheduleID;};
    inline void    GetGUID(IN OUT GUID *pguid);
protected:
    GUID    m_guidRouter;
    DWORD   m_dwScheduleID;
};

//---[ CAQMessageType::CAQMessageType ]----------------------------------------
//
//
//  Description: 
//      Constructor for CAQMessageType
//  Parameters:
//      guidRouter  - GUID returned by IMessageRouter::GetTransportSinkID
//      dwMessageType - Message type returned by IMessageRouter::GetMessageType
//  Returns:
//      -
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMessageType::CAQMessageType(GUID guidRouter, DWORD dwMessageType)
{
    m_guidRouter = guidRouter;
    m_dwMessageType = dwMessageType;
}

//---[ CAQMessageType::CAQMessageType ]----------------------------------------
//
//
//  Description: 
//      Contructor for CAQMessageType that clones another CAQMessageType
//  Parameters:
//      paqmt   CAQMessageType to clone
//  Returns:
//      -
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMessageType::CAQMessageType(CAQMessageType *paqmt)
{
    m_guidRouter = paqmt->m_guidRouter;
    m_dwMessageType = paqmt->m_dwMessageType;
}

//---[ CAQMessageType::fIsEqual ]----------------------------------------------
//
//
//  Description: 
//      Determines if 2 given CAQMessageType's refer to the same router and
//      message type pair
//  Parameters:
//      paqmt   - Other CAQMessageType to compare against
//  Returns:
//      TRUE if the refer to the same message type and router
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQMessageType::fIsEqual(CAQMessageType *paqmt)
{
    return ((paqmt->m_dwMessageType == m_dwMessageType) &&
            (paqmt->m_guidRouter == m_guidRouter));
};

//---[ CAQMessageType::fSameMessageRouter ]------------------------------------
//
//
//  Description: 
//      Determines if 2 given CAQMessageType's refer to the same router ID
//  Parameters:
//      paqmt   - Other CAQMessageType to compare against
//  Returns:
//      TRUE if the refer to the same router ID
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQMessageType::fSameMessageRouter(CAQMessageType *paqmt)
{
    return(paqmt->m_guidRouter == m_guidRouter);
};

//---[ CAQMessageType::GetGUID ]------------------------------------------------
//
//
//  Description: 
//      Gets the GUID associated with this message type
//  Parameters:
//      pguid   GUID to copy value into
//  Returns:
//      -
//  History:
//      12/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMessageType::GetGUID(IN OUT GUID *pguid)
{
    _ASSERT(pguid);
    memcpy(pguid, &m_guidRouter, sizeof(GUID));
}

//---[ CAQScheduleID::CAQScheduleID ]------------------------------------------
//
//
//  Description: 
//      CAQScheduleID constructor & initialization function
//  Parameters:
//      pIMessageRouter  - Message Router for this link
//      dwScheduleID - ScheduleID returned by IMessageRouter::GetNextHop
//  Returns:
//      -
//  History:
//      5/21/98 - MikeSwa Created 
//      6/9/98 - MikeSwa Modified to take pIMessageRouter
//
//-----------------------------------------------------------------------------
CAQScheduleID::CAQScheduleID(IMessageRouter *pIMessageRouter, DWORD dwScheduleID)
{
    Init(pIMessageRouter, dwScheduleID);
}

//---[ CAQScheduleID::CAQScheduleID ]-------------------------------------------
//
//
//  Description: 
//      Default constructor for CAQScheduleID... should be used with 
//  Parameters:
//
//  Returns:
//
//  History:
//      6/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQScheduleID::CAQScheduleID()
{
    ZeroMemory(&m_guidRouter, sizeof(GUID));
    m_dwScheduleID = 0xDEAFBEEF;
}

//---[ CAQScheduleID::CAQScheduleID ]------------------------------------------
//
//
//  Description: 
//      Yet another flavor of CAQScheduleID constructor
//  Parameters:
//      guidRouter      GUID of router for schedule ID
//      dwScheduleID    Schedule ID returned by router
//  Returns:
//      -
//  History:
//      9/22/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQScheduleID::CAQScheduleID(GUID guidRouter, DWORD dwScheduleID)
{
    m_guidRouter = guidRouter;
    m_dwScheduleID = dwScheduleID;
}

//---[ CAQScheduleID::Init ]---------------------------------------------------
//
//
//  Description: 
//      Initalization of CAQScheduleID object... used to allow allocation of 
//      object on stack before dwScheduleID is known
//  Parameters:
//      pIMessageRouter  - Message Router for this link
//      dwScheduleID - ScheduleID returned by IMessageRouter::GetNextHop
//  Returns:
//      -
//  History:
//      6/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQScheduleID::Init(IMessageRouter *pIMessageRouter, DWORD dwScheduleID)
{
    m_guidRouter = pIMessageRouter->GetTransportSinkID();
    m_dwScheduleID = dwScheduleID;
}

//---[ CAQScheduleID::fIsEqual ]----------------------------------------------
//
//
//  Description: 
//      Determines if 2 given CAQScheduleID's refer to the same router and
//      Schedule ID pair
//  Parameters:
//      paqsched   - Other CAQScheduleID to compare against
//  Returns:
//      TRUE if the refer to the same schedule ID and router
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQScheduleID::fIsEqual(CAQScheduleID *paqsched)
{
    return ((paqsched->m_dwScheduleID == m_dwScheduleID) &&
            (paqsched->m_guidRouter == m_guidRouter));
};

//---[ CAQScheduleID::fSameMessageRouter ]-------------------------------------
//
//
//  Description: 
//      Determines if 2 given CAQScheduleID's refer to the same router ID
//  Parameters:
//      paqsched   - Other CAQScheduleID to compare against
//  Returns:
//      TRUE if the refer to the same router ID
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQScheduleID::fSameMessageRouter(CAQScheduleID *paqsched)
{
    return (paqsched->m_guidRouter == m_guidRouter);
};

//---[ CAQScheduleID::GetGUID ]------------------------------------------------
//
//
//  Description: 
//      Gets the GUID associated with this schedule ID
//  Parameters:
//      pguid   GUID to copy value into
//  Returns:
//      -
//  History:
//      9/25/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQScheduleID::GetGUID(IN OUT GUID *pguid)
{
    _ASSERT(pguid);
    memcpy(pguid, &m_guidRouter, sizeof(GUID));
}
#endif //__AQROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqrpcsvr.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqrpcsvr.h
//
//  Description:  Header file for AQueue server-side RPC implementations.
//      Contains per-instance initialization functions.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQRPCSVR_H__
#define __AQRPCSVR_H__

#include <aqincs.h>
#include <rwnew.h>
#include <baseobj.h>
#include <shutdown.h>
#include <mailmsg.h>

class CAQSvrInst;


#define CAQRpcSvrInst_Sig       'cpRQ'
#define CAQRpcSvrInst_SigFree   'cpR!'

//---[ CAQRpcSvrInst ]---------------------------------------------------------
//
//
//  Description: 
//      Per-instance RPC class.  Handles RPC details and shutdown timing
//  Hungarian: 
//      aqrpc, paqrpc
//  
//-----------------------------------------------------------------------------
class CAQRpcSvrInst : 
    public CBaseObject,
    public CSyncShutdown
{
  private:
    static  CShareLockNH        s_slPrivateData;
    static  LIST_ENTRY          s_liInstancesHead;
    static  RPC_BINDING_VECTOR *s_pRpcBindingVector;
    static  BOOL                s_fEndpointsRegistered;
  protected:
    DWORD                   m_dwSignature;
    LIST_ENTRY              m_liInstances;
    CAQSvrInst             *m_paqinst;
    DWORD                   m_dwVirtualServerID;
    ISMTPServer            *m_pISMTPServer;
  public:
    CAQRpcSvrInst(CAQSvrInst *paqinst, DWORD dwVirtualServerID,
                  ISMTPServer *pISMTPServer);
    ~CAQRpcSvrInst();

    CAQSvrInst *paqinstGetAQ() {return m_paqinst;}; 
    static CAQRpcSvrInst *paqrpcGetRpcSvrInstance(DWORD dwVirtualServerID);

    BOOL   fAccessCheck(BOOL fReadOnly);


  public: //static functions
    static HRESULT HrInitializeAQRpc();
    static HRESULT HrDeinitializeAQRpc();

    static HRESULT HrInitializeAQServerInstanceRPC(CAQSvrInst *paqinst, 
                                            DWORD dwVirtualServerID,
                                            ISMTPServer *pISMTPServer);
    static HRESULT HrDeinitializeAQServerInstanceRPC(CAQSvrInst *paqinst, 
                                              DWORD dwVirtualServerID);

};

#endif //__AQRPCSVR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqrpcsvr.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqrpcsvr.cpp
//
//  Description:  Implementation of AQ RPC server
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqrpcsvr.h"
#include "aqadmrpc.h"
#include <inetcom.h>
#include <iiscnfg.h>

LIST_ENTRY          CAQRpcSvrInst::s_liInstancesHead;
CShareLockNH        CAQRpcSvrInst::s_slPrivateData;
RPC_BINDING_VECTOR *CAQRpcSvrInst::s_pRpcBindingVector = NULL;
BOOL                CAQRpcSvrInst::s_fEndpointsRegistered = FALSE;

//
// Quick and dirty string validation
//
static inline BOOL pValidateStringPtr(LPWSTR lpwszString, DWORD dwMaxLength)
{
    if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
        return(FALSE);
    while (dwMaxLength--)
        if (*lpwszString++ == 0)
            return(TRUE);
    return(FALSE);
}

//---[ HrInitializeAQRpc ]-----------------------------------------------------
//
//
//  Description:
//      Initializes AQ RPC.  This should only be called once per service
//      startup (not VS).  Caller in responable for ensuring that this and
//      HrInitializeAQRpc are called in a thread safe manner.
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      Error code from RPC
//  History:
//      6/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQRpcSvrInst::HrInitializeAQRpc()
{
    TraceFunctEnterEx((LPARAM) NULL, "CAQRpcSvrInst::HrInitializeAQRpc");
    HRESULT     hr = S_OK;
    RPC_STATUS  status = RPC_S_OK;

    InitializeListHead(&s_liInstancesHead);
    s_pRpcBindingVector = NULL;
    s_fEndpointsRegistered = FALSE;

    //Listen on the appropriate protocols sequences
    status = RpcServerUseAllProtseqs(RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                      NULL);

    if (status != RPC_S_OK)
        goto Exit;

    //Advertise the appropriate interface
    status = RpcServerRegisterIfEx(IAQAdminRPC_v1_0_s_ifspec, NULL, NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL);

    if (status != RPC_S_OK)
        goto Exit;

    //Get the dynamic endpoints
    status = RpcServerInqBindings(&s_pRpcBindingVector);
    if (status != RPC_S_OK)
        goto Exit;

    //Register the endpoints
    status = RpcEpRegister(IAQAdminRPC_v1_0_s_ifspec, s_pRpcBindingVector,
                           NULL, NULL);
    if (status != RPC_S_OK)
        goto Exit;

    s_fEndpointsRegistered = TRUE;

  Exit:
    if (status != RPC_S_OK)
        hr = HRESULT_FROM_WIN32(status);

    TraceFunctLeave();
    return hr;
}

//---[ HrDeinitializeAQRpc ]----------------------------------------------------
//
//
//  Description:
//      Do global RPC cleanup
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      Error code from RPC otherwise
//  History:
//      6/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQRpcSvrInst::HrDeinitializeAQRpc()
{
    TraceFunctEnterEx((LPARAM) NULL, "CAQRpcSvrInst::HrDeinitializeAQRpc");
    HRESULT     hr = S_OK;
    RPC_STATUS  status = RPC_S_OK;

    if (s_fEndpointsRegistered) {
        status = RpcEpUnregister(IAQAdminRPC_v1_0_s_ifspec, s_pRpcBindingVector, NULL);
        if (status != RPC_S_OK) hr = HRESULT_FROM_WIN32(status);
    }

    if (s_pRpcBindingVector) {
        status = RpcBindingVectorFree(&s_pRpcBindingVector);
        if (status != RPC_S_OK) hr = HRESULT_FROM_WIN32(status);
    }

    status = RpcServerUnregisterIf(IAQAdminRPC_v1_0_s_ifspec, NULL, 0);

    if (status != RPC_S_OK) hr = HRESULT_FROM_WIN32(status);

    s_fEndpointsRegistered = FALSE;
    s_pRpcBindingVector = NULL;
    TraceFunctLeave();
    return hr;
}

//---[ HrInitializeAQServerInstanceRPC ]---------------------------------------
//
//
//  Description:
//      Add instance to RPC interface
//  Parameters:
//      IN  paqinst             Instnace to add to interface
//      IN  dwVirtualServerID   Virtual server ID of instance
//  Returns:
//      S_OK on success
//  History:
//      6/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQRpcSvrInst::HrInitializeAQServerInstanceRPC(CAQSvrInst *paqinst,
                                        DWORD dwVirtualServerID,
                                        ISMTPServer *pISMTPServer)
{
    TraceFunctEnterEx((LPARAM) paqinst,
        "CAQRpcSvrInst::HrInitializeAQServerInstanceRPC");
    HRESULT hr = S_OK;
    CAQRpcSvrInst *paqrpc = NULL;

    paqrpc = CAQRpcSvrInst::paqrpcGetRpcSvrInstance(dwVirtualServerID);
    if (paqrpc)
    {
        _ASSERT(0 && "Instance already added to RPC interface");
        paqrpc->Release();
        paqrpc = NULL;
        goto Exit;
    }

    paqrpc = new CAQRpcSvrInst(paqinst, dwVirtualServerID, pISMTPServer);
    if (!paqrpc)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ HrDeinitializeAQServerInstanceRPC ]-------------------------------------
//
//
//  Description:
//      Remove instance from RPC interface
//  Parameters:
//      IN  paqinst             Instnace to remove from interface
//      IN  dwVirtualServerID   Virtual server ID of instance
//  Returns:
//      S_OK on success
//  History:
//      6/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQRpcSvrInst::HrDeinitializeAQServerInstanceRPC(CAQSvrInst *paqinst,
                                          DWORD dwVirtualServerID)
{
    TraceFunctEnterEx((LPARAM) paqinst,
        "CAQRpcSvrInst::HrDeinitializeAQServerInstanceRPC");
    HRESULT hr = S_OK;
    CAQRpcSvrInst *paqrpc = NULL;

    paqrpc = CAQRpcSvrInst::paqrpcGetRpcSvrInstance(dwVirtualServerID);
    if (!paqrpc)
        goto Exit; //allow calls if HrInitializeAQServerInstanceRPC failed

    //Found it
    //$$TODO - verify the paqinst is correct

    paqrpc->SignalShutdown();

    //Remove from list of entries
    s_slPrivateData.ExclusiveLock();
    RemoveEntryList(&(paqrpc->m_liInstances));
    s_slPrivateData.ExclusiveUnlock();
    paqrpc->Release(); //release reference associated with list

  Exit:
    if (paqrpc)
        paqrpc->Release();



    TraceFunctLeave();
    return hr;
}


//---[ CAQRpcSvrInst::CAQRpcSvrInst ]------------------------------------------
//
//
//  Description:
//      Constructor for CAQRpcSvrInst class
//  Parameters:
//      IN  paqinst             Instnace to remove from interface
//      IN  dwVirtualServerID   Virtual server ID of instance
//  Returns:
//      -
//  History:
//      6/6/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQRpcSvrInst::CAQRpcSvrInst(CAQSvrInst *paqinst, DWORD dwVirtualServerID,
                             ISMTPServer *pISMTPServer)
{
    _ASSERT(paqinst);
    _ASSERT(pISMTPServer);

    m_paqinst = paqinst;
    m_dwVirtualServerID = dwVirtualServerID;
    m_pISMTPServer = pISMTPServer;
    m_dwSignature = CAQRpcSvrInst_Sig;

    if (m_paqinst)
        m_paqinst->AddRef();

    if (m_pISMTPServer)
        m_pISMTPServer->AddRef();

    //Add to list of virtual server instaces
    s_slPrivateData.ExclusiveLock();
    InsertHeadList(&s_liInstancesHead, &m_liInstances);
    s_slPrivateData.ExclusiveUnlock();
}

//---[ CAQRpcSvrInst::~CAQRpcSvrInst ]-----------------------------------------
//
//
//  Description:
//      Desctructor for CAQRpcSvrInst
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/6/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQRpcSvrInst::~CAQRpcSvrInst()
{

    if (m_paqinst)
        m_paqinst->Release();

    if (m_pISMTPServer)
        m_pISMTPServer->Release();

    m_dwSignature = CAQRpcSvrInst_SigFree;

}


//---[ CAQRpcSvrInst::paqrpcGetRpcSvrInstance ]--------------------------------
//
//
//  Description:
//      Gets the CAQRpcSvrInst for a given virtual server ID
//  Parameters:
//      IN  dwVirtualServerID   Virtual server ID of instance
//  Returns:
//      Pointer to appropriate CAQRpcSvrInst on success
//      NULL if not found
//  History:
//      6/6/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQRpcSvrInst *CAQRpcSvrInst::paqrpcGetRpcSvrInstance(DWORD dwVirtualServerID)
{
    LIST_ENTRY  *pli = NULL;
    CAQRpcSvrInst *paqrpc = NULL;

    s_slPrivateData.ShareLock();
    pli = s_liInstancesHead.Flink;

    while (pli && (pli != &s_liInstancesHead))
    {
        paqrpc = CONTAINING_RECORD(pli, CAQRpcSvrInst, m_liInstances);
        //$$TODO check signature
        if (paqrpc->m_dwVirtualServerID == dwVirtualServerID)
        {
            paqrpc->AddRef();
            break; //found it
        }

        paqrpc = NULL;
        pli = pli->Flink;
    }
    s_slPrivateData.ShareUnlock();

    return paqrpc;
}


//---[ CAQRpcSvrInst::fAccessCheck ]-------------------------------------------
//
//
//  Description:
//      Performs acess check for RPC interfaces
//  Parameters:
//      IN      fWriteAccessRequired    TRUE if write access is required
//  Returns:
//      TRUE if access check is succeeds
//      FALSE if user does not have access
//  History:
//      6/7/99 - MikeSwa Created (from SMTP AQAdmin access code)
//
//-----------------------------------------------------------------------------
BOOL CAQRpcSvrInst::fAccessCheck(BOOL fWriteAccessRequired)
{
    TraceFunctEnterEx((LPARAM) this, "CAQRpcSvrInst::fAccessCheck");
    SECURITY_DESCRIPTOR    *pSecurityDescriptor = NULL;
    DWORD                   cbSecurityDescriptor = 0;
    HRESULT                 hr = S_OK;
    DWORD                   err = ERROR_SUCCESS;
    BOOL                    fAccessAllowed = FALSE;
    HANDLE                  hAccessToken = NULL;
    BYTE                    PrivSet[200];
    DWORD                   cbPrivSet = sizeof(PrivSet);
    ACCESS_MASK             maskAccessGranted;
    GENERIC_MAPPING         gmGenericMapping = {
                                MD_ACR_READ,
                                MD_ACR_WRITE,
                                MD_ACR_READ,
                                MD_ACR_READ | MD_ACR_WRITE
                            };

    if (!m_pISMTPServer)
        goto Exit;  //if we cannot check it... assume if fails

    hr = m_pISMTPServer->ReadMetabaseData(MD_ADMIN_ACL, NULL,
                                         &cbSecurityDescriptor);
    if (SUCCEEDED(hr))
    {
        //We passed in NULL.. should have failed
        _ASSERT(0 && "Invalid response for ReadMetabaseData");
        goto Exit;
    }
    if ((HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr) ||
        !cbSecurityDescriptor)
    {
        //Can't get ACL... bail
        goto Exit;
    }

    pSecurityDescriptor = (SECURITY_DESCRIPTOR *) pvMalloc(cbSecurityDescriptor);
    if (!pSecurityDescriptor)
        goto Exit;

    hr = m_pISMTPServer->ReadMetabaseData(MD_ADMIN_ACL, (BYTE *) pSecurityDescriptor,
                                         &cbSecurityDescriptor);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Error calling ReadMetabaseData for AccessCheck - hr 0x%08X", hr);
        goto Exit;
    }

    // Verify that we got a proper SD.  if not then fail
    if (!IsValidSecurityDescriptor(pSecurityDescriptor))
    {
        ErrorTrace(0, "IsValidSecurityDescriptor failed with %lu", GetLastError());
        goto Exit;
    }

    err = RpcImpersonateClient(NULL);
    if (err != ERROR_SUCCESS)
    {
        ErrorTrace((LPARAM) this, "RpcImpersonateClient failed with %lu", err);
        goto Exit;
    }

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hAccessToken))
    {
        ErrorTrace((LPARAM) this,
            "OpenThreadToken Failed with %lu", GetLastError());
        goto Exit;
    }

    //Check access
    if (!AccessCheck(pSecurityDescriptor,
                     hAccessToken,
                     fWriteAccessRequired ? MD_ACR_WRITE : MD_ACR_READ,
                     &gmGenericMapping,
                     (PRIVILEGE_SET *)PrivSet,
                     &cbPrivSet,
                     &maskAccessGranted,
                     &fAccessAllowed))
    {
        fAccessAllowed = FALSE;
        ErrorTrace((LPARAM) this,
            "AccessCheck Failed with %lu", GetLastError());
        goto Exit;
    }

    if (!fAccessAllowed)
        DebugTrace((LPARAM) this, "Access denied for Queue Admin RPC");

    //Do any additional read-only processing
    if (fWriteAccessRequired && fAccessAllowed &&
        !(MD_ACR_WRITE & maskAccessGranted))
    {
        DebugTrace((LPARAM) this, "Write Access denied for Queue Admin RPC");
        fAccessAllowed = FALSE;
    }

  Exit:
    if (pSecurityDescriptor)
        FreePv(pSecurityDescriptor);

    if (hAccessToken)
        CloseHandle(hAccessToken);

    TraceFunctLeave();
    return fAccessAllowed;
}

//---[ HrGetAQInstance ]-------------------------------------------------------
//
//
//  Description:
//      This is used by all of the AQ RPC's to get a pointer to AQ based on an
//      instance name.
//
//      THE SHUTDOWN LOCK ON ppaqrpc IS HELD AFTER THIS CALL COMPLETES.
//      THE CALLER MUST CALL paqrpc->ShutdownUnlock() WHEN THEY HAVE
//      FINISHED THEIR QUEUE ADMIN OPERATION.
//  Parameters:
//      IN  wszInstance             A number containing the instance to lookup.
//      IN  fWriteAccessRequired    TRUE if write access is required
//      OUT ppIAdvQueueAdmin        Pointer to AQ admin interface
//      OUT ppaqrpc                 Pointer to CAQRpcSvrInst
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) if user does not have access
//      HRESULT_FROM_WIN32(ERROR_NOT_FOUND) if virtual server is not found
//      HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) if server is shutting
//          down.
//      E_POINTER if pointer arguments are NULL
//      E_INVALIDARG if wszInstance is a bad pointer
//  History:
//      6/11/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrGetAQInstance(IN  LPWSTR wszInstance,
                                IN  BOOL fWriteAccessRequired,
                                OUT IAdvQueueAdmin **ppIAdvQueueAdmin,
                                OUT CAQRpcSvrInst **ppaqrpc) {
    TraceFunctEnter("GetAQInstance");

    CAQSvrInst     *paqinst = NULL;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;
    CAQRpcSvrInst  *paqrpc = NULL;
    BOOL            fHasAccess = FALSE;
    DWORD           dwInstance = 1;
    BOOL            fShutdownLock = FALSE;
    HRESULT         hr = S_OK;

    _ASSERT(ppIAdvQueueAdmin);
    _ASSERT(ppaqrpc);

    if (!wszInstance || !ppIAdvQueueAdmin || !ppaqrpc)
    {
        hr = E_POINTER;
        goto Exit;
    }

    *ppIAdvQueueAdmin = NULL;
    *ppaqrpc = NULL;

    if (!pValidateStringPtr(wszInstance, MAX_PATH))
    {
        ErrorTrace(NULL, "Invalid parameter: wszInstance\n");
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwInstance = _wtoi(wszInstance);
    DebugTrace((LPARAM) NULL, "instance is %S (%i)", wszInstance, dwInstance);

    paqrpc = CAQRpcSvrInst::paqrpcGetRpcSvrInstance(dwInstance);
    if (!paqrpc)
    {
        ErrorTrace((LPARAM) NULL,
            "Error unable to find requested virtual server for QAPI %d", dwInstance);
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    //
    //  Check for proper access.
    //
    //  This should be done BEFORE the shutdown lock is grabbed because it
    //  may require hitting the metabase (which could cause a shutdown deadlock)
    if (!paqrpc->fAccessCheck(fWriteAccessRequired))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }

    // Ensure that shutdown does not happen in the middle of our operation
    if (!paqrpc->fTryShutdownLock())
    {
        hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
        goto Exit;
    }

    fShutdownLock = TRUE;
    paqinst = paqrpc->paqinstGetAQ();

    hr = paqinst->QueryInterface(IID_IAdvQueueAdmin,
                                        (void **) &pIAdvQueueAdmin);
    if (FAILED(hr))
    {
        pIAdvQueueAdmin = NULL;
        goto Exit;
    }

  Exit:

    if (FAILED(hr))
    {
        //cleanup
        if (paqrpc)
        {
            if (fShutdownLock)
                paqrpc->ShutdownUnlock();
            paqrpc->Release();
        }

        if (pIAdvQueueAdmin)
            pIAdvQueueAdmin->Release();
        pIAdvQueueAdmin = NULL;
    }
    else //return OUT params
    {
        *ppIAdvQueueAdmin = pIAdvQueueAdmin;
        *ppaqrpc = paqrpc;
        _ASSERT(ppaqrpc);
        _ASSERT(pIAdvQueueAdmin);
    }

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQApplyActionToLinks(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
    LINK_ACTION		laAction)
{
    TraceFunctEnter("AQApplyActionToLinks");
    HRESULT hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;
    CAQRpcSvrInst  *paqrpc = NULL;
    BOOL    fNeedWriteAccess = TRUE;

    if (LA_INTERNAL == laAction) //just checking the state
        fNeedWriteAccess = FALSE;

    hr = HrGetAQInstance(wszInstance, fNeedWriteAccess, &pIAdvQueueAdmin, &paqrpc);
    if (FAILED(hr))
        return hr;

    hr = pIAdvQueueAdmin->ApplyActionToLinks(laAction);

    paqrpc->ShutdownUnlock();
    paqrpc->Release();
    pIAdvQueueAdmin->Release();

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQApplyActionToMessages(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
	MESSAGE_FILTER	*pmfMessageFilter,
	MESSAGE_ACTION	maMessageAction,
    DWORD           *pcMsgs)
{
    TraceFunctEnter("AQApplyActionToMessages");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlQueueLinkId, sizeof(QUEUELINK_ID)))
    {
        ErrorTrace(NULL, "Invalid parameter: pqlQueueLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadReadPtr((LPVOID)pmfMessageFilter, sizeof(MESSAGE_FILTER)))
    {
        ErrorTrace(NULL, "Invalid parameter: pmfMessageFilter\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, TRUE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr))
    {
        hr = pIAdvQueueAdmin->ApplyActionToMessages(pqlQueueLinkId,
                                           pmfMessageFilter,
                                           maMessageAction,
                                           pcMsgs);
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetQueueInfo(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueId,
	QUEUE_INFO		*pqiQueueInfo)
{
    TraceFunctEnter("AQGetQueueInfo");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlQueueId, sizeof(QUEUELINK_ID)))
    {
        ErrorTrace(NULL, "Invalid parameter: pqlQueueId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadReadPtr((LPVOID)pqiQueueInfo, sizeof(QUEUE_INFO)))
    {
        ErrorTrace(NULL, "Invalid parameter: pqiQueueInfo\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr))
    {
        hr = pIAdvQueueAdmin->GetQueueInfo(pqlQueueId,
                                  pqiQueueInfo);
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetLinkInfo(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_INFO		*pliLinkInfo,
    HRESULT         *phrLinkDiagnostic)
{
    TraceFunctEnter("AQGetLinkInfo");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlLinkId, sizeof(QUEUELINK_ID)))
    {
        ErrorTrace(NULL, "Invalid parameter: pqlLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadReadPtr((LPVOID)pliLinkInfo, sizeof(LINK_INFO)))
    {
        ErrorTrace(NULL, "Invalid parameter: pliLinkInfo\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)phrLinkDiagnostic, sizeof(HRESULT)))
    {
        ErrorTrace(NULL, "Invalid parameter: pliLinkInfo\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr))
    {
        hr = pIAdvQueueAdmin->GetLinkInfo(pqlLinkId,
                                 pliLinkInfo, phrLinkDiagnostic);
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }

    // X5:195608
    // I'm pretty sure the root of this has been fixed in fRPCCopyName but
    // just to be sure we are Firewalling against the problem here
    // and in vsaqlink.cpp
    if(SUCCEEDED(hr) && pliLinkInfo && !pliLinkInfo->szLinkName)
    {
        // ASSERT this so we can catch it internally
        _ASSERT(0 && "AQGetLinkInfo wants to return success with a NULL szLinkName");

        // return a failure because we do not have a link name - I'm going
        // with AQUEUE_E_INVALID_DOMAIN to prevent an admin popup
        hr = AQUEUE_E_INVALID_DOMAIN;
    }

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQSetLinkState(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_ACTION		la)
{
    TraceFunctEnter("AQSetLinkInfo");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlLinkId, sizeof(QUEUELINK_ID)))
    {
        ErrorTrace(NULL, "Invalid parameter: pqlLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, TRUE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr))
    {
        hr = pIAdvQueueAdmin->SetLinkState(pqlLinkId,
                                 la);
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetLinkIDs(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	DWORD			*pcLinks,
	QUEUELINK_ID	**prgLinks)
{
    TraceFunctEnter("AQGetLinkIDs");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadWritePtr((LPVOID)pcLinks, sizeof(DWORD)))
    {
        ErrorTrace(NULL, "Invalid parameter: pcLinks\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)prgLinks, sizeof(QUEUELINK_ID *)))
    {
        ErrorTrace(NULL, "Invalid parameter: prgLinks\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr))
    {
        QUEUELINK_ID *rgLinks = NULL;
        DWORD cLinks = 0;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        // loop on calls to GetLinkIDs until we have enough memory to
        // get all of the links.  for the first call we will always
        // have a NULL rgLinks and just be asking for the size.  we need
        // to loop in case more links show up between calls
        while (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            hr = pIAdvQueueAdmin->GetLinkIDs(&cLinks, rgLinks);
            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            {
                if (rgLinks != NULL) MIDL_user_free(rgLinks);
                rgLinks = (QUEUELINK_ID *)
                    MIDL_user_allocate(sizeof(QUEUELINK_ID) * cLinks);
                if (rgLinks == NULL) hr = E_OUTOFMEMORY;
            }
        }

        if (SUCCEEDED(hr))
        {
            *prgLinks = rgLinks;
            *pcLinks = cLinks;
        }
        else
        {
            *prgLinks = NULL;
            *pcLinks = 0;
            if (rgLinks) MIDL_user_free(rgLinks);
        }
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetQueueIDs(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	DWORD			*pcQueues,
	QUEUELINK_ID	**prgQueues)
{
    TraceFunctEnter("AQGetQueueIDs");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlLinkId, sizeof(QUEUELINK_ID)))
    {
        ErrorTrace(NULL, "Invalid parameter: pqlLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)pcQueues, sizeof(DWORD)))
    {
        ErrorTrace(NULL, "Invalid parameter: pcQueues\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)prgQueues, sizeof(QUEUELINK_ID *)))
    {
        ErrorTrace(NULL, "Invalid parameter: prgQueues\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr))
    {
        QUEUELINK_ID *rgQueues = NULL;
        DWORD cQueues = 0;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        // loop on calls to GetLinkIDs until we have enough memory to
        // get all of the links.  for the first call we will always
        // have a NULL rgQueues and just be asking for the size.  we need
        // to loop in case more links show up between calls
        while (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            hr = pIAdvQueueAdmin->GetQueueIDs(pqlLinkId, &cQueues, rgQueues);
            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            {
                if (rgQueues != NULL) MIDL_user_free(rgQueues);
                rgQueues = (QUEUELINK_ID *)
                    MIDL_user_allocate(sizeof(QUEUELINK_ID) * cQueues);
                if (rgQueues == NULL) hr = E_OUTOFMEMORY;
            }
        }

        if (SUCCEEDED(hr))
        {
            *prgQueues = rgQueues;
            *pcQueues = cQueues;
        }
        else
        {
            *prgQueues = NULL;
            *pcQueues = 0;
            if (rgQueues) MIDL_user_free(rgQueues);
        }
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetMessageProperties(
    AQUEUE_HANDLE     	wszServer,
    LPWSTR          	wszInstance,
	QUEUELINK_ID		*pqlQueueLinkId,
	MESSAGE_ENUM_FILTER	*pmfMessageEnumFilter,
	DWORD				*pcMsgs,
	MESSAGE_INFO		**prgMsgs)
{
    TraceFunctEnter("AQGetMessageProperties");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlQueueLinkId, sizeof(QUEUELINK_ID)))
    {
        ErrorTrace(NULL, "Invalid parameter: pqlQueueLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadReadPtr((LPVOID)pmfMessageEnumFilter, sizeof(MESSAGE_FILTER)))
    {
        ErrorTrace(NULL, "Invalid parameter: pmfMessageEnumFilter\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)pcMsgs, sizeof(DWORD)))
    {
        ErrorTrace(NULL, "Invalid parameter: pcMsgs\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)prgMsgs, sizeof(MESSAGE_INFO *)))
    {
        ErrorTrace(NULL, "Invalid parameter: prgMsgs\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr))
    {
        MESSAGE_INFO *rgMsgs = NULL;
        DWORD cMsgs = 0;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        // loop on calls to GetLinkIDs until we have enough memory to
        // get all of the links.  for the first call we will always
        // have a NULL rgMsgs and just be asking for the size.  we need
        // to loop in case more links show up between calls
        while (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            hr = pIAdvQueueAdmin->GetMessageProperties(pqlQueueLinkId,
                                              pmfMessageEnumFilter,
                                              &cMsgs,
                                              rgMsgs);
            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            {
                if (rgMsgs != NULL) MIDL_user_free(rgMsgs);
                rgMsgs = (MESSAGE_INFO *)
                    MIDL_user_allocate(sizeof(MESSAGE_INFO) * cMsgs);
                if (rgMsgs == NULL) hr = E_OUTOFMEMORY;
            }
        }

        if (SUCCEEDED(hr))
        {
            *prgMsgs = rgMsgs;
            *pcMsgs = cMsgs;
        }
        else
        {
            *prgMsgs = NULL;
            *pcMsgs = 0;
            if (rgMsgs) MIDL_user_free(rgMsgs);
        }
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }

    TraceFunctLeave();
    return hr;
}


//---[ AQQuerySupportedActions ]----------------------------------------------
//
//
//  Description:
//      Client stub for querying supported actions
//  Parameters:
//      IN  wszServer               The server to connect to
//      IN  wszInstance             The virtual server instance to connect to
//      IN  pqlQueueLinkId          The queue/link we are interested in
//      OUT pdwSupportedActions     The MESSAGE_ACTION flags supported
//      OUT pdwSupportedFilterFlags The supported filter flags
//  Returns:
//      S_OK on success
//      E_INVALIDARG on bad pointer args
//      Internal error code from HrGetAQInstance or
//          IAdvQueue::QuerySupportedActions
//  History:
//      6/15/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
NET_API_STATUS
NET_API_FUNCTION
AQQuerySupportedActions(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
    DWORD           *pdwSupportedActions,
    DWORD           *pdwSupportedFilterFlags)
{
    TraceFunctEnter("AQQuerySupportedActions");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;
    BOOL            fHasWriteAccess = TRUE;

    if (IsBadReadPtr((LPVOID)pqlQueueLinkId, sizeof(QUEUELINK_ID)))
    {
        ErrorTrace(NULL, "Invalid parameter: pqlQueueLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)pdwSupportedActions, sizeof(DWORD)))
    {
        ErrorTrace(NULL, "Invalid parameter: pdwSupportedActions\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)pdwSupportedFilterFlags, sizeof(DWORD)))
    {
        ErrorTrace(NULL, "Invalid parameter: pdwSupportedFilterFlags\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, TRUE, &pIAdvQueueAdmin, &paqrpc);
    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr))
        return hr;

    //
    //  If we cannot get the instance, then try again only requesting
    //  read-only access
    //
    if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
    {
        fHasWriteAccess = FALSE;
        hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    }

    if (SUCCEEDED(hr))
    {
        hr = pIAdvQueueAdmin->QuerySupportedActions(pqlQueueLinkId,
                                           pdwSupportedActions,
                                           pdwSupportedFilterFlags);

        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();

        //
        //  If the caller does not have write access, we need to
        //  censor the supported actions
        //
        if (!fHasWriteAccess)
            *pdwSupportedActions = 0;
    }

    TraceFunctLeave();
    return hr;
}

//---[ MIDL_user_allocate ]----------------------------------------------------
//
//
//  Description:
//      MIDL memory allocation
//  Parameters:
//      size : Memory size requested.
//  Returns:
//      Pointer to the allocated memory block.
//  History:
//      6/5/99 - MikeSwa Created (taken from smtpapi rcputil.c)
//
//-----------------------------------------------------------------------------
PVOID MIDL_user_allocate(IN size_t size)
{
    PVOID pvBlob = NULL;

    pvBlob = LocalAlloc( LPTR, size);

    return(pvBlob);

}

//---[ MIDL_user_free ]--------------------------------------------------------
//
//
//  Description:
//    MIDL memory free .
//  Parameters:
//    IN    pvBlob    Pointer to a memory block that is freed.
//  Returns:
//      -
//  History:
//      6/5/99 - MikeSwa Created (from smtpapi rcputil.c)
//
//-----------------------------------------------------------------------------
VOID MIDL_user_free(IN PVOID pvBlob)
{
    LocalFree(pvBlob);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqreg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqreg.cpp
//
//  Description:
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      1/21/2000 - MikeSwa Created
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "aqprecmp.h"
#include <registry.h>

//---[ CAQRegDwordDescriptor ]-------------------------------------------------
//
//
//  Description:
//      Simple stucture used to match the name of a value of a DWORD in memory
//  Hungarian:
//      regdw, pregwd
//
//-----------------------------------------------------------------------------
class CAQRegDwordDescriptor
{
  public:
    LPCSTR      m_szName;
    DWORD      *m_pdwValue;
    VOID UpdateGlobalDwordFromRegistry(const CMyRegKey &regKey) const;
};

//
//  Array of descriptors that match the name of the value with the internal
//  variable
//
const CAQRegDwordDescriptor g_rgregwd[] = {
    {"MsgHandleThreshold",              &g_cMaxIMsgHandlesThreshold},
    {"MsgHandleAsyncThreshold",         &g_cMaxIMsgHandlesAsyncThreshold},
    {"LocalRetryMinutes",               &g_cLocalRetryMinutes},
    {"CatRetryMinutes",                 &g_cCatRetryMinutes},
    {"RoutingRetryMinutes",             &g_cRoutingRetryMinutes},
    {"SubmissionRetryMinutes",          &g_cSubmissionRetryMinutes},
    {"ResetRoutesRetryMinutes",         &g_cResetRoutesRetryMinutes},
    {"SecondsPerDSNPass",               &g_cMaxSecondsPerDSNsGenerationPass},
    {"AdditionalPoolThreadsPerProc",    &g_cPerProcMaxThreadPoolModifier},
    {"MaxPercentPoolThreads",           &g_cMaxATQPercent},
    {"MaxTicksPerATQThread",            &g_cMaxTicksPerATQThread},
    {"ResetMessageStatus",              &g_fResetMessageStatus},
    {"GlitchRetrySeconds",              &g_dwGlitchRetrySeconds},
    {"MaxPendingCat",                   &g_cMaxPendingCat},
    {"MaxPendingLocal",                 &g_cMaxPendingLocal},
    {"MsgHandleThresholdRangePercentage", &g_cMaxIMsgHandlesThresholdRangePercent},
    {"MaxHandleReserve",                &g_cMaxHandleReserve},
    {"MaxSyncCatQThreads",              &g_cMaxSyncCatQThreads},
    {"ItemsPerAsyncCatQThread",         &g_cItemsPerCatQAsyncThread},
    {"ItemsPerSyncCatQThread",          &g_cItemsPerCatQSyncThread},
    {"MaxSyncLocalQThreads",            &g_cMaxSyncLocalQThreads},
    {"ItemsPerAsyncLocalQThread",       &g_cItemsPerLocalQAsyncThread},
    {"ItemsPerSyncLocalQThread",        &g_cItemsPerLocalQSyncThread},
    {"ItemsPerPostDSNQAsyncThread",     &g_cItemsPerPostDSNQAsyncThread},
    {"ItemsPerRoutingQAsyncThread",     &g_cItemsPerRoutingQAsyncThread},
    {"ItemsPerSubmitQAsyncThread",      &g_cItemsPerSubmitQAsyncThread},
    {"ItemsPerWorkQAsyncThread",        &g_cItemsPerWorkQAsyncThread},
    {"MaxDSNSize",                      &g_dwMaxDSNSize},
    {"PerMsgFailuresBeforeMarkingAsProblem", &g_cMsgFailuresBeforeMarkingMsgAsProblem},
};

// Key to enable test settings array below
const CAQRegDwordDescriptor g_regwdEnableTestSettings =
    {"EnableTestSettings", &g_fEnableTestSettings};

//
//  Second Array of values to be enabled only when "EnableTestSettings"
//  is set to TRUE
//
const CAQRegDwordDescriptor g_rgregwdTestSettings[] = {
    {"PreSubmitQueueFailurePercent",    &g_cPreSubmitQueueFailurePercent},
    {"PreRoutingQueueFailurePercent",   &g_cPreRoutingQueueFailurePercent},
    {"PreCatQueueFailurePercent",       &g_cPreCatQueueFailurePercent},
    {"SubmitQueueSleepMilliseconds",    &g_dwSubmitQueueSleepMilliseconds},
    {"CatQueueSleepMilliseconds",       &g_dwCatQueueSleepMilliseconds},
    {"RoutingQueueSleepMilliseconds",   &g_dwRoutingQueueSleepMilliseconds},
    {"LocalQueueSleepMilliseconds",     &g_dwLocalQueueSleepMilliseconds},
    {"DelayLinkRemovalSeconds",         &g_cDelayLinkRemovalSeconds},
    {"EnableRetailAsserts",             &g_fEnableRetailAsserts},
};


//  Max message objects.  This key is slightly special in that it is read
//  from a mailmsg configuration key.
const CAQRegDwordDescriptor g_regwdMaxMessageObjects =
    {"MaxMessageObjects", &g_cMaxMsgObjects};

//---[ UpdateGlobalDwordFromRegistry ]-----------------------------------------
//
//
//  Description:
//      Updates a global DWORD value from the registry.  Will not modify data
//      if the value is not in the registry
//  Parameters:
//      IN  regKey      CMyRegKey class for containing key
//      IN  szValue     Name of value to read under key
//      IN  pdwData     Data of value
//  Returns:
//      -
//  History:
//      1/21/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CAQRegDwordDescriptor::UpdateGlobalDwordFromRegistry(const CMyRegKey &regKey) const
{
    TraceFunctEnterEx(0, "UpdateGlobalDwordFromRegistry");
    DWORD       dwValue = 0;
    DWORD       dwErr   = NO_ERROR;
    CRegDWORD   regDWHandles(regKey, m_szName);


    //
    //  We should have a valid string associated with this object
    //
    _ASSERT(m_szName);

    dwErr = regDWHandles.QueryErrorStatus();
    if (NO_ERROR != dwErr)
        goto Exit;

    dwErr = regDWHandles.GetDword(&dwValue);
    if (NO_ERROR != dwErr)
        goto Exit;

    if (m_pdwValue)
        *m_pdwValue = dwValue;

  Exit:
    DebugTrace(0, "Reading registry value %s\\%s %d - (err 0x%08X)",
        regKey.GetName(), m_szName, dwValue, dwErr);

    TraceFunctLeave();
    return;
}

//---[ ReadGlobalRegistryConfiguration ]---------------------------------------
//
//
//  Description:
//      Reads all the global registry configuration.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/21/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID ReadGlobalRegistryConfiguration()
{
    TraceFunctEnterEx(0, "HrReadGlobalRegistryConfiguration");
    DWORD   dwErr                   = NO_ERROR;
    DWORD   cValues                 = 0;
    CAQRegDwordDescriptor *pregdw   = NULL;
    MEMORYSTATUSEX MemStatus;

    // Clear this value so we can tell if the user configured it
    g_cMaxIMsgHandlesThreshold = 0;

    // Registry Key for Queueing Settings
    CMyRegKey regKey(HKEY_LOCAL_MACHINE, &dwErr, AQREG_KEY_CONFIGURATION, KEY_READ);

    if (NO_ERROR != dwErr) {
        DebugTrace(0, "Opening aqreg key %s failed with - Err 0x%08X",
            regKey.GetName(), dwErr);
    }
    else {
        //
        // Loop through all our DWORD config and store the global variable
        //
        cValues = sizeof(g_rgregwd)/sizeof(CAQRegDwordDescriptor);
        pregdw = (CAQRegDwordDescriptor *) g_rgregwd;
        while (cValues) {
            pregdw->UpdateGlobalDwordFromRegistry(regKey);
            cValues--;
            pregdw++;
        }
    }

    // Registry Key for Test Settings
    CMyRegKey regKeyTestSettings(HKEY_LOCAL_MACHINE, &dwErr, AQREG_KEY_CONFIGURATION_TESTSETTINGS, KEY_READ);
    if (NO_ERROR != dwErr) {
        DebugTrace(0, "Opening aqreg key %s failed with - Err 0x%08X",
            regKeyTestSettings.GetName(), dwErr);
    }
    else {
        // Load Test Settings if key "EnableTestSettings" is TRUE
        g_regwdEnableTestSettings.UpdateGlobalDwordFromRegistry(regKeyTestSettings);
        if (g_fEnableTestSettings) {

            //
            // Loop through all our DWORD config and store the global variable
            //
            cValues = sizeof(g_rgregwdTestSettings)/sizeof(CAQRegDwordDescriptor);
            pregdw = (CAQRegDwordDescriptor *) g_rgregwdTestSettings;
            while (cValues) {
                pregdw->UpdateGlobalDwordFromRegistry(regKeyTestSettings);
                cValues--;
                pregdw++;
            }
        }
    }

    // Registry Key for MailMsg Settings
    CMyRegKey regKeyMailMsg(HKEY_LOCAL_MACHINE, &dwErr, MAILMSG_KEY_CONFIGURATION, KEY_READ);

    if (NO_ERROR != dwErr) {
        DebugTrace(0, "Opening aqreg key %s failed with - Err 0x%08X",
            regKeyMailMsg.GetName(), dwErr);
    }
    else {
        g_regwdMaxMessageObjects.UpdateGlobalDwordFromRegistry(regKeyMailMsg);
    }

    //
    // Now, special case the MsgHandleThreshold to satisify raid 166958
    //
    if ( 0 == g_cMaxIMsgHandlesThreshold ) {

        g_cMaxIMsgHandlesThreshold = 1000;

        MemStatus.dwLength = sizeof( MEMORYSTATUSEX );
        if ( TRUE == GlobalMemoryStatusEx( &MemStatus ) ) {

            ULONG MemBlocks = ( ULONG )( ( ( ( MemStatus.ullTotalPhys >> 10 ) + 512) >> 10 ) / 256 );
            if ( 0 == MemBlocks ) {

                MemBlocks = 1;

            } else if ( 16 < MemBlocks ) {

                MemBlocks = 16;
            }
            g_cMaxIMsgHandlesThreshold = MemBlocks * 1000;

        } else {

            DebugTrace( 0,
                        "Getting global memory status failed - (err 0x%08X)",
                        GetLastError( ) );

        }
    }

    //
    //  Calculate high and low thresholds
    //
    if (g_cMaxIMsgHandlesThresholdRangePercent > 99)
        g_cMaxIMsgHandlesThresholdRangePercent = 99;

    g_cMaxIMsgHandlesLowThreshold = g_cMaxIMsgHandlesThreshold;
    if (0 != g_cMaxIMsgHandlesThresholdRangePercent) {
        DWORD dwRange = (g_cMaxIMsgHandlesThreshold*g_cMaxIMsgHandlesThresholdRangePercent)/100;
        g_cMaxIMsgHandlesLowThreshold -= dwRange;
    }


    DebugTrace( 0,
                "g_cMaxIMsgHandlesThreshold set to %lu",
                g_cMaxIMsgHandlesThreshold );

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqreg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqreg.h
//
//  Description:    Header file containing aq's registry constants
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      1/4/2000 - MikeSwa Created
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQREG_H__
#define __AQREG_H__

//---[ Registry Paths ]--------------------------------------------------------
//
//
//  Description:
//      These are the registry keys used by AQ for configuration
//
//-----------------------------------------------------------------------------
#define AQREG_KEY_CONFIGURATION "System\\CurrentControlSet\\Services\\SMTPSVC\\Queuing"
#define AQREG_KEY_CONFIGURATION_TESTSETTINGS "System\\CurrentControlSet\\Services\\SMTPSVC\\Queuing\\TestSettings"

//---[ Global Registry Variables ]---------------------------------------------
//
//
//  Description:
//      The following are the global configuration variables that can be
//      affected by registry settings.
//
//-----------------------------------------------------------------------------

//
// Handle management values.  When the number of mailmsgs in the system hits
// this threshold, we will start closing handles.
//
_declspec(selectany)    DWORD   g_cMaxIMsgHandlesThreshold      = 1000;
_declspec(selectany)    DWORD   g_cMaxIMsgHandlesAsyncThreshold = 1000;


//
//  Used to generate a range of handle thresholds that we will
//  use in conjunction with the length of the queue to determine
//  if we actually need to close handles.
//
_declspec(selectany)    DWORD   g_cMaxIMsgHandlesThresholdRangePercent  = 20;
_declspec(selectany)    DWORD   g_cMaxIMsgHandlesLowThreshold = g_cMaxIMsgHandlesThreshold;
_declspec(selectany)	DWORD	g_cMaxHandleReserve = 200;

//
//  The following is a for optimizing DSN generation.  After generating
//  a certain number of DSNs, we will quit and go and restart at a later time
//
_declspec(selectany)    DWORD   g_cMaxSecondsPerDSNsGenerationPass = 10;

//
//  The following is the amount of time to wait before retry a reset
//  routes after a routing failure
//
_declspec(selectany)    DWORD   g_cResetRoutesRetryMinutes = 10;

//
//  Async Queue retry intervals that can be modified by registry settings
//
_declspec(selectany)    DWORD   g_cLocalRetryMinutes        = 5;
_declspec(selectany)    DWORD   g_cCatRetryMinutes          = 60;
_declspec(selectany)    DWORD   g_cRoutingRetryMinutes      = 10;
_declspec(selectany)    DWORD   g_cSubmissionRetryMinutes   = 60;

//
//  Async Queue Adjustment values.  We will increase the max number
//  of threads per proc by this value
//
_declspec(selectany)    DWORD   g_cPerProcMaxThreadPoolModifier = 6;

//
//  Async Queue Adjustment value.  We will request up to this % of
//  max ATQ threads *per async queue*.  This % is post our modifcation
//  as per g_cPerProcMaxThreadPoolModifier.
//
_declspec(selectany)    DWORD   g_cMaxATQPercent            = 90;

//
//  Async Queue Thread Timeout value.  After we process each item in
//  a queue we will check to see if we have been processing longer than
//  this number of milliseconds and if we have we will drop the thread.
//  This is intended to keep thread times short and the system responsive.
//

_declspec(selectany)    DWORD   g_cMaxTicksPerATQThread     = 10000;

//
//  Reset Message status.  If this is non-zero, we will reset the
//  message status of every message submitted to MP_STATUS_SUBMITTED.
//
_declspec(selectany)    DWORD   g_fResetMessageStatus       = 0;

//
// retry a glitch failures quicker than "normal" failures
//
_declspec(selectany)    DWORD   g_dwGlitchRetrySeconds      = 60;

//
// the maximum number of outstanding CAT or LD operations
//
_declspec(selectany)    DWORD   g_cMaxPendingCat            = 1000;
_declspec(selectany)    DWORD   g_cMaxPendingLocal          = 1000;

//
//	Internal AsyncQueue tuning parameters
//		- NOTE - Some are not registry configurable, because non-zero
//		  values can cause a deadlock.
_declspec(selectany)    DWORD   g_cMaxSyncCatQThreads           = 5;
_declspec(selectany)    DWORD   g_cItemsPerCatQSyncThread	    = 10;
_declspec(selectany)    DWORD   g_cItemsPerCatQAsyncThread      = 10;

_declspec(selectany)    DWORD   g_cMaxSyncLocalQThreads         = 0;
_declspec(selectany)    DWORD   g_cItemsPerLocalQSyncThread     = 10;
_declspec(selectany)    DWORD   g_cItemsPerLocalQAsyncThread    = 10;

// Cannot config g_cMaxSyncPostDSNQThreads
//  It must be zero to avoid a deadlock (same thread cannot enqueue and dequeue)
const                   DWORD   g_cMaxSyncPostDSNQThreads       = 0;
const                   DWORD   g_cItemsPerPostDSNQSyncThread   = 100;
_declspec(selectany)    DWORD   g_cItemsPerPostDSNQAsyncThread  = 100;


//  Cannot config g_cMaxSyncRoutingThreads
//  It must be zero to avoid a deadlock (same thread cannot enqueue and dequeue)
const                   DWORD   g_cMaxSyncRoutingQThreads        = 0;
const                   DWORD   g_cItemsPerRoutingQSyncThread    = 10;
_declspec(selectany)    DWORD   g_cItemsPerRoutingQAsyncThread   = 10;


// Cannot configure g_cMaxSyncSubmitQThreads
//  It must be zero to avoid a deadlock (same thread cannot enqueue and dequeue)
const                   DWORD   g_cMaxSyncSubmitQThreads        = 0;
const                   DWORD   g_cItemsPerSubmitQSyncThread    = 10;
_declspec(selectany)    DWORD   g_cItemsPerSubmitQAsyncThread   = 10;

// Used to determine the number of threads that will be requested by
// the async workq
_declspec(selectany)    DWORD   g_cItemsPerWorkQAsyncThread     = 10;



//
// Flag to enable registry "Test Settings" values - this must be enabled
// for any of the below testing values to have any effect.
//
_declspec(selectany)    DWORD   g_fEnableTestSettings = FALSE;

//
// Percentage of failures to cause processing local queues
//
_declspec(selectany)    DWORD   g_cPreSubmitQueueFailurePercent = 0;
_declspec(selectany)    DWORD   g_cPreRoutingQueueFailurePercent = 0;
_declspec(selectany)    DWORD   g_cPreCatQueueFailurePercent = 0;

//
//  Sleep times used for performance analysis.
//
_declspec(selectany)    DWORD   g_dwSubmitQueueSleepMilliseconds = 0;
_declspec(selectany)    DWORD   g_dwCatQueueSleepMilliseconds    = 0;
_declspec(selectany)    DWORD   g_dwRoutingQueueSleepMilliseconds= 0;
_declspec(selectany)    DWORD   g_dwLocalQueueSleepMilliseconds  = 0;

// Flag to allow us to delay link removal to repro bug where a queue
// may be added to a removed link if timing is just right
_declspec(selectany)    DWORD   g_cDelayLinkRemovalSeconds  = 0;


// DSNs for message larger than this size will contain only the headers
_declspec(selectany)    DWORD   g_dwMaxDSNSize = 0xFFFFFFFF; // No limit


//
// Number of *message* failures to allow before marking a message as
// problem and queuing differently
//
_declspec(selectany)    DWORD   g_cMsgFailuresBeforeMarkingMsgAsProblem = 2;

// Test key to enable "retail asserts" - special asserts which will AV
// in RTL if this key is enabled
_declspec(selectany)    DWORD   g_fEnableRetailAsserts = FALSE;

//
//  Max message objects.  This key is slightly special in that it is read
//  from a mailmsg configuration key.
//
#define MAILMSG_KEY_CONFIGURATION "Software\\Microsoft\\Exchange\\MailMsg"
_declspec(selectany)    DWORD   g_cMaxMsgObjects = 100000;

//
// Inline function that sleeps as appropriate
//
inline void SleepForPerfAnalysis(DWORD dwSleepMilliseconds)
{
    if (g_fEnableTestSettings && dwSleepMilliseconds)
        Sleep(dwSleepMilliseconds);
}

//
// Inline function to control test failures
//
inline BOOL fShouldFail(DWORD dwPercent)
{
    if (g_fEnableTestSettings && dwPercent)
        return (((DWORD)(rand() % 100)) < dwPercent);
    else
        return FALSE;
}

//
// Implementation of _ASSERTRTL.  This will cause an _ASSERT in
// DEBUG and an AV in RTL if the EnableRetailAsserts reg value is set
//

#ifdef DEBUG
#define _ASSERTRTL _ASSERT
#else // RETAIL
inline void _ASSERTRTL(BOOL fExpression)
{
    if (g_fEnableTestSettings && g_fEnableRetailAsserts)
    {
        if (!fExpression)
        {
            *((int*)0) = 0; // _ASSERTRTL : Trigger an AV here
        }
    }
}
#endif // DEBUG / RETAIL

//
//Reads config information from the registry and modifies the appropriate globals.
//
VOID ReadGlobalRegistryConfiguration();

#endif //__AQREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqstats.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqstats.h
//
//  Description:  Header file for CAQStats class
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      11/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQSTATS_H__
#define __AQSTATS_H__

#include "cmt.h"
#include "aqutil.h"

enum NotifyType
{
    NotifyTypeUndefined     = 0x00000000,
    NotifyTypeDestMsgQueue  = 0x00000001, //notification sender is a dest queue
    NotifyTypeLinkMsgQueue  = 0x00000002, //notification sender is a link
    NotifyTypeReroute       = 0x00000004, //notification sender is a reroute
    NotifyTypeNewLink       = 0x10000000, //sender is a newly created link
};

class CDestMsgQueue;
class CLinkMsgQueue;

#define AQSTATS_SIG 'tatS'

//---[ CAQStats ]-------------------------------------------------------
//
//
//  Hungarian: aqstat, paqstat
//
//  
//-----------------------------------------------------------------------------
class CAQStats 
{
protected:
    DWORD               m_dwSignature;
public:
    DWORD               m_dwNotifyType; //Type of notification being sent
    DWORD               m_cMsgs;        //Total count of msgs
    DWORD               m_cOtherDomainsMsgSpread;  //Count of other domains message
                                                   //is queued for
    DWORD               m_rgcMsgPriorities[NUM_PRIORITIES]; //count per-priority
    ULARGE_INTEGER      m_uliVolume;
    DWORD               m_dwHighestPri;
    union //notification sender
    {
        PVOID          m_pvContext;
        CDestMsgQueue  *m_pdmq;
        CLinkMsgQueue  *m_plmq;
    };
    DWORD               m_cRetryMsgs;     // Total count of messages in retry queue 
    
    CAQStats();
    void Reset();

    //Used to provide thread-safe update
    void UpdateStats(CAQStats *paqstat, BOOL fAdd);
    void UpdateRetryStats(BOOL fAdd);
    
};


#endif //__AQSTATS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqsize.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqsize.h
//
//  Description:  Header file that defines globals that can be used as a 
//      internal version stamp by debugger exstensions
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/5/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQSIZE_H__
#define __AQSIZE_H__

_declspec(selectany) DWORD g_cbClasses = 
                                sizeof(CAQSvrInst) +
                                sizeof(CLinkMsgQueue) +
                                sizeof(CDestMsgQueue) +
                                sizeof(CDomainEntry) + 
                                sizeof(CMsgRef) +
                                sizeof(CSMTPConn);

_declspec(selectany) DWORD g_dwFlavorSignature = 
#ifdef DEBUG
' GBD';
#else
' LTR';
#endif

#endif //__AQSIZE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqstats.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqstats.cpp
//
//  Description:  Implementation of CAQStats/
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      11/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqstats.h"
#include "aqutil.h"

CAQStats::CAQStats()
{
    m_dwSignature = AQSTATS_SIG;
    Reset();
}

void CAQStats::Reset()
{
    m_dwHighestPri = 0;
    m_dwNotifyType = NotifyTypeUndefined;
    m_uliVolume.QuadPart = 0;
    m_pvContext = NULL;
    m_cMsgs = 0;
    m_cRetryMsgs = 0;
    m_cOtherDomainsMsgSpread = 0;
    ZeroMemory(m_rgcMsgPriorities, NUM_PRIORITIES*sizeof(DWORD));
};

//---[ CAQStats::UpdateRetryStats ]------------------------------------------
//
//
//  Description: 
//      Used to provide "thread-safe" update on retry queue.
//      This function only updates m_cRetryMsg.
//      One message at a time. Only called after enqueu/dequeue of retry queue.
//      There's no need to adjust other members
//  
//  Parameters:
//      fAdd            TRUE if update reflects addition of msgs into retry queue 
//                      FALSE if update reflects removal of msgs into retry queue
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CAQStats::UpdateRetryStats(BOOL fAdd)
{
    dwInterlockedAddSubtractDWORD(&m_cRetryMsgs, 1, fAdd);
}

//---[ CAQStats::UpdateStats ]------------------------------------------
//
//
//  Description: 
//      Used to provide "thread-safe" update.
//
//      NOTE: It is possible that m_dwHighestPri will not be entirely correct
//      if multple threads are changing the max priority at the same time, but
//      was deemed non-crucial.
//  Parameters:
//      paqstats        CAQStats to update data from
//      fAdd            TRUE if update reflects addition of msgs 
//                      FALSE if update reflects removal of msgs
//  Returns:
//      -
//  History:
//      11/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQStats::UpdateStats(CAQStats *paqstat, BOOL fAdd)
{
    DWORD dwPri = 0;
    DWORD cTmpMsgCount = 0;
    DWORD dwNewHighestPri = 0;

    dwInterlockedAddSubtractDWORD(&m_cMsgs, paqstat->m_cMsgs, fAdd);
    dwInterlockedAddSubtractDWORD(&m_cOtherDomainsMsgSpread, paqstat->m_cOtherDomainsMsgSpread, fAdd);
    dwInterlockedAddSubtractDWORD(&m_cRetryMsgs, paqstat->m_cRetryMsgs, fAdd);
    
    //When adding new messages, finding the highest priority is easy
    dwPri = m_dwHighestPri;
    if (fAdd && (paqstat->m_dwHighestPri > dwPri))
    {
        InterlockedCompareExchange((PLONG) &m_dwHighestPri, 
                                   (LONG) paqstat->m_dwHighestPri, 
                                   (LONG) dwPri);
    }

    //Count down from highest prioriry
    for (DWORD iPri = 0; iPri < NUM_PRIORITIES; iPri++)
    {
        if (paqstat->m_rgcMsgPriorities[iPri])
        {
            cTmpMsgCount = dwInterlockedAddSubtractDWORD(&(m_rgcMsgPriorities[iPri]), 
                                paqstat->m_rgcMsgPriorities[iPri], fAdd);

            if (!fAdd && (cTmpMsgCount != paqstat->m_rgcMsgPriorities[iPri]))
            {
                if (dwNewHighestPri < iPri)
                    dwNewHighestPri = dwNewHighestPri;
            }
        }
        else if (!fAdd && m_rgcMsgPriorities[iPri] && (dwNewHighestPri < iPri))
        {
            dwNewHighestPri = dwNewHighestPri;
        }

    }

    //See if removing message has changed the highest priority
    if (!fAdd && (dwNewHighestPri < dwPri))
    {
        InterlockedCompareExchange((PLONG) &m_dwHighestPri, 
                                   (LONG) dwNewHighestPri, 
                                   (LONG) dwPri);
    }

    //Update total volume
    InterlockedAddSubtractULARGE(&m_uliVolume, &(paqstat->m_uliVolume), fAdd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqutil.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqutil.cpp
//
//  Description:
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/20/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqutil.h"

//---[ HrIncrementIMailMsgUsageCount ]-------------------------------------------
//
//
//  Description:
//      Calls IMailMsgQueueMgmt::AddUsage.  Handles calling QueryInterface
//      for the right interface
//  Parameters:
//      pIUnknown   - ptr to IUknown for MailMsg
//  Returns:
//      S_OK on success
//  History:
//      7/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrIncrementIMailMsgUsageCount(IUnknown *pIUnknown)
{
    TraceFunctEnterEx((LPARAM) pIUnknown, "HrIncrementIMailMsgUsageCount");
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    _ASSERT(pIUnknown);

    hr = pIUnknown->QueryInterface(IID_IMailMsgQueueMgmt, (PVOID *) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgQueueMgmt FAILED");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->AddUsage();
    if (FAILED(hr))
        goto Exit;

  Exit:
    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    TraceFunctLeave();
    return hr;
}

//---[ HrReleaseIMailMsgUsageCount ]-------------------------------------------
//
//
//  Description:
//      Calls IMailMsgQueueMgmt::ReleaseUsage.  Handles calling QueryInterface
//      for the right interface
//  Parameters:
//      pIUnknown   - ptr to IUknown for MailMsg
//  Returns:
//      S_OK on success
//  History:
//      7/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrReleaseIMailMsgUsageCount(IUnknown *pIUnknown)
{
    TraceFunctEnterEx((LPARAM) pIUnknown, "HrReleaseIMailMsgUsageCount");
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    _ASSERT(pIUnknown);

    hr = pIUnknown->QueryInterface(IID_IMailMsgQueueMgmt, (PVOID *) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgQueueMgmt FAILED");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->ReleaseUsage();
    if (FAILED(hr))
        goto Exit;

  Exit:
    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    TraceFunctLeave();
    return hr;
}

//---[ HrDeleteIMailMsg ]------------------------------------------------------
//
//
//  Description:
//      Deletes a Msg and releases its usage count
//  Parameters:
//      pIUnknown   Ptr to mailmsg
//  Returns:
//      S_OK on success
//  History:
//      7/21/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrDeleteIMailMsg(IUnknown *pIUnknown)
{
    TraceFunctEnterEx((LPARAM) pIUnknown, "HrDeleteIMailMsg");
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    _ASSERT(pIUnknown);

    hr = pIUnknown->QueryInterface(IID_IMailMsgQueueMgmt, (PVOID *) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgQueueMgmt FAILED");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->Delete(NULL);
    if (FAILED(hr))
        goto Exit;

  Exit:
    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    TraceFunctLeave();
    return hr;
}

//---[ HrWalkMailMsgQueueForShutdown ]------------------------------------------
//
//
//  Description:
//      Function to walk an IMailMsg queue at shutdown and clear out all of the
//      IMailMsgs
//  Parameters:
//      IN  pIMailMsgProperties //ptr to data on queue
//      IN  PVOID pvContext   //list of queues to prepare for DSN
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      S_OK
//  History:
//      7/20/98 - MikeSwa Created
//      7/7/99 - Added async shutdown
//-----------------------------------------------------------------------------
HRESULT HrWalkMailMsgQueueForShutdown(IN IMailMsgProperties *pIMailMsgProperties,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrWalkMailMsgQueueForShutdown");
    Assert(pfContinue);
    Assert(pfDelete);
    HRESULT hrTmp = S_OK;
    CAQSvrInst *paqinst = (CAQSvrInst *) pvContext;

    _ASSERT(pIMailMsgProperties);
    _ASSERT(paqinst);


    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    paqinst->ServerStopHintFunction();

    //Add to queue so async thread will have final release and the associated I/O
    pIMailMsgProperties->AddRef();
    paqinst->HrQueueWorkItem(pIMailMsgProperties, fMailMsgShutdownCompletion);

    TraceFunctLeave();
    return S_OK;
}


//---[ fMailMsgShutdownCompletion ]---------------------------------------------
//
//
//  Description:
//      CAsyncWorkQueue completion function to allow multi-threaded shutdown
//      of a MailMsgQueue
//  Parameters:
//      IN  pvContext   - A mailmsg to release
//      IN  dwStatus    - The status passed in by the async work queue
//  Returns:
//      TRUE always
//  History:
//      7/7/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL    fMailMsgShutdownCompletion(PVOID pvContext, DWORD dwStatus)
{
    IMailMsgProperties *pIMailMsgProperties = (IMailMsgProperties *) pvContext;
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    _ASSERT(pIMailMsgProperties);

    if (!pIMailMsgProperties)
        goto Exit;

    //Bounce the usage count to force this thread to do any necessary commits
    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt,
                                            (PVOID *) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgQueueMgmt FAILED");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->ReleaseUsage();
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->AddUsage();
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    return TRUE;
}

//---[ HrWalkMsgRefQueueForShutdown ]--------------------------------
//
//
//  Description:
//      Function to walk a queue containing msgrefs at shutdown and
//      clear out all of the IMailMsgs
//  Parameters:
//      IN  CMsgRef pmsgref,  //ptr to data on queue
//      IN  PVOID pvContext   //list of queues to prepare for DSN
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      S_OK - *always*
//  History:
//      7/20/98 - MikeSwa Created
//      7/7/99 - MikeSwa Added async shutdown
//-----------------------------------------------------------------------------
HRESULT HrWalkMsgRefQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "HrWalkMsgRefQueueForShutdown");
    Assert(pfContinue);
    Assert(pfDelete);
    CAQSvrInst *paqinst = (CAQSvrInst *) pvContext;
    _ASSERT(pmsgref);
    _ASSERT(paqinst);

    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    if (paqinst)
        paqinst->ServerStopHintFunction();

    //Add to queue so async thread will have final release and the associated I/O
    pmsgref->AddRef();
    paqinst->HrQueueWorkItem(pmsgref, fMsgRefShutdownCompletion);

    TraceFunctLeave();
    return S_OK;
}

//---[ fMsgRefShutdownCompletion ]---------------------------------------------
//
//
//  Description:
//      CAsyncWorkQueue completion function to allow multi-threaded shutdown
//      of a MailMsgQueue
//  Parameters:
//      IN  pvContext   - A mailmsg to release
//      IN  dwStatus    - The status passed in by the async work queue
//  Returns:
//      TRUE always
//  History:
//      7/7/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL    fMsgRefShutdownCompletion(PVOID pvContext, DWORD dwStatus)
{
    CMsgRef *pmsgref = (CMsgRef *) pvContext;
    _ASSERT(pmsgref);

    if (!pmsgref)
        return TRUE;

    //Call prepare to shutdown to force async threads to be the ones
    //doing that actual IO
    pmsgref->PrepareForShutdown();
    pmsgref->Release();
    return TRUE;
}

//---[ CalcDMTPerfCountersIteratorFn ]-----------------------------------------
//
//
//  Description:
//      Iterator function used to walk the DMT and generate the perf counters
//      we are interested in.
//  Parameters:
//          IN  pvContext   - pointer to context (current total of pending msgs)
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      7/29/98 - MikeSwa Created
//      7/31/98 - MikeSwa Modified (Added link state counters)
//      9/22/98 - MikeSwa Changed from domain flags to link flags
//
//  Note:
//      Currently the status is stored on the domain entry (and not the link).
//      At some point we will have to differentiate this, and add flags to
//      the link.  In this funciton the cLinkCount variable is a temporary
//      workaround.
//-----------------------------------------------------------------------------
VOID CalcDMTPerfCountersIteratorFn(PVOID pvContext, PVOID pvData,
                                    BOOL fWildcard, BOOL *pfContinue,
                                    BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pvData, "CalcMsgsPendingRetryIteratorFn");
    CDomainEntry   *pdentry = (CDomainEntry *) pvData;
    AQPerfCounters *pAQPerfCounters = (AQPerfCounters *) pvContext;
    CLinkMsgQueue  *plmq = NULL;
    CDomainEntryLinkIterator delit;
    DWORD           cRetryMsgsOnCurrentLink = 0;
    DWORD           dwLinkStateFlags = 0;
    HRESULT         hr = S_OK;
    BOOL            fLinkEnabled = TRUE;

    _ASSERT(pvContext);
    _ASSERT(pvData);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(sizeof(AQPerfCounters) == pAQPerfCounters->cbVersion);


    //Always continue, and never delete
    *pfContinue = TRUE;
    *pfDelete = FALSE;

    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
        goto Exit;

    while (plmq = delit.plmqGetNextLinkMsgQueue(plmq))
    {
        dwLinkStateFlags = plmq->dwGetLinkState();
        fLinkEnabled = TRUE;

        // msgs on the retry queue should be added to remote retry queue counter
        cRetryMsgsOnCurrentLink = plmq->cGetRetryMsgCount();
        if (!(LINK_STATE_RETRY_ENABLED & dwLinkStateFlags))
        {
            //Link is pending retry
            fLinkEnabled = FALSE;
            
            // also add #of msgs NOT on retry queue
            cRetryMsgsOnCurrentLink += plmq->cGetTotalMsgCount();
        }

        pAQPerfCounters->cCurrentMsgsPendingRemoteRetry += cRetryMsgsOnCurrentLink;

        if (!(LINK_STATE_SCHED_ENABLED & dwLinkStateFlags))
        {
            //Link is pending a scheduled connection
            fLinkEnabled = FALSE;
            pAQPerfCounters->cCurrentRemoteNextHopLinksPendingScheduling++;
        }

        if (LINK_STATE_PRIV_CONFIG_TURN_ETRN & dwLinkStateFlags)
        {
            //Link is a TURN/ETRN link
            if (!((LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_PRIV_TURN_ENABLED)
                  & dwLinkStateFlags))
                fLinkEnabled = FALSE; //link is not currently being serviced

            pAQPerfCounters->cCurrentRemoteNextHopLinksPendingTURNETRN++;
        }

        if (LINK_STATE_ADMIN_HALT & dwLinkStateFlags)
        {
            //Link is currently frozen by admin
            fLinkEnabled = FALSE;
            pAQPerfCounters->cCurrentRemoteNextHopLinksFrozenByAdmin++;
        }

        if (fLinkEnabled)
        {
            //There are no flags set that indicate this link is not enabled
            pAQPerfCounters->cCurrentRemoteNextHopLinksEnabled++;
        }

    }

  Exit:
    if (plmq)
        plmq->Release();

    TraceFunctLeave();
}


//---[ dwInterlockedSetBits ]--------------------------------------------------
//
//
//  Description:
//      Set bits in a DWORD in a thread sate manner
//  Parameters:
//      IN  pdwTarget   Ptr to DWORD to modify
//      IN  dwFlagMask  bits to set
//  Returns:
//      Original value
//  History:
//      8/3/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD dwInterlockedSetBits(DWORD *pdwTarget, DWORD dwFlagMask)
{
    DWORD dwChk;
    DWORD dwTmp;

    _ASSERT(pdwTarget);
    do
    {
        dwChk = *pdwTarget;
        dwTmp = dwChk | dwFlagMask;
        if (dwChk == dwTmp) //no work to be done
            break;
    } while (InterlockedCompareExchange((PLONG) pdwTarget,
                                        (LONG) dwTmp,
                                        (LONG) dwChk) != (LONG) dwChk);

    return dwChk;
}

//---[ dwInterlockedUnsetBits ]------------------------------------------------
//
//
//  Description:
//      Unset bits in a DWORD in a thread sate manner
//  Parameters:
//      IN  pdwTarget   Ptr to DWORD to modify
//      IN  dwFlagMask  bits to unset
//  Returns:
//      Original value
//  History:
//      8/3/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD dwInterlockedUnsetBits(DWORD *pdwTarget, DWORD dwFlagMask)
{
    DWORD dwChk;
    DWORD dwTmp;

    _ASSERT(pdwTarget);
    do
    {
        dwChk = *pdwTarget;
        dwTmp = dwChk & ~dwFlagMask;
        if (dwChk == dwTmp) //no work to be done
            break;
    } while (InterlockedCompareExchange((PLONG) pdwTarget,
                                        (LONG) dwTmp,
                                        (LONG) dwChk) != (LONG) dwChk);

    return dwChk;
}

//---[ HrWalkPreLocalQueueForDSN ]---------------------------------------------
//
//
//  Description:
//      Function to walk the pre-local delivery queue for DSN generation
//  Parameters:
//      IN  CMsgRef pmsgref     ptr to data on queue
//      IN  PVOID pvContext     ptr to CAQSvrInst
//      OUT BOOL *pfContinue    TRUE if we should continue
//      OUT BOOL *pfDelete      TRUE if item should be deleted
//  Returns:
//      S_OK on success
//  History:
//      8/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrWalkPreLocalQueueForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext,
                           OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "HrWalkPreLocalQueueForDSN");
    HRESULT hr = S_OK;
    DWORD   dwDSNFlags = 0;
    CLinkMsgQueue *plmq = NULL;
    BOOL    fShutdownLock = FALSE;
    CAQStats aqstats;
    CAQSvrInst *paqinst = (CAQSvrInst *)pvContext;

    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(paqinst);

    *pfContinue = TRUE; //always keep walking queue
    *pfDelete = FALSE;  //keep message in queue unless we NDR it

    if (!paqinst)
        goto Exit;

    if (!paqinst->fTryShutdownLock())
    {
        //If we got a shutdown hint...we should bail
        *pfContinue = FALSE;
        goto Exit;
    }
    fShutdownLock = TRUE;

    hr = pmsgref->HrSendDelayOrNDR(CMsgRef::MSGREF_DSN_LOCAL_QUEUE |
                                   CMsgRef::MSGREF_DSN_SEND_DELAY,
                                   NULL, AQUEUE_E_MSG_EXPIRED, &dwDSNFlags);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pmsgref, "ERROR: HrSendDelayOrNDR failed - hr 0x%08X", hr);
        goto Exit;
    }

    //We need to remove this message from the queue
    if ((CMsgRef::MSGREF_DSN_SENT_NDR | CMsgRef::MSGREF_HANDLED) & dwDSNFlags)
    {
        *pfDelete = TRUE;

        //Update relevant counters
        paqinst->DecPendingLocal();

        //
        //  Get local link and update stats
        //
        plmq = paqinst->pdmtGetDMT()->plmqGetLocalLink();

        if (plmq) 
        {
            pmsgref->GetStatsForMsg(&aqstats);
            plmq->HrNotify(&aqstats, FALSE);
        }    
    }

  Exit:
    if (fShutdownLock)
        paqinst->ShutdownUnlock();

    if (plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;
}


//---[ HrReGetMessageType ]-----------------------------------------------------
//
//
//  Description:
//      Regets the message type after a retry failure
//  Parameters:
//      IN     pIMailMsgProperties      Message we are interested in
//      IN     pIMessageRouter          Router for that message
//      IN OUT pdwMessageType           Old/New message type for the message
//  Returns:
//      S_OK on success
//      Passes through errors from ReleaseMessageType & GetMessageType
//  History:
//      9/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrReGetMessageType(IN     IMailMsgProperties *pIMailMsgProperties,
                           IN     IMessageRouter *pIMessageRouter,
                           IN OUT DWORD *pdwMessageType)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrReGetMessageType");
    HRESULT hr = S_OK;

    //$$REVIEW - we might not have to get a new message type here... we
    //might only need it on a specific error code returned by HrInitialize.
    //Get New Messagetype... in case that changed
    hr = pIMessageRouter->ReleaseMessageType(*pdwMessageType, 1);
    if (FAILED(hr))
    {
        _ASSERT(SUCCEEDED(hr) && "ReleaseMessageType failed... may leak message types");
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "ERROR: ReleaseMessageType failed! - hr 0x%08X", hr);
        hr = S_OK; //we are about to retry anyway
    }

    hr = pIMessageRouter->GetMessageType(pIMailMsgProperties, pdwMessageType);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "ERROR: Unable to re-get message type - HR 0x%08X", hr);
        goto Exit; //we cannot recover from this
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//Used to guarantee uniqueue files names
DWORD g_cUniqueueFileNames = 0;

//---[ GetUniqueFileName ]-----------------------------------------------------
//
//
//  Description:
//      Creates a uniqueue file name
//  Parameters:
//      pft             Ptr to current filetime
//      szFileBuffer    Buffer to put string into... should be
//                      at least UNIQUEUE_FILENAME_BUFFER_SIZE
//      szExtension     Extension for file name... if longer than three chars,
//                      you will need to increase the size of szFileBuffer
//                      accordingly.
//  Returns:
//      -
//  History:
//      10/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void GetUniqueFileName(IN FILETIME *pft, IN LPSTR szFileBuffer,
                       IN LPSTR szExtension)
{
     DWORD cbFileNameSize = 0;
     DWORD cUnique = InterlockedIncrement((PLONG) &g_cUniqueueFileNames);
     SYSTEMTIME systime;

     _ASSERT(szFileBuffer);
     _ASSERT(szExtension);

     FileTimeToSystemTime(pft, &systime);

     cbFileNameSize = wsprintf(
            szFileBuffer,
            "%05.5x%02.2d%02.2d%02.2d%02.2d%02.2d%04.4d%08X.%s",
            systime.wMilliseconds,
            systime.wSecond, systime.wMinute, systime.wHour,
            systime.wDay, systime.wMonth, systime.wYear,
            cUnique, szExtension);

     //Assert that are constant is big enough
     //By default... allow room for ".eml" extension
     _ASSERT((cbFileNameSize + 4 - lstrlen(szExtension)) < UNIQUEUE_FILENAME_BUFFER_SIZE);
}



//---[ HrLinkAllDomains ]-------------------------------------------------------
//
//
//  Description:
//      Ultility function to link all domains together  for recipient enumeration
//      (primarly used to NDR an entire message).
//
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to link domains together for
//  Returns:
//      S_OK on success
//  History:
//      10/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrLinkAllDomains(IN IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrLinkAllDomains");
    HRESULT hr = S_OK;
    DWORD cDomains = 0;
    DWORD iCurrentDomain = 1;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;

    _ASSERT(pIMailMsgProperties);

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients,
                                            (void **) &pIMailMsgRecipients);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgRecipients failed");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgRecipients->DomainCount(&cDomains);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: Unable to get DomainCount - hr 0x%08X", hr);
        goto Exit;
    }

    //Set up domain list for all domains
    for (iCurrentDomain = 1; iCurrentDomain < cDomains; iCurrentDomain++)
    {
        hr = pIMailMsgRecipients->SetNextDomain(iCurrentDomain-1, iCurrentDomain,
                                FLAG_OVERWRITE_EXISTING_LINKS);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: SetNextDomain Failed - hr 0x%08X", hr);
            goto Exit;
        }
    }

    //handle single domain case
    if (1 == cDomains)
    {
        hr = pIMailMsgRecipients->SetNextDomain(0, 0, FLAG_SET_FIRST_DOMAIN);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: SetNextDomain Failed for single domain- hr 0x%08X", hr);
            goto Exit;
        }
    }

  Exit:

    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    TraceFunctLeave();
    return hr;
}


//Parses a GUID from a string... returns TRUE on success
//---[ fAQParseGuidString ]----------------------------------------------------
//
//
//  Description:
//      Attempts to parse a GUID from a string of hex digits..
//      Can handle punctuation, spaces and even leading "0x"'s.
//  Parameters:
//      IN  szGuid  String to parse GUID from
//      IN  cbGuid  Max size of GUID string buffer
//      OUT guidID  GUID parsed from string
//  Returns:
//      TRUE if a guid value could be parsed from the string
//      FALSE if a guid value could not be parsed from the string
//  History:
//      10/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fAQParseGuidString(LPSTR szGuid, DWORD cbGuid, GUID *pguid)
{
    const   DWORD NO_SUCH_VALUE = 0xFF;
    BOOL    fParsed = FALSE;
    BOOL    fLastCharZero = FALSE; //Used to handle "0x"
    DWORD   *pdwGuid = (DWORD *) pguid;
    DWORD   cDigits = 0;
    DWORD   dwValue = NO_SUCH_VALUE;
    LPSTR   szCurrent = szGuid;
    LPSTR   szStop = szGuid + cbGuid/sizeof(CHAR);

    //Use DWORD array to populate GUID
    *pdwGuid = 0;
    while ((szStop > szCurrent) && (*szCurrent))
    {
        dwValue = NO_SUCH_VALUE;
        if (('0' <= *szCurrent) && ('9' >= *szCurrent))
            dwValue = *szCurrent-'0';
        else if (('a' <= *szCurrent) && ('f' >= *szCurrent))
            dwValue = 10 + *szCurrent-'a';
        else if (('A' <= *szCurrent) && ('F' >= *szCurrent))
            dwValue = 10 + *szCurrent-'A';
        else if (fLastCharZero &&
                 (('x' == *szCurrent) || ('X' == *szCurrent)))
        {
            //back out last shift (we don't have to subtract anything, since
            //the value was zero).
            _ASSERT(cDigits);
            if (0 == (cDigits % 8)) //happened when we changed DWORDs
                pdwGuid--;
            else
                *pdwGuid /= 16;  //undo last shift
            cDigits--;
        }

        //Set flag for handling 0x sequence
        if (0 != dwValue)
            fLastCharZero = FALSE;
        else
            fLastCharZero = TRUE;

        //In all string guid representations... a valid hex number is at least
        //2 characters long... so 0x0 should be mapped to 0x00 and 0xa should
        //be mapped to 0x0a.  Check and see if such a situation is happening
        if ((NO_SUCH_VALUE == dwValue) && (0 != (cDigits % 2)) &&
            (',' == *szCurrent))
        {
            //undo last add and shift.  The next if clause will re-write
            //the last value in at the proper point
            *pdwGuid /= 16;
            dwValue = *pdwGuid & 0x0000000F;
            *pdwGuid &= 0xFFFFFFF0;
            *pdwGuid *= 16;
        }

        //Add value to GUID if hex character
        if (NO_SUCH_VALUE != dwValue)
        {
            *pdwGuid += dwValue;
            if (0 == (++cDigits % 8))
            {
                //We have reached a DWORD boundary... move on
                if (32 == cDigits)
                {
                    //quit when we have enough
                    fParsed = TRUE;
                    break;
                }
                pdwGuid++;
                *pdwGuid = 0;
            }
            else
                *pdwGuid *= 16;
        }
        szCurrent++;
    }

    //Handle ending 0xa (should be 0x0a) digits
    if (!fParsed && (31 == cDigits))
    {
        dwValue = *pdwGuid & 0x000000FF;
        _ASSERT(!(dwValue & 0x0000000F));
        *pdwGuid &= 0xFFFFFF00;
        dwValue /= 16;
        *pdwGuid += dwValue;
        fParsed = TRUE;
    }

    return fParsed;
}


//---[ InterlockedAddSubtractULARGE ]------------------------------------------
//
//
//  Description:
//      Performs "interlocked" Add/Subtract on ULARGE_INTEGER structures.
//
//      Uses s_slUtilityData to synchronize if neccessary.
//  Parameters:
//      IN      puliValue       ULARGE to modify
//      IN      puliNew         ULARGE to modify value with
//      IN      fAdd            TRUE if we are adding new value
//                              FALSE if we are subtracting
//  Returns:
//      -
//  History:
//      11/2/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------

void InterlockedAddSubtractULARGE(ULARGE_INTEGER *puliValue,
                                  ULARGE_INTEGER *puliNew, BOOL fAdd)
{
    _ASSERT(puliValue);
    _ASSERT(puliNew);
    ULARGE_INTEGER uliTmp = {0};
    BOOL    fDone = FALSE;
    DWORD   dwTmp = 0;
    DWORD   dwHighPart = 0;
    DWORD   dwLowPart = 0;
    static  CShareLockNH s_slUtilityData; //Used to synchronize global updates of ULONG

    s_slUtilityData.ShareLock();
    BOOL    fShareLock = TRUE; //FALSE implies Exclusive lock

    while (!fDone)
    {
        uliTmp.QuadPart = puliValue->QuadPart;
        dwHighPart = uliTmp.HighPart;
        dwLowPart = uliTmp.LowPart;

        if (fAdd)
            uliTmp.QuadPart += puliNew->QuadPart; //add volume
        else
            uliTmp.QuadPart -= puliNew->QuadPart;

        //First see of the high part needs updating
        if (dwHighPart != uliTmp.HighPart)
        {
            if (fShareLock)
            {
                //This only happens every 4GB of data per queue..
                //which means we shouldn't be hitting this lock that
                //often
                s_slUtilityData.ShareUnlock();
                s_slUtilityData.ExclusiveLock();
                fShareLock = FALSE;

                //Go back to top of loop and re-get data
                continue;
            }

            //At this point it is just safe for us to update the values
            puliValue->QuadPart = uliTmp.QuadPart;
        }
        else if (dwLowPart != uliTmp.LowPart)
        {
            //Only need to update the low DWORD
            dwTmp = (DWORD) InterlockedCompareExchange(
                                            (PLONG) &(puliValue->LowPart),
                                            (LONG) uliTmp.LowPart,
                                            (LONG) dwLowPart);
            if (dwLowPart != dwTmp)
                continue;  //update failed
        }

        fDone = TRUE;
    }

    if (fShareLock)
        s_slUtilityData.ShareUnlock();
    else
        s_slUtilityData.ExclusiveUnlock();

}

//---[ HrValidateMessageContent ]----------------------------------------------
//
//
//  Description:
//      Validates a message based on its content handle.  If the backing store
//      has been deleted, and the handle is not cached, we should detect this.
//  Parameters:
//      pIMailMsgProperties             - MailMsg to validate
//  Returns:
//      HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) Message belongs to this store
//          driver but is no longer valid
//      other error code from store driver interface or mailmsg
//  History:
//      4/13/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrValidateMessageContent(IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrValidateMessageContent");
    IMailMsgBind   *pBindInterface = NULL;
    PFIO_CONTEXT    pIMsgFileHandle = NULL;
    HRESULT hr = S_OK;

    //
    //  Attempt to query interface for the binding interface
    //
    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgBind,
                                            (void **)&pBindInterface);
    if (FAILED(hr) || !pBindInterface)
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to QI for IID_IMailMsgBind - hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Request the PFIO_CONTEXT for this message
    //
    hr = pBindInterface->GetBinding(&pIMsgFileHandle, NULL);
    DebugTrace((LPARAM) pIMailMsgProperties,
            "GetBinding return hr - 0x%08X", hr);

  Exit:

    if (pBindInterface)
    {
        pBindInterface->ReleaseContext();
        pBindInterface->Release();
    }

    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqutil.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqutil.h
//
//  Description:
//      General AQueue utility functions... like IMailMsg Usage Count
//      manipulation, queue mapping functions, and domain name table iterator
//      functions.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/20/98 - MikeSwa Created
//      7/29/98 - MikeSwa Modified (added CalcMsgsPendingRetryIteratorFn)
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQUTIL_H__
#define __AQUTIL_H__
#include "aqincs.h"
#include "msgref.h"
#include "refstr.h"

//Functions to manipulate IMailMsg usage count
HRESULT HrIncrementIMailMsgUsageCount(IUnknown *pIUnknown);
HRESULT HrReleaseIMailMsgUsageCount(IUnknown *pIUnknown);
HRESULT HrDeleteIMailMsg(IUnknown *pIUnknown); //deletes and releases usage count

HRESULT HrWalkMailMsgQueueForShutdown(IN IMailMsgProperties *pIMailMsgProperties,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete);

BOOL    fMailMsgShutdownCompletion(PVOID pvContext, DWORD dwStatus);

HRESULT HrWalkMsgRefQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete);

BOOL    fMsgRefShutdownCompletion(PVOID pvContext, DWORD dwStatus);

//Domain Name Table iterator function used to count perf counters
VOID CalcDMTPerfCountersIteratorFn(PVOID pvContext, PVOID pvData,
                                         BOOL fWildcard, BOOL *pfContinue,
                                         BOOL *pfDelete);


//Functions to manipulate DWORD's bits in a thread safe manner
DWORD dwInterlockedSetBits(DWORD *pdwTarget, DWORD dwFlagMask);
DWORD dwInterlockedUnsetBits(DWORD *pdwTarget, DWORD dwFlagMask);

HRESULT HrWalkPreLocalQueueForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext,
                           OUT BOOL *pfContinue, OUT BOOL *pfDelete);

//Used to reget the message type in various retry situations
HRESULT HrReGetMessageType(IN     IMailMsgProperties *pIMailMsgProperties,
                           IN     IMessageRouter *pIMessageRouter,
                           IN OUT DWORD *pdwMessageType);

#define UNIQUEUE_FILENAME_BUFFER_SIZE 35

//Creates a unique filename
void GetUniqueFileName(IN FILETIME *pft, IN LPSTR szFileBuffer, IN LPSTR szExtension);


//Ultility function to link all domains together (primarly to NDR an entire message)
HRESULT HrLinkAllDomains(IN IMailMsgProperties *pIMailMsgProperties);

//Parses a GUID from a string... returns TRUE on success
BOOL fAQParseGuidString(LPSTR szGuid, DWORD cbGuid, GUID *pguid);


inline DWORD dwInterlockedAddSubtractDWORD(DWORD *pdwValue,
                                        DWORD dwNew, BOOL fAdd)
{
    return InterlockedExchangeAdd((PLONG) pdwValue,
                            fAdd ? ((LONG) dwNew) : (-1 * ((LONG) dwNew)));
};

void InterlockedAddSubtractULARGE(ULARGE_INTEGER *puliValue,
                                  ULARGE_INTEGER *puliNew, BOOL fAdd);


//Functions to do simple spin lock manipulations
inline BOOL fTrySpinLock(DWORD *pdwLock, DWORD dwLockBit)
{
    return (!(dwLockBit & dwInterlockedSetBits(pdwLock, dwLockBit)));
}

inline void ReleaseSpinLock(DWORD *pdwLock, DWORD dwLockBit)
{
    _ASSERT(*pdwLock & dwLockBit);
    dwInterlockedUnsetBits(pdwLock, dwLockBit);
}

//
//  Same as above but checks content handle.  We force a rendering of the
//  message
//
HRESULT HrValidateMessageContent(IMailMsgProperties *pIMailMsgProperties);

#endif //__AQUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqueue.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File:
//      aqueue.cpp
//  Description:
//      Implementation of DLL Exports.
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"

#ifndef PLATINUM
#include "initguid.h"
#include <iadmw.h>
#endif //PLATINUM

#include "aqueue_i.c"
#include "aqintrnl_i.c"
#include "SMTPConn.h"
#include "qwiklist.h"
#include "fifoqimp.h"
#include <irtlmisc.h>
#include <iiscnfg.h>
#include <wrapmb.h>
#include <smtpinet.h>

#include <cat.h>
#include <aqinit.h>
#include "aqrpcsvr.h"

//Global vars used for shutdown
DWORD g_cInstances = 0;
CShareLockNH g_slInit;  //lock used for thread-safe initialization

//Global vars used for Dll init/shutdown (including Cat COM stuff)
LONG  g_cDllInit = 0;
BOOL  g_fInit = FALSE;
CShareLockNH g_slDllInit;
BOOL  g_fForceDllCanUnloadNowFailure = FALSE;

#define CALL_SERVICE_STATUS_CALLBACK \
    pServiceStatusFn ? pServiceStatusFn(pvServiceContext) : 0

// SEO crap needed for aqdisp
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL
CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()
#include <pudebug.h>
DEBUG_PRINTS *g_pDebug = NULL;


//---[ HrAdvQueueInitializeEx ]-------------------------------------------------
//
//
//  Description:
//      Aqueue.dll initialization function that provides in params for user name,
//      domain, password, and service control callback functions.
//  Parameters:
//      IN  pISMTPServer         ptr to local delivery function / object
//      IN  dwServerInstance     virtual server instance
//      IN  szUserName           User name to log on DS with
//      IN  szDomainName         Domain name to log on to DS with
//      IN  szPassword           Password to authenticate to DS with
//      IN  pServiceStatusFn     Server status callback function
//      IN  pvServiceContext     Context to pass back for callback function
//      OUT ppIAdvQueue          returned IAdvQueue ptr
//      OUT ppIConnectionManager returned IConnectionManager ptr
//      OUT ppIAdvQueueConfig    returned IAdvQueueConfig ptr
//      OUT ppvContext           Virtual server context
//  Returns:
//
//
//-----------------------------------------------------------------------------
HRESULT HrAdvQueueInitializeEx(
                    IN  ISMTPServer *pISMTPServer,
                    IN  DWORD   dwServerInstance,
                    IN  LPSTR   szUserName,
                    IN  LPSTR   szDomainName,
                    IN  LPSTR   szPassword,
                    IN  PSRVFN  pServiceStatusFn,
                    IN  PVOID   pvServiceContext,
                    OUT IAdvQueue **ppIAdvQueue,
                    OUT IConnectionManager **ppIConnectionManager,
                    OUT IAdvQueueConfig **ppIAdvQueueConfig,
                    OUT PVOID *ppvContext)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrAdvQueueInitialize");
    HRESULT hr = S_OK;
    CAQSvrInst *paqinst = NULL;
    CDomainMappingTable *pdmt = NULL;
    BOOL    fLocked = FALSE;
    BOOL    fInstanceCounted = FALSE;

#ifdef PLATINUM
    BOOL    fIisRtlInit = FALSE;
    BOOL    fATQInit = FALSE;
#endif

    BOOL    fAQDllInit = FALSE;
    BOOL    fExchmemInit = FALSE;
    BOOL    fCPoolInit = FALSE;
    BOOL    fRpcInit = FALSE;
    BOOL    fDSNInit = FALSE;

    CALL_SERVICE_STATUS_CALLBACK;
    g_slInit.ExclusiveLock();
    fLocked = TRUE;

    if ((NULL == ppIAdvQueue) ||
        (NULL == ppIConnectionManager) ||
        (NULL == ppvContext) ||
        (NULL == ppIAdvQueueConfig))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppvContext = NULL;

    //
    //  Update global config information.
    //
    ReadGlobalRegistryConfiguration();

    if (1 == InterlockedIncrement((PLONG) &g_cInstances))
    {
        fInstanceCounted = TRUE;
        CALL_SERVICE_STATUS_CALLBACK;

#ifdef PLATINUM
        //Initialize IISRTL
        if (!InitializeIISRTL())
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM) NULL, "ERROR: LISRTL Init failed with 0x%08X", hr);
            if (SUCCEEDED(hr))
                hr = E_FAIL;
            goto Exit;
        }
        fIisRtlInit = TRUE;

        //Initialize ATQ
        if (!AtqInitialize(0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM) NULL, "ERROR: ATQ Init failed with 0x%08X", hr);
            if (SUCCEEDED(hr))
                hr = E_FAIL;
            goto Exit;
        }
        fATQInit = TRUE;
#endif

        hr = HrDllInitialize();
        if (FAILED(hr))
        {
            goto Exit;
        }
        fAQDllInit = TRUE;

        //create CPool objects
        if (!CQuickList::s_QuickListPool.ReserveMemory(10000, sizeof(CQuickList)))
            hr = E_OUTOFMEMORY;

        if (!CSMTPConn::s_SMTPConnPool.ReserveMemory(g_cMaxConnections, sizeof(CSMTPConn)))
            hr = E_OUTOFMEMORY;

        if (!CMsgRef::s_MsgRefPool.ReserveMemory(g_cMaxMsgObjects, MSGREF_STANDARD_CPOOL_SIZE))
            hr = E_OUTOFMEMORY;

        if (!CAQMsgGuidListEntry::s_MsgGuidListEntryPool.ReserveMemory(500, sizeof(CAQMsgGuidListEntry)))
            hr = E_OUTOFMEMORY;

        if (!CAsyncWorkQueueItem::s_CAsyncWorkQueueItemPool.ReserveMemory(20000, sizeof(CAsyncWorkQueueItemAllocatorBlock)))
            hr = E_OUTOFMEMORY;

        if (!CAddr::Pool.ReserveMemory(1000, sizeof(CAddr)))
            hr = E_OUTOFMEMORY;

        if (!CAQSvrInst::CAQLocalDeliveryNotify::s_pool.ReserveMemory(g_cMaxPendingLocal, sizeof(CAQSvrInst::CAQLocalDeliveryNotify)))
            hr = E_OUTOFMEMORY;

        if (!CBlockMemoryAccess::m_Pool.ReserveMemory(2000, sizeof(BLOCK_HEAP_NODE)))
            hr = E_OUTOFMEMORY;

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL, "Error unable to initialize CPOOL");
            goto Exit;
        }

        fCPoolInit = TRUE;

        hr = CDSNGenerator::HrStaticInit();
        if(FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL, "CDSNGenerator::StaticInif failed hr %08lx", hr);
            goto Exit;
        }
        fDSNInit = TRUE;

        //Initialize Queue Admin RPC interface
        hr = CAQRpcSvrInst::HrInitializeAQRpc();
        if (FAILED(hr))
            goto Exit;

        fRpcInit = TRUE;

    }

    if (!g_pslGlobals)
    {
        g_pslGlobals = new CShareLockNH();
        if (NULL == g_pslGlobals) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    CALL_SERVICE_STATUS_CALLBACK;
    g_slInit.ExclusiveUnlock();
    fLocked = FALSE;

    CFifoQueue<CLinkMsgQueue *>::StaticInit();
    CFifoQueue<CMsgRef *>::StaticInit();
    CFifoQueue<IMailMsgProperties *>::StaticInit();
    CFifoQueue<CAsyncWorkQueueItem *>::StaticInit();

    //Create requested objects
    CALL_SERVICE_STATUS_CALLBACK;
    paqinst = new CAQSvrInst(dwServerInstance, pISMTPServer);
    if (NULL == paqinst)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    CALL_SERVICE_STATUS_CALLBACK;
    hr = paqinst->HrInitialize(szUserName, szDomainName, szPassword,
                            pServiceStatusFn,
                            pvServiceContext);
    if (FAILED(hr))
        goto Exit;

    //Create Connection Manager
    CALL_SERVICE_STATUS_CALLBACK;
    hr = paqinst->HrGetIConnectionManager(ppIConnectionManager);

    //Set Return values
    *ppIAdvQueue = (IAdvQueue *) paqinst;  //Already addref'd at creation
    *ppIAdvQueueConfig = (IAdvQueueConfig *) paqinst;
    (*ppIAdvQueueConfig)->AddRef();

  Exit:
    if (FAILED(hr))
    {
        //Make sure that we clean up everything here
        if (NULL != paqinst)
            paqinst->Release();

        //If initialization failed... we should not count an
        //instance as started
        if (fInstanceCounted)
            InterlockedDecrement((PLONG) &g_cInstances);

#ifdef PLATINUM
        if (fATQInit)
            AtqTerminate();

        if (fIisRtlInit)
            TerminateIISRTL();
#endif

        if (fAQDllInit)
            DllDeinitialize();

        if (fCPoolInit)
        {
            //Release CPool objects
            CAQSvrInst::CAQLocalDeliveryNotify::s_pool.ReleaseMemory();
            CAddr::Pool.ReleaseMemory();
            CQuickList::s_QuickListPool.ReleaseMemory();
            CSMTPConn::s_SMTPConnPool.ReleaseMemory();
            CMsgRef::s_MsgRefPool.ReleaseMemory();
            CAQMsgGuidListEntry::s_MsgGuidListEntryPool.ReleaseMemory();
            CAsyncWorkQueueItem::s_CAsyncWorkQueueItemPool.ReleaseMemory();
            CBlockMemoryAccess::m_Pool.ReleaseMemory();
        }

        if (fDSNInit)
            CDSNGenerator::StaticDeinit();

        if (fRpcInit)
            CAQRpcSvrInst::HrDeinitializeAQRpc();
    }
    else
    {
        *ppvContext = (PVOID) paqinst;
        paqinst->AddRef();
    }

    if (fLocked)
        g_slInit.ExclusiveUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ HrAdvQueueInitialize ]---------------------------------------------------
//
//
//  Description:
//      Performs DLL-wide initialization
//
//  Parameters:
//      IN  pISMTPServer         ptr to local delivery function / object
//      IN  dwServerInstance     virtual server instance
//      OUT ppIAdvQueue          returned IAdvQueue ptr
//      OUT ppIConnectionManager returned IConnectionManager ptr
//      OUT ppIAdvQueueConfig    returned IAdvQueueConfig ptr
//      OUT ppvContext           Virtual server context
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT HrAdvQueueInitialize(
                    IN  ISMTPServer *pISMTPServer,
                    IN  DWORD   dwServerInstance,
                    OUT IAdvQueue **ppIAdvQueue,
                    OUT IConnectionManager **ppIConnectionManager,
                    OUT IAdvQueueConfig **ppIAdvQueueConfig,
                    OUT PVOID *ppvContext)
{
    HRESULT hr = S_OK;

    hr =  HrAdvQueueInitializeEx(pISMTPServer, dwServerInstance,
                NULL, NULL, NULL, NULL, NULL, ppIAdvQueue,
                ppIConnectionManager, ppIAdvQueueConfig, ppvContext);
    return hr;
}

//---[ HrAdvQueueDeinitializeEx ]------------------------------------------------
//
//
//  Description:
//      Performs DLL-wide Cleanup.
//
//      Adds callback to service control manager.
//
//      This MUST not be called until all DLL objects have been released.
//
//      NOTE: There are several objects that are exported outside this DLL.
//      The following are directly exported & should be released before the
//      the Heap and CPool allocations are freed
//          IAdvQueue
//          IConnectionManager
//          ISMTPConnection
//      The Message Context also contains several references to internal objects,
//      but does not need to be explicitly released (since these objects can only
//      be accessed though the AckMessage() call).
//  Parameters:
//      PVOID   pvContext       Context that was returned by initialization
//                              function
//      IN  pServiceStatusFn     Server status callback function
//      IN  pvServiceContext     Context to pass back for callback function
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT HrAdvQueueDeinitializeEx(IN PVOID pvContext,
                               IN  PSRVFN  pServiceStatusFn,
                               IN  PVOID   pvServiceContext)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrAdvQueueDeinitialize");
    HRESULT hr = S_OK;
    HRESULT hrCurrent = S_OK;
    DWORD   cRefs;
    DWORD   dwWaitResult = WAIT_OBJECT_0;
    bool    fDestroyHeap = true;
    DWORD   dwShutdownTimeout = 0;  //time to wait for shutdown
    CAQSvrInst *paqinst;
    g_fForceDllCanUnloadNowFailure = TRUE;
    g_slInit.ExclusiveLock();

    if (NULL != pvContext)
    {
        paqinst = (CAQSvrInst *) pvContext;
        hr = paqinst->HrDeinitialize();

        cRefs = paqinst->Release();
        DebugTrace((LPARAM) NULL, "There are %d refs remaining on the CMQ", cRefs);
        if (0 != cRefs)
        {
            _ASSERT(0 && "Someone has outstanding references to IAdvQueue or IAdvQueuConfig");
            fDestroyHeap = false;
        }
    }

    CFifoQueue<CLinkMsgQueue *>::StaticDeinit();
    CFifoQueue<CMsgRef *>::StaticDeinit();
    CFifoQueue<IMailMsgProperties *>::StaticDeinit();
    CFifoQueue<CAsyncWorkQueueItem *>::StaticDeinit();

    if (0 == InterlockedDecrement((PLONG) &g_cInstances))
    {
#ifdef PLATINUM
        AtqTerminate();
#endif

        if (fDestroyHeap)
        {
            delete g_pslGlobals;
            g_pslGlobals = NULL;

            DllDeinitialize();

            //Release CPool objects
            CAQSvrInst::CAQLocalDeliveryNotify::s_pool.ReleaseMemory();
            CAddr::Pool.ReleaseMemory();
            CQuickList::s_QuickListPool.ReleaseMemory();
            CSMTPConn::s_SMTPConnPool.ReleaseMemory();
            CMsgRef::s_MsgRefPool.ReleaseMemory();
            CAQMsgGuidListEntry::s_MsgGuidListEntryPool.ReleaseMemory();
            CAsyncWorkQueueItem::s_CAsyncWorkQueueItemPool.ReleaseMemory();
            CBlockMemoryAccess::m_Pool.ReleaseMemory();
        }
        //
        // Deinit DSN Generator
        //
        CDSNGenerator::StaticDeinit();

        //Deinitialize Queue Admin RPC interface
        hr = CAQRpcSvrInst::HrDeinitializeAQRpc();

#ifdef PLATINUM
        TerminateIISRTL();
#endif

        //Force mailmsg and other COM DLLs to go buh-bye
        CoFreeUnusedLibraries();
    }

    g_slInit.ExclusiveUnlock();
    TraceFunctLeave();
    g_fForceDllCanUnloadNowFailure = FALSE;
    return hr;
}

//---[ HrAdvQueueDeinitialize ]------------------------------------------------
//
//
//  Description:
//      Performs DLL-wide Cleanup.
//
//      This MUST not be called until all DLL objects have been released.
//
//      NOTE: There are several objects that are exported outside this DLL.
//      The following are directly exported & should be released before the
//      the Heap and CPool allocations are freed
//          IAdvQueue
//          IConnectionManager
//          ISMTPConnection
//      The Message Context also contains several references to internal objects,
//      but does not need to be explicitly released (since these objects can only
//      be accessed though the AckMessage() call).
//  Parameters:
//      PVOID   pvContext       Context that was returned by initialization
//                              function
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT HrAdvQueueDeinitialize(PVOID pvContext)
{
    return HrAdvQueueDeinitializeEx(pvContext, NULL, NULL);
}

//---[ HrRegisterAdvQueueDll ]-------------------------------------------------
//
//
//  Description:
//      Sets metabase path of for advanced queuing DLL to this DLL.
//  Parameters:
//      hAQInstance - Handle passed into DLL main
//  Returns:
//      S_OK on success
//      E_INVALIDARG if hAQInstance is NULL.
//      Error codes from accessed metabase
//  History:
//      7/30/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrRegisterAdvQueueDll(HMODULE hAQInstance)
{
    HRESULT hr = S_OK;
    WCHAR   wszModule[512] = L"";
    METADATA_HANDLE     hMDRootVS = NULL;
    METADATA_RECORD     mdrData;
    DWORD   dwErr = NO_ERROR;
    DWORD   cbModule = 0;
    IMSAdminBase *pMSAdmin = NULL;

    ZeroMemory(&mdrData, sizeof(METADATA_RECORD));

    CoInitialize(NULL);
    InitAsyncTrace();
    TraceFunctEnterEx((LPARAM) NULL, "HrRegisterAdvQueueDll");

    if (!hAQInstance)
    {
        hr = E_INVALIDARG;
        ErrorTrace((LPARAM) NULL, "DLL Main did not save instance");
        goto Exit;
    }

    hr = CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **) &pMSAdmin);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "CoCreateInstance failed! hr = 0x%08X", hr);
        goto Exit;
    }

    dwErr = GetModuleFileNameW(hAQInstance,
                              wszModule,
                              sizeof(wszModule)/sizeof(WCHAR));
    //GetModuleFileName returns non-zero on success
    if (0 == dwErr)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL, "GetModule name failed - 0x%08X", hr);
        if (SUCCEEDED(hr)) hr = E_FAIL;
        goto Exit;
    }

    cbModule = (wcslen(wszModule)+1)*sizeof(WCHAR);

    hr = pMSAdmin->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                            L"LM/SMTPSVC/",
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                            10000,
                            &hMDRootVS);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "Could not open the key! - 0x%08x", hr);
        goto Exit;
    }

    mdrData.dwMDIdentifier  = MD_AQUEUE_DLL;
    mdrData.dwMDAttributes  = METADATA_INHERIT;
    mdrData.dwMDUserType    = IIS_MD_UT_SERVER;
    mdrData.dwMDDataType    = STRING_METADATA;
    mdrData.dwMDDataLen     = cbModule;
    mdrData.pbMDData        = (PBYTE) wszModule;
    mdrData.dwMDDataTag     = 0;
    hr = pMSAdmin->SetData( hMDRootVS, L"", &mdrData);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "Could set the AQ DLL - 0x%08X", hr);
        goto Exit;
    }


  Exit:

    if (NULL != hMDRootVS)
        pMSAdmin->CloseKey(hMDRootVS);

    if (pMSAdmin)
    {
        hr = pMSAdmin->SaveData();
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL, "Error saving metabase data  -  0x%08X", hr);
        }
		pMSAdmin->Release();
    }

    TraceFunctLeave();
    TermAsyncTrace();
    CoUninitialize();
    return hr;
}

//---[ HrUnregisterAdvQueueDll ]-----------------------------------------------
//
//
//  Description:
//      Removes the AdvQueue DLL setting from the metabase
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      Error from MSAdminBase
//  History:
//      8/2/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrUnregisterAdvQueueDll()
{
    HRESULT hr = S_OK;
    DWORD   dwErr = NO_ERROR;
    METADATA_HANDLE     hMDRootVS = NULL;
    IMSAdminBase *pMSAdmin = NULL;


    CoInitialize(NULL);
    InitAsyncTrace();
    TraceFunctEnterEx((LPARAM) NULL, "HrUnregisterAdvQueueDll");

    hr = CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **) &pMSAdmin);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "CoCreateInstance failed! hr = 0x%08X", hr);
        goto Exit;
    }

    hr = pMSAdmin->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                            L"LM/SMTPSVC/",
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                            10000,
                            &hMDRootVS);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "Could not open the key! - 0x%08x", hr);
        goto Exit;
    }

    hr = pMSAdmin->DeleteData( hMDRootVS, L"", MD_AQUEUE_DLL, STRING_METADATA);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "Could delete the AQ DLL - 0x%08X", hr);
        goto Exit;
    }


  Exit:

    if (NULL != hMDRootVS)
        pMSAdmin->CloseKey(hMDRootVS);

    if (pMSAdmin)
    {
        hr = pMSAdmin->SaveData();
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL, "Error saving metabase data  -  0x%08X", hr);
        }
		pMSAdmin->Release();
    }

    TraceFunctLeave();
    TermAsyncTrace();
    CoUninitialize();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hAQInstance = hInstance;
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return CatDllMain(hInstance, dwReason, NULL);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

//
// Register COM objects
//
STDAPI DllRegisterServer()
{
    HRESULT hr = S_OK;
    HRESULT hrCat = S_OK;

    hr = HrRegisterAdvQueueDll(g_hAQInstance);

    hrCat =  RegisterCatServer();

    if (SUCCEEDED(hr))
        hr = hrCat;

    return hr;
}

//
// Unregister COM objects
//
STDAPI DllUnregisterServer()
{
    HRESULT hr = S_OK;
    HRESULT hrCat = S_OK;

    hr = HrUnregisterAdvQueueDll();

    hrCat = UnregisterCatServer();

    if (SUCCEEDED(hr))
        hr = hrCat;

    return hr;
}

STDAPI DllCanUnloadNow()
{
    HRESULT hr;

    hr = DllCanUnloadCatNow();
    if(hr == S_OK) {
        //
        // Check aqueue COM objects (if any)
        //
        if (g_fForceDllCanUnloadNowFailure || g_cInstances)
            hr = S_FALSE;
    }
    return hr;
}

STDAPI DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
{
    HRESULT hr;
    //
    // Check to see if clsid is an aqueue object (if any aqueue
    // objects are cocreateable)
    // Currently none are
    //
    // Pass to the cat
    //
    hr = DllGetCatClassObject(
        clsid,
        iid,
        ppv);

    return hr;
}


//+------------------------------------------------------------
//
// Function: HrDllInitialize
//
// Synopsis: Refcounted initialize of exchmem and tracing
//  The logic for HrDllInitialize and DllDeInitialize depend on the
//  facts that the callers always call HrDllInitialize first and only
//  call DllDeInitialize once after each call to HrDllInitialize succeeds
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  error from exstrace
//
// History:
// jstamerj 1998/12/16 15:37:07: Created.
//
//-------------------------------------------------------------
HRESULT HrDllInitialize()
{
    HRESULT hr = S_OK;
    LONG lNewCount;

    //
    // Increment inside a sharelock because of the following case:
    // If multiple threads are calling initialize and one thread is
    // actually doing the initialization, we don't want any threads to
    // return from this function until the initialization is done
    //
    g_slDllInit.ShareLock();

    lNewCount = InterlockedIncrement(&g_cDllInit);

    //
    // No matter what, we must Init before leaving this call
    // Possible scenerios:
    //
    // lNewCount = 1, g_fInit = FALSE
    //   Normal initialization case
    // lNewCount = 1, g_fInit = TRUE
    //   Another thread is in DllDeinitialize and we have a race to
    //   see who gets the exclusive lock first.  If we get it first,
    //   DllInitialize will do nothing (since g_fInit is TRUE) and
    //   DllDeInitialize will do nothing (since g_cDllInit will be >
    //   0)
    //   If DllDeInitialize gets the exclusive lock first, it will
    //   deinit and we will reinit
    // lNewCount > 1, g_fInit = FALSE
    //   We need to get the exclusive lock to init (or to wait until
    //   another thread inits)
    // lNewCount > 1, g_fInit = TRUE
    //   We're alrady initialized, continue.
    //
    if((lNewCount == 1) || (g_fInit == FALSE)) {

        g_slDllInit.ShareUnlock();
        g_slDllInit.ExclusiveLock();

        if(g_fInit == FALSE) {
            //
            // Initialize exchmem and tracing
            //
            InitAsyncTrace();

            //
            // Initialize exchmem
            //
            if(!TrHeapCreate()) {

                hr = E_OUTOFMEMORY;
                TermAsyncTrace();
            }
            if(SUCCEEDED(hr))  {
                g_fInit = TRUE;
            } else {
                InterlockedDecrement(&g_cDllInit);
            }
        }
        g_slDllInit.ExclusiveUnlock();

    } else {

        g_slDllInit.ShareUnlock();
    }
    _ASSERT(g_fInit);
    return hr;
}


//+------------------------------------------------------------
//
// Function: DllDeinitialize
//
// Synopsis: Refcounted deinitialize of exchmem and tracing
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/16 15:46:32: Created.
//
//-------------------------------------------------------------
VOID DllDeinitialize()
{
    //
    // We don't need to do the decrement inside a sharelock because we
    // don't care about blocking threads until the DLL is really
    // DeInitialzied (whereas HrDllInitialize does care)
    //
    if(InterlockedDecrement(&g_cDllInit) == 0) {

        g_slDllInit.ExclusiveLock();
        //
        // If the refcount is still zero, deinitialize
        // If the refcount is non-zero, someone initialized before we
        // got the exclusive lock, so do not deinitialize
        //
        if(g_cDllInit == 0) {
            //
            // If this assert fires, then DllDeinitialize has been
            // called before DllInitialize returned (or there is a
            // DllInit/Deinit mismatch)
            //
            _ASSERT(g_fInit == TRUE);

            //
            // Termiante exchmem and tracing
            //
            if(!TrHeapDestroy()) {

                TraceFunctEnter("DllDeinitialize");
                ErrorTrace((LPARAM) 0,
                           "Unable to Destroy Exchmem heap for Advanced Queuing");
                TraceFunctLeave();
            }
            TermAsyncTrace();
            g_fInit = FALSE;

        } else {
            //
            // Someone called initialize between the time we
            // decremented the count and got the exclusive lock.  In
            // this case we don't want to deinitialize
            //
        }
        g_slDllInit.ExclusiveUnlock();
    }
}

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asncwrkq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: asncwrkq.cpp
//
//  Description:  Implementation of CAsyncWorkQueue.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      3/8/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "asncwrkq.h"
#include "asyncq.inl"


CPool CAsyncWorkQueueItem::s_CAsyncWorkQueueItemPool;
DWORD CAsyncWorkQueueItem::s_cCurrentHeapAllocations = 0;
DWORD CAsyncWorkQueueItem::s_cTotalHeapAllocations = 0;

//---[ CAsyncWorkQueueItem::new ]----------------------------------------------
//
//
//  Description: 
//      Wrapper for new that will use CPool or Exchmem to allocate... 
//      whichever is appropriate.
//  Parameters:
//      size        size of item to allocate (should always be 
//                  sizeof (CAsyncWorkQueueItem)
//  Returns:
//      Pointer to newly allocated CAsyncWorkQueueItem
//  History:
//      7/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void * CAsyncWorkQueueItem::operator new(size_t size)
{
    CAsyncWorkQueueItemAllocatorBlock *pcpaqwi = NULL;

    _ASSERT(sizeof(CAsyncWorkQueueItem) == size);

    pcpaqwi = (CAsyncWorkQueueItemAllocatorBlock *) s_CAsyncWorkQueueItemPool.Alloc(); 
    if (pcpaqwi)
    {
        pcpaqwi->m_dwSignature = ASYNC_WORK_QUEUE_ENTRY_ALLOC_CPOOL_SIG;
    }
    else
    {
        //Fallback on Exchmem
        pcpaqwi = (CAsyncWorkQueueItemAllocatorBlock *) 
                            pvMalloc(sizeof(CAsyncWorkQueueItemAllocatorBlock));
        if (pcpaqwi)
        {
            pcpaqwi->m_dwSignature = ASYNC_WORK_QUEUE_ENTRY_ALLOC_HEAP_SIG;
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &s_cCurrentHeapAllocations));
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &s_cTotalHeapAllocations));
        }
    }

    if (pcpaqwi)
        return ((void *) &(pcpaqwi->m_pawqi));
    else
        return NULL;
}

//---[ CAsyncWorkQueueItem::delete ]-------------------------------------------
//
//
//  Description: 
//      Delete operator that will handle deleting via CPool or exchmem
//  Parameters:
//      pv      Object to delete
//      size    Size of object
//  Returns:
//      -
//  History:
//      7/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAsyncWorkQueueItem::operator delete(void *pv, size_t size)
{
    _ASSERT(sizeof(CAsyncWorkQueueItem) == size);
    _ASSERT(pv);
    CAsyncWorkQueueItemAllocatorBlock *pcpaqwi = CONTAINING_RECORD(pv, 
                                    CAsyncWorkQueueItemAllocatorBlock, m_pawqi);
    DWORD   dwOldSignature = pcpaqwi->m_dwSignature;

    _ASSERT(ASYNC_WORK_QUEUE_ENTRY_ALLOC_INVALID_SIG != dwOldSignature);

    //Reset signature before we free it, in case memory allocators
    //do not overwrite it (we want our asserts to fire at the time 
    //of the double-free).
    pcpaqwi->m_dwSignature = ASYNC_WORK_QUEUE_ENTRY_ALLOC_INVALID_SIG;
    switch(dwOldSignature)
    {
      case ASYNC_WORK_QUEUE_ENTRY_ALLOC_CPOOL_SIG:
        s_CAsyncWorkQueueItemPool.Free(pcpaqwi);
        break;
      case ASYNC_WORK_QUEUE_ENTRY_ALLOC_HEAP_SIG:
        DEBUG_DO_IT(InterlockedDecrement((PLONG) &s_cCurrentHeapAllocations));
        FreePv(pcpaqwi);
        break;
      default:
        _ASSERT(0 && "Invalid signature when freeing CAsyncWorkQueueItem");
    }
}

//---[ CAsyncWorkQueueItem::CAsyncWorkQueueItem ]------------------------------
//
//
//  Description: 
//      Default constructor for CAsyncWorkQueueItem
//  Parameters:
//      pvData          Data to pass to completion function
//      pfnCompletion   Completion function
//  Returns:
//      -
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncWorkQueueItem::CAsyncWorkQueueItem(PVOID pvData,
                                         PASYNC_WORK_QUEUE_FN pfnCompletion)
{
    _ASSERT(pfnCompletion);

    m_dwSignature   = ASYNC_WORK_QUEUE_ENTRY;
    m_pvData        = pvData;
    m_pfnCompletion = pfnCompletion;
}

//---[ CAsyncWorkQueueItem::~CAsyncWorkQueueItem ]-----------------------------
//
//
//  Description: 
//      Default destructor for CAsyncWorkQueueItem
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncWorkQueueItem::~CAsyncWorkQueueItem()
{
    m_dwSignature = ASYNC_WORK_QUEUE_ENTRY_FREE;
}

//---[ CAsyncWorkQueue::CAsyncWorkQueue ]--------------------------------------
//
//
//  Description: 
//      Default constructor for CAsyncWorkQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncWorkQueue::CAsyncWorkQueue()
{
    m_dwSignature = ASYNC_WORK_QUEUE_SIG;
    m_cWorkQueueItems = 0;
    m_dwStateFlags = ASYNC_WORK_QUEUE_NORMAL;
}

//---[ CAsyncWorkQueue::~CAsyncWorkQueue ]-------------------------------------
//
//
//  Description: 
//      Destructor for CAsyncWorkQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncWorkQueue::~CAsyncWorkQueue()
{
    m_dwSignature = ASYNC_WORK_QUEUE_SIG_FREE;
}

//---[ CAsyncWorkQueue::HrInitialize ]-----------------------------------------
//
//
//  Description: 
//      Initialization routing for CAsyncWorkQueue base.  Initializes the 
//      CAsyncQueue
//  Parameters:
//      cItemsPerThread     The number of items to process per async thread
//  Returns:
//      S_OK on success
//      Failure code from CAsyncQueue::HrInitialize()
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncWorkQueue::HrInitialize(DWORD cItemsPerThread)
{
    HRESULT hr = S_OK;
    hr = m_asyncq.HrInitialize(0, //there can be *no* sync threads
                               cItemsPerThread, 
                               1,//init requires this value to be at least 1
                               this,
                               CAsyncWorkQueue::fQueueCompletion, 
                               CAsyncWorkQueue::fQueueFailure,
                               NULL);

    return hr;
}

//---[ CAsyncWorkQueue::HrDeinitialize ]---------------------------------------
//
//
//  Description:   
//      Signals shutdown for queue code
//  Parameters:
//      paqinst         Pointer to AQ server instance object
//  Returns:
//      S_OK on success
//  History:
//      3/8/99 - MikeSwa Created 
//      7/7/99 - MikeSwa Allow async threads to help process shutdown
//
//-----------------------------------------------------------------------------
HRESULT CAsyncWorkQueue::HrDeinitialize(CAQSvrInst *paqinst)
{
    const   DWORD   MAX_ITERATIONS_NO_PROGRESS = 1000; //iterations before assert
    HRESULT hr = S_OK;
    DWORD   cLastCount = cGetWorkQueueItems();
    DWORD   cIterationsNoProgress = 0;
    _ASSERT(paqinst);

    //Start processing all items in "shutdown" mode
    m_dwStateFlags = ASYNC_WORK_QUEUE_SHUTDOWN;

    //
    //  Make sure we have threads actively processing this queue before
    //  we settle down and wait for them to stop.
    //
    _ASSERT(!cGetWorkQueueItems() || m_asyncq.dwGetTotalThreads());
    m_asyncq.StartRetry();

    //Let the worker threads have some fun before we stop and do the single
    //theaded initialization
    while (cLastCount && (cIterationsNoProgress < MAX_ITERATIONS_NO_PROGRESS))
    {
        if (cLastCount <= cGetWorkQueueItems())
            cIterationsNoProgress++;
        
        //I'd like to see this case
        _ASSERT(cIterationsNoProgress < MAX_ITERATIONS_NO_PROGRESS); 

        cLastCount = cGetWorkQueueItems();
        paqinst->ServerStopHintFunction();

        //Since it may take longer than our stop hint to process a 
        //single item in the queue, we need to sleep instead of 
        //attempting to process an item (Bug #X5:118258).
        Sleep(10000);
    }
    hr = m_asyncq.HrDeinitialize(CAsyncWorkQueue::HrShutdownWalkFn, 
                                           paqinst);
    return hr;
}

//---[ CAsyncWorkQueue::HrQueueWorkItem ]--------------------------------------
//
//
//  Description: 
//      Queues items to async work queue
//  Parameters:
//      pvData          Data item to pass to completion function
//      pfCompletion    Completion function
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if queue item could not be allocated
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncWorkQueue::HrQueueWorkItem(PVOID pvData, 
                                         PASYNC_WORK_QUEUE_FN pfnCompletion)
{
    HRESULT hr = S_OK;
    CAsyncWorkQueueItem *pawqi = NULL;

    _ASSERT(pvData);
    _ASSERT(pfnCompletion);

    if (!pfnCompletion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Create queue item, initialize it, and queue it
    pawqi = new CAsyncWorkQueueItem(pvData, pfnCompletion);
    if (!pawqi)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = m_asyncq.HrQueueRequest(pawqi, FALSE);
    if (FAILED(hr))
        goto Exit;

    InterlockedIncrement((PLONG) &m_cWorkQueueItems);

  Exit:
    if (FAILED(hr) && pfnCompletion)
    {
        //call completion function
        pfnCompletion(pvData,
                      ASYNC_WORK_QUEUE_FAILURE | 
                      ASYNC_WORK_QUEUE_ENQUEUE_THREAD);
    }

    if (pawqi)
        pawqi->Release();

    return hr;
}

//---[ CAsyncWorkQueue::fQueueCompletion ]-------------------------------------
//
//
//  Description: 
//      Completion function called by CAsyncQueue
//  Parameters:
//      pawqi       CAsyncWorkQueueItem to process
//      pvContext   "this" pointer
//  Returns:
//      TRUE if item was process
//      FALSE otherwise
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAsyncWorkQueue::fQueueCompletion(CAsyncWorkQueueItem *pawqi,
                                       PVOID pvContext)
{
    BOOL    fRet = TRUE;
    CAsyncWorkQueue *pawq = (CAsyncWorkQueue *) pvContext;

    _ASSERT(pawqi);
    _ASSERT(pawq);
    _ASSERT(ASYNC_WORK_QUEUE_ENTRY == pawqi->m_dwSignature);
    _ASSERT(ASYNC_WORK_QUEUE_SIG == pawq->m_dwSignature);

    fRet = pawqi->m_pfnCompletion(pawqi->m_pvData, 
                                  pawq->m_dwStateFlags);

    if (fRet)
        InterlockedDecrement((PLONG) 
                    &(((CAsyncWorkQueue *)pawq)->m_cWorkQueueItems));

    return fRet;
}

//---[ CAsyncWorkQueue::fQueueFailure ]----------------------------------------
//
//
//  Description:    
//      Function to handle internal failures in CAsyncQueue
//  Parameters:
//      pawq        "this" pointer
//      pawqi       CAsyncWorkQueueItem to process
//  Returns:
//      TRUE always
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAsyncWorkQueue::fQueueFailure(CAsyncWorkQueueItem *pawqi,
                                    PVOID pawq)
                                    
{
    _ASSERT(pawqi);
    _ASSERT(pawq);
    _ASSERT(ASYNC_WORK_QUEUE_ENTRY == pawqi->m_dwSignature);
    _ASSERT(ASYNC_WORK_QUEUE_SIG == ((CAsyncWorkQueue *)pawq)->m_dwSignature);

    pawqi->m_pfnCompletion(pawqi->m_pvData, ASYNC_WORK_QUEUE_FAILURE);

    InterlockedDecrement((PLONG) &(((CAsyncWorkQueue *)pawq)->m_cWorkQueueItems));

    return TRUE;
}

//---[ CAsyncWorkQueue::HrShutdownWalkFn ]-------------------------------------
//
//
//  Description: 
//      Function to walk an CAsyncWorkQueue queue at shutdown and clear out 
//      all of the pending work items
//  Parameters:
//      IN  CAsyncWorkQueueItem ptr to data on queue
//      IN  PVOID pvContext     AQ server intstance
//      OUT BOOL *pfContinue,   TRUE if we should continue
//      OUT BOOL *pfDelete);    TRUE if item should be deleted
//  Returns:
//      S_OK always
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncWorkQueue::HrShutdownWalkFn(
                                     CAsyncWorkQueueItem *pawqi, 
                                     PVOID pvContext,
                                     BOOL *pfContinue, 
                                     BOOL *pfDelete)
{
    CAQSvrInst *paqinst = (CAQSvrInst *) pvContext;

    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(pawqi);
    _ASSERT(ASYNC_WORK_QUEUE_ENTRY == pawqi->m_dwSignature);


    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    paqinst->ServerStopHintFunction();
    pawqi->m_pfnCompletion(pawqi->m_pvData, ASYNC_WORK_QUEUE_SHUTDOWN);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asncwrkq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: asncwrkq.h
//
//  Description:  Header file for CAsyncWorkQueue class.  This class uses
//      ATQ threads to do async work.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      3/8/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __ASNCWRKQ_H__
#define __ASNCWRKQ_H__

#include "aqincs.h"
#include "asyncq.h"

//Async work queue call back function
typedef BOOL (*PASYNC_WORK_QUEUE_FN)(PVOID pvContext, 
                                    DWORD dwStatus);

#define ASYNC_WORK_QUEUE_SIG                        'QkrW'
#define ASYNC_WORK_QUEUE_SIG_FREE                   'Qkr!'
#define ASYNC_WORK_QUEUE_ENTRY                      'EkrW'
#define ASYNC_WORK_QUEUE_ENTRY_FREE                 'Ekr!'

//Signatures to describe how this entry was allocated
#define ASYNC_WORK_QUEUE_ENTRY_ALLOC_CPOOL_SIG      'QWAP'
#define ASYNC_WORK_QUEUE_ENTRY_ALLOC_HEAP_SIG       'QWAH'
#define ASYNC_WORK_QUEUE_ENTRY_ALLOC_INVALID_SIG    'QWA!'

typedef enum TagAsyncWorkQueueItemState
{
    ASYNC_WORK_QUEUE_NORMAL         = 0x00000001,
    ASYNC_WORK_QUEUE_SHUTDOWN       = 0x00000002,
    ASYNC_WORK_QUEUE_FAILURE        = 0x00000003,

    //Warning flag set when failure happens on enqueue thread
    ASYNC_WORK_QUEUE_ENQUEUE_THREAD = 0x80000001,
} AsyncWorkQueueItemState;

class CAsyncWorkQueue;

//---[ CAsyncWorkQueueItem ]---------------------------------------------------
//
//
//  Description: 
//      Item in async work queue
//
//  Hungarian: 
//      awqi, pawqi
//  
//-----------------------------------------------------------------------------
class CAsyncWorkQueueItem : 
    public CBaseObject
{
  public:
    //define special memory allocators
    static  CPool           s_CAsyncWorkQueueItemPool;
    static  DWORD           s_cCurrentHeapAllocations;
    static  DWORD           s_cTotalHeapAllocations;

    void * operator new (size_t size); 
    void operator delete(void *pv, size_t size);

    CAsyncWorkQueueItem(PVOID pvData,
                        PASYNC_WORK_QUEUE_FN pfnCompletion);
    ~CAsyncWorkQueueItem();
  protected:
    DWORD                   m_dwSignature;
    PVOID                   m_pvData;
    PASYNC_WORK_QUEUE_FN    m_pfnCompletion;
    friend class            CAsyncWorkQueue;
};


//---[ CAsyncWorkQueueItemAllocatorBlock ]-------------------------------------
//
//
//  Description: 
//      Struct used as a hidden wrapper for CAsyncWorkQueueItem allocation... 
//      used exclusively by the CAsyncWorkQueueItem new and delete operators
//  Hungarian: 
//      cpawqi, pcpawqi
//  
//-----------------------------------------------------------------------------
typedef struct TagCAsyncWorkQueueItemAllocatorBlock

{
    DWORD                   m_dwSignature;
    CAsyncWorkQueueItem     m_pawqi;
} CAsyncWorkQueueItemAllocatorBlock;


//---[ CAsyncWorkQueue ]-------------------------------------------------------
//
//
//  Description: 
//      Async work queue that 
//  Hungarian: 
//      awq, paqw
//  
//-----------------------------------------------------------------------------
class CAsyncWorkQueue 
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_cWorkQueueItems;
    DWORD       m_dwStateFlags;
    CAsyncQueue<CAsyncWorkQueueItem *, ASYNC_QUEUE_WORK_SIG> m_asyncq;
  public:
    CAsyncWorkQueue();
    ~CAsyncWorkQueue();
    HRESULT HrInitialize(DWORD cItemsPerThread);
    HRESULT HrDeinitialize(CAQSvrInst *paqinst);
    HRESULT HrQueueWorkItem(PVOID pvData, 
                            PASYNC_WORK_QUEUE_FN pfnCompletion);

    DWORD   cGetWorkQueueItems() {return m_cWorkQueueItems;};

    static  BOOL fQueueCompletion(CAsyncWorkQueueItem *pawqi,
                                  PVOID pawq);
    static  BOOL fQueueFailure(CAsyncWorkQueueItem *pawqi,
                               PVOID pawq);

    static  HRESULT HrShutdownWalkFn(CAsyncWorkQueueItem *paqwi, 
                                     PVOID pvContext,
                                     BOOL *pfContinue, 
                                     BOOL *pfDelete);
};

#endif //__ASNCWRKQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asyncadm.h ===
//-----------------------------------------------------------------------------
//
//
//  File: asyncqadm.h
//
//  Description:
//      Header for for CAsyncAdminQueue class.  This is the base class that
//      our QAPI implementation is based on.
//
//      The object model for QAPI is (<>'s indicate a template class):
//          CAsyncQueueBase - pure base class for async queue
//              CAsyncQueue<> - original async queue implementations
//                  CAsyncRetryQueue<> - async queue /w retry queue
//                      CAsyncAdminQueue<> - Base for admin funtionality
//                          CAsyncAdminMailMsgQueue - MailMsg specific 
//                          CAsyncAdminMsgRefQueue - MsgRef specific 
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/6/2000 - MikeSwa Created (from t-toddc's summer work)
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __ASYNCQADM_H__
#define __ASYNCQADM_H__
#include <fifoq.h>
#include <intrnlqa.h>
#include <baseobj.h>
#include <aqstats.h>
#include <aqadmtyp.h>
#include <aqnotify.h>
#include <hndlmgr.h>

class CAQSvrInst;

//---[ CAsyncAdminQueue ]------------------------------------------------------
//
//
//  Description: 
//      Base class that implements basic functionality of Administratable queues
//  Hungarian: 
// 
//  
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
class CAsyncAdminQueue : 
    public IQueueAdminAction,
    public IQueueAdminQueue,
    public CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>,
    public CBaseObject
{
  private:
    DWORD                           m_cbDomain;
    LPSTR                           m_szDomain;
    DWORD                           m_cbLinkName;
    LPSTR                           m_szLinkName;
    GUID                            m_guid;
    DWORD                           m_dwID;

  protected:
    typename CFifoQueue<PQDATA>::MAPFNAPI    m_pfnMessageAction;
    CAQSvrInst                     *m_paqinst;
    IAQNotify                      *m_pAQNotify;
    CQueueHandleManager				m_qhmgr;


  public:
    HRESULT HrInitialize(
                DWORD cMaxSyncThreads,
                DWORD cItemsPerATQThread,
                DWORD cItemsPerSyncThread,
                PVOID pvContext,
                QCOMPFN pfnQueueCompletion,
                QCOMPFN pfnFailedItem,
                typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFailure,
                DWORD cMaxPendingAsyncCompletions = 0);

    CAsyncAdminQueue(LPCSTR szDomain, LPCSTR szLinkName, 
            const GUID *pguid, DWORD dwID, CAQSvrInst *paqinst,
             typename CFifoQueue<PQDATA>::MAPFNAPI pfnMessageAction);
    ~CAsyncAdminQueue();

    //
    //  Used to set the interface to do stats updates to
    //
    inline void SetAQNotify(IAQNotify *pAQNotify) {m_pAQNotify = pAQNotify;};

  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj); 
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    //All of these objects are allocated as part CAQSvrInst... we can
    //add the assert below to make sure that someone does not relese it 
    //early
    STDMETHOD_(ULONG, Release)(void) 
        {_ASSERT(m_lReferences > 1); return CBaseObject::Release();};

  public: //IQueueAdminAction
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD(HrApplyActionToMessage)(
		IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
		BOOL *pfShouldDelete);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        return HrInternalQuerySupportedActions(pdwSupportedActions, 
                                            pdwSupportedFilterFlags);
    };
  public: //IQueueAdminQueue
    STDMETHOD(HrGetQueueInfo)(
        QUEUE_INFO *pliQueueInfo);

    STDMETHOD(HrGetQueueID)(
        QUEUELINK_ID *pQueueID);

  protected: // Virutal functions used to implement msg specific actions
    virtual HRESULT HrDeleteMsgFromQueueNDR(IUnknown *pIUnknownMsg) = 0;
    virtual HRESULT HrDeleteMsgFromQueueSilent(IUnknown *pIUnknownMsg) = 0;
    virtual HRESULT HrFreezeMsg(IUnknown *pIUnknownMsg) = 0;
    virtual HRESULT HrThawMsg(IUnknown *pIUnknownMsg) = 0;
    virtual HRESULT HrGetStatsForMsg(IUnknown *pIUnknownMsg, CAQStats *paqstats) = 0;
    virtual HRESULT HrInternalQuerySupportedActions(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags) = 0;

};


#endif //__ASYNCQADM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\bitmap.cpp ===
//-----------------------------------------------------------------------------
//
//
//    File: bitmap.cpp
//
//    Description: Contains code for implementation of bitmap functions
//
//    Owner: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "bitmap.h"

#define BITS_PER_DWORD  32

//Set up static masks for quick parsing
const DWORD   s_rgdwMasks[8] =
{
    0xF0000000,
    0x0F000000,
    0x00F00000,
    0x000F0000,
    0x0000F000,
    0x00000F00,
    0x000000F0,
    0x0000000F
};

//Used for fast conversion from index to bitmap
const DWORD   s_rgdwIndexMasks[32] =
{
    0x80000000, 0x40000000, 0x20000000, 0x10000000,
    0x08000000, 0x04000000, 0x02000000, 0x01000000,
    0x00800000, 0x00400000, 0x00200000, 0x00100000,
    0x00080000, 0x00040000, 0x00020000, 0x00010000,
    0x00008000, 0x00004000, 0x00002000, 0x00001000,
    0x00000800, 0x00000400, 0x00000200, 0x00000100,
    0x00000080, 0x00000040, 0x00000020, 0x00000010,
    0x00000008, 0x00000004, 0x00000002, 0x00000001
};

//Used to check for zero'd bitmaps with cBits does not fill up a DWORD
const DWORD   s_rgdwZeroMasks[32] =
{
    0x80000000, 0xC0000000, 0xE0000000, 0xF0000000,
    0xF8000000, 0xFC000000, 0xFE000000, 0xFF000000,
    0xFF800000, 0xFFC00000, 0xFFE00000, 0xFFF00000,
    0xFFF80000, 0xFFFC0000, 0xFFFE0000, 0xFFFF0000,
    0xFFFF8000, 0xFFFFC000, 0xFFFFE000, 0xFFFFF000,
    0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00, 0xFFFFFF00,
    0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0, 0xFFFFFFF0,
    0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE, 0xFFFFFFFF,
};

//---[ fInterlockedDWORDCompareExchange ]--------------------------------------
//
//
//  Description:
//      Provide an inline function to handle the type-checking, casts,
//      and comparison in DWORD chunks.
//  Parameters:
//      pdwDest     Destination to update
//      dwNewValue  Value to update with
//      dwCompare   Old value to check against
//  Returns:
//      TRUE if update succeeded
//
//-----------------------------------------------------------------------------
inline BOOL fInterlockedDWORDCompareExchange(LPDWORD pdwDest, DWORD dwNewValue,
                                             DWORD dwCompare)
{
    return(
        ((DWORD) InterlockedCompareExchange((PLONG)pdwDest,
            (LONG) dwNewValue, (LONG) dwCompare))
        == dwCompare);
}

//---[ CMsgBitMap::new ]----------------------------------------------------------
//
//
//  Description:
//      Overide the new operator to allow for the variable size of this class.
//      A good optimization would be to use the C-pool type stuff for the
//      90% case of 1 domain, and allocate the rest on the fly
//  Parameters:
//      cBits    the number of bits this message is being delivered to.
//  Returns:
//      -
//-----------------------------------------------------------------------------
void * CMsgBitMap::operator new(size_t stIgnored, unsigned int cBits)
{
    void    *pvThis = NULL;
    int      i = 0;

    _ASSERT(size(cBits) >= sizeof(DWORD));
    pvThis = pvMalloc(size(cBits));

    return (pvThis);
}

//---[ CMsgBitMap::CMsgBitMap ]------------------------------------------------
//
//
//  Description:
//      Class constructor.  Will zero memory for a bitmap that is not part of
//      a message reference
//  Parameters:
//      cBits - The number of bits in the bitmap
//  Returns:
//
//
//-----------------------------------------------------------------------------
CMsgBitMap::CMsgBitMap(DWORD cBits)
{
    DWORD   cDWORDs = cGetNumDWORDS(cBits);
    ZeroMemory(m_rgdwBitMap, cDWORDs*sizeof(DWORD));
}

//---[ CMsgBitMap::FAllClear ]-------------------------------------------------
//
//
//  Description:
//      Checks to see of all relevant bits (1st cBits) are 0
//  Parameters:
//      cBits the number of bits in the bitmap
//  Returns:
//      TRUE if all bits are 0, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL CMsgBitMap::FAllClear(DWORD cBits)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::FAllClear");
    BOOL    fResult = TRUE;
    DWORD   cDWORDs = cGetNumDWORDS(cBits) ;

    //verify all DWORD's by checking if 0
    for (DWORD i = 0; i < cDWORDs; i++)
    {
        if (m_rgdwBitMap[i] != 0x00000000)
        {
            fResult = FALSE;
            break;
        }
    }

    TraceFunctLeave();
    return fResult;
}

//---[ CMsgBitMap::FAllSet ]---------------------------------------------------
//
//
//  Description:
//      Checks to see of all relevant bits (1st cBits) are 1
//  Parameters:
//      cBits the number of bits in the bitmap
//  Returns:
//      TRUE if all bits are 1, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL CMsgBitMap::FAllSet(DWORD cBits)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::FAllClear");
    BOOL    fResult = TRUE;
    DWORD   cDWORDs = cGetNumDWORDS(cBits+1) -1;  //check all but last DWORD
    DWORD   iZeroIndex = cBits & 0x0000001F;

    //verify all DWORD's by checking if 0
    for (DWORD i = 0; i < cDWORDs; i++)
    {
        if (m_rgdwBitMap[i] != 0xFFFFFFFF)
        {
            fResult = FALSE;
            goto Exit;  //if we hit the iZeroIndex clause, we might assert
        }
    }

    _ASSERT(i || iZeroIndex || !fResult); //We must check at least 1 DWORD

    if (iZeroIndex)
    {
        iZeroIndex--; //we cBits is a count... our index starts at 0.
        //last DWORD should be a subset of the ZeroMask
        _ASSERT(s_rgdwZeroMasks[iZeroIndex] ==
                (s_rgdwZeroMasks[iZeroIndex] | m_rgdwBitMap[cDWORDs]));

        if (s_rgdwZeroMasks[iZeroIndex] != m_rgdwBitMap[cDWORDs])
            fResult = FALSE;
    }

  Exit:
    TraceFunctLeave();
    return fResult;
}

//---[ CMsgBitMap::HrMarkBits ]------------------------------------------------
//
//
//    Description:
//      Marks the bits (as 0 or 1) that corresponds to the given indexes
//
//    Parameters:
//      IN DWORD cBits
//      IN DWORD cIndexes   # of indexes in array
//      IN DWORD rgiBits    SORTED array of indexes of bits to mark
//      IN BOOL  fSet       TRUE => set to 1, 0 otherwise
//    Returns:
//      S_OK on success
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrMarkBits(IN DWORD cBits, IN DWORD cIndexes,
                               IN DWORD *rgiBits, IN BOOL fSet)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrMarkBits");
    HRESULT hr = S_OK;
    DWORD   cDWORDs = cGetNumDWORDS(cBits);
    DWORD   dwTmp;
    DWORD   dwIndex = 0x00000000;
    DWORD   i;
    DWORD   iCurrentIndex = 0;     //current index in rgiBits
    DWORD   iCurrentLimit = BITS_PER_DWORD -1; //current limit of 32 bit range for values of rgiBits

    _ASSERT(cIndexes);
    _ASSERT(cIndexes <= cBits);

    for (i = 0; i < cDWORDs; i++)
    {
        dwIndex = 0x00000000;
        while ((iCurrentIndex < cIndexes) &&
                (rgiBits[iCurrentIndex] <= iCurrentLimit))
        {
            _ASSERT(rgiBits[iCurrentIndex] < cBits);
            dwIndex |= s_rgdwIndexMasks[(rgiBits[iCurrentIndex] % BITS_PER_DWORD)];
            iCurrentIndex++;
        }

        if (dwIndex != 0x00000000) //don't perform costly interlocked op if we don't need to
        {
            if (fSet) //set bit
            {
              SpinTry1:
                dwTmp = m_rgdwBitMap[i];
                if (!fInterlockedDWORDCompareExchange(&(m_rgdwBitMap[i]), (dwIndex | dwTmp), dwTmp))
                    goto SpinTry1;
            }
            else  //clear bit
            {
              SpinTry2:
                dwTmp = m_rgdwBitMap[i];
                if (!fInterlockedDWORDCompareExchange(&(m_rgdwBitMap[i]), ((~dwIndex) & dwTmp), dwTmp))
                    goto SpinTry2;
            }
        }

        if (iCurrentIndex >= cIndexes)
            break; //don't do more work than we have to

        iCurrentLimit += BITS_PER_DWORD;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrGetIndexes ]----------------------------------------------
//
//
//  Description:
//      Generates an array of indexes represented by the bitmap
//  Parameters:
//      IN  DWORD   cBits
//      OUT DWORD  *pcIndexes     //# of indexes returned
//      OUT DWORD **prgdwIndexes  //array of indexes
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if memory allocation fails
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrGetIndexes(IN DWORD cBits, OUT DWORD *pcIndexes,
                         OUT DWORD **prgdwIndexes)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrGetIndexes");
    HRESULT  hr         = S_OK;
    DWORD   *pdwIndexes = NULL;
    DWORD    dwIndex    = 0;
    DWORD    dwIndexOffset = 0;
    DWORD    cDWORDs = cGetNumDWORDS(cBits);
    DWORD    cdwAllocated = 0;
    DWORD    cCurrentIndexes = 0;
    DWORD    i = 0;
    DWORD   *pdwTmp = NULL;

    //$$REVIEW: How do we balance CPU usage vs memory usage here?  We know the
    //  max size of the output array is cBits DWORDS, but in actuality it can
    //  little as 1 DWORD.  Prognosticating the actual size accurately would
    //  require scanning the bitmap multiple times.
    //
    // Easy(studpid) way: Count bits, allocate array, recount and add indexes to array
    //
    // Idea #1: Allocate in chunks of 32 DWORDS, Realloc if we run out  Should
    //  not have to worry about reallocing for 90% of the cases.
    //
    // Idea #2: Add some stats to this class, and run some stress tests in debug
    //  mode, and develop a heuristic that limits reallocs and such (ie alloc
    //  lg(cBits) to start with).
    //
    // Idea #3: Continue with Idea #2, but add self-tuning stats
    Assert(pcIndexes);
    Assert(prgdwIndexes);

    pdwIndexes = (DWORD *) pvMalloc(BITS_PER_DWORD*sizeof(DWORD));
    if (pdwIndexes == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    cdwAllocated = BITS_PER_DWORD;

    cCurrentIndexes = 0;

    for (i = 0; i < cDWORDs; i++)
    {
        dwIndex = 0;
        while (dwIndex < BITS_PER_DWORD)
        {
            //can use mask to check if possible
            if ((!(dwIndex & 0x00000003)) && //if %4 == 0
                !(s_rgdwMasks[dwIndex/4] & m_rgdwBitMap[i]))
            {
                dwIndex += 4; //Can skip ahead 4
            }
            else
            {
                if (s_rgdwIndexMasks[dwIndex] & m_rgdwBitMap[i])  //Found it!
                {
                    //Write index and check if re-allocation is needed
                    if (cCurrentIndexes >= cdwAllocated)
                    {
                        cdwAllocated += BITS_PER_DWORD;
                        pdwTmp = (DWORD *) pvRealloc(pdwIndexes, cdwAllocated*sizeof(DWORD));
                        if (NULL == pdwTmp)
                        {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                        }
                        pdwIndexes = pdwTmp;
                    }
                    *(pdwIndexes + cCurrentIndexes) = (dwIndex + dwIndexOffset);
                    cCurrentIndexes++;
                }
                dwIndex++;
            }
        }

        //Use dwIndexOffset to break down index generation into 32-bit chunks
        dwIndexOffset += BITS_PER_DWORD;
    }

    *prgdwIndexes = pdwIndexes; //set OUT value
    *pcIndexes = cCurrentIndexes;

  Exit:

    if (FAILED(hr))
    {
        *prgdwIndexes = NULL;
        *pcIndexes = 0;
        FreePv(pdwIndexes);
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrGroupOr ]-------------------------------------------------
//
//
//  Description:
//      Sets thir bitmap to the logical OR of the given list of bitmaps. This
//      is used to prepare a bitmap that represents the domains being delivered
//      over a list (or destmsg queue).  Current bitmap is NOT cleared prior to
//      this operation.
//  Parameters:
//      IN DWORD cBits  number of bits in bitmap
//      IN DWORD cBitMaps number of bitmaps in array
//      IN CMsgBitMap **rgpBitMaps array of bitmaps to OR
//  Returns:
//      S_OK on success
//
// Note: This is NOT thread safe.. it's intended use is only for tmp bitmaps
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrGroupOr(IN DWORD cBits, IN DWORD cBitMaps,
                      IN CMsgBitMap **rgpBitMaps)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrGroupOr");
    HRESULT hr = S_OK;
    DWORD   cDWORDs = cGetNumDWORDS(cBits);
    DWORD   i, j;

    for (i = 0; i < cDWORDs; i++)
    {
        for (j = 0; j < cBitMaps; j++)
        {
            Assert(rgpBitMaps[j]);
            m_rgdwBitMap[i] |= rgpBitMaps[j]->m_rgdwBitMap[i];
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrFilter ]--------------------------------------------------
//
//
//  Description:
//      Filters the current bitmap by setting only the bits that are SET in
//      in and UNSET in the given bitmap..
//      Performs a logical AND with the complement of the given bitmap
//  Parameters:
//      IN DWORD cBits          # of bits in bitmap
//      IN CMsgBitMap *pmbmap   bitmap to filter against
//  Returns:
//      S_OK on success
//
//  Truth Table:
//      A => this bitmap
//      B => pmbmap
//
//      A B | A'B'
//     ===========
//      0 0 | 0 0
//      0 1 | 0 1
//      1 0 | 1 0
//      1 1 | 0 1
//
// Note: This is NOT thread safe.. it's intended use is only for tmp bitmaps
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrFilter(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrFilter");
    HRESULT hr = S_OK;
    DWORD   cDWORDs = cGetNumDWORDS(cBits);

    Assert(pmbmap);

    for (DWORD i = 0; i < cDWORDs; i++)
    {
        m_rgdwBitMap[i] &= ~(pmbmap->m_rgdwBitMap[i]);
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrFilterSet ]-----------------------------------------------
//
//
//  Description:
//      Filters the current bitmap and sets those bits to 1 in the given
//      bitmap.  Unlike HrFilter, this modifies the given bitmap and does so
//      in a thread-safe manner.
//  Parameters:
//      IN DWORD cBits          # of bits in bitmap
//      IN CMsgBitMap *pmbmap   bitmap to filter against
//  Returns:
//      S_OK on success
//
//  Truth Table:
//      A => this bitmap
//      B => pmbmap
//
//      A B | A'B'
//     ===========
//      0 0 | 0 0
//      0 1 | 0 1
//      1 0 | 1 1
//      1 1 | 0 1
//
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrFilterSet(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrFilterSet");
    Assert(pmbmap);

    HRESULT hr         = S_OK;
    DWORD   cDWORDs    = cGetNumDWORDS(cBits);
    DWORD   dwSelfNew;
    DWORD   dwOtherNew;
    DWORD   dwOtherOld;
    DWORD   i;
    BOOL    fDone      = FALSE;

    for (i = 0; i < cDWORDs; i++)
    {
        fDone = FALSE;
        dwSelfNew  = m_rgdwBitMap[i];
        while (!fDone)
        {
            dwOtherNew = pmbmap->m_rgdwBitMap[i];
            dwOtherOld = dwOtherNew;

            dwSelfNew &= ~dwOtherNew;  //filter
            dwOtherNew ^= dwSelfNew;   //set

            if (fInterlockedDWORDCompareExchange(&(pmbmap->m_rgdwBitMap[i]),
                        dwOtherNew, dwOtherOld))
            {
                fDone = TRUE;
                m_rgdwBitMap[i] = dwSelfNew;
            }
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrFilterUnset ]-----------------------------------------------
//
//
//  Description:
//      Uses the current bitmap and sets those bits that are 1 on it to 0 in the
//      given bitmap.  Unlike HrFilterSet, only the pmbmap is modified.
//
//      This also checks that all bits that are 1 in self are also 1 in the
//      other... ie that the 1 bits in this are a subset of pmbmap
//  Parameters:
//      IN DWORD cBits          # of bits in bitmap
//      IN CMsgBitMap *pmbmap   bitmap to filter against
//  Returns:
//      S_OK on success
//
//  Truth Table:
//      A => this bitmap
//      B => pmbmap
//
//      A B | A'B'
//     ===========
//      0 0 | 0 0
//      0 1 | 0 1
//      1 0 | x x  - undefined (will assert)
//      1 1 | 1 0
//
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrFilterUnset(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrFilterUnset");
    Assert(pmbmap);

    HRESULT hr         = S_OK;
    DWORD   cDWORDs    = cGetNumDWORDS(cBits);
    BOOL    fDone      = FALSE;
    DWORD   i;
    DWORD   dwOtherNew;
    DWORD   dwOtherOld;

    for (i = 0; i < cDWORDs; i++)
    {
        fDone = FALSE;

        while (!fDone)
        {
            dwOtherNew = pmbmap->m_rgdwBitMap[i];
            dwOtherOld = dwOtherNew;

            if (m_rgdwBitMap[i] & ~dwOtherNew)
            {
                //this bitmap is NOT a subset of the given bitmap
                _ASSERT(0); //caller's mistake
                hr = E_FAIL;
                goto Exit;
            }

            dwOtherNew ^= m_rgdwBitMap[i];   //unset

            if (fInterlockedDWORDCompareExchange(&(pmbmap->m_rgdwBitMap[i]),
                        dwOtherNew, dwOtherOld))
            {
                fDone = TRUE;
            }
        }
    }


  Exit:
    TraceFunctLeave();
    return hr;
}


//---[ CMsgBitMap::FTestAndSet ]-----------------------------------------------
//
//
//  Description:
//      An Interlocked function to test and set a bit on the this bit map.
//      Looks for the bit that is set in the given bitmap, if that bit is also
//      1 in this bitmap, returns FALSE.  If that bit is 0, it sets it to 1,
//      and returns TRUE.
//
//      NOTE: Results are UNDEFINED if there is more than 1 bit set in pmbmap.
//  Parameters:
//      cBits       # of bits in bitmap
//      pmbmap      Bitmap to check against
//  Returns:
//      TRUE if the corresponding bit was 0 (and is now set to 1)
//      FALSE if the corresponding bit was already1
//  History:
//      11/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CMsgBitMap::FTestAndSet(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    BOOL    fRet      = FALSE;
    DWORD   cDWORDs   = cGetNumDWORDS(cBits);
    BOOL    fDone     = FALSE;
    DWORD   dwThisNew = 0;
    DWORD   dwThisOld = 0;
    DWORD   i         = 0;

    for (i = 0; i < cDWORDs; i++)
    {

        if (pmbmap->m_rgdwBitMap[i])
        {
            //We've hit the bit in the given bitmap

            //See if bit is already set
            if (pmbmap->m_rgdwBitMap[i] & m_rgdwBitMap[i])
                break;

            while (!fDone)
            {
                dwThisOld = m_rgdwBitMap[i];
                dwThisNew = dwThisOld | pmbmap->m_rgdwBitMap[i];

                //See if another thread has set it
                if (dwThisOld & pmbmap->m_rgdwBitMap[i])
                    break;

                //Only 1 bit should be set on given bitmap
                _ASSERT((dwThisOld | pmbmap->m_rgdwBitMap[i]) ==
                        (dwThisOld ^ pmbmap->m_rgdwBitMap[i]));

                //Try to set bit
                if (fInterlockedDWORDCompareExchange(&(m_rgdwBitMap[i]),
                            dwThisNew, dwThisOld))
                {
                    fDone = TRUE;
                    fRet = TRUE;
                }
            }

            break;
        }
    }

    return fRet;
}

//---[ CMsgBitMap::FTest ]-----------------------------------------------------
//
//
//  Description:
//      Tests this bitmap against a single bit in the given bitmap
//      NOTE: Results are UNDEFINED if there is more than 1 bit set in pmbmap.
//  Parameters:
//      cBits       # of bits in bitmap
//      pmbmap      Bitmap to check against
//  Returns:
//      TRUE if the corresponding bit is 1
//      FALSE if the corresponding bit is 0
//  History:
//      11/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CMsgBitMap::FTest(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    BOOL    fRet      = FALSE;
    DWORD   cDWORDs   = cGetNumDWORDS(cBits);
    DWORD   i         = 0;

    for (i = 0; i < cDWORDs; i++)
    {
        //See if we've hit the bit in the given bitmap
        if (pmbmap->m_rgdwBitMap[i])
        {
            //See if bit is already set
            if (pmbmap->m_rgdwBitMap[i] & m_rgdwBitMap[i])
                fRet = TRUE;

            break;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asyncq.inl ===
//-----------------------------------------------------------------------------
//
//
//  File: asyncq.inl
//
//  Description:  Implementation of templated CAsyncQueue class.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/17/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __ASYNCQ_INL__
#define __ASYNCQ_INL__

#include "asyncq.h"
#include "fifoqimp.h"
#include "aqinst.h"

//---[ CAsyncQueueBase::CAsyncQueueBase ]--------------------------------------
//
//
//  Description:
//      Default constructor for CAsyncQueueBase class
//  Parameters:
//      dwTemplateSignature     - Signature used to identify the type of
//                                templated super class this is associated with
//                                when an ATQ completion routine is called
//  Returns:
//      -
//  History:
//      7/18/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAsyncQueueBase::CAsyncQueueBase(DWORD dwTemplateSignature) :
    CStateMachineBase(ASYNC_QUEUE_STATUS_NORMAL, ASYNC_QUEUE_STATE_MACHINE_SIG)
{
    m_dwSignature = ASYNC_QUEUE_SIG;
    m_dwTemplateSignature = dwTemplateSignature;
    m_cMaxSyncThreads = 0;
    m_cCurrentSyncThreads = 0;
    m_cCurrentAsyncThreads = 0;
    m_cItemsPending = 0;
    m_cItemsPerATQThread = 0;
    m_cItemsPerSyncThread = 0;
    m_cScheduledWorkItems = 0;
    m_cCurrentCompletionThreads = 0;
    m_cCompletionThreadsRequested = 0;
    m_pvContext = NULL;
    m_pAtqContext = NULL;
    m_hAtqHandle = INVALID_SOCKET;
    m_cTotalAsyncCompletionThreads = 0;
    m_cTotalSyncCompletionThreads = 0;
    m_cTotalShortCircuitThreads = 0;
    m_cPendingAsyncCompletions = 0;
    m_cMaxPendingAsyncCompletions = 0;
    m_cThreadsNeeded = 0;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::CAsyncQueue<PQDATA, TEMPLATE_SIG> ]--
//
//
//  Description:
//      Default constructor for CAsyncQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncQueue<PQDATA, TEMPLATE_SIG>::CAsyncQueue<PQDATA, TEMPLATE_SIG>() :
    CAsyncQueueBase(TEMPLATE_SIG)
{
    m_pfnQueueCompletion = NULL;
    m_pfnQueueFailure = NULL;
    m_pfnFailedItem = NULL;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::~CAsyncQueue<PQDATA, TEMPLATE_SIG> ]--
//
//
//  Description:
//      Default desctructor for CAsyncQueue.  Call Queue-mapping function to
//      to clear out the queue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncQueue<PQDATA, TEMPLATE_SIG>::~CAsyncQueue<PQDATA, TEMPLATE_SIG>()
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue<PQDATA, TEMPLATE_SIG>::~CAsyncQueue<PQDATA, TEMPLATE_SIG>");
    HRESULT hr = S_OK;
    DWORD   cItems = 0;

    //
    //  If this is off, then we may not actually be processing anything
    //  (if we have hit the limit).
    //
    _ASSERT(!m_cPendingAsyncCompletions);

    hr = m_fqQueue.HrMapFn(HrClearQueueMapFn, m_pvContext, &cItems);
    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "ERROR: Unable to Cleanup CAsyncQueue - hr 0x%08X", hr);
    else
        DecrementPendingCount(-((LONG) cItems));

    if (m_pAtqContext)
    {
        //Freeing context will close handle
        AtqFreeContext(m_pAtqContext, FALSE);
    }

    TraceFunctLeave();
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrInitialize ]-----------------------
//
//
//  Description:
//      Initializes CAsyncQueue with the neccessary information
//  Parameters:
//      cMaxSyncThreads     The maximum # of threads that will be "stolen" from
//                          the enqueuing threads and used to process items
//                          from the front of the queue
//      cItemsPerATQThread  Max # of items an ATQ thread will process from the
//                          front of the queue before being released
//      cItemsPerSyncThread Max # of items a stolen sync thread will process
//                          from the fron of the queeu before being released
//      pvContext           Context pass to completion routines and queue-map
//                          functions (can be NULL)
//      pfnQueueCompletion  Function called to process a single item from
//                          the front of the queue.
//      pfnFailedItem       Function called if an internal resource failure
//                          prevents an item from being queued or requeued
//      pfnQueueFailure     Function called to walk the queues when the
//                          completion function fails
//
//  Note:
//      Queue completion functino has the following prototype
//              BOOL (*QCOMPFN)(PQDATA pqData, PVOID pvContext)
//      Returns TRUE if the item has been handles
//              FALSE if the item needs to be requeued
//
//  Returns:
//      S_OK on success
//      E_INVALIDARG if the params are invalid:
//          cItemsPerThread is 0
//          pfnQueueCompletion is NULL
//  History:
//      7/17/98 - MikeSwa Created
//      2/3/99 - MikeSwa Added pfnFailedItem
//      12/11/2000 - MikeSwa Added t-toddc's state table work
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrInitialize(
                DWORD cMaxSyncThreads,
                DWORD cItemsPerATQThread,
                DWORD cItemsPerSyncThread,
                PVOID pvContext,
                QCOMPFN pfnQueueCompletion,
                QCOMPFN pfnFailedItem,
                typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFailure,
                DWORD cMaxPendingAsyncCompletions)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrInitialize");
    HRESULT hr = S_OK;

    ThreadPoolInitialize();

    if (!cItemsPerATQThread || !cItemsPerSyncThread || !pfnQueueCompletion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    m_cMaxSyncThreads = cMaxSyncThreads;
    m_cItemsPerATQThread = (DWORD) cItemsPerATQThread;
    m_cItemsPerSyncThread = (DWORD) cItemsPerSyncThread;
    _ASSERT(m_cItemsPerATQThread > 0);
    m_pvContext = pvContext;
    m_pfnFailedItem = pfnFailedItem;
    m_pfnQueueCompletion = pfnQueueCompletion;
    m_pfnQueueFailure = pfnQueueFailure;
    m_cMaxPendingAsyncCompletions = cMaxPendingAsyncCompletions;

    //Create a dummy socket to handle async completion
    m_hAtqHandle = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == m_hAtqHandle)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        ErrorTrace((LPARAM) this, "ERROR socket() failed - hr 0x%08X", hr);
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        goto Exit;
    }

    //associate socket handle with ATQ
    if (!AtqAddAsyncHandle(&m_pAtqContext, NULL, this,
            AsyncQueueAtqCompletion, INFINITE, (HANDLE) m_hAtqHandle))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "ERROR AtqAddAsyncHandle failed - hr 0x%08X", hr);
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        goto Exit;
    }

    // make sure state transition table is valid
    if (!fValidateStateTable())
    {
        _ASSERT(0 && "State Transition Table Invalid");
        hr = E_FAIL;
        goto Exit;
    }

  Exit:
    if (FAILED(hr))
        ThreadPoolDeinitialize();

    TraceFunctLeave();
    return hr;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize ]---------------------
//
//
//  Description:
//      Walks queues with given function for shutdown
//  Parameters:
//      pfnQueueShutdown    Queue-mapping function called on shutdown to
//                          clean queues.  If NULL, it will substitute
//                          HrClearQueueMapFn which walks the queues and
//                          releases all PQDATA in it
//      paqinst             Shutdown context with server stop hint function
//  Returns:
//      S_OK on success
//  History:
//      7/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize(
                              typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueShutdown,
                              CAQSvrInst *paqinst)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize");
    HRESULT hr = S_OK;
    _ASSERT(paqinst);
    DWORD   cItems = 0;

    //shutdown action has occurred.
    dwGetNextState(ASYNC_QUEUE_ACTION_SHUTDOWN);

    //wait until all requested threads have returned
    while (m_cCurrentCompletionThreads || m_cCompletionThreadsRequested)
    {
        if (paqinst)
            paqinst->ServerStopHintFunction();
        Sleep(1000);
    }

    //map shutdown function
    hr = m_fqQueue.HrMapFn(pfnQueueShutdown, paqinst, &cItems);
    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "ERROR: Unable to Cleanup CAsyncQueue - hr 0x%08X", hr);
    else
        DecrementPendingCount(-((LONG)cItems));

    ThreadPoolDeinitialize();
    TraceFunctLeave();
    return hr;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest ]---------------------
//
//
//  Description:
//      Queues request for async completion.
//  Parameters:
//      pqdata          Data to pass to completion function
//      fRetry          TRUE => Put item at front of queue (and don't use this
//                              thread to process it).
//                      FALSE => Queue normaly
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if queue-related resources could not be allocated
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest(PQDATA pqdata,
                                                          BOOL fRetry)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest");
    HRESULT hr = S_OK;
    DWORD   cCurrentSyncThreads;

    _ASSERT(m_pfnQueueCompletion);

    cCurrentSyncThreads = InterlockedIncrement((PLONG) &m_cCurrentSyncThreads);

    //If we are shutting down... do not bother to queue the message
    if (fInShutdown())
        goto Exit;

    IncrementPendingCount();
    //Only enqueue if there are others waiting
    if (fRetry ||  (m_cItemsPending > 1) ||
        (m_cMaxSyncThreads < cCurrentSyncThreads) || fShouldStopProcessing())
    {
        //Enqueue data
        if (fRetry && g_fRetryAtFrontOfAsyncQueue)
            hr = m_fqQueue.HrRequeue(pqdata);
        else
            hr = m_fqQueue.HrEnqueue(pqdata);

        if (FAILED(hr))
        {
            DecrementPendingCount();
            ErrorTrace((LPARAM) this, "ERROR: Unable to queue item for async handling - hr 0x%08X", hr);
            goto Exit;
        }

        //see if we can steal this thread thread to process queue entries
        //Only steal a thread if the following conditions are met:
        //  - We have not exceeded our sync thread limit
        //  - There are no async threads that could be doing the work
        //  - We are not retrying something
        if (!fRetry && !fShouldStopProcessing() &&
            (m_cMaxSyncThreads >= cCurrentSyncThreads) &&
            !m_cCurrentAsyncThreads && !m_cCompletionThreadsRequested)
        {
            //Make sure there is work to be done
            if (fThreadNeededAndMarkWorkPending(TRUE))
            {
                //Steal thread
                StartThreadCompletionRoutine(TRUE);
            }
        }
    }
    else
    {
        //Steal this thread thread to proccess this item w/o hitting queue
        DecrementPendingCount();
        InterlockedIncrement((PLONG) &m_cTotalShortCircuitThreads);

        //Process Item & handle failure case
        if (!m_pfnQueueCompletion(pqdata, m_pvContext))
        {
            fHandleCompletionFailure(pqdata);
        }
    }

    //Always make sure there are enough threads to do the work (unless we are retrying)
    if (!fRetry)
        RequestCompletionThreadIfNeeded();

  Exit:
    InterlockedDecrement((PLONG) &m_cCurrentSyncThreads);
    return hr;
    TraceFunctLeave();
}


//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::ProcessSingleQueueItem ]-------------
//
//
//  Description:
//      Processes a single item at the head of the queue.  All failures need
//      to be handled internally
//  Parameters:
//      -
//  Returns:
//      SUCCEEDED(hr)) on success and we should continue
//      AQUEUE_E_QUEUE_EMPTY when there are no more items to process
//      E_FAIL if the completion call failed
//      Error code from HrDequeue on other failure.
//  History:
//      7/17/98 - MikeSwa Created
//      2/3/2000 - MikeSwa Modified to return an HRESULT
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrProcessSingleQueueItem()
{
    HRESULT hr = S_OK;
    PQDATA  pqdata = NULL;
    DWORD   cItemsLeft = 0;
    BOOL    fSucceeded = TRUE;

    hr = m_fqQueue.HrDequeue(&pqdata);
    if (SUCCEEDED(hr))
    {
        DecrementPendingCount();

        //We have data item - now process it
        fSucceeded = m_pfnQueueCompletion(pqdata, m_pvContext);

        if (fSucceeded || fHandleCompletionFailure(pqdata))
        {
            //Request another thread if
            // - we had at least 1 success.
            // - handle failure told use to continue
            RequestCompletionThreadIfNeeded();

            //If fHandleCompletionFailure said we succeeded, then continue
            fSucceeded = TRUE;

        }
        pqdata->Release();
    }

    //
    //  If the dequeue succeeded but the completion failed, then return E_FAIL
    //
    if (!fSucceeded && (SUCCEEDED(hr)))
        hr = E_FAIL;

    return hr;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::StartThreadCompletionRoutine ]-------
//
//
//  Description:
//      Starting point to completion threads.  Each thread will attempt to
//      process m_cItemsPerATQThread items from the front of the queue
//  Parameters:
//      fSync   TRUE if a sync thread, FALSE... this is an ATQ thread
//  Returns:
//      -
//  History:
//      7/17/98 - MikeSwa Created
//      2/3/2000 - MikeSwa Modified to fix window that would leave items
//                  "stranded" in queue.
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::StartThreadCompletionRoutine(BOOL fSync)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue::StartThreadCompletionRoutine");
    DWORD   cItemsToProcess     = (DWORD) (fSync ? m_cItemsPerSyncThread: m_cItemsPerATQThread);
    HRESULT hr                  = S_OK;
    DWORD   dwInitialTickCount  = 0;
    DWORD   dwCurrentTickCount  = 0;
    BOOL    fRequestNewThread   = TRUE;

    InterlockedIncrement((PLONG) &m_cCurrentCompletionThreads);

    if (fSync)
        InterlockedIncrement((PLONG) &m_cTotalSyncCompletionThreads);

    // obtain tick count immediately before processing
    dwInitialTickCount = GetTickCount();

    //process items until we fail or are done
    while (cItemsToProcess) { // all cases for quitting are handled in the loop

        hr = HrProcessSingleQueueItem();

        // If we fail to process an item we will stop working in this thread
        if (FAILED(hr)) {

            // We failed, do not request a thread to replace this one unless
            // the failure was "AQUEUE_E_QUEUE_EMPTY" in which case we need
            // to try another thread in case an item is added between here
            // and this thread's termination.
            if (hr != AQUEUE_E_QUEUE_EMPTY) {
                fRequestNewThread = FALSE;

                InterlockedIncrement((PLONG)&s_cThreadCompletion_Failure);
            }
            else {
                InterlockedIncrement((PLONG)&s_cThreadCompletion_QueueEmpty);
            }

            break;
        }

        // A note about cItemsToProcess and m_cScheduledWorkItems : It is
        // important that when this function completes we have decremented the
        // original value of cItemsToProcess from m_cScheduledWorkItems because
        // that is the number that was added when this thread was requested.  We
        // will either subtract them here one by one (items that were processed)
        // or at the end (items that were not processed) but what is most
        // important is that the exact number is subtracted when the thread
        // completes (to maintain the validity of m_cScheduledWorkItems)

        // Decrement number of items to process and scheduled work count
        cItemsToProcess--;
        InterlockedDecrement((PLONG)&m_cScheduledWorkItems);

        // If we have processed all our scheduled items - drop out now
        if (!cItemsToProcess) {
            InterlockedIncrement((PLONG)&s_cThreadCompletion_CompletedScheduledItems);
            break;
        }

        // If there's nothing left in the queue - drop out now
        if (!m_cItemsPending) {
            InterlockedIncrement((PLONG)&s_cThreadCompletion_QueueEmpty);
            break;
        }

        // If we have been paused - drop out now
        if (fShouldStopProcessing()){
            InterlockedIncrement((PLONG)&s_cThreadCompletion_Paused);
            break;
        }

        // If we are using too many threads - drop out now
        if (!fIsThreadCountAcceptable()) {
            InterlockedIncrement((PLONG)&s_cThreadCompletion_UnacceptableThreadCount);
            break;
        }

        // If we have been processing for too long - drop out now
        dwCurrentTickCount = GetTickCount();
        if (dwCurrentTickCount - dwInitialTickCount > g_cMaxTicksPerATQThread) {
            InterlockedIncrement((PLONG)&s_cThreadCompletion_Timeout);
            break;
        }
    }

    // Subtract from the scheduled item count the number of items we did not process
    if (cItemsToProcess) {
        InterlockedExchangeAdd((PLONG)&m_cScheduledWorkItems, -((LONG)cItemsToProcess));
    }

    InterlockedDecrement((PLONG) &m_cCurrentCompletionThreads);

    // Always request another thread when completing unless we failed - we will let
    // the ThreadsNeeded logic handle throttling how many threads act on this queue
    // at a time.
    if (fRequestNewThread)
        RequestCompletionThreadIfNeeded();

    TraceFunctLeave();
}


//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::fThreadNeededAndMarkWorkPending ]----
//
//
//  Description:
//      Determines if another worker thread is needed, and adjusts
//      m_cScheduledWorkItems accordingly.  Callee is repsonsible for determining
//      if a thread can be allocated.
//  Parameters:
//      fSync   TRUE if checking for a sync thread, FALSE... checking for an ATQ thread
//  Returns:
//      TRUE if another thread is needed (and member values adjusted accordingly)
//      FALSE if another thread is not needed to do work
//  History:
//      7/18/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL CAsyncQueue<PQDATA, TEMPLATE_SIG>::fThreadNeededAndMarkWorkPending(BOOL fSync)
{
    if (fInShutdown())
    {
        _ASSERT(!fSync && "CAQSvrInst should not call now!!!");
        return FALSE;
    }
    else if (fShouldStopProcessing())
    {
        return FALSE;
    }
    else if (m_cScheduledWorkItems < m_cItemsPending)
    {
        // There are unscheduled items - we need a thread

        // Schedule the right number of items
        InterlockedExchangeAdd((PLONG)&m_cScheduledWorkItems,
                (fSync ? m_cItemsPerSyncThread : m_cItemsPerATQThread));

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::RequestCompletionThreadIfNeeded ]----
//
//
//  Description:
//      Requests a queue completion thread if needed.  Uses ATQ and handle
//      allocated to POQS for another thread.  Makes sure that we do not
//      exceed the max # of async threads.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/18/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::RequestCompletionThreadIfNeeded()
{
    DWORD cThreadsRequested = m_cCompletionThreadsRequested;
    BOOL    fThreadRequested = FALSE;

    // Can we have a thread?
    InterlockedIncrement((PLONG) &m_cCompletionThreadsRequested);
    if (fIsThreadCountAcceptable()) {

        // Do we want a thread?
        if (fThreadNeededAndMarkWorkPending(FALSE)) {

            // Request a thread
            fThreadRequested = TRUE;
            AtqPostCompletionStatus(m_pAtqContext, GetTickCount());
        }
    }

    // If we didn't request a thread, decrement the request count
    if (!fThreadRequested)
        InterlockedDecrement((PLONG) &m_cCompletionThreadsRequested);
}


//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::fHandleCompletionFailure ]------------
//
//
//  Description:
//      Called when async completion function returns false... handles requeuing
//      data and record-keeping.  Needs to handle the following:
//  Parameters:
//      pqdata      - Data that triggered failure
//  Returns:
//      -
//  History:
//      7/18/98 - MikeSwa Created
//      8/14/98 - MikeSwa Modified to add failure handling
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL CAsyncQueue<PQDATA, TEMPLATE_SIG>::fHandleCompletionFailure(PQDATA pqdata)
{
    HRESULT hr;
    DWORD   cItemsRemoved = 0;

    if (fInShutdown())
        return FALSE;

    if (g_fRetryAtFrontOfAsyncQueue)
        hr = m_fqQueue.HrRequeue(pqdata);
    else
        hr = m_fqQueue.HrEnqueue(pqdata);

    if (SUCCEEDED(hr))
    {
        IncrementPendingCount();
    }
    else
        HandleDroppedItem(pqdata);


    //call failure routine (if present)
    if (m_pfnQueueFailure)
    {
        hr = m_fqQueue.HrMapFn(m_pfnQueueFailure, m_pvContext, &cItemsRemoved);
        if (SUCCEEDED(hr))
        {
            //Adjust appropriate counters
            DecrementPendingCount(-((LONG)cItemsRemoved));
        }
    }

    return FALSE;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HandleDroppedItem ]------------------
//
//
//  Description:
//      Handles a dropped PQDATA by calling the callback provided at start
//      up
//  Parameters:
//      pqData
//  Returns:
//
//  History:
//      2/3/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::HandleDroppedItem(PQDATA pqData)
{
    if (m_pfnFailedItem)
        m_pfnFailedItem(pqData, m_pvContext);
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrMapFn ]----------------------------
//
//
//  Description:
//      Calls a function on every message in the queue
//  Parameters:
//      IN  pfnQueueFn      Function to call for every message
//      IN  pvContext       Context passed to completion function
//  Returns:
//      S_OK on success
//      Error code from CFifoQueue<PQDATA>::HrMapFn
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrMapFn(
                                      typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn,
                                      PVOID pvContext)
{
    DWORD cItems = 0;
    HRESULT hr = S_OK;

    hr = m_fqQueue.HrMapFn(pfnQueueFn, pvContext, &cItems);
    if (SUCCEEDED(hr))
    {
        DecrementPendingCount(-((LONG)cItems));
    }

    return hr;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::UnpauseQueue ]-----------------------
//
//
//  Description:
//      Unpauses a queue by unsetting the ASYNC_QUEUE_STATUS_PAUSED bit and
//      requesting threads if neccessary.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/24/2000 - MikeSwa Created
//      6/12/2000 - t-toodc modified to use state machine functionality
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::UnpauseQueue()
{
    BOOL fStopped = fShouldStopProcessing();
    dwGetNextState(ASYNC_QUEUE_ACTION_UNPAUSE);

    //
    //  The queue *was* paused.  We should make sure that we reqest threads
    //  if there are items to process.
    //
    if (fStopped && !fShouldStopProcessing()) {
        UpdateThreadsNeeded();
        RequestCompletionThreadIfNeeded();
    }
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::ThawQueue ]-----------------------
//
//  Description:
//      Thaws a queue and sets the next state, requesting a completion thread
//      if necessary
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/24/2000 - MikeSwa Created
//      6/12/2000 - t-toodc modified to use state machine functionality
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::ThawQueue()
{
    BOOL fStopped = fShouldStopProcessing();
    dwGetNextState(ASYNC_QUEUE_ACTION_THAW);

    //
    //  The queue *was* frozen.  We should make sure that we reqest threads
    //  if there are items to process.
    //
    if (fStopped && !fShouldStopProcessing())
    {
        // Update threads needed, we need threads again
        UpdateThreadsNeeded();
        RequestCompletionThreadIfNeeded();
    }
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::IncPendingAsyncCompletions ]---------
//
//
//  Description:
//      Increments the pending async completion count.  If the async queue
//      feeds into something that may complete async (like CatMsg).  In this
//      case, we may want to throttle the number of outstanding completions
//      we have (i.e.- too avoid having too many active messages)
//
//      If we have hit our limit, then this call with pause the queue.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/24/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::IncPendingAsyncCompletions()
{
    InterlockedIncrement((PLONG) &m_cPendingAsyncCompletions);

    //
    //  Check against limit if we have one
    //
    if (m_cMaxPendingAsyncCompletions &&
        (m_cPendingAsyncCompletions > m_cMaxPendingAsyncCompletions))
    {
        PauseQueue();
    }
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::DecPendingAsyncCompletions ]---------
//
//
//  Description:
//      Decrements the pending async completion count.  If we drop below our
//      threshold, then we will unpause the queue.
//  Parameters:
//
//  Returns:
//
//  History:
//      1/24/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::DecPendingAsyncCompletions()
{
    InterlockedDecrement((PLONG) &m_cPendingAsyncCompletions);

    if (m_cMaxPendingAsyncCompletions &&
        (m_cPendingAsyncCompletions < m_cMaxPendingAsyncCompletions))
    {
        UnpauseQueue();
    }
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::fNoPendingAsyncCompletions ]---------
//
//
//  Description:
//      Are there any pending async completions?
//  Parameters:
//
//  Returns:
//      BOOL
//
//  History:
//      11/01/2000 - Awetmore created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL CAsyncQueue<PQDATA, TEMPLATE_SIG>::fNoPendingAsyncCompletions()
{
    return (m_cPendingAsyncCompletions == 0);
}



//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::dwQueueAdminLinkGetLinkState ]-------
//
//
//  Description:
//      Gets the Queue admin state of this queue.  This is different depending
//      on the type of async queue this is (normal vs. retry).
//  Parameters:
//      -
//  Returns:
//      returns the QAPI link flags describing what state this link is in
//  History:
//      3/3/2000 - MikeSwa Created (moved from mailadmq.cpp)
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
DWORD  CAsyncQueue<PQDATA, TEMPLATE_SIG>::dwQueueAdminLinkGetLinkState()
{
    //
    //Queue is in retry if there are items pending and no threads are
    //processing them or it is active if there are items pending and
    //threads processing them. If there are no items then it is ready.
    //
    if (fIsFrozen())
        return LI_FROZEN;
    else if (fIsPaused())
        return LI_READY;
    else if (0 != cGetItemsPending() && 0 == dwGetTotalThreads())
        return LI_RETRY;
    else if (0 != m_pammq->cGetItemsPending())
        return LI_ACTIVE;
    else
        return LI_READY;
}

//---[ CAsyncQueueBase::UpdateThreadsNeeded ]----------------------------------
//
//
//  Description:
//      Update the threads needed counter locally and globally.  This thread
//      need is only the need for ASYNC threads but does take into account the
//      fact that some items may already be scheduled for sync threads.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      11/16/2000 - dbraun - created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void  CAsyncQueue<PQDATA, TEMPLATE_SIG>::UpdateThreadsNeeded()
{
    DWORD   cNewThreadsNeeded = 0;
    DWORD   cOldThreadsNeeded = 0;
    LONG    lUnscheduledItems = 0; // may be negative if we over-committed

    // We only get threads if we are not paused and we have items
    if(!fShouldStopProcessing() && m_cItemsPending) {

        // We always need the threads we have (or have requested)
        cNewThreadsNeeded = m_cCompletionThreadsRequested + m_cCurrentCompletionThreads;

        // Number of pending items that we have not already scheduled threads for
        lUnscheduledItems = m_cItemsPending - m_cScheduledWorkItems;

        // If we have unscheduled items, we need some more threads than we have
        if (lUnscheduledItems > 0) {
            _ASSERT(m_cItemsPerATQThread);
            cNewThreadsNeeded += (lUnscheduledItems / m_cItemsPerATQThread) + 1;
        }
    }

    if (cNewThreadsNeeded == m_cThreadsNeeded)
        return; // nothing to do here ...

    cOldThreadsNeeded = InterlockedExchange ((LPLONG) &m_cThreadsNeeded, cNewThreadsNeeded);
    InterlockedExchangeAdd((LPLONG) &g_cTotalThreadsNeeded, cNewThreadsNeeded - cOldThreadsNeeded);
}

//---[ CAsyncQueueBase::fIsThreadCountAcceptable ]-----------------------------
//
//
//  Description:
//      Checks whether the current thread count for this queue is acceptable.
//      This is used to release threads and to allow new threads to start on
//      this queue.
//  Parameters:
//      -
//  Returns:
//      TRUE : Count is acceptable
//  History:
//      11/16/2000 - dbraun - created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL  CAsyncQueue<PQDATA, TEMPLATE_SIG>::fIsThreadCountAcceptable()
{
    // Get these values once to make sure we are consistent and to prevent div/0
    DWORD cGlobalThreadsNeeded      = g_cTotalThreadsNeeded;
    DWORD cThreadsNeeded            = m_cThreadsNeeded;
    DWORD cThreadsAllowed           = 0;
    DWORD cThreadsActiveAndPending  = m_cCompletionThreadsRequested + m_cCurrentCompletionThreads;

    // We are only allowed threads if we are not paused and we have items pending
    if(!fShouldStopProcessing() && m_cItemsPending) {

        // Below we calculate how many threads are allowed.  This can be more or less than
        // the number of threads needed and is only used to limit thread counts, it does
        // not mean that we will actually use the total threads allowed.

        // The number of threads allowed is based on the max threads and how many threads
        // this queue needs when compared with the rest of the queues that want threads
        if (cGlobalThreadsNeeded) {
            cThreadsAllowed = s_cDefaultMaxAsyncThreads * cThreadsNeeded / cGlobalThreadsNeeded;
        }

        // One thread is always acceptable
        if (!cThreadsAllowed) {
            cThreadsAllowed = 1;
        }
    }

    return (cThreadsAllowed >= cThreadsActiveAndPending);
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::CAsyncRetryQueue ]--------------
//
//
//  Description:
//      Default constructor for CAsyncRetryQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::CAsyncRetryQueue()
{
    m_dwRetrySignature = ASYNC_RETRY_QUEUE_SIG;
    m_cRetryItems = 0;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::~CAsyncRetryQueue ]-------------
//
//
//  Description:
//      Default destructor for CAsyncRetryQueue.  Walks retry queue to release
//      items on it.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::~CAsyncRetryQueue()
{
    m_fqRetryQueue.HrMapFn(HrClearQueueMapFn, m_pvContext, NULL);
}


//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize ]----------------
//
//
//  Description:
//      Walks queues with given function for shutdown
//  Parameters:
//      pfnQueueShutdown    Queue-mapping function called on shutdown to
//                          clean queues.  If NULL, it will substitute
//                          HrClearQueueMapFn which walks the queues and
//                          releases all PQDATA in it
//      paqinst             Shutdown context with server stop hint function
//  Returns:
//      S_OK on success
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize(
                            typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueShutdown,
                            CAQSvrInst *paqinst)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize");
    HRESULT hr = S_OK;
    DWORD   cItems = 0;
    _ASSERT(paqinst);

    CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize(pfnQueueShutdown,
                                                          paqinst);

    //map shutdown function
    hr = m_fqRetryQueue.HrMapFn(pfnQueueShutdown, paqinst, &cItems);
    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "ERROR: Unable to Cleanup CAsyncQueue - hr 0x%08X", hr);
    else
        dwInterlockedAddSubtractDWORD(&m_cRetryItems, cItems, FALSE);


    TraceFunctLeave();
    return hr;

}


//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::fHandleCompletionFailure ]------
//
//
//  Description:
//      Called when async completion function returns false... handles requeuing
//      data to the retry queue
//  Parameters:
//      pqdata      - Data that triggered failure
//  Returns:
//      -
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::fHandleCompletionFailure(PQDATA pqdata)
{
    HRESULT hr;
    DWORD   cItemsRemoved = 0;

    if (fInShutdown())
        return FALSE;

    //Requeue failed item to retry queue... a possible interesting thing to do
    //here would be to run the failed item through the failure function
    //(without the queue) to generate DSNs and see if the item actually need to
    //be queues.
    hr = m_fqRetryQueue.HrRequeue(pqdata);
    if (SUCCEEDED(hr))
        InterlockedIncrement((PLONG) &m_cRetryItems);
    else
        HandleDroppedItem(pqdata);

    return TRUE;

}


//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest ]----------------
//
//
//  Description:
//      Queue a request for a retry queue.
//  Parameters:
//      pqdata          Data to pass to completion function
//      fRetry          TRUE => Put item in retry queue until queue is kicked
//                      FALSE => Queue normaly
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if queue-related resources could not be allocated
//  History:
//      3/3/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest(PQDATA pqdata,
                                                               BOOL fRetry)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncRetryQueue<>::HrQueueRequest");
    HRESULT hr = S_OK;

    //
    //  Handle as failure if retry (will put the item in the retry queue).
    //  Otherwise pass to base implementation (queue to normal asyncq).
    //
    if (fRetry)
        fHandleCompletionFailure(pqdata);
    else
        hr = CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest(pqdata, fRetry);

    TraceFunctLeave();
    return hr;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrMapFn ]-----------------------
//
//
//  Description:
//      Calls a function on every message in the queue
//  Parameters:
//      IN  pfnQueueFn      Function to call for every message
//      IN  pvContext       Context passed to completion function
//  Returns:
//      S_OK on success
//      Error code from CFifoQueue<PQDATA>::HrMapFn
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrMapFn(
                                       typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn,
                                       PVOID pvContext)
{
    HRESULT hr = S_OK;

    hr = HrMapFnBaseQueue(pfnQueueFn, pvContext);
    if (FAILED(hr))
        goto Exit;

    hr = HrMapFnRetryQueue(pfnQueueFn, pvContext);
    if (FAILED(hr))
        goto Exit;

  Exit:
    return hr;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrMapFnBaseQueue ]--------------
//
//
//  Description:
//      Calls a function on every message in the base (non-retry) queue
//  Parameters:
//      IN  pfnQueueFn      Function to call for every message
//      IN  pvContext       Context passed to completion function
//  Returns:
//      S_OK on success
//      Error code from CFifoQueue<PQDATA>::HrMapFn
//  History:
//      2/23/99 - MikeSwa Created
//      1/10/2001 - MikeSwa Modified from HrMapFn
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrMapFnBaseQueue(
                                       typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn,
                                       PVOID pvContext)
{
    HRESULT hr = S_OK;
    hr = CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrMapFn(pfnQueueFn, pvContext);
    return hr;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrMapFnRetryQueue ]-------------
//
//
//  Description:
//      Calls a function on every message in the queue retry
//  Parameters:
//      IN  pfnQueueFn      Function to call for every message
//      IN  pvContext       Context passed to completion function
//  Returns:
//      S_OK on success
//      Error code from CFifoQueue<PQDATA>::HrMapFn
//  History:
//      2/23/99 - MikeSwa Created
//      1/10/2001 - MikeSwa Modified from HrMapFn
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrMapFnRetryQueue(
                                       typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn,
                                       PVOID pvContext)
{
    DWORD cItems = 0;
    HRESULT hr = S_OK;

    hr = m_fqRetryQueue.HrMapFn(pfnQueueFn, pvContext, &cItems);
    if (SUCCEEDED(hr))
        dwInterlockedAddSubtractDWORD(&m_cRetryItems, cItems, FALSE);

    return hr;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::MergeRetryQueue ]---------------
//
//
//  Description:
//      Merges retry queue into normal queue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::MergeRetryQueue()
{
    DWORD   cItemsRemoved = 0;
    PQDATA  pqData = NULL;
    HRESULT hr = S_OK;

    if (fInShutdown())
        return;

    //call failure routine (if present)
    if (m_pfnQueueFailure)
    {
        hr = m_fqRetryQueue.HrMapFn(m_pfnQueueFailure, m_pvContext, &cItemsRemoved);
        if (SUCCEEDED(hr))
        {
            //Adjust appropriate counters
            InterlockedExchangeAdd((PLONG) &m_cRetryItems, -((LONG) cItemsRemoved));
        }
    }

    //Now remerge queue
    hr = S_OK;
    while (SUCCEEDED(hr))
    {
        pqData = NULL;
        hr = m_fqRetryQueue.HrDequeue(&pqData);

        if (FAILED(hr))
            break;

        _ASSERT(pqData);

        InterlockedDecrement((PLONG) &m_cRetryItems);

        //Queue request as retry so we know thread will not be stolen
        hr = CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest(pqData, TRUE);
        if (FAILED(hr))
            HandleDroppedItem(pqData);

        pqData->Release();
    }
}


//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::dwQueueAdminLinkGetLinkState ]--
//
//
//  Description:
//      Gets the Queue admin state of this queue.  This is different depending
//      on the type of async queue this is (normal vs. retry).
//  Parameters:
//      -
//  Returns:
//      returns the QAPI link flags describing what state this link is in
//  History:
//      3/3/2000 - MikeSwa Created (moved from localq.cpp)
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
DWORD  CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::dwQueueAdminLinkGetLinkState()
{
    //If we items in retry and others... mark it in retry
    //If we have items pending.. it is active
    //Otherwise it is ready
    if (fIsFrozen())
        return LI_FROZEN;
    else if (fIsPaused())
        return LI_READY;
    else if ((0 != cGetItemsPendingRetry()) && (0 == cGetItemsPending()))
        return LI_RETRY;
    else if (0 != cGetItemsPending())
        return LI_ACTIVE;
    else
        return LI_READY;
}

#endif //__ASYNCQ_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\cmt.h ===
//-----------------------------------------------------------------------------
//
//
//    File: cmt.h
//
//    Description:    
//      General Header file for the CMT objects
//
//      Circa 2001, this only contains priority information.
//
//    Owner: mikeswa
//
//    Copyright (C) 1997, 2001 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _CMT_H_
#define _CMT_H_

//Comment out the following if you do not information printed out (ie running as
// a service).
#define CMT_CONSOLE_DEBUG

#include "aqincs.h"

//---[ EffectivePriority ]-----------------------------------------------------
//
//
//  Hungarian: pri
//
//  Effective Routing priority.  Allows standardf priorities to be adjusted
//  based on configuration (ie, message size, originator... etc)
//-----------------------------------------------------------------------------
typedef enum _EffectivePriority
{
//Priorities in order of importance          
//                      | hex | binary |
//                      ================
    eEffPriLow          = 0x0, //000    Standard low pri needs to map here 
    eEffPriNormal       = 0x1, //001    Standard normal pri needs to map here
    eEffPriHigh         = 0x2, //011    Standard high pri needs to map here
    eEffPriMask         = 0x3  //011
} EffectivePriority, *PEffectivePriority;

typedef EffectivePriority   TEffectivePriority;  //to make Mahesh's life easier



//Besure to update Macros when constants are changed
#define fNormalPri(Pri)  (((EffectivePriority) (Pri)) == ((EffectivePriority) eEffPriNormal))
#define fHighPri(Pri)    (((EffectivePriority) (Pri)) == ((EffectivePriority) eEffPriHigh))
#define NUM_PRIORITIES  3

#endif // _CMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asyncq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: asyncq.cpp
//
//  Description: Non-template asyncq implementations
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/23/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "asyncq.h"
#include "asyncq.inl"

DWORD CAsyncQueueBase::s_cAsyncQueueStaticInitRefCount = 0;
DWORD CAsyncQueueBase::s_cMaxPerProcATQThreadAdjustment = 0;
DWORD CAsyncQueueBase::s_cDefaultMaxAsyncThreads = 0;


// Some counters for debugging thread management
DWORD CAsyncQueueBase::s_cThreadCompletion_QueueEmpty                = 0;
DWORD CAsyncQueueBase::s_cThreadCompletion_CompletedScheduledItems   = 0;
DWORD CAsyncQueueBase::s_cThreadCompletion_UnacceptableThreadCount   = 0;
DWORD CAsyncQueueBase::s_cThreadCompletion_Timeout                   = 0;
DWORD CAsyncQueueBase::s_cThreadCompletion_Failure                   = 0;
DWORD CAsyncQueueBase::s_cThreadCompletion_Paused                    = 0;

// state transition table for the async queue state machine
STATE_TRANSITION CAsyncQueueBase::s_rgTransitionTable[] = 
{
    // start state normal:
    { ASYNC_QUEUE_STATUS_NORMAL,       ASYNC_QUEUE_ACTION_KICK,     ASYNC_QUEUE_STATUS_NORMAL       },
    { ASYNC_QUEUE_STATUS_NORMAL,       ASYNC_QUEUE_ACTION_PAUSE,    ASYNC_QUEUE_STATUS_PAUSED       },
    { ASYNC_QUEUE_STATUS_NORMAL,       ASYNC_QUEUE_ACTION_UNPAUSE,  ASYNC_QUEUE_STATUS_NORMAL       },
    { ASYNC_QUEUE_STATUS_NORMAL,       ASYNC_QUEUE_ACTION_FREEZE,   ASYNC_QUEUE_STATUS_FROZEN       },
    { ASYNC_QUEUE_STATUS_NORMAL,       ASYNC_QUEUE_ACTION_THAW,     ASYNC_QUEUE_STATUS_NORMAL       },
    { ASYNC_QUEUE_STATUS_NORMAL,       ASYNC_QUEUE_ACTION_SHUTDOWN, ASYNC_QUEUE_STATUS_SHUTDOWN     },
    // start state paused:
    { ASYNC_QUEUE_STATUS_PAUSED,       ASYNC_QUEUE_ACTION_KICK,     ASYNC_QUEUE_STATUS_NORMAL       },
    { ASYNC_QUEUE_STATUS_PAUSED,       ASYNC_QUEUE_ACTION_PAUSE,    ASYNC_QUEUE_STATUS_PAUSED       },
    { ASYNC_QUEUE_STATUS_PAUSED,       ASYNC_QUEUE_ACTION_UNPAUSE,  ASYNC_QUEUE_STATUS_NORMAL       },
    { ASYNC_QUEUE_STATUS_PAUSED,       ASYNC_QUEUE_ACTION_FREEZE,   ASYNC_QUEUE_STATUS_FROZENPAUSED },
    { ASYNC_QUEUE_STATUS_PAUSED,       ASYNC_QUEUE_ACTION_THAW,     ASYNC_QUEUE_STATUS_PAUSED       },
    { ASYNC_QUEUE_STATUS_PAUSED,       ASYNC_QUEUE_ACTION_SHUTDOWN, ASYNC_QUEUE_STATUS_SHUTDOWN     },
    // start state frozen:
    { ASYNC_QUEUE_STATUS_FROZEN,       ASYNC_QUEUE_ACTION_KICK,     ASYNC_QUEUE_STATUS_NORMAL       },
    { ASYNC_QUEUE_STATUS_FROZEN,       ASYNC_QUEUE_ACTION_PAUSE,    ASYNC_QUEUE_STATUS_FROZENPAUSED },
    { ASYNC_QUEUE_STATUS_FROZEN,       ASYNC_QUEUE_ACTION_UNPAUSE,  ASYNC_QUEUE_STATUS_FROZEN       },
    { ASYNC_QUEUE_STATUS_FROZEN,       ASYNC_QUEUE_ACTION_FREEZE,   ASYNC_QUEUE_STATUS_FROZEN       },
    { ASYNC_QUEUE_STATUS_FROZEN,       ASYNC_QUEUE_ACTION_THAW,     ASYNC_QUEUE_STATUS_NORMAL       },
    { ASYNC_QUEUE_STATUS_FROZEN,       ASYNC_QUEUE_ACTION_SHUTDOWN, ASYNC_QUEUE_STATUS_SHUTDOWN     },
    // start state frozenpaused:
    { ASYNC_QUEUE_STATUS_FROZENPAUSED, ASYNC_QUEUE_ACTION_KICK,     ASYNC_QUEUE_STATUS_NORMAL       },
    { ASYNC_QUEUE_STATUS_FROZENPAUSED, ASYNC_QUEUE_ACTION_PAUSE,    ASYNC_QUEUE_STATUS_FROZENPAUSED },
    { ASYNC_QUEUE_STATUS_FROZENPAUSED, ASYNC_QUEUE_ACTION_UNPAUSE,  ASYNC_QUEUE_STATUS_FROZEN       },
    { ASYNC_QUEUE_STATUS_FROZENPAUSED, ASYNC_QUEUE_ACTION_FREEZE,   ASYNC_QUEUE_STATUS_FROZENPAUSED },
    { ASYNC_QUEUE_STATUS_FROZENPAUSED, ASYNC_QUEUE_ACTION_THAW,     ASYNC_QUEUE_STATUS_PAUSED       },
    { ASYNC_QUEUE_STATUS_FROZENPAUSED, ASYNC_QUEUE_ACTION_SHUTDOWN, ASYNC_QUEUE_STATUS_SHUTDOWN     },
    // start state shutdown:
    { ASYNC_QUEUE_STATUS_SHUTDOWN,     ASYNC_QUEUE_ACTION_KICK,     ASYNC_QUEUE_STATUS_SHUTDOWN     },
    { ASYNC_QUEUE_STATUS_SHUTDOWN,     ASYNC_QUEUE_ACTION_PAUSE,    ASYNC_QUEUE_STATUS_SHUTDOWN     },
    { ASYNC_QUEUE_STATUS_SHUTDOWN,     ASYNC_QUEUE_ACTION_UNPAUSE,  ASYNC_QUEUE_STATUS_SHUTDOWN     },
    { ASYNC_QUEUE_STATUS_SHUTDOWN,     ASYNC_QUEUE_ACTION_FREEZE,   ASYNC_QUEUE_STATUS_SHUTDOWN     },
    { ASYNC_QUEUE_STATUS_SHUTDOWN,     ASYNC_QUEUE_ACTION_THAW,     ASYNC_QUEUE_STATUS_SHUTDOWN     },
    { ASYNC_QUEUE_STATUS_SHUTDOWN,     ASYNC_QUEUE_ACTION_SHUTDOWN, ASYNC_QUEUE_STATUS_SHUTDOWN     },
};

//---[ CAsyncQueueBase::getTransitionTable ]------------
//
//
//  Description: 
//      returns the state transition table and its size to 
//      CStateMachineBase whenever needed.
//  Parameters:
//      - ppTransitionTable   pointer to the state transition table
//        pdwNumTransitions   pointer to the number of transitions in 
//                            the table
//  Returns:
//      - 
//  History:
//      6/5/2000 - t-toddc Created 
//      12/11/2000 - MikeSwa Merged for Hg checkin 
//
//------------------------------------------------------------------
void CAsyncQueueBase::getTransitionTable(const STATE_TRANSITION** ppTransitionTable,
                                         DWORD* pdwNumTransitions)
{
    TraceFunctEnter("CAsyncQueueStateMachine::getTransitionTable");
    ASSERT(ppTransitionTable && "NULL transition table pointer");
    ASSERT(pdwNumTransitions && "NULL num transitions pointer");
    ASSERT(s_rgTransitionTable && "transition table uninitialized");

    // bail on bad input or no good transition table
    if (!ppTransitionTable || !pdwNumTransitions || !s_rgTransitionTable)
        goto Exit;

    *ppTransitionTable = s_rgTransitionTable;
    *pdwNumTransitions = sizeof(CAsyncQueueBase::s_rgTransitionTable) / 
                         sizeof(STATE_TRANSITION);

  Exit:
    TraceFunctLeave();
}



//---[ CAsyncQueueBase::ThreadPoolInitialize ]---------------------------------
//
//
//  Description:
//      Performs static ATQ initialization.  This call is ref-counted.  If
//      it succeeds, the caller should call ThreadPoolDeinitialze();
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/30/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAsyncQueueBase::ThreadPoolInitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueueBase::ThreadPoolInitialize");
    DWORD   cATQMaxAsyncThreads = 0;
    DWORD   cATQMaxTotalAsyncThreads = 0;
    DWORD   cOurMaxAsyncThreads = 0;
    SYSTEM_INFO sinf;

    //
    //  On 0 -> 1 transition, adjust ATQ according to our config
    //
    if (!s_cAsyncQueueStaticInitRefCount)
    {
        //
        //  Get max threads per proc
        //
        cATQMaxAsyncThreads = (DWORD)AtqGetInfo(AtqMaxPoolThreads);
        _ASSERT(cATQMaxAsyncThreads && "AtqGetInfo says there are no threads!");
        if (!cATQMaxAsyncThreads)
            cATQMaxAsyncThreads = 1;

        cOurMaxAsyncThreads = cATQMaxAsyncThreads;

        //
        //  Adjust value by our config value
        //
        cOurMaxAsyncThreads += g_cPerProcMaxThreadPoolModifier;

        //
        //  Get # of procs (using GetSystemInfo)
        //
        GetSystemInfo(&sinf);
        cOurMaxAsyncThreads *= sinf.dwNumberOfProcessors;

        //
        //  We will throttle our requests at g_cMaxATQPercent
        //  the max number of ATQ threads
        //
        cOurMaxAsyncThreads = (g_cMaxATQPercent*cOurMaxAsyncThreads)/100;

        if (!cOurMaxAsyncThreads)
            cOurMaxAsyncThreads = 1;

        //
        //  Set static so people later on can use this calculation
        //
        s_cDefaultMaxAsyncThreads = cOurMaxAsyncThreads;

        //
        //  Now we need to adjust our threads
        //
        s_cMaxPerProcATQThreadAdjustment = g_cPerProcMaxThreadPoolModifier;

        //
        //  Per proc thread limit
        //
        if (s_cMaxPerProcATQThreadAdjustment)
        {
            AtqSetInfo(AtqMaxPoolThreads,
                cATQMaxAsyncThreads + s_cMaxPerProcATQThreadAdjustment);
            DebugTrace((LPARAM) this,
                "Adjusting per proc ATQ thread limit by %d (orig %d)",
                s_cMaxPerProcATQThreadAdjustment, cATQMaxAsyncThreads);
        }

        _ASSERT(!(0xFF000000 & cOurMaxAsyncThreads)); //sanity check number
    }

    s_cAsyncQueueStaticInitRefCount++;

    TraceFunctLeave();
}


//---[ CAsyncQueueBase::ThreadPoolDeinitialize ]-------------------------------
//
//
//  Description:
//      Will re-adjust ATQ data if we changed them during initialization
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/30/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAsyncQueueBase::ThreadPoolDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueueBase::ThreadPoolDeinitialize");
    DWORD   cATQMaxAsyncThreads = 0;
    DWORD   cATQMaxTotalAsyncThreads = 0;

    _ASSERT(s_cAsyncQueueStaticInitRefCount != 0);
    s_cAsyncQueueStaticInitRefCount--;

    //
    //   If this is the last queue, adjust our configuration so back to
    //   the way we found it.
    //
    if (!s_cAsyncQueueStaticInitRefCount)
    {
        cATQMaxAsyncThreads = (DWORD)AtqGetInfo(AtqMaxPoolThreads);
        cATQMaxTotalAsyncThreads = (DWORD) AtqGetInfo(AtqMaxThreadLimit);

        //
        //  Reset per-proc threads if it makes sense
        //
        if (s_cMaxPerProcATQThreadAdjustment &&
            (cATQMaxAsyncThreads > s_cMaxPerProcATQThreadAdjustment))
        {
            AtqSetInfo(AtqMaxPoolThreads,
                cATQMaxAsyncThreads - s_cMaxPerProcATQThreadAdjustment);

            DebugTrace((LPARAM) this,
                "Resetting ATQ Max per proc threads to %d",
                cATQMaxAsyncThreads - s_cMaxPerProcATQThreadAdjustment);

            s_cMaxPerProcATQThreadAdjustment = 0;
        }

    }

    // Verify that m_cThreadsNeeded has reached zero
    _ASSERT(!m_cThreadsNeeded);

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\connmgr.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ConnMgr.cpp
//
//  Description:  Implementation of CConnMgr which provides the
//      IConnectionManager interface.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "retrsink.h"
#include "ConnMgr.h"
#include "fifoqimp.h"
#include "smtpconn.h"
#include "tran_evntlog.h"

VOID LookupQueueforETRN(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete);
VOID CreateETRNDomainList(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete);

//If we are not limiting the number of messages that each connection can handle,
//then lets use this as a guide to determine how many connections to create.
#define UNLIMITED_MSGS_PER_CONNECTION 20

//---[ CConnMgr::CConnMgr ]----------------------------------------------------
//
//
//  Description:
//      Default constructor for CConnMgr class.
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CConnMgr::CConnMgr() : CSyncShutdown()
{
    HRESULT hr = S_OK;
    m_paqinst = NULL;
    m_pqol = NULL;
    m_hNextConnectionEvent = NULL;
    m_hShutdownEvent = NULL;
    m_hReleaseAllEvent = NULL;
    m_cConnections = 0;

    m_cMaxLinkConnections = g_cMaxLinkConnections;
    m_cMinMessagesPerConnection = g_cMinMessagesPerConnection;
    m_cMaxMessagesPerConnection = g_cMaxMessagesPerConnection;
    m_cMaxConnections = g_cMaxConnections;
    m_cGetNextConnectionWaitTime = g_dwConnectionWaitMilliseconds;
    m_dwConfigVersion = 0;
    m_fStoppedByAdmin = FALSE;

}

//---[ CConnMgr::~CConnMgr ]-----------------------------------------------------
//
//
//  Description:
//      Default destructor for CConnMgr
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CConnMgr::~CConnMgr()
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::~CConnMgr");

    if (NULL != m_hNextConnectionEvent)
    {
        if (!CloseHandle(m_hNextConnectionEvent))
        {
            DebugTrace((LPARAM) HRESULT_FROM_WIN32(GetLastError()),
                "Unable to close handle for Get Next Connection Event");
        }
    }

    if (NULL != m_hShutdownEvent)
    {
        if (!CloseHandle(m_hShutdownEvent))
        {
            DebugTrace((LPARAM) HRESULT_FROM_WIN32(GetLastError()),
                "Unable to close handle for Connection Manger Shutdown Event");
        }
    }

    if (NULL != m_hReleaseAllEvent)
    {
        if (!CloseHandle(m_hReleaseAllEvent))
        {
            DebugTrace((LPARAM) HRESULT_FROM_WIN32(GetLastError()),
                "Unable to close handle for Connection Manger Release All Event");
        }
    }

    TraceFunctLeave();
}

//---[ CConnMgr::HrInitialize ]------------------------------------------------
//
//
//  Description:
//      CConnMgr Initialization function.
//  Parameters:
//      paqinst            ptr fo CAQSvrInst virtual instance object
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::HrInitialize(CAQSvrInst *paqinst)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::HrInitialize");
    HRESULT hr = S_OK;
    IConnectionRetryManager *pIRetryMgr = NULL;

    _ASSERT(paqinst);

    paqinst->AddRef();
    m_paqinst = paqinst;

    //Create Manual reset event to release all waiting threads on shutdown
    m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == m_hShutdownEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //Create Queue of Links
    m_pqol = new QueueOfLinks;
    if (NULL == m_pqol)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    m_hNextConnectionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hNextConnectionEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //Create Manual reset event to release all waiting threads on caller's request
    m_hReleaseAllEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == m_hReleaseAllEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    hr = QueryInterface(IID_IConnectionRetryManager, (PVOID *) &pIRetryMgr);
    if (FAILED(hr))
        goto Exit;

   //Create the default retry handler object and initialize it
   m_pDefaultRetryHandler = new CSMTP_RETRY_HANDLER();

    if (!m_pDefaultRetryHandler)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

   //Addref IConnectionRetryManager here
   //and release it during deinit
   pIRetryMgr->AddRef();
   hr = m_pDefaultRetryHandler->HrInitialize(pIRetryMgr);
   if (FAILED(hr))
   {
      ErrorTrace((LPARAM) hr, "ERROR: Unable to initialize the retry handler!");
        goto Exit;
   }

  Exit:

    if (pIRetryMgr)
        pIRetryMgr->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CConnMgr::HrDeinitialize ]----------------------------------------------
//
//
//  Description:
//      CConnMgr Deinitialization function.
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::HrDeinitialize");

    //Wait max of 3 minutes no-progress.
    const DWORD CONNMGR_WAIT_SECONDS = 5;
    const DWORD MAX_CONNMGR_SHUTDOWN_WAITS = 1200/CONNMGR_WAIT_SECONDS;
    const DWORD MAX_CONNMGR_SHUTDOWN_WAITS_WITHOUT_PROGRESS = 180/CONNMGR_WAIT_SECONDS;
    HRESULT hr = S_OK;
    HRESULT hrQueue = S_OK;
    CLinkMsgQueue *plmq = NULL;
    DWORD   cWaits = 0;
    DWORD   cWaitsSinceLastProgress = 0;
    DWORD   cConnectionsPrevious = 0;

    if (m_paqinst)
        m_paqinst->ServerStopHintFunction();

    SignalShutdown();

    if (NULL != m_hShutdownEvent)
    {
        if (!SetEvent(m_hShutdownEvent))
        {
            if (SUCCEEDED(hr))
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (NULL != m_pqol)
    {
        //Dequeue Links until empty
        hrQueue = m_pqol->HrDequeue(&plmq);
        while (SUCCEEDED(hrQueue))
        {
            _ASSERT(plmq);
            plmq->Release();
            hrQueue = m_pqol->HrDequeue(&plmq);
        }
        delete m_pqol;
        m_pqol = NULL;
    }


    cConnectionsPrevious = m_cConnections;
    while (m_cConnections)
    {
        cWaits++;
        cWaitsSinceLastProgress++;
        if (m_paqinst)
            m_paqinst->ServerStopHintFunction();
        Sleep(CONNMGR_WAIT_SECONDS * 1000);
        if (m_cConnections != cConnectionsPrevious)
        {
            cConnectionsPrevious = m_cConnections;
            cWaitsSinceLastProgress = 0;
        }

        if ((cWaits > MAX_CONNMGR_SHUTDOWN_WAITS) ||
            (cWaitsSinceLastProgress > MAX_CONNMGR_SHUTDOWN_WAITS_WITHOUT_PROGRESS))
        {
            _ASSERT(0 && "SMTP not returning all connections");
            ErrorTrace((LPARAM) this, "ERROR: %d Connections outstanding on shutdown", m_cConnections);
            break;
        }
    }

    //Must happen after we are done caller server stop hint functions
    if (NULL != m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    //NK** To be safe do it as interlocked exchange
   if (m_pDefaultRetryHandler)
   {
      m_pDefaultRetryHandler->HrDeInitialize();
      m_pDefaultRetryHandler = NULL;
   }

    TraceFunctLeave();
    return hr;
}

//---[ CConnMgr::HrNotify ]----------------------------------------------------
//
//
//  Description:
//      Method exposed to recieve a notification about a change in queue status
//  Parameters:
//      IN  paqstats    Notification object
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::HrNotify(IN CAQStats *paqstats, BOOL fAdd)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::HrNotify");
    HRESULT hr = S_OK;
    CLinkMsgQueue *plmq = NULL;
    DWORD   cbDomainName = 0;
    LPSTR   szDomainName = NULL;

    _ASSERT(paqstats);

    plmq = paqstats->m_plmq;

    _ASSERT(plmq); //ConnMgr notifications must have a link associated with then

    if (paqstats->m_dwNotifyType & NotifyTypeNewLink)
    {
        hr = plmq->HrGetSMTPDomain(&cbDomainName, &szDomainName);
        if (FAILED(hr))
            goto Exit;

        //must add new link to QueueOfLinks
        plmq->IncrementConnMgrCount();
        hr = m_pqol->HrEnqueue(plmq);
        if (FAILED(hr))
        {
            plmq->DecrementConnMgrCount();
            DebugTrace((LPARAM) hr, "ERROR: Unable to add new link to connection manager!");
            goto Exit;
        }
    }

    //See if we can (and *should*) create a connection
    if ((m_cConnections < m_cMaxConnections) &&
        plmq->fShouldConnect(m_cMaxLinkConnections, m_cMinMessagesPerConnection))
    {
        DebugTrace((LPARAM) m_hNextConnectionEvent, "INFO: Setting Next Connection Event");
        if (!SetEvent(m_hNextConnectionEvent))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CConnMgr::ReleaseConnection ]-------------------------------------------
//
//
//  Description:
//      Releases the connection count when a connection is being destroyed
//  Parameters:
//      IN  pSMTPConn               SMTP Connection Object to release
//      OUT pfForceCheckForDSNGeneration
//                                  TRUE if there was a hard error and we must
//                                  pass this link through DSN generation.
//
//  This 2nd parameter does not mean that will will or will not NDR the 
//  messages... just that we will iterate over all of the messages in the 
//  link.  If CMsgRef::fIsFatalError() returns TRUE for the current
//  connection status (as passed into the DSN generation code, then messages
//  will be NDR'd.  One way to control this is by setting the 
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CConnMgr::ReleaseConnection(CSMTPConn *pSMTPConn,
                                 BOOL *pfForceCheckForDSNGeneration)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::ReleaseConnection");
    DWORD   dwDomainInfoFlags = 0;
    DWORD   dwLinkStateFlags = 0;
    DWORD   dwConnectionStatus = pSMTPConn->dwGetConnectionStatus();
    DWORD   dwConnectionFailureCount = 0;
    HRESULT hr = S_OK;
    CLinkMsgQueue   *plmq = NULL;
    DWORD   cbDomain = 0;
    LPSTR   szDomain = NULL;
    BOOL    fCanRetry = FALSE;
    BOOL    fLocked = FALSE;
    DWORD   cConnections = 0;
    CInternalDomainInfo    *pIntDomainInfo= NULL;
    CAQScheduleID *paqsched = NULL;
    FILETIME ftNextRetry;
    BOOL    fShouldNotify = FALSE;
    BOOL    fMayNDRAllMessages = FALSE;


    GUID guidRouting = GUID_NULL;
    DWORD cMessages = 0;

    ZeroMemory(&ftNextRetry, sizeof(FILETIME));

    _ASSERT(pfForceCheckForDSNGeneration);
    if (pfForceCheckForDSNGeneration)
        *pfForceCheckForDSNGeneration = FALSE;

    plmq = pSMTPConn->plmqGetLink();
    _ASSERT(plmq); //connection must be associated with a link

    paqsched = plmq->paqschedGetScheduleID();
    _ASSERT(paqsched);

    //Get the routing GUID
    paqsched->GetGUID(&guidRouting);

    hr = plmq->HrGetSMTPDomain(&cbDomain, &szDomain);
    if (FAILED(hr))
    {
        _ASSERT(0);  //I need to unstand when this can happen
        DebugTrace((LPARAM) hr, "ERROR: HrGetSMTPDomain failed");
        goto Exit;
    }

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }
    else
    {
        fLocked = TRUE;

        _ASSERT(m_paqinst);
        hr = plmq->HrGetDomainInfo(&cbDomain, &szDomain, &pIntDomainInfo);
        if (FAILED(hr))
        {
            //It must match the "*" domain at least
            _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
            DebugTrace((LPARAM) hr, "ERROR: HrGetInternalDomainInfo");
            goto Exit;
        }
        _ASSERT(pIntDomainInfo);
        dwDomainInfoFlags = pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags ;
        cConnections = plmq->cGetConnections();

        //NK** Update the link with the number of messages tried, failed, sent etc
        //If the remaining count goes to 0 and trigger is set, we will disable the trigger
        cMessages = plmq->cGetTotalMsgCount();

        //If we no more messages on the link, we need to disable
        //flags that caused one time triggering
        if(!cMessages)
        {
            //No more messages on the link - we may need to unset some flags on the link

            //If someone set this bit... then we should continue to notify them
            if (plmq->dwGetLinkState() & LINK_STATE_CONNECT_IF_NO_MSGS)
                fShouldNotify = TRUE;

            if(dwDomainInfoFlags & DOMAIN_INFO_TURN_ONLY || dwDomainInfoFlags & DOMAIN_INFO_ETRN_ONLY )
                dwLinkStateFlags |= LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_PRIV_TURN_ENABLED;

        }
        //Disable the admin forced connection
        // 2/1/99 - MikeSwa - We need to do this check every time, or we will
        //  continue to create connections for this link
        if (plmq->dwGetLinkState() & LINK_STATE_ADMIN_FORCE_CONN)
            dwLinkStateFlags |= LINK_STATE_ADMIN_FORCE_CONN;

        //Call link function to *unset* flags
        if (dwLinkStateFlags)
            plmq->dwModifyLinkState(LINK_STATE_NO_ACTION, dwLinkStateFlags);

        //The connection failed and this is the last outstanding connection to this domain
        //Increment the failure count
        dwConnectionFailureCount = plmq->cGetMessageFailureCount();
        if(cConnections == 1 && (CONNECTION_STATUS_OK != dwConnectionStatus))
        {
            dwConnectionFailureCount =  plmq->IncrementFailureCounts();
        }

        
        if (CONNECTION_STATUS_FAILED_LOOPBACK & dwConnectionStatus)
        {
            ErrorTrace((LPARAM) this, 
               "Loopback detected for domain %s (smarthost %s)",
               pIntDomainInfo->m_DomainInfo.szDomainName, 
               pIntDomainInfo->m_DomainInfo.szSmartHostDomainName);
            fMayNDRAllMessages = TRUE;
        }

        if (CONNECTION_STATUS_FAILED_NDR_UNDELIVERED & dwConnectionStatus)
        {
            //
            // If not set treat the failure as retryable - see detailed 
            // comments in GenerateDSNsIfNecessary() in linkmsgq.cpp for 
            // details comments
            //
            dwLinkStateFlags = plmq->dwGetLinkState();
            if (!(LINK_STATE_RETRY_ALL_DNS_FAILURES & dwLinkStateFlags))
            {
                ErrorTrace((LPARAM) plmq,
                    "hard failure for %s (smarthost %s) - flags 0x%08X",
                    pIntDomainInfo->m_DomainInfo.szDomainName, 
                    pIntDomainInfo->m_DomainInfo.szSmartHostDomainName,
                    dwLinkStateFlags);
                fMayNDRAllMessages = TRUE;
            }
        }

        //
        // Flag the link so that we generate DSNs on it and fall down to
        // the retry handler sink. This link will be marked retry so that
        // no new connections are created.  Ultimately, the DSN generation
        // code/MsgRef will make the final determination if we need to NDR,
        // but this being set means that:
        //      - We think we have hit an NDR-able error
        //      - We will use the glitch retry (so new messages
        //          can be retried as well).
        //
        if (fMayNDRAllMessages)
        {
            if(pfForceCheckForDSNGeneration)
                *pfForceCheckForDSNGeneration = TRUE;

            //
            //  Trick the retry sink so it always uses the glitch retry
            //
            dwConnectionFailureCount = 1;
        }


        _ASSERT(m_pDefaultRetryHandler);
        DebugTrace((LPARAM) this,
                "INFO: ConnectionRelease for domain %s: %d failed, %d tried, status 0x%08X",
                szDomain, pSMTPConn->cGetFailedMsgCount(),
                pSMTPConn->cGetTriedMsgCount(),
                pSMTPConn->dwGetConnectionStatus());
        hr = m_pDefaultRetryHandler->ConnectionReleased(cbDomain, szDomain,
                    dwDomainInfoFlags, paqsched->dwGetScheduleID(),
                    guidRouting, dwConnectionStatus,
                    pSMTPConn->cGetFailedMsgCount(),
                    pSMTPConn->cGetTriedMsgCount(),
                    dwConnectionFailureCount, &fCanRetry, &ftNextRetry);
        if (FAILED(hr))
        {
            DebugTrace((LPARAM) hr,
                "ERROR: Failed to deal with released connection");
        }

        //Make sure that the proper flags are set WRT retry
        if (fCanRetry)
        {
            if (dwConnectionStatus == CONNECTION_STATUS_OK)
                plmq->ResetConnectionFailureCount();

            //If this is a TURN/ETRN domain, we do not want to enable it unless
            //another TURN/ETRN request comes... or a retry request is scheduled for
            //later.  The reason for this, is that we don't want to retry TURN/ETRN
            //domains in the conventional sense, so the defaul retry sink ignores
            //them except for "glitch" retries
            if(dwDomainInfoFlags & (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY))
                dwLinkStateFlags = LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_PRIV_TURN_ENABLED;
            else
                dwLinkStateFlags = LINK_STATE_NO_ACTION;

            dwLinkStateFlags = plmq->dwModifyLinkState(LINK_STATE_RETRY_ENABLED,
                                                       dwLinkStateFlags);

            //Check for state change
            if (!(LINK_STATE_RETRY_ENABLED & dwLinkStateFlags))
                fShouldNotify = TRUE;
        }
        else
        {
            DebugTrace((LPARAM) this,"ASSERT_RETRY : ReleaseConnection about to clear flag for link 0x%08X", plmq);

            dwLinkStateFlags = plmq->dwModifyLinkState(LINK_STATE_NO_ACTION,
                                                       LINK_STATE_RETRY_ENABLED);

            DebugTrace((LPARAM) this,"ASSERT_RETRY : ReleaseConnection has cleared the flag for link 0x%08X", plmq);

            //Check for state change
            if (LINK_STATE_RETRY_ENABLED & dwLinkStateFlags)
                fShouldNotify = TRUE;

            if (ftNextRetry.dwHighDateTime || ftNextRetry.dwLowDateTime)
            {
                //Retry is telling us a retry time... report that.
                //Set the next retry time that the retry sink tells us about
                plmq->SetNextRetry(&ftNextRetry);
            }

            //
            //  Log something useful
            //
            LogConnectionFailedEvent(pSMTPConn, plmq, szDomain);
            
            if (dwConnectionStatus == CONNECTION_STATUS_OK)
                plmq->IncrementFailureCounts(); //we had a false positive
        }

        //Notify router/scheduler of any changes
        if (fShouldNotify)
            plmq->SendLinkStateNotification();

        if (cConnections < m_cMaxConnections)
        {
           if (!SetEvent(m_hNextConnectionEvent))
              DebugTrace((LPARAM) HRESULT_FROM_WIN32(GetLastError()), "Unable to set GetNextConnection Event");
        }
    }

  Exit:
    if (plmq)
        plmq->Release();

    //Decrement connection count
    cConnections = InterlockedDecrement((long *) &m_cConnections);
    DebugTrace((LPARAM) this, "INFO: Releasing Connection for link 0x%08X", plmq);

    if (fLocked)
        ShutdownUnlock();

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    TraceFunctLeave();
}

//---[ CConnMgr::LogConnectionFailedEvent ]------------------------------------
//
//
//  Description:
//      Logs the specific connection failure event.
//  Parameters:
//      IN  pSMTPConn               SMTP Connection Object to release
//      IN  plmq                    ClinkMsgQueue for this link
//      IN  szDomain                The domain name 
//  Returns:
//      -
//  History:
//    11/29/2001 - Mikeswa created (moved from ReleaseConnection)
//
//-----------------------------------------------------------------------------
void CConnMgr::LogConnectionFailedEvent(CSMTPConn *pSMTPConn,
                                                      CLinkMsgQueue *plmq,
                                                      LPSTR szDomain)
{
    TraceFunctEnterEx((LPARAM)this, "CConnMgr::LogConnectionFailedEvent");
    char szDiagnosticVerb[1024] = "";
    char szDiagnosticError[1024] = "";
    DWORD iMessage = AQUEUE_REMOTE_DELIVERY_FAILED;
    HRESULT hrDiagnostic = PHATQ_E_CONNECTION_FAILED;
    LPSTR szConnectedIPAddress = pSMTPConn ? pSMTPConn->szGetConnectedIPAddress() : NULL;
    BOOL  fLogIPAddress = FALSE;
    DWORD iSubstringDiagnosticIndex = 1; //index of dianostic in substring
    WORD wSubstringWordCount = 0;

    const char *rgszSubstrings[] = {
                szDomain,
                NULL /* error message */,
                szDiagnosticVerb,
                szDiagnosticError,
    };

    const char *rgszSubstringWithIP[] = {
                szConnectedIPAddress,
                szDomain,
                NULL /* error message */,
                szDiagnosticVerb,
                szDiagnosticError,
    };

    if (!plmq || !pSMTPConn || !m_paqinst)
    {
        ErrorTrace((LPARAM)this, 
            "Bogus pointers plmq %p, pSMTPConn %p, m_paqinst %p", 
            plmq, pSMTPConn, m_paqinst);
        goto Exit;
    }
    
    plmq->GetDiagnosticInfo(szDiagnosticVerb,
                            sizeof(szDiagnosticVerb),
                            szDiagnosticError,
                            sizeof(szDiagnosticError),
                            &hrDiagnostic);

    if (SUCCEEDED(hrDiagnostic))
    {
        //This means that the connection has failed,
        //but there is no diagnostic information... this could
        //be caused by several things, but we want to avoid
        //logging a potentially bogus event.

        //Set this error to something that looks useful, but
        //is actually the transport equivalent on E_FAIL.  We
        //can use this to find when this was hit by looking at
        //the error logs on retail builds.
        hrDiagnostic = PHATQ_E_CONNECTION_FAILED;

        ErrorTrace((LPARAM) this,
              "Link Diagnostic was not set - defaulting");
    }
    
    //
    //  There are 4 different events we can log at this point.  Each as a 
    //  different number of words to substitute & a different place to put the
    //  diagnostic.  Each has a different message ID.  The variations are 
    //  with/without SMTP protocol verbs and with/without IP address
    //
    //  Failure     fLogIPAddress   Words   Substring Array         Diag Index
    //  ======================================================================
    //   no verb    FALSE           2       rgszSubstrings          1
    //   Verb       FALSE           4       rgszSubstrings          1
    //   no verb    TRUE            3       rgszSubstringWithIP     2
    //   Verb       TRUE            5       rgszSubstringWithIP     2
    //

    //
    //  Check if there is anything in the IP address string.  
    //  If there is, we will use it.
    //
    if (szConnectedIPAddress && szConnectedIPAddress[0]) {
        fLogIPAddress = TRUE;
    }

    //
    //  Is there any protocol verb data? If so, use this.
    //
    if (*szDiagnosticVerb != 0 || *szDiagnosticError != 0)
    {
        if (fLogIPAddress)
        {
            wSubstringWordCount = 5;
            iSubstringDiagnosticIndex = 2;  
            iMessage = AQUEUE_REMOTE_DELIVERY_TO_IP_FAILED_DIAGNOSTIC;
        }
        else 
        {
            wSubstringWordCount = 4;
            iSubstringDiagnosticIndex = 1;  
            iMessage = AQUEUE_REMOTE_DELIVERY_FAILED_DIAGNOSTIC;
        }
    }
    else
    {
        if (fLogIPAddress)
        {
            wSubstringWordCount = 3;
            iSubstringDiagnosticIndex = 2;  
            iMessage = AQUEUE_REMOTE_DELIVERY_TO_IP_FAILED;
        }
        else 
        {
            wSubstringWordCount = 2;
            iSubstringDiagnosticIndex = 1;  
            iMessage = AQUEUE_REMOTE_DELIVERY_FAILED;
        }
    }

    m_paqinst->HrTriggerLogEvent(
            iMessage,                               // Message ID
            TRAN_CAT_CONNECTION_MANAGER,            // Category
            wSubstringWordCount,                   // Word count of substring
            fLogIPAddress ? rgszSubstringWithIP : rgszSubstrings,
            EVENTLOG_WARNING_TYPE,                  // Type of the message
            hrDiagnostic,                           // error code
            LOGEVENT_LEVEL_MEDIUM,                  // Logging level
            szDomain,                               // Key to identify this event
            LOGEVENT_FLAG_PERIODIC,                 // Event logging option
            iSubstringDiagnosticIndex,              // format string's index in substring
            GetModuleHandle(AQ_MODULE_NAME)         // module handle to format a message
            );
        
  Exit:
    TraceFunctLeave();
}
//---[ CConnMgr::QueryInterface ]------------------------------------------
//
//
//  Description:
//      QueryInterface for IAdvQueue
//  Parameters:
//
//  Returns:
//      S_OK on success
//
//  Notes:
//      This implementation makes it possible for any server component to get
//      the IConnectionManager interface.
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IConnectionRetryManager *>(this);
    }
    else if (IID_IConnectionRetryManager == riid)
    {
        *ppvObj = static_cast<IConnectionRetryManager *>(this);
    }
    else if (IID_IConnectionManager == riid)
    {
        *ppvObj = static_cast<IConnectionManager *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CConnMgr::GetNextConnection ]-------------------------------------------
//
//
//  Description:
//      Implementation of IConnectionManager::GetNextConnection()
//
//      Returns the next available connection.  Will create a connection object
//      and associate it with a link.  If we are already at max connections, or
//      no link needs a connection, then this call will block until a an
//      appropriate connection can be made.
//  Parameters:
//      OUT pismtpconn  SMTP Connection interface
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::GetNextConnection(ISMTPConnection ** ppISMTPConnection)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::GetNextConnection");
    const DWORD NUM_CONNECTION_OBJECTS = 3;
    //Release event is the last event in array
    const DWORD WAIT_OBJECT_RELEASE_EVENT = WAIT_OBJECT_0 + NUM_CONNECTION_OBJECTS -1;
    HRESULT hr = S_OK;
    DWORD   cLinksToTry = 0;
    DWORD   cConnections = 0;
    CLinkMsgQueue *plmq = NULL;
    CSMTPConn *pSMTPConn = NULL;
    bool    fForceWait = false;  //temporarily force thread to wait
    bool    fLocked = false;
    DWORD   cbDomain = 0;
    LPSTR   szDomain = NULL;
    HANDLE  rghWaitEvents[NUM_CONNECTION_OBJECTS] = {m_hShutdownEvent, m_hNextConnectionEvent, m_hReleaseAllEvent};
    DWORD   dwWaitResult;
    DWORD   cMaxConnections = 0;
    DWORD   cGetNextConnectionWaitTime = 30000;  //make sure we never start in a busy wait loop
    DWORD   cMaxLinkConnections = 0;
    DWORD   cMinMessagesPerConnection = 0;
    DWORD   cMaxMessagesPerConnection = 0;
    DWORD   dwConfigVersion;
    LONG    cTimesQueued = 0; //# of times a link has been queue'd
    BOOL    fOwnConnectionCount = FALSE;
    BOOL    fMembersUnsafe = FALSE; //set to TRUE during shutdown situations

    if (NULL == ppISMTPConnection)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Get config data
    m_slPrivateData.ShareLock();
    cMaxLinkConnections = m_cMaxLinkConnections;
    cMaxMessagesPerConnection = m_cMaxMessagesPerConnection;

    //Handle unlimited case
    if (m_cMinMessagesPerConnection)
        cMinMessagesPerConnection = m_cMinMessagesPerConnection;
    else
        cMinMessagesPerConnection = UNLIMITED_MSGS_PER_CONNECTION;

    cMaxConnections = m_cMaxConnections;
    cGetNextConnectionWaitTime = m_cGetNextConnectionWaitTime;
    dwConfigVersion = m_dwConfigVersion;
    m_slPrivateData.ShareUnlock();


    cConnections = InterlockedIncrement((PLONG) &m_cConnections);
    fOwnConnectionCount = TRUE;
    cLinksToTry = m_pqol->cGetCount();
    while (true)
    {

        //Use CSyncShutdown locking to prevent shutdown from happening under us
        if (!fLocked)
        {
            if (!fTryShutdownLock())
            {
                hr = AQUEUE_E_SHUTDOWN;
                goto Exit;
            }
            m_paqinst->RoutingShareLock();
            fLocked = TRUE;
        }

        if (m_dwConfigVersion != dwConfigVersion)
        {
            //Config data has/is being updated aquire lock & get new data
            m_slPrivateData.ShareLock();
            cMaxLinkConnections = m_cMaxLinkConnections;
            cMaxMessagesPerConnection = m_cMaxMessagesPerConnection;

            //Handle unlimited case
            if (m_cMinMessagesPerConnection)
                cMinMessagesPerConnection = m_cMinMessagesPerConnection;
            else
                cMinMessagesPerConnection = UNLIMITED_MSGS_PER_CONNECTION;

            cMaxConnections = m_cMaxConnections;
            cGetNextConnectionWaitTime = m_cGetNextConnectionWaitTime;
            dwConfigVersion = m_dwConfigVersion;
            m_slPrivateData.ShareUnlock();
        }

        //$$REVIEW: If there is more than 1 thread waiting on GetNextConnection,
        //then all threads will cycle through all availalbe links (if none are
        //available for connections).  However, it is very unlikely that this
        //run through the queue will be neccessary after Milestone #1.
        while ((0 == cLinksToTry) ||
                (cConnections > cMaxConnections) || fForceWait ||
                fConnectionsStoppedByAdmin())
        {
            InterlockedDecrement((PLONG) &m_cConnections);
            fOwnConnectionCount = FALSE;

            //Release lock for wait function
            fLocked = false;
            m_paqinst->RoutingShareUnlock();
            ShutdownUnlock();

            DebugTrace((LPARAM) m_cConnections, "INFO: Waiting in GetNextConnection");

            _ASSERT(m_cGetNextConnectionWaitTime && "Configured for busy wait loop");
            dwWaitResult = WaitForMultipleObjects(NUM_CONNECTION_OBJECTS,
                        rghWaitEvents, FALSE, cGetNextConnectionWaitTime);

            //NOTE: We *cannot* touch member variables until we determine that
            //we are not shutting down, because SMTP may have a thread in here
            //after this object is destroyed.
            DebugTrace((LPARAM) this, "INFO: Waking up in GetNextConnection");

            if (WAIT_FAILED == dwWaitResult)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
            else if (WAIT_OBJECT_0 == dwWaitResult)  //shutdown event fired
            {
                DebugTrace((LPARAM) this, "INFO: Leaving GetNextConnection because of Shutdown event");
                fMembersUnsafe = TRUE;
                hr = AQUEUE_E_SHUTDOWN;
                goto Exit;
            }
            else if (WAIT_OBJECT_RELEASE_EVENT == dwWaitResult)
            {
                DebugTrace((LPARAM) this, "INFO: Leaving GetNextConnection because ReleaseAllWaitingThreads called");
                //Caller asked that all threads be released
                *ppISMTPConnection = NULL;
                hr = AQUEUE_E_SHUTDOWN;
                fMembersUnsafe = TRUE;
                goto Exit;
            }

            _ASSERT((WAIT_OBJECT_0 == dwWaitResult - 1) || (WAIT_TIMEOUT == dwWaitResult));

            //Re-aquire lock
            if (!fTryShutdownLock())
            {
                hr = AQUEUE_E_SHUTDOWN;
                goto Exit;
            }
            else
            {
                m_paqinst->RoutingShareLock();
                fLocked = true;
            }

            cLinksToTry = m_pqol->cGetCount();
            fForceWait = false; //only force wait once in a row
            cConnections = InterlockedIncrement((PLONG) &m_cConnections);
            fOwnConnectionCount = TRUE;
        }

        _ASSERT(cConnections <= cMaxConnections);

        cLinksToTry--;

      //NK**Insted of Dequeue we should lock and peek to see if the link
      //needs to be dequed
      //If the peek is quick it will be better than dequeing and then
      //enquing it in order
      //Move this complete check into peek

        hr = m_pqol->HrDequeue(&plmq);
        if (FAILED(hr))
        {
            if (AQUEUE_E_QUEUE_EMPTY == hr) //not really an error
            {
                hr = S_OK;
                fForceWait = true;
                continue;
            }
            else
                goto Exit;  //need to handle case of empty queues a little better
        }

        hr = plmq->HrCreateConnectionIfNeeded(cMaxLinkConnections,
                        cMinMessagesPerConnection, cMaxMessagesPerConnection,
                        this, &pSMTPConn);

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "ERROR: HrCreateConnectionIfNeeded failed - hr 0x%08X", hr);
            goto Exit;
        }

        if (S_OK == hr)
        {
            _ASSERT(pSMTPConn);

            //take this opportunity to see if it need queueing
            cTimesQueued = plmq->DecrementConnMgrCount();
            if (!cTimesQueued)
            {
                plmq->IncrementConnMgrCount();
                hr = m_pqol->HrEnqueue(plmq);

                //If we fail here, we are in serious trouble...
                //A link has been lost - we should probably log an event $$TODO
                if (FAILED(hr))
                {
                    plmq->DecrementConnMgrCount();
                    DebugTrace((LPARAM) hr, "ERROR: Unable to requeue link 0x%8X", plmq);
                    goto Exit;
                }
            }

            hr = plmq->HrGetSMTPDomain(&cbDomain, &szDomain);
            if (FAILED(hr))
                goto Exit;

            DebugTrace((LPARAM) plmq, "INFO: Allocating new connection for domain %s", szDomain);

            break;
        }
        else
        {
            _ASSERT(!pSMTPConn);
            //The link does not need a connection - queue the link and look at
            //the next in line.

            //Check if this link can be delete (will increment ConnMgrCount if
            //it can
            plmq->RemoveLinkIfEmpty();
            cTimesQueued = plmq->DecrementConnMgrCount();
            if (!cTimesQueued)
            {
                plmq->IncrementConnMgrCount();
                hr = m_pqol->HrEnqueue(plmq);
                if (FAILED(hr))
                {
                    plmq->DecrementConnMgrCount();
                    DebugTrace((LPARAM) hr,
                        "ERROR: Unable to requeue link 0x%8X", plmq);
                    goto Exit;
                }
            }

            plmq->Release();
            plmq = NULL;
        }

        _ASSERT(fLocked);
        m_paqinst->RoutingShareUnlock();
        ShutdownUnlock();
        fLocked = false;
    }

    *ppISMTPConnection = (ISMTPConnection *) pSMTPConn;
    fOwnConnectionCount = FALSE;

  Exit:
    //NOTE: We *cannot* touch member variables until we determine that
    //we are not shutting down, because SMTP may have a thread in here
    //after this object is destroyed.

    //make sure connection count is correct if we couldn't create a connection
    if (fOwnConnectionCount)
    {
        _ASSERT(!fMembersUnsafe);
        InterlockedDecrement((PLONG) &m_cConnections);
    }

    if (NULL != plmq)
        plmq->Release();

    if (fLocked)
    {
        _ASSERT(!fMembersUnsafe);
        m_paqinst->RoutingShareUnlock();
        ShutdownUnlock();
    }

    if (FAILED(hr) && pSMTPConn)
    {
        if (hr != AQUEUE_E_SHUTDOWN)
            ErrorTrace((LPARAM) this, "ERROR: GetNextConnection failed - hr 0x%08X", hr);

        if (pSMTPConn)
        {
            pSMTPConn->Release();
            *ppISMTPConnection = NULL;
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ ConnMgr::GetNamedConnection ]-------------------------------------------
//
//
//  Description:
//      Implements IConnectionManager::GetNamedConnection
//
//      Returns a connection for the specifically requested connection (if it
//      exists).  Unlike GetNextConnection, this call will not block, it will
//      immediately succeed or fail.
//  Parameters:
//      IN  cbSMTPDomain    Length of domain name (strlen)
//      IN  szSMTPDomain    SMTP Domain of requested connection
//      OUT ppismtpconn     Returned SMTP Connection interface
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if no link exists for the domain
//      AQUEUE_E_QUEUE_EMPTY if link exists but there are no messages on it
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::GetNamedConnection(
                                  IN  DWORD cbSMTPDomain,
                                  IN  char szSMTPDomain[],
                                  OUT ISMTPConnection **ppISMTPConnection)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::GetNamedConnection");
    HRESULT hr = S_OK;
    CDomainEntry   *pdentry = NULL;
    CAQScheduleID aqsched;
    CSMTPConn *pSMTPConn = NULL;
    CLinkMsgQueue  *plmq = NULL;
    CDomainEntryLinkIterator delit;
    DWORD cMessages = 0;
    DWORD cConnectionsOnLink = 0;

    _ASSERT(ppISMTPConnection);
    *ppISMTPConnection = NULL;

    if (fConnectionsStoppedByAdmin()) //Can't create connections
    {
        hr = S_OK;
        goto Exit;
    }

    //Check if it has a queue in DMT for it
    hr = m_paqinst->HrGetDomainEntry(cbSMTPDomain, szSMTPDomain, &pdentry);
    if (FAILED(hr))
    {
        //If we do not have a DMQ corresponding to it
        //we should respond with zero message
        if( hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
        {
            hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
        }
        else
        {
            hr = S_OK;
        }
        goto Exit;

    }

    //NK** : Can we live with this single call
    //The assumption being that domain configured for TURN will
    //always have only one link associated with it
    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
    {
        //Treat as no-link case
        ErrorTrace((LPARAM) this, "Initializing link iterator failed - hr 0x%08X", hr);
        hr = S_OK;
        goto Exit;
    }

    plmq = delit.plmqGetNextLinkMsgQueue(plmq);
    if (!plmq)
    {
        //If we do not have a link corresponding to it
        //we should report the error back to SMTP
        hr = S_OK;
        goto Exit;
    }

    //Check if there are connections for this link that exist
    //
    cConnectionsOnLink = plmq->cGetConnections();
    if(cConnectionsOnLink)
    {
        //Do not allow multiple connections on TURN domains
        //It does not make much sense
        hr = S_OK;
        goto Exit;
    }

    //get the msg count from the dmq
    cMessages = plmq->cGetTotalMsgCount();

    if(cMessages)
    {
        //Create the connection with no message limit
        pSMTPConn = new CSMTPConn(this, plmq, 0);

        if (NULL == pSMTPConn)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        plmq->AddConnection(pSMTPConn);

        *ppISMTPConnection = (ISMTPConnection *) pSMTPConn;

        InterlockedIncrement((PLONG) &m_cConnections);

        //Now enable the link for turned connections
        plmq->dwModifyLinkState(LINK_STATE_PRIV_TURN_ENABLED, LINK_STATE_NO_ACTION);

        goto Exit;
    }
    else
    {
        hr = S_OK;
        goto Exit;
    }


  Exit:
    if (pdentry)
        pdentry->Release();
    if(plmq)
        plmq->Release();
    TraceFunctLeave();
    return hr;
}

//---[ CConnMgr::ReleaseWaitingThreads ]---------------------------------------
//
//
//  Description:
//      Releases all threads waiting on get next connection.
//  Parameters:
//      -
//  Returns:
//      AQUEUE_E_NOT_INITIALIZED if event handle does not exist
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::ReleaseWaitingThreads()
{
    HRESULT hr = S_OK;

    if (m_paqinst)
        m_paqinst->SetShutdownHint();

    if (NULL == m_hReleaseAllEvent)
    {
        hr = AQUEUE_E_NOT_INITIALIZED;
        goto Exit;
    }

    //Since this is an manual-reset event, we will need to Set the Event
    //NOTE: Using PulseEvent here would sometimes cause the system to hang
    //on shutdown.
    if (!SetEvent(m_hReleaseAllEvent))
        hr = HRESULT_FROM_WIN32(GetLastError());

  Exit:
    return hr;
}

//---[ CreateETRNDomainList ]-----------------------------------------------------------
//
//
//  Description:
//      Implements CreateETRNDomainList. A function passed to the
//      DCT iterator to create a list of subdomains corresponding to the ETRN requests
//      of type @domain
//
//  Parameters:
//
//  Returns:
//
//
//---------------------------------------------------------------------------------

VOID CreateETRNDomainList(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete)
{
    CInternalDomainInfo    *pIntDomainInfo = (CInternalDomainInfo*)pvData;
    ETRNCTX         *pETRNCtx = (ETRNCTX*) pvContext;

    *pfContinue = TRUE;
    *pfDelete   = FALSE;
    HRESULT hr  = S_OK;

    TraceFunctEnterEx((LPARAM) NULL, "ETRNSubDomains");

    //We simply create a list of domains in DMT that match our pattern
    //IDI stands for InternalDomainInfo
    if( pETRNCtx && pIntDomainInfo)
    {
        //We add it to the array and add a reference to it
        pETRNCtx->rIDIList[pETRNCtx->cIDICount] = pIntDomainInfo;
        pIntDomainInfo->AddRef();
        if(++pETRNCtx->cIDICount >= MAX_ETRNDOMAIN_PER_COMMAND)
        {
            _ASSERT(0);
            pETRNCtx->hr = AQUEUE_E_ETRN_TOO_MANY_DOMAINS;
            *pfContinue = FALSE;
        }
    }
    else
    {
        if (pETRNCtx)
            pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
        *pfContinue = FALSE;
    }

    TraceFunctLeave();
    return;
}



//---[ LookupQueueforETRN ]--------------------------------------------------
//
//
//  Description:
//      Implements LookupQueueforETRN. A function passed to the
//      DMT iterator to lookup all queues for a wild card domain
//
//  Parameters:
//  Returns:
//
//
//---------------------------------------------------------------------------------

VOID LookupQueueforETRN(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete)
{
    CDomainEntry   *pdentry = (CDomainEntry*)pvData;
    CLinkMsgQueue   *plmq = NULL;
    CDomainEntryLinkIterator delit;
    CInternalDomainInfo    *pIntDomainInfo =NULL;
    ETRNCTX         *pETRNCtx = (ETRNCTX*) pvContext;
    char            *szSMTPDomain = NULL;
    DWORD           cbSMTPDomain = 0;
    DWORD           cMessages = 0;
    HRESULT hr  = S_OK;
    *pfContinue = TRUE;
    *pfDelete   = FALSE;


    TraceFunctEnterEx((LPARAM) NULL, "ETRNSubDomains");

    //If the Domain has messages it is candidate for ETRN
    //Get the link msg queue from the DMT entry
    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
        goto Exit;

    while (plmq = delit.plmqGetNextLinkMsgQueue(plmq))
    {

        //get the msg count from the dmq
        cMessages = plmq->cGetTotalMsgCount();

        if(cMessages)
        {
            //get the name of the domain we are currently considering
            hr = pdentry->HrGetDomainName(&szSMTPDomain);
            if (FAILED(hr))
            {
                //we had some internal error we need to stop iterating
                //Set the Hr in context
                DebugTrace((LPARAM) NULL, "Failed to get message count for %s", szSMTPDomain);
                *pfContinue = FALSE;
                pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                goto Exit;
            }
            cbSMTPDomain = lstrlen(szSMTPDomain);

            //Lookup it up in the DCT to see if there is an entry that conflicts with this
            //If there is no exact match the lookup will comeup with the closest configured
            //ancestor

            hr = pETRNCtx->paqinst->HrGetInternalDomainInfo(cbSMTPDomain, szSMTPDomain, &pIntDomainInfo);
            if (FAILED(hr))
            {
                //It must match the "*" domain at least
                //Otherwise we had some internal error we need to stop iterating
                //Set the Hr in context
                *pfContinue = FALSE;
                pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                goto Exit;
            }
            else
            {
                _ASSERT(pIntDomainInfo);
                //If that ancestor configured for ETRN and it is not the root, we enable it
                //else we skip domain
                //
                if ((pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags & DOMAIN_INFO_ETRN_ONLY) &&
                              pIntDomainInfo->m_DomainInfo.cbDomainNameLength != 1)
                {

                    pETRNCtx->cMessages += cMessages;
                    cMessages = 0;

                    //If it does - trigger the links.
                    DebugTrace((LPARAM) NULL, "Enabling ETRN for domain %s", szSMTPDomain);

                    plmq->dwModifyLinkState(
                            LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_RETRY_ENABLED,
                            LINK_STATE_NO_ACTION);

                }

            } //If we have a valid IntDomainInfo
        } //Message count is zero
    } //looping over lmq's for entry

Exit:
    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    if (szSMTPDomain)
        FreePv(szSMTPDomain);

    if (plmq)
        plmq->Release();

    return;
}


//---[ CConnMgr::ETRNDomainList ]--------------------------------------------------
//
//
//  Description:
//      Implements IConnectionManager:ETRNDomainList.  Used to ETRN appropriate
//      domains based on the list of CInternalDomainInfo passed in
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::ETRNDomainList(ETRNCTX *pETRNCtx)
{
    CInternalDomainInfo *pIntDomainInfo = NULL;

    BOOL fWildcard = FALSE;
    HRESULT hr = S_OK;
    DWORD i = 0;
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::ETRNDomain");

    //NK** Do I need to sort the pointers for duplicates ?
    if(!pETRNCtx->cIDICount)
    {
        //We have nothing in our list
        //
        hr = AQUEUE_E_INVALID_DOMAIN;
        goto Exit;

    }
    for(; i < pETRNCtx->cIDICount; i++)
    {
        if(!(pIntDomainInfo = pETRNCtx->rIDIList[i]))
        {
            //Error happend
            pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
            break;
        }
        //We go ahead only if the domain is marked for ETRN
        if ((pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags & DOMAIN_INFO_ETRN_ONLY))
        {
            //check if this is wild card domain
            fWildcard = FALSE;
            if( pIntDomainInfo->m_DomainInfo.szDomainName[0] == '*' &&
                            pIntDomainInfo->m_DomainInfo.cbDomainNameLength != 1)
            {
                fWildcard = TRUE;
            }
            //If the domain in the list is a wild card entry then
            if(fWildcard)
            {
                //So we have atleast one matching ETRN domain configured
                if(pETRNCtx->hr == S_OK)
                    pETRNCtx->hr = AQ_S_SMTP_WILD_CARD_NODE;
                //Lookup this domain and all its subdomains in the DMT
                //skip over the leading "*."
                hr = pETRNCtx->paqinst->HrIterateDMTSubDomains(pIntDomainInfo->m_DomainInfo.szDomainName + 2,
                                                            pIntDomainInfo->m_DomainInfo.cbDomainNameLength - 2,
                                                       (DOMAIN_ITR_FN)LookupQueueforETRN,  pETRNCtx);
                if (FAILED(hr) && hr != DOMHASH_E_NO_SUCH_DOMAIN && hr != AQUEUE_E_INVALID_DOMAIN)
                {
                     DebugTrace((LPARAM) NULL, "ERROR calling HrIterateDMTSubDomains");
                     goto Exit;
                }

            } // wild card DCT entry
            else
            {
                //Start the queue for the entry
                hr = StartETRNQueue(pIntDomainInfo->m_DomainInfo.cbDomainNameLength,
                                    pIntDomainInfo->m_DomainInfo.szDomainName,
                                    pETRNCtx);
                if (FAILED(hr))
                {
                    //NK** This actually may not be an error
                    //If we do not have a DMQ corresponding to it
                    //we should respond with zero message
                    if( hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
                    {
                        pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                        goto Exit;
                    }
                    else
                        continue;

                }
            } //not a wild card DCT entry
        }
    }

Exit:

    TraceFunctLeave();
    return hr;

}

//---[ CConnMgr::StartETRNQueue ]--------------------------------------------------
//
//
//  Description:
//      Implements CConnMgr::StartETRNQueuet.  Used to start the queue for any
//      domain configured for ETRN
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::StartETRNQueue(IN  DWORD   cbSMTPDomain,
                         IN  char szSMTPDomain[],
                         ETRNCTX *pETRNCtx)
{
    CDomainEntry    *pdentry = NULL;
    CDomainEntryLinkIterator delit;
    CLinkMsgQueue   *plmq = NULL;
    CAQSvrInst      *paqinst = pETRNCtx->paqinst;
    DWORD           cMessages = 0;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "CConnMgr::ETRNDomain");

    //So we have a domain configured for ETRN by this name
    if( pETRNCtx->hr == S_OK)
        pETRNCtx->hr = AQ_S_SMTP_VALID_ETRN_DOMAIN;

    //Check if it has a queue in DMT for it
    hr = pETRNCtx->paqinst->HrGetDomainEntry(cbSMTPDomain, szSMTPDomain, &pdentry);
    if (FAILED(hr))
    {
        //If we do not have a DMQ corresponding to it
        //we should respond with zero message
        if( hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
        {
            pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
        }
        goto Exit;

    }

    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
        goto Exit;

    while (plmq = delit.plmqGetNextLinkMsgQueue(plmq))
    {
        //get the msg count from the dmq
        cMessages = plmq->cGetTotalMsgCount();

        if(cMessages)
        {
            pETRNCtx->cMessages += cMessages;
            cMessages = 0;

            //If it does - trigger the link.
            DebugTrace((LPARAM) NULL, "Enabling ETRN for domain %s", szSMTPDomain);
            plmq->dwModifyLinkState(
                        LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_RETRY_ENABLED,
                        LINK_STATE_NO_ACTION);

        }

    }

Exit:
    if (pdentry)
        pdentry->Release();

    if (plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;

}

//---[ CConnMgr::ETRNDomain ]----------------------------------------------------
//
//
//  Description:
//      Implements IConnectionManager:ETRNDomain.  Used to reqeust that a
//      domain be ETRN'd (enabled for outbound connections).
//  Parameters:
//      IN  cbSMTPDomain    String length of domain name
//      IN  szSMTPDomain    SMTP Domain name.  Wildcarded names start with
//                          a "@" (eg "@foo.com");
//      OUT pcMessages      # of Messages queued for ETRN domain
//  Returns:
//  Remarks:
//  If the received domain is wildcarded '@' then we follow this logic :
//      Lookup this node and every subnode of this node in DCT. The lookup is done
//  using table iterator and iterator function CreateETRNDomainList. For every entry
//  that is found with ETRN flag set, lookup if any queues exist in DMT. If the
//  queue exist and have messages in them then we enable the corresponding links.
//      If the lookup in DCT yields a domain that is configured as wild card '*.",
//  then we lookup all queus corresponding to all sub domains of that domain. We do
//  this using the iterator and iterator function LookupQueueforETRN. For every queue
//  found by iterator the function checks back in DMT if the domain is configured for
//  ETRN. This is to take care of situations where one specific subdomain of a wild
//  card configured domain may be not configured for etrn.
//      Eg : *.foo.com => ETRN, but 1.foo.com => NO_ETRN
//
//  Both calls to iterate are covered with reader locks. The lock stays valid for
//  the duration of all iterations.
//  The iterator function used during DCT iterations also adds reference to every
//  InternalDomainInfo as we need the data to stay valid after the table lock is released.
//----------------------------------------------------------------------------------
STDMETHODIMP CConnMgr::ETRNDomain(
                          IN  DWORD   cbSMTPDomain,
                         IN  char szSMTPDomain[],
                         OUT DWORD *pcMessages)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    CDomainEntry   *pdentry = NULL;
    CDestMsgQueue *pdmq = NULL;
    CInternalDomainInfo    *pIntDomainInfo =NULL;

    BOOL    fETRNSubDomains = FALSE;

    char    * szTmpDomain = szSMTPDomain;
    ETRNCTX EtrnCtx;
    EtrnCtx.hr = S_OK;
    EtrnCtx.cMessages = 0;
    EtrnCtx.paqinst = NULL;
    EtrnCtx.cIDICount = 0;
    EtrnCtx.rIDIList[0] = NULL;

    TraceFunctEnterEx((LPARAM) this, "CConnMgr::ETRNDomain");

    DWORD      cMessages = 0;

    *pcMessages = 0;  //$$TODO - Get real values


    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    m_paqinst->RoutingShareLock();
    fLocked = TRUE;

    EtrnCtx.paqinst = m_paqinst;

    //do we have a '@' request
    if(*szTmpDomain == '@')
        fETRNSubDomains = TRUE;

    //If we do have '@' request, we need to skip the first chararcter
    //and then look for every sub domain of the domain in the DCT
    //For every subdomain that we find with ETRN flag, we will lookup the
    //DMT to see if there is a queue
    //If the entry we find in DCT is of wildcard type, we will lookup all
    //subdomains of that domain in DMT looking for all queues destined for
    //subdomains of the DCT entry.
    if(fETRNSubDomains)
    {
        ++szTmpDomain;
        //Create a list of all subdomains of this domain in the DCT
        hr = m_paqinst->HrIterateDCTSubDomains(szTmpDomain, lstrlen(szTmpDomain),
                                        (DOMAIN_ITR_FN)CreateETRNDomainList, &EtrnCtx);

        //If we fail to look up single domain
        if (FAILED(hr))
        {
            if(hr == AQUEUE_E_INVALID_DOMAIN || hr == DOMHASH_E_NO_SUCH_DOMAIN)
            {
                DebugTrace((LPARAM)this, "ERROR calling HrIterateDCTSubdomains");
                hr = hr = AQ_E_SMTP_ETRN_NODE_INVALID;
            }
            else
            {
                DebugTrace((LPARAM)this, "ERROR calling HrIterateDCTSubdomains");
                hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
            }
            goto Exit;
        }

        //Check if the lookup got us anything
        if(!FAILED(EtrnCtx.hr))
        {
            //Check if any queus can be started for domains in the list
            //Start if possible
            hr = ETRNDomainList(&EtrnCtx);
            if (FAILED(hr))
            {
                if(hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
                {
                    DebugTrace((LPARAM)this, "ERROR calling ETRNSubDomain");
                    hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                    goto Exit;
                }
            }

            //If we saw atleast one matching domain
            if(EtrnCtx.hr == AQ_S_SMTP_VALID_ETRN_DOMAIN || EtrnCtx.hr == AQ_S_SMTP_WILD_CARD_NODE)
            {
                *pcMessages = EtrnCtx.cMessages;
                hr = EtrnCtx.hr;
            }
            else
                hr = AQ_E_SMTP_ETRN_NODE_INVALID;
        }
        else
            hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;

        goto Exit;
    }
    else
    {
        //Lookup the domain in the domain cfg table and see if it has ETRN bit set
        _ASSERT(m_paqinst);
        hr = m_paqinst->HrGetInternalDomainInfo(cbSMTPDomain, szSMTPDomain, &pIntDomainInfo);
        if (FAILED(hr))
        {
            //It must match the "*" domain at least
            _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
            hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
            goto Exit;
        }
        else
        {
            _ASSERT(pIntDomainInfo);
             EtrnCtx.rIDIList[0] = pIntDomainInfo;
             EtrnCtx.cIDICount = 1;

            //We will not ETRN if the closest ancestor is Root or two level
            //NK** implement search for two level
            if( pIntDomainInfo->m_DomainInfo.cbDomainNameLength == 1)
            {
                //Cannot ETRN based on the root domain
                hr = AQ_E_SMTP_ETRN_NODE_INVALID;
                goto Exit;
            }

            if ((pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags & DOMAIN_INFO_ETRN_ONLY))
            {
                //Start the queue if exists for this domain
                hr = StartETRNQueue(cbSMTPDomain, szSMTPDomain,&EtrnCtx);
                if (FAILED(hr))
                {
                    if(hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
                    {
                        DebugTrace((LPARAM)this, "ERROR calling ETRNSubDomain");
                        hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                        goto Exit;
                    }
                }

                //If we saw atleast one matching domain
                if(EtrnCtx.hr == AQ_S_SMTP_VALID_ETRN_DOMAIN || EtrnCtx.hr == AQ_S_SMTP_WILD_CARD_NODE)
                {
                    *pcMessages = EtrnCtx.cMessages;
                    hr = AQ_S_SMTP_VALID_ETRN_DOMAIN;
                }
                else
                    hr = AQ_E_SMTP_ETRN_NODE_INVALID;

                goto Exit;
            }
            else
            {
                //Cannot ETRN based on the root domain
                hr = AQ_E_SMTP_ETRN_NODE_INVALID;
                goto Exit;
            }
        }
    }



Exit:

    //wake up thread in GetNextConnection
    if (SUCCEEDED(hr) &&SUCCEEDED(EtrnCtx.hr) && EtrnCtx.cMessages)
        _VERIFY(SetEvent(m_hNextConnectionEvent));


    if (fLocked)
    {
        m_paqinst->RoutingShareUnlock();
        ShutdownUnlock();
    }

    //free up all InternalDomainInfo
    for(DWORD i=0; i < EtrnCtx.cIDICount; i++)
        if (EtrnCtx.rIDIList[i])
            EtrnCtx.rIDIList[i]->Release();

    if (pdentry)
        pdentry->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CConnMgr::ModifyLinkState ]---------------------------------------------
//
//
//  Description:
//      Link state can change so that connections can(not) be created for a link.
//  Parameters:
//      IN cbDomainName     String length of domain name
//      IN szDomainName     Domain Name to enable
//      IN dwScheduleID     ScheduleID of <domain, schedule> pair
//      IN rguidTransportSink GUID of router associated with link
//      IN dwFlagsToSet     Link State Flags to set
//      IN dwFlagsToUnset   Link State Flags to unset
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain does not exist
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::ModifyLinkState(
               IN  DWORD cbDomainName,
               IN  char szDomainName[],
               IN  DWORD dwScheduleID,
               IN  GUID rguidTransportSink,
               IN  DWORD dwFlagsToSet,
               IN  DWORD dwFlagsToUnset)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    CDomainEntry *pdentry = NULL;
    CLinkMsgQueue *plmq = NULL;
    CAQScheduleID aqsched(rguidTransportSink, dwScheduleID);

    if (!cbDomainName || !szDomainName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    _ASSERT(m_paqinst);
    hr = m_paqinst->HrGetDomainEntry(cbDomainName, szDomainName, &pdentry);
    if (FAILED(hr))
        goto Exit;

    hr = pdentry->HrGetLinkMsgQueue(&aqsched, &plmq);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(plmq);
    //filter out the reserved bits for this "public" API
    plmq->dwModifyLinkState(~LINK_STATE_RESERVED & dwFlagsToSet,
                            ~LINK_STATE_RESERVED & dwFlagsToUnset);

  Exit:
    if (fLocked)
        ShutdownUnlock();

    if (pdentry)
        pdentry->Release();

    if (plmq)
        plmq->Release();

    return hr;
}

//---[ CConnMgr::UpdateConfigData ]-------------------------------------------
//
//
//  Description:
//      Will be used by catmsgq to update the metabase changes
//
//  Parameters:
//
//  Returns:
//
//-----------------------------------------------------------------------------
//

void CConnMgr::UpdateConfigData(IN AQConfigInfo *pAQConfigInfo)
{
    BOOL    fUpdated = FALSE;
    RETRYCONFIG RetryConfig;

    RetryConfig.dwRetryThreshold = g_dwRetryThreshold;
    RetryConfig.dwGlitchRetrySeconds = g_dwGlitchRetrySeconds;

    //
    //  This is registry configurable... make sure we have a sane
    //  value
    //
    if (!RetryConfig.dwGlitchRetrySeconds)
        RetryConfig.dwGlitchRetrySeconds = 60;

    RetryConfig.dwFirstRetrySeconds = g_dwFirstTierRetrySeconds;
    RetryConfig.dwSecondRetrySeconds = g_dwSecondTierRetrySeconds;
    RetryConfig.dwThirdRetrySeconds = g_dwThirdTierRetrySeconds;
    RetryConfig.dwFourthRetrySeconds = g_dwFourthTierRetrySeconds;

    m_slPrivateData.ExclusiveLock();
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MAX_CON &&
        MEMBER_OK(pAQConfigInfo, cMaxConnections))
    {
        if ((m_cMaxConnections != pAQConfigInfo->cMaxConnections))
        {
            fUpdated = TRUE;

            //g_cMaxConnections is the number connection objects we
            //reserve with CPool... we can't go above that.
            if (g_cMaxConnections < pAQConfigInfo->cMaxConnections)
                m_cMaxConnections = g_cMaxConnections;
            else
                m_cMaxConnections = pAQConfigInfo->cMaxConnections;
        }
    }

    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MAX_LINK &&
        MEMBER_OK(pAQConfigInfo, cMaxLinkConnections))
    {
        if (m_cMaxLinkConnections != pAQConfigInfo->cMaxLinkConnections)
        {
            fUpdated = TRUE;
            //g_cMaxConnections is the number connection objects we
            //reserve with CPool... we can't go above that.
            if (!pAQConfigInfo->cMaxLinkConnections ||
                (g_cMaxConnections < pAQConfigInfo->cMaxLinkConnections))
                m_cMaxLinkConnections = g_cMaxConnections;
            else
                m_cMaxLinkConnections = pAQConfigInfo->cMaxLinkConnections;
        }
    }

    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MIN_MSG &&
        MEMBER_OK(pAQConfigInfo, cMinMessagesPerConnection))
    {

        if (m_cMinMessagesPerConnection != pAQConfigInfo->cMinMessagesPerConnection)
        {
            fUpdated = TRUE;
            m_cMinMessagesPerConnection = pAQConfigInfo->cMinMessagesPerConnection;
            //Currently we set both these values based on the batching value from SMTP
            m_cMaxMessagesPerConnection = pAQConfigInfo->cMinMessagesPerConnection;
        }

    }

    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_WAIT &&
        MEMBER_OK(pAQConfigInfo, dwConnectionWaitMilliseconds))
    {
        if (m_cGetNextConnectionWaitTime != pAQConfigInfo->dwConnectionWaitMilliseconds)
        {
            fUpdated = TRUE;
            m_cGetNextConnectionWaitTime = pAQConfigInfo->dwConnectionWaitMilliseconds;
        }
    }

    if (fUpdated) //only force updated when really required
        InterlockedIncrement((PLONG) &m_dwConfigVersion);

    m_slPrivateData.ExclusiveUnlock();

    fUpdated = FALSE;

    //Retry related config data
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwRetryThreshold))
    {
        fUpdated = TRUE;
        RetryConfig.dwRetryThreshold = pAQConfigInfo->dwRetryThreshold;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwFirstRetrySeconds))
    {
        fUpdated = TRUE;
        RetryConfig.dwFirstRetrySeconds = pAQConfigInfo->dwFirstRetrySeconds;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwSecondRetrySeconds))
    {
        fUpdated = TRUE;
        RetryConfig.dwSecondRetrySeconds = pAQConfigInfo->dwSecondRetrySeconds;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwThirdRetrySeconds))
    {
        fUpdated = TRUE;
        RetryConfig.dwThirdRetrySeconds = pAQConfigInfo->dwThirdRetrySeconds;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwFourthRetrySeconds))
    {
        fUpdated = TRUE;
        RetryConfig.dwFourthRetrySeconds = pAQConfigInfo->dwFourthRetrySeconds;
    }

    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        fUpdated )
        m_pDefaultRetryHandler->UpdateRetryData(&RetryConfig);

}




//---[ CConnMgr::RetryLink ]---------------------------------------------------
//
//
//  Description:
//      Implements IConnectionRetryManager::RetryLink, which enables the retry
//      sink to enable a link for retry.
//  Parameters:
//      IN cbDomainName     String length of domain name
//      IN szDomainName     Domain Name to enable
//      IN dwScheduleID     ScheduleID of <domain, schedule> pair
//      IN rguidTransportSink GUID of router associated with link
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain does not exist
//  History:
//      1/9/99 - MikeSwa Created (simplified routing sink)
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::RetryLink(
               IN  DWORD cbDomainName,
               IN  char szDomainName[],
               IN  DWORD dwScheduleID,
               IN  GUID rguidTransportSink)
{
    HRESULT hr = S_OK;
    hr = ModifyLinkState(cbDomainName, szDomainName, dwScheduleID,
                rguidTransportSink, LINK_STATE_RETRY_ENABLED,
                LINK_STATE_NO_ACTION);

    //
    //  Kick the connections so we know to make one
    //
    KickConnections();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asyncadm.inl ===
//-----------------------------------------------------------------------------
//
//
//  File: asyncadm.inl
//
//  Description:
//      Implementation of CAsyncAdminQueue class.  See header file for object
//      model
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/7/2000 - MikeSwa Created
//          (pulled from asyncq.cpp and t-toddc's summer work)
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------

//---[ CAsyncAdminQueue::CAsyncAdminQueue ]------------------------------------
//
//
//  Description:
//      Constructor for CAsyncRetryAdminMsgRefQueue
//  Parameters:
//      szDomain        Domain name for this queue
//      pguid           GUID for this queue
//      dwID            Shedule ID for this queue
//  Returns:
//      -
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::CAsyncAdminQueue(
                        LPCSTR szDomain, LPCSTR szLinkName,
                        const GUID *pguid, DWORD dwID, CAQSvrInst *paqinst,
                        typename CFifoQueue<PQDATA>::MAPFNAPI pfnMessageAction)
{
    _ASSERT(szDomain);
    _ASSERT(pguid);

    m_cbDomain = 0;
    m_szDomain = NULL;
    m_cbLinkName = 0;
    m_szLinkName = NULL;
    m_pAQNotify = NULL;
    m_paqinst = paqinst;
    m_pfnMessageAction = pfnMessageAction;

    _ASSERT(m_pfnMessageAction);

    if (szDomain)
    {
        m_cbDomain = lstrlen(szDomain);
        m_szDomain = (LPSTR) pvMalloc(m_cbDomain+1);
        if (m_szDomain)
            lstrcpy(m_szDomain, szDomain);
    }

    if (szLinkName)
    {
        m_cbLinkName = lstrlen(szLinkName);
        m_szLinkName = (LPSTR) pvMalloc(m_cbLinkName+1);
    }

    if (m_szLinkName)
        lstrcpy(m_szLinkName, szLinkName);

    if (pguid)
        memcpy(&m_guid, pguid, sizeof(GUID));
    else
        ZeroMemory(&m_guid, sizeof(GUID));

    m_dwID = dwID;
}

//---[ CAsyncAdminQueue::~CAsyncAdminQueue ]-----------------------------------
//
//
//  Description:
//      Destructor for CAsyncAdminQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::~CAsyncAdminQueue()
{
    if (m_szDomain)
        FreePv(m_szDomain);

    if (m_szLinkName)
        FreePv(m_szLinkName);
}

//---[ CAsyncAdminQueue::HrInitialize ]----------------------------------------
//
//
//  Description: 
//      Wrapper for parent class HrInitialize... used to call set
//      CHandleManager
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/18/2001 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::HrInitialize(
                DWORD cMaxSyncThreads,
                DWORD cItemsPerATQThread,
                DWORD cItemsPerSyncThread,
                PVOID pvContext,
                QCOMPFN pfnQueueCompletion,
                QCOMPFN pfnFailedItem,
                typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFailure,
                DWORD cMaxPendingAsyncCompletions)
{
    HRESULT hr = S_OK;

    hr = CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrInitialize(cMaxSyncThreads,
            cItemsPerATQThread, cItemsPerSyncThread, pvContext, 
            pfnQueueCompletion, pfnFailedItem, pfnQueueFailure, 
            cMaxPendingAsyncCompletions);
    
    m_qhmgr.SetMaxConcurrentItems(s_cDefaultMaxAsyncThreads, cMaxSyncThreads);
    return hr;
}

//---[ CAsyncAdminQueue::QueryInterface ]---------------------------
//
//
//  Description:
//      QueryInterface for CAsyncAdminQueue that supports:
//          - IQueueAdminAction
//          - IUnknown
//          - IQueueAdminQueue
//  Parameters:
//
//  Returns:
//
//  History:
//      2/23/99 - MikeSwa Created
//      12/7/2000 - MikeSwa Modified - Made template base class
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
STDMETHODIMP CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::QueryInterface(
                                                  REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminAction == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminQueue == riid)
    {
        *ppvObj = static_cast<IQueueAdminQueue *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CAsyncAdminQueue::HrApplyQueueAdminFunction ]----------------
//
//
//  Description:
//      Will call the IQueueAdminMessageFilter::Process message for every
//      message in this queue.  If the message passes the filter, then
//      HrApplyActionToMessage on this object will be called.
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created
//      12/7/2000 - MikeSwa Modified - Made template base class
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
STDMETHODIMP CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::HrApplyQueueAdminFunction(
                     IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    HRESULT hr = S_OK;
    CQueueAdminContext qapictx(m_pAQNotify, m_paqinst);
    _ASSERT(pIQueueAdminMessageFilter);
    hr = pIQueueAdminMessageFilter->HrSetQueueAdminAction(
                                    (IQueueAdminAction *) this);

    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetQueueAdminAction");

    if (FAILED(hr))
        goto Exit;

    hr = pIQueueAdminMessageFilter->HrSetCurrentUserContext(&qapictx);
    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetCurrentUserContext");
    if (FAILED(hr))
        goto Exit;

    hr = HrMapFn(m_pfnMessageAction, pIQueueAdminMessageFilter);

    hr = pIQueueAdminMessageFilter->HrSetCurrentUserContext(NULL);
    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetCurrentUserContext");
    if (FAILED(hr))
        goto Exit;

    //
    //   If we have thawed any messages we need to kick the retry queue to make sure
    //  they get processed.
    //
    if (qapictx.cGetNumThawedMsgs())
        StartRetry();

  Exit:
    return hr;
}

//---[ CAsyncAdminQueue::HrApplyActionToMessage ]-------------------
//
//
//  Description:
//      Applies an action to this message for this queue.  This will be called
//      by the IQueueAdminMessageFilter during a queue enumeration function.
//  Parameters:
//      IN  *pIUnknownMsg       ptr to message abstraction
//      IN  ma                  Message action to perform
//      IN  pvContext           Context set on IQueueAdminFilter
//      OUT pfShouldDelete      TRUE if the message should be deleted
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created
//      4/2/99 - MikeSwa Added context
//      12/7/2000 - MikeSwa Modified - Made template base class
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
STDMETHODIMP CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::HrApplyActionToMessage(
                     IUnknown *pIUnknownMsg,
                     MESSAGE_ACTION ma,
                     PVOID pvContext,
                     BOOL *pfShouldDelete)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminQueue::HrApplyActionToMessage");
    HRESULT hr = S_OK;
    CQueueAdminContext *pqapictx = (CQueueAdminContext *) pvContext;
    CAQStats aqstats;
    CAQStats *paqstats = &aqstats;

    _ASSERT(pIUnknownMsg);
    _ASSERT(pfShouldDelete);

    //
    //  If we have a context... it better be valid
    //
    if (pqapictx && !pqapictx->fIsValid()) {
        _ASSERT(FALSE && "CQueueAdminContext is not valid");
        pqapictx = NULL;  //be defensive... don't use it.
    }

    *pfShouldDelete = FALSE;

    switch (ma)
    {
      case MA_DELETE:
        hr = HrDeleteMsgFromQueueNDR(pIUnknownMsg);
        *pfShouldDelete = TRUE;
        break;
      case MA_DELETE_SILENT:
        hr = HrDeleteMsgFromQueueSilent(pIUnknownMsg);
        *pfShouldDelete = TRUE;
        break;
      case MA_FREEZE_GLOBAL:
        hr = HrFreezeMsg(pIUnknownMsg);
        break;
      case MA_THAW_GLOBAL:
        hr = HrThawMsg(pIUnknownMsg);
        if (pqapictx)
            pqapictx->IncThawedMsgs();
        break;
      case MA_COUNT:
      default:
        //do nothing for counting and default
        break;
    }

    //
    //  If we are deleting the message, we need to tell the
    //  link so we can have accurate stats for the link.
    //
    if (*pfShouldDelete && SUCCEEDED(hr))
    {
        if (pqapictx)
        {
            hr = HrGetStatsForMsg(pIUnknownMsg, &aqstats);
            if (FAILED(hr))
            {
                paqstats = NULL;
                ErrorTrace((LPARAM) this, "Unable to get Msg Stats0x%08X", hr);
            }
            pqapictx->NotifyMessageRemoved(paqstats);
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CAsyncAdminQueue::HrGetQueueInfo ]---------------------------
//
//
//  Description:
//      Gets the Queue Admin info for this Queue
//  Parameters:
//      IN OUT pqiQueueInfo     Ptr to Queue Info Stucture to fill
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate memory for queue name.
//  History:
//      2/23/99 - MikeSwa Created
//      12/7/2000 - MikeSwa Modified - Made template base class
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::HrGetQueueInfo(QUEUE_INFO *pqiQueueInfo)
{
    HRESULT hr = S_OK;

    //Get # of messages
    pqiQueueInfo->cMessages = m_cItemsPending+m_cRetryItems;

    //Get Link name: Note that this class is used for special links like
    //local delivery queue... so there is no destination SMTP domain to
    //route to... therefore we need to return a special link name to admin.

    pqiQueueInfo->szLinkName = wszQueueAdminConvertToUnicode(m_szLinkName,
                                                             m_cbLinkName);

    if (m_szDomain)
    {
        //Get Queue name
        pqiQueueInfo->szQueueName = wszQueueAdminConvertToUnicode(m_szDomain,
                                                                  m_cbDomain);
        if (!pqiQueueInfo->szQueueName)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

    }

    //Currently setting this to zero since we do not calculate it
    pqiQueueInfo->cbQueueVolume.QuadPart = 0;

    pqiQueueInfo->dwMsgEnumFlagsSupported = AQUEUE_DEFAULT_SUPPORTED_ENUM_FILTERS;

  Exit:
    return hr;
}

//---[ CAsyncAdminMsgRefQueue::HrGetQueueID ]----------------------------------
//
//
//  Description:
//      Gets the QueueID for this Queue.
//  Parameters:
//      IN OUT pQueueID     QUEUELINK_ID struct to fill in
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate memory for queue name.
//  History:
//      2/23/99 - MikeSwa Created
//      12/7/2000 - MikeSwa Modified - Made template base class
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::HrGetQueueID(
                                                    QUEUELINK_ID *pQueueID)
{
    pQueueID->qltType = QLT_QUEUE;
    pQueueID->dwId = m_dwID;
    memcpy(&pQueueID->uuid, &m_guid, sizeof(GUID));

    if (m_szDomain)
    {
        pQueueID->szName = wszQueueAdminConvertToUnicode(m_szDomain, m_cbDomain);
        if (!pQueueID->szName)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}


//---[ CAsyncAdminQueue::fMatchesID ]-------------------------------
//
//
//  Description:
//      Used to determine if this link matches a given scheduleID/guid pair
//  Parameters:
//      IN  QueueLinkID         ID to match against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created
//      12/7/2000 - MikeSwa Modified - Made template base class
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL STDMETHODCALLTYPE CAsyncAdminQueue<PQDATA, TEMPLATE_SIG>::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    _ASSERT(pQueueLinkID);

    if (!pQueueLinkID)
        return FALSE;

    if (0 != memcmp(&m_guid, &(pQueueLinkID->uuid), sizeof(GUID)))
        return FALSE;

    if (m_dwID != pQueueLinkID->dwId)
        return FALSE;

    //Don't need to check domain name since there is a special GUID to
    //identify the async queues.

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asyncq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: asyncq.h
//
//  Description: Header file for CAsyncQueue class, which provides the
//      underlying implementation of pre-local delivery and pre-categorization
//      queue.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/16/98 - MikeSwa Created
//      2/2/99 - MikeSwa Added CAsyncRetryQueue
//      2/22/99 - MikeSwa Added  CAsyncRetryAdminMsgRefQueue
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __ASYNCQ_H__
#define __ASYNCQ_H__
#include <fifoq.h>
#include <intrnlqa.h>
#include <baseobj.h>
#include <aqstats.h>
#include "statemachinebase.h"

_declspec(selectany) BOOL   g_fRetryAtFrontOfAsyncQueue = FALSE;

// global count of total number of async threads needed
_declspec(selectany) DWORD g_cTotalThreadsNeeded = 0;

class CAQSvrInst;
class CAsyncWorkQueueItem;

// sig for state machine
#define ASYNC_QUEUE_STATE_MACHINE_SIG 'MSQA'

#define ASYNC_QUEUE_SIG         'QnsA'
#define ASYNC_RETRY_QUEUE_SIG   ' QRA'

//Add new template signatures here
#define ASYNC_QUEUE_MAILMSG_SIG 'MMIt'
#define ASYNC_QUEUE_MSGREF_SIG  'frMt'
#define ASYNC_QUEUE_WORK_SIG    'krWt'

//---[ CAsyncQueueBase ]-------------------------------------------------------
//
//
//  Description:
//      Base class for CAsyncQueue.  This is a separate class for 2 reasons.
//      The most important reason to to allow access to standard member data
//      with out knowing the template type of the class (for ATQ completion
//      functions).  The 2nd reason is to make it easier to write a debugger
//      extension to dump this information.
//
//      This class should only be used as a baseclass for CAsyncQueue... it
//      is not designed to be used by itself.
//  Hungarian:
//      asyncqb, pasyncqb
//
//-----------------------------------------------------------------------------
class CAsyncQueueBase : public CStateMachineBase
{
  protected:
    DWORD   m_dwSignature;
    DWORD   m_dwTemplateSignature;      //signature that defines type of PQDATA (for ATQ)
    DWORD   m_cMaxSyncThreads;          //max threads that can complete sync
    DWORD   m_cCurrentSyncThreads;      //current sync threads
    DWORD   m_cCurrentAsyncThreads;     //current number of async threads
    DWORD   m_cItemsPending;            //# of items pending in the queue
    LONG    m_cItemsPerATQThread;       //max # of items an atq thread will process
    LONG    m_cItemsPerSyncThread;      //max # of items a pilfered thread will process
    DWORD   m_cScheduledWorkItems;      // Number of items that a thread has been allocated for
    DWORD   m_cCurrentCompletionThreads;//# of threads processing end of queue
    DWORD   m_cTotalAsyncCompletionThreads;//Total # of async completion threads
    DWORD   m_cTotalSyncCompletionThreads; //Total # of sync completion threads
    DWORD   m_cTotalShortCircuitThreads; //Total # of threads that proccess data without queue
    DWORD   m_cCompletionThreadsRequested; //# of threads requested to process queue
    DWORD   m_cPendingAsyncCompletions; //# of async completions that we know about
    DWORD   m_cMaxPendingAsyncCompletions;
    PVOID   m_pvContext;                //Context that is passed to completion function
    PATQ_CONTEXT m_pAtqContext;         //ATQ Context for this object
    SOCKET  m_hAtqHandle;               //Handle used for atq stuff
    DWORD   m_cThreadsNeeded;           // Number of threads we need currently to ideally
                                        // process the queue - used for thread management

    friend  VOID AsyncQueueAtqCompletion(PVOID pvContext, DWORD vbBytesWritten,
                             DWORD dwStatus, OVERLAPPED *pOverLapped);
    inline  CAsyncQueueBase(DWORD dwTemplateSignature);
   
    // possible states
    enum
    {
        ASYNC_QUEUE_STATUS_NORMAL       = 0x00000000,
        ASYNC_QUEUE_STATUS_PAUSED       = 0x00000001,
        ASYNC_QUEUE_STATUS_FROZEN       = 0x00000002,
        ASYNC_QUEUE_STATUS_FROZENPAUSED = 0x00000003,
        ASYNC_QUEUE_STATUS_SHUTDOWN     = 0x00000004,
    };

    // possible internal queue actions
    enum
    {
        ASYNC_QUEUE_ACTION_KICK       = 0x00000000,
        ASYNC_QUEUE_ACTION_FREEZE     = 0x00000001,
        ASYNC_QUEUE_ACTION_THAW       = 0x00000002,
        ASYNC_QUEUE_ACTION_PAUSE      = 0x00000003,
        ASYNC_QUEUE_ACTION_UNPAUSE    = 0x00000004,
        ASYNC_QUEUE_ACTION_SHUTDOWN   = 0x00000005,
    };

    //
    //  Statics used for ATQ stuff.
    //
    static DWORD s_cAsyncQueueStaticInitRefCount;
    static DWORD s_cMaxPerProcATQThreadAdjustment;
    static DWORD s_cDefaultMaxAsyncThreads;

    //
    // Statics uses for debugging thread management
    //
    static DWORD s_cThreadCompletion_QueueEmpty;                // Completed because the queue was empty
    static DWORD s_cThreadCompletion_CompletedScheduledItems;   // Completed because we processed all items we were scheduled for
    static DWORD s_cThreadCompletion_UnacceptableThreadCount;   // Completed because our queue was consuming more threads than allowed
    static DWORD s_cThreadCompletion_Timeout;                   // Completed because the thread was taking too long to process
    static DWORD s_cThreadCompletion_Failure;                   // Completed because an item failed
    static DWORD s_cThreadCompletion_Paused;                    // Completed because the queue was paused

    void ThreadPoolInitialize();
    void ThreadPoolDeinitialize();

    // used for state machine stuff
    static STATE_TRANSITION s_rgTransitionTable[];
    virtual void getTransitionTable(const STATE_TRANSITION** ppTransitionTable,
                                    DWORD* pdwNumTransitions);


  public:
      DWORD dwGetTotalThreads()
      {
          return (  m_cCurrentSyncThreads +
                    m_cCurrentAsyncThreads +
                    m_cCompletionThreadsRequested);
      }

      //
      //  Start point for worker threads
      //
      virtual void StartThreadCompletionRoutine(BOOL fSync) = 0;

};

//---[ CAsyncQueue ]-----------------------------------------------------------
//
//
//  Description:
//      FIFO queue that allows thread-throttling and async completion.
//      Inherits from CAsyncQueueBase.
//  Hungarian:
//      asyncq, pasyncq
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
class CAsyncQueue : public CAsyncQueueBase
{
  public:
    typedef BOOL (*QCOMPFN)(PQDATA pqdItem, PVOID pvContext); //function type for Queue completion
    CAsyncQueue();
    ~CAsyncQueue();
    HRESULT HrInitialize(
                DWORD cMaxSyncThreads,
                DWORD cItemsPerATQThread,
                DWORD cItemsPerSyncThread,
                PVOID pvContext,
                QCOMPFN pfnQueueCompletion,
                QCOMPFN pfnFailedItem,
                typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFailure,
                DWORD cMaxPendingAsyncCompletions = 0);

    HRESULT HrDeinitialize(typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueShutdown,
                           CAQSvrInst *paqinst);

    HRESULT HrQueueRequest(PQDATA pqdata, BOOL fRetry = FALSE); //Queue request for processing
    void    StartThreadCompletionRoutine(BOOL fSync);  //Start point for worker threads
    void    RequestCompletionThreadIfNeeded();
    BOOL    fThreadNeededAndMarkWorkPending(BOOL fSync);
    virtual BOOL   fHandleCompletionFailure(PQDATA pqdata);
    void    StartRetry() {UnpauseQueue();RequestCompletionThreadIfNeeded();};
    virtual HRESULT HrMapFn(typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn, PVOID pvContext);
    DWORD   cGetItemsPending() {return m_cItemsPending;};

    //
    //  "Pause" API - This is used to throttle async completions
    //
    void    PauseQueue() { dwGetNextState(ASYNC_QUEUE_ACTION_PAUSE); UpdateThreadsNeeded();};
    void    UnpauseQueue();
    inline BOOL    fIsPaused() {return (ASYNC_QUEUE_STATUS_PAUSED == dwGetCurrentState());};

    //
    // "Freeze" API - This is used to allow the QAPI to freeze/thaw a queue
    //
    void    FreezeQueue() { dwGetNextState(ASYNC_QUEUE_ACTION_FREEZE); UpdateThreadsNeeded();};
    void    ThawQueue();
    inline BOOL    fIsFrozen() {return (ASYNC_QUEUE_STATUS_FROZEN == dwGetCurrentState());};

    // "Kick" API
    // kicking the queue overrides freezing, so if it is frozen it should be thawed.
    void    KickQueue() { ThawQueue(); StartRetry(); };

    // chefking for shutdown
    inline BOOL fInShutdown() {return (ASYNC_QUEUE_STATUS_SHUTDOWN == dwGetCurrentState());};

    // Denotes whether threads should stop processing.  (replaces fIsPaused)
    inline BOOL fShouldStopProcessing() { return (fIsFrozen() || fIsPaused());};
    
    //
    //  Tells the queue about pending async completions, so it can be
    //  intelligent about throttling.  As we hit the limit, we will
    //  pause/unpause the queue
    //
    void    IncPendingAsyncCompletions();
    void    DecPendingAsyncCompletions();
    BOOL    fNoPendingAsyncCompletions();

    //
    //  Basic QAPI functionality
    //
    DWORD   cQueueAdminGetNumItems() {return m_cItemsPending;};
    DWORD   dwQueueAdminLinkGetLinkState();

  protected:
    CFifoQueue<PQDATA>  m_fqQueue;       //queue for items

    //Function called to handle item pulled off of queue
    QCOMPFN m_pfnQueueCompletion;

    //Function called to handle items that could not be called due to resource
    //failures (for example during MergeRetryQueue).
    QCOMPFN m_pfnFailedItem;

    //Function called to walk the queues when the completion function fails
    typename CFifoQueue<PQDATA>::MAPFNAPI m_pfnQueueFailure;

    //Process the item at the head of the queue
    HRESULT HrProcessSingleQueueItem();

    //Handles callback for dropped data
    void HandleDroppedItem(PQDATA pqdItem);

    VOID    IncrementPendingCount(LONG lCount=1)
    {
        if (!lCount)
            return;

        _ASSERT(lCount > 0); //should call decrement
        InterlockedExchangeAdd((PLONG) &m_cItemsPending, lCount);

        // Update threads needed
        UpdateThreadsNeeded();
    };

    VOID    DecrementPendingCount(LONG lCount=-1)
    {
        if (!lCount)
            return;
        _ASSERT(lCount < 0); //should call increment instead
        InterlockedExchangeAdd((PLONG) &m_cItemsPending, lCount);

        // Update threads needed
        UpdateThreadsNeeded();
    };

    //Update the local and global threads needed counters
    void UpdateThreadsNeeded();

    //Used to decide if we should add or remove threads from this queue
    BOOL fIsThreadCountAcceptable();
};

//---[ CAsyncRetryQueue ]------------------------------------------------------
//
//
//  Description:
//      Derived class of CAsyncQueue adds an additional queue to gracefully
//      handle retry scenarios.
//
//      Messages are first placed in the normal retry queue,  If they fail,
//      they are placed in a secondary retry queue, which will not be retried
//      until this queue is kicked by an external retry timer.
//  Hungarian:
//      asyncrq, pasyncrq
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
class CAsyncRetryQueue : public CAsyncQueue<PQDATA, TEMPLATE_SIG>
{
  public:
    CAsyncRetryQueue();
    ~CAsyncRetryQueue();

    HRESULT HrDeinitialize(typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueShutdown,
                           CAQSvrInst *paqinst);
    void    StartRetry()
    {
        MergeRetryQueue();
        CAsyncQueue<PQDATA, TEMPLATE_SIG>::StartRetry();
    };
    HRESULT HrQueueRequest(PQDATA pqdata, BOOL fRetry = FALSE); //Queue request for processing
    virtual BOOL       fHandleCompletionFailure(PQDATA pqdata);
    virtual HRESULT HrMapFn(typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn, PVOID pvContext);
    virtual HRESULT HrMapFnBaseQueue(typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn, PVOID pvContext);
    virtual HRESULT HrMapFnRetryQueue(typename CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn, PVOID pvContext);

    DWORD   cGetItemsPendingRetry() {return m_cRetryItems;};

    //
    //  Basic QAPI functionality
    //
    DWORD   cQueueAdminGetNumItems() {return (m_cItemsPending+m_cRetryItems);};
    DWORD   dwQueueAdminLinkGetLinkState();
  protected:
    DWORD               m_dwRetrySignature;
    DWORD               m_cRetryItems;

    CFifoQueue<PQDATA>  m_fqRetryQueue;  //queue for items

    void MergeRetryQueue();
};

//Define typical asyncq type for casting
typedef  CAsyncQueue<CMsgRef *, ASYNC_QUEUE_MSGREF_SIG>  ASYNCQ_TYPE;
typedef  ASYNCQ_TYPE *PASYNCQ_TYPE;


//---[ AsyncQueueAtqCompletion ]-----------------------------------------------
//
//
//  Description:
//      Atq completion routine.  This is slightly tricky since we cannot pass
//      a templated function to the ATQ context.  This is the one place that
//      templating breaks down, and we actually need to list all of the
//      supported PQDATA types.
//  Parameters:
//      pvContext   - ptr fo CAsyncQueue class
//  Returns:
//      -
//  History:
//      7/17/98 - MikeSwa Created
//      3/8/99 - MikeSwa Added ASYNC_QUEUE_WORK_SIG
//      12/11/2000 - MikeSwa Added t-toddc's virtual code 
//
//----------------------------------------------------------------------------
inline VOID AsyncQueueAtqCompletion(PVOID pvContext, DWORD vbBytesWritten,
                             DWORD dwStatus, OVERLAPPED *pOverLapped)
{
    CAsyncQueueBase *pasyncqb = (PASYNCQ_TYPE) pvContext;
    DWORD dwTemplateSig = pasyncqb->m_dwTemplateSignature;
    DWORD dwCurrentQueueState = pasyncqb->dwGetCurrentState();
    
    _ASSERT(ASYNC_QUEUE_SIG == pasyncqb->m_dwSignature);

    //Up total async thread count (only async threads visit this function)
    InterlockedIncrement((PLONG) &(pasyncqb->m_cTotalAsyncCompletionThreads));
    InterlockedDecrement((PLONG) &(pasyncqb->m_cCompletionThreadsRequested));
    InterlockedIncrement((PLONG) &(pasyncqb->m_cCurrentAsyncThreads));

    //
    //  Call completion routing if we are not shutting down
    //
    if (CAsyncQueueBase::ASYNC_QUEUE_STATUS_SHUTDOWN != dwCurrentQueueState)
    {
        pasyncqb->StartThreadCompletionRoutine(FALSE);
    }

    InterlockedDecrement((PLONG) &(pasyncqb->m_cCurrentAsyncThreads));
}

#endif //__ASYNCQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\bitmap.h ===
//-----------------------------------------------------------------------------
//
//
//    File: bitmap.h
//
//    Description: Contains bitmap manipulation utilities
//
//    Author: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __bitmap_h__
#define __bitmap_h__

#include "cmt.h"

//---[ CMsgBitMap ]------------------------------------------------------------
//
//
//    Hungarian: mbmap, pmbmap
//
//    Provides a wrapper around the bitmaps used to indicate per recipient responsibility
//    and statistics.
//
//    Number of recipients is not stored with bitmaps, since there will be many bitmaps
//    per message. This can reduce memory usage nearly by half (in the case of < 32 recips).
//-----------------------------------------------------------------------------

class CMsgBitMap
{
private:
    DWORD        m_rgdwBitMap[1]; //if there are MORE than 32 recipients

    //private helper functions
    DWORD dwIndexToBitMap(DWORD dwIndex);

    static inline DWORD cGetNumDWORDS(DWORD cBits)
        {return((cBits + 31)/32);};

public:
    //overide new operator to allow for variable sized bitmaps
    void * operator new(size_t stIgnored, unsigned int cBits);
    void operator delete(void *pMem, size_t cBits) {::delete pMem;};


    CMsgBitMap(DWORD cBits);  //only zeros memory... can be done externally when there
                              //is a large array of bitmaps.

    //return the actual size of the bitmap with a given # of recips
    static inline size_t size(DWORD cBits)
        {return (cGetNumDWORDS(cBits)*sizeof(DWORD));};

    //Simple logic checking for bitmaps
    BOOL    FAllClear(IN DWORD cBits);
    BOOL    FAllSet(IN DWORD cBits);

    //Test against a single other bit
    BOOL    FTest(IN DWORD cBits, IN CMsgBitMap *pmbmap);

    //Interlocked Test and set functionality
    BOOL    FTestAndSet(IN DWORD cBits, IN CMsgBitMap *pmbmap);

    //Set/Clear the bit corresponding to a given index on the bitmap
    HRESULT HrMarkBits(IN DWORD cBits,
                    IN DWORD cIndexes,  //# of indexes in array
                    IN DWORD *rgiBits,  //array of indexes to mark
                    IN BOOL  fSet);    //TRUE => set to 1, 0 otherwise

    //Generate a list of indexes represented by the bitmap
    HRESULT HrGetIndexes(IN  DWORD   cBits,
                         OUT DWORD  *pcIndexes,     //# of indexes returned
                         OUT DWORD **prgdwIndexes); //array of indexes


    //Set self to logical OR of group
    HRESULT HrGroupOr(IN DWORD cBits,
                      IN DWORD cBitMaps,     //# of bitmaps passed in
                      IN CMsgBitMap **rgpBitMaps); //array of bitmap ptrs

    //If the description of the following is not immediately clear, I have
    //included a truth table with the implementation

    //Filter self against other bitmap-only keep bits set if NOT set in other
    HRESULT HrFilter(IN DWORD cBits,
                     IN CMsgBitMap *pmbmap); //bitmap to filter against

    //Filters and sets filtered bits to 1 in other bitmap
    HRESULT HrFilterSet(IN DWORD cBits,
                        IN CMsgBitMap *pmbmap); //bitmap to filter and set

    //Sets bits that are 1 in self to 0 in other.  Checks to make sure that
    //self is a subset of setbits to other
    HRESULT HrFilterUnset(IN DWORD cBits,
                        IN CMsgBitMap *pmbmap); //bitmap to unset

};


#endif //__bitmap_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\dcontext.h ===
//-----------------------------------------------------------------------------
//
//
//	File: dcontext.h
//
//	Description: Defines stucture referenced by delilvery context HANDLE
//		(as returned by HrGetNextMessage).  This should only be used inside
//		the CMT.
//
//	Author: mikeswa
//
//	Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _DCONTEXT_H_
#define _DCONTEXT_H_

#include "bitmap.h"
#include "aqueue.h"

class CMsgRef;
class CDestMsgRetryQueue;

#define DELIVERY_CONTEXT_SIG    'txtC'
#define DELIVERY_CONTEXT_FREE   'txt!'

//---[ CDeliveryContext ]------------------------------------------------------
//
//
//  Description: 
//      Context that is used to Ack message after local/remote delivery.  The
//      memory for this class is either allocated with the connection object
//      or on the stack for local delivery.
//  Hungarian: 
//
//  
//-----------------------------------------------------------------------------
class CDeliveryContext
{
public:
    CDeliveryContext();
    CDeliveryContext(CMsgRef *pmsgref, CMsgBitMap *pmbmap, DWORD cRecips, 
            DWORD *rgdwRecips, DWORD dwStartDomain, CDestMsgRetryQueue *pdmrq); 
    ~CDeliveryContext();
    
    HRESULT HrAckMessage(IN MessageAck *pMsgAck);
    
    void Init(CMsgRef *pmsgref, CMsgBitMap *pmbmap, DWORD cRecips, 
            DWORD *rgdwRecips, DWORD dwStartDomain, CDestMsgRetryQueue *pdmrq);
    void Recycle();
    BOOL FVerifyHandle(IMailMsgProperties *pIMailMsgPropeties);

    CDestMsgRetryQueue *pdmrqGetDMRQ() {return m_pdmrq;};
private:
    friend class CMsgRef;
    DWORD       m_dwSignature;
    CMsgRef     *m_pmsgref;  //MsgRef for this context
    CMsgBitMap  *m_pmbmap;   //Bitmap of domains that delivery was attempted for
    DWORD        m_cRecips;  //Number of recips to deliver to
    DWORD       *m_rgdwRecips; //Array of recip indexes
    DWORD        m_dwStartDomain; //First domain delivered to

    //Retry interface for this delivey attempt
    CDestMsgRetryQueue *m_pdmrq; 
};

#endif //_DCONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\destmsgq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: destmsgq.cpp
//
//  Description: Implementation of the CDestMsgQueue class
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "aqprecmp.h"
#include "fifoqimp.h"
#include "qwiklist.h"
#include "aqutil.h"

//---[ DEST_QUEUE_CONTEXT ]----------------------------------------------------
//
//
//  Description:
//      Context used for DSN generation.  This is created by
//      GenerateDSNsIfNecessary() and passed to the DMQ iterator function
//      HrWalkDMQForDSN().
//  Hungarian:
//      dqcontext, pdqcontext
//
//-----------------------------------------------------------------------------
class DEST_QUEUE_CONTEXT
{
  private:
    friend HRESULT CDestMsgQueue::HrWalkDMQForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext,
                           OUT BOOL *pfContinue, OUT BOOL *pfDelete);
    CDestMsgQueue   *m_pdmq;
    CQuickList      *m_pql;
    HRESULT         m_hrConnectionStatus;
    DWORD           m_cMsgsSeenThisQueue;
    DWORD           m_cDSNsGeneratedThisQueue;
    DWORD           m_dwTickCountStart;
    BOOL              m_bRetryQueue;


  public:
    //Contructor.... initializes and updates DWORD context
    DEST_QUEUE_CONTEXT(IN OUT DWORD *pdwContext, IN CDestMsgQueue *pdmq,
                        IN CQuickList *pql, IN HRESULT hr)
    {
        _ASSERT(pdwContext);
        m_pdmq = pdmq;
        m_pql = pql;
        m_hrConnectionStatus = hr;
        m_cMsgsSeenThisQueue = 0;
        m_cDSNsGeneratedThisQueue = 0;
        m_bRetryQueue = FALSE;


        //Initialize/Update context if it has not been initialized
        if (!*pdwContext)
            *pdwContext = GetTickCount();

        m_dwTickCountStart = *pdwContext;
    }

    ~DEST_QUEUE_CONTEXT()
    {
        TraceFunctEnterEx((LPARAM) this, "DEST_QUEUE_CONTEXT::~DEST_QUEUE_CONTEXT");
        DWORD       dwTickDiff = GetTickCount() - m_dwTickCountStart;
        DebugTrace((LPARAM) this,
            "DSN summary: %d milliseconds - %d msgs - %d DSNs",
            dwTickDiff, m_cMsgsSeenThisQueue, m_cDSNsGeneratedThisQueue);

        _ASSERT(m_cMsgsSeenThisQueue >= m_cDSNsGeneratedThisQueue);
        TraceFunctLeave();
    }

    void SetRetry(BOOL bRetry)
    {
        m_bRetryQueue = bRetry;
    }
    BOOL    fPastTimeLimit()
    {
        DWORD   dwTickCountDiff = GetTickCount() - m_dwTickCountStart;
        if (dwTickCountDiff >= g_cMaxSecondsPerDSNsGenerationPass*1000)
            return TRUE;
        else
            return FALSE;
    }
};

//---[ CDestMsgRetryQueue::CDestMsgRetryQueue ]--------------------------------
//
//
//  Description:
//      Constructor for CDestMsgRetryQueue.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/25/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDestMsgRetryQueue::CDestMsgRetryQueue()
{
    m_dwSignature = DESTMSGRETRYQ_SIG;
    m_cRetryReferenceCount = 0;
    m_pdmq = NULL;
}

//---[ CDestMsgRetryQueue::HrRetryMsg ]----------------------------------------
//
//
//  Description:
//      Puts a message into the retry queue
//  Parameters:
//      pmsgref     Message to put into retry queue
//  Returns:
//      S_OK on success
//      E_INVALIDARG if no refcount (asserts in DBG)
//  History:
//      10/25/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgRetryQueue::HrRetryMsg(IN CMsgRef *pmsgref)
{
    _ASSERT(m_pdmq);
    _ASSERT(m_cRetryReferenceCount);
    _ASSERT(DESTMSGRETRYQ_SIG == m_dwSignature);

    if (!m_pdmq || !m_cRetryReferenceCount)
    {
        return E_INVALIDARG;
    }

    m_pdmq->AssertSignature();
    return (m_pdmq->HrRetryMsg(pmsgref));
}

//---[ CDestMsgQueueHrWalkDMQForDSN ]------------------------------------------
//
//
//  Description:
//      Example default function to use with HrMapFn... will always return TRUE
//      to continue and delete the current queued data
//  Parameters:
//      IN  CMsgRef pmsgref,  //ptr to data on queue
//      IN  PVOID pvContext   //list of queues to prepare for DSN
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      S_OK
//  History:
//      7/13/98 - MikeSwa Created
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrWalkDMQForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext,
                           OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "CDestMsgQueue::HrWalkDMQForDSN");
    Assert(pfContinue);
    Assert(pfDelete);
    HRESULT hr = S_OK;
    HRESULT hrReason = S_OK;
    DWORD   dwDSNFlags = 0;
    DWORD   dwMsgRefDSNOptions = CMsgRef::MSGREF_DSN_SEND_DELAY |
                                 CMsgRef::MSGREF_DSN_HAS_ROUTING_LOCK;
    DEST_QUEUE_CONTEXT *pdqcontext = (DEST_QUEUE_CONTEXT *) pvContext;
    CLinkMsgQueue *plmq = NULL;
    CQuickList quicklist;
    CQuickList *pql;
    DWORD dwIndex;

    _ASSERT(pdqcontext->m_pdmq);
    _ASSERT(pdqcontext->m_pql);

    *pfContinue = TRUE;
    *pfDelete = FALSE;

    //See if we got the shutdown hint... if so bail
    if (pdqcontext->m_pdmq->m_paqinst->fShutdownSignaled())
    {
        *pfContinue = FALSE;
        goto Exit;
    }

    //Check and make sure that a routing change is not pending
    if (!pdqcontext->m_pdmq->m_paqinst ||
        !pdqcontext->m_pdmq->m_paqinst->fTryRoutingShareLock())
    {
        *pfContinue = FALSE;
        goto Exit;
    }
    pdqcontext->m_pdmq->m_paqinst->RoutingShareUnlock();

    //Check and see if we have hit our limit.  We force ourselves
    //to generate at least one DSN, so we make some forward progress
    //each pass.
    if (pdqcontext->m_cDSNsGeneratedThisQueue && pdqcontext->fPastTimeLimit())
    {
        *pfContinue = FALSE;
        hr = HRESULT_FROM_WIN32(E_PENDING);
        goto Exit;
    }

    //Avoid holding the lock while making external calls other than AddRef etc
    pdqcontext->m_pdmq->m_slPrivateData.ShareLock();
    plmq = pdqcontext->m_pdmq->m_plmq;
    if (plmq)
        plmq->AddRef();
    pdqcontext->m_pdmq->m_slPrivateData.ShareUnlock();

    //$$REVIEW: Holding the lock for such a short time is something of a moot
    //point here, since a Sharelock is held at the link level to assure that
    //the qwiklist passed in as part of our context does not change

    if (plmq)
    {
        //We should not send delay DSNs to TURN/ETRN domains
        if (plmq->dwGetLinkState() & LINK_STATE_PRIV_CONFIG_TURN_ETRN)
            dwMsgRefDSNOptions &= ~CMsgRef::MSGREF_DSN_SEND_DELAY;
        plmq->Release();
    }

    if(pdqcontext->m_pdmq->m_hrRoutingDiag != S_OK)
    {
        //
        //  This message is being NDR'ed because routing had a problem with
        //  it. Pass in the HRESULT from routing so that we can use it during
        //  DSN generation. Pass in a quicklist with only the CDestMsgQueue
        //  on which the routing error occured.
        //
        hrReason = pdqcontext->m_pdmq->m_hrRoutingDiag;
        DebugTrace((LPARAM)pmsgref, "Generating DSN due to routing, hr - %08x", hrReason);

        hr = quicklist.HrAppendItem(pdqcontext->m_pdmq, &dwIndex);
        if(FAILED(hr))
        {
            ErrorTrace((LPARAM)pmsgref, "Unable to generate DSN for msg");
            goto Exit;
        }
        pql = &quicklist;
    }
    else
    {
        hrReason = pdqcontext->m_hrConnectionStatus;
        pql = pdqcontext->m_pql;
    }

    if (pdqcontext->m_pdmq->m_dwFlags & DMQ_CHECK_FOR_STALE_MSGS)
    {
        DebugTrace((LPARAM) pmsgref, "Enabling checking for stale messages");
        dwMsgRefDSNOptions |= CMsgRef::MSGREF_DSN_CHECK_IF_STALE;
    }

    hr = pmsgref->HrSendDelayOrNDR(dwMsgRefDSNOptions, pql, hrReason, &dwDSNFlags);

    if (FAILED(hr))
        goto Exit;

    //NOTE: Although it would be tempting to return *pfContinue as FALSE if
    //MSGREF_HAS_NOT_EXPIRED was set, it would be wrong since queues may be
    //out of order on startup... and some sink may modify the expiration time
    //(for example... routing may want to expire low-priority messages earlier).

    //We need to remove this message from the queue
    if ((CMsgRef::MSGREF_DSN_SENT_NDR | CMsgRef::MSGREF_HANDLED) & dwDSNFlags)
    {
        *pfDelete = TRUE;
        if (pdqcontext->m_bRetryQueue)
            pdqcontext->m_pdmq->UpdateRetryStats(FALSE);
        else
            pdqcontext->m_pdmq->UpdateMsgStats(pmsgref, FALSE);
    }

    //Update counts in context
    pdqcontext->m_cMsgsSeenThisQueue++;

    if ((CMsgRef::MSGREF_DSN_SENT_NDR | CMsgRef::MSGREF_DSN_SENT_DELAY) & dwDSNFlags)
    {
        pdqcontext->m_cDSNsGeneratedThisQueue++;
    }

  Exit:
    if (AQUEUE_E_SHUTDOWN == hr)
    {
        *pfContinue = FALSE;
        hr = S_OK;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::HrWalkQueueForShutdown ]--------------------------------
//
//
//  Description:
//      Static function to walk a queue containing msgrefs at shutdown and
//      clear out all of the IMailMsgs
//  Parameters:
//      IN  CMsgRef pmsgref,  ptr to data on queue
//      IN  PVOID pvContext   Pointer to CDestMsgQueue we are walking for
//                            shutdown.
//      OUT BOOL *pfContinue, TRUE if we should continue
//      OUT BOOL *pfDelete);  TRUE if item should be deleted
//  Returns:
//      S_OK - *always*
//  History:
//      11/18/98 - MikeSwa Created
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrWalkQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "HrWalkMsgRefQueueForShutdown");
    Assert(pfContinue);
    Assert(pfDelete);
    CDestMsgQueue *pdmq = (CDestMsgQueue *) pvContext;
    _ASSERT(pmsgref);
    _ASSERT(pdmq);

    _ASSERT(DESTMSGQ_SIG == pdmq->m_dwSignature);

    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    if (pdmq->m_paqinst)
        pdmq->m_paqinst->ServerStopHintFunction();

    //Update stats
    pdmq->UpdateMsgStats(pmsgref, FALSE);

    pmsgref->AddRef();
    pdmq->m_paqinst->HrQueueWorkItem(pmsgref, fMsgRefShutdownCompletion);

    TraceFunctLeave();
    return S_OK;
}

//---[ CDestMsgQueue::HrWalkRetryQueueForShutdown ]--------------------------------
//
//
//  Description:
//      Static function to walk a retry queue containing msgrefs at shutdown and
//      clear out all of the IMailMsgs
//  Parameters:
//      IN  CMsgRef pmsgref,  ptr to data on queue
//      IN  PVOID pvContext   Pointer to CDestMsgQueue we are walking for
//                            shutdown.
//      OUT BOOL *pfContinue, TRUE if we should continue
//      OUT BOOL *pfDelete);  TRUE if item should be deleted
//  Returns:
//      S_OK - *always*
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrWalkRetryQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "HrWalkMsgRefQueueForShutdown");
    Assert(pfContinue);
    Assert(pfDelete);
    CDestMsgQueue *pdmq = (CDestMsgQueue *) pvContext;
    _ASSERT(pmsgref);
    _ASSERT(pdmq);

    _ASSERT(DESTMSGQ_SIG == pdmq->m_dwSignature);

    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    if (pdmq->m_paqinst)
        pdmq->m_paqinst->ServerStopHintFunction();

    //Update retry stats
    pdmq->UpdateRetryStats(FALSE);

    pmsgref->AddRef();
    pdmq->m_paqinst->HrQueueWorkItem(pmsgref, fMsgRefShutdownCompletion);

    TraceFunctLeave();
    return S_OK;
}

//---[ CDestMsgQueue::CDestMsgQueue() ]----------------------------------------
//
//
//  Description:
//      Class constructor
//  Parameters:
//      IN  paqinst             AQ virtual server object
//      IN  paqmtMessageType    Message type for this queue
//      IN  pIMessageRouter     IMessageRouter interface for this queue
//  Returns:
//      -
//-----------------------------------------------------------------------------
CDestMsgQueue::CDestMsgQueue(CAQSvrInst *paqinst,
                             CAQMessageType *paqmtMessageType,
                             IMessageRouter *pIMessageRouter)
                    : m_aqmt(paqmtMessageType)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::CDestMsgQueue");
    _ASSERT(paqinst);
    _ASSERT(pIMessageRouter);

    m_dwSignature        = DESTMSGQ_SIG;
    m_dwFlags            = DMQ_EMPTY;
    m_pIMessageRouter    = pIMessageRouter;
    m_plmq               = NULL;
    m_paqinst            = paqinst;
    m_cMessageTypeRefs   = 0;
    m_pvLinkContext      = NULL;
    m_cCurrentThreadsEnqueuing = 0;
    m_hrRoutingDiag      = S_OK;

    m_pIMessageRouter->AddRef();
    m_paqinst->AddRef();

    m_paqinst->IncDestQueueCount();

    m_liDomainEntryDMQs.Flink = NULL;
    m_liDomainEntryDMQs.Blink = NULL;

    m_liEmptyDMQs.Flink = NULL;
    m_liEmptyDMQs.Blink = NULL;
    m_cRemovedFromEmptyList = 0;

    ZeroMemory(m_rgpfqQueues, NUM_PRIORITIES*sizeof(CFifoQueue<CMsgRef *> **));
    ZeroMemory(&m_ftOldest, sizeof (FILETIME));

    m_dmrq.m_pdmq = this;
    TraceFunctLeave();
}

//---[ CDestMsgQueue::~CDestMsgQueue() ]---------------------------------------
//
//
//  Description:
//      Default destructor
//  Parameters:
//      -
//  Returns:
//      -
//-----------------------------------------------------------------------------
CDestMsgQueue::~CDestMsgQueue()
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::~CDestMsgQueue");

    for (int i = 0; i < NUM_PRIORITIES; i++)
    {
        if (NULL != m_rgpfqQueues[i])
            delete m_rgpfqQueues[i];
    }

    //Make sure we clean up the link even if HrDeinitialize wasn't called
    if (m_plmq)
    {
        m_plmq->HrDeinitialize();
        m_plmq->Release();
        m_plmq = NULL;
    }

    if (m_pIMessageRouter)
    {
        _ASSERT((!m_cMessageTypeRefs) && "Message Type references in destructor");
        m_pIMessageRouter->Release();
        m_pIMessageRouter = NULL;
    }

    if (m_paqinst)
    {
        m_paqinst->DecDestQueueCount();
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    _ASSERT(NULL == m_liDomainEntryDMQs.Flink);
    _ASSERT(NULL == m_liDomainEntryDMQs.Blink);
    _ASSERT(!m_cCurrentThreadsEnqueuing);

    MARK_SIG_AS_DELETED(m_dwSignature);
    TraceFunctLeave();
}

//---[ CDestMsgQueue::HrInitialize() ]-----------------------------------------
//
//
//  Description:
//      Performs initialization that may require allocation
//  Parameters:
//      IN CDomainMapping *pdmap //array of domain mappings to use
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if allocations fail
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrInitialize(IN CDomainMapping *pdmap)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrInitialize");
    HRESULT hr  = S_OK;
    DWORD   i   = 0; //loop counter

    _ASSERT(pdmap);

    if (!pdmap)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //If the queues are compressed (more than one domain name per destination),
    //then each queue will contain multiple domain mappings (1 for each domain)
    m_dmap.Clone(pdmap);

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::HrDeinitialize ]-----------------------------------------
//
//
//  Description:
//      Deinitialize object
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrDeinitialize");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    DWORD   cMsgsRemoved =0;

    dwInterlockedSetBits(&m_dwFlags, DMQ_SHUTDOWN_SIGNALED);
    for (int i = 0; i < NUM_PRIORITIES; i++)
    {
        if (NULL != m_rgpfqQueues[i])
        {
            hrTmp = m_rgpfqQueues[i]->HrMapFn(CDestMsgQueue::HrWalkQueueForShutdown,
                                               this, &cMsgsRemoved);

            //This should really never fail, since HrMapFn will only return errors from
            //the function walking the queues (which in this case never fails)
            _ASSERT(SUCCEEDED(hrTmp));

            //This *should* have removed all msgs
            _ASSERT(!m_aqstats.m_cMsgs && "Still msgs in queue after Deinit");
        }
    }

    m_fqRetryQueue.HrMapFn(CDestMsgQueue::HrWalkRetryQueueForShutdown, this, NULL);

    if (m_pIMessageRouter)
    {
        if (m_cMessageTypeRefs)
        {
            hr = m_pIMessageRouter->ReleaseMessageType(m_aqmt.dwGetMessageType(),
                                        m_cMessageTypeRefs);
            _ASSERT(SUCCEEDED(hr) && "Release Message Type Failed");
            m_cMessageTypeRefs = 0;
        }
        m_pIMessageRouter->Release();
        m_pIMessageRouter = NULL;
    }
    else
    {
        _ASSERT((!m_cMessageTypeRefs) && "We're leaking message type references");
    }


    if (m_paqinst)
    {
        m_paqinst->DecDestQueueCount();
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    if (m_plmq)
    {
        m_plmq->Release();
        m_plmq = NULL;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::HrAddMsg ]----------------------------------------------
//
//
//  Description:
//      Enqueues or Requeues a message to the appropriate priority queue,
//      allocating queue if not present.
//
//      A notification will be sent if needed (& requested) to the associated
//      link object.  The fNotify argument was originally included to prevent
//      messages from the retry queue causing notifications.
//  Parameters:
//      IN CMsgRef *pmsgref - the message ref to enqueue
//      IN BOOL fEnqueue    - TRUE => enqueue and FALSE => requeue
//      IN BOOL fNotify     - TRUE => send notification if necessary.
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrAddMsg(IN CMsgRef *pmsgref, IN BOOL fEnqueue,
                                IN BOOL fNotify)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrAddMsg");
    HRESULT                hr         = S_OK;
    DWORD                  dwFlags    = 0;
    DWORD                  iQueueIndex   = (DWORD) eEffPriNormal;
    CFifoQueue<CMsgRef *> *pfqQueue   = NULL;
    CFifoQueue<CMsgRef *> *pfqQueueNew= NULL;

    _ASSERT(pmsgref);
    _ASSERT(m_aqmt.fIsEqual(pmsgref->paqmtGetMessageType()));
    _ASSERT(!(m_dwFlags & (DMQ_INVALID | DMQ_SHUTDOWN_SIGNALED)));

    //get the priority from the message reference
    iQueueIndex = (DWORD) pmsgref->PriGetPriority();

    //
    //  If the message is marked as problem... treat with lower priority.
    //
    if (iQueueIndex && pmsgref->fIsProblemMsg())
        iQueueIndex--;

    //use priority to get to get ptr to correct queue
    _ASSERT(iQueueIndex < NUM_PRIORITIES);

    pfqQueue = m_rgpfqQueues[iQueueIndex];

    if (NULL == pfqQueue) //we must allocate a queue
    {
        pfqQueueNew = new CFifoQueue<CMsgRef *>();
        if (NULL != pfqQueueNew)
        {
            pfqQueue = (CFifoQueue<CMsgRef *> *) InterlockedCompareExchangePointer(
                                              (VOID **) &(m_rgpfqQueues[iQueueIndex]),
                                              (VOID *) pfqQueueNew,
                                              NULL);
            if (NULL != pfqQueue)
            {
                //someone else updated first
                delete pfqQueueNew;
            }
            else
            {
                //Our updated worked
                pfqQueue = pfqQueueNew;
            }
            pfqQueueNew = NULL;
        }
        else //allocation failed
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    //at this point queue ptr should be good
    _ASSERT(pfqQueue);

    //Assume enqueue will work - optimize to avoid dealing with negative stats

    //Mark queue as non-empty
    dwFlags = dwInterlockedUnsetBits(&m_dwFlags, DMQ_EMPTY);
    if (DMQ_EMPTY & dwFlags)
        UpdateOldest(pmsgref->pftGetAge());

    //
    //  Keep track of how many threads are enqueuing so that we know what
    //  is the most we can expect to be off in our message count.
    //
    InterlockedIncrement((PLONG) &m_cCurrentThreadsEnqueuing);

    //Add the msg to the appropriate queue
    if (fEnqueue)
        hr = pfqQueue->HrEnqueue(pmsgref);
    else
        hr = pfqQueue->HrRequeue(pmsgref);

    //If the enqueue/requeue succeeded, update the stats. DO NOT update the
    //stats before the enqueue/requeue attempt. This will cause the link to
    //wake up and start spinning off connections before the msg is enqueued.
    //See bug 88931
    if (SUCCEEDED(hr))
        UpdateMsgStats(pmsgref, TRUE);

    InterlockedDecrement((PLONG) &m_cCurrentThreadsEnqueuing);

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::HrDequeueMsg ]-------------------------------------------
//
//
//  Description:
//      Finds and dequeues the next message.  All OUT parameters are
//      ref-counted.  The call is responsible for there release
//  Parameters:
//      IN  priLowestPriority - Lowest priority message allowed
//      OUT ppmsgref - MsgRef dequeued
//      OUT ppdmrq   - Ptr to retry interface (can be NULL)
//  Returns:
//      NO_ERROR if successful
//      AQUEUE_E_QUEUE_EMPTY if no messages in queue
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrDequeueMsg(
                                    IN  DWORD priLowestPriority,
                                    OUT CMsgRef **ppmsgref,
                                    OUT CDestMsgRetryQueue **ppdmrq)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrDequeueMsg");
    Assert(ppmsgref);
    HRESULT             hr         = S_OK;
    DWORD               priCurrent = eEffPriHigh; //start at highest priority
    *ppmsgref = NULL;

    Assert(priCurrent < NUM_PRIORITIES);

    hr = AQUEUE_E_QUEUE_EMPTY;

    while (TRUE)
    {

        if (NULL != m_rgpfqQueues[priCurrent])
        {
            hr = m_rgpfqQueues[priCurrent]->HrDequeue(ppmsgref);

            if (SUCCEEDED(hr))
            {
                if ((*ppmsgref)->fIsMsgFrozen())
                {
                    //Msg is frozen, we need to put it in
                    //the retry queue and get the next one

                    //We must call UpdateMsgStats,because
                    //MergeRetryQueue will re-add it.
                    UpdateMsgStats(*ppmsgref, FALSE);
                    hr = HrRetryMsg(*ppmsgref);
                    if (FAILED(hr))
                        goto Exit;
                    (*ppmsgref)->Release();
                    *ppmsgref = NULL;
                    continue;
                }
                else
                {
                    break;
                }
            }
            else if (hr != AQUEUE_E_QUEUE_EMPTY)
            {
                //some unexpected error has occured
                goto Exit;
            }
        }

        //otherwise decrement the priority
        if (priCurrent == eEffPriLow)
            break;

        //
        // If there are no messages at the current lowest priority, 
        // then treat this queue as empty
        //
        if (priCurrent <= priLowestPriority) 
        {
            hr = AQUEUE_E_QUEUE_EMPTY;
            goto Exit;
        }
        
        Assert(eEffPriLow < priCurrent);
        priCurrent--;
    }

    if (FAILED(hr))
        goto Exit;

    Assert(*ppmsgref);

    //Before we update stats.  AddRef the retry interface so there is
    //no timing window where the queue is erroniously marked as empty
    if (ppdmrq)
    {
        *ppdmrq = &m_dmrq;
        m_dmrq.AddRef();
    }

    UpdateMsgStats(*ppmsgref, FALSE);

    //approximate oldest
    UpdateOldest((*ppmsgref)->pftGetAge());


  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::UpdateMsgStats ]---------------------------------------
//
//
//  Description:
//      Updates stats.  A shared lock must be aquired before calling into this.
//  Parameters:
//      IN pmsgref  - message reference added or removed
//      IN fAdd     - TRUE => msgref is being added the queue
//                    FALSE => msgref is being removed from the queue
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::UpdateMsgStats(IN CMsgRef *pmsgref, IN BOOL fAdd)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::UpdateMsgStats");
    Assert(pmsgref);

    CAQStats aqstats;

    if (fAdd)
    {
        m_paqinst->IncQueueMsgInstances();
    }
    else
    {
        m_paqinst->DecQueueMsgInstances();
    }

    aqstats.m_cMsgs = 1;
    aqstats.m_rgcMsgPriorities[pmsgref->PriGetPriority()] = 1;
    aqstats.m_uliVolume.QuadPart = (ULONGLONG) pmsgref->dwGetMsgSize();
    aqstats.m_pdmq = this;
    aqstats.m_dwNotifyType = NotifyTypeDestMsgQueue;
    aqstats.m_dwHighestPri = pmsgref->PriGetPriority();

    //Keep track of the number of *other* domains this is being sent to, so
    //that we can make an accurate guess when to create connections
    aqstats.m_cOtherDomainsMsgSpread = pmsgref->cGetNumDomains()-1;

    //
    //  Make sure that our stats are within reason.  We expect to be negative
    //  for short periods of time, but never more negative than the
    //  number of threads currently enqueueing.
    //
    _ASSERT(m_aqstats.m_cMsgs+m_cCurrentThreadsEnqueuing < 0xFFFFFFF0);

    m_slPrivateData.ShareLock();

    m_aqstats.UpdateStats(&aqstats, fAdd);

    //send notification off to link
    if (m_plmq)
    {
        //Caller does not care about success of notification... only
        //about updating stats
        m_plmq->HrNotify(&aqstats, fAdd);
    }

    m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
}

//---[ CDestMsgQueue::UpdateRetryStats ]---------------------------------------
//
//
//  Description:
//      Updates retry stats.  A shared lock must be aquired before calling into this.
//  Parameters:
//      IN fAdd     - TRUE => msgref is being added the queue
//                    FALSE => msgref is being removed from the queue
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::UpdateRetryStats(IN BOOL fAdd)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::UpdateRetryStats");

    if (fAdd)
    {
        m_paqinst->IncQueueMsgInstances();
    }
    else
    {
        m_paqinst->DecQueueMsgInstances();
    }

    m_slPrivateData.ShareLock();

    m_aqstats.UpdateRetryStats(fAdd);
    if (m_plmq)
    {
        //Caller does not care about success of notification... only
        //about updating stats
        m_plmq->HrNotifyRetryStatChange(fAdd);
    }
    
    m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
}


//---[ CDestMsgQueue::HrRetryMsg ]---------------------------------------------
//
//
//  Description:
//      Add an message to the queue for retry.  This will put a message in
//      a retry queue (that is not usually checked during HrDequeueMessage)
//  Parameters:
//      IN  pmsgref     Message to add to the queue for retry
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrRetryMsg(IN CMsgRef *pmsgref)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrRetryMsg");
    HRESULT hr = S_OK;

    _ASSERT(pmsgref);

    hr = m_fqRetryQueue.HrRequeue(pmsgref);

    //If we couldn't put it in retry queue... retry when all references
    //have been released
    if (FAILED(hr))
        pmsgref->RetryOnDelete();
    else
    	 UpdateRetryStats(true);

    hr = S_OK;

    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::MarkQueueEmptyIfNecessary ]------------------------------
//
//
//  Description:
//      Checks and sees if it is OK to mark the queue as empty.  Will
//      insert it in the empty list if needed.
//      If queue is now empty (and not tagged as empty), then we need to put
//      it in the empty queue list.  If it is already tagged as empty, then
//      it is already in the empty queue list with the appropirate expire time.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/25/1999 - MikeSwa Created (separated from MergeRetryQueue())
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::MarkQueueEmptyIfNecessary()
{

    //A queue cannot be considered empty if any of the following conditions
    //  - There are messages queued up for delivery
    //  - There are messages pending ack (someone has a reference to the
    //     retry interface)
    //  - There are messages pending retry

    // if we can't get the shutdown lock then there is no reason to mark the
    // queue as empty, since it will go away when we shutdown
    if (m_paqinst->fTryShutdownLock()) {
        //To be thread safe we should check in the opposite order that they
        //are set/unset.  On dequeue, we add a ref count, then update stats.  On
        //retry we update the retry stats, and then release.
        //
        if (!m_aqstats.m_cMsgs &&
            !m_dmrq.m_cRetryReferenceCount &&
            !m_fqRetryQueue.cGetCount() &&
            !(m_dwFlags & DMQ_EMPTY))
        {
            m_paqinst->pdmtGetDMT()->AddDMQToEmptyList(this);
        }
        m_paqinst->ShutdownUnlock();
    }

}
//---[ CDestMsgQueue::HrGenerateDSNsIfNecessary ]-----------------------------
//
//
//  Description:
//      Merge Messages from retry queue into main priority queues and
//      generates DSNs if neccessary.
//  Parameters:
//      IN pqlQueues            List of queues to pass to DSN code
//      IN hrConnectionStatus   HRESULT that should be passed to DSN generation
//                              code.
//      IN OUT pdwContext       Context that is used to throttle
//                              DSN generation.  Should be initialzed to
//                              0 on first call.  Actually used to store
//                              the tick count when we started DSN generation
//  Returns:
//      Failures will be handled internally
//      S_OK - success, and all messages processed
//      HRESULT_FROM_WIN32(E_PENDING) - more messages left to processes
//  History:
//      11/10/1999 - MikeSwa Modified to return pending error
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrGenerateDSNsIfNecessary(IN CQuickList *pqlQueues,
                                                 IN HRESULT hrConnectionStatus,
                                                 IN OUT DWORD *pdwContext)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::GenerateDSNsIfNecessary");
    HRESULT hr = S_OK;
    int     i = 0;
    DEST_QUEUE_CONTEXT dqcontext(pdwContext, this, pqlQueues, hrConnectionStatus);

    //Re-merge retry queue
    MergeRetryQueue();

    //Check re-try queue as well since we may have frozen messages that need to
    //be NDR'd or DSN'd
    // this is on a retry queue, HrWalkDMQForDSN should call UpdateMsgStats
    dqcontext.SetRetry(TRUE);
    hr = m_fqRetryQueue.HrMapFn(CDestMsgQueue::HrWalkDMQForDSN, &dqcontext, NULL);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(E_PENDING) == hr)
        {
            DebugTrace((LPARAM) this,
                "Hit DSN generation limit, must continue DSN genration later");
            goto Exit;
        }

        ErrorTrace((LPARAM) this,
            "ERROR: Unable to Check Queues for DSNs - hr 0x%08X", hr);

        hr = S_OK;
    }

    dqcontext.SetRetry(FALSE);
    for (i = 0; i < NUM_PRIORITIES; i++)
    {
        if (NULL != m_rgpfqQueues[i])
        {
            hr = m_rgpfqQueues[i]->HrMapFn(CDestMsgQueue::HrWalkDMQForDSN,
                                            &dqcontext, NULL);
            if (FAILED(hr))
            {
                if (HRESULT_FROM_WIN32(E_PENDING) == hr)
                {
                    DebugTrace((LPARAM) this,
                        "Hit msg limit, must continue DSN genration later");
                    goto Exit;
                }

                ErrorTrace((LPARAM) this,
                    "ERROR: Unable to Check Queues for DSNs - hr 0x%08X", hr);

                hr = S_OK;
            }
        }
    }

    //
    //  If we where checking for stale messages, we should stop until we
    //  hit another stale message on a message ack
    //
    dwInterlockedUnsetBits(&m_dwFlags, DMQ_CHECK_FOR_STALE_MSGS);


  Exit:
    MarkQueueEmptyIfNecessary();
    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::MergeRetryQueue ]------------------------------------------
//
//
//  Description:
//      Merges retry queues with normal queues.  Will keep frozen msgs in
//      retry queue.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/13/98 - MikeSwa split from original MergeRetryQueue
//                    (now called GenerateDSNsIfNecessary)
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::MergeRetryQueue()
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::MergeRetryQueue");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;
    CMsgRef *pmsgrefFirstFrozen = NULL;
    DWORD   cMsgsInRetry = m_fqRetryQueue.cGetCount();
    DWORD   cMsgsProcessed = 0;

    while (SUCCEEDED(hr))
    {
        //While we have a mechanism to loop through the queue only once by
        //checking the pmsgrefFirstFrozen pointer.  It is possible that another
        //thread will remove that from the queue (unfreeze, NDR, etc), so it
        //is important that we have a failsafe mechanism.  Worst case here, is
        //that we will see every message twice, but lets us handle extra
        //messages added to the retry queue.
        if (cMsgsProcessed++ > 2*cMsgsInRetry)
            break;

        hr = m_fqRetryQueue.HrDequeue(&pmsgref);
        if (FAILED(hr))
            break;
        UpdateRetryStats(false);

        //Handle frozen messages sitting in the retry queue
        if (pmsgref->fIsMsgFrozen())
        {
            //Message is frozen, we are keeping it in the retry queue

            hr = m_fqRetryQueue.HrEnqueue(pmsgref);
            if (FAILED(hr))
            {
                //Mark Msgref as retry
                pmsgref->RetryOnDelete();
                ErrorTrace((LPARAM) this,
                    "ERROR: Unable to add frozen msg to retry queue - msg 0x%X", pmsgref);
            }
            else 
            {
                UpdateRetryStats(true);
            }

            pmsgref->Release();

            //See if we've made it all the way through the retry queue
            if (!pmsgrefFirstFrozen)
                pmsgrefFirstFrozen = pmsgref;
            else if (pmsgref == pmsgrefFirstFrozen)
                break;
        }
        else
        {
            //Re-queue non-frozen message for delivery
            hr = HrAddMsg(pmsgref, FALSE, FALSE);

            if (FAILED(hr))
            {
                pmsgref->RetryOnDelete();
                ErrorTrace((LPARAM) this, "ERROR: Unable to merge retry queue - msg 0x%X", pmsgref);
            }

            pmsgref->Release();
        }
    }

    MarkQueueEmptyIfNecessary();
    TraceFunctLeave();
}

//---[ CDestMsgQueue::RemoveDMQFromLink ]--------------------------------------
//
//
//  Description:
//      Removes this DMQ from its associated link
//  Parameters:
//      fNotifyLink     TRUE if not being called by owning link, and link needs
//                      to be notified
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Created
//      11/6/98 - MikeSwa Modified to allow changes to routing info
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::RemoveDMQFromLink(BOOL fNotifyLink)
{
    _ASSERT(DESTMSGQ_SIG == m_dwSignature);
    CLinkMsgQueue *plmq = NULL;
    CAQStats    aqstats;

    m_slPrivateData.ExclusiveLock();
    plmq = m_plmq;
    m_plmq = NULL;
    if (plmq && fNotifyLink)
        memcpy(&aqstats, &m_aqstats, sizeof(CAQStats));
    m_slPrivateData.ExclusiveUnlock();

    if (plmq)
    {
        if (fNotifyLink)
            plmq->RemoveQueue(this, &aqstats);
        plmq->Release();
    }
}

//---[ CDestMsgQueue::SetRouteInfo ]-------------------------------------------
//
//
//  Description:
//      Sets the routing information for this domain.  Will blow away any
//      previous routing info.
//  Parameters:
//      IN  plmq        Link to associate with this domain.
//  Returns:
//      -
//  History:
//      11/6/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::SetRouteInfo(CLinkMsgQueue *plmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::SetRouteInfo");
    HRESULT hr = S_OK;
    CAQStats aqstats;
    //First blow-away old routing info
    RemoveDMQFromLink(TRUE);

    //Grab lock and update routing info
    m_slPrivateData.ExclusiveLock();
    m_plmq = plmq;
    if (plmq)
    {
        plmq->AddRef();
        memcpy(&aqstats, &m_aqstats, sizeof(CAQStats));
        aqstats.m_dwNotifyType |= NotifyTypeDestMsgQueue;
        hr = plmq->HrNotify(&aqstats, TRUE);
        if (FAILED(hr))
        {
            //nothing really we can do
            ErrorTrace((LPARAM) this,
                "ERROR: Unable to update link stats - hr 0x%08X", hr);
        }
    }
    m_slPrivateData.ExclusiveUnlock();
    TraceFunctLeave();
}

//---[ CDestMsgQueue::plmqGetLink ]--------------------------------------------
//
//
//  Description:
//      Returns the Addref'd Link for the Queue.
//  Parameters:
//      -
//  Returns:
//      Ptr to CLinkMsgQueue
//  History:
//      5/14/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CDestMsgQueue::plmqGetLink()
{
    CLinkMsgQueue *plmq = NULL;
    m_slPrivateData.ShareLock();
    plmq = m_plmq;
    if (plmq)
        plmq->AddRef();
    m_slPrivateData.ShareUnlock();

    return plmq;
}


//---[ CDestMsgQueue::HrGetQueueID ]--------------------------------------------
//
//
//  Description:
//      Gets the QueueID for this DMQ.  Used by Queue Admin
//  Parameters:
//      IN OUT pQueueID     QUEUELINK_ID struct to fill in
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate memory for queue name.
//  History:
//      12/3/98 - MikeSwa Created
//      2/23/99 - MikeSwa Modified to be part of IQueueAdminQueue interface
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::HrGetQueueID(QUEUELINK_ID *pQueueID)
{
    DWORD   cbDomainName = m_dmap.pdentryGetQueueEntry()->cbGetDomainNameLength();
    LPSTR   szDomainName = m_dmap.pdentryGetQueueEntry()->szGetDomainName();
    pQueueID->qltType = QLT_QUEUE;
    pQueueID->dwId = m_aqmt.dwGetMessageType();
    m_aqmt.GetGUID(&pQueueID->uuid);

    pQueueID->szName = wszQueueAdminConvertToUnicode(szDomainName,
                                                             cbDomainName);
    if (!pQueueID->szName)
        return E_OUTOFMEMORY;

    return S_OK;
}


//---[ CDestMsgQueue::HrGetQueueInfo ]------------------------------------------
//
//
//  Description:
//      Gets the Queue Admin infor for this Queue
//  Parameters:
//      IN OUT pqiQueueInfo     Ptr to Queue Info Stucture to fill
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate memory for queue name.
//  History:
//      12/5/98 - MikeSwa Created
//      2/22/99 - MikeSwa changed to COM function
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::HrGetQueueInfo(QUEUE_INFO *pqiQueueInfo)
{
    DWORD   cbDomainName = m_dmap.pdentryGetQueueEntry()->cbGetDomainNameLength();
    LPSTR   szDomainName = m_dmap.pdentryGetQueueEntry()->szGetDomainName();
    HRESULT hr = S_OK;

    //Get # of messages = # in queue + failed msgs
    pqiQueueInfo->cMessages = m_aqstats.m_cMsgs + cGetFailedMsgs();

    //Get DMQ name
    pqiQueueInfo->szQueueName = wszQueueAdminConvertToUnicode(szDomainName,
                                                              cbDomainName);
    if (!pqiQueueInfo->szQueueName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pqiQueueInfo->cbQueueVolume.QuadPart = m_aqstats.m_uliVolume.QuadPart;

    pqiQueueInfo->dwMsgEnumFlagsSupported = AQUEUE_DEFAULT_SUPPORTED_ENUM_FILTERS;

    //Get Link name
    m_slPrivateData.ShareLock();

    if (m_plmq && !m_plmq->fRPCCopyName(&pqiQueueInfo->szLinkName))
        hr = E_OUTOFMEMORY;

    m_slPrivateData.ShareUnlock();

  Exit:
    return hr;
}

//---[ CDestMsgQueue::UpdateOldest ]-------------------------------------------
//
//
//  Description:
//      Updates the age of the "oldest" message in the queue
//  Parameters:
//      pft     Ptr to filetime of oldest nessage
//  Returns:
//      -
//  History:
//      12/13/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::UpdateOldest(FILETIME *pft)
{
    DWORD dwFlags = dwInterlockedSetBits(&m_dwFlags, DMQ_UPDATING_OLDEST_TIME);

    if (!(DMQ_UPDATING_OLDEST_TIME & dwFlags))
    {
        //we got the spin lock
        memcpy(&m_ftOldest, pft, sizeof(FILETIME));
        dwInterlockedUnsetBits(&m_dwFlags, DMQ_UPDATING_OLDEST_TIME);
    }
}

//---[ CDestMsgQueue::QueryInterface ]-----------------------------------------
//
//
//  Description:
//      QueryInterface for CDestMsgQueue that supports:
//          - IQueueAdminAction
//          - IUnknown
//          - IQueueAdminQueue
//  Parameters:
//
//  Returns:
//
//  History:
//      2/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminAction == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminQueue == riid)
    {
        *ppvObj = static_cast<IQueueAdminQueue *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CDestMsgQueue::HrApplyQueueAdminFunction ]------------------------------
//
//
//  Description:
//      Will call the IQueueAdminMessageFilter::Process message for every
//      message in this queue.  If the message passes the filter, then
//      HrApplyActionToMessage on this object will be called.
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created
//      4/1/99 - MikeSwa Merged implementations of ApplyQueueAdminFunction
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::HrApplyQueueAdminFunction(
                     IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    HRESULT hr = S_OK;
    DWORD   i = 0;
    DWORD   dwFlags = 0;
    PVOID   pvOldContext = NULL;
    CQueueAdminContext qapictx(NULL, m_paqinst);

    _ASSERT(pIQueueAdminMessageFilter);
    hr = pIQueueAdminMessageFilter->HrSetQueueAdminAction(
                                    (IQueueAdminAction *) this);

    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetQueueAdminAction");

    if (FAILED(hr))
        goto Exit;

    pIQueueAdminMessageFilter->HrGetCurrentUserContext(&pvOldContext);
    pIQueueAdminMessageFilter->HrSetCurrentUserContext(&qapictx);

    //Apply action to every queue in DMQ

    dwInterlockedSetBits(&m_dwFlags, DMQ_QUEUE_ADMIN_OP_PENDING);

    //Map function on retry queue first, because that will make display
    //order more consistant, since messages that where at the front of
    //the queue, will be in the retry queue for retry errors.
    qapictx.SetQueueState(LI_RETRY);
    hr = m_fqRetryQueue.HrMapFn(QueueAdminApplyActionToMessages,
                                pIQueueAdminMessageFilter, NULL);
    qapictx.SetQueueState(LI_READY);
    if (FAILED(hr))
        goto Exit;


    for (i = 0; i < NUM_PRIORITIES; i++)
    {
        if (NULL != m_rgpfqQueues[i])
        {
            hr = m_rgpfqQueues[i]->HrMapFn(QueueAdminApplyActionToMessages,
                                           pIQueueAdminMessageFilter, NULL);
            if (FAILED(hr))
            {
                goto Exit;
            }
        }
    }


  Exit:
    dwFlags = dwInterlockedUnsetBits(&m_dwFlags, DMQ_QUEUE_ADMIN_OP_PENDING);

    //
    //  NOTE - By doing this here, we will only check DMQ's for which
    //  explicit queue admin actions have happened.  Other DMQ's will wait
    //  for retry or another QAPI action.
    //
    if (qapictx.cGetNumThawedMsgs())
    {
        //We need to walk the retry queue for thawed msgs.  We have to do
        //it here, because otherwise we might deadlock if this thread called
        //MergeRetryQueue() from within the HrMapFn
        MergeRetryQueue();
    }

    //Restore inital context
    pIQueueAdminMessageFilter->HrSetCurrentUserContext(pvOldContext);
    return hr;
}

//---[ CDestMsgQueue::HrApplyActionToMessage ]---------------------------------
//
//
//  Description:
//      Applies an action to this message for this queue.  This will be called
//      by the IQueueAdminMessageFilter during a queue enumeration function.
//  Parameters:
//      IN  *pIUnknownMsg       ptr to message abstraction
//      IN  ma                  Message action to perform
//      IN  pvContext           Context set on IQueueAdminFilter
//      OUT pfShouldDelete      TRUE if the message should be deleted
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created
//      4/2/99 - MikeSwa Added context
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::HrApplyActionToMessage(
                     IUnknown *pIUnknownMsg,
                     MESSAGE_ACTION ma,
                     PVOID  pvContext,
                     BOOL *pfShouldDelete)
{
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = (CMsgRef *)pIUnknownMsg;
    CQueueAdminContext *pqapictx = (CQueueAdminContext *)pvContext;
    BOOL    fUpdateStats = TRUE;


    _ASSERT(pmsgref);
    _ASSERT(pfShouldDelete);
    _ASSERT(pqapictx);
    _ASSERT(pqapictx && pqapictx->fIsValid());

    if (pqapictx && !pqapictx->fIsValid())
        pqapictx = NULL;

    if (pqapictx && (LI_RETRY == pqapictx->lfGetQueueState()))
    {
        //We should not update stats if we are working on the retry queue
        //instead we should call UpdateRetryStats if this is a retry queue
        fUpdateStats = FALSE;
    }

    *pfShouldDelete = FALSE;

    switch (ma)
    {
      case MA_DELETE:
        hr = pmsgref->HrQueueAdminNDRMessage((CDestMsgQueue *)this);
        *pfShouldDelete = TRUE;
        break;
      case MA_DELETE_SILENT:
        hr = pmsgref->HrRemoveMessageFromQueue((CDestMsgQueue *)this);
        *pfShouldDelete = TRUE;
        break;
      case MA_FREEZE_GLOBAL:
        pmsgref->GlobalFreezeMessage();
        break;
      case MA_THAW_GLOBAL:
        pmsgref->GlobalThawMessage();

        //
        //  Mark this queue as one to check for thawed messages.
        //
        if (pqapictx)
            pqapictx->IncThawedMsgs();

        break;
      case MA_COUNT:
      default:
        //do nothing for counting and default
        break;
    }

    if (*pfShouldDelete && SUCCEEDED(hr) ) {
        if (fUpdateStats)
        {
            UpdateMsgStats(pmsgref, FALSE);
            MarkQueueEmptyIfNecessary();
        }
        else
        {
            UpdateRetryStats(FALSE);
        }
    }

    return hr;
}

//---[ CDestMsgQueue::fMatchesID ]---------------------------------------------
//
//
//  Description:
//      Used to determine if this link matches a given scheduleID/link pair
//  Parameters:
//      IN  QueueLinkID         ID to match against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CDestMsgQueue::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    //This is not used at the DMQ level
    _ASSERT(0 && "Not implemented");
    return E_NOTIMPL;
}

//---[ CDestMsgQueue::SendLinkStateNotification ]------------------------------
//
//
//  Description:
//      Sends link state notification saying that the link was created.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      8/18/99 - AWetmore Created
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::SendLinkStateNotification(void) {
    CLinkMsgQueue *plmq = plmqGetLink();
    if (plmq) {
        plmq->SendLinkStateNotificationIfNew();
        plmq->Release();
    }
}

//---[ CDestMsgQueue::fIsRemote ]----------------------------------------------
//
//
//  Description:
//      Determines if queue is routed remotely.  Caller should have routing
//      share lock.
//  Parameters:
//      -
//  Returns:
//      TRUE if link is routed remotely
//      FALSE otherwise
//  History:
//      11/29/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CDestMsgQueue::fIsRemote()
{
    CLinkMsgQueue *plmq = plmqGetLink();
    BOOL           fIsRemote = FALSE;
    if (plmq) {
        fIsRemote = plmq->fIsRemote();
        plmq->Release();
    }

    return fIsRemote;
}


//---[ CDestMsgRetryQueue::CheckForStaleMsgsNextDSNGenerationPass ]------------
//
//
//  Description:
//      Marks the queue as so that we will do the (expensive) check for
//      stale messages during the next DSN generation pass.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      4/18/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDestMsgRetryQueue::CheckForStaleMsgsNextDSNGenerationPass()
{
    _ASSERT(m_pdmq);
    dwInterlockedSetBits(&(m_pdmq->m_dwFlags),
                         CDestMsgQueue::DMQ_CHECK_FOR_STALE_MSGS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\domain.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: domain.cpp
//
//  Description: Implementation of CDomainMapping, CDomainEntry, and
//      CDomainMappingTable.
//
//      The DomainMappingTable is a domain name hash table that contains the
//      mappings from final destination to queues.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqroute.h"
#include "localq.h"
#include "asyncq.h"
#include "mailadmq.h"
#include "tran_evntlog.h"

const DWORD LOCAL_DOMAIN_NAME_SIZE = 512;

//Max mislabled queues in empty list, before we will clean the list
const DWORD MAX_MISPLACED_QUEUES_IN_EMPTY_LIST = 100;


//Callback for retry
void CDomainMappingTable::SpecialRetryCallback(PVOID pvContext)
{
    CDomainMappingTable *pdnt = (CDomainMappingTable *) pvContext;
    _ASSERT(pdnt);
    _ASSERT(DOMAIN_MAPPING_TABLE_SIG == pdnt->m_dwSignature);

    dwInterlockedUnsetBits(&(pdnt->m_dwFlags), DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK);
    pdnt->ProcessSpecialLinks(0, FALSE);
}

//---[ ReUnreachableErrorToAqueueError ]---------------------------------------
//
//
//  Description:
//      Translates a HRESULT returned from GetNextHop to one that is meaningful
//      to aqueue DSN generation.
//  Parameters:
//      IN HRESULT reErr -- Error from routing.
//      IN OUT HRESULT aqErr -- Corresponding aqueue error code.
//  Returns:
//      Nothing.
//  History:
//      GPulla created.
//
//-----------------------------------------------------------------------------
void ReUnreachableErrorToAqueueError(HRESULT reErr, HRESULT *aqErr)
{
    if(E_ACCESSDENIED == reErr)
        *aqErr = AQUEUE_E_ACCESS_DENIED;

    else if(HRESULT_FROM_WIN32(ERROR_MESSAGE_EXCEEDS_MAX_SIZE) == reErr)
        *aqErr = AQUEUE_E_MESSAGE_TOO_LARGE;

    else
        *aqErr = AQUEUE_E_NO_ROUTE;

}

//---[ DeinitDomainEntryIteratorFn ]--------------------------------------------
//
//
//  Description:
//      Deletes and releases all internal domain info objects in table
//  Parameters:
//          IN  pvContext   - pointer to context (ignored)
//          IN  pvData      - data entry to look at
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfRemoveEntry - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      6/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID DeinitDomainEntryIteratorFn(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete)
{
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    *pfDelete = FALSE;
    *pfContinue = TRUE;
    pdentry->HrDeinitialize();
}

//---[ ReleaseDomainEntryIteratorFn ]------------------------------------------
//
//
//  Description:
//      Deletes and releases all internal domain info objects in table
//  Parameters:
//          IN  pvContext   - pointer to context (ignored)
//          IN  pvData      - data entry to look at
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfRemoveEntry - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      6/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID ReleaseDomainEntryIteratorFn(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete)
{
    ULONG   cRefs;
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    *pfDelete = TRUE;
    *pfContinue = TRUE;
    cRefs = pdentry->Release();
    _ASSERT(!cRefs && "leaking domain entries");
}

//***[ CDomainMapping Methods ]************************************************

//---[ CDomainMapping::Clone ]-------------------------------------------------
//
//
//  Description: Fills the current mapping with data from another DomainMapping
//
//  Parameters:
//      IN pdmap    CDomainMapping to clone
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CDomainMapping::Clone(IN CDomainMapping *pdmap)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMapping::Clone");
    Assert(pdmap);
    m_pdentryDomainID = pdmap->m_pdentryDomainID;
    m_pdentryQueueID  = pdmap->m_pdentryQueueID;
    TraceFunctLeave();
}

//---[ CDomainMapping::HrGetDestMsgQueue ]-------------------------------------
//
//
//  Description: Returns a pointer to the queue that this mapping points to
//
//  Parameters:
//      IN  paqmt    Message Type to get queue for
//      OUT ppdmq    pointer returned
//
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN
//
//-----------------------------------------------------------------------------
HRESULT CDomainMapping::HrGetDestMsgQueue(IN CAQMessageType *paqmt,
                                          OUT CDestMsgQueue **ppdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMapping::HrGetDestMsgQueue");
    HRESULT hr = S_OK;
    Assert(ppdmq);

    if (m_pdentryQueueID == NULL)
    {
        hr = AQUEUE_E_INVALID_DOMAIN;
        goto Exit;
    }

    hr = m_pdentryQueueID->HrGetDestMsgQueue(paqmt, ppdmq);

  Exit:
    TraceFunctLeave();
    return hr;
}

//***[ CDomainEntry Methods ]**************************************************

//---[ CDomainEntry::CDomainEntry() ]------------------------------------------
//
//
//  Description: CDomainEntry constructor
//
//  Parameters:
//      paqinst    - ptr to the virtual server object
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDomainEntry::CDomainEntry(CAQSvrInst *paqinst) :
            m_slPrivateData("CDomainEntry")
{
    _ASSERT(paqinst);
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::CDomainEntry");
    //Create a mapping that is not compressed
    m_dmap.m_pdentryDomainID = this;
    m_dmap.m_pdentryQueueID = this;
    m_dwSignature = DOMAIN_ENTRY_SIG;

    //init pointers
    m_szDomainName = NULL;
    m_cbDomainName = 0;
    InitializeListHead(&m_liDestQueues);
    InitializeListHead(&m_liLinks);

    m_cLinks = 0;
    m_cQueues = 0;

    m_paqinst = paqinst;
    m_paqinst->AddRef();

    TraceFunctLeave();
}

//---[ CDomainEntry::~CDomainEntry() ]-----------------------------------------
//
//
//  Description: CDomainEntry destructor
//
//  Parameters:
//      -
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDomainEntry::~CDomainEntry()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::~CDomainEntry");
    PLIST_ENTRY pli = NULL; //used to iterate over lists
    CDestMsgQueue *pdmq = NULL;
    CLinkMsgQueue  *plmq = NULL;

    //Remove all DestMsgQueues from list
    while (!IsListEmpty(&m_liDestQueues))
    {
        pli = m_liDestQueues.Flink;
        _ASSERT((pli != &m_liDestQueues) && "List Macros are broken");
        pdmq = CDestMsgQueue::pdmqGetDMQFromDomainListEntry(pli);
        pdmq->RemoveQueueFromDomainList();
        pdmq->Release();
        m_cQueues--;
    }

    //Remove all links from list
    while (!IsListEmpty(&m_liLinks))
    {
        pli = m_liLinks.Flink;
        plmq = CLinkMsgQueue::plmqGetLinkMsgQueue(pli);
        plmq->fRemoveLinkFromList();
        plmq->Release();
        m_cLinks--;
        _ASSERT((pli != &m_liLinks) && "List Macros are broken");
    }

    FreePv(m_szDomainName);

    if (m_paqinst)
        m_paqinst->Release();

    TraceFunctLeave();
}

//---[ CDomainEntry::HrInitialize ]--------------------------------------------
//
//
//  Description: Initilizer for CDomainEntry.  This should be called BEFORE the
//      entry is inserted into the DMT where other threads can access it.
//
//  Parameters:
//      szDomainName    string of domain name for entry, will *NOT* be copied, this
//                      object will take control of this. This will save a unneeded
//                      buffer copy and allocation per domain entry
//      pdentryQueueID  ptr to the primary entry for this domain (usually this)
//      pdmq            ptr to DestMsgQueue
//      plmq            ptr to LinkMsgQueue to allocate
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if any allocation fails
//
//  It is expected that this is only called by the DMT while creating an entry
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrInitialize(DWORD cbDomainName, LPSTR szDomainName,
                           CDomainEntry *pdentryQueueID, CDestMsgQueue *pdmq,
                           CLinkMsgQueue *plmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrInitialize");
    Assert(szDomainName);
    Assert((pdentryQueueID == this) || (pdmq == NULL));

    HRESULT hr = S_OK;

    m_cbDomainName = cbDomainName;
    m_szDomainName = szDomainName;

    //write domain mapping
    m_dmap.m_pdentryDomainID = this;
    m_dmap.m_pdentryQueueID  = pdentryQueueID;

    //add the queue to our list of queues
    if (pdmq)
    {
        m_slPrivateData.ExclusiveLock();
        m_cQueues++;
        pdmq->AddRef();
        pdmq->InsertQueueInDomainList(&m_liDestQueues);
        m_slPrivateData.ExclusiveUnlock();
    }

    if (plmq)
    {
        m_slPrivateData.ExclusiveLock();
        m_cLinks++;
        plmq->AddRef();
        plmq->InsertLinkInList(&m_liLinks);
        m_slPrivateData.ExclusiveUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrDeinitialize ]------------------------------------------
//
//
//  Description: Deinitializer for CDomainEntry
//
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrDeinitialize");
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL; //used to iterate over lists
    CDestMsgQueue *pdmq = NULL;
    CLinkMsgQueue *plmq = NULL;

    m_slPrivateData.ExclusiveLock();
    while (!IsListEmpty(&m_liDestQueues))
    {
        pli = m_liDestQueues.Flink;
        _ASSERT((pli != &m_liDestQueues) && "List Macros are broken");
        pdmq = CDestMsgQueue::pdmqGetDMQFromDomainListEntry(pli);
        pdmq->HrDeinitialize();
        pdmq->RemoveQueueFromDomainList();
        pdmq->Release();
        m_cQueues--;
        pdmq = NULL;
    }

    //Remove all links from list
    while (!IsListEmpty(&m_liLinks))
    {
        pli = m_liLinks.Flink;
        plmq = CLinkMsgQueue::plmqGetLinkMsgQueue(pli);
        plmq->HrDeinitialize();
        plmq->fRemoveLinkFromList();
        plmq->Release();
        m_cLinks--;
        _ASSERT((pli != &m_liLinks) && "List Macros are broken");
    }

    if (m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    m_slPrivateData.ExclusiveUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrGetDomainMapping ]--------------------------------------
//
//
//  Description: Returns Domain Mapping for this object
//
//  Parameters:
//      OUT pdmap   CDomainMapping for return information
//
//  Returns:
//      S_OK on success
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrGetDomainMapping(OUT CDomainMapping *pdmap)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrGetDomainMapping");
    HRESULT hr = S_OK;
    _ASSERT(pdmap);
    pdmap->Clone(&m_dmap);
    TraceFunctLeave();
    return S_OK;
}

//---[ CDomainEntry::HrGetDomainName ]----------------------------------------------
//
//
//  Description: Copies Domain Name. Caller is responsible for freeing string
//
//  Parameters:
//      OUT pszDomainName    string of domain name for entry, will be copied
//
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if any allocation fails
//
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrGetDomainName(OUT LPSTR *pszDomainName)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrGetDomainName");
    HRESULT hr = S_OK;
    Assert(pszDomainName);

    if (m_szDomainName == NULL)
    {
        *pszDomainName = NULL;
        goto Exit;
    }

    //Copy domain name
    *pszDomainName = (LPSTR) pvMalloc(m_cbDomainName + sizeof(CHAR));

    if (*pszDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    strcpy(*pszDomainName, m_szDomainName);

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrGetDestMsgQueue ]---------------------------------------
//
//
//  Description: Returns a pointer to the queue that this entry points to
//
//  Parameters:
//      IN  paqmt    Message Type to get domain for
//      OUT ppdmq    pointer returned
//
//  Returns:
//      S_OK on success
//      E_FAIL no queue matching message type is found
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrGetDestMsgQueue(IN CAQMessageType *paqmt,
                                        OUT CDestMsgQueue **ppdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrGetDestMsgQueue");
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL;
    CDestMsgQueue *pdmq = NULL;
    _ASSERT(ppdmq);
    _ASSERT(m_dmap.m_pdentryDomainID == this);
    DEBUG_DO_IT(DWORD cQueues = 0);

    if (m_dmap.m_pdentryQueueID == m_dmap.m_pdentryDomainID)
    {
        //this must be the primary entry... scan our own list of queues
        m_slPrivateData.ShareLock();
        pli = m_liDestQueues.Flink;
        while (pli != &m_liDestQueues)
        {
            _ASSERT(m_cQueues >= cQueues);
            DEBUG_DO_IT(cQueues++);
            pdmq = CDestMsgQueue::pdmqIsSameMessageType(paqmt, pli);
            if (pdmq)
                break;

            pli = pli->Flink;
        }
        m_slPrivateData.ShareUnlock();

        if (!pdmq)
            hr = E_FAIL; //no such queue
        else
        {
            pdmq->AddRef();
            *ppdmq = pdmq;
        }
    }
    else
    {
        //we are not primary
        _ASSERT(0 && "Non-primary domain entry... currently only primary entries are supported");
        _ASSERT(IsListEmpty(&m_liDestQueues));  //make sure it matches the profile
        hr = m_dmap.m_pdentryQueueID->HrGetDestMsgQueue(paqmt, ppdmq);
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrAddUniqueDestMsgQueue ]---------------------------------
//
//
//  Description:
//      Adds a queue to this entry's list of queues if a queue with the same
//      message type does not already exist.
//
//      Will appropriately AddRef domain.
//  Parameters:
//      IN  pdmqNew         - CDestMsgQueue to add
//      OUT ppdmqCurrent    - Set to curent CDestMsgQueue on failure
//  Returns:
//      S_OK on success
//      E_FAIL if a CDestMsgQueue with same Message type alread exists.
//  History:
//      5/28/98 - MikeSwa Created
//      9/8/98 - MikeSwa Modified to use AddRef/Relase for queues
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrAddUniqueDestMsgQueue(IN  CDestMsgQueue *pdmqNew,
                                OUT CDestMsgQueue **ppdmqCurrent)
{
    _ASSERT(pdmqNew);
    _ASSERT(ppdmqCurrent);
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL;
    CDestMsgQueue *pdmq = NULL;
    CAQMessageType *paqmt = pdmqNew->paqmtGetMessageType();
    DEBUG_DO_IT(DWORD cQueues = 0);

    *ppdmqCurrent = NULL;

    m_slPrivateData.ExclusiveLock();
    pli = m_liDestQueues.Flink;

    //First look through list and make sure that there isn't already a
    //queue with this message type
    while (pli != &m_liDestQueues)
    {
        _ASSERT(m_cQueues >= cQueues);
        pdmq = CDestMsgQueue::pdmqIsSameMessageType(paqmt, pli);
        if (pdmq)
        {
            hr = E_FAIL;
            pdmq->AddRef();
            *ppdmqCurrent = pdmq;
            goto Exit;
        }
        DEBUG_DO_IT(cQueues++);
        pli = pli->Flink;
    }

    pdmqNew->AddRef();
    pdmqNew->InsertQueueInDomainList(&m_liDestQueues);
    m_cQueues++;

  Exit:
    m_slPrivateData.ExclusiveUnlock();
    return hr;
}

//---[ CDomainEntry::HrGetLinkMsgQueue ]---------------------------------------
//
//
//  Description:
//      Gets a link for the given schedule id
//  Parameters:
//      IN  paqsched    - ScheduleID to search for
//      OUT pplmq       - returned queue
//  Returns:
//      S_OK on success
//      E_FAIL if no link matching the schudule ID can be found
//  History:
//      6/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrGetLinkMsgQueue(IN CAQScheduleID *paqsched,
                              OUT CLinkMsgQueue **pplmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrGetLinkMsgQueue");
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL;
    CLinkMsgQueue *plmq = NULL;
    _ASSERT(pplmq);
    _ASSERT(m_dmap.m_pdentryDomainID == this);
    DEBUG_DO_IT(DWORD cLinks = 0);

    m_slPrivateData.ShareLock();
    pli = m_liLinks.Flink;
    while (pli != &m_liLinks)
    {
        _ASSERT(m_cLinks >= cLinks);
        DEBUG_DO_IT(cLinks++);
        plmq = CLinkMsgQueue::plmqIsSameScheduleID(paqsched, pli);
        if (plmq)
        {
            plmq->AddRef();
            break;
        }

        pli = pli->Flink;
    }
    m_slPrivateData.ShareUnlock();

    if (!plmq)
        hr = E_FAIL; //no such queue
    else
        *pplmq = plmq;

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrAddUniqueLinkMsgQueue ]---------------------------------
//
//
//  Description:
//      Inserts a link with a unique schedule ID
//  Parameters:
//      IN  plmqNew     New link to insert
//      OUT plmqCurrent Current link with schedule ID on insert failure
//  Returns:
//      S_OK if insert succeeds
//      E_FAIL if insert fails
//  History:
//      6/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrAddUniqueLinkMsgQueue(IN  CLinkMsgQueue *plmqNew,
                                    OUT CLinkMsgQueue **pplmqCurrent)
{
    _ASSERT(plmqNew);
    _ASSERT(pplmqCurrent);
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL;
    CLinkMsgQueue *plmq = NULL;
    CAQScheduleID *paqsched = plmqNew->paqschedGetScheduleID();
    DEBUG_DO_IT(DWORD cLinks = 0);

    *pplmqCurrent = NULL;

    m_slPrivateData.ExclusiveLock();
    pli = m_liLinks.Flink;

    //First look through list and make sure that there isn't already a
    //queue with this schedule ID
    while (pli != &m_liLinks)
    {
        _ASSERT(m_cLinks >= cLinks);
        plmq = CLinkMsgQueue::plmqIsSameScheduleID(paqsched, pli);
        if (plmq)
        {
            hr = E_FAIL;
            *pplmqCurrent = plmq;
            plmq->AddRef();
            goto Exit;
        }
        DEBUG_DO_IT(cLinks++);
        pli = pli->Flink;
    }

    plmqNew->InsertLinkInList(&m_liLinks);
    plmqNew->AddRef();
    m_cLinks++;

  Exit:
    m_slPrivateData.ExclusiveUnlock();
    return hr;
}

//---[ CDomainEntry::RemoveDestMsgQueue ]--------------------------------------
//
//
//  Description:
//      Removes empty DMQ from entry.
//  Parameters:
//      IN  pdmq        DMQ to remove from domain entry
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainEntry::RemoveDestMsgQueue(IN CDestMsgQueue *pdmq)
{
    _ASSERT(pdmq && "INVALID Param for internal function");
    m_slPrivateData.ExclusiveLock();
    pdmq->RemoveQueueFromDomainList();
    pdmq->HrDeinitialize();
    pdmq->Release();
    m_cQueues--;
    m_slPrivateData.ExclusiveUnlock();
}

//---[ CDomainEntry::RemoveLinkMsgQueue ]--------------------------------------
//
//
//  Description:
//      Removes an empty LinkMsgQueue from the domain entry
//  Parameters:
//      IN  plmq        Link to remove
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainEntry::RemoveLinkMsgQueue(IN CLinkMsgQueue *plmq)
{
    _ASSERT(plmq && "INVALID Param for internal function");
    m_slPrivateData.ExclusiveLock();
    BOOL fRemove = plmq->fRemoveLinkFromList();
    if (fRemove)
        m_cLinks--;
    m_slPrivateData.ExclusiveUnlock();

    if (fRemove) {

        //do *NOT* call HrDeinitialize here since it will deadlock

        plmq->RemovedFromDMT();
        plmq->Release();
    }
}


//***[ CDomainMappingTable Methods ]*******************************************

//---[ CDomainMappingTable::CDomainMappingTable ]------------------------------
//
//
//  Description: CDomainMappingTable constructor
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
CDomainMappingTable::CDomainMappingTable() :
            m_slPrivateData("CDomainMappingTable")
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::CDomainMappingTable");
    m_paqinst = NULL;
    m_dwSignature = DOMAIN_MAPPING_TABLE_SIG;
    m_dwInternalVersion = 0;
    m_cOutstandingExternalShareLocks = 0;
    m_cThreadsForEmptyDMQList = 0;

    m_plmqLocal = NULL;
    m_plmqCurrentlyUnreachable = NULL;
    m_plmqUnreachable = NULL;
    m_pmmaqPreCategorized = NULL;
    m_pmmaqPreRouting = NULL;
    m_cSpecialRetryMinutes = 0;
    m_cResetRoutesRetriesPending = 0;

    m_dwFlags = 0;
    InitializeListHead(&m_liEmptyDMQHead);
    TraceFunctLeave();
}

//---[ CDomainMappingTable::~CDomainMappingTable ]------------------------------------------------------------
//
//
//  Description: CDomainMappingTable destructor
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
CDomainMappingTable::~CDomainMappingTable()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::~CDomainMappingTable");

    //Remove everything from the table
    m_dnt.HrIterateOverSubDomains(NULL, ReleaseDomainEntryIteratorFn, NULL);

    if (m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    if (m_plmqLocal)
        m_plmqLocal->Release();

    if (m_plmqCurrentlyUnreachable)
        m_plmqCurrentlyUnreachable->Release();

    if (m_plmqUnreachable)
        m_plmqUnreachable->Release();

    if (m_pmmaqPreCategorized)
        m_pmmaqPreCategorized->Release();

    if (m_pmmaqPreRouting)
        m_pmmaqPreRouting->Release();

    if (m_pmmaqPreSubmission)
        m_pmmaqPreSubmission->Release();

    _ASSERT(!m_cOutstandingExternalShareLocks); //there should be no outstanding sharelocks
    TraceFunctLeave();
}

//---[ CDomainMappingTable::HrInitialize ]-------------------------------------
//
//
//  Description: Performs initialization that may return an error code
//
//  Parameters:
//      IN  paqinst     AQ Svr Inst
//      IN  paradmq     Local Async Queue (passed to local link as part
//  Returns: S_OK on success
//
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrInitialize(CAQSvrInst *paqinst,
                                          CAsyncAdminMsgRefQueue *paradmq,
                                          CAsyncAdminMailMsgQueue *pammqPreCatQ,
                                          CAsyncAdminMailMsgQueue *pammqPreRoutingQ,
                                          CAsyncAdminMailMsgQueue *pammqPreSubmissionQ)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrInitialize");
    HRESULT hr = S_OK;
    HRESULT hrCurrent = S_OK;
    _ASSERT(paqinst);
    m_paqinst = paqinst;
    m_paqinst->AddRef();

    //------Link for local Queue-----------------------------------------------
    m_plmqLocal = new CLocalLinkMsgQueue(paradmq, g_sGuidLocalLink, m_paqinst);
    if (!m_plmqLocal)
        hr = E_OUTOFMEMORY;

    hrCurrent = HrInializeGlobalLink(LOCAL_LINK_NAME,
                                    sizeof(LOCAL_LINK_NAME) - sizeof(CHAR),
                                    (CLinkMsgQueue **) &m_plmqLocal,
                                    LA_KICK | LA_FREEZE | LA_THAW,
                                    LI_TYPE_LOCAL_DELIVERY);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //------Link for currently unreachable Queue-------------------------------
    hrCurrent = HrInializeGlobalLink(CURRENTLY_UNREACHABLE_LINK_NAME,
                                    sizeof(CURRENTLY_UNREACHABLE_LINK_NAME) - sizeof(CHAR),
                                    &m_plmqCurrentlyUnreachable,
                                    0,
                                    LI_TYPE_CURRENTLY_UNREACHABLE);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    hrCurrent = HrInializeGlobalLink(UNREACHABLE_LINK_NAME,
                                    sizeof(UNREACHABLE_LINK_NAME) - sizeof(CHAR),
                                    &m_plmqUnreachable,
                                    0,
                                    LI_TYPE_INTERNAL);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //-------Link for precat Queue---------------------------------------------
    m_pmmaqPreCategorized = new CMailMsgAdminLink(g_sGuidPrecatLink, PRECAT_QUEUE_NAME,
                                       pammqPreCatQ, LI_TYPE_PENDING_CAT,
                                       m_paqinst);

    if (!m_pmmaqPreCategorized)
        hr = E_OUTOFMEMORY;

    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //-------Link for prerouting Queue-----------------------------------------
    m_pmmaqPreRouting = new CMailMsgAdminLink(g_sGuidPreRoutingLink, PREROUTING_QUEUE_NAME,
                                       pammqPreRoutingQ, LI_TYPE_PENDING_ROUTING,
                                       m_paqinst);

    if (!m_pmmaqPreRouting)
        hr = E_OUTOFMEMORY;

    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //-------Link for presubmissionQueue--------------------------------------
    m_pmmaqPreSubmission = new CMailMsgAdminLink(g_sGuidPreSubmissionLink,
                                       PRESUBMISSION_QUEUE_NAME,
                                       pammqPreSubmissionQ, LI_TYPE_PENDING_SUBMIT,
                                       m_paqinst);

    if (!m_pmmaqPreSubmission)
        hr = E_OUTOFMEMORY;

    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;
    //-------------------------------------------------------------------------

    hrCurrent = m_dnt.HrInit();
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrDeinitialize ]-----------------------------------
//
//
//  Description: Performs cleanup that may return an error code
//
//  Parameters: -
//
//  Returns: S_OK on success
//
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrDeinitialize");
    HRESULT hr = S_OK;
    HRESULT hrCurrent = S_OK;

    hr = m_dnt.HrIterateOverSubDomains(NULL, DeinitDomainEntryIteratorFn, NULL);

    //Deinitialize global special links
    hrCurrent = HrDeinitializeGlobalLink((CLinkMsgQueue **) &m_plmqLocal);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    hrCurrent = HrDeinitializeGlobalLink(&m_plmqCurrentlyUnreachable);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    hrCurrent = HrDeinitializeGlobalLink(&m_plmqUnreachable);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //NOTE: This *must* come after Deinitialize of entries
    if (m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    TraceFunctLeave();
    return hr;
}


//---[ <CDomainMappingTable::HrInializeGlobalLink ]-----------------------------
//
//
//  Description:
//      Initializes a single global link for the DMT.  Configures link to not
//      send notifications to the connection manager, and to
//  Parameters:
//      IN  szLinkName              The link name to use for the link
//      IN  cbLinkName              The string length of the link name
//      OUT pplmq                   Link to allocate/initialize
//      IN  dwSupportedActions    Bitmask specifying what actions are supported on this link
//      IN  dwLinkType              Link type to be returned to admin (LI_TYPE)
//  Returns:
//
//  History:
//      1/27/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrInializeGlobalLink(IN  LPCSTR szLinkName,
                                                  IN  DWORD  cbLinkName,
                                                  OUT CLinkMsgQueue **pplmq,
                                                  DWORD dwSupportedActions,
                                                  DWORD dwLinkType)
{
    HRESULT hr = S_OK;

    _ASSERT(pplmq);

    if (!*pplmq)
        *pplmq = new CLinkMsgQueue();

    if (*pplmq)
    {
        //Initialize local queue
        hr = (*pplmq)->HrInitialize(m_paqinst, NULL, cbLinkName,
                                     (LPSTR) szLinkName,
                                     eLinkFlagsAQSpecialLinkInfo, NULL);

        //Set flags so no connections will be made for this link
        (*pplmq)->dwModifyLinkState(   LINK_STATE_PRIV_NO_NOTIFY |
                                       LINK_STATE_PRIV_NO_CONNECTION,
                                       LINK_STATE_NO_ACTION );

        (*pplmq)->SetSupportedActions(dwSupportedActions);
        (*pplmq)->SetLinkType(dwLinkType);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//---[ CDomainMappingTable::HrDeinitializeGlobalLink ]-------------------------
//
//
//  Description:
//      Deinitializes a single global link for the DMT
//  Parameters:
//      IN OUT pplmq        Link to deinitialze / set to NULL
//  Returns:
//      S_OK on success
//      ERROR code from CLinkMsgQueue::HrDeinitialize();
//  History:
//      1/27/99 - MikeSwa Created
//      7/21/99 - MikeSwa Modified - removed free of link domain
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrDeinitializeGlobalLink(IN OUT CLinkMsgQueue **pplmq)
{
    HRESULT hr = S_OK;

    _ASSERT(pplmq);
    if (pplmq && *pplmq)
    {
        hr = (*pplmq)->HrDeinitialize();
        (*pplmq)->Release();
        *pplmq = NULL;
    }
    return hr;
}


//---[ CDomainMappingTable::HrMapDomainName ]----------------------------------
//
//
//  Description:
//      Looks up a DomainName in the DMT.  Will create a new entry if necessary
//
//  Parameters:
//      IN  szDomainName        Domain Name to map
//      IN  paqmtMessageType    Message type as returned by routing
//      IN  pIMessageRouter     IMessageRouter for this message
//      OUT pdmap               Mapping returned - allocated by caller
//      OUT ppdmq               ptr to Queue
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if an allocation fails
//      HRESULT_FROM_WIN32(ERROR_RETRY) if mapping data changes and entire
//          message should be re-mapped
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrMapDomainName(
                IN LPSTR szDomainName,
                IN CAQMessageType *paqmtMessageType,
                IN IMessageRouter *pIMessageRouter,
                OUT CDomainMapping *pdmap,
                OUT CDestMsgQueue **ppdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrMapDomainName");
    _ASSERT(pdmap);
    _ASSERT(ppdmq);
    _ASSERT(szDomainName);
    _ASSERT(szDomainName[0] && "unsupported config - RAID #68208");
    _ASSERT(pIMessageRouter);

    HRESULT                 hr            = S_OK;
    CDomainEntry           *pdentryResult = NULL;
    CDomainEntry           *pdentryExisting = NULL;
    DWORD                   cbDomainName  = 0;
    CInternalDomainInfo    *pIntDomainInfo= NULL;
    BOOL                    fLocal        = FALSE; //Is delivery local?
    BOOL                    fWalkEmptyList= FALSE;
    DOMAIN_STRING           strDomain; //allows quicker lookups/inserts
    CLinkMsgQueue          *plmq          = NULL;

    *ppdmq = NULL;
    cbDomainName = strlen(szDomainName)*sizeof(CHAR);
    INIT_DOMAIN_STRING(strDomain, cbDomainName, szDomainName);

    m_slPrivateData.ShareLock();
    hr = m_dnt.HrFindDomainName(&strDomain, (PVOID *) &pdentryResult);

    //
    //  If succeeded aquire usage lock before we give up DMT lock.
    //  Handle failure cases after releasing lock.
    //
    if (SUCCEEDED(hr))
    {
        pdentryResult->AddRef();
    }

    fWalkEmptyList = fNeedToWalkEmptyQueueList();
    m_slPrivateData.ShareUnlock();

    //
    //  Check and see if we need to delete empty queues.
    //
    if (fWalkEmptyList)
    {
        if (fDeleteExpiredQueues())
        {
            //something has changes
            hr = HRESULT_FROM_WIN32(ERROR_RETRY);
            goto Exit;
        }
    }

    if (hr == DOMHASH_E_NO_SUCH_DOMAIN) //gotta create a new entry
    {
        DebugTrace((LPARAM) this, "Creating new DMT entry");
        pdentryResult = new CDomainEntry(m_paqinst);
        if (NULL == pdentryResult)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        _ASSERT(m_paqinst);
        hr = m_paqinst->HrGetInternalDomainInfo(cbDomainName, szDomainName, &pIntDomainInfo);
        if (FAILED(hr))
        {
            //It must match the "*" domain at least
            _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
            goto Exit;
        }
        else
        {
            _ASSERT(pIntDomainInfo);
            if (pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
                DOMAIN_INFO_LOCAL_MAILBOX)
            {
                DebugTrace((LPARAM) NULL, "INFO: Local delivery queued.");
                fLocal = TRUE;
            }
        }

        //perform  initialization of domain entry... create queues if needed
        if (fLocal)
        {
            hr = HrInitLocalDomain(pdentryResult, &strDomain,
                        paqmtMessageType, pdmap);
        }
        else
        {
            hr = HrInitRemoteDomain(pdentryResult, &strDomain, pIntDomainInfo,
                        paqmtMessageType, pIMessageRouter, pdmap, ppdmq, &plmq);
        }

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Initializing %s domain %s - hr 0x%08X",
                (fLocal ? "local" : "remote"), szDomainName, hr);
            goto Exit;
        }

        m_slPrivateData.ExclusiveLock();

        hr = HrPrvInsertDomainEntry(&strDomain, pdentryResult, FALSE, &pdentryExisting);


        //Need to release exclusive lock in if/else clause

        if (SUCCEEDED(hr))  //the insertion succeeded
        {
            pdentryResult->AddRef();
            m_slPrivateData.ExclusiveUnlock();
            DebugTrace((LPARAM) szDomainName, "INFO: Creating new entry in DMT for domain %s", szDomainName);
            _ASSERT((fLocal || *ppdmq) && "Out param should be set here!");  //skip past getting value from table

            if (!fLocal)
            {
                hr = plmq->HrAddQueue(*ppdmq);
                if (FAILED(hr))
                {
                    // Remove DMQ from link w/o notify since we never added it
                    (*ppdmq)->RemoveDMQFromLink(FALSE);

                    // Release the link we couldn't use and get the
                    // currently unreachable link
                    plmq->Release();
                    plmq = plmqGetCurrentlyUnreachable();
                    if (plmq)
                    {
                        (*ppdmq)->SetRouteInfo(plmq);
                        hr = plmq->HrAddQueue(*ppdmq);
                        if (FAILED(hr))
                            (*ppdmq)->RemoveDMQFromLink(FALSE);
                    }

                    // Schedule a reset routes to clean up the currently
                    // unreachable queue
                    m_paqinst->ResetRoutes(RESET_NEXT_HOPS);
                }
            }

            goto Exit;
        }
        else if (DOMHASH_E_DOMAIN_EXISTS == hr) //another inserted first
        {
            hr = S_OK; //not really a failure
            DebugTrace((LPARAM) this, "Another thread inserted in the the DMT before us");
            pdentryExisting->AddRef();
            m_slPrivateData.ExclusiveUnlock();

            _ASSERT(pdentryExisting != pdentryResult);

            //release entry that we could not insert and replace with entry currently
            //in the table
            pdentryResult->HrDeinitialize();
            pdentryResult->Release();
            pdentryResult = NULL;
            pdentryResult = pdentryExisting;

            //Release queue if we have one
            if (*ppdmq)
            {
                (*ppdmq)->Release();
                *ppdmq = NULL;
            }

        }
        else
        {
            m_slPrivateData.ExclusiveUnlock();
            //general failure to insert

            //We must deinitialize the entry to force it to release any
            //queues and links associated with it.
            pdentryResult->HrDeinitialize();
            goto Exit;
        }
    }

    if (!*ppdmq & !fLocal) //we did not create entry in the table
    {
        _ASSERT(pdentryResult);

        //
        //  Prefix wants us to to more than assert.
        //      If HrFindDomainName() fails silently or
        //      fails with an error other than AQUEUE_E_INVALID_DOMAIN,
        //      will will hit this code path
        //
        if (!pdentryResult)
        {
            //
            //  Make sure HR is set.
            //
            if (SUCCEEDED(hr))
                hr = E_FAIL;

            goto Exit;
        }

        //Domain Name already exists in table
        //At this point, we need to pull an existing entry from the mapping
        //get domain mapping
        hr = pdentryResult->HrGetDomainMapping(pdmap);
        if (FAILED(hr))
            goto Exit;

        //get queue
        hr = pdentryResult->HrGetDestMsgQueue(paqmtMessageType, ppdmq);
        if (FAILED(hr))
        {
            //entry exists, but no queue for our message type
            _ASSERT(NULL == *ppdmq); //cannot fail if we create queue

            //$$TODO cache domain config on entry
            if (!pIntDomainInfo)
            {
                hr = m_paqinst->HrGetInternalDomainInfo(cbDomainName, szDomainName,
                                            &pIntDomainInfo);
                if (FAILED(hr))
                {
                    //It must match the "*" domain at least
                    _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
                    goto Exit;
                }
            }

            _ASSERT(pIntDomainInfo);
            if (!(pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
                DOMAIN_INFO_LOCAL_MAILBOX))
            {
                //this is a not a local domain entry
                hr = HrCreateQueueForEntry(pdentryResult, &strDomain, pIntDomainInfo,
                                paqmtMessageType, pIMessageRouter, pdmap, ppdmq);
                if (FAILED(hr))
                    goto Exit;
            }
            else
            {
                fLocal = TRUE;
            }

        }
    }
    _ASSERT((*ppdmq || fLocal) && "Non-local domains must have queue ptrs!");

  Exit:

    if (FAILED(hr)) //cleanup
    {
        if (pdentryResult)
        {
            pdentryResult->Release();
        }

        if (*ppdmq)
        {
            (*ppdmq)->Release();
            *ppdmq = NULL;
        }
    }
    else
    {
        if (*ppdmq) {
            // send link state notification saying that the link has
            // been created
            (*ppdmq)->SendLinkStateNotification();
        }
        if (pdentryResult) pdentryResult->Release();
    }

    if (plmq)
        plmq->Release();

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrPrvGetDomainEntry ]------------------------------
//
//
//  Description:
//      Internal private function to lookup Domain entry for given domain
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      IN      fDMTLocked              TRUE if locks are already
//      OUT     ppdentry                Domain Entry for domain (from DMT)
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain is not found
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrPrvGetDomainEntry(IN  DWORD cbDomainNameLength,
                      IN  LPSTR szDomainName, BOOL fDMTLocked,
                      OUT CDomainEntry **ppdentry)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    DOMAIN_STRING strDomain;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(ppdentry);

    INIT_DOMAIN_STRING(strDomain, cbDomainNameLength, szDomainName);

    if (!fDMTLocked)
    {
        m_slPrivateData.ShareLock();
        fLocked = TRUE;
    }

    hr = m_dnt.HrFindDomainName(&strDomain, (PVOID *) ppdentry);
    if (FAILED(hr))
    {
        if (DOMHASH_E_NO_SUCH_DOMAIN == hr)
            hr = AQUEUE_E_INVALID_DOMAIN;
        _ASSERT(NULL == *ppdentry);
        goto Exit;
    }

    (*ppdentry)->AddRef();

  Exit:

    if (fLocked)
        m_slPrivateData.ShareUnlock();

    return hr;
}

//---[ CDomainMappingTable::HrPrvInsertDomainEntry ]---------------------------
//
//
//  Description:
//      Private wrapper function for HrInsertDomainName
//  Parameters:
//      IN  pstrDomainName      Domain Name to insert in DNT
//      IN  pdnetryNew          DomainEntry to insert
//      IN  fTreadAsWildcard    TRUE if DNT to be told to treat as wildcard
//      OUT pdentryOld          Existing DomainEntry if there is one
//  Returns:
//
//  History:
//      10/5/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrPrvInsertDomainEntry(
                     IN  PDOMAIN_STRING  pstrDomainName,
                     IN  CDomainEntry *pdentryNew,
                     IN  BOOL  fTreatAsWildcard,
                     OUT CDomainEntry **ppdentryOld)
{
    HRESULT hr = S_OK;

    hr = m_dnt.HrInsertDomainName(pstrDomainName, pdentryNew, fTreatAsWildcard,
                                  (PVOID *) ppdentryOld);
    if (E_INVALIDARG == hr)
        hr = PHATQ_BAD_DOMAIN_SYNTAX;

    return hr;

}

//---[ CDomainMappingTable::HrInitLocalDomain ]--------------------------------
//
//
//  Description:
//      Performs initialization needed for a local domain when an entry is
//      created in the DMT
//  Parameters:
//      IN OUT pdentry - entry to init
//      IN     pStrDomain - domain name of entry
//      IN     paqmtMessageType Message Type of message
//      OUT    pdmap - Domain Mapping for domain
//  Returns:
//      S_OK  - when all succeeds
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrInitLocalDomain(
                            IN     CDomainEntry *pdentry,
                            IN     DOMAIN_STRING *pStrDomain,
                            IN     CAQMessageType *paqmtMessageType,
                            OUT    CDomainMapping *pdmap)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrInitLocalDomain");
    HRESULT hr = S_OK;
    LPSTR   szKey = NULL;

    _ASSERT(pdentry);
    _ASSERT(pStrDomain);
    _ASSERT(pdmap);
    _ASSERT('\0' == pStrDomain->Buffer[pStrDomain->Length]);

    //make copy of string to store in domain entry
    szKey = (LPSTR) pvMalloc(pStrDomain->Length + sizeof(CHAR));
    if (szKey == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    strcpy(szKey, pStrDomain->Buffer);

    //passes ownership of szKey
    hr = pdentry->HrInitialize(pStrDomain->Length, szKey, pdentry, NULL, NULL);
    if (FAILED(hr))
        goto Exit;

    hr = pdentry->HrGetDomainMapping(pdmap);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (FAILED(hr) && szKey)
        FreePv(szKey);

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrInitRemoteDomain ]--------------------------------
//
//
//  Description:
//      Performs initialization needed for a remote domain when an entry is
//      created in the DMT.
//  Parameters:
//      IN     pdentry - entry to init
//      IN     pStrDomain - domain name of entry
//      IN     pIntDomainInfo - Internal config info for domain
//      IN     paqmtMessageType - Message type returned by routing
//      IN     pIMessageRouter - Message Router interface for this message
//      OUT    pdmap - Domain Mapping for domain
//      OUT    ppdmq - destmsgqueue for domain
//      OUT    pplmq - LinkMsgQueue that this queue should be associated with
//                  caller should call HrAddQueue once entry is in DMT
//  Returns:
//      S_OK   on success.
//      E_OUTOFMEMORY when allocations fail
//  History:
//      6/24/98 - Mikeswa Modified... added pplmq param and removed call to
//              HrAddQueue
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrInitRemoteDomain(
                            IN     CDomainEntry *pdentry,
                            IN     DOMAIN_STRING *pStrDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            OUT    CDomainMapping *pdmap,
                            OUT    CDestMsgQueue **ppdmq,
                            OUT    CLinkMsgQueue **pplmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrInitRemoteDomain");
    HRESULT hr = S_OK;
    HRESULT hrRoutingDiag = S_OK;
    LPSTR   szKey = NULL;
    CDestMsgQueue          *pdmq          = NULL;
    CLinkMsgQueue          *plmq          = NULL;
    BOOL    fEntryInit = FALSE;

    _ASSERT(ppdmq);
    _ASSERT(pplmq);
    _ASSERT(pdentry);
    _ASSERT(pStrDomain);
    _ASSERT(pdmap);
    _ASSERT(pIMessageRouter);
    _ASSERT('\0' == pStrDomain->Buffer[pStrDomain->Length]);

    //Initialze out params
    *ppdmq = NULL;
    *pplmq = NULL;

    //make copy of string to store in domain entry
    szKey = (LPSTR) pvMalloc(pStrDomain->Length + sizeof(CHAR));
    if (szKey == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    strcpy(szKey, pStrDomain->Buffer);

    hr = HrGetNextHopLink(pdentry, szKey, pStrDomain->Length, pIntDomainInfo,
            paqmtMessageType, pIMessageRouter, FALSE, &plmq, &hrRoutingDiag);
    if (FAILED(hr))
        goto Exit;

    pdmq = new CDestMsgQueue(m_paqinst, paqmtMessageType, pIMessageRouter);
    if (!pdmq)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //passes ownership of szKey & pdmq
    hr = pdentry->HrInitialize(pStrDomain->Length, szKey, pdentry, pdmq, NULL);
    if (FAILED(hr))
        goto Exit;

    fEntryInit = TRUE; //we cannot delete pdmq or szKey now

    //get the newly created domain mapping so we can initialize the queue
    hr = pdentry->HrGetDomainMapping(pdmap);
    if (FAILED(hr))
        goto Exit;

    //Initialize queue to use this domain mapping using the DomainMapping we just got
    hr = pdmq->HrInitialize(pdmap);
    if (FAILED(hr))
        goto Exit;

    //Associate link with DMQ
    pdmq->SetRouteInfo(plmq);

    //Set routing error if there was one.
    pdmq->SetRoutingDiagnostic(hrRoutingDiag);

    *ppdmq = pdmq;
    *pplmq = plmq;

  Exit:

    //Cleanup failure cases
    if (FAILED(hr) && !fEntryInit)
    {
        if (szKey)
            FreePv(szKey);

        if (NULL != pdmq)
        {
            //once domain entry has been initialized, it owns pdmq
            pdmq->HrDeinitialize();
            pdmq->Release();
            _ASSERT(NULL == *ppdmq);
        }

        if (NULL != plmq)
        {
            plmq->HrDeinitialize();
        }
    }

    if (plmq && !*pplmq) //we haven't passed refernce to OUT param
        plmq->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrCreateQueueForEntry ]----------------------------
//
//
//  Description:
//      Create a new queue for an already existing domain entry.
//
//      Currently, this is done by creating a new queue and link, and
//      attempting to associate the queue with the domain entry.
//  Parameters:
//      IN     pdentry - entry to add queue to
//      IN     pStrDomain - domain name of entry
//      IN     pIntDomainInfo - Internal config info for domain
//      IN     paqmtMessageType - Message type returned by routing
//      IN     pIMessageRouter - Message Router interface for this message
//      IN     pdmap - Domain Mapping for domain
//      OUT    ppdmq - destmsgqueue for domain
//  Returns:
//      S_OK on succcess
//  History:
//      6/2/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrCreateQueueForEntry(
                            IN     CDomainEntry *pdentry,
                            IN     DOMAIN_STRING *pStrDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     CDomainMapping *pdmap,
                            OUT    CDestMsgQueue **ppdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrCreateQueueForEntry");
    _ASSERT(pdentry);
    HRESULT hr = S_OK;
    HRESULT hrRoutingDiag = S_OK;
    CDestMsgQueue   *pdmq   = NULL;
    CLinkMsgQueue   *plmq   = NULL;
    LPSTR           szKey   = pdentry->szGetDomainName();

    *ppdmq = NULL;
    _ASSERT(pStrDomain);
    _ASSERT(pdmap);
    _ASSERT(pIMessageRouter);
    _ASSERT('\0' == pStrDomain->Buffer[pStrDomain->Length]);


    hr = HrGetNextHopLink(pdentry, szKey, pStrDomain->Length, pIntDomainInfo,
            paqmtMessageType, pIMessageRouter, FALSE, &plmq, &hrRoutingDiag);
    if (FAILED(hr))
        goto Exit;

    pdmq = new CDestMsgQueue(m_paqinst, paqmtMessageType, pIMessageRouter);
    if (NULL == pdmq)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    DebugTrace((LPARAM) szKey, "INFO: Creating new Destination Message Queue for domain %s", szKey);

    hr = pdmq->HrInitialize(pdmap);
    if (FAILED(hr))
        goto Exit;

    //Associate link with DMQ
    pdmq->SetRouteInfo(plmq);

    //Set routing error if there was one.
    pdmq->SetRoutingDiagnostic(hrRoutingDiag);

    //Now attempt to associate newly created queue/link pair with domain entry
    hr = pdentry->HrAddUniqueDestMsgQueue(pdmq, ppdmq);

    if (SUCCEEDED(hr))
    {
        *ppdmq = pdmq;

        //Only add the queue in this case... if a queue is already in the entry, then
        //the other thread must have already (or soon will) call HrAddQueue... we
        //should not call it twice.
        hr = plmq->HrAddQueue(*ppdmq);
        if (FAILED(hr))
        {
            // Remove DMQ from link w/o notify since we never added it
            (*ppdmq)->RemoveDMQFromLink(FALSE);

            // Release the link we couldn't use and get the
            // currently unreachable link
            plmq->Release();
            plmq = plmqGetCurrentlyUnreachable();
            if (plmq)
            {
                pdmq->SetRouteInfo(plmq);
                hr = plmq->HrAddQueue(*ppdmq);
                if (FAILED(hr))
                {
                    (*ppdmq)->RemoveDMQFromLink(FALSE);
                }
            }

            // Schedule a reset routes to clean up the currently
            // unreachable queue
            m_paqinst->ResetRoutes(RESET_NEXT_HOPS);

            // If we still have a failed hr, goto exit
            if (FAILED(hr))
                goto Exit;
        }
    }
    else
    {
        DebugTrace((LPARAM) this, "INFO: Thread swap while trying to add queue for domain %s", szKey);
        _ASSERT(*ppdmq != pdmq);
        _ASSERT(*ppdmq && "HrAddUniqueDestMsgQueue failed without returning an error code");
        hr = S_OK; //return new value

        //Remove link from DMQ... since we will never call HrAddQueue
        //don't notify link since it was never added
        pdmq->RemoveDMQFromLink(FALSE);
    }


  Exit:

    //Cleanup failure cases (including if queue created is not used)
    if (FAILED(hr) || (*ppdmq != pdmq))
    {
        if (NULL != pdmq)
        {
            //once domain entry has been initialized, it owns pdmq
            pdmq->Release();
        }
    }

    if (NULL != plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::LogDomainUnreachableEvent] ------------------------
//
//
//  Description:
//      Logs an event for an unreachable domain
//  Parameters:
//      IN  fCurrentlyUnreachable   Is the domain currently unreachable or
//                                     completely unreachable?
//      IN  szDomain                Final destination domain
//  History:
//      3/8/99 - AWetmore Created
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::LogDomainUnreachableEvent(BOOL fCurrentlyUnreachable,
                                      LPCSTR szDomain)
{

    DWORD dwMessageId =
        (fCurrentlyUnreachable) ? AQUEUE_DOMAIN_CURRENTLY_UNREACHABLE
                                : AQUEUE_DOMAIN_UNREACHABLE;

    LPSTR rgszSubStrings[1];

    rgszSubStrings[0] = (char*)szDomain;

    if (m_paqinst)
    {
        m_paqinst->HrTriggerLogEvent(
            dwMessageId,                            // Message ID
            TRAN_CAT_QUEUE_ENGINE,                  // Category
            1,                                      // Word count of substring
            (const char**)&rgszSubStrings[0],       // Substring
            EVENTLOG_WARNING_TYPE,                  // Type of the message
            0,                                      // No error code
            LOGEVENT_LEVEL_MINIMUM,                 // Logging level
            "",                                     // Key to identify this event
            LOGEVENT_FLAG_PERIODIC                  // Event logging option
            );
    }
}

//---[ CDomainMappingTable::HrGetNextHopLink ]------------------------------
//
//
//  Description:
//      Creates and initializes the CLinkMsgQueue object for this message
//      (if neccessary).  Calls router to get next hop info
//  Parameters:
//      IN  pdentry             Entry that is being initialized for destination
//      IN  szDomain            Final destination domain
//      IN  cbDomain            string length in bytes of domain (without \0)
//      IN  pIntDomainInfo      Domain info for final destination domain
//      IN  paqmtMessageType    Message type of this message
//      IN  pIMessageRouter     Routing interface for this message
//      IN  fDMTLocked          TRUE if DMT is already locked
//      OUT pplmq               Resulting link msg queue
//      OUT phrRoutingDiag      If next hop is unreachable, this tells us why
//  Returns:
//      S_OK on success
//  History:
//      6/19/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrGetNextHopLink(
                            IN     CDomainEntry *pdentry,
                            IN     LPSTR szDomain,
                            IN     DWORD cbDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     BOOL fDMTLocked,
                            OUT    CLinkMsgQueue **pplmq,
                            OUT    HRESULT *phrRoutingDiag)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrGetNextHopLink");
    HRESULT hr = S_OK;
    BOOL  fCalledGetNextHop = FALSE;
    BOOL  fValidSMTP = FALSE;
    BOOL  fOwnsScheduleId = FALSE;
    LPSTR szRouteAddressType = NULL;
    LPSTR szRouteAddress = NULL;
    LPSTR szRouteAddressClass = NULL;
    LPSTR szConnectorName = NULL;
    DWORD dwScheduleID = 0;
    DWORD dwNextHopType = 0;
    CLinkMsgQueue *plmq = NULL;
    CLinkMsgQueue *plmqTmp = NULL;
    LPSTR szOwnedDomain = NULL; // string buffer that is "owned" by an entry
    CDomainEntry *pdentryLink = NULL; //entry for link
    CDomainEntry *pdentryTmp = NULL;
    DOMAIN_STRING strNextHop;
    DWORD cbRouteAddress = 0;
    CAQScheduleID aqsched;
    IMessageRouterLinkStateNotification *pILinkStateNotify = NULL;
    LinkFlags lf = eLinkFlagsExternalSMTPLinkInfo;
    *phrRoutingDiag = S_OK;

    _ASSERT(pdentry);
    _ASSERT(szDomain);
    _ASSERT(pIntDomainInfo);
    _ASSERT(paqmtMessageType);
    _ASSERT(pIMessageRouter);
    _ASSERT(pplmq);

    hr = pIMessageRouter->QueryInterface(IID_IMessageRouterLinkStateNotification,
                                (VOID **) &pILinkStateNotify);
    if (FAILED(hr))
    {
        pILinkStateNotify = NULL;
        hr = S_OK;
    }

    //If we can route this domain.... call router to get next hop
    //We do not route TURN/ETRN domains... or local drop domains
    //Also check to see if the domain is configured as a local domain...
    //if it is, return the local link
    if (DOMAIN_INFO_LOCAL_MAILBOX & pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags)
    {
        //The likely scenario of this happening is if a domain was previously
        //configured as remote and then reconfigured as local.
        m_plmqLocal->AddRef();
        *pplmq = m_plmqLocal;
        goto Exit;
    }
    else if (!(pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
        (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY | DOMAIN_INFO_LOCAL_DROP)))
    {
        hr = pIMessageRouter->GetNextHop(MTI_ROUTING_ADDRESS_TYPE_SMTP, szDomain,
                                    paqmtMessageType->dwGetMessageType(), &szRouteAddressType,
                                    &szRouteAddress, &dwScheduleID, &szRouteAddressClass,
                                    &szConnectorName, &dwNextHopType);

        fCalledGetNextHop = TRUE;
        *pplmq = NULL;

        if(MTI_NEXT_HOP_TYPE_UNREACHABLE == dwNextHopType)
        {
            //If the next hop is unreachable, store the reason for the unreachable
            //error into *phrRoutingDiag (which is used by aqueue DSN generation).

            const char *rgszStrings[2] = { szDomain, NULL };

            if (m_paqinst)
            {
                m_paqinst->HrTriggerLogEvent(
                    PHATQ_UNREACHABLE_DOMAIN,           // Message ID
                    TRAN_CAT_QUEUE_ENGINE,              // Category
                    2,                                  // Word count of substring
                    rgszStrings,                        // Substring
                    EVENTLOG_WARNING_TYPE,              // Type of the message
                    hr,                                 // error code
                    LOGEVENT_LEVEL_FIELD_ENGINEERING,   // Logging level
                    "phatq",                            // key to this event
                    LOGEVENT_FLAG_PERIODIC,             // Logging option
                    1,                                  // index of format message string in rgszStrings
                    GetModuleHandle(AQ_MODULE_NAME)     // module handle to format a message
                );
            }

            ReUnreachableErrorToAqueueError(hr, phrRoutingDiag);
            hr = S_OK;
        }

        if (FAILED(hr))
        {
            RequestResetRoutesRetryIfNecessary();
            ErrorTrace((LPARAM) this,
                "GetNextHop failed with hr - 0x%08X", hr);

            //treat all failures as a routing currently unreachable
            hr = S_OK;
            dwNextHopType = MTI_NEXT_HOP_TYPE_CURRENTLY_UNREACHABLE;
        }


        if (MTI_NEXT_HOP_TYPE_CURRENTLY_UNREACHABLE == dwNextHopType)
        {
            LogDomainUnreachableEvent(TRUE, szDomain);
            *pplmq = m_plmqCurrentlyUnreachable;
        }
        else if (MTI_NEXT_HOP_TYPE_UNREACHABLE == dwNextHopType)
        {
            LogDomainUnreachableEvent(FALSE, szDomain);
            *pplmq = m_plmqUnreachable;
        }
        else if ((MTI_NEXT_HOP_TYPE_SAME_VIRTUAL_SERVER == dwNextHopType) ||
            (szRouteAddressType &&
             lstrcmpi(MTI_ROUTING_ADDRESS_TYPE_SMTP, szRouteAddressType)))
        {
            //Handle any cases that might be considered local delivery
            *pplmq = m_plmqLocal;
        }
        else if (!szRouteAddressType || ('\0' == *szRouteAddressType) ||
                 !szRouteAddress || ('\0' == *szRouteAddress))
        {
            //This is a bogus combination of values... try try again
            hr = E_FAIL;
            goto Exit;
        }
        else
        {
            fValidSMTP = TRUE;
            fOwnsScheduleId = TRUE;
            //At this point we should have valid SMTP values for the address
            _ASSERT(szRouteAddressType);
            _ASSERT(szRouteAddress);
            _ASSERT(!lstrcmpi(MTI_ROUTING_ADDRESS_TYPE_SMTP, szRouteAddressType));

            if (MTI_NEXT_HOP_TYPE_PEER_SMTP1_BYPASS_CONFIG_LOOKUP == dwNextHopType ||
                    MTI_NEXT_HOP_TYPE_PEER_SMTP2_BYPASS_CONFIG_LOOKUP == dwNextHopType) {
                lf = eLinkFlagsInternalSMTPLinkInfo;
            }

        }

        if (!fValidSMTP)
        {
            //Must be going to one of them-there global queues.
            hr = S_OK;

            if (*pplmq)
                (*pplmq)->AddRef();
            else
                hr = E_FAIL;

            //Our work here is done
            goto Exit;
        }

    }

    if ((!fCalledGetNextHop) || (!lstrcmpi(szDomain, szRouteAddress)))
    {
        //final destination and next hop are the same
        DebugTrace((LPARAM) this, "DEBUG: Routing case 1 - same next hop and final dest");

        // See if there is already a link for this schedule ID
        aqsched.Init(pIMessageRouter, dwScheduleID);

        hr = pdentry->HrGetLinkMsgQueue(&aqsched, &plmq);
        if (FAILED(hr))
        {
            hr = S_OK;

            //link does not exist for this schedule id yet
            plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                pILinkStateNotify);
            if (!plmq)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            fOwnsScheduleId = FALSE; //link now owns it
            DebugTrace((LPARAM) szDomain, "INFO: Creating new Link for domain %s", szDomain);

            hr = plmq->HrInitialize(m_paqinst, pdentry, cbDomain, szDomain,
                                lf, szConnectorName);
            if (FAILED(hr))
                goto Exit;

            hr = pdentry->HrAddUniqueLinkMsgQueue(plmq, &plmqTmp);
            if (FAILED(hr))
            {
                //Another link was inserted since we called get link msg queue
                DebugTrace((LPARAM) this, "DEBUG: Routing case 2(a) - next hop link created by other thread");
                _ASSERT(plmqTmp);
                plmq->HrDeinitialize();
                plmq->Release();
                plmq = plmqTmp;
                hr = S_OK;
            }
        }
        else
        {
            DebugTrace((LPARAM) this, "DEBUG: Routing case 2(b) - next hop link created by other thread");
        }
    }
    else
    {
        //next hop is different from final destination
        cbRouteAddress = strlen(szRouteAddress);

        //First see if there is an entry for this link
        hr = HrPrvGetDomainEntry(cbRouteAddress, szRouteAddress, fDMTLocked, &pdentryLink);
        if (AQUEUE_E_INVALID_DOMAIN == hr)
        {
            //an entry for this link does not exist... add one for this link
            hr = S_OK;
            DebugTrace((LPARAM) this, "DEBUG: Routing case 3 - next hop entry does not exist");

            szOwnedDomain = (LPSTR) pvMalloc(sizeof(CHAR)*(cbRouteAddress+1));
            if (!szOwnedDomain)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            lstrcpy(szOwnedDomain, szRouteAddress);

            pdentryLink = new CDomainEntry(m_paqinst);
            if (!pdentryLink)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                     pILinkStateNotify);
            if (!plmq)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            fOwnsScheduleId = FALSE; //link now owns it

            //passes ownership of szOwnedDomain
            hr = pdentryLink->HrInitialize(cbRouteAddress, szOwnedDomain,
                                        pdentryLink, NULL, plmq);
            if (FAILED(hr))
                goto Exit;

            hr = plmq->HrInitialize(m_paqinst, pdentryLink, cbRouteAddress,
                    szOwnedDomain, lf, szConnectorName);
            if (FAILED(hr))
                goto Exit;

            //insert entry in DMT
            strNextHop.Length = (USHORT) cbRouteAddress;
            strNextHop.Buffer = szOwnedDomain;
            strNextHop.MaximumLength = (USHORT) cbRouteAddress;

            if (!fDMTLocked)
                m_slPrivateData.ExclusiveLock();

            hr = HrPrvInsertDomainEntry(&strNextHop, pdentryLink, FALSE, &pdentryTmp);

            if (hr == DOMHASH_E_DOMAIN_EXISTS)
            {
                DebugTrace((LPARAM) this, "DEBUG: Routing case 4 - next hop entry did not exist... inserted by other thread");
                plmq->Release();
                plmq = NULL;
                pdentryTmp->AddRef();
                pdentryLink->HrDeinitialize();
                pdentryLink->Release();
                pdentryLink = pdentryTmp;
                hr = S_OK;

                //Will fall through to case as if an entry was found by HrGetDomainEntry
            }
            else if (SUCCEEDED(hr))
            {
                pdentryLink->AddRef();
            }

            if (!fDMTLocked)
                m_slPrivateData.ExclusiveUnlock();

            if (FAILED(hr))
                goto Exit;

        }
        else if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: General DMT failure - hr 0x%08X", hr);
            //general failure... bail
            goto Exit;
        }

        if (!plmq)
        {
            DebugTrace((LPARAM) this, "DEBUG: Routing case 5 - next hop entry exists");
            //An entry exists for this next hop... use link if possible
            // 1 - Get link for this schedule ID.. if it exists use it
            // 2 - Create another link and attempt to insert it
            _ASSERT(pdentryLink);
            aqsched.Init(pIMessageRouter, dwScheduleID);

            hr = pdentryLink->HrGetLinkMsgQueue(&aqsched, &plmq);
            if (FAILED(hr))
            {
                hr = S_OK;
                //link does not exist for this schedule id yet
                DebugTrace((LPARAM) this, "DEBUG: Routing case 6 - next hop link does not exist");

                szOwnedDomain = pdentryLink->szGetDomainName();

                plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                         pILinkStateNotify);
                if (!plmq)
                {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }

                fOwnsScheduleId = FALSE; //link now owns it

                hr = plmq->HrInitialize(m_paqinst, pdentryLink, cbRouteAddress,
                        szOwnedDomain, lf, szConnectorName);
                if (FAILED(hr))
                    goto Exit;

                hr = pdentryLink->HrAddUniqueLinkMsgQueue(plmq, &plmqTmp);
                if (FAILED(hr))
                {
                    //Another link was inserted since we called get link msg queue
                    DebugTrace((LPARAM) this, "DEBUG: Routing case 7 - next hop link created by other thread");
                    _ASSERT(plmqTmp);
                    plmq->Release();
                    plmq = plmqTmp;
                    hr = S_OK;
                }
            }
            else
            {
                DebugTrace((LPARAM) this, "DEBUG: Routing case 8 - next hop link exists");
            }

        }

    }

    _ASSERT(plmq && "We should have allocated a link by this point");
    *pplmq = plmq;

  Exit:

    if (pdentryLink)
        pdentryLink->Release();

    if (fCalledGetNextHop)
    {
        //
        // If we have not passed the schedule ID on to a link, we
        // must notify routing that we are not using it (to avoid a leak).
        // This needs to be be done *before* we release the strings
        // and routing interfaces.  If we hit this case, we have
        // either failed to create a link, or another link has
        // been created by another thread.
        //
        if (fOwnsScheduleId && pILinkStateNotify && pIMessageRouter)
        {
            FILETIME ftNotUsed = {0,0};
            DWORD    dwSetNotUsed = LINK_STATE_NO_ACTION;
            DWORD    dwUnsetNotUsed = LINK_STATE_NO_ACTION;
            pILinkStateNotify->LinkStateNotify(
                                        szDomain,
                                        pIMessageRouter->GetTransportSinkID(),
                                        dwScheduleID,
                                        szConnectorName,
                                        LINK_STATE_LINK_NO_LONGER_USED,
                                        0, //consecutive failures
                                        &ftNotUsed,
                                        &dwSetNotUsed,
                                        &dwUnsetNotUsed);
        }

        //
        // Free Strings returned by GetNextHop
        //
        _VERIFY(SUCCEEDED(pIMessageRouter->GetNextHopFree(
            MTI_ROUTING_ADDRESS_TYPE_SMTP,
            szDomain,
            szConnectorName,
            szRouteAddressType,
            szRouteAddress,
            szRouteAddressClass)));


    }

    if (pILinkStateNotify)
        pILinkStateNotify->Release();

    if (FAILED(hr) && plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrGetOrCreateLink ]--------------------------------
//
//
//  Description:
//      Gets or creates a link object for a domain name
//  Parameters:
//      IN  szRouteAddress      Final destination domain
//      IN  cbRouteAddress      string length in bytes of domain (without \0)
//      IN  dwScheduleID        Schedule ID for link (used in create)
//      IN  szConnectorName     Name (stringized GUID) of connector in DS
//      IN  pIMessageRouter     Routing interface for this message (used in create)
//      IN  fCreateIfNotExist   Create the link if it doesn't exist?
//      OUT pplmq               Resulting link msg queue
//      OUT pfRemoveOwnedSchedule   FALSE if a new link was created, TRUE on errors
//                                  and in case the link was addref'ed.
//  Returns:
//      S_OK on success
//  History:
//      7/6/1999 - AWetmore Created
//      12/30/1999 - MikeSwa Modified to not notify until connection attempt
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrGetOrCreateLink(
                            IN     LPSTR szRouteAddress,
                            IN     DWORD cbRouteAddress,
                            IN     DWORD dwScheduleID,
                            IN     LPSTR szConnectorName,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     BOOL fCreateIfNotExist,
                            IN     DWORD linkFlags,
                            OUT    CLinkMsgQueue **pplmq,
                            OUT    BOOL *pfRemoveOwnedSchedule)
{
    TraceFunctEnter("CDomainMappingTable::HrGetOrCreateLink");
    HRESULT hr = S_OK;
    BOOL  fValidSMTP = FALSE;
    LPSTR szRouteAddressType = NULL;
    LPSTR szRouteAddressClass = NULL;
    DWORD dwNextHopType = 0;
    CLinkMsgQueue *plmq = NULL;
    CLinkMsgQueue *plmqTmp = NULL;
    LPSTR szOwnedDomain = NULL; // string buffer that is "owned" by an entry
    CDomainEntry *pdentryLink = NULL; //entry for link
    CDomainEntry *pdentryTmp = NULL;
    DOMAIN_STRING strNextHop;
    CAQScheduleID aqsched;
    IMessageRouterLinkStateNotification *pILinkStateNotify = NULL;
    CAQStats aqstats;
    *pfRemoveOwnedSchedule = TRUE;

    _ASSERT(szRouteAddress);
    _ASSERT(pplmq);

    //First see if there is an entry for this link
    hr = HrPrvGetDomainEntry(cbRouteAddress, szRouteAddress, FALSE, &pdentryLink);
    if (AQUEUE_E_INVALID_DOMAIN == hr && fCreateIfNotExist)
    {
        _ASSERT(pIMessageRouter);
        hr = pIMessageRouter->QueryInterface(IID_IMessageRouterLinkStateNotification,
                                (VOID **) &pILinkStateNotify);
        if (FAILED(hr)) {
            pILinkStateNotify = NULL;
            goto Exit;
        }

        //an entry for this link does not exist... add one for this link
        hr = S_OK;
        DebugTrace((LPARAM) this, "DEBUG: Routing case 3 - next hop entry does not exist");

        szOwnedDomain = (LPSTR) pvMalloc(sizeof(CHAR)*(cbRouteAddress+1));
        if (!szOwnedDomain)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        lstrcpy(szOwnedDomain, szRouteAddress);

        pdentryLink = new CDomainEntry(m_paqinst);
        if (!pdentryLink)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                 pILinkStateNotify);
        if (!plmq)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        *pfRemoveOwnedSchedule = FALSE;

        //passes ownership of szOwnedDomain
        hr = pdentryLink->HrInitialize(cbRouteAddress, szOwnedDomain,
                                    pdentryLink, NULL, plmq);
        if (FAILED(hr))
            goto Exit;

        hr = plmq->HrInitialize(m_paqinst, pdentryLink, cbRouteAddress,
                szOwnedDomain, (LinkFlags) linkFlags, szConnectorName);
        if (FAILED(hr))
            goto Exit;

        //insert entry in DMT
        strNextHop.Length = (USHORT) cbRouteAddress;
        strNextHop.Buffer = szOwnedDomain;
        strNextHop.MaximumLength = (USHORT) cbRouteAddress;

        m_slPrivateData.ExclusiveLock();

        hr = HrPrvInsertDomainEntry(&strNextHop, pdentryLink, FALSE, &pdentryTmp);

        if (hr == DOMHASH_E_DOMAIN_EXISTS)
        {
            DebugTrace((LPARAM) this, "DEBUG: Routing case 4 - next hop entry did not exist... inserted by other thread");
            plmq->Release();
            plmq = NULL;
            pdentryTmp->AddRef();
            pdentryLink->HrDeinitialize();
            pdentryLink->Release();
            pdentryLink = pdentryTmp;
            hr = S_OK;

            //Will fall through to case as if an entry was found by HrGetDomainEntry
        }
        else if (SUCCEEDED(hr))
        {
            pdentryLink->AddRef();
        }

        m_slPrivateData.ExclusiveUnlock();

        if (FAILED(hr))
            goto Exit;

    }
    else if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "ERROR: General DMT failure - hr 0x%08X", hr);
        //general failure... bail
        goto Exit;
    }

    if (!plmq) {
        _ASSERT(pdentryLink);
        DebugTrace((LPARAM) this, "DEBUG: Routing case 5 - next hop entry exists");
        //An entry exists for this next hop... use link if possible
        // 1 - Get link for this schedule ID.. if it exists use it
        // 2 - Create another link and attempt to insert it
        _ASSERT(pdentryLink);
        aqsched.Init(pIMessageRouter, dwScheduleID);

        hr = pdentryLink->HrGetLinkMsgQueue(&aqsched, &plmq);
        if (FAILED(hr) && fCreateIfNotExist)
        {
            hr = S_OK;
            //link does not exist for this schedule id yet
            DebugTrace((LPARAM) this, "DEBUG: Routing case 6 - next hop link does not exist");

            szOwnedDomain = pdentryLink->szGetDomainName();

            if (!pILinkStateNotify) {
                _ASSERT(pIMessageRouter);
                hr = pIMessageRouter->QueryInterface(IID_IMessageRouterLinkStateNotification,
                                        (VOID **) &pILinkStateNotify);
                if (FAILED(hr)) {
                    pILinkStateNotify = NULL;
                    goto Exit;
                }
            }

            plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                     pILinkStateNotify);
            if (!plmq)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            *pfRemoveOwnedSchedule = FALSE;

            hr = plmq->HrInitialize(m_paqinst, pdentryLink, cbRouteAddress,
                    szOwnedDomain, (LinkFlags) linkFlags, szConnectorName);
            if (FAILED(hr))
                goto Exit;

            hr = pdentryLink->HrAddUniqueLinkMsgQueue(plmq, &plmqTmp);
            if (FAILED(hr))
            {
                //Another link was inserted since we called get link msg queue
                DebugTrace((LPARAM) this, "DEBUG: Routing case 7 - next hop link created by other thread");
                _ASSERT(plmqTmp);
                plmq->Release();
                plmq = plmqTmp;
                hr = S_OK;
            }
        } else {
            DebugTrace((LPARAM) this, "DEBUG: Routing case 8 - next hop link exists");
        }

    }

    _ASSERT(plmq && "We should have allocated a link by this point");

    if (plmq) {

        //We count a SetLinkState as a link state notification.... do not
        //notify again before attempting a connection or we will break link
        //state notifications.
        plmq->dwModifyLinkState(LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION,
                                LINK_STATE_NO_ACTION);
        aqstats.m_dwNotifyType = NotifyTypeNewLink | NotifyTypeLinkMsgQueue;
        aqstats.m_plmq = plmq;
        hr = m_paqinst->HrNotify(&aqstats, TRUE);
    }

    if (SUCCEEDED(hr)) *pplmq = plmq;

  Exit:

    if (pdentryLink)
        pdentryLink->Release();

    if (pILinkStateNotify)
        pILinkStateNotify->Release();

    if (FAILED(hr) && plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::AddDMQToEmptyList ]--------------------------------
//
//
//  Description:
//      Used by DMQ to add itself to the list of empty queues.  This function
//      will aquire (and release) the appropriate locks
//  Parameters:
//      IN  pdmq        DestMsgQueue to add to list
//  Returns:
//      -
//  History:
//      9/12/98 - MikeSwa Created
//      5/5/99  - MikeSwa Changed to TryExclusiveLock to avoid potential
//                deadlock.
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::AddDMQToEmptyList(CDestMsgQueue *pdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::AddDMQToEmptyList");
    if (m_slPrivateData.TryExclusiveLock())
    {
        pdmq->InsertQueueInEmptyQueueList(&m_liEmptyDMQHead);
        m_slPrivateData.ExclusiveUnlock();
    }
    else
    {
        DebugTrace((LPARAM) this,
            "AddDMQToEmptyList could not get m_slPrivateData Lock");
    }
    TraceFunctLeave();
}

//---[ CDomainMappingTable::fNeedToWalkEmptyQueueList ]------------------------
//
//
//  Description:
//      Checks list of Empty queues to see if we need to call
//      fDeleteExpiredQueues().  The caller of this function *must* have
//      m_slPrivateData is shared mode, if it returns TRUE, the caller *must*
//      release the lock and call fDeleteExpiredQueues() (which will aquire
//      the lock Exclusively)
//  Parameters:
//      -
//  Returns:
//      TRUE if fDeleteExpiredQueues should be called.
//  History:
//      9/12/98 - MikeSwa Created
//      6/27/2000 - MikeSwa fixed short-circuit logic
//
//-----------------------------------------------------------------------------
BOOL CDomainMappingTable::fNeedToWalkEmptyQueueList()
{
    BOOL    fRet = FALSE;
    PLIST_ENTRY pli = m_liEmptyDMQHead.Flink;
    CDestMsgQueue *pdmq = NULL;
    DWORD   dwDMQState = 0;
    DWORD   cMisplacedQueues = 0; //# of queues in list that should not be

    _ASSERT(pli);

    // Only one thread at a time should be searching.
    if (1 != InterlockedIncrement((PLONG) &m_cThreadsForEmptyDMQList))
    {
        InterlockedDecrement((PLONG) &m_cThreadsForEmptyDMQList);
        return FALSE;
    }

    if(m_dwFlags & DMT_FLAGS_RESET_ROUTES_IN_PROGRESS)
        return fRet;  // we shouldn't remove queues during reset routes

    while (&m_liEmptyDMQHead != pli)
    {
        pdmq = CDestMsgQueue::pdmqGetDMQFromEmptyListEntry(pli);
        _ASSERT(pdmq);
        dwDMQState = pdmq->dwGetDMQState();

        //See if it is empty and expired.. if so, we have a winner
        if (dwDMQState & CDestMsgQueue::DMQ_EMPTY)
        {
            if (dwDMQState & CDestMsgQueue::DMQ_EXPIRED)
            {
               fRet = TRUE;
               break;
            }
        }
        else
        {
            //
            //  The queue is no longer empty... we will remove it
            //  from this list the next time we have the exclusive
            //  lock.
            //
            cMisplacedQueues++;

            //
            //  If there are a large number of non-empty DMQs, we
            //  want wish to return TRUE even though there are no DMQs to
            //  delete... just so we can clean the list of non-empty DMQs.
            //
            if (MAX_MISPLACED_QUEUES_IN_EMPTY_LIST < cMisplacedQueues)
            {
                fRet = TRUE;
                break;
            }
        }
        pli = pli->Flink;

    }

    // If we decide to delete queues we keep this count until we have done
    // the work, if we decide not to then we release the count so someone
    // else will walk the list again
    if(fRet == FALSE)
    {
        InterlockedDecrement((PLONG) &m_cThreadsForEmptyDMQList);
    }

    //NOTE: The reason there may be non-empty queues in this list, is that
    //we cannot remove the queues from the list when we ENQUEUE a message
    //because it would deadlock (we already have the m_slPrivateData lock
    //in shared mode), and removing the queue requires this lock in exclusive
    //mode.
    return fRet;
}

//---[ CDomainMappingTable::fDeleteExpiredQueues ]-----------------------------
//
//
//  Description:
//      Removes DMQs from empty list. DMQs will be deleted if they have expired
//      and do not have any messages on them.  Non-empty DMQs will be removed
//      from the list as well.
//
//      The DMT m_slPrivateData lock should *not* be held when this is called.
//      This function will aquire it exclusively.
//
//  Parameters:
//      -
//  Returns:
//      TRUE if any queues, links, or entries were deleted
//      FALSE if no queues were deleted
//  History:
//      9/12/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CDomainMappingTable::fDeleteExpiredQueues()
{
    PLIST_ENTRY     pli = NULL;
    CDestMsgQueue  *pdmq = NULL;
    CLinkMsgQueue  *plmq = NULL;
    DWORD           dwDMQState = 0;
    CDomainMapping *pdmap = NULL;
    CDomainEntry   *pdentry = NULL;
    CDomainEntry   *pdentryOld = NULL;
    BOOL            fRemovedQueues = FALSE;
    HRESULT         hr = S_OK;
    DOMAIN_STRING   strDomain;

    // Don't attempt this if it would require waiting for a lock.  This
    // decreases contention and also prevents multiple threads from trying
    // to do this work
    if (!m_slPrivateData.TryExclusiveLock())
        goto Exit;

    pli = m_liEmptyDMQHead.Flink;
    while (&m_liEmptyDMQHead != pli)
    {
        _ASSERT(pli);
        pdmq = CDestMsgQueue::pdmqGetDMQFromEmptyListEntry(pli);
        _ASSERT(pdmq);
        dwDMQState = pdmq->dwGetDMQState();

        if (!(dwDMQState & CDestMsgQueue::DMQ_EMPTY))
        {
            //If it is not empty - remove it from the list
            pli = pli->Flink;
            pdmq->RemoveQueueFromEmptyQueueList();
            continue;
        }
        else if (!(dwDMQState & CDestMsgQueue::DMQ_EXPIRED))
        {
            //If this queue hasn't expired... check the next to see if it is empty
            pli = pli->Flink;
            continue;
        }
        else
        {
            //We need to delete this DMQ
            pli = pli->Flink;  //get next LIST_ENTRY before we delete the queue

            //Add a reference to the DMQ, so we can guarantee its lifespan
            pdmq->AddRef();

            //Remove the queue from the list of empty queues
            pdmq->RemoveQueueFromEmptyQueueList();

            //Get the domain mapping (and domain entry) for this DMQ
            pdmq->GetDomainMapping(&pdmap);
            _ASSERT(pdmap);
            pdentry = pdmap->pdentryGetQueueEntry();

            //Remove the DMQ from its associated link
            plmq = pdmq->plmqGetLink();
            pdmq->RemoveDMQFromLink(TRUE);
            if (plmq)
            {
                //Remove the link from the DMT if it is empty
                plmq->RemoveLinkIfEmpty();
                plmq->Release();
                plmq = NULL;
            }

            //Now that we have the domain entry, we can remove it the DMQ
            //from it.
            _ASSERT(pdentry);
            pdentry->RemoveDestMsgQueue(pdmq);

            //Remove Entry if needed
            if (pdentry->fSafeToRemove())
            {
                //There are no links or queues left on this entry... we
                //can remove it from the hash table and delete it
                pdentry->InitDomainString(&strDomain);
                hr = m_dnt.HrRemoveDomainName(&strDomain, (void **) &pdentryOld);

                _ASSERT(DOMHASH_E_NO_SUCH_DOMAIN != hr);
                if (SUCCEEDED(hr))
                {
                    _ASSERT(pdentryOld == pdentry);
                    pdentryOld = NULL;
                    pdentry->Release();
                    pdentry = NULL;
                }
            }

            //If there are no enqueues pending, this will be the last reference
            //for the DMQ.  If there is a enqueue pending, then there may be
            //references outstanding that will be released when they see the
            //updated DMT version number.
            pdmq->Release();

            fRemovedQueues = TRUE;
        }
    }

    //Update version number, so other threads will know that queues
    //have been removed from the DMT.
    if (fRemovedQueues)
        m_dwInternalVersion++;

    m_slPrivateData.ExclusiveUnlock();

Exit:
    // Release our count so someone else can search the list and possibly
    // remove queues ...
    InterlockedDecrement((PLONG) &m_cThreadsForEmptyDMQList);
    return fRemovedQueues;
}


//---[ CDomainMappingTable::RequestResetRoutesRetryIfNecessary ]---------------
//
//
//  Description:
//      This is called when routing fails and we need to call reset routes
//      at a later time to try it.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      11/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::RequestResetRoutesRetryIfNecessary()
{
    HRESULT hr = S_OK;

    dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_GET_NEXT_HOP_FAILED);

    if (DMT_FLAGS_RESET_ROUTES_IN_PROGRESS & m_dwFlags)
        return;

    //We need to reqest a callback for a later reset routes. We should
    //only allow one callback pending at a time.  If this thread increments
    //the count for a 0->1 transition, then we can request the callback
    if (1 == InterlockedIncrement((PLONG) &m_cResetRoutesRetriesPending))
    {
        hr = m_paqinst->SetCallbackTime(
                    CDomainMappingTable::RetryResetRoutes,
                    this, g_cResetRoutesRetryMinutes);

        if (FAILED(hr))
            InterlockedDecrement((PLONG) &m_cResetRoutesRetriesPending);
    }
}

//---[ CDomainMappingTable::RetryResetRoutes ]--------------------------------
//
//
//  Description:
//      Handles callback for reset routes.  This codepath will be used if
//      GetNextHop failes.  Routing has no internal logic to remember if
//      a failure has happened... and no method of sceduling a callback.  By
//      periodically call reset routes, we can centrally solve this problem
//      for all routing sinks.
//  Parameters:
//      pvThis      "this" pointer for CDomainMappingTable
//  Returns:
//      -
//  History:
//      11/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::RetryResetRoutes(PVOID pvThis)
{
    _ASSERT(pvThis);
    CDomainMappingTable *pdmt = (CDomainMappingTable *)pvThis;
    CAQSvrInst *paqinst = pdmt->m_paqinst;

    //Make sure shutdown has not been started.  This instance is waits for
    //all threads before deleting itself, so it is safe to call in to the local
    //variable
    if (!paqinst)
        return;

    //Decrement the count, so another request can be queued up.
    InterlockedDecrement((PLONG) &(pdmt->m_cResetRoutesRetriesPending));

    //Kick off another reset routes
    paqinst->ResetRoutes(RESET_NEXT_HOPS);
}

//---[ CDomainMappingTable::HrBeginRerouteDomains ]----------------------------
//
//
//  Description:
//      Begins the process of handing a ResetRoutes.  This function sets
//      DMT_FLAGS_RESET_ROUTES_IN_PROGRESS and then moves all queues into
//      the CurrentlyUnreachable link so that they will not be processed
//      until they have been re-routed.
//  Parameters:
//      NONE
//  Returns:
//      S_OK on success
//  History:
//      11/5/1998 - MikeSwa Created
//      10/31/2000 - dbraun - renamed / was part of HrRerouteDomains
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrBeginRerouteDomains()
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;

    m_slPrivateData.ExclusiveLock();

    //Clear the failed bit before we make any calls into routing.  This way
    //we can detect a failure that has happened during this reset routes
    dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_GET_NEXT_HOP_FAILED);

    //Make sure this flag is set.  This will prevent a reset routes request
    //from being generated while this thread is resetting routes.  If
    //GetNextHop is still failing, we want to start the retry timer
    //*after* we finish we reset routes, or we will get stuck in a loop
    //of constant reset routes until GetNextHop succeeds.
    dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_RESET_ROUTES_IN_PROGRESS);

    //Move all of the domains to the currently unreachable link
    hr = m_dnt.HrIterateOverSubDomains(NULL,
            CDomainMappingTable::MakeSingleDomainCurrentlyUnreachable, this);
    m_slPrivateData.ExclusiveUnlock();

    //Handle a failure to move the domains - if this function fails then
    //the caller won't call HrCompleteRerouteDomains so we need to clear
    //the reset routes in progress bit and potentially request another
    //ResetRoutes
    if(FAILED(hr)) {
        dwFlags = dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_RESET_ROUTES_IN_PROGRESS);

        if (DMT_FLAGS_GET_NEXT_HOP_FAILED & dwFlags) {
            //This reset routes failed... we must try again later.
            RequestResetRoutesRetryIfNecessary();
        }
    }

    return hr;
}

//---[ CDomainMappingTable::HrCompleteRerouteDomains ]-------------------------
//
//
//  Description:
//      This function completes the handling of a ResetRoutes.  Mail flow has
//      been restarted and this function will go through all the domains, now
//      sitting in CurrentlyUnreachable, and will re-route them according to
//      the new routing configuration.
//  Parameters:
//      NONE
//  Returns:
//      S_OK on success
//  History:
//      11/5/1998 - MikeSwa Created
//      10/31/2000 - dbraun - renamed / was part of HrRerouteDomains
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrCompleteRerouteDomains()
{
    HRESULT         hr      = S_OK;
    DWORD           dwFlags = 0;

/*      -- this would only be applicable if we supported a "partial retry
            reset routes" that only called this function not the Begin above

    // It is possible that we are being called WITHOUT HrBeginRerouteDomains
    // being called first (if we failed here before the retry will only retry
    // this part of rerouting) ... we need to make sure that
    // DMT_FLAGS_RESET_ROUTES_IN_PROGRESS is set to ensure this proceeds safely
    // and we need to make sure that DMT_FLAGS_GET_NEXT_HOP_FAILED is not set
    // so we can pick up a failure during rerouting
    dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_RESET_ROUTES_IN_PROGRESS);
    dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_GET_NEXT_HOP_FAILED);
*/

    // Rebuild routing information queues in the CurrentlyUnreachable link.
    hr = HrRerouteLink(m_plmqCurrentlyUnreachable);

    dwFlags = dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_RESET_ROUTES_IN_PROGRESS);

    if (DMT_FLAGS_GET_NEXT_HOP_FAILED & dwFlags)
    {
        // This reset routes failed... we must try again later.
        RequestResetRoutesRetryIfNecessary();
    }

    return hr;
}

//---[ CDomainMappingTable::MakeSingleDomainCurrentlyUnreachable ]-------------
//
//
//  Description:
//      This iterator moves a given domain's queues to the CurrentlyUnreachable
//      link to prevent SMTP from operating on them until they can be re-routed.
//  Parameters:
//          IN  pvContext   - pointer to context
//                           (pointer to BOOL that tells if we force a re-route)
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      10/31/2000 - dbraun - created
//
//-----------------------------------------------------------------------------
VOID CDomainMappingTable::MakeSingleDomainCurrentlyUnreachable(
                                PVOID pvContext, PVOID pvData,
                                BOOL fWildcard, BOOL *pfContinue,
                                BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pvContext, "CDomainMappingTable::MakeSingleDomainCurrentlyUnreachable");

    CDomainEntry               *pdentry = (CDomainEntry *) pvData;
    HRESULT                     hr      = S_OK;
    CDestMsgQueue              *pdmq    = NULL;
    CDomainMappingTable        *pThis   = (CDomainMappingTable *) pvContext;
    CDomainEntryQueueIterator   deqit;
    CAQStats                    aqstat;

    _ASSERT(pfContinue);
    _ASSERT(pfDelete);

    *pfDelete   = FALSE;
    *pfContinue = TRUE;

    if (fWildcard)
        return; //we shouldn't care about wildcard entries

    _ASSERT(pdentry);

    //
    // Initialize the aqstat to type reroute
    //
    aqstat.m_dwNotifyType = NotifyTypeReroute;

    //Loop through dmq's and blow away their routing information -
    //then route them to the currently unreachable link
    hr = deqit.HrInitialize(pdentry);
    if (FAILED(hr))
        pdmq = NULL;
    else
        pdmq = deqit.pdmqGetNextDestMsgQueue(pdmq);
    while (pdmq)
    {
        //Remove this queue from it's link
        pdmq->RemoveDMQFromLink(TRUE);

        //
        //  Figure out if it is useful to route this queue
        //  before we call into routing
        //
        if (pdmq->fIsEmptyAndAbandoned())
            pdentry->RemoveDestMsgQueue(pdmq);
        else
        {
            //Add this queue to the currently unreachable link
            hr = pThis->m_plmqCurrentlyUnreachable->HrAddQueue(pdmq);
            if (FAILED(hr)) {
                //We failed to add the queue to the currently unreachable link
                ErrorTrace((LPARAM) pvContext,
                    "HrAddQueue failed on reroute hr - 0x%08X", hr);
                hr = S_OK;
            }
            pdmq->SetRouteInfo(pThis->m_plmqCurrentlyUnreachable);

            //
            // Make sure the link is associated with the connection manager
            //
            hr = pThis->m_plmqCurrentlyUnreachable->HrNotify(&aqstat, TRUE);
            if (FAILED(hr)) {
                //If this fails... we *may* leak an unused link until the
                //next reset routes (or shutdown).
                ErrorTrace((LPARAM) pvContext,
                    "HrNotify failed on reroute hr - 0x%08X", hr);
                hr = S_OK;
            }
        }

        //On to the next queue for this entry
        pdmq = deqit.pdmqGetNextDestMsgQueue(pdmq);
    }

    //
    //  If it is safe to clean this up... then do so
    //
    if (pdentry->fSafeToRemove())
    {
        *pfDelete = TRUE;
        pdentry->Release();
        pdentry = NULL;
    }

    TraceFunctLeave();
}

//---[ CDomainMappingTable::HrRerouteLink ]------------------------------------
//
//
//  Description:
//      Function that is used to re-route all queues on a given link.
//  Parameters:
//          IN  plmq   - pointer link to be rerouted
//  Returns:
//      -
//  History:
//      11/8/2000 - dbraun created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrRerouteLink(CLinkMsgQueue *plmqReroute)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrRerouteLink");
    CDomainEntry           *pdentry         = NULL;
    CDestMsgQueue          *pdmq            = NULL;
    CLinkMsgQueue          *plmq            = NULL;
    CInternalDomainInfo    *pIntDomainInfo  = NULL;
    HRESULT                 hr              = S_OK;
    HRESULT                 hrRoutingDiag   = S_OK;
    CQuickList             *pqlQueueList    = NULL;
    DWORD                   cQueues         = 0;
    DWORD                   dwIndex         = 0;
    PVOID                   pvContext       = NULL;
    CDomainMapping         *pdmap           = NULL;
    CAQStats                aqstat;

    _ASSERT(plmqReroute);

    // Initialize the aqstat to type reroute
    aqstat.m_dwNotifyType = NotifyTypeReroute;

    // Loop through dmq's and re-route them
    hr = plmqReroute->HrGetQueueListSnapshot(&pqlQueueList);
    if (FAILED(hr))
    {
        cQueues = 0;
    }
    else
    {
        cQueues = pqlQueueList->dwGetCount();
    }

    for (dwIndex = 0; dwIndex < cQueues; dwIndex++)
    {
        // Get the dest msg queue
        pdmq = (CDestMsgQueue *) pqlQueueList->pvGetItem(dwIndex, &pvContext);

        // Get the domain for this queue
        pdmq->GetDomainMapping(&pdmap);
        _ASSERT(pdmap);
        pdentry = pdmap->pdentryGetQueueEntry();

        // Get the internal domain info for this domain
        hr = m_paqinst->HrGetInternalDomainInfo(
                        pdentry->cbGetDomainNameLength(),
                        pdentry->szGetDomainName(),
                        &pIntDomainInfo);

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to get config for domain - hr 0x%08X", hr);
            pIntDomainInfo = NULL;
        }

        if (pIntDomainInfo)
        {
            hr = HrGetNextHopLink(
                    pdentry, pdentry->szGetDomainName(),
                    pdentry->cbGetDomainNameLength(), pIntDomainInfo,
                    pdmq->paqmtGetMessageType(), pdmq->pIMessageRouterGetRouter(),
                    FALSE, // DMT is not locked
                    &plmq, &hrRoutingDiag);

            if (FAILED(hr))
            {
                //$$TODO - Deal with more exotic Get next hop errors
                ErrorTrace((LPARAM) this,
                    "ERROR: Unable to get next hop for domain - hr 0x%08X", hr);
            }

            // Update with new routing info if we can
            if (SUCCEEDED(hr))
            {
                // Remove from the old link
                pdmq->RemoveDMQFromLink(TRUE);

                // Add to the new one
                hr = plmq->HrAddQueue(pdmq);
                if (FAILED(hr))
                {
                    // Release the link we couldn't use and get the
                    // currently unreachable link
                    plmq->Release();
                    plmq = plmqGetCurrentlyUnreachable();
                    if (plmq)
                        hr = plmq->HrAddQueue(pdmq);

                    // If we still have a failed hr, remove the DMQ from
                    // it's link, otherwise, make sure it is associated with
                    // the link we just added it to
                    if (FAILED(hr))
                        pdmq->RemoveDMQFromLink(TRUE);
                    else
                        pdmq->SetRouteInfo(plmq);

                    // Request reset routes retry
                    RequestResetRoutesRetryIfNecessary();
                }
                else
                    pdmq->SetRouteInfo(plmq);

                // Set routing error if there was one.
                pdmq->SetRoutingDiagnostic(hrRoutingDiag);

                //
                // Make sure the link is associated with the connection manager
                //
                hr = plmq->HrNotify(&aqstat, TRUE);
                if (FAILED(hr))
                {
                    // If this fails... we *may* leak an unused link until the
                    // next reset routes (or shutdown).
                    ErrorTrace((LPARAM) this,
                        "HrNotify failed on reroute hr - 0x%08X", hr);
                    hr = S_OK;
                }
                plmq->Release();
                plmq = NULL;
            }

            // Release the domain info
            pIntDomainInfo->Release();
            pIntDomainInfo = NULL;
        }
    }

    _ASSERT(!pIntDomainInfo);

    if (pqlQueueList)
        delete pqlQueueList;

    TraceFunctLeave();

    return hr;
}

//---[ CDomainMappingTable::ProcessSpecialLinks ]------------------------------
//
//
//  Description:
//      Processes all the special global links to handle things like local
//      delivery.
//  Parameters:
//      IN      cSpecialRetryMinutes minutes to retry currently unreachable
//              if 0, will use previous value
//      IN      fRoutingLockHeld
//  Returns:
//      -
//  History:
//      1/26/99 - MikeSwa Created
//      3/25/99 - MikeSwa Added fRoutingLockHeld to fix GetNextMsgRef deadlock
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::ProcessSpecialLinks(DWORD  cSpecialRetryMinutes,
                                              BOOL fRoutingLockHeld)
{
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;
    CAQSvrInst *paqinst = m_paqinst;
    BOOL    fSchedRetry = FALSE;
    BOOL    fShutdownLock = FALSE;

    //If this thread has the routing lock... we are safe from shutdown
    _ASSERT(m_paqinst || !fRoutingLockHeld);
    if (!paqinst)
        return;  //we must be shutting down

    if (!fRoutingLockHeld)
    {
        //It is safe to access paqinst to acquire the shutdown lock because
        //all threads that can call this function will be gone before the
        //reference count on the server instance is 0 (however, this call
        //could happen during deinialization which would cause m_aqinst
        //to be NULL and the following call to return FALSE).
        if (!paqinst->fTryShutdownLock())
            return; //we are shutting down

        //Now we have the shutdown lock... m_aqinst must be safe
        _ASSERT(m_paqinst);
        if (!m_paqinst)
        {
            //might as well be defensive in retail about this.
            paqinst->ShutdownUnlock();
            return;
        }
        fShutdownLock = TRUE;
    }

    if (!(DMT_FLAGS_SPECIAL_DELIVERY_SPINLOCK &
          dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_SPINLOCK)))
    {
        //we have the lock... only 1 thread at a time should do this

        //Loop over queue and enqueue for local delivery
        while (SUCCEEDED(hr) && m_plmqLocal)
        {
            hr = m_plmqLocal->HrGetNextMsgRef(fRoutingLockHeld, &pmsgref);
            if (FAILED(hr))
                break;

            _ASSERT(pmsgref);
            m_paqinst->QueueMsgForLocalDelivery(pmsgref, TRUE);
            pmsgref->Release();
            pmsgref = NULL;
        }

        //Tell link to walk queues so they will be added to the empty list
        //for deletion
        if (m_plmqLocal)
        {
            m_plmqLocal->GenerateDSNsIfNecessary(TRUE /*check if empty */,
                                                 TRUE /*merge retry queue only*/);
        }

        //NDR all messages in the unreachable link
        if (m_plmqUnreachable)
        {
            //We must hold the routing lock for DSN generation
            if (!fRoutingLockHeld)
                m_paqinst->RoutingShareLock();

            m_plmqUnreachable->SetLastConnectionFailure(AQUEUE_E_NDR_ALL);
            m_plmqUnreachable->GenerateDSNsIfNecessary(FALSE, FALSE);

            if (!fRoutingLockHeld)
                m_paqinst->RoutingShareUnlock();

        }

        //Process the currently unreachable link ... unless we are currently
        //doing a ResetRoutes.  If we are we must skip this because the
        //currently unreachable link contains queues we should not process
        //here - this function will be called again when ResetRoutes completes
        if (m_plmqCurrentlyUnreachable &&
            !(m_dwFlags & DMT_FLAGS_RESET_ROUTES_IN_PROGRESS))
        {
            if (cSpecialRetryMinutes)
            {
                //new time is sooner... we better ask for a retry
                if (cSpecialRetryMinutes < m_cSpecialRetryMinutes)
                    fSchedRetry = TRUE;

                InterlockedExchange((PLONG)&m_cSpecialRetryMinutes,
                                    cSpecialRetryMinutes);
            }

            if (!(DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK &
                  dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK)))
            {
                //We are the only thread doing this

                //We must hold the routing lock for DSN generation
                if (!fRoutingLockHeld)
                    m_paqinst->RoutingShareLock();

                m_plmqCurrentlyUnreachable->GenerateDSNsIfNecessary(FALSE, FALSE);
                dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK);
                fSchedRetry = TRUE;

                if (!fRoutingLockHeld)
                    m_paqinst->RoutingShareUnlock();
            }

            //periodically check the currently unreachable link... to genrate NDRs
            if (fSchedRetry)
            {
                dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK);
                if (m_paqinst)
                {
                    hr = m_paqinst->SetCallbackTime(
                                  CDomainMappingTable::SpecialRetryCallback, this,
                                  m_cSpecialRetryMinutes);
                    if (FAILED(hr))
                    {
                        //Unmark bits to we try next time
                        dwInterlockedUnsetBits(&m_dwFlags,
                            DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK);
                        hr = S_OK;
                    }
                }
            }
        }

        //Release the lock
        dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_SPINLOCK);
    }

    if (fShutdownLock)
    {
        _ASSERT(m_paqinst);
        m_paqinst->ShutdownUnlock();
    }
}


//---[ CDomainMappingTable::HrPrepareForLocalDelivery ]------------------------
//
//
//  Description:
//      Prepares a message for local delivery using the m_plmqLocal Link.
//  Parameters:
//      IN      pmsgref     MsgRef to prepare for delivery
//      IN      fLocal      Prepare delivery for all domains with NULL queues
//      IN      fDelayDSN   Check/Set Delay bitmap (only send 1 Delay DSN).
//      IN      pqlstQueues QuickList of DMQ's
//      IN OUT  pdcntxt     context that must be returned on Ack
//      OUT     pcRecips    # of recips to deliver for
//      OUT     prgdwRecips Array of recipient indexes
//  Returns:
//      S_OK on success
//      E_FAIL if m_plmqLocal is not initialized
//  History:
//      1/26/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrPrepareForLocalDelivery(
                                    IN CMsgRef *pmsgref,
                                    IN BOOL fDelayDSN,
                                    IN OUT CDeliveryContext *pdcntxt,
                                    OUT DWORD *pcRecips,
                                    OUT DWORD **prgdwRecips)
{
    if (m_plmqLocal)
    {
        return m_plmqLocal->HrPrepareDelivery(pmsgref, TRUE, fDelayDSN,
                                pdcntxt, pcRecips, prgdwRecips);
    }
    else
        return E_FAIL;
}

DWORD CDomainMappingTable::GetCurrentlyUnreachableTotalMsgCount() {
        return m_plmqCurrentlyUnreachable->cGetTotalMsgCount();
}

//---[ CDomainMappingTable::plmqGetLocalLink ]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the local link object
//  Parameters:
//      -
//  Returns:
//      AddRef'd pointer to the local link object
//  History:
//      2/22/99 - MikeSwa Created
//      1/28/2000 - MikeSwa Modified to make shutdown safe
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CDomainMappingTable::plmqGetLocalLink()
{
    CAQSvrInst *paqinst = m_paqinst;
    CLinkMsgQueue *plmq = NULL;

    //
    //  If paqinst is non-NULL, then we have the possibility of not being
    //  shutdown.  If we are shutdown, it is possible that m_plmqLocal is
    //  in the process of being released (which would be a really bad
    //  time to addref/release it).  We can safely access paqinst, since
    //  this class is a member of CAQSvrInst.
    //
    if (paqinst && paqinst->fTryShutdownLock())
    {
        plmq = m_plmqLocal;
        if (plmq)
            plmq->AddRef();
        paqinst->ShutdownUnlock();
    }

    return plmq;
}

//---[ CDomainMappingTable::plmqGetCurrentlyUnreachable]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the currently unreachable link object
//  Parameters:
//      -
//  Returns:
//      AddRef'd pointer to the currently unreachable link object
//  History:
//      6/21/99 - GPulla Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CDomainMappingTable::plmqGetCurrentlyUnreachable()
{
    if(m_plmqCurrentlyUnreachable)
        m_plmqCurrentlyUnreachable->AddRef();

    return m_plmqCurrentlyUnreachable;
}

//---[ CDomainMappingTable::pmmaqGetPreCategorized]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the precategorized queue object
//  Parameters:
//      -
//      AddRef'd pointer to the precategorized link object.
//  History:
//      6/21/99 - GPulla Created
//
//-----------------------------------------------------------------------------
CMailMsgAdminLink *CDomainMappingTable::pmmaqGetPreCategorized()
{
    if(m_pmmaqPreCategorized)
        m_pmmaqPreCategorized->AddRef();

    return m_pmmaqPreCategorized;
}

//---[ CDomainMappingTable::pmmaqGetPreRouting]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the pre routing queue object
//  Parameters:
//      -
//      AddRef'd pointer to the precategorized link object.
//  History:
//      6/21/99 - GPulla Created
//
//-----------------------------------------------------------------------------
CMailMsgAdminLink *CDomainMappingTable::pmmaqGetPreRouting()
{
    if(m_pmmaqPreRouting)
        m_pmmaqPreRouting->AddRef();

    return m_pmmaqPreRouting;
}

//---[ CDomainMappingTable::pmmaqGetPreRouting]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the pre routing queue object
//  Parameters:
//      -
//      AddRef'd pointer to the precategorized link object.
//  History:
//      6/21/99 - GPulla Created
//
//-----------------------------------------------------------------------------
CMailMsgAdminLink *CDomainMappingTable::pmmaqGetPreSubmission()
{
    if(m_pmmaqPreSubmission)
        m_pmmaqPreSubmission->AddRef();

    return m_pmmaqPreSubmission;
}

//---[ CDomainEntryIterator::CDomainEntryIterator ]----------------------------
//
//
//  Description:
//      Constructor for CDomainEntryIterator
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDomainEntryIterator::CDomainEntryIterator()
{
    m_dwSignature = DOMAIN_ENTRY_ITERATOR_SIG;
    m_cItems = 0;
    m_iCurrentItem = 0;
    m_rgpvItems = NULL;
}

//---[ CDomainEntryIterator::Recycle ]-----------------------------------------
//
//
//  Description:
//      CDomainEntryIterator Recycle... destroys using virtual functions
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDomainEntryIterator::Recycle()
{
    DWORD   iCurrentItem = 0;

    for (iCurrentItem = 0; iCurrentItem < m_cItems; iCurrentItem++)
    {
        _ASSERT(m_rgpvItems);
        if (!m_rgpvItems)
            break;

        if (m_rgpvItems[iCurrentItem])
        {
            ReleaseItem(m_rgpvItems[iCurrentItem]);
            m_rgpvItems[iCurrentItem] = NULL;
        }
    }

    if (m_rgpvItems)
    {
        FreePv(m_rgpvItems);
        m_rgpvItems = NULL;
    }
    m_cItems = 0;
    m_iCurrentItem = 0;
}

//---[ CDomainEntryIterator::pvGetNext ]---------------------------------------
//
//
//  Description:
//      Gets the next Item
//  Parameters:
//      -
//  Returns:
//      The next item in the iterator
//      NULL if at last item
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CDomainEntryIterator::pvGetNext()
{
    PVOID   pvRet = NULL;
    if (m_rgpvItems && (m_iCurrentItem < m_cItems))
    {
        pvRet = m_rgpvItems[m_iCurrentItem];
        _ASSERT(pvRet);
        m_iCurrentItem++;
    }
    return pvRet;
}

//---[ CDomainEntryIterator::HrInitialize ]------------------------------------
//
//
//  Description:
//      Initializes a CDomainEntryIterator from a given CDomainEntry
//  Parameters:
//      pdentry     CDomainEntry to initialize from
//  Returns:
//      S_OK on success
//      E_POINTER if pdentry is NULL
//      E_INVALIDARG if HrInitialize has already be called for this iterator
//      E_OUTOFMEMORY if we cannot allocate memory for iterator
//  History:
//      8/20/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntryIterator::HrInitialize(CDomainEntry *pdentry)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntryIterator::HrInitialize");
    HRESULT hr = S_OK;
    BOOL    fEntryLocked = FALSE;
    DWORD   cAddedItems = 0;
    DWORD   cItems = 0;
    PLIST_ENTRY pli = NULL;
    PLIST_ENTRY pliHead = NULL;
    CLinkMsgQueue *plmq = NULL;

    _ASSERT(pdentry);
    _ASSERT(!m_rgpvItems && "Iterator initialized twice");

    if (!pdentry)
    {
        hr = E_POINTER;
        ErrorTrace((LPARAM) this, "NULL pdentry used to initialized iterator");
        goto Exit;
    }

    if (m_rgpvItems)
    {
        hr = E_INVALIDARG;
        ErrorTrace((LPARAM) this, "Iterator initialized twice!");
        goto Exit;
    }

    pdentry->m_slPrivateData.ShareLock();
    fEntryLocked = TRUE;

    cItems = cItemsFromDomainEntry(pdentry);
    if (!cItems) //Empty entry
        goto Exit;

    m_rgpvItems = (PVOID *) pvMalloc(sizeof(PVOID) * cItems);

    if (!m_rgpvItems)
    {
        hr = E_OUTOFMEMORY;
        ErrorTrace((LPARAM) this,
            "Unable to allocate memory for iterator of size %d", cItems);
        goto Exit;
    }

    ZeroMemory(m_rgpvItems, sizeof(PVOID)*cItems);

    pliHead = pliHeadFromDomainEntry(pdentry);
    _ASSERT(pliHead);
    pli = pliHead->Flink;

    while(pliHead != pli)
    {
        _ASSERT(pli);
        m_rgpvItems[cAddedItems] = pvItemFromListEntry(pli);
        _ASSERT(m_rgpvItems[cAddedItems]);
        if (m_rgpvItems[cAddedItems])
            cAddedItems++;

        pli = pli->Flink;
        _ASSERT(cAddedItems <= cItems); //We've run out of room
        if (cAddedItems > cItems)
            break;
    }
    _ASSERT(cAddedItems == cItems);
    m_cItems = cAddedItems;

  Exit:
    if (fEntryLocked)
        pdentry->m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntryLinkIterator ]---------------------------------------------
//
//
//  Description:
//      Releases a CLinkMsgQueue during the CDomainEntryQueueIterator
//      destructor
//  Parameters:
//      pvItem    LMQ to release
//  Returns:
//      -
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDomainEntryLinkIterator::ReleaseItem(PVOID pvItem)
{
    CLinkMsgQueue *plmq = (CLinkMsgQueue *) pvItem;
    _ASSERT(plmq);
    plmq->Release();
}

//---[ CDomainEntryLinkIterator::pvItemFromListEntry ]-------------------------
//
//
//  Description:
//      Returns a CLinkMsgQueue item from the given LIST_ENTRY
//  Parameters:
//      pli     LIST_ENTRY to get LMQ from... *must* be non-NULL
//  Returns:
//      PVOID   for Addref'd CLinkMsgQueue
//  History:
//      8/20/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CDomainEntryLinkIterator::pvItemFromListEntry(PLIST_ENTRY pli)
{
    CLinkMsgQueue *plmq = CLinkMsgQueue::plmqGetLinkMsgQueue(pli);
    _ASSERT(plmq);
    _ASSERT(pli);

    plmq->AddRef();
    return plmq;
}

//---[ CDomainEntryLinkIterator::plmqGetNextLinkMsgQueue ]---------------------
//
//
//  Description:
//      Gets the next LMQ for this iterator
//  Parameters:
//      plmq to release... addref'd by previous call
//  Returns:
//      Addref'd Next LMQ.
//      NULL if no more left
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CDomainEntryLinkIterator::plmqGetNextLinkMsgQueue(
                            CLinkMsgQueue *plmq)
{
    CLinkMsgQueue *plmqNext = (CLinkMsgQueue *) pvGetNext();

    if (plmqNext)
        plmqNext->AddRef();

    if (plmq)
        plmq->Release();

    return plmqNext;
}

//---[ CDomainEntryQueueIterator::pdmqGetNextDestMsgQueue ]--------------------
//
//
//  Description:
//      Get the next DMQ in the iterator
//  Parameters:
//      pdmq    CDestMsgQueue to release... addref'd by previous call
//  Returns:
//      Addref'd next DMQ
//      NULL if no more DMQ's for iterator
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDestMsgQueue *CDomainEntryQueueIterator::pdmqGetNextDestMsgQueue(
                            CDestMsgQueue *pdmq)
{
    CDestMsgQueue *pdmqNext = (CDestMsgQueue *) pvGetNext();

    if (pdmqNext)
    {
        pdmqNext->AssertSignature();
        pdmqNext->AddRef();
    }

    if (pdmq)
    {
        pdmq->AssertSignature();
        pdmq->Release();
    }

    return pdmqNext;
}

//---[ CDomainEntryDestIterator::pvItemFromListEntry ]-------------------------
//
//
//  Description:
//      Returns a CDestMsgQueue item from the given LIST_ENTRY
//  Parameters:
//      pli     LIST_ENTRY to get DMQ from... *must* be non-NULL
//  Returns:
//      PVOID   for Addref'd CDestMsgQueue
//  History:
//      8/20/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CDomainEntryQueueIterator::pvItemFromListEntry(PLIST_ENTRY pli)
{
    CDestMsgQueue *pdmq = CDestMsgQueue::pdmqGetDMQFromDomainListEntry(pli);
    _ASSERT(pdmq);
    _ASSERT(pli);

    pdmq->AssertSignature();
    pdmq->AddRef();
    return (PVOID) pdmq;
}

//---[ CDomainEntryQueueIterator ]---------------------------------------------
//
//
//  Description:
//      Releases a CDestMsgQueue during the CDomainEntryQueueIterator
//      destructor
//  Parameters:
//      pvItem    DMQ to release
//  Returns:
//      -
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDomainEntryQueueIterator::ReleaseItem(PVOID pvItem)
{
    CDestMsgQueue *pdmq = (CDestMsgQueue *) pvItem;
    _ASSERT(pdmq);
    pdmq->AssertSignature();
    pdmq->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\connmgr.h ===
//-----------------------------------------------------------------------------
//
//
//  File: ConnMgr.h
//
//  Description: Definition CConnMgr, class that implements IConnectionManager
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------


#ifndef __CONNMGR_H_
#define __CONNMGR_H_

#include "aqinst.h"
#include <aqueue.h>
#include "aqnotify.h"
#include <fifoq.h>
#include "shutdown.h"
#include <baseobj.h>
#include <mailmsg.h>
#include "retrsink.h"

class   CLinkMsgQueue;
class   CDomainMappingTable;
class   CSMTPConn;

typedef CFifoQueue<CLinkMsgQueue *> QueueOfLinks;

//We will only allow one @command to ETRN maximum 'X' domains
//Anything more will be denied
#define MAX_ETRNDOMAIN_PER_COMMAND  50

typedef struct etrncontext
{
    HRESULT hr;
    DWORD   cMessages;
    CAQSvrInst *paqinst;
    CInternalDomainInfo* rIDIList[MAX_ETRNDOMAIN_PER_COMMAND];
    DWORD   cIDICount;
} ETRNCTX, *PETRNCTX;

//---[ CConnMgr ]--------------------------------------------------------------
//
//
//  Hungarian: connmgr, pconnmgr
//
//
//-----------------------------------------------------------------------------
class CConnMgr :
    public IConnectionManager,
    public IConnectionRetryManager,
    public CBaseObject,
    public IAQNotify,
    protected CSyncShutdown
{
private:
    CAQSvrInst          *m_paqinst;
    QueueOfLinks        *m_pqol;
    CSMTP_RETRY_HANDLER  *m_pDefaultRetryHandler;
    HANDLE               m_hNextConnectionEvent;
    HANDLE               m_hShutdownEvent;
    HANDLE               m_hReleaseAllEvent;
    DWORD                m_cConnections;

    //config stuff
    CShareLockNH         m_slPrivateData;
    DWORD                m_dwConfigVersion; //updated every time config is updated
    DWORD                m_cMinMessagesPerConnection;  //will be per-domain
    DWORD                m_cMaxLinkConnections; //will be per-domain
    DWORD                m_cMaxMessagesPerConnection;
    DWORD                m_cMaxConnections;
    DWORD                m_cGetNextConnectionWaitTime;
    BOOL                 m_fStoppedByAdmin;

private :
    HRESULT CConnMgr::ETRNDomainList(ETRNCTX *pETRNCtx);
    HRESULT CConnMgr::StartETRNQueue(IN  DWORD   cbSMTPDomain,
                                     IN  char szSMTPDomain[],
						             ETRNCTX *pETRNCtx);

public:
    CConnMgr();
    ~CConnMgr();
    HRESULT HrInitialize(CAQSvrInst *paqinst);
    HRESULT HrDeinitialize();
    HRESULT HrNotify(IN CAQStats *paqstats, BOOL fAdd);

    //Keep track of the number of connections
    void ReleaseConnection(CSMTPConn *pSMTPConn, 
                                    BOOL *pfForceCheckForDSNGeneration);

    void LogConnectionFailedEvent(CSMTPConn *pSMTPConn,
                                  CLinkMsgQueue *plmq,
                                  LPSTR szDomain);

    //Will be used by catmsgq to update the metabase changes
    void UpdateConfigData(IN AQConfigInfo *pAQConfigInfo);

    //Used by CAQSvrInst to signal local delivery retry
    HRESULT SetCallbackTime(IN RETRFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN DWORD    dwCallbackMinutes)
    {
        HRESULT hr = S_OK;
        if (m_pDefaultRetryHandler)
        {
            hr = m_pDefaultRetryHandler->SetCallbackTime(pCallbackFn,
                                pvContext, dwCallbackMinutes);
        }
        else
        {
            hr = E_FAIL;
        }
        return hr;
    }

    //Can be used to make an otherwise idle system re-evaluate the
    //need for connections
    void KickConnections()
    {
        if (!m_fStoppedByAdmin)
            _VERIFY(SetEvent(m_hNextConnectionEvent));
    };

    void QueueAdminStopConnections() {m_fStoppedByAdmin = TRUE;};
    void QueueAdminStartConnections() {m_fStoppedByAdmin = FALSE;KickConnections();};
    BOOL fConnectionsStoppedByAdmin() {return m_fStoppedByAdmin;};

    HRESULT ModifyLinkState(
               IN  DWORD cbDomainName,
               IN  char szDomainName[],
               IN  DWORD dwScheduleID,
               IN  GUID rguidTransportSink,
               IN  DWORD dwFlagsToSet,
               IN  DWORD dwFlagsToUnset);

public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

public: // IConnectionManager - private interface with SMTP
    STDMETHOD(GetNextConnection)(OUT ISMTPConnection **ppISMTPConnection);
    STDMETHOD(GetNamedConnection)(IN  DWORD cbSMTPDomain,
                                  IN  char szSMTPDomain[],
                                  OUT ISMTPConnection **ppISMTPConnection);
    STDMETHOD(ReleaseWaitingThreads)();
    STDMETHOD(ETRNDomain)(IN  DWORD   cbSMTPDomain,
                     IN  char szSMTPDomain[],
                     OUT DWORD *pcMessages);


public: //IConnectionRetryManager - interface with routing
    STDMETHOD(RetryLink)(
               IN  DWORD cbDomainName,
               IN  char szDomainName[],
               IN  DWORD dwScheduleID,
               IN  GUID rguidTransportSink);

};

#endif //__CONNMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\dcontext.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dcontext.cpp
//
//  Description:    Implementation of delivery context class.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "dcontext.h"

CDeliveryContext::CDeliveryContext()
{
    m_dwSignature = DELIVERY_CONTEXT_FREE;
    m_pmsgref = NULL;
    m_pmbmap = NULL;
    m_cRecips = 0;
    m_rgdwRecips = NULL;
    m_pdmrq = NULL;
}

void CDeliveryContext::Recycle()
{
    if (m_pmsgref)    
        m_pmsgref->Release();
    if (m_pmbmap)     
        delete m_pmbmap;
    if (m_rgdwRecips)
        FreePv(m_rgdwRecips);
    if (m_pdmrq)
        m_pdmrq->Release();

    m_dwSignature = DELIVERY_CONTEXT_FREE;
    m_pmsgref = NULL;
    m_pmbmap = NULL;
    m_cRecips = 0;
    m_rgdwRecips = NULL;
    m_pdmrq = NULL;
}

//---[ CDeliveryContext::CDeliveryContext ]------------------------------------
//
//
//  Description: 
//      Constructor for CDeliveryContext.  Should be created by a CMsgRef on
//      Prepare delivery.
//
//      $$REVIEW:  We may wish to include the ability to define rgdwRecips
//      as a CPool buffer.  If so, we will need to add a flag telling how to
//      get rid of it.
//  Parameters:
//      pmsgref     MsgRef that generated this context
//      pmbmap      Bitmap of domains that delivery is being attempted on
//      cRecips     Number of Recipients we are attempting delivery to
//      rgdwRecips  Array of recip indexes.  This allows the delivery context
//                  to handle deleting the buffer.
//      dwStartDomain The first domain in context
//      pdmrq       Retry interface for this delivery attempt
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDeliveryContext::CDeliveryContext(CMsgRef *pmsgref, CMsgBitMap *pmbmap,
                                   DWORD cRecips, DWORD *rgdwRecips, 
                                   DWORD dwStartDomain, 
                                   CDestMsgRetryQueue *pdmrq) 
{
    m_dwSignature = DELIVERY_CONTEXT_FREE;  //so init succeeds
    Init(pmsgref, pmbmap, cRecips, rgdwRecips, dwStartDomain, pdmrq);
}

void CDeliveryContext::Init(CMsgRef *pmsgref, CMsgBitMap *pmbmap,
                       DWORD cRecips, DWORD *rgdwRecips, DWORD dwStartDomain,
                       CDestMsgRetryQueue *pdmrq) 
{
    _ASSERT(pmsgref);
    _ASSERT(pmbmap);
    _ASSERT(cRecips);
    _ASSERT(rgdwRecips);
    _ASSERT(DELIVERY_CONTEXT_FREE == m_dwSignature);
    m_dwSignature = DELIVERY_CONTEXT_SIG;
    m_pmsgref = pmsgref;
    m_pmbmap = pmbmap;
    m_cRecips = cRecips;
    m_rgdwRecips = rgdwRecips;
    m_dwStartDomain = dwStartDomain;
    m_pdmrq = pdmrq;
    if (m_pdmrq)
        m_pdmrq->AddRef();
}; 

//---[ CDeliveryContext::~CDeliveryContext ]-----------------------------------
//
//
//  Description: 
//      Destructor for CDeliveryContext.  The buffer used to pass recipients to
//      the SMTP stack will be freed here.
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDeliveryContext::~CDeliveryContext()
{
    if (m_pmsgref)    
        m_pmsgref->Release();
    if (m_pmbmap)     
        delete m_pmbmap;
    if (m_rgdwRecips)
        FreePv(m_rgdwRecips);
    if (m_pdmrq)
        m_pdmrq->Release();

    m_dwSignature = DELIVERY_CONTEXT_FREE;
};

//---[  CDeliveryContext::HrAckMessage ]----------------------------------------
//
//
//  Description: 
//      Ack (non)delivery of message
//  Parameters:
//      pMsgAck     Ptr to MessageAck structure
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDeliveryContext::HrAckMessage(IN MessageAck *pMsgAck)
{
    HRESULT hr = S_OK;
    _ASSERT(m_pmsgref);
    _ASSERT(DELIVERY_CONTEXT_SIG == m_dwSignature);

    hr = m_pmsgref->HrAckMessage(this, pMsgAck);

    return hr;
}

//---[ CDeliveryContext::FVerifyHandle ]---------------------------------------
//
//
//  Description: 
//      Used to perform simple validation that the data being passed is 
//      actually a delivery context.  This should not AV if the handle is bad
//      (as long as the actual function call can be made).
//
//  Parameters:
//      -
//  Returns:
//      True is the this ptr looks like a valid CDeliveryContext.
//
//-----------------------------------------------------------------------------
CDeliveryContext::FVerifyHandle(IMailMsgProperties *pIMailMsgPropeties)
{
    _ASSERT((DELIVERY_CONTEXT_SIG == m_dwSignature) && "bogus delivery context");

    register BOOL fResult = TRUE;
    if (NULL == m_pmsgref)
        fResult = FALSE;
    else if (NULL == m_pmbmap)
        fResult = FALSE;

    if (fResult)
    {
        if (!m_pmsgref->fIsMyMailMsg(pIMailMsgPropeties))
        {
            _ASSERT(0 && "Wrong message acked on connection");
            fResult = FALSE;
        }
    }
    return fResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\defdlvrq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: defdlvrq.cpp
//
//  Description:  Implementation of CAQDeferredDeliveryQueue & 
//      CAQDeferredDeliveryQueueEntry.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/23/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "defdlvrq.h"
#include "aqutil.h"

//---[ CAQDeferredDeliveryQueueEntry::CAQDeferredDeliveryQueueEntry ]----------
//
//
//  Description: 
//      Constructor for CAQDeferredDeliveryQueueEntry class
//  Parameters:
//      IN  pIMailMsgProperties     MailMsg to queue
//      IN  pft                     FILTIME (UT) to defer deliver until
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQDeferredDeliveryQueueEntry::CAQDeferredDeliveryQueueEntry(
                                  IMailMsgProperties *pIMailMsgProperties,
                                  FILETIME *pft)
{
    _ASSERT(pIMailMsgProperties);
    _ASSERT(pft);

    m_liQueueEntry.Flink = NULL;
    m_liQueueEntry.Blink = NULL;

    memcpy(&m_ftDeferredDeilveryTime, pft, sizeof(FILETIME));

    m_pIMailMsgProperties = pIMailMsgProperties;

    if (m_pIMailMsgProperties)
    {
        m_pIMailMsgProperties->AddRef();

        //Release usage count while this message is pending delivery
        HrReleaseIMailMsgUsageCount(m_pIMailMsgProperties);

    }

    m_fCallbackSet = FALSE;
    m_dwSignature = DEFERRED_DELIVERY_QUEUE_ENTRY_SIG;
}

//---[ CAQDeferredDeliveryQueueEntry::~CAQDeferredDeliveryQueueEntry ]---------
//
//
//  Description: 
//      Descructor for CAQDeferredDeliveryQueueEntry class
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQDeferredDeliveryQueueEntry::~CAQDeferredDeliveryQueueEntry()
{
    //Release mailmsg properties
    if (m_pIMailMsgProperties)
    {
        m_pIMailMsgProperties->Release();
        m_pIMailMsgProperties = NULL;
    }

    //Remove from list (if in list)
    if (m_liQueueEntry.Flink)
    {
        _ASSERT(m_liQueueEntry.Blink);
        RemoveEntryList(&m_liQueueEntry);
    }
    MARK_SIG_AS_DELETED(m_dwSignature);
}


//---[ CAQDeferredDeliveryQueueEntry::SetCallback ]----------------------------
//
//
//  Description: 
//      Sets callback for queue.  Per Entry state is maintained so we know we 
//      have 1 and only 1 callback per head of queue.
//
//      Queue private lock should be exclusive when this is called
//  Parameters:
//      pvContext       Context for callback function
//      paqinst         Server Instance object
//  Returns:
//      TRUE if a callback is set
//  History:
//      1/13/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQDeferredDeliveryQueueEntry::fSetCallback(PVOID pvContext, 
                                                 CAQSvrInst *paqinst)
{
    if (!m_fCallbackSet && paqinst)
    {
        m_fCallbackSet = TRUE;
        paqinst->SetCallbackTime(CAQDeferredDeliveryQueue::TimerCallback,
                                 pvContext, &m_ftDeferredDeilveryTime);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//---[ CAQDeferredDeliveryQueueEntry::pmsgGetMsg ]-----------------------------
//
//
//  Description: 
//      Get AddRef'd message for this entry
//  Parameters:
//      -
//  Returns:
//      pIMailMsgProperties.
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
IMailMsgProperties *CAQDeferredDeliveryQueueEntry::pmsgGetMsg()
{
    _ASSERT(m_pIMailMsgProperties);
    IMailMsgProperties *pIMailMsgProperties = m_pIMailMsgProperties;

    if (pIMailMsgProperties)
    {
        //Add the usage count the we released earlier on
        HrIncrementIMailMsgUsageCount(m_pIMailMsgProperties);

        //Set to NULL, so caller "owns" this entry's reference count (and
        //usage count).
        m_pIMailMsgProperties = NULL;
    }

    return pIMailMsgProperties;
}


//---[ CAQDeferredDeliveryQueue::CAQDeferredDeliveryQueue ]--------------------
//
//
//  Description: 
//      Constructor for CAQDeferredDeliveryQueue class
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQDeferredDeliveryQueue::CAQDeferredDeliveryQueue()
{
    m_dwSignature = DEFERRED_DELIVERY_QUEUE_SIG;
    InitializeListHead(&m_liQueueHead);
    m_paqinst = NULL;
    m_cCallbacksPending = 0;
}

//---[ CAQDeferredDeliveryQueue::~CAQDeferredDeliveryQueue ]-------------------
//
//
//  Description: 
//      Default destructor for CAQDeferredDeliveryQueue.
//  Parameters:
//
//  Returns:
//
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQDeferredDeliveryQueue::~CAQDeferredDeliveryQueue()
{
    Deinitialize();
}

//---[ CAQDeferredDeliveryQueue::Initialize ]----------------------------------
//
//
//  Description: 
//      Initialization for CAQDeferredDeliveryQueue
//  Parameters:
//      IN  paqinst         Ptr to virtual server instance object
//  Returns:
//      -
//  History:
//      12/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::Initialize(CAQSvrInst *paqinst)
{
    _ASSERT(paqinst);
    m_paqinst = paqinst;
    m_paqinst->AddRef();
}

//---[ CAQDeferredDeliveryQueue::Deinitialize ]--------------------------------
//
//
//  Description: 
//      Performs first-pass shutdown for CAQDeferredDeliveryQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::Deinitialize()
{
    CAQDeferredDeliveryQueueEntry *pdefqe = NULL;
    LIST_ENTRY *pli = NULL;

    //$$REVIEW - It may be adventagious to remove this lock and rely on the
    //private data lock of the virtual server instance.  This will require 
    //fixing fTryRoutingLock.  Also having a single lock leads to single-thread
    //deadlock issues while we have it exclusively and call to submit.

    m_slPrivateData.ExclusiveLock();
    pli = m_liQueueHead.Flink;

    //Walk queue and delete remaining entries
    while (pli != &m_liQueueHead)
    {
        pdefqe = CAQDeferredDeliveryQueueEntry::pdefqeGetEntry(pli);

        if (m_paqinst)
            m_paqinst->ServerStopHintFunction();

        //Make sure we get the next before deleting the entry :)
        pli = pli->Flink;

        _ASSERT(pdefqe);
        delete pdefqe;
    }

    if (m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    m_slPrivateData.ExclusiveUnlock();
}

//---[ CAQDeferredDeliveryQueue::Enqueue ]-------------------------------------
//
//
//  Description: 
//      Enqueues a message for deferred delivery
//  Parameters:
//      IN  pIMailMsgProperties         message to defer
//      IN  pft                         FILETIME to defer delivery too
//  Returns:
//      -   Failures are handled internally
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::Enqueue(IMailMsgProperties *pIMailMsgProperties,
                                  FILETIME *pft)
{
    CAQDeferredDeliveryQueueEntry *pdefqeCurrent = NULL;
    CAQDeferredDeliveryQueueEntry *pdefqeNew = NULL;
    LIST_ENTRY *pli = NULL;
    LARGE_INTEGER   *pLargeIntCurrentDeferredTime = NULL;
    LARGE_INTEGER   *pLargeIntNewDeferredTime = (LARGE_INTEGER *)pft;

    _ASSERT(pIMailMsgProperties);
    _ASSERT(pft);
    
    pdefqeNew = new CAQDeferredDeliveryQueueEntry(pIMailMsgProperties, pft);

    m_slPrivateData.ExclusiveLock();

    if (!pdefqeNew)
    {
        //Handle Out of memory situation
        _ASSERT(m_paqinst); //if we don't have a virtual server we're toast
        if (m_paqinst)
        {
            m_paqinst->DecPendingDeferred();
            //pass off to virtual server object for general failure handling
            m_paqinst->HandleAQFailure(AQ_FAILURE_PENDING_DEFERRED_DELIVERY, 
                                        E_OUTOFMEMORY, pIMailMsgProperties);
        }

        goto Exit;
    }
    pli = m_liQueueHead.Flink;

    //Walk queue and look for entries with a later deferred delivery time.
    while (pli != &m_liQueueHead)
    {
        pdefqeCurrent = CAQDeferredDeliveryQueueEntry::pdefqeGetEntry(pli);
        _ASSERT(pdefqeCurrent);
        pLargeIntCurrentDeferredTime = (LARGE_INTEGER *) 
                            pdefqeCurrent->pftGetDeferredDeliveryTime();

        //If we have found an entry with a later time, we're done and will insert
        //in front of this entry
        if (pLargeIntCurrentDeferredTime->QuadPart > pLargeIntNewDeferredTime->QuadPart)
        {
            //back up so insert will happen between current and previous entry
            pli = pli->Blink; 
            break;
        }

        //continue searching forward (same direction as dequeue)
        pli = pli->Flink;
        _ASSERT(pli);
    }

    _ASSERT(pli);
    pdefqeNew->InsertBefore(pli);

    SetCallback();

  Exit:
    m_slPrivateData.ExclusiveUnlock();

}

//---[ CAQDeferredDeliveryQueue::ProcessEntries ]------------------------------
//
//
//  Description: 
//      Processes entries from the front of the queue until there are no 
//      more entries with deferred delivery times in the past.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::ProcessEntries()
{
    CAQDeferredDeliveryQueueEntry *pdefqe = NULL;
    LIST_ENTRY *pli = NULL;
    FILETIME *pftDeferredTime = NULL;
    DWORD dwTimeContext = 0;
    IMailMsgProperties *pIMailMsgProperties = NULL;
    HRESULT hr = S_OK;
    DWORD   cEntriesProcessed = 0;

    m_slPrivateData.ExclusiveLock();
    pli = m_liQueueHead.Flink;

    //if we do not have a virtual server pointer... then we have nothing
    //to do with the processed messages
    if (!m_paqinst)
        goto Exit;

    //Walk queue and delete remaining entries
    while (pli != &m_liQueueHead)
    {
        pdefqe = CAQDeferredDeliveryQueueEntry::pdefqeGetEntry(pli);
        _ASSERT(pdefqe);
        pftDeferredTime = pdefqe->pftGetDeferredDeliveryTime();

        //Check if the deferred delivery time is in the past... if not, we are done
        if (!m_paqinst->fInPast(pftDeferredTime, &dwTimeContext))
        {
            if (!cEntriesProcessed)
            {
                //we have processed no entries... and wasted a callback
                //force another callback so messages don't get stranded
                pdefqe->ResetCallbackFlag();
            }
            break;
        }

        cEntriesProcessed++;

        pIMailMsgProperties = pdefqe->pmsgGetMsg();
        delete pdefqe; //we remove from list

        //Release lock, so we do not hold it for external calls to submit
        //the message
        m_slPrivateData.ExclusiveUnlock();

        m_paqinst->DecPendingDeferred();

        //This is the external verions of AQ's submit API which should
        //always succeed... (unless shutdown is happening).
        hr = m_paqinst->HrInternalSubmitMessage(pIMailMsgProperties);

        if (FAILED(hr))
            m_paqinst->HandleAQFailure(AQ_FAILURE_PROCESSING_DEFERRED_DELIVERY, hr,
                                        pIMailMsgProperties);

        pIMailMsgProperties->Release();
        pIMailMsgProperties = NULL;

        //Since we gave up the lock, we need to start from the front of
        //the queue
        m_slPrivateData.ExclusiveLock();
        pli = m_liQueueHead.Flink;
        
    }

    //see if there are any other entries an set a new callback time
    SetCallback();

  Exit:
    m_slPrivateData.ExclusiveUnlock();
}

//---[ CAQDeferredDeliveryQueue::TimerCallback ]-------------------------------
//
//
//  Description: 
//      Callback function that is triggered by the retry-callback code.
//  Parameters:
//      IN  pvContext           A this ptr for the CAQDeferredDeliveryQueue
//                              object.
//  Returns:
//      - 
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::TimerCallback(PVOID pvContext)
{
    CAQDeferredDeliveryQueue *pdefq = (CAQDeferredDeliveryQueue *) pvContext;

    _ASSERT(DEFERRED_DELIVERY_QUEUE_SIG == pdefq->m_dwSignature);

    InterlockedDecrement((PLONG) &pdefq->m_cCallbacksPending);
    pdefq->ProcessEntries();
}


//---[ CAQDeferredDeliveryQueue::SetCallback ]---------------------------------
//
//
//  Description: 
//      Sets the retry callback if the queue is non-empty... Exclusive lock
//      on queue should be held at this point.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/13/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::SetCallback()
{
    CAQDeferredDeliveryQueueEntry *pdefqe = NULL;
    if (!IsListEmpty(&m_liQueueHead))
    {
        //Set the callback time.
        pdefqe = CAQDeferredDeliveryQueueEntry::pdefqeGetEntry(m_liQueueHead.Flink);
        _ASSERT(pdefqe);
        
        if (pdefqe->fSetCallback(this, m_paqinst))
            InterlockedIncrement((PLONG) &m_cCallbacksPending);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\defdlvrq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: defdlvrq.h
//
//  Description:  Header file for CAQDeferredDeliveryQueue.  This class 
//      implements storage for msgs pending deferred delivery
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/23/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DEFDLVRQ_H__
#define __DEFDLVRQ_H__

#include <aqincs.h>

class CAQSvrInst;

#define DEFERRED_DELIVERY_QUEUE_SIG         'QfeD'
#define DEFERRED_DELIVERY_QUEUE_ENTRY_SIG   'nEQD'

//---[ CAQDeferredDeliveryQueue ]----------------------------------------------
//
//
//  Description: 
//      Priority Queue / timer management for deferred delivery messages.
//  Hungarian: 
//      defq, pdefq
//  
//-----------------------------------------------------------------------------
class CAQDeferredDeliveryQueue
{
  protected:
    DWORD           m_dwSignature;
    LIST_ENTRY      m_liQueueHead;
    CAQSvrInst     *m_paqinst;
    CShareLockNH    m_slPrivateData;
    DWORD           m_cCallbacksPending;
  public:
    CAQDeferredDeliveryQueue();
    ~CAQDeferredDeliveryQueue();
    void Initialize(CAQSvrInst *paqinst);
    void Deinitialize();

    //Functions to enqueue and process entries... Any failures are handled
    //internally (by calling the HandleFailedMessage API).
    void Enqueue(IMailMsgProperties *pIMailMsgProperties, FILETIME *pft);
    void ProcessEntries();

    //callback function to "kick" queue
    static void TimerCallback(PVOID pvContext);
    void SetCallback();
};


//---[ CAQDeferredDeliveryQueueEntry ]-----------------------------------------
//
//
//  Description: 
//      Queue Entry for for deferred delivery queue
//  Hungarian: 
//      defqe, pdefqe
//  
//-----------------------------------------------------------------------------
class CAQDeferredDeliveryQueueEntry
{
  protected:
    DWORD               m_dwSignature;
    LIST_ENTRY          m_liQueueEntry;
    FILETIME            m_ftDeferredDeilveryTime;
    IMailMsgProperties *m_pIMailMsgProperties;
    BOOL                m_fCallbackSet;
  public:
    CAQDeferredDeliveryQueueEntry(IMailMsgProperties *pIMailMsgProperties,
                                  FILETIME *pft);
    ~CAQDeferredDeliveryQueueEntry();

    FILETIME   *pftGetDeferredDeliveryTime() {return &m_ftDeferredDeilveryTime;};
    void        InsertBefore(LIST_ENTRY *pli) 
    {
        _ASSERT(pli);
        InsertHeadList(pli, &m_liQueueEntry)
    };
    IMailMsgProperties *pmsgGetMsg();

    static CAQDeferredDeliveryQueueEntry *pdefqeGetEntry(LIST_ENTRY *pli)
    {
        _ASSERT(pli);
        CAQDeferredDeliveryQueueEntry *pdefqe = CONTAINING_RECORD(pli, 
                                                    CAQDeferredDeliveryQueueEntry,
                                                    m_liQueueEntry);

        _ASSERT(DEFERRED_DELIVERY_QUEUE_ENTRY_SIG == pdefqe->m_dwSignature);
        return pdefqe;
    };

    BOOL fSetCallback(PVOID pvContext, CAQSvrInst *paqinst);
    void ResetCallbackFlag() {m_fCallbackSet = FALSE;};
};


#endif __DEFDLVRQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\destmsgq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: destmsgq.h
//
//  Description: 
//      Header file for CDestMsgQueue class.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _DESTMSGQ_H_
#define _DESTMSGQ_H_

#include "cmt.h"
#include <fifoq.h>
#include <rwnew.h>
#include "domain.h"
#include "aqroute.h"
#include <listmacr.h>
#include "aqutil.h"
#include "aqinst.h"
#include "aqstats.h"
#include "aqadmsvr.h"

class CLinkMsgQueue;
class CMsgRef;
class CAQSvrInst;
class CQuickList;

#define DESTMSGQ_SIG ' QMD'
#define DESTMSGRETRYQ_SIG 'QRMD'
#define EMPTY_DMQ_EXPIRE_TIME_MINUTES   1

class CDestMsgQueue;

//---[ CDestMsgRetryQueue ]----------------------------------------------------
//
//
//  Hungarian: dmrq, pmdrq
//
//  Provides a retry interface for requeuing messages to DMQ.  If there are 
//  any outstanding messages for a queue, then someone must hold a reference
//  to this intertace to requeue it.
//
//  This class can only be created as as member of a CDestMsgQueue
//
//-----------------------------------------------------------------------------
class CDestMsgRetryQueue
{
  protected:
    DWORD                   m_dwSignature;
    //Reference count for retry interface.
    //Count is used to determine if it is safe to remove this DMQ from the
    //DMT.  This queue will only be removed when it has no messages and this 
    //count is zero.  The count represents the total number of
    //messages pending Ack on this queue. This is held while the message
    //is sent over the wire, and we determine if the message needs
    //to be retried.
    DWORD                   m_cRetryReferenceCount;
    CDestMsgQueue          *m_pdmq;

    friend class CDestMsgQueue;

    CDestMsgRetryQueue();
    ~CDestMsgRetryQueue() {_ASSERT(!m_cRetryReferenceCount);};
  public:

    DWORD   AddRef() 
        {return InterlockedIncrement((PLONG) &m_cRetryReferenceCount);};
    DWORD   Release() 
        {return InterlockedDecrement((PLONG) &m_cRetryReferenceCount);};

    HRESULT HrRetryMsg(IN CMsgRef *pmsgref); //put message on retry queue 

    VOID CheckForStaleMsgsNextDSNGenerationPass();

};

//---[ CDestMsgQueue ]---------------------------------------------------------
//
//
//  Hungarian: dmq, pmdq
//
//  Provides a priority queue of MsgRef's for the CMT
//-----------------------------------------------------------------------------
class CDestMsgQueue : 
    public IQueueAdminAction,
    public IQueueAdminQueue,
    public CBaseObject
{
public:
    CDestMsgQueue(CAQSvrInst *paqinst, 
        CAQMessageType *paqmtMessageType, IMessageRouter *pIMessageRouter);
    ~CDestMsgQueue();
   
    HRESULT HrInitialize(IN CDomainMapping *pdmap);

    HRESULT HrDeinitialize();

    //Set the routing information for this domain
    void    SetRouteInfo(CLinkMsgQueue *plmq);

    //Queue operations
    inline HRESULT HrEnqueueMsg(IN CMsgRef *pmsgref, BOOL fOwnsTypeRef);

    //Dequeue a message for delivery.  All OUT params are ref-counted, and
    //caller is responsable for releasing
    HRESULT HrDequeueMsg(
                IN DWORD dwLowestPriority,        //Lowest priority message that will be dequeued
                OUT CMsgRef **ppmsgref,           //MsgRef dequeued
                OUT CDestMsgRetryQueue **ppdmrq); //retry interface (optional)

    inline void GetDomainMapping(OUT CDomainMapping **ppdmap);

    //Remerge the retry queue with queues & generate DSNs if required
    HRESULT HrGenerateDSNsIfNecessary(IN CQuickList *pqlQueues, 
                                      IN HRESULT hrConnectionStatus,
                                      IN OUT DWORD *pdwContext);
    
    //functions used to manipulate lists of queues
    inline CAQMessageType *paqmtGetMessageType();
    inline IMessageRouter *pIMessageRouterGetRouter();
    inline BOOL     fIsSameMessageType(CAQMessageType *paqmt);
    static inline   CDestMsgQueue *pdmqIsSameMessageType(
                                    CAQMessageType *paqmt,
                                    PLIST_ENTRY pli);

    static inline   CDestMsgQueue *pdmqGetDMQFromDomainListEntry(PLIST_ENTRY pli);

    //Accessor functions for DomainEntry list
    inline void     InsertQueueInDomainList(PLIST_ENTRY pliHead);
    inline void     RemoveQueueFromDomainList();
    inline PLIST_ENTRY pliGetNextDomainListEntry();

    //Accessor functions for "empty-queue" list
    void            MarkQueueEmptyIfNecessary();
    inline void     InsertQueueInEmptyQueueList(PLIST_ENTRY pliHead);
    inline void     RemoveQueueFromEmptyQueueList();
    inline PLIST_ENTRY pliGetNextEmptyQueueListEntry();
    inline DWORD    dwGetDMQState();
    inline void     MarkDMQInvalid();
    void            RemoveDMQFromLink(BOOL fNotifyLink);
    
    //Addref and get link (returns NULL if not routed)
    CLinkMsgQueue  *plmqGetLink();

    static inline   CDestMsgQueue *pdmqGetDMQFromEmptyListEntry(PLIST_ENTRY pli);

    //Method that external users can use to verify the signature for
    //DMQ's passed as contexts or LIST_ENTRY's
    inline void     AssertSignature() {_ASSERT(DESTMSGQ_SIG == m_dwSignature);};

    static HRESULT HrWalkDMQForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext, 
                                   OUT BOOL *pfContinue, OUT BOOL *pfDelete);

    static HRESULT HrWalkQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue, 
                                     OUT BOOL *pfDelete);
    static HRESULT HrWalkRetryQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete);

    //Called by link to get & set link context
    inline PVOID    pvGetLinkContext() {return m_pvLinkContext;};
    inline void     SetLinkContext(IN PVOID pvLinkContext) {m_pvLinkContext = pvLinkContext;};

    inline BOOL     fIsRouted() {return (m_plmq ? TRUE : FALSE);};

    //update stats after adding or removing a message 
    //This should only be called by member functions and queue iterators
    void UpdateMsgStats(
        IN CMsgRef *pmsgref,                //Msg that was added/removed
        IN BOOL     fAdd);                  //TRUE => message was added

    //update stats after adding or removing a message on retry queue
    void UpdateRetryStats(
        IN BOOL     fAdd);                  //TRUE => message was added



    //Returns an approximation of the age of the oldest message in the queue
    inline void GetOldestMsg(FILETIME *pft);

    //Walk retry queue and remerge messages into normal queues
    void MergeRetryQueue();

    void SendLinkStateNotification(void);

    //Returns TRUE if queue is routed remotely.
    BOOL fIsRemote();

    //Describes DMQ state.  Returned by dwGetDMQState and cached in m_dwFlags
    enum 
    {
        DMQ_INVALID                 = 0x00000001, //This DMQ is no longer valid
        DMQ_IN_EMPTY_QUEUE_LIST     = 0x00000002, //This DMQ is in empty list
        DMQ_SHUTDOWN_SIGNALED       = 0x00000004, //Shutdown has been signaled
        DMQ_EMPTY                   = 0x00000010, //DMQ has no messages
        DMQ_EXPIRED                 = 0x00000020, //DMQ has expired in empty list
        DMQ_QUEUE_ADMIN_OP_PENDING  = 0x00000040, //A queue admin operation is pending
        DMQ_UPDATING_OLDEST_TIME    = 0x00000100, //Spinlock for updating oldest time
        DMQ_CHECK_FOR_STALE_MSGS    = 0x00000200, //Do check filehandles during DSN gen
    };

    //
    //  Since queues start out empty... there some error paths that can cause a queue
    //  to be marked as empty, but not actually put in the empty list.  We should
    //  clean these up during reset routes.  This tells us if it is safe to do so.
    //
    BOOL fIsEmptyAndAbandoned()
    {
        return (!m_aqstats.m_cMsgs &&
            !m_dmrq.m_cRetryReferenceCount &&
            !m_fqRetryQueue.cGetCount() &&
            (m_dwFlags & DMQ_EMPTY) && !(m_dwFlags & DMQ_IN_EMPTY_QUEUE_LIST));
    }

  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj); 
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

  public: //IQueueAdminAction
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD(HrApplyActionToMessage)(
		IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
		BOOL *pfShouldDelete);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        return QueryDefaultSupportedActions(pdwSupportedActions, 
                                            pdwSupportedFilterFlags);
    };

  public: //IQueueAdminQueue
    STDMETHOD(HrGetQueueInfo)(
        QUEUE_INFO *pliQueueInfo);

    STDMETHOD(HrGetQueueID)(
        QUEUELINK_ID *pQueueID);

  public:
    //  Return # of failed messages: They are not counted in the m_aqstats of the DMQ
    DWORD cGetFailedMsgs() { return m_fqRetryQueue.cGetCount(); }

    //  Set error code from routing
    void SetRoutingDiagnostic(HRESULT hr) { m_hrRoutingDiag = hr; }

protected:
    DWORD                   m_dwSignature;
    DWORD                   m_dwFlags;
    LIST_ENTRY              m_liDomainEntryDMQs;

    //Type of message (as returned by routing) that is on this queue.
    CAQMessageType           m_aqmt;
    DWORD                    m_cMessageTypeRefs; 
    
    IMessageRouter          *m_pIMessageRouter;

    //Errorcode from routing. This is set to S_OK if there's no errorcode. 
    //Currently this indicates the reason why a destination is unreachable.
    HRESULT                 m_hrRoutingDiag;

    //Members used for DMQ deletion (maintaining a list of empty queues)
    LIST_ENTRY              m_liEmptyDMQs;
    FILETIME                m_ftEmptyExpireTime; //expiration time of empty DMQ
    DWORD                   m_cRemovedFromEmptyList; //# of times on list w/o
                                                     //being deleted.

    CShareLockNH            m_slPrivateData; //Share lock to protect access to m_rgpfqQueues

    //The following three fields encapsulate all of the routing data
    //for this DMQ.  The actual routing data is the pointer to the link,
    //and the context is used by the link to optimize access
    CLinkMsgQueue           *m_plmq;      
    PVOID                   m_pvLinkContext; 

    CAQSvrInst              *m_paqinst;

    //Array of FIFO queues (used to make a priority queue
    CFifoQueue<CMsgRef *>   *m_rgpfqQueues[NUM_PRIORITIES];

    //Retry Qeueue for failed messages
    CFifoQueue<CMsgRef *>   m_fqRetryQueue;

    //class used to store stats
    CAQStats                m_aqstats;

    //which domain is  represented in this destination
    CDomainMapping          m_dmap;

    FILETIME                m_ftOldest;

    CDestMsgRetryQueue      m_dmrq;

    DWORD                   m_cCurrentThreadsEnqueuing;
  protected: //internal interfaces

    //Add Message to front or back of priority queues
    HRESULT HrAddMsg(
        IN CMsgRef *pmsgref,                //Msg to add
        IN BOOL fEnqueue,                   //TRUE => enqueue,FALSE => requeue
        IN BOOL fNotify);                   //TRUE => send notification if needed

    void UpdateOldest(FILETIME *pft);

    //Callers must use CDestMsgRetryQueueClass
    HRESULT HrRetryMsg(IN CMsgRef *pmsgref); //put message on retry queue 

    friend class CDestMsgRetryQueue;
};

//---[ CDestMsgQueue::HrEnqueueMsg ]-------------------------------------------
//
//
//  Description: 
//      Enqueues a message for remote delivery for a given final destination
//      and message type
//  Parameters:
//      pmsgref         AQ Message Reference to enqueue
//      fOwnsTypeRef    TRUE if this queue is responsible for calling
//                      IMessageRouter::ReleaseMessageType
//  Returns:
//      S_OK on success
//      Error code from HrAddMsg
//  History:
//      5/21/98 - MikeSwa added fOwnsTypeRef
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrEnqueueMsg(IN CMsgRef *pmsgref, BOOL fOwnsTypeRef)
{
    HRESULT hr = S_OK;

    hr = HrAddMsg(pmsgref, TRUE, TRUE);
    
    if (fOwnsTypeRef && SUCCEEDED(hr))
        InterlockedIncrement((PLONG) &m_cMessageTypeRefs);

    //Callers should have shutdown lock
    _ASSERT(!(m_dwFlags & (DMQ_INVALID | DMQ_SHUTDOWN_SIGNALED)));
    return hr;
}


//---[ CDestMsgQueue::paqmtGetMessageType ]------------------------------------
//
//
//  Description: 
//      Get the message type for this queue
//  Parameters:
//      -
//  Returns:
//      CAQMessageType * of this queue's message type
//  History:
//      5/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMessageType *CDestMsgQueue::paqmtGetMessageType()
{
    return (&m_aqmt);
}

//---[ CDestMsgQueue::fIsSameMessageType ]-------------------------------------
//
//
//  Description: 
//      Tells if the message type of this queue is the same as the given
//      message type.
//  Parameters:
//      paqmt   - ptr to CAQMessageType to test
//  Returns:
//      TRUE if they match, FALSE if they do not
//  History:
//      5/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CDestMsgQueue::fIsSameMessageType(CAQMessageType *paqmt)
{
    _ASSERT(paqmt);
    return m_aqmt.fIsEqual(paqmt);
}

//---[ CDestMsgQueue::pdmqIsSameMessageType ]----------------------------------
//
//
//  Description: 
//      STATIC function used to determine if a LIST_ENTRY refers to a 
//      CDestMsgQueue with a given message type.
//  Parameters:
//      paqmt   - ptr to CAQMessageType to check against
//      pli     - ptr to list entry to check (must refer to a CDestMsgQueue)
//  Returns:
//      Ptr to CDestMsgQueue if LIST_ENTRY refers to a CDestMsgQueue with
//      the given message type.
//      NULL if no match is not found
//  History:
//      5/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDestMsgQueue *CDestMsgQueue::pdmqIsSameMessageType(
                                    CAQMessageType *paqmt,
                                    PLIST_ENTRY pli)
{
    CDestMsgQueue *pdmq = NULL;
    pdmq = CONTAINING_RECORD(pli, CDestMsgQueue, m_liDomainEntryDMQs);
    _ASSERT(DESTMSGQ_SIG == pdmq->m_dwSignature);
    
    //if not the same message type return NULL
    if (!pdmq->fIsSameMessageType(paqmt))
        pdmq = NULL;
    
    return pdmq;
}

//---[ CDestMsgQueue::pdmqGetDMQFromDomainListEntry ]--------------------------
//
//
//  Description: 
//      Returns the CDestMsgQueue associated with a list entry
//  Parameters:
//      IN pli     ptr to list entry to get CDestMsgQueue from
//  Returns:
//      ptr to CDestMsgQueue
//  History:
//      5/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDestMsgQueue *CDestMsgQueue::pdmqGetDMQFromDomainListEntry(PLIST_ENTRY pli)
{
    _ASSERT(DESTMSGQ_SIG == (CONTAINING_RECORD(pli, CDestMsgQueue, m_liDomainEntryDMQs))->m_dwSignature);
    return (CONTAINING_RECORD(pli, CDestMsgQueue, m_liDomainEntryDMQs));
}

//---[ CDestMsgQueue::InsertQueueInDomainList ]---------------------------------
//
//
//  Description: 
//      Inserts this CDestMsgQueue into the given linked list of queues
//  Parameters:
//      pliHead     - PLIST_ENTRY for list head
//  Returns:
//      -
//  History:
//      5/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::InsertQueueInDomainList(PLIST_ENTRY pliHead)
{
    _ASSERT(NULL == m_liDomainEntryDMQs.Flink);
    _ASSERT(NULL == m_liDomainEntryDMQs.Blink);
    InsertHeadList(pliHead, &m_liDomainEntryDMQs);
}

//---[ CDestMsgQueue::RemoveQueueFromDomainList ]-------------------------------
//
//
//  Description: 
//      Removes this queue from a list of queues
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::RemoveQueueFromDomainList()
{
    RemoveEntryList(&m_liDomainEntryDMQs);
    m_liDomainEntryDMQs.Flink = NULL;
    m_liDomainEntryDMQs.Blink = NULL;
}

//---[ CDestMsgQueue::pliGetNextDomainListEntry ]-------------------------------
//
//
//  Description: 
//      Gets the pointer to the next list entry for this queue.
//  Parameters:
//      -
//  Returns:
//      The Flink of the queues LIST_ENTRY
//  History:
//      6/16/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
PLIST_ENTRY CDestMsgQueue::pliGetNextDomainListEntry()
{
    return m_liDomainEntryDMQs.Flink;
}

//---[ CDestMsgQueue::InsertQueueInEmptyQueueList ]----------------------------
//
//
//  Description: 
//      Inserts queue at *tail* of DMT empty queue list. The queue that has 
//      been empty the longest should be at the   As with the other EmptyQueue
//      list functions this is called by the DMT, when it has the appropriate 
//      lock for the head of the list.
//
//      Upon insertion, an "expire time" is stamped on the queue. If the queue
//      is still in the list, then it is a candidate for deletion, and will be
//      delete the next time the DMT looks at the queue (everytime HrMapDomain
//      is called).
//
//      NOTE"We need to make sure this function is thread-safe.  Since the
//      DMQ lock is aquired exclusively before this is called, we know that
//      no one will ENQUEUE a messsage.  This function call is tiggered after
//      the retry queues are emptied when a connection finished, so we can
//      also ensure that no one will call this while there are messages to 
//      retry.  

//      It is however (remotely) possible for 2 threads to finish connections 
//      for this queue and thus cause 2 threads to be in this function.
//      The thread that successfully modified the EMPTY bit will be allowed
//      to add the queue to the list.
//  Parameters:
//      IN  pliHead     The head of the list to insert into
//  Returns:
//      -
//  History:
//      9/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::InsertQueueInEmptyQueueList(PLIST_ENTRY pliHead)
{
    _ASSERT(m_paqinst);

    //Now that we have the exclusive lock recheck to make sure there are no messages
    if (m_aqstats.m_cMsgs || m_fqRetryQueue.cGetCount())
        return; 

    //Attempt to set the DMQ_EMPTY bit
    if (DMQ_EMPTY & dwInterlockedSetBits(&m_dwFlags, DMQ_EMPTY))
    {
        //Another thread has set it, we cannot modify the LIST_ENTRY
        return; 
    }

    //If it is already in queue, that means that the queue has gone
    //from empty to non-empty to empty. Insert at tail of list with new time
    if (m_dwFlags & DMQ_IN_EMPTY_QUEUE_LIST)
    {
        _ASSERT(NULL != m_liEmptyDMQs.Flink);
        _ASSERT(NULL != m_liEmptyDMQs.Blink);
        RemoveEntryList(&m_liEmptyDMQs);
        m_cRemovedFromEmptyList++;
    }
    else
    {
        _ASSERT(NULL == m_liEmptyDMQs.Flink);
        _ASSERT(NULL == m_liEmptyDMQs.Blink);
    }

    //Get expire time for this queue
    m_paqinst->GetExpireTime(EMPTY_DMQ_EXPIRE_TIME_MINUTES, 
                              &m_ftEmptyExpireTime, NULL);

    //Mark queue as in empty queue
    dwInterlockedSetBits(&m_dwFlags, DMQ_IN_EMPTY_QUEUE_LIST);

    //Insert into queue
    InsertTailList(pliHead, &m_liEmptyDMQs);
    _ASSERT(pliHead->Blink == &m_liEmptyDMQs);
    _ASSERT(!m_aqstats.m_cMsgs); //No other thread should be able to add msgs
}

//---[ DestMsgQueue::RemoveQueueFromEmptyQueueList ]---------------------------
//
//
//  Description: 
//      Removed the queue from the empty list.  Caller *must* have DMT lock
//      to call this.  DMQ will not call this directly, but will call into
//      DMT .
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::RemoveQueueFromEmptyQueueList()
{
    RemoveEntryList(&m_liEmptyDMQs);
    
    //Increment count now that queue is being removed from empty list
    m_cRemovedFromEmptyList++;

    //Mark queue as not in empty queue
    dwInterlockedUnsetBits(&m_dwFlags, DMQ_IN_EMPTY_QUEUE_LIST);

    m_liEmptyDMQs.Flink = NULL;
    m_liEmptyDMQs.Blink = NULL;
}

//---[ CDestMsgQueue::pliGetNextEmptyQueueListEntry ]--------------------------
//
//
//  Description: 
//      Gets next queue entry in empty list.
//  Parameters:
//      -
//  Returns:
//      Next entry pointed to by list entry
//  History:
//      9/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
PLIST_ENTRY CDestMsgQueue::pliGetNextEmptyQueueListEntry()
{
    return m_liEmptyDMQs.Flink;
}

//---[ CDestMsgQueue::dwGetDMQState ]------------------------------------------
//
//
//  Description: 
//      Returns the state of the DMQ and caches that state in m_dwFlags.  May
//      update DMQ_EXPIRED if DMQ is in empty list and it has expired
//  Parameters:
//      -
//  Returns:
//      Current DMQ state
//  History:
//      9/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CDestMsgQueue::dwGetDMQState()
{
    _ASSERT(DESTMSGQ_SIG == m_dwSignature);
    _ASSERT(m_paqinst);

    if (DMQ_IN_EMPTY_QUEUE_LIST & m_dwFlags)
    {
        //If it is empty and not expired..check if expired
        if ((DMQ_EMPTY & m_dwFlags) && !(DMQ_EXPIRED & m_dwFlags))
        {
            if (m_paqinst->fInPast(&m_ftEmptyExpireTime, NULL))
                dwInterlockedSetBits(&m_dwFlags, DMQ_EXPIRED);
        }
    }

    return m_dwFlags;
}

//---[ CDestMsgQueue::MarkDMQInvalid ]------------------------------------------
//
//
//  Description: 
//      Marks this queue as invalid.  Queue *must* be empty for this to happen
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::MarkDMQInvalid()
{
    _ASSERT(DESTMSGQ_SIG == m_dwSignature);
    _ASSERT(DMQ_EMPTY & m_dwFlags);
    dwInterlockedSetBits(&m_dwFlags, DMQ_INVALID);
}

//---[ CDestMsgQueue::pdmqGetDMQFromEmptyListEntry ]---------------------------
//
//
//  Description: 
//      Returns the DMQ corresponding to a given Empty Queue LIST_ENTRY.
//
//      Will assert that DMQ signature is valid
//  Parameters:
//      IN  pli     Pointer to LIST_ENTRY for queue
//  Returns:
//
//  History:
//      9/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDestMsgQueue *CDestMsgQueue::pdmqGetDMQFromEmptyListEntry(PLIST_ENTRY pli)
{
    _ASSERT(DESTMSGQ_SIG == (CONTAINING_RECORD(pli, CDestMsgQueue, m_liEmptyDMQs))->m_dwSignature);
    return (CONTAINING_RECORD(pli, CDestMsgQueue, m_liEmptyDMQs));
}

//---[ CDestMsgQueue::GetDomainMapping ]---------------------------------------
//
//
//  Description: 
//      Returns the domain mapping for this queue.
//  Parameters:
//      OUT ppdmap  Returned domain mapping
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Modified to not have a return value
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::GetDomainMapping(OUT CDomainMapping **ppdmap)
{
    _ASSERT(ppdmap);
    *ppdmap = &m_dmap; 
}

IMessageRouter *CDestMsgQueue::pIMessageRouterGetRouter()
{
    return m_pIMessageRouter;
}

//---[ CDestMsgQueue::GetOldestMsg ]-------------------------------------------
//
//
//  Description: 
//      Retruns an approximation of the oldest message in the queue
//  Parameters:
//      OUT pft     FILTIME of "oldest" Messate
//  Returns:
//      -
//  History:
//      12/13/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::GetOldestMsg(FILETIME *pft)
{
    _ASSERT(pft);
    if (m_aqstats.m_cMsgs)
        memcpy(pft, &m_ftOldest, sizeof(FILETIME));
    else
        ZeroMemory(pft, sizeof (FILETIME));
}

#endif //_DESTMSGQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\domcfg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: DomCfg.cpp
//
//  Description: Implementation of CDomainConfigTable and CInternalDomainInfo
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include <domhash.h>
#include "domcfg.h"
#include "aqutil.h"

//Encourage compiler to include symbols for enums
eDomainInfoFlags    g_eDomainInfo       = DOMAIN_INFO_USE_SSL;
eIntDomainInfoFlags g_eIntDomainInfo    = INT_DOMAIN_INFO_INVALID;

//---[ RemoveConfigEntryIteratorFn ]--------------------------------------------
//
//
//  Description: 
//      Deletes and releases all internal domain info objects in table
//  Parameters:
//          IN  pvContext   - pointer to context (ignored)
//          IN  pvData      - data entry to look at
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfRemoveEntry - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      6/17/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID RemoveConfigEntryIteratorFn(PVOID pvContext, PVOID pvData, BOOL fWildcard, 
                    BOOL *pfContinue, BOOL *pfDelete)
{
    CInternalDomainInfo *pIntDomainInfo = (CInternalDomainInfo *) pvData;
    *pfDelete = TRUE;
    *pfContinue = TRUE;
    _ASSERT(INT_DOMAIN_INFO_SIG == pIntDomainInfo->m_dwSignature);
    pIntDomainInfo->m_dwIntDomainInfoFlags |= INT_DOMAIN_INFO_INVALID;
    pIntDomainInfo->Release();
}


//---[ RemoveOutdatedConfigEntryIteratorFn ]------------------------------------
//
//
//  Description: 
//      Deletes and releases all outdated internal domain info objects in table.
//      An internal domain entry is considered outdated if its version number
//      does not match the global version number.
//  Parameters:
//          IN  pvContext   - pointer to context (current version number)
//          IN  pvData      - data entry to look at
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfRemoveEntry - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      9/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID RemoveOutdatedConfigEntryIteratorFn(PVOID pvContext, PVOID pvData, 
                    BOOL fWildcard, BOOL *pfContinue, BOOL *pfDelete)
{
    CInternalDomainInfo *pIntDomainInfo = (CInternalDomainInfo *) pvData;
    _ASSERT(INT_DOMAIN_INFO_SIG == pIntDomainInfo->m_dwSignature);
    _ASSERT(pvContext);
    *pfContinue = TRUE;

    if (pIntDomainInfo->m_dwVersion != *((DWORD *)pvContext))
    {
        //make sure it is not the root entry
        if ((1*sizeof(CHAR) == pIntDomainInfo->m_DomainInfo.cbDomainNameLength) &&
            ('*'  == pIntDomainInfo->m_DomainInfo.szDomainName[0]) &&
            ('\0' == pIntDomainInfo->m_DomainInfo.szDomainName[1]))
        {
            //
            //NOTE - It is not expected for this to happen.  We expect
            //SMTP to always provide a default entry.  If SMTP changes such
            //that does not, then dynamic updates would fail, because we never
            //mark the default entry that we create as invalid.  Once a link 
            //picks up this entry, it will never let it go.
            //
            _ASSERT(0 && "SMTP did not supply a * entry");

            //It is the root entry... update verision number
            
            //NOTE: The Root entry is a special case... it is required to be
            //present at all times, and is not always inserted into the 
            //metabase.  Because of this, it's version number may be incorrect,
            //so we need to make sure that we don't remove it.
            *pfDelete = FALSE;
            pIntDomainInfo->m_dwVersion = *((DWORD *)pvContext);
        }
        else
        {
            //The entry is old
            *pfDelete = TRUE;
            pIntDomainInfo->m_dwIntDomainInfoFlags |= INT_DOMAIN_INFO_INVALID;
            pIntDomainInfo->Release();
        }
    }
    else
    {
        *pfDelete = FALSE;
    }
}

//---[ HrCopyStringProperty ]--------------------------------------------------
//
//
//  Description: 
//      Private helper function that is used to allocate and copy string 
//      properties in the DomainInfo struct
//  Parameters:
//      OUT (ref)   szDest      Dest string to allocate and copy to
//      IN          szSource    Source string to copy
//      IN          cbLength    Length of string (without ending '\0'
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT inline HrCopyStringProperty(LPSTR &szDest, const LPSTR szSource, 
                                    DWORD cbLength)
{
    HRESULT hr = S_OK;
    _ASSERT(szSource);  //must have a buffer to copy
    _ASSERT(!szDest);

    szDest = (LPSTR) pvMalloc(cbLength + sizeof(CHAR));
    if (!szDest)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //copy data
    memcpy(szDest, szSource, cbLength);  //copy string
    szDest[cbLength] = '\0';

  Exit:
    return hr;
}

//---[ COPY_DOMAIN_INFO_STRING_PROP ]------------------------------------------
//
//
//  Description: 
//      Macro used to call private helper function HrCopyStringProperty
//  Parameters:
//      pOldDomainInfo      DomainInfo Struct to copy
//      pNewDomainInfo      New DomainInfo stuct to copy to
//      cbProp              Name of size property
//      szProp              Name of string proptery
//  Returns:
//      
//
//-----------------------------------------------------------------------------
#define COPY_DOMAIN_INFO_STRING_PROP(pOldDomainInfo, pNewDomainInfo, cbProp, szProp) \
{                                                                               \
    _ASSERT(!(pNewDomainInfo)->cbProp);                                         \
    _ASSERT(!(pNewDomainInfo)->szProp);                                         \
    (pNewDomainInfo)->cbProp = (pOldDomainInfo)->cbProp;                        \
    if ((pOldDomainInfo)->cbProp)                                               \
        hr = HrCopyStringProperty((pNewDomainInfo)->szProp,                     \
                (pOldDomainInfo)->szProp, (pOldDomainInfo)->cbProp);            \
}

//---[ CInternalDomainInfo::CInternalDomainInfo ]------------------------------
//
//
//  Description: 
//      Object constructor.  Initializes DomainInfo struct
//  Parameters:
//      DWORD   dwVersion   Current DomainConfigTable version
//  Returns:
//      -
//  History:
//      9/29/98 - MikeSwa - added version
//
//-----------------------------------------------------------------------------
CInternalDomainInfo::CInternalDomainInfo(DWORD dwVersion)
{
    ZeroMemory(&m_DomainInfo.dwDomainInfoFlags, sizeof(DomainInfo) - sizeof(DWORD));
    m_dwIntDomainInfoFlags = INT_DOMAIN_INFO_OK;
    m_dwSignature = INT_DOMAIN_INFO_SIG;
    m_dwVersion = dwVersion;

    //make sure our assumptions about the struct of DomainInfo are valid
    _ASSERT(1 == ((DWORD *) &m_DomainInfo.dwDomainInfoFlags) - ((DWORD *) &m_DomainInfo));

    m_DomainInfo.cbVersion = sizeof(DomainInfo);
}

//---[ CInternalDomainInfo::~CInternalDomainInfo ]-----------------------------
//
//
//  Description: 
//      Class destructor... deallocates any memory associated with the 
//      DomainInfo struct
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CInternalDomainInfo::~CInternalDomainInfo()
{
    _ASSERT(m_DomainInfo.cbVersion == sizeof(DomainInfo));

    if (m_DomainInfo.szDomainName)
        FreePv(m_DomainInfo.szDomainName);

    if (m_DomainInfo.szETRNDomainName)
        FreePv(m_DomainInfo.szETRNDomainName);

    if (m_DomainInfo.szSmartHostDomainName)
        FreePv(m_DomainInfo.szSmartHostDomainName);

    if (m_DomainInfo.szDropDirectory)
        FreePv(m_DomainInfo.szDropDirectory);

    if (m_DomainInfo.szAuthType)
        FreePv(m_DomainInfo.szAuthType);

    if (m_DomainInfo.szUserName)
        FreePv(m_DomainInfo.szUserName);

    if (m_DomainInfo.szPassword)
        FreePv(m_DomainInfo.szPassword);

    if (m_DomainInfo.pvBlob)
        FreePv(m_DomainInfo.pvBlob);

}

//---[ CInternalDomainInfo::HrInit ]-------------------------------------------
//
//
//  Description: 
//      Clones a DomainInfo struct and allocates needed memory
//  Parameters:
//      IN  pDomainInfo     DomainInfo struct to copy
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if allocations fail
//-----------------------------------------------------------------------------
HRESULT CInternalDomainInfo::HrInit(DomainInfo *pDomainInfo)
{
    HRESULT hr = S_OK;

    m_DomainInfo.dwDomainInfoFlags = pDomainInfo->dwDomainInfoFlags;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbDomainNameLength, szDomainName);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbETRNDomainNameLength, szETRNDomainName);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbSmartHostDomainNameLength, szSmartHostDomainName);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbDropDirectoryLength, szDropDirectory);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbAuthTypeLength, szAuthType);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbUserNameLength, szUserName);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbPasswordLength, szPassword);
    if (FAILED(hr))
        goto Exit;

    m_DomainInfo.cEtrnDelayTime = pDomainInfo->cEtrnDelayTime;

    //Copy the blob
    if (pDomainInfo->cbBlob)
    {
        _ASSERT(pDomainInfo->pvBlob);
        m_DomainInfo.pvBlob = (DWORD *) pvMalloc(pDomainInfo->cbBlob);
        if (!m_DomainInfo.pvBlob)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        //copy data
        memcpy(m_DomainInfo.pvBlob, pDomainInfo->pvBlob, pDomainInfo->cbBlob);
        m_DomainInfo.cbBlob = pDomainInfo->cbBlob;
    }

  Exit:
    return hr;
}

//---[ CDomainConfigTable::CDomainConfigTable ]--------------------------------
//
//
//  Description: 
//      Constuctor for CDomainConfig Table
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDomainConfigTable::CDomainConfigTable() :
                                m_slPrivateData("CDomainConfigTable")
{
    m_dwFlags = 0;
    m_dwSignature = DOMAIN_CONFIG_SIG;
    m_dwCurrentConfigVersion = 0;
    m_pLastStarDomainInfo = NULL;
    m_pDefaultDomainConfig = NULL;
}

//---[ CDomainConfigTable::~CDomainConfigTable ]-------------------------------
//
//
//  Description: 
//      Destructor for CDomainConfig Table
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDomainConfigTable::~CDomainConfigTable()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::~CDomainConfigTable");
    HRESULT hr = S_OK;

    //Delete all entries from the table
    if (DOMCFG_DOMAIN_NAME_TABLE_INIT & m_dwFlags)
    {
        //iterate over all domains and delete entries in hash table
        m_dnt.HrIterateOverSubDomains(NULL, RemoveConfigEntryIteratorFn, NULL);
        if (m_pDefaultDomainConfig != NULL) {
            m_pDefaultDomainConfig->Release();
            m_pDefaultDomainConfig = NULL;
        }
        m_dwFlags ^= DOMCFG_DOMAIN_NAME_TABLE_INIT;
    }

    TraceFunctLeave();
}

//---[ CDomainConfigTable::HrInit ]--------------------------------------------
//
//
//  Description: 
//      Initializes DOMAIN_NAME_TABLE hash table
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDomainConfigTable::HrInit()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::HrInit");
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfoDefault = NULL;
    DOMAIN_STRING strDomain;

    hr = m_dnt.HrInit();
    if (FAILED(hr))
        goto Exit;

    m_dwFlags |= DOMCFG_DOMAIN_NAME_TABLE_INIT;

    //Part 1
    //
    //Allocate an InternalDomainInfo for m_pDefaultDomainConfig. This
    //will be used for links/connections for which a routing sink has returned
    //no connector
    m_pDefaultDomainConfig = new CInternalDomainInfo(m_dwCurrentConfigVersion);
    if (!m_pDefaultDomainConfig) 
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    m_pDefaultDomainConfig->m_DomainInfo.cbDomainNameLength = 1;
    m_pDefaultDomainConfig->m_DomainInfo.szDomainName = 
        (LPSTR) pvMalloc(2*sizeof(CHAR));
    if (!m_pDefaultDomainConfig->m_DomainInfo.szDomainName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    memcpy(m_pDefaultDomainConfig->m_DomainInfo.szDomainName, "*", 2);


    //Part 2
    //
    //Create default "*" entry in the DCT so that arbitrary domains will have
    //something to match against. Note that this entry is separate from the
    //m_pDefaultDomainConfig entry that is *not* part of the DCT, and is used
    //for links/connections that are *not* supposed to match anything in the DCT
    pIntDomainInfoDefault = new CInternalDomainInfo(m_dwCurrentConfigVersion);
    if (!pIntDomainInfoDefault)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pIntDomainInfoDefault->m_DomainInfo.cbDomainNameLength = 1;
    pIntDomainInfoDefault->m_DomainInfo.szDomainName = (LPSTR) pvMalloc(2*sizeof(CHAR));
    if (!pIntDomainInfoDefault->m_DomainInfo.szDomainName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    memcpy(pIntDomainInfoDefault->m_DomainInfo.szDomainName, "*", 2);

    strDomain.Length = (USHORT) pIntDomainInfoDefault->m_DomainInfo.cbDomainNameLength;
    strDomain.MaximumLength = strDomain.Length;
    strDomain.Buffer = pIntDomainInfoDefault->m_DomainInfo.szDomainName;
    hr = m_dnt.HrInsertDomainName(&strDomain, (PVOID) pIntDomainInfoDefault);

    if (FAILED(hr))
        goto Exit;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDomainConfigTable::HrSetInternalDomainInfo ]---------------------------
//
//
//  Description: 
//      Inserts InternalDomainInfo into hash table based on szDomain
//  Parameters:
//      IN  pIntDomainInfo      Internal DomainInfo to insert
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDomainConfigTable::HrSetInternalDomainInfo(
                    IN CInternalDomainInfo *pIntDomainInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::SetInternalDomainInfo");
    HRESULT hr = S_OK;
    DOMAIN_STRING  strDomain;
    CInternalDomainInfo *pIntDomainInfoCurrent = NULL;

    _ASSERT(pIntDomainInfo);
    _ASSERT(pIntDomainInfo->m_DomainInfo.szDomainName);
    _ASSERT(pIntDomainInfo->m_DomainInfo.cbDomainNameLength);
    _ASSERT(pIntDomainInfo->m_dwVersion == m_dwCurrentConfigVersion);

    strDomain.Length = (USHORT) pIntDomainInfo->m_DomainInfo.cbDomainNameLength;
    strDomain.MaximumLength = (USHORT) pIntDomainInfo->m_DomainInfo.cbDomainNameLength;
    strDomain.Buffer = pIntDomainInfo->m_DomainInfo.szDomainName;

    pIntDomainInfo->AddRef();

    //Get Lock on table
    m_slPrivateData.ExclusiveLock();

    //HACK ALERT
    //
    //SMTP calls this routine with info from one of two places:
    //1. For each domain configured in the /smtpsvc/1/domains container in the
    //   metabase. In PT, these entries are populated from address spaces on 
    //   connectors.
    //2. For outbound-security configured at the /smtpsvc/1 (ie, at the VS) 
    //   level, it creates a "dummy" entry for the "*" domain.
    //
    //Unfortunately, this creates a problem if you have a connector with the
    //   * address space, because the insertion in item 2 will overwrite the
    //   insertion for * in item 1. 
    //To handle this case, we keep the "last" * entry received in the 
    //   m_pLastStarDomainInfo. If we receive a second entry, then we know the
    //   m_pLastStarDomainInfo is a domain entry from item 1. Otherwise, it 
    //   is the default config info.
    //

    //
    //If this is the "*" domain, then store it in m_pLastStarDomainInfo, until
    //we decide whether this is really the star domain info from item 1 or 
    //the info from item 2
    //

    if (pIntDomainInfo->m_DomainInfo.cbDomainNameLength == 1 &&
            pIntDomainInfo->m_DomainInfo.szDomainName[0] == '*') {

        if (m_pLastStarDomainInfo == NULL) {
            m_pLastStarDomainInfo = pIntDomainInfo;
            hr = S_OK;
            goto Exit;
        } else {

            // This is the second * domain entry we have seen. Insert the
            // previous entry into the DMT, and keep this one as the last star
            // entry seen.

            pIntDomainInfoCurrent = pIntDomainInfo;
            pIntDomainInfo = m_pLastStarDomainInfo;
            m_pLastStarDomainInfo = pIntDomainInfoCurrent;

            pIntDomainInfoCurrent = NULL;
            dwInterlockedSetBits(&m_dwFlags, DOMCFG_MULTIPLE_STAR_DOMAINS);


        }

    }

    hr = m_dnt.HrInsertDomainName(&strDomain, (PVOID) pIntDomainInfo);
    if (FAILED(hr))
    {
        if (DOMHASH_E_DOMAIN_EXISTS == hr)
        {
            //someone already inserted for this domain
            hr = m_dnt.HrRemoveDomainName(&strDomain, 
                            (PVOID *) &pIntDomainInfoCurrent);
            _ASSERT(DOMHASH_E_NO_SUCH_DOMAIN != hr); //someone violated write-lock
            if (FAILED(hr))
                goto Exit;

            _ASSERT(pIntDomainInfoCurrent);

            //Mark old info as invalid & release
            pIntDomainInfoCurrent->m_dwIntDomainInfoFlags |= INT_DOMAIN_INFO_INVALID;
            _ASSERT(pIntDomainInfoCurrent->m_dwVersion <= pIntDomainInfo->m_dwVersion);
            pIntDomainInfoCurrent->Release();
            pIntDomainInfoCurrent = NULL;

            hr = m_dnt.HrInsertDomainName(&strDomain, (PVOID) pIntDomainInfo);
            _ASSERT(DOMHASH_E_DOMAIN_EXISTS != hr); //someone violated write-lock
            if (FAILED(hr))
                goto Exit;
        }
        else
        {
            goto Exit;
        }
    }

  Exit:
    m_slPrivateData.ExclusiveUnlock();
    TraceFunctLeave();
    return hr;
}

//---[ CDomainConfigTable::HrGetInternalDomainInfo ]---------------------------
//
//
//  Description: 
//      Gets internal Domaininfo stuct from hash table.  Will use wildcard 
//      matching
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      OUT     ppIntDomainInfo         Domain info returned (must be released)
//  Returns:
//      S_OK    if match is found
//      AQUEUE_E_INVALID_DOMAIN if no match is found
//
//-----------------------------------------------------------------------------
HRESULT CDomainConfigTable::HrGetInternalDomainInfo(
                                  IN  DWORD cbDomainNameLength,
                                  IN  LPSTR szDomainName,
                                  OUT CInternalDomainInfo **ppIntDomainInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::GetInternalDomainInfo");
    HRESULT hr = S_OK;
    DOMAIN_STRING  strDomain;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(ppIntDomainInfo);

    strDomain.Length = (USHORT) cbDomainNameLength;
    strDomain.MaximumLength = (USHORT) cbDomainNameLength;
    strDomain.Buffer = szDomainName;

    m_slPrivateData.ShareLock();

    //Use wildcard lookup
    hr = m_dnt.HrFindDomainName(&strDomain, (PVOID *) ppIntDomainInfo, FALSE);

    if (FAILED(hr))
    {
        //It should at least match the default domain
        _ASSERT(DOMHASH_E_NO_SUCH_DOMAIN != hr);  
        goto Exit;
    }

    _ASSERT(*ppIntDomainInfo);

    (*ppIntDomainInfo)->AddRef();

  Exit:
    m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainConfigTable::HrGetDefaultDomainInfo ]---------------------------
//
//
//  Description: 
//      Gets internal Default Domaininfo stuct.
//  Parameters:
//      OUT     ppIntDomainInfo         Domain info returned (must be released)
//  Returns:
//      S_OK    if successful
//      AQUEUE_E_INVALID_DOMAIN if error
//
//-----------------------------------------------------------------------------
HRESULT CDomainConfigTable::HrGetDefaultDomainInfo(
                                  OUT CInternalDomainInfo **ppIntDomainInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::GetDefaultDomainInfo");

    HRESULT hr = S_OK;

    *ppIntDomainInfo = NULL;

    m_slPrivateData.ShareLock();

    if (m_pDefaultDomainConfig != NULL) {
        *ppIntDomainInfo = m_pDefaultDomainConfig;
    } else {
        hr = AQUEUE_E_INVALID_DOMAIN;
        goto Exit;
    }

    _ASSERT(*ppIntDomainInfo);

    (*ppIntDomainInfo)->AddRef();

  Exit:
    m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
    return hr;
}


//---[ CDomainConfigTable::StartConfigUpdate ]---------------------------------
//
//
//  Description: 
//      Signals that the metabase has been updated, and we will now begin to
//      get updated information.  Increments an internal version number that
//      will be used to removed old, outdated entries once all of the config
//      info has been updated.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDomainConfigTable::StartConfigUpdate()
{
    InterlockedIncrement((PLONG) &m_dwCurrentConfigVersion);
    _ASSERT(!(m_dwFlags & DOMCFG_FINISH_UPDATE_PENDING));
    _ASSERT(m_pLastStarDomainInfo == NULL);
    dwInterlockedSetBits(&m_dwFlags, DOMCFG_FINISH_UPDATE_PENDING);
    dwInterlockedUnsetBits(&m_dwFlags, DOMCFG_MULTIPLE_STAR_DOMAINS);
}

//---[ CDomainConfigTable::FinishConfigUpdate ]--------------------------------
//
//
//  Description: 
//      Used to signal when all updated configuration information has been 
//      passed in.  Will then walk all of our cached configuration information
//      and remove outdated entries
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDomainConfigTable::FinishConfigUpdate()
{
    HRESULT hr = S_OK;
    DWORD   dwCurrentVersion = m_dwCurrentConfigVersion;
    CInternalDomainInfo *pIntDomainInfo = NULL;

    //There should be a matching start
    _ASSERT(m_dwFlags & DOMCFG_FINISH_UPDATE_PENDING);

    //
    //  Get the last "*" domain in case we need to explicitly update the table
    //  with it.
    //
    m_slPrivateData.ShareLock();
    pIntDomainInfo = m_pLastStarDomainInfo;
    if (pIntDomainInfo)
        pIntDomainInfo->AddRef();
    m_slPrivateData.ShareUnlock();

    //
    //  If only 1 "*" domain has been configured, then we have not inserted
    //  it in the DNT, and the actual data there is out of date.  We
    //  need to insert it into the table.
    //
    if (pIntDomainInfo && !(DOMCFG_MULTIPLE_STAR_DOMAINS & m_dwFlags)) 
    {
        HrSetInternalDomainInfo(pIntDomainInfo);
    }

    //
    //  Release the internal domain info if we got it.
    //
    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    dwInterlockedUnsetBits(&m_dwFlags, DOMCFG_FINISH_UPDATE_PENDING);


    //Lock table, remove outdated entries, and update the default domain config
    m_slPrivateData.ExclusiveLock();

    if (m_pLastStarDomainInfo) {
        m_pDefaultDomainConfig->m_dwIntDomainInfoFlags |= 
            INT_DOMAIN_INFO_INVALID;
        m_pDefaultDomainConfig->Release();
        m_pDefaultDomainConfig = m_pLastStarDomainInfo;
        m_pLastStarDomainInfo = NULL;

    }

    hr = m_dnt.HrIterateOverSubDomains(NULL, 
        RemoveOutdatedConfigEntryIteratorFn, &dwCurrentVersion);
    m_slPrivateData.ExclusiveUnlock();

    if (FAILED(hr))
        _ASSERT(DOMHASH_E_NO_SUCH_DOMAIN == hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\domcfg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: DomCfg.h
//
//  Description: DomainConfigTable header file.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DOMCFG_H__
#define __DOMCFG_H__

#include <baseobj.h>
#include <domhash.h>

#define INT_DOMAIN_INFO_SIG 'fnID'
#define DOMAIN_CONFIG_SIG   ' TCD'

//---[ eIntDomainInfoFlags ]---------------------------------------------------
//
//
//  Description: Internal Domain Info flags
//
//
//-----------------------------------------------------------------------------
typedef enum
{
    INT_DOMAIN_INFO_OK                  = 0x00000000,
    INT_DOMAIN_INFO_INVALID             = 0x80000000,  //The domain info struct
                                                       //has been replaced... if
                                                       //an object has a cached
                                                       //copy it should release it
} eIntDomainInfoFlags;

//---[ CInternalDomainInfo ]---------------------------------------------------
//
//  Description:
//      A entry in CDomainConfigTable.  Basically an internal wrapper for the
//      public DomainInfo struct.
//
//  Hungarian: IntDomainInfo, pIntDomainInfo
//
//-----------------------------------------------------------------------------
class CInternalDomainInfo : public CBaseObject
{
  public:
      CInternalDomainInfo(DWORD dwVersion);
      ~CInternalDomainInfo();
      HRESULT       HrInit(DomainInfo *pDomainInfo);
      DWORD         m_dwSignature;
      DWORD         m_dwIntDomainInfoFlags;
      DWORD         m_dwVersion;
      DomainInfo    m_DomainInfo;
};

//---[ CDomainConfigTable ]----------------------------------------------------
//
//
//  Description:
//      Contains per domain configuration information, and exposes wildcarded
//      hash-table based lookup of this information.
//
//  Hungarian: dct, pdct
//
//-----------------------------------------------------------------------------
class CDomainConfigTable
{
  protected:
    DWORD               m_dwSignature;
    DWORD               m_dwCurrentConfigVersion;
    CInternalDomainInfo *m_pLastStarDomainInfo;
    DOMAIN_NAME_TABLE   m_dnt;
    CShareLockInst      m_slPrivateData;
    DWORD               m_dwFlags;
    CInternalDomainInfo *m_pDefaultDomainConfig;

  public:
    CDomainConfigTable();
    ~CDomainConfigTable();
    HRESULT HrInit();
    HRESULT HrSetInternalDomainInfo(IN CInternalDomainInfo *pDomainInfo);
    HRESULT HrGetInternalDomainInfo(IN  DWORD cbDomainNameLength,
                           IN  LPSTR szDomainName,
                                  OUT CInternalDomainInfo **ppDomainInfo);
    HRESULT HrGetDefaultDomainInfo(OUT CInternalDomainInfo **ppDomainInfo);
    HRESULT HrIterateOverSubDomains(DOMAIN_STRING * pstrDomain,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext)
    {
        HRESULT hr = S_OK;
        m_slPrivateData.ShareLock();
        hr = m_dnt.HrIterateOverSubDomains(pstrDomain, pfn, pvContext);
        m_slPrivateData.ShareUnlock();
        return hr;
    };

    DWORD   dwGetCurrentVersion() {return m_dwCurrentConfigVersion;};

    void    StartConfigUpdate();
    void    FinishConfigUpdate();

    enum _DomainConfigTableFlags
    {
        DOMCFG_DOMAIN_NAME_TABLE_INIT = 0x00000001,
        DOMCFG_FINISH_UPDATE_PENDING  = 0x00000002, //StartConfig update has been called
        DOMCFG_MULTIPLE_STAR_DOMAINS  = 0x00000004, //There have been more that one
                                                    // "*" domain configured
    };
};

#endif //__DOMCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\dsnevent.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: dsnevent.cpp
//
// Contents: Implementation of functions in dsnevent.h
//
// Classes: CDSNParams
//
// Functions:
//
// History:
// jstamerj 2000/12/08 15:48:27: Created.
//
//-------------------------------------------------------------
#include <aqprecmp.h>
#include "dsnevent.h"


//+------------------------------------------------------------
//
// Function: CDSNParams::HrAllocBoundMessage
//
// Synopsis: Allocate and bind a message
//
// Arguments:
//  ppMsg: Out parameter for message
//  phContent: Out parameter for content
//
// Returns:
//  S_OK: Success
//  error from SMTP
//
// History:
// jstamerj 2001/05/11 15:34:49: Created.
//
//-------------------------------------------------------------
HRESULT CDSNParams::HrAllocBoundMessage(
    OUT IMailMsgProperties **ppMsg,
    OUT PFIO_CONTEXT *phContent)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDSNParams::HrAllocBoundMessage");

    _ASSERT(paqinst);
    hr = paqinst->HrAllocBoundMessage(
        ppMsg,
        phContent);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDSNParams::HrAllocBoundMessage




//+------------------------------------------------------------
//
// Function: CDSNParams::HrSubmitDSN
//
// Synopsis: Accepts a DSN message from a DSN sink
//
// Arguments:
//  dwDSNAction: Type of DSN generated
//  cRecipsDSNs: # of recipients DSNd
//  pDSNMsg: The DSN mailmsg
//
// Returns:
//  S_OK: Success
//  error from CAQSvrInst::HrSubmitDSN
//
// History:
// jstamerj 2000/12/08 15:48:56: Created.
//
//-------------------------------------------------------------
HRESULT CDSNParams::HrSubmitDSN(
    IN  DWORD dwDSNAction,
    IN  DWORD cRecipsDSNd,
    IN  IMailMsgProperties *pDSNMsg)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDSNParams::HrSubmitDSN");

    _ASSERT(paqinst);
    hr = paqinst->HrSubmitDSN(
        this,
        dwDSNAction,
        cRecipsDSNd,
        pDSNMsg);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDSNParams::HrSubmitDSN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\dsnevent.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnevent.h
//
//  Description: Define dsnevent structure. Used to pass parameters to DSN sink
//      with intelligent defaults
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/11/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNEVENT_H__
#define __DSNEVENT_H__


class CAQSvrInst;

#define DSN_PARAMS_SIG 'PnsD'
const   CHAR    DEFAULT_MTA_TYPE[] = "dns";

#define DSN_DEBUG_CONTEXT_MAX_SIZE 	50
#define DSN_DEBUG_CONTEXT_FORMAT   	"12345678 - line#"
#define DSN_LINE_PREFIX				" - "
//
// We will encode the filename using the same hash we use for domhash.  
// This way, we can always have supplemental info useful for debugging DSNs
//
#define SET_DEBUG_DSN_CONTEXT(x, linenum) \
{ \
	register LPSTR szCurrent = (x).szDebugContext; \
	_itoa(dwDSNContextHash(__FILE__, sizeof(__FILE__)), \
		  szCurrent, 16); \
	szCurrent += strlen((x).szDebugContext);\
	strcpy(szCurrent, DSN_LINE_PREFIX); \
	szCurrent += (sizeof(DSN_LINE_PREFIX)-1); \
	_itoa(linenum, szCurrent, 10); \
} 

//---[ CDSNParams ]------------------------------------------------------------
//
//
//  Description: 
//      Encapsulated DSN Parameters in a class
//  Hungarian: 
//      dsnparams, *pdsnparams
//  
//-----------------------------------------------------------------------------

class CDSNParams : 
    public IDSNSubmission
{
  private:
    DWORD       m_dwSignature;
  public: //actual parameters of DSN Generation event
    IMailMsgProperties *pIMailMsgProperties;
    DWORD dwStartDomain; //starting index used to init context
    DWORD dwDSNActions;  //type(s) of DSN to generate
    DWORD dwRFC821Status; //global RFC821 status
    HRESULT hrStatus; //global HRESULT

    //OUT param(s)
    DWORD dwDSNTypesGenerated;
    DWORD cRecips; //# of recipients DSN'd
    CAQSvrInst *paqinst;
    CHAR  szDebugContext[DSN_DEBUG_CONTEXT_MAX_SIZE];  //debug context stampted as "x=" header
  public:
    inline CDSNParams();

  public: // IDSNSubmission
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj)
    {
        *ppvObj = NULL;
        if(riid == IID_IUnknown)
        {
            *ppvObj = (IUnknown *)this;
        }
        else if(riid == IID_IDSNSubmission)
        {
            *ppvObj = (IDSNSubmission *)this;
        }
        else
        {
            return E_NOINTERFACE;
        }
        AddRef();
        return S_OK;
    }
    //
    // This class is always allocated on the stack
    //
    STDMETHOD_(ULONG, AddRef)(void) { return 2; }
    STDMETHOD_(ULONG, Release)(void) { return 1; }

    STDMETHOD(HrAllocBoundMessage)(
        OUT IMailMsgProperties **ppMsg,
        OUT PFIO_CONTEXT *phContent);

    STDMETHOD(HrSubmitDSN)(
        IN  DWORD dwDSNAction,
        IN  DWORD cRecipsDSNd,
        IN  IMailMsgProperties *pDSNMsg);

};

CDSNParams::CDSNParams()
{
	_ASSERT(sizeof(DSN_DEBUG_CONTEXT_FORMAT) < DSN_DEBUG_CONTEXT_MAX_SIZE);
    m_dwSignature = DSN_PARAMS_SIG;
    pIMailMsgProperties = NULL;
    dwStartDomain = 0;
    dwDSNActions = 0;
    dwRFC821Status = 0;
    hrStatus = S_OK;
    dwDSNTypesGenerated = 0;
    cRecips = 0;
    paqinst = NULL;
    szDebugContext[0] = '\0';
}

inline DWORD dwDSNContextHash(LPCSTR szString, DWORD cbString)
{
    DWORD dwHash = 0;
    LPCSTR szStringEnd = szString+cbString-1;

    if (szStringEnd && cbString)
    {
    	
    	//
    	//  Loop until the end of the string or we hit a file separation
    	//  character.
    	//
        while (szStringEnd && 
               (szStringEnd >= szString) && 
               ('\\' != *szStringEnd))
        {
            //Use Hash from Domhash.lib
            dwHash *= 131;  //First prime after ASCII character codes
            dwHash += *szStringEnd;
            szStringEnd--;
        }
    }
    return dwHash;
}
#endif //__DSNEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\failmsgq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: failmsgq.h
//
//  Description:
//      Header file for CFailedMsgQueue class with servers as a holding place
//      for messages that cannot be delivered due to out of memory and other
//      conditions.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      1/18/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __FAILMSGQ_H__
#define __FAILMSGQ_H__

#include "aqincs.h"
#include "rwnew.h"

class CMsgRef;
class CAQSvrInst;

#define FAILEDMSGQUEUE_SIG ' QMF'

//---[ CFailedMsgQueue ]-------------------------------------------------------
//
//
//  Description: 
//      Class that abtracts handling of failed messages.  There is no 
//      additional memory allocation need during the processing of the 
//      of these failed messages.  The key design point is that none of these
//      API calls can fail.
//
//      This class contains a single list entries for MailMsgs.  MailMsgs that 
//      have been dropped here must not be referenced by another other thread,
//      or we might break the threading-access restrictions of the mailmsg
//      interface.  Once a MailMsg has been queued, it is encapsultated in a 
//      CMsgRef object, which can be referenced by many threads.  At this point
//      we must wait until all references to that CMsgRef are released.
//   
//  Hungarian: 
//      fmq, pfmq
//  
//-----------------------------------------------------------------------------
class CFailedMsgQueue
{
  private:
    DWORD           m_dwSignature;
    DWORD           m_dwFlags;
    DWORD           m_cMsgs; 
    CAQSvrInst     *m_paqinst;
    LIST_ENTRY      m_liHead;
    CShareLockNH    m_slPrivateData;

    enum
    {
        FMQ_CALLBACK_REQUESTED =    0x00000001,
    };

    void InternalStartProcessingIfNecessary();

  public:
    CFailedMsgQueue();
    ~CFailedMsgQueue();

    void Initialize(CAQSvrInst *paqinst);
    void Deinitialize();

    //Functions called to handle a failure
    void HandleFailedMailMsg(IMailMsgProperties *pIMailMsgProperties);

    //Called on SubmitMessage to kick off processing if necessary
    inline void StartProcessingIfNecessary()
    {
        if (!(FMQ_CALLBACK_REQUESTED & m_dwFlags) && m_cMsgs)
            InternalStartProcessingIfNecessary();
    }

    //Member function and callback function to process entries.
    void ProcessEntries();
    static void ProcessEntriesCallback(PVOID pvContext);
};

//---[ AQueueFailedListEntry ]-------------------------------------------------
//
//
//  Description: 
//      Actual in-memory representation of LIST_ENTRY ptr returned by mailmsg.
//      Memory after LIST_ENTRY is used to store original pointer.
//  Hungarian: 
//      fli, pfli
//  
//-----------------------------------------------------------------------------
typedef struct tagAQueueFailedListEntry 
{
    LIST_ENTRY          m_li;
    IMailMsgProperties *m_pIMailMsgProperties;
} AQueueFailedListEntry;

#endif //__FAILMSGQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\domain.h ===
//-----------------------------------------------------------------------------
//
//
//    File: domain.h
//
//    Description:
//      Contains descriptions of the Domain table management structure
//
//    Author: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _DOMAIN_H_
#define _DOMAIN_H_

#include "cmt.h"
#include <baseobj.h>
#include <domhash.h>
#include <rwnew.h>
#include <smtpevent.h>

class CInternalDomainInfo;
class CDestMsgQueue;
class CDomainEntry;
class CDomainMappingTable;
class CAQSvrInst;
class CAQMessageType;
class CLinkMsgQueue;
class CLocalLinkMsgQueue;
class CAQScheduleID;
class CMsgRef;
class CDeliveryContext;
class CAsyncAdminMsgRefQueue;
class CAsyncAdminMailMsgQueue;
class CMailMsgAdminLink;
class CDomainEntryLinkIterator;
class CDomainEntryQueueIterator;
class CDomainEntryIterator;

#include "asyncq.h"

#define DOMAIN_ENTRY_SIG            'tnED'
#define DOMAIN_ENTRY_ITERATOR_SIG   'ItnD'
#define DOMAIN_MAPPING_TABLE_SIG    ' TMD'

//Name used for global 'local' link
#define LOCAL_LINK_NAME                 "LocalLink"
#define UNREACHABLE_LINK_NAME           "UnreachableLink"
#define CURRENTLY_UNREACHABLE_LINK_NAME "CurrentlyUnreachableLink"
#define PRECAT_QUEUE_NAME               "PreCatQueue"
#define PREROUTING_QUEUE_NAME           "PreRoutingQueue"
#define PRESUBMISSION_QUEUE_NAME        "PreSubmissionQueue"
#define POSTDSN_QUEUE_NAME              "PostDSNGenerationQueue"

// {34E2DCCA-C91A-11d2-A6B1-00C04FA3490A}
static const GUID g_sGuidLocalLink =
{ 0x34e2dcca, 0xc91a, 0x11d2, { 0xa6, 0xb1, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

// {CD08CEE0-2A95-11d3-B38E-00C04F6B6167}
static const GUID g_sGuidPrecatLink =
{ 0xcd08cee0, 0x2a95, 0x11d3, { 0xb3, 0x8e, 0x0, 0xc0, 0x4f, 0x6b, 0x61, 0x67 } };

// {98C90E90-2BB5-11d3-B390-00C04F6B6167}
static const GUID g_sGuidPreRoutingLink =
{ 0x98c90e90, 0x2bb5, 0x11d3, { 0xb3, 0x90, 0x0, 0xc0, 0x4f, 0x6b, 0x61, 0x67 } };

// {0F5C33F2-B83A-41fa-9BE3-69C6D1314E13}
static const GUID g_sGuidPreSubmissionLink =
{ 0xf5c33f2, 0xb83a, 0x41fa, { 0x9b, 0xe3, 0x69, 0xc6, 0xd1, 0x31, 0x4e, 0x13 } };


#define DMT_FLAGS_SPECIAL_DELIVERY_SPINLOCK   0x80000000
#define DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK   0x40000000

//Bits used to retry GetNextHop after it has failed.  If
//DMT_FLAGS_RESET_ROUTES_IN_PROGRESS is set, then a reset routes attempt is
//in progress, and we should not have more than one attempt pending.  If
//DMT_FLAGS_GET_NEXT_HOP_FAILED is set, then a failure has been encountered
//since the last reset routes.
#define DMT_FLAGS_RESET_ROUTES_IN_PROGRESS    0x20000000
#define DMT_FLAGS_GET_NEXT_HOP_FAILED         0x10000000

//---[ DomainMapping ]---------------------------------------------------------
//
//
//    Hungarian: dmap, pdmap
//
//    unquely identifies a queue / domain name pair.
//    Each Domain mapping that contains the same QueueID, belongs to
//    same queue.
//
//    This entire ID should be treated as an opaque to the outside world.
//
//    This class is essentially an abstraction that can allow us to add another
//    layer of indirection.  Configuration based grouping of queues.... static
//    routing instead of dynamic.
//-----------------------------------------------------------------------------

class CDomainMapping
{
public:
    //removed constructor so we could have this in a union... works fine, but
    //you have to set mapping with manually or via clone
    void Clone(IN CDomainMapping *pdmap);

    //Returns a ptr to the DestMsgQueue associated with this object
    HRESULT HrGetDestMsgQueue(IN CAQMessageType *paqmt,
                              OUT CDestMsgQueue **ppdmq);

    friend   class CDomainEntry;

    //provide sorting operators
    friend bool operator <(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID < pdmap2.m_pdentryDomainID);};
    friend bool operator >(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID > pdmap2.m_pdentryDomainID);};
    friend bool operator <=(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID <= pdmap2.m_pdentryDomainID);};
    friend bool operator >=(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID >= pdmap2.m_pdentryDomainID);};

    //Compressed Queues will not be supported... this will be a sufficient test
    friend bool operator ==(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID == pdmap2.m_pdentryDomainID);};

    CDomainEntry *pdentryGetQueueEntry() {return m_pdentryQueueID;};
protected:
    CDomainEntry *m_pdentryDomainID;
    CDomainEntry *m_pdentryQueueID;
};



//---[ CDomainEntry ]----------------------------------------------------------
//
//
//    Hungarian: dentry pdentry
//
//    Represents a entry in the Domain Name Mapping Table
//-----------------------------------------------------------------------------

class CDomainEntry : public CBaseObject
{
protected:
    DWORD           m_dwSignature;
    CShareLockInst  m_slPrivateData; //Share lock used to maintain lists
    CDomainMapping  m_dmap; //Domain mapping for this domain
    DWORD           m_cbDomainName;
    LPSTR           m_szDomainName; //Domain name for this entry
    DWORD           m_cQueues;
    DWORD           m_cLinks;
    CAQSvrInst     *m_paqinst;
    LIST_ENTRY      m_liDestQueues; //linked list of dest queues for this domain name
    LIST_ENTRY      m_liLinks; //linked list of links for this domain name
    friend class    CDomainEntryIterator;
    friend class    CDomainEntryLinkIterator;
    friend class    CDomainEntryQueueIterator;
public:
    CDomainEntry(CAQSvrInst *paqinst);
    ~CDomainEntry();

    HRESULT HrInitialize(
                DWORD cbDomainName,           //string length of domain name
                LPSTR szDomainName,           //domain name for entry
                CDomainEntry *pdentryQueueID, //primary entry for this domain
                CDestMsgQueue *pdmq,          //queue prt for this entry
                                              //NULL if not primary
                CLinkMsgQueue *plmq);


    HRESULT HrDeinitialize();

    //Returns the Domain Mapping associated with this object
    HRESULT HrGetDomainMapping(OUT CDomainMapping *pdmap);

    //Returns the Domain Name associated with this object
    //Caller is responsible for freeing string
    HRESULT HrGetDomainName(OUT LPSTR *pszDomainName);

    //Returns a ptr to the DestMsgQueue associated with this object
    HRESULT HrGetDestMsgQueue(IN CAQMessageType *paqmt,
                              OUT CDestMsgQueue **ppdmq);

    //Add a queue to this domain entry if one does not already exist for that message type
    HRESULT HrAddUniqueDestMsgQueue(IN  CDestMsgQueue *pdmqNew,
                                    OUT CDestMsgQueue **ppdmqCurrent);

    //Returns a ptr to the DestMsgQueue associated with this object
    HRESULT HrGetLinkMsgQueue(IN CAQScheduleID *paqsched,
                              OUT CLinkMsgQueue **pplmq);

    //Add a queue to this domain entry if one does not already exist for that message type
    HRESULT HrAddUniqueLinkMsgQueue(IN  CLinkMsgQueue *plmqNew,
                                    OUT CLinkMsgQueue **pplmqCurrent);

    void    RemoveDestMsgQueue(IN CDestMsgQueue *pdmq);
    void    RemoveLinkMsgQueue(IN CLinkMsgQueue *plmq);

    //returns internal ptr to domain name... use HrGetDomainName if you
    //are not *directly* tied to the life span of a domain entry
    inline LPSTR szGetDomainName() {return m_szDomainName;};
    inline DWORD cbGetDomainNameLength() {return m_cbDomainName;};

    inline void InitDomainString(PDOMAIN_STRING pDomain);

    //Is it safe to get rid of this domain entry?
    inline BOOL    fSafeToRemove() {
        return (BOOL) ((m_lReferences == 1) &&
                            (m_cQueues == 0) &&
                                (m_cLinks == 0));}
};

//---[ CDomainEntryIterator ]--------------------------------------------------
//
//
//  Description:
//      Base iterator class for domain entry.  Provides a consistent snapshot
//      of the elements of a domain entry
//  Hungarian:
//      deit, pdeit
//
//-----------------------------------------------------------------------------
class CDomainEntryIterator
{
  protected:
    DWORD           m_dwSignature;
    DWORD           m_cItems;
    DWORD           m_iCurrentItem;
    PVOID          *m_rgpvItems;
  protected:
    CDomainEntryIterator();
    PVOID               pvGetNext();
    VOID                Recycle();
    virtual VOID        ReleaseItem(PVOID pvItem)
        {_ASSERT(FALSE && "Base virtual function");};
    virtual PVOID       pvItemFromListEntry(PLIST_ENTRY pli)
        {_ASSERT(FALSE && "Base virtual function");return NULL;};
    virtual PLIST_ENTRY pliHeadFromDomainEntry(CDomainEntry *pdentry)
        {_ASSERT(FALSE && "Base virtual function");return NULL;};
    virtual DWORD       cItemsFromDomainEntry(CDomainEntry *pdentry)
        {_ASSERT(FALSE && "Base virtual function");return 0;};
  public:
    HRESULT     HrInitialize(CDomainEntry *pdentry);
    VOID        Reset() {m_iCurrentItem = 0;};
};

//---[ CDomainEntryLinkIterator ]----------------------------------------------
//
//
//  Description:
//      Implementation of CDomainEntryIterator for CLinkMsgQueues
//  Hungarian:
//      delit, pdelit
//
//-----------------------------------------------------------------------------
class CDomainEntryLinkIterator : public CDomainEntryIterator
{
  protected:
    virtual VOID        ReleaseItem(PVOID pvItem);
    virtual PVOID       pvItemFromListEntry(PLIST_ENTRY pli);
    virtual PLIST_ENTRY pliHeadFromDomainEntry(CDomainEntry *pdentry)
        {return &(pdentry->m_liLinks);};
    virtual DWORD       cItemsFromDomainEntry(CDomainEntry *pdentry)
        {return pdentry->m_cLinks;};
  public:
    ~CDomainEntryLinkIterator() {Recycle();};
    CLinkMsgQueue      *plmqGetNextLinkMsgQueue(CLinkMsgQueue *plmq);
};

//---[ CDomainEntryQueueIterator ]---------------------------------------------
//
//
//  Description:
//      Implementation of CDomainEntryIterator for CDestMsgQueues
//  Hungarian:
//      deqit, pdeqit
//
//-----------------------------------------------------------------------------
class CDomainEntryQueueIterator : public CDomainEntryIterator
{
  protected:
    virtual VOID        ReleaseItem(PVOID pvItem);
    virtual PVOID       pvItemFromListEntry(PLIST_ENTRY pli);
    virtual PLIST_ENTRY pliHeadFromDomainEntry(CDomainEntry *pdentry)
        {return &(pdentry->m_liDestQueues);};
    virtual DWORD       cItemsFromDomainEntry(CDomainEntry *pdentry)
        {return pdentry->m_cQueues;};
  public:
    ~CDomainEntryQueueIterator() {Recycle();};
    CDestMsgQueue      *pdmqGetNextDestMsgQueue(CDestMsgQueue *pdmq);
};

class CDomainMappingTable
{
private:
    DWORD               m_dwSignature;
    DWORD               m_dwInternalVersion; //version # used to keep track of queue deletions
    DWORD               m_dwFlags;
    CAQSvrInst         *m_paqinst;
    DWORD               m_cOutstandingExternalShareLocks; //number of outstanding external sharelocks
    LIST_ENTRY          m_liEmptyDMQHead; //head of list for empty DMQ's
    DWORD               m_cThreadsForEmptyDMQList;
    DOMAIN_NAME_TABLE   m_dnt; //where domain names are actually stored
    CShareLockInst      m_slPrivateData;    //Sharelock for accessing Domain Name Table
    CLocalLinkMsgQueue *m_plmqLocal; //Local link Queue
    CLinkMsgQueue      *m_plmqCurrentlyUnreachable; //link for currently unreachable
    CLinkMsgQueue      *m_plmqUnreachable; //link unreachable destinations
    CMailMsgAdminLink *m_pmmaqPreCategorized; //link for precat queue
    CMailMsgAdminLink *m_pmmaqPreRouting;   //link for prerouting queue
    CMailMsgAdminLink *m_pmmaqPreSubmission;   //link for prerouting queue

    DWORD               m_cSpecialRetryMinutes;

    DWORD               m_cResetRoutesRetriesPending;

    HRESULT             HrInitLocalDomain(
                            IN     CDomainEntry *pdentry, //entry to init
                            IN     DOMAIN_STRING *pStrDomain, //Domain name
                            IN     CAQMessageType *paqmtMessageType,    //Message type as returned by routing
                            OUT    CDomainMapping *pdmap); //domain mapping for domain
    HRESULT             HrInitRemoteDomain(
                            IN     CDomainEntry *pdentry, //entry to init
                            IN     DOMAIN_STRING *pStrDomain, //Domain Name
                            IN     CInternalDomainInfo *pIntDomainInfo,  //domain config
                            IN     CAQMessageType *paqmtMessageType,    //Message type as returned by routing
                            IN     IMessageRouter *pIMessageRouter, //router for this message
                            OUT    CDomainMapping *pdmap, //domain mapping for domain
                            OUT    CDestMsgQueue **ppdmq, //destmsgqueue for domain
                            OUT    CLinkMsgQueue **pplmq);
    HRESULT             HrCreateQueueForEntry(
                            IN     CDomainEntry *pdentry,
                            IN     DOMAIN_STRING *pStrDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     CDomainMapping *pdmap,
                            OUT    CDestMsgQueue **ppdmq);
    HRESULT             HrGetNextHopLink(
                            IN     CDomainEntry *pdentry,
                            IN     LPSTR szDomain,
                            IN     DWORD cbDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     BOOL fDMTLocked,
                            OUT    CLinkMsgQueue **pplmq,
                            OUT    HRESULT *phrRoutingDiag);

    void LogDomainUnreachableEvent(BOOL fCurrentlyUnreachable,
                                      LPCSTR szDomain);

    //Checks head of EMPTY_LIST to see if there are any expired queues
    //or an excesive number of non-empty queues in the list
    BOOL                fNeedToWalkEmptyQueueList();

    //Used to delete expired queues
    BOOL                fDeleteExpiredQueues();

    //Domain Name Table iterator function to move a domain to the currently
    //unreachable link - used for re-routing
    static VOID MakeSingleDomainCurrentlyUnreachable(PVOID pvContext, PVOID pvData,
                                    BOOL fWildcard, BOOL *pfContinue,
                                    BOOL *pfDelete);

    HRESULT HrPrvGetDomainEntry(IN  DWORD cbDomainNameLength,
                                IN  LPSTR szDomainName,
                                IN  BOOL  fDMTLocked,
                                OUT CDomainEntry **ppdentry);

    HRESULT HrInializeGlobalLink(IN  LPCSTR szLinkName,
                                 IN  DWORD  cbLinkName,
                                 OUT CLinkMsgQueue **pplmq,
                                 DWORD dwSupportedActions = 0,
                                 DWORD dwLinkType = 0);

    HRESULT HrDeinitializeGlobalLink(IN OUT CLinkMsgQueue **pplmq);

    HRESULT HrPrvInsertDomainEntry(
                     IN  PDOMAIN_STRING  pstrDomainName,
                     IN  CDomainEntry *pdentryNew,
                     IN  BOOL  fTreatAsWildcard,
                     OUT CDomainEntry **ppdentryOld);

    static void RetryResetRoutes(PVOID pvThis);
    void    RequestResetRoutesRetryIfNecessary();
public:
    CDomainMappingTable();
    ~CDomainMappingTable();
    HRESULT HrInitialize(
        CAQSvrInst *paqinst,
        CAsyncAdminMsgRefQueue *paradmq,
        CAsyncAdminMailMsgQueue *pmmaqPrecatQ,
        CAsyncAdminMailMsgQueue *pmmaqPreRoutingQ,
        CAsyncAdminMailMsgQueue *pmmaqPreSubmission);

    HRESULT HrDeinitialize();

    //Lookup Domain name; This will create a new entry if neccessary.
    HRESULT HrMapDomainName(
                IN LPSTR szDomainName,     //Domain Name to map
                IN CAQMessageType *paqmtMessageType,    //Message type as returned by routing
                IN IMessageRouter *pIMessageRouter, //router for this message
                OUT CDomainMapping *pdmap, //Mapping returned caller allocated
                OUT CDestMsgQueue **ppdmq);//ptr to Queue

    HRESULT HrGetDomainEntry(IN  DWORD cbDomainNameLength,
                             IN  LPSTR szDomainName,
                             OUT CDomainEntry **ppdentry)
    {
        return HrPrvGetDomainEntry(cbDomainNameLength,
                        szDomainName, FALSE, ppdentry);
    }

    HRESULT HrIterateOverSubDomains(DOMAIN_STRING * pstrDomain,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext)
    {
        HRESULT hr = S_OK;
        m_slPrivateData.ShareLock();
        hr = m_dnt.HrIterateOverSubDomains(pstrDomain, pfn, pvContext);
        m_slPrivateData.ShareUnlock();
        return hr;
    };

    // Functions for rerouting domains
    HRESULT HrBeginRerouteDomains();
    HRESULT HrCompleteRerouteDomains();

    // Reroute the queues on a given link
    HRESULT HrRerouteLink(CLinkMsgQueue *plmqReroute);

    HRESULT             HrGetOrCreateLink(
                            IN     LPSTR szRouteAddress,
                            IN     DWORD cbRouteAddress,
                            IN     DWORD dwScheduleID,
                            IN     LPSTR szConnectorName,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     BOOL fCreateIfNotExist,
                            IN     DWORD linkInfoType,
                            OUT    CLinkMsgQueue **pplmq,
                            OUT    BOOL *pfRemoveOwnedSchedule);

    //The following functions are used to check the version number of the DMT.
    //The version number is guananteed remain constant while the DMT Sharelock
    //is held.  While it is not *required* to get lock before getting the
    //version number for the first time, it is required to get the lock (and
    //keep it) while verify that the version number has not changed.  The
    //expected usage of these functions is:
    //DWORD dwDMTVersion = pdmt->dwGetDMTVersion();
    //...
    //pdmt->AquireDMTShareLock();
    //if (pdmt->dwGetDMTVersion() == dwDMTVersion)
    //  ... do stuff that requires consitant DMT version
    //pdmt->ReleaseDMTShareLock();
    inline void  AquireDMTShareLock();
    inline void  ReleaseDMTShareLock();
    inline DWORD dwGetDMTVersion();

    //Used by DestMsgQueue to Add themselves from the empty queue list
    void AddDMQToEmptyList(CDestMsgQueue *pdmq);

    void ProcessSpecialLinks(DWORD  cSpecialRetryMinutes, BOOL fRoutingLockHeld);
    static void SpecialRetryCallback(PVOID pvContext);

    CLinkMsgQueue *plmqGetLocalLink();
    CLinkMsgQueue *plmqGetCurrentlyUnreachable();
    CMailMsgAdminLink *pmmaqGetPreCategorized();
    CMailMsgAdminLink *pmmaqGetPreRouting();
    CMailMsgAdminLink *pmmaqGetPreSubmission();

    HRESULT HrPrepareForLocalDelivery(
                IN CMsgRef *pmsgref,
                IN BOOL fDelayDSN,
                IN OUT CDeliveryContext *pdcntxt,
                OUT DWORD *pcRecips,
                OUT DWORD **prgdwRecips);

    DWORD GetCurrentlyUnreachableTotalMsgCount();
};


//---[ CDomainEntry::InitDomainString ]----------------------------------------
//
//
//  Description:
//      Initialized a domain string based on this domain's info
//  Parameters:
//      pDomain     - ptr to DOMAIN_STRING to initialize
//  Returns:
//      -
//  History:
//      5/26/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainEntry::InitDomainString(PDOMAIN_STRING pDomain)
{
    pDomain->Buffer = m_szDomainName;
    pDomain->Length = (USHORT) m_cbDomainName;
    pDomain->MaximumLength = pDomain->Length;
}

//---[ CDomainMappingTable::AquireDMTShareLock ]-------------------------------
//
//
//  Description:
//      Aquires a share lcok on the DMT's internal lock... must be released
//      with a call to ReleaseDMTShareLock.
//  Parameters:
//
//  Returns:
//
//  History:
//      9/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void  CDomainMappingTable::AquireDMTShareLock()
{
    m_slPrivateData.ShareLock();
    DEBUG_DO_IT(InterlockedIncrement((PLONG) &m_cOutstandingExternalShareLocks));
}

//---[ CDomainMappingTable::ReleaseDMTShareLock ]-------------------------------
//
//
//  Description:
//      Releases a DMT sharelock aquired by AquireDMTShareLock
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void  CDomainMappingTable::ReleaseDMTShareLock()
{
    _ASSERT(m_cOutstandingExternalShareLocks); //Count should not go below 0
    DEBUG_DO_IT(InterlockedDecrement((PLONG) &m_cOutstandingExternalShareLocks));
    m_slPrivateData.ShareUnlock();
}

//---[ CDomainMappingTable::dwGetDMTVersion ]----------------------------------
//
//
//  Description:
//      Returns the internal DMT version number
//  Parameters:
//      -
//  Returns:
//      DMT Version number
//  History:
//      9/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CDomainMappingTable::dwGetDMTVersion()
{
    return m_dwInternalVersion;
}

void ReUnreachableErrorToAqueueError(HRESULT reErr, HRESULT *aqErr);

#endif //_DOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\failmsgq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: failmsgq.cpp
//
//  Description:
//      Implementation of CFailedMsgQueue class.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      1/18/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "failmsgq.h"
#include "aqutil.h"
#include <mailmsgi_i.c>

//---[ IMailMsgAQueueListEntry ]----------------------------------------------
//
//
//  Description:
//      Helper function that gets list entry for message.
//  Parameters:
//      IN  pIMailMsgPropertes      Msg to get list entry for
//  Returns:
//      Pointer to list entry
//  History:
//      1/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQueueFailedListEntry *pfliGetListEntryForMsg(
                                  IMailMsgProperties *pIMailMsgProperties)
{
    HRESULT hr = S_OK;
    AQueueFailedListEntry *pfli = NULL;
    IMailMsgAQueueListEntry *pIMailMsgAQueueListEntry = NULL;

    _ASSERT(pIMailMsgProperties);

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgAQueueListEntry,
                                         (void **) &pIMailMsgAQueueListEntry);

    //This are spec'd to never fail
    _ASSERT(SUCCEEDED(hr));
    _ASSERT(pIMailMsgAQueueListEntry);

    if (pIMailMsgAQueueListEntry)
    {
        hr = pIMailMsgAQueueListEntry->GetListEntry((void **) &pfli);
        _ASSERT(SUCCEEDED(hr));
        _ASSERT(pfli);
        pIMailMsgAQueueListEntry->Release();

        pfli->m_pIMailMsgProperties = pIMailMsgProperties;
        pIMailMsgProperties->AddRef();
    }

    return pfli;
}

//---[ ValidateListEntry ]-----------------------------------------------------
//
//
//  Description:
//      Debug code to do some validation on the list entry pulled off the list
//  Parameters:
//      IN  pfli        list entry struct pulled off of
//  Returns:
//
//  History:
//      1/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
#ifndef DEBUG
#define AQValidateListEntry(x)
#else //is DEBUG
void AQValidateListEntry(AQueueFailedListEntry *pfli)
{
    HRESULT hr = S_OK;
    AQueueFailedListEntry *pfliNew = NULL;
    IMailMsgAQueueListEntry *pIMailMsgAQueueListEntry = NULL;

    _ASSERT(pfli);
    _ASSERT(pfli->m_pIMailMsgProperties);

    hr = pfli->m_pIMailMsgProperties->QueryInterface(IID_IMailMsgAQueueListEntry,
                                         (void **) &pIMailMsgAQueueListEntry);

    //This are spec'd to never fail
    _ASSERT(SUCCEEDED(hr));
    _ASSERT(pIMailMsgAQueueListEntry);
    hr = pIMailMsgAQueueListEntry->GetListEntry((void **) &pfliNew);
    _ASSERT(SUCCEEDED(hr));
    _ASSERT(pfliNew);

    //The list entry returned should be the same one pass into this function
    _ASSERT(pfli == pfliNew);
    pIMailMsgAQueueListEntry->Release();
}
#endif //DEBUG

//---[ CFailedMsgQueue::CFailedMsgQueue ]--------------------------------------
//
//
//  Description:
//      Constuctor for CFailedMsgQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CFailedMsgQueue::CFailedMsgQueue()
{
    m_dwSignature = FAILEDMSGQUEUE_SIG;
    m_cMsgs = 0;
    m_paqinst = NULL;
    m_dwFlags = 0;

    InitializeListHead(&m_liHead);

}

//---[ CFailedMsgQueue::~CFailedMsgQueue ]-------------------------------------
//
//
//  Description:
//      Default destructor for CFailedMsgQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CFailedMsgQueue::~CFailedMsgQueue()
{
    Deinitialize();
}

//---[ CFailedMsgQueue::Initialize ]-------------------------------------------
//
//
//  Description:
//      Initialization routine for CFailedMsgQueue
//  Parameters:
//      IN  paqinst         Ptr to the server instance object
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::Initialize(CAQSvrInst *paqinst)
{
    _ASSERT(paqinst);
    m_paqinst = paqinst;

    if (m_paqinst)
        m_paqinst->AddRef();
}

//---[ CFailedMsgQueue::Deinitialize ]-----------------------------------------
//
//
//  Description:
//      Deinitialization code for CFailedMsgQueue.  Release server instance
//      object.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::Deinitialize()
{
    CAQSvrInst *paqinst = NULL;
    AQueueFailedListEntry *pfli = NULL;

    m_slPrivateData.ExclusiveLock();
    paqinst = m_paqinst;
    m_paqinst = NULL;

    //Loop through list & release messages
    while (!IsListEmpty(&m_liHead))
    {
        pfli = (AQueueFailedListEntry *) m_liHead.Flink;

        _ASSERT(&m_liHead != ((PLIST_ENTRY) pfli));

        _ASSERT(pfli->m_pIMailMsgProperties);

        if (paqinst)
            paqinst->ServerStopHintFunction();

        RemoveEntryList((PLIST_ENTRY)pfli);

        pfli->m_pIMailMsgProperties->Release();
    }
    m_slPrivateData.ExclusiveUnlock();

    if (paqinst)
        paqinst->Release();
}

//---[ CFailedMsgQueue::HandleFailedMailMsg ]----------------------------------
//
//
//  Description:
//      Puts a failed mailmsg in the queue of mailmsgs to retry
//  Parameters:
//      IN  pIMailMsgProperties         MailMsgProperties to try
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::HandleFailedMailMsg(IMailMsgProperties *pIMailMsgProperties)
{
    AQueueFailedListEntry *pfli = NULL;

    if (!pIMailMsgProperties)
    {
        m_slPrivateData.ShareLock();
        if (m_paqinst)
            m_paqinst->DecPendingFailed();
        m_slPrivateData.ShareUnlock();

        return;
    }

    pfli = pfliGetListEntryForMsg(pIMailMsgProperties);

    //If above fails... there is nothing we can do
    _ASSERT(pfli);
    if (!pfli)
        return;

    m_slPrivateData.ExclusiveLock();

    if (!m_paqinst)
    {
        _ASSERT(pfli->m_pIMailMsgProperties);
        pfli->m_pIMailMsgProperties->Release();
        pfli->m_pIMailMsgProperties = NULL;
    }
    else
    {
        InsertTailList(&m_liHead, &(pfli->m_li));
        InterlockedIncrement((PLONG) &m_cMsgs);
    }

    m_slPrivateData.ExclusiveUnlock();

    //Make sure we have a retry pending
    StartProcessingIfNecessary();
}

//---[ CFailedMsgQueue::InternalStartProcessingIfNecessary ]-------------------
//
//
//  Description:
//      Called at various times (ie SubmitMessage) to kick off the processing
//      of Failed Msgs.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::InternalStartProcessingIfNecessary()
{
    CAQSvrInst *paqinst = NULL;
    HRESULT     hr      = S_OK;
    BOOL        fCallbackRequestFailed = FALSE;

    //See if there is work to be done and no one else doing it or scheduled to
    if (!(FMQ_CALLBACK_REQUESTED & m_dwFlags) && m_cMsgs)
    {
        //Try to set the call back bit.... if this thread gets it... arrange for
        //a callback.
        if (!(FMQ_CALLBACK_REQUESTED &
              dwInterlockedSetBits(&m_dwFlags, FMQ_CALLBACK_REQUESTED)))
        {
            //Get Virtual server object in a thread safe manner
            m_slPrivateData.ShareLock();
            paqinst = m_paqinst;
            if (paqinst)
                paqinst->AddRef();
            m_slPrivateData.ShareUnlock();

            //Only worry about trying if we have a virtual server object.
            if (paqinst)
            {
                //Retry in 5 minutes
                hr = paqinst->SetCallbackTime(
                               CFailedMsgQueue::ProcessEntriesCallback,
                               this, 5);
                if (FAILED(hr))
                    fCallbackRequestFailed = TRUE;
            }
            else
            {
                fCallbackRequestFailed = TRUE;
            }

        }
    }

    //We failed to request a callback... unset the flag, so another thread 
    //can try
    if (fCallbackRequestFailed)
        dwInterlockedUnsetBits(&m_dwFlags, FMQ_CALLBACK_REQUESTED);

    if (paqinst)
        paqinst->Release();
}

//---[ CFailedMsgQueue::ProcessEntries ]---------------------------------------
//
//
//  Description:
//      Walks queues of failed IMailMsgs and proccesses them for retry
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::ProcessEntries()
{
    DWORD   cMsgsToProcess = m_cMsgs; //Only walk list once.
    HRESULT hr = S_OK;
    AQueueFailedListEntry *pfli = NULL;
    CAQSvrInst *paqinst = NULL;

    //There should only be 1 thread processing entries, and we should have
    //set the bit
    _ASSERT(FMQ_CALLBACK_REQUESTED & m_dwFlags);

    m_slPrivateData.ExclusiveLock();

    paqinst = m_paqinst;
    if (paqinst)
    {
        paqinst->AddRef();

        while (!IsListEmpty(&m_liHead) && cMsgsToProcess-- && m_paqinst)
        {
            pfli = (AQueueFailedListEntry *) m_liHead.Flink;

            _ASSERT(&m_liHead != ((PLIST_ENTRY) pfli));

            RemoveEntryList((PLIST_ENTRY)pfli);

            m_slPrivateData.ExclusiveUnlock();

            //Verify that pli we have now is the same as what the interface
            //returns
            AQValidateListEntry(pfli);

            paqinst->DecPendingFailed();
            InterlockedDecrement((PLONG) &m_cMsgs);
            hr = paqinst->HrInternalSubmitMessage(pfli->m_pIMailMsgProperties);
            if (FAILED(hr) && (AQUEUE_E_SHUTDOWN != hr) && 
                paqinst->fShouldRetryMessage(pfli->m_pIMailMsgProperties))
            {
                HandleFailedMailMsg(pfli->m_pIMailMsgProperties);
            }

            pfli->m_pIMailMsgProperties->Release();

            //Should be lock when we hit top of loop
            m_slPrivateData.ExclusiveLock();
        }

        paqinst->Release();
        paqinst = NULL;
    }

    m_slPrivateData.ExclusiveUnlock();


}

//---[ CFailedMsgQueue::ProcessEntries ]---------------------------------------
//
//
//  Description:
//      Static function that is used as a retry callback for ProcessEntries.
//  Parameters:
//      IN  pvContext           This ptr of CFailedMsgQueue object
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::ProcessEntriesCallback(PVOID pvContext)
{
    CFailedMsgQueue *pfmq = (CFailedMsgQueue *) pvContext;

    _ASSERT(pfmq);
    _ASSERT(FAILEDMSGQUEUE_SIG == pfmq->m_dwSignature);

    if (pfmq && (FAILEDMSGQUEUE_SIG == pfmq->m_dwSignature))
    {
        pfmq->ProcessEntries();
        _ASSERT(FMQ_CALLBACK_REQUESTED & (pfmq->m_dwFlags));
        dwInterlockedUnsetBits(&(pfmq->m_dwFlags), FMQ_CALLBACK_REQUESTED);
        pfmq->StartProcessingIfNecessary();
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\fifoqimp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: fifoqimp.h
//
//  Description: Implementation for Fifo Queue template
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <fifoq.h>

#define FIFOQ_ASSERT_QUEUE
//#define SHARELOCK_TRY_BROKEN

//some constants used
const DWORD FIFOQ_QUEUE_PAGE_SIZE       = 127; //number of entires per page
const DWORD FIFOQ_QUEUE_MAX_FREE_PAGES  = 200; //maximum # of free pages kept

//$$REVIEW: It might be nice to pick a size that is page size friendly
//  Current of objects is
//      sizeof(PVOID) + sizeof(PVOID)*FIFOQ_QUEUE_PAGE_SIZE = 512 bytes

//---[ CFifoQueuePage ]--------------------------------------------------------
//
//
//  Hungarian: fqp, pfqp
//
//  Single page of a FIFO queue.  Most operations are handled within the actual
//  CFifoQueue class.  FQPAGE is a typedef for this template class within
//  the scope of the CFifoQueue class
//-----------------------------------------------------------------------------
template<class PQDATA>
class CFifoQueuePage
{
public:
    friend class CFifoQueue<PQDATA>;
    CFifoQueuePage() {Recycle();};
protected:
    inline void Recycle();
    inline bool FIsOutOfBounds(IN PQDATA *ppqdata);
    CFifoQueuePage<PQDATA>  *m_pfqpNext;  //Next page in linked list
    CFifoQueuePage<PQDATA>  *m_pfqpPrev;  //previous page in linked list
    PQDATA                   m_rgpqdata[FIFOQ_QUEUE_PAGE_SIZE];
#ifdef FIFOQ_ASSERT_QUEUE
    //# of entries on this page that have been removed out of order
    //- Used in assertion routines
    DWORD                   m_cHoles;
#endif //FIFOQ_ASSERT_QUEUE
};

//---[ CFifoQueuePage::Recycle ]-----------------------------------------------
//
//
//  Description:
//      Performs initialization of a page.  Called when a page is created as
//      well as when it is retrieved from the free list
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
template<class PQDATA>
void CFifoQueuePage<PQDATA>::Recycle()
{
    m_pfqpNext = NULL;
    m_pfqpPrev = NULL;
#ifdef FIFOQ_ASSERT_QUEUE
    m_cHoles = 0;
#endif //FIFOQ_ASSERT_QUEUE
}

//---[ CFifoQueuePage::FIsOutOfBounds ]----------------------------------------
//
//
//  Description:
//      Tests to see if a PQDATA ptr is within range of this page
//  Parameters:
//      IN ppqdata - PQDATA ptr to test
//  Returns:
//      TRUE if in bounds
//      FALSE if ptr is out of bounds
//-----------------------------------------------------------------------------
template<class PQDATA>
bool CFifoQueuePage<PQDATA>::FIsOutOfBounds(PQDATA *ppqdata)
{
    return ((ppqdata < m_rgpqdata) ||
            ((m_rgpqdata + (FIFOQ_QUEUE_PAGE_SIZE-1)) < ppqdata));
}

#ifdef DEBUG
#ifdef FIFOQ_ASSERT_QUEUE

//---[ CFifoQueue::AssertQueueFn() ]-------------------------------------------
//
//
//  Description:
//      Perform some rather involved validation of the queue.  Including:
//          - Check Head and Tail page to make sure they conform various
//              retrictions of our data structure
//          - Check count to make sure it reflects data
//      At some point we may wish to add further checking (ie walking the linked
//      list in both directions to validate it).
//  Parameters:
//      fHaveLocks - set to true if the caller has both the head and tail locked
//                   Default value is FALSE.
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
template <class PQDATA>
void CFifoQueue<PQDATA>::AssertQueueFn(BOOL fHaveLocks)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::AssertQueue");
    FQPAGE *pfqpTmp  = NULL; //used to count entries
    DWORD   cEntries = 0;    //what we think count should be

    _ASSERT(FIFOQ_SIG == m_dwSignature);
    //include text in assert, to have it appear in dialog box (if applicable)
    if (!fHaveLocks)
    {
        m_slHead.ShareLock();
        m_slTail.ShareLock();
    }
    if ((m_pfqpHead != NULL) && (NULL != m_pfqpHead->m_pfqpPrev))
    {
        //If Head is not NULL, it should not have a pervious page
        DebugTrace((LPARAM) this, "Queue Assert: Head's Previous ptr is non-NULL");
        Assert(0 && "Queue Assert: Head's Previous is non-NULL");
    }

    if ((m_pfqpTail != NULL) && (NULL != m_pfqpTail->m_pfqpNext))
    {
        //If Tail is not NULL, it should not have a next page
        DebugTrace((LPARAM) this, "Queue Assert: Tail's Next ptr is non-NULL");
        Assert(0 && "Queue Assert: Tail's Next is non-NULL");
    }

    if ((m_pfqpHead != NULL) && (m_pfqpTail != NULL))
    {
        Assert(m_ppqdataTail);
        Assert(m_ppqdataHead);

        if (m_pfqpHead != m_pfqpTail)
        {
            // If Tail and Head are non-NULL and not equal to each other, then they
            // must have non-NULL Prev and Next ptrs (respectively).
            if (NULL == m_pfqpTail->m_pfqpPrev)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Tail's Prev ptr is NULL, Head != Tail");
                Assert(0 && "Queue Assert: Tail's Prev ptr is NULL, Head != Tail");
            }
            if (NULL == m_pfqpHead->m_pfqpNext)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Head's Next ptr is NULL, Head != Tail");
                Assert(0 && "Queue Assert: Head's Next ptr is NULL, Head != Tail");
            }

            //Check count when Head and Tail differ
            pfqpTmp = m_pfqpTail->m_pfqpPrev;
            while (NULL != pfqpTmp)
            {
                cEntries += FIFOQ_QUEUE_PAGE_SIZE - pfqpTmp->m_cHoles;
                pfqpTmp = pfqpTmp->m_pfqpPrev;
            }
            cEntries += (DWORD)(m_ppqdataTail - m_pfqpTail->m_rgpqdata); //tail page
            cEntries -= m_pfqpTail->m_cHoles;
            cEntries -= (DWORD)(m_ppqdataHead - m_pfqpHead->m_rgpqdata); //head page
            if (cEntries != m_cQueueEntries)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Count is %d when it should be %d",
                    m_cQueueEntries, cEntries);
                Assert(0 && "Queue Assert: Entry Count is inaccurate");
            }
        }
        else //Head and Tail are same
        {
            Assert(m_pfqpHead == m_pfqpTail);
            cEntries = (DWORD)(m_ppqdataTail - m_ppqdataHead) - m_pfqpTail->m_cHoles;
            if (cEntries != m_cQueueEntries)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Count is %d when it should be %d",
                    m_cQueueEntries, cEntries);
                Assert(0 && "Queue Assert: Entry Count is inaccurate");
            }
        }
    }
    else if ((m_pfqpHead != NULL) && (m_pfqpTail == NULL))
    {
        //If Tail is NULL, then Head should be as well
        DebugTrace((LPARAM) this, "Queue Assert: Tail is NULL while Head is non-NULL");
        Assert(0 && "Queue Assert: Tail is NULL while Head is non-NULL");
    }
    else if (m_pfqpTail != NULL)
    {
        Assert(m_pfqpHead == NULL);  //should fall out of if/else
        if (NULL == m_pfqpTail->m_pfqpPrev)
        {
            //count is easy here :)
            if (m_cQueueEntries != (size_t) (m_ppqdataTail - m_pfqpTail->m_rgpqdata))
            {
                DebugTrace((LPARAM) this, "Queue Assert: Count is %d when it should be %d",
                    m_cQueueEntries, (m_ppqdataTail - m_pfqpTail->m_rgpqdata));
                Assert(0 && "Queue Assert: Entry Count is inaccurate");
            }
        }
        else //there is more than 1 page, but head is still NULL
        {
            pfqpTmp = m_pfqpTail->m_pfqpPrev;
            while (NULL != pfqpTmp)
            {
                cEntries += FIFOQ_QUEUE_PAGE_SIZE - pfqpTmp->m_cHoles;
                pfqpTmp = pfqpTmp->m_pfqpPrev;
            }
            cEntries += (DWORD)(m_ppqdataTail - m_pfqpTail->m_rgpqdata) - m_pfqpTail->m_cHoles;
            if (cEntries != m_cQueueEntries)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Count is %d when it should be %d",
                    m_cQueueEntries, cEntries);
                Assert(0 && "Queue Assert: Entry Count is inaccurate");
            }
        }
    }
    else //both head and tail are NULL
    {
        Assert((m_pfqpHead == NULL) && (m_pfqpTail == NULL)); //falls out of if/else
        if (m_cQueueEntries != 0)
        {
            //If both Head and Tail are NULL, them m_cQueueEntries == 0
            DebugTrace((LPARAM) this,
                "Queue Assert: Entry Counter is %d when queue should be empty",
                m_cQueueEntries);
            Assert(0 && "Queue Assert: Entry Counter is non-zero when queue should be empty");
        }
    }


    if (!fHaveLocks) //we aquired the locks in this function
    {
        m_slTail.ShareUnlock();
        m_slHead.ShareUnlock();
    }

    TraceFunctLeave();

}

#define AssertQueue() AssertQueueFn(FALSE)
#define AssertQueueHaveLocks() AssertQueueFn(TRUE)
#else //FIFOQ_ASSERT_QUEUE
#define AssertQueue()
#define AssertQueueHaveLocks()
#endif //FIFOQ_ASSERT_QUEUE
#else //not DEBUG
#define AssertQueue()
#define AssertQueueHaveLocks()
#endif //DEBUG

//---[ CFifoQueue Static Variables ]-------------------------------------------
template <class PQDATA>
volatile CFifoQueuePage<PQDATA> *CFifoQueue<PQDATA>::s_pfqpFree = NULL;

template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cFreePages = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cFifoQueueObj = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cStaticRefs = 0;
template <class PQDATA>
CRITICAL_SECTION   CFifoQueue<PQDATA>::s_csAlloc;

#ifdef DEBUG
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cAllocated = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cDeleted = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cFreeAllocated = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cFreeDeleted = 0;
#endif //DEBUG

//---[ CFifoQueue::CFifoQueue ]------------------------------------------------
//
//
//  Description: CFifoQueue constructor
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
template <class PQDATA>
CFifoQueue<PQDATA>::CFifoQueue<PQDATA>()
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::CFifoQueue");

    m_dwSignature   = FIFOQ_SIG;
    m_cQueueEntries = 0;    //set count of entries to 0
    m_pfqpHead      = NULL; //Initialize page pointers
    m_pfqpTail      = NULL;
    m_pfqpCursor    = NULL;
    m_ppqdataHead   = NULL; //Initialize data pointers
    m_ppqdataTail   = NULL;
    m_ppqdataCursor = NULL;

    InterlockedIncrement((PLONG) &s_cFifoQueueObj);
    TraceFunctLeave();
}

//---[ CFifoQueue::~CFifoQueue ]------------------------------------------------
//
//
//  Description: CFifoQueue destructor
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
template <class PQDATA>
CFifoQueue<PQDATA>::~CFifoQueue<PQDATA>()
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::~CFifoQueue");
    FQPAGE *pfqpTmp = NULL;

    if (m_cQueueEntries != 0)
    {
        PQDATA pqdata = NULL;
        int iLeft = m_cQueueEntries;

        for (int i = iLeft; i > 0; i--)
        {
            if (FAILED(HrDequeue(&pqdata)))
                break;
            Assert(NULL != pqdata);
            pqdata->Release();
        }
    }

    while (m_pfqpHead)
    {
        //If last dequeue could not delete page, then make sure pages
        //are freed
        pfqpTmp = m_pfqpHead->m_pfqpNext;
        FreeQueuePage(m_pfqpHead);
        m_pfqpHead = pfqpTmp;
    }

    InterlockedDecrement((PLONG) &s_cFifoQueueObj);

    TraceFunctLeave();
}

//---[ CFifoQueue::StaticInit() ]--------------------------------------------
//
//
//  Description: Initialization routines for CFifoQueue.  This
//      is excplcitly single threaded.  The limitations are:
//              - Only one thread in this function
//              - You cannot use any queues until this has completed
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
template <class PQDATA>
void CFifoQueue<PQDATA>::StaticInit()
{
    TraceFunctEnter("CFifoQueue::HrStaticInit()");
    DWORD   cRefs = 0;

    //
    //  Add a static ref for each call to this
    //
    cRefs = InterlockedIncrement((PLONG) &s_cStaticRefs);

    if (1 == cRefs)
    {
        InitializeCriticalSection(&s_csAlloc);
    }

    //
    //  Catch unsafe callers
    //
    _ASSERT(cRefs == s_cStaticRefs);

    TraceFunctLeave();
}

//---[ CFifoQueue::StaticDeinit() ]------------------------------------------
//
//
//  Description: Deinitialization routines for CFifoQueue
//
//  Parameters: -
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
template <class PQDATA>
void  CFifoQueue<PQDATA>::StaticDeinit()
{
    TraceFunctEnter("CFifoQueue::HrStaticDeinit()");
    LONG    lRefs   = 0;
    lRefs = InterlockedDecrement((PLONG) &s_cStaticRefs);
    DWORD   cLost   = 0;
    DEBUG_DO_IT(cLost = s_cAllocated - s_cDeleted - s_cFreePages);


    if (lRefs == 0)
    {
        if (0 != cLost)
            ErrorTrace((LPARAM) NULL, "ERROR: CFifoQueue Deinit with %d Lost Pages", cLost);

        //This assert will catch if the any queue pages were allocated but not freed
        _ASSERT(!cLost && "We are leaking some queue pages");

        //There should be no other threads calling into this
        //note quite true, there are still outstanding refs at the time
        FQPAGE  *pfqpCur =  (FQPAGE *) s_pfqpFree;
        while (NULL != pfqpCur)
        {
            s_pfqpFree = pfqpCur->m_pfqpNext;
            delete pfqpCur;
            pfqpCur = (FQPAGE *) s_pfqpFree;
            s_cFreePages--;

            //It is possible to stop all server instances without
            //unloading the DLL.  The cLost Assert will fire on the next
            //shutdown if we don't increment the deleted counter as well...
            //even though we aren't leaking any pages.
            DEBUG_DO_IT(s_cDeleted++);

        }
        //This assert catches if there are any free pages left after we walk the list
        Assert(s_cFreePages == 0);

        DeleteCriticalSection(&s_csAlloc);
    }

    TraceFunctLeave();
}

//---[ CFifoQueue::HrEnqueue ]-------------------------------------------------
//
//
//  Description: Enqueue a new item to the tail of the queue
//
//  Parameters:
//      IN PQDATA pqdata    Data to enqueue
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate page
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrEnqueue(IN PQDATA pqdata)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrEnqueue");
    HRESULT hr      = S_OK;
    FQPAGE *pfqpNew = NULL;  //newly allocated page

    AssertQueue();
    Assert(pqdata);
    pqdata->AddRef();

    m_slTail.ExclusiveLock();

    if ((m_pfqpTail == NULL) || //Queue is empty or needs a new queue page
        (m_pfqpTail->FIsOutOfBounds(m_ppqdataTail)))
    {
        //assert that tail is NULL or 1 past end of previous tail page
        Assert((m_ppqdataTail == NULL) || (m_ppqdataTail == (m_pfqpTail->m_rgpqdata + FIFOQ_QUEUE_PAGE_SIZE)));
        Assert((m_cQueueEntries == 0) || (m_pfqpTail != NULL));

        hr = HrAllocQueuePage(&pfqpNew);
        if (FAILED(hr))
            goto Exit;

        Assert(pfqpNew);

        if (NULL != m_pfqpTail)  //Update Next & prev ptr if not first page
        {
            Assert(NULL == m_pfqpTail->m_pfqpNext);
            m_pfqpTail->m_pfqpNext = pfqpNew;
            pfqpNew->m_pfqpPrev = m_pfqpTail;
        }
#ifndef SHARELOCK_TRY_BROKEN
        else {
            if (m_slHead.TryExclusiveLock())
            {
                //can update head stuff with impunity
                m_pfqpHead = pfqpNew;
                m_ppqdataHead = pfqpNew->m_rgpqdata;
                m_slHead.ExclusiveUnlock();
            }
            //else requeue or MapFn has lock
        }
#endif //SHARELOCK_TRY_BROKEN
        m_pfqpTail = pfqpNew;
        m_ppqdataTail = pfqpNew->m_rgpqdata;

    }

    Assert(!m_pfqpTail->FIsOutOfBounds(m_ppqdataTail));
    Assert(m_ppqdataTail);

    *m_ppqdataTail = pqdata;
    m_ppqdataTail++;

    //increment count
    InterlockedIncrement((PLONG) &m_cQueueEntries);

    m_slTail.ExclusiveUnlock();

  Exit:
    AssertQueue();
    if (FAILED(hr))
        pqdata->Release();
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrDequeue ]-------------------------------------------------
//
//
//  Description: Dequeue an item from the queue
//
//  Parameters:
//      OUT PQDATA *ppqdata Data dequeued
//
//  Returns:
//      S_OK on success
//      AQUEUE_E_QUEUE_EMPTY if the queue is empty
//      E_NOTIMPL if fPrimary is FALSE (for now)
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrDequeue(OUT PQDATA *ppqdata)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrDequeue");
    HRESULT hr = S_OK;

    AssertQueue();
    Assert(ppqdata);

    if (m_cQueueEntries == 0)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }


    m_slHead.ExclusiveLock();

    hr = HrAdjustHead();
    if (FAILED(hr))
    {
        m_slHead.ExclusiveUnlock();
        goto Exit;
    }

    *ppqdata = *m_ppqdataHead;
    *m_ppqdataHead = NULL;

    InterlockedDecrement((PLONG) &m_cQueueEntries);

    m_ppqdataHead++;  //If it crosses page boundary, then HrAdjustQueue
                      //will fix it on next dequeue

#ifndef SHARELOCK_TRY_BROKEN
    //Deal with brand new way of deleting last page
    if ((m_cQueueEntries == 0) && (m_slTail.TryExclusiveLock()))
    {
        //If we cannot access tail ptr, the enqueue in progress and
        //we should not delete the page they are enqueueing on
        if (m_cQueueEntries == 0) //gotta be thread safe
        {
            Assert(m_pfqpHead == m_pfqpTail);

            m_pfqpTail = NULL;
            m_ppqdataTail = NULL;

            m_slTail.ExclusiveUnlock();

            m_ppqdataHead = NULL;

            FreeQueuePage(m_pfqpHead);
            m_pfqpHead = NULL;
        }
        else
            m_slTail.ExclusiveUnlock();

    }
#endif //SHARELOCK_TRY_BROKEN

    m_slHead.ExclusiveUnlock();

  Exit:
    AssertQueue();

    if (FAILED(hr))
        *ppqdata = NULL;
#ifdef DEBUG
    else
        Assert(NULL != *ppqdata);
#endif //DEBUG

    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrRequeue ]--------------------------------------------------
//
//
//  Description:
//      Requeues a message to the head of the queue (like an enqueue that occurs
//      at the head.
//
//  Parameters:
//      IN PQDATA pqdata  data to be enqueued
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if an allocation error occurs
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrRequeue(IN PQDATA pqdata)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrRequeue");
    HRESULT  hr             = S_OK;
    PQDATA  *ppqdataNewHead = NULL;
    BOOL     fHeadLocked    = FALSE;

    AssertQueue();
    Assert(pqdata);
    pqdata->AddRef();

    m_slHead.ExclusiveLock();
    fHeadLocked = TRUE;
    ppqdataNewHead = m_ppqdataHead - 1;

    //There are 2 cases to worry about here
    //  CASE 0: Head page is NULL - Either Queue is empty, or head has not
    //      been updated yet... may be changed into CASE 2 if queue non-empty
    //  CASE 1: Head page is valid and decremented Headptr is on a Head page
    //      In this case, the data can be requeued. Having m_slHead will make
    //      sure that the Head Page is not deleted from underneath us
    //  CASE 2: New Head ptr is invalid.  We need to allocate a new page to
    //      put requeued data on.

    if (NULL == m_pfqpHead)
    {
        //CASE 0
        hr = HrAdjustHead();
        if (FAILED(hr))
        {
            if (AQUEUE_E_QUEUE_EMPTY == hr)
            {
                //Queue is empty... just enqueue
                //But first, release head lock so enqueue has can allocate
                //first page etc....  Otherwise, we would guarantee failure
                //of enqueue TryExlusiveLock and for HrAdjustHead to do the
                //work next time.
                m_slHead.ExclusiveUnlock();
                fHeadLocked = FALSE;

                hr = HrEnqueue(pqdata);
                if (SUCCEEDED(hr))
                    pqdata->Release();
            }

            goto Exit;
        }
        //else will fall through to case 2
    }

    if ((m_pfqpHead != NULL) && !m_pfqpHead->FIsOutOfBounds(ppqdataNewHead))
    {
        //CASE 1
        *ppqdataNewHead = pqdata;
        m_ppqdataHead = ppqdataNewHead;
    }
    else
    {
        //CASE 2
        FQPAGE *pfqpNew = NULL;

        hr = HrAllocQueuePage(&pfqpNew);
        if (FAILED(hr))
            goto Exit;

        //make sure next points to the  head page
        pfqpNew->m_pfqpNext = m_pfqpHead;

        //prev needs to point to the new page
        if (m_pfqpHead)
            m_pfqpHead->m_pfqpPrev = pfqpNew;

        m_pfqpHead = pfqpNew;

        //write the data & update local copy of head
        m_ppqdataHead = &(pfqpNew->m_rgpqdata[FIFOQ_QUEUE_PAGE_SIZE-1]);
        *m_ppqdataHead = pqdata;

    }

    InterlockedIncrement((PLONG) &m_cQueueEntries);

  Exit:
    if (fHeadLocked)
        m_slHead.ExclusiveUnlock();
    AssertQueue();

    if (FAILED(hr))
        pqdata->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrPeek ]-----------------------------------------------------
//
//
//  Description:
//      Peeks at the head data on the queue.
//  Parameters:
//      OUT PQDATA *ppqdata   returned data
//  Returns:
//      S_OK on success
//      AQUEUE_E_QUEUE_EMPTY if the queue has no data in it
//      possibly E_FAIL or E_OUTOFMEMORY if one of the supporting functions fail
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrPeek(OUT PQDATA *ppqdata)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrPeek");
    HRESULT hr            = S_OK;

    AssertQueue();
    Assert(ppqdata);

    if (m_cQueueEntries == 0)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    m_slHead.ExclusiveLock();

    hr = HrAdjustHead();
    if (FAILED(hr))
        goto Exit;

    *ppqdata = *m_ppqdataHead;
    (*ppqdata)->AddRef();

  Exit:
    m_slHead.ExclusiveUnlock();
    AssertQueue();
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrMapFn ]---------------------------------
//
//
//  Description:
//      Advances a secondary cursor until supplied function  returns FALSE
//  Parameters:
//      IN  pFunc - must be a function with the following prototype:
//
//          HRESULT pvFunc(
//                          IN  PQDATA pqdata,  //ptr to data on queue
//                          IN  PVOID pvContext,
//                          OUT BOOL *pfContinue, //TRUE if we should continue
//                          OUT BOOL *pfDelete);  //TRUE if item should be deleted
//      pvFunc must NOT release pqdata.. if it is no longer valid, it should
//      return TRUE in pfDelete, and the calling code will remove it from
//      the queue and release it.
//
//      OUT pcItems - count of queue items removed from queue
//
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pvFunc is not valid
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrMapFn(
              IN MAPFNAPI pFunc,
              IN PVOID pvContext,
              OUT DWORD *pcItems)
{
    //$$TODO: Test the context handle feature
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrMapFn");
    HRESULT  hr               = S_OK;
    FQPAGE  *pfqpCurrent      = NULL;   //The current page we are looking at
    FQPAGE  *pfqpTmp          = NULL;
    PQDATA  *ppqdataCurrent   = NULL;   //The current queue data we are looking at
    PQDATA  *ppqdataLastValid = NULL;   //The last non-NULL queue data
    DWORD    cItems           = 0;
    BOOL     fPageInUse       = FALSE;
    BOOL     fContinue        = FALSE;
    BOOL     fDelete          = FALSE;
    BOOL     fLocked          = FALSE;

    //Variables that make it easier to debug this function
    PQDATA  *ppqdataOldTail   = NULL;
    PQDATA  *ppqdataOldHead   = NULL;

    if (NULL != pcItems)
        *pcItems = 0;

    if (NULL == pFunc)  //$$REVIEW - more validation than this?
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (0 == m_cQueueEntries) //don't even bother if nothing is in the queue
        goto Exit;

    m_slHead.ExclusiveLock();
    m_slTail.ExclusiveLock();

    fLocked = TRUE;
    DebugTrace((LPARAM) this, "MapFn Has Exclusive Locks");

    //make sure that head pointer is adjusted properly
    hr = HrAdjustHead();
    if (FAILED(hr))
    {
        _ASSERT((AQUEUE_E_QUEUE_EMPTY == hr) && "HrAdjustHead failed without AQUEUE_E_QUEUE_EMPTY!!!!");
        hr = S_OK;
    }

    AssertQueueHaveLocks();

    pfqpCurrent = m_pfqpHead;  //start at head and work backwards
    ppqdataCurrent = m_ppqdataHead;

    _ASSERT(pfqpCurrent || !m_cQueueEntries);

    while (NULL != pfqpCurrent)
    {
        DEBUG_DO_IT(ppqdataOldTail = m_ppqdataTail);
        DEBUG_DO_IT(ppqdataOldHead = m_ppqdataHead);

        if (m_cQueueEntries == 0)
        {
            Assert(m_pfqpHead == m_pfqpTail);
            Assert(m_pfqpHead == pfqpCurrent);
            m_pfqpHead = NULL;
            m_pfqpTail = NULL;
            m_ppqdataHead = NULL;
            m_ppqdataTail = NULL;
            FreeQueuePage(pfqpCurrent);
            pfqpCurrent = NULL;
            goto Exit;
        }

        if (pfqpCurrent->FIsOutOfBounds(ppqdataCurrent) ||
            ((m_pfqpTail == pfqpCurrent) && (ppqdataCurrent >= m_ppqdataTail)))
        {
            //We are ready to set pfqpCurrent to point to the next page.. may need to
            //free the old page.

            if (fPageInUse)
            {
                //don't delete the page if there is still something on there
                pfqpCurrent = pfqpCurrent->m_pfqpNext;
            }
            else
            {
                pfqpTmp = pfqpCurrent->m_pfqpNext;
                if (NULL != pfqpTmp)
                    pfqpTmp->m_pfqpPrev = pfqpCurrent->m_pfqpPrev;
                else
                {
                    Assert(pfqpCurrent == m_pfqpTail); //It must be the tail

                    //point the tail to the next page
                    m_pfqpTail = m_pfqpTail->m_pfqpPrev;
                    m_ppqdataTail = ppqdataLastValid + 1;
                    //If last page was not deleted, then the last valid ptr should be on it
                    Assert((NULL == m_pfqpTail) || !m_pfqpTail->FIsOutOfBounds(ppqdataLastValid));
#ifdef FIFOQ_ASSERT_QUEUE
                    //fixup Hole count
                    //will not touch count if Tail ptr is after end of tail page
                    for (PQDATA *ppqdataTmp = m_ppqdataTail;
                         ppqdataTmp < m_pfqpTail->m_rgpqdata + FIFOQ_QUEUE_PAGE_SIZE;
                         ppqdataTmp++)
                    {
                        if (NULL == *ppqdataTmp)
                            m_pfqpTail->m_cHoles--;
                    }
#endif //FIFOQ_ASSERT_QUEUE
                    ppqdataLastValid = NULL;
                }

                if (NULL != pfqpCurrent->m_pfqpPrev)
                {
                    Assert(pfqpCurrent->m_pfqpPrev->m_pfqpNext == pfqpCurrent);
                    pfqpCurrent->m_pfqpPrev->m_pfqpNext = pfqpTmp;
                }
                else
                {
                    //if it does not have a prev pointer is should be the head
                    Assert(pfqpCurrent == m_pfqpHead);
                    Assert(NULL == pfqpCurrent->m_pfqpPrev);
                    if (m_pfqpTail == m_pfqpHead) //be sure to make tail valid
                    {
                        Assert(0); //the 1st if/else now handles this
                    }
                    m_pfqpHead = pfqpTmp;
                    m_ppqdataHead = m_pfqpHead->m_rgpqdata;
                }

                AssertQueueHaveLocks();//try to see what has happened before freeing
                FreeQueuePage(pfqpCurrent);
                pfqpCurrent = pfqpTmp;
                if (NULL != m_pfqpHead) {
                    Assert(NULL == m_pfqpHead->m_pfqpPrev);
                }

                AssertQueueHaveLocks();


            }
            if (NULL == pfqpCurrent)
                break;
            ppqdataCurrent = pfqpCurrent->m_rgpqdata;
            fPageInUse = FALSE;
        }

        Assert(ppqdataCurrent);  //the above should guarantee this

        if (NULL != *ppqdataCurrent)
        {
            hr = pFunc(*ppqdataCurrent, pvContext, &fContinue, &fDelete);
            if (FAILED(hr))
                goto Exit;

            if (fDelete)
            {
                InterlockedDecrement((PLONG) &m_cQueueEntries);
                (*ppqdataCurrent)->Release();
                *ppqdataCurrent = NULL;
#ifdef FIFOQ_ASSERT_QUEUE
                pfqpCurrent->m_cHoles++;  //adjust Hole counter for assertions
#endif //FIFOQ_ASSERT_QUEUE
                cItems++;
            }
            else
            {
                fPageInUse = TRUE;
                ppqdataLastValid = ppqdataCurrent;
            }
            if (!fContinue)
                break;
        }
        ppqdataCurrent++;
    }


  Exit:
    if (fLocked)
    {
        AssertQueueHaveLocks();
        m_slTail.ExclusiveUnlock();
        m_slHead.ExclusiveUnlock();
    }
    else
    {
        AssertQueue();
    }

    if (NULL != pcItems)
        *pcItems = cItems;
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrAdjustHead ]----------------------------------------------
//
//
//  Description:
//      Adjust Head ptr and Head Page ptr if necessary for pending dequeue or
//      peek.  To keep operations thread-safe, you MUST have the head lock
//
//      This function is used because there are many operations that may leave
//      the head page/ptr in an inconsistant state, but very few that actually
//      need them to be consistant.  Rather than running the risk of missing
//      a case where the head ptr is inconsistant, we call this function when
//      we need them to be consistant
//
//      Head page and head ptr may be updated as a side-effect
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      AQUEUE_E_QUEUE_EMPTY if the queue is empty (or becomes empty)
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrAdjustHead()
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrAdjustHead");
    HRESULT hr = S_OK;

    //AssertQueue(); // the locks we are using are not re-entrant.

    //Make sure that something hasn't been dequeued from underneath us
    //at least from our perception of the ptrs
    if (m_cQueueEntries == 0)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    while (TRUE) //handle holes in queue (marked as NULL ptrs)
    {
        //now find an appropriate value for the head ptr
        //  Case 0: if Head Page is NULL, then find first page by searching from
        //          Tail page. This case happens when the queue is truely empty
        //          or first enqueue could not get Tail lock.
        //  Case 1: if Head data pointer is NULL, or invalid and not just
        //          past end of head page, then set it to first thing on
        //          head page.
        //
        //          $$REVIEW - I don't think there are any cases that
        //          can cause (and not case 0).  I will put an assert in to
        //          make sure this is truely the case.
        //  Case 2: if just past end of page, attempt to update head page,
        //          and set to first thing on new head page. This means
        //          that the last item on that page has been dequeued.
        //  Case 3: Within current head page boundaries, keep it as is.
        //          This is the 90% case that happens most often during
        //          normal operation.
        if (NULL == m_pfqpHead)
        {
            //case 0
            DebugTrace((LPARAM) this, "Searching list for Head page");
            m_pfqpHead = m_pfqpTail;
            if (NULL == m_pfqpHead) //there IS nothing in the queue
            {
                Assert(0 == m_cQueueEntries);
                hr = AQUEUE_E_QUEUE_EMPTY;
                goto Exit;
            }

            while (NULL != m_pfqpHead->m_pfqpPrev) //get to first page
            {
                m_pfqpHead = m_pfqpHead->m_pfqpPrev;
            }
            m_ppqdataHead = m_pfqpHead->m_rgpqdata;
        }

        _ASSERT(m_pfqpHead); //otherwise should have returned AQUEUE_E_QUEUE_EMPTY
        if ((m_ppqdataHead == NULL) ||
              (m_pfqpHead->FIsOutOfBounds(m_ppqdataHead) &&
              (m_ppqdataHead != (&m_pfqpHead->m_rgpqdata[FIFOQ_QUEUE_PAGE_SIZE]))))
        {
            //case 1
            m_ppqdataHead = m_pfqpHead->m_rgpqdata;

            _ASSERT(0 && "Non-fatal assert... get mikeswa to take a look at this case");
        }
        else if (m_ppqdataHead == (&m_pfqpHead->m_rgpqdata[FIFOQ_QUEUE_PAGE_SIZE]))
        {
            //case 2
            DebugTrace((LPARAM) this, "Deleting page 0x%08X", m_pfqpHead);
            //set new head page
            FQPAGE *pfqpOld = m_pfqpHead;
            m_pfqpHead = m_pfqpHead->m_pfqpNext;
            Assert(m_pfqpHead->m_pfqpPrev == pfqpOld);
            Assert(m_pfqpHead);  //There must be a next head if not empty

            m_pfqpHead->m_pfqpPrev = NULL;
            m_ppqdataHead = m_pfqpHead->m_rgpqdata;

            FreeQueuePage(pfqpOld);

            _ASSERT(m_pfqpHead && (NULL == m_pfqpHead->m_pfqpPrev));

        }

        if (NULL != *m_ppqdataHead)
            break;
        else
        {
            //Case 3
            m_ppqdataHead++;
#ifdef FIFOQ_ASSERT_QUEUE
            Assert(m_pfqpHead->m_cHoles >= 1);
            Assert(m_pfqpHead->m_cHoles <= FIFOQ_QUEUE_PAGE_SIZE);
            m_pfqpHead->m_cHoles--;
#endif //FIFOQ_ASSERT_QUEUE
        }
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrAllocQueuePage ]------------------------------------------
//
//
//  Description: Allocates a queue page
//
//  Parameters:
//      OUT FQPAGE **ppfqp  newly allocated page
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY on failure
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrAllocQueuePage(FQPAGE **ppfqp)
{
    TraceFunctEnterEx((LPARAM) s_cFreePages, "CFifoQueue::HrAllocQueuePage");
    HRESULT hr              = S_OK;
    FQPAGE *pfqpNew         = NULL;
    FQPAGE *pfqpNext        = NULL;
    FQPAGE *pfqpCheck       = NULL;

    Assert(ppfqp);
    *ppfqp = NULL;

    if (s_cFreePages)
    {
        //
        //  Grab critical section before looking at head of the free list
        //
        EnterCriticalSection(&s_csAlloc);

        pfqpNew = (FQPAGE *) s_pfqpFree;
        if (NULL != pfqpNew)
        {
            pfqpNext = pfqpNew->m_pfqpNext;
            s_pfqpFree = pfqpNext;
            *ppfqp = pfqpNew;
        }

        //
        //  Release the critical section now that we are done with the free list
        //
        LeaveCriticalSection(&s_csAlloc);

        //
        //  If our allocation was successfull, bail and return the new page
        //
        if (*ppfqp)
        {
            InterlockedDecrement((PLONG) &s_cFreePages);
#ifdef DEBUG
            InterlockedIncrement((PLONG) &s_cFreeAllocated);
#endif //DEBUG

            pfqpNew->Recycle();
            goto Exit;
        }

    }

    *ppfqp = new FQPAGE();

    if (*ppfqp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

#ifdef DEBUG
    InterlockedIncrement((PLONG) &s_cAllocated);
#endif //DEBUG

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::FreeQueuePage ]------------------------------------------------------------
//
//
//  Description: Free's a queue page, by putting it on the free list.
//
//  Parameters:
//      FQPAGE *pfqp    page to free
//  Returns:
//      -
//-----------------------------------------------------------------------------
template <class PQDATA>
void CFifoQueue<PQDATA>::FreeQueuePage(FQPAGE *pfqp)
{
    TraceFunctEnterEx((LPARAM) s_cFreePages, "CFifoQueue::FreeQueuePage");
    Assert(pfqp);
    Assert(pfqp != s_pfqpFree); //check against pushing same thing twice in a row

    FQPAGE *pfqpCheck = NULL;
    FQPAGE *pfqpFree  = NULL;

    if (s_cFreePages < FIFOQ_QUEUE_MAX_FREE_PAGES)
    {
        //
        //  Grab critical section before looking at head of the free list
        //
        EnterCriticalSection(&s_csAlloc);

        //
        //  Update the free list
        //
        pfqpFree = (FQPAGE *) s_pfqpFree;
        pfqp->m_pfqpNext = pfqpFree;
        s_pfqpFree = pfqp;

        //
        //  Release Critical section now that we have updated the freelist
        //
        LeaveCriticalSection(&s_csAlloc);

        InterlockedIncrement((PLONG) &s_cFreePages);
#ifdef DEBUG
        InterlockedIncrement((PLONG) &s_cFreeDeleted);
#endif //DEBUG
    }
    else
    {
        delete pfqp;
#ifdef DEBUG
        InterlockedIncrement((PLONG) &s_cDeleted);
#endif //DEBUG
    }
    TraceFunctLeave();
}

//---[ HrClearQueueMapFn ]-----------------------------------------------------
//
//
//  Description:
//      Example default function to use with HrMapFn... will always return TRUE
//      to continue and delete the current queued data
//  Parameters:
//      IN  PQDATA pqdata,  //ptr to data on queue
//      IN  PVOID pvContext - ignored
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      S_OK
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT HrClearQueueMapFn(IN PQDATA pqdata, IN PVOID pvContext, OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    Assert(pfContinue);
    Assert(pfDelete);
    HRESULT hr = S_OK;

    *pfContinue = TRUE;
    *pfDelete   = TRUE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\guids.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: guids.cpp
//
// Contents: Source file for defining GUIDs
//
// Classes: None
//
// Functions: None
//
// History:
// jstamerj 2001/05/18 11:13:17: Created.
//
//-------------------------------------------------------------
#include <aqprecmp.h>

#include <mailmsg_i.c>
#include <smtpevent_i.c>

#ifdef PLATINUM
#include <ptntintf_i.c>
#include <exdrv_i.c>
#include <exaqadm_i.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\linkmsgq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: linkmsgq.cpp
//
//  Description: Implementation of CLinkMsgQueue object.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "dcontext.h"
#include "aqnotify.h"
#include "connmgr.h"
#include "domcfg.h"
#include "smtpconn.h"
#include "smproute.h"

#define CONNECTION_BUFFER_SIZE 10

LinkFlags li; //encourage symbols to appear debug versions


//---[ CLinkMsgQueue::RestartDSNGenerationIfNecessary ]------------------------
//
//
//  Description:
//      Static wrapper to continue generating DSNs after we have hit our
//      limit of time spent in DSNs generation
//  Parameters:
//      pvContext   - "this" pointer for CLinkMsgQueue
//      dwStatus    - Completion Status
//  Returns:
//      TRUE always
//  History:
//      11/10/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fRestartDSNGenerationIfNecessary(PVOID pvContext,
                                                    DWORD dwStatus)
{
    TraceFunctEnterEx((LPARAM) pvContext, "CLinkMsgQueue::fRestartDSNGenerationIfNecessary");
    CLinkMsgQueue *plmq = (CLinkMsgQueue *) pvContext;
    BOOL           fHasShutdownLock = FALSE;
    BOOL           fHasRoutingLock = FALSE;

    _ASSERT(plmq);
    _ASSERT(LINK_MSGQ_SIG == plmq->m_dwSignature);

    DebugTrace((LPARAM) plmq, "Attempting to restart DSN generation");

    //Don't try DSN generation if this is not a normal completion
    if (dwStatus != ASYNC_WORK_QUEUE_NORMAL)
        goto Exit;

    //Only attempt to continue DSN genration if we cannot create a connection
    //now and have no current connections
    if (plmq->m_cConnections)
    {
        DebugTrace((LPARAM) plmq,
            "We have %d connections... skipping DSN generation",
            plmq->m_cConnections);
        goto Exit;
    }

    if (fFlagsAllowConnection(plmq->m_dwLinkStateFlags))
    {
        DebugTrace((LPARAM) plmq,
            "We can create a connection, skipping DSN generation - flags 0x%X",
            plmq->m_dwLinkStateFlags);
        goto Exit;
    }

    //We need to grab the shutdown and routing lock... just like
    //normal DSN generation.
    if (!plmq->m_paqinst->fTryShutdownLock())
        goto Exit;

    fHasShutdownLock = TRUE;

    if (!plmq->m_paqinst->fTryRoutingShareLock())
        goto Exit;

    fHasRoutingLock = TRUE;

    //Call to generate DSNs... pass in parameters to always check the
    //queues and walk for DSN generation (not just remerge).
    plmq->GenerateDSNsIfNecessary(TRUE, FALSE);

  Exit:
    if (fHasRoutingLock)
        plmq->m_paqinst->RoutingShareUnlock();

    if (fHasShutdownLock)
        plmq->m_paqinst->ShutdownUnlock();

    plmq->Release();
    TraceFunctLeave();
    return TRUE;
}

//---[ CLinkMsgQueue::HrGetInternalInfo ]---------------------------------------
//
//
//  Description:
//      Private function to get cached link info, and update cached data if
//      needed.
//
//      NOTE:  This is the only way the cached data should be access (other than
//          startup and shutdown).
//  Parameters:
//      OUT     ppIntDomainInfo     (can be NULL)
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if queue is shutting down.
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetInternalInfo(OUT CInternalDomainInfo **ppIntDomainInfo)
{
    HRESULT hr = S_OK;
    _ASSERT(m_cbSMTPDomain);
    _ASSERT(m_szSMTPDomain);

    if (ppIntDomainInfo)
        *ppIntDomainInfo = NULL;

    //If we don't currently have domain info and it was not a failure
    //condition... don't reget domain info
    if (!m_pIntDomainInfo && !(eLinkFlagsGetInfoFailed & m_dwLinkFlags))
        goto Exit;

    m_slInfo.ShareLock();

    //Verify Domain Config Info
    while (!m_pIntDomainInfo ||
        (m_pIntDomainInfo->m_dwIntDomainInfoFlags & INT_DOMAIN_INFO_INVALID))
    {
        m_slInfo.ShareUnlock();
        m_slInfo.ExclusiveLock();
        //another may have gotten exclusive lock in meantime
        if (m_pIntDomainInfo &&
            !(m_pIntDomainInfo->m_dwIntDomainInfoFlags & INT_DOMAIN_INFO_INVALID))
        {
            //another thread has updated info
            m_slInfo.ExclusiveUnlock();
            m_slInfo.ShareLock();
            continue;
        }

        //Domain info is no longer valid at this point
        if (m_pIntDomainInfo)
        {
            m_pIntDomainInfo->Release();
            m_pIntDomainInfo = NULL;
        }

        if (m_dwLinkFlags & eLinkFlagsExternalSMTPLinkInfo) {
            hr = m_paqinst->HrGetInternalDomainInfo(m_cbSMTPDomain, m_szSMTPDomain,
                                &m_pIntDomainInfo);
        } else {
            hr = m_paqinst->HrGetDefaultDomainInfo(&m_pIntDomainInfo);
        }

        if (FAILED(hr))
        {
            dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsGetInfoFailed);
            m_slInfo.ExclusiveUnlock();
            _ASSERT(AQUEUE_E_SHUTDOWN == hr);
            goto Exit;
        }

        _ASSERT(m_pIntDomainInfo);
        //Handle change of TURN/ETRN
        if (m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
             (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY))
        {
            if (!(m_dwLinkStateFlags & LINK_STATE_PRIV_CONFIG_TURN_ETRN))
            {
                //Modify link flags to account for TURN/ETRN
                dwInterlockedSetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_CONFIG_TURN_ETRN);
            }
        }
        else if (m_dwLinkStateFlags & LINK_STATE_PRIV_CONFIG_TURN_ETRN)
        {
            //We used to be TURN/ETRN, but are no-longer configured as such
            dwInterlockedUnsetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_CONFIG_TURN_ETRN);
        }

        m_slInfo.ExclusiveUnlock();
        m_slInfo.ShareLock();
    }

    //Now we have info... set out param and addref
    if (ppIntDomainInfo)
    {
        *ppIntDomainInfo = m_pIntDomainInfo;
        m_pIntDomainInfo->AddRef();
    }

    //Clear failure bit if set
    if (eLinkFlagsGetInfoFailed & m_dwLinkFlags)
        dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsGetInfoFailed);

    m_slInfo.ShareUnlock();

   Exit:
    return hr;
}


//---[ CLinkMsgQueue::InternalInit ]------------------------------------------
//
//
//  Description:
//      Default constructor for CLinkMsgQueue.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/25/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::InternalInit()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::InternalInit");
    m_dwSignature       = LINK_MSGQ_SIG;
    m_dwLinkFlags       = eLinkFlagsClear;
    m_dwLinkStateFlags  = LINK_STATE_SCHED_ENABLED |
                          LINK_STATE_RETRY_ENABLED |
                          LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY;
    m_paqinst           = NULL;
    m_cQueues           = 0;
    m_cConnections      = 0;
    m_szSMTPDomain      = NULL;
    m_cbSMTPDomain      = 0;
    m_pIntDomainInfo    = NULL;
    m_pdentryLink       = NULL;
    m_lConnMgrCount     = 0;
    m_lConsecutiveConnectionFailureCount = 0;
    m_lConsecutiveMessageFailureCount = 0;
    m_liLinks.Flink     = NULL;
    m_liLinks.Blink     = NULL;
    m_szConnectorName   = NULL;
    m_dwRoundRobinIndex = 0;
    m_pILinkStateNotify = NULL;
    m_hrDiagnosticError      = S_OK;
    m_szDiagnosticVerb[0]    = '\0';
    m_szDiagnosticResponse[0]= '\0';
    m_hrLastConnectionFailure= S_OK;

    ZeroMemory(&m_ftNextRetry, sizeof(FILETIME));
    ZeroMemory(&m_ftNextScheduledCallback, sizeof(FILETIME));
    ZeroMemory(&m_ftEmptyExpireTime, sizeof(FILETIME));

    AssertPrivateLinkStateFlags();

    //normally links are for remote delivery, in special cases like the currently unreachable
    //queue they are not. so we need a type field to differentiate between links, so that some
    //actions can be performed differently for the special links.
    SetLinkType(LI_TYPE_REMOTE_DELIVERY);

    //all actions are supported by default, but special links like currently unreachable may
    //set this bitmask to specify that certain actions are unsupported. when such an unsupported
    //action is commanded, nothing happens.
    SetSupportedActions(LA_KICK | LA_FREEZE | LA_THAW);

    InitializeListHead(&m_liConnections);
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::CLinkMsgQueue ]------------------------------------------
//
//
//  Description:
//      Class constuctor
//  Parameters:
//      IN dwScheduleID         Schedule ID to associate with link
//      IN pIMessageRouter      Router for this link
//      IN pILinkStateNotify    Scheduler Interface for this link
//  Returns:
//      -
//-----------------------------------------------------------------------------
CLinkMsgQueue::CLinkMsgQueue(DWORD dwScheduleID,
                         IMessageRouter *pIMessageRouter,
                         IMessageRouterLinkStateNotification *pILinkStateNotify)
                         : m_aqsched(pIMessageRouter, dwScheduleID),
                         m_slQueues("CLinkMsgQueue::m_slQueues"),
                         m_slConnections("CLinkMsgQueue::m_slConnections"),
                         m_slInfo("CLinkMsgQueue::m_slInfo")
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::CLinkMsgQueue2");

    InternalInit();


    m_pILinkStateNotify = pILinkStateNotify;
    if (m_pILinkStateNotify)
        m_pILinkStateNotify->AddRef();

    TraceFunctLeave();
}

//---[ CLinkMsgQueue::~CLinkMsgQueue ]------------------------------------------------------------
//
//
//  Description:
//      Class destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CLinkMsgQueue::~CLinkMsgQueue()
{
    // tell routing that this link is going away
    DWORD dw = dwModifyLinkState(LINK_STATE_LINK_NO_LONGER_USED, 0);
    if (!(dw & LINK_STATE_LINK_NO_LONGER_USED))
        SendLinkStateNotification();

    if (NULL != m_paqinst)
    {
        m_paqinst->DecNextHopCount();
        m_paqinst->Release();
    }

    if (NULL != m_pIntDomainInfo)
        m_pIntDomainInfo->Release();

    if (NULL != m_pdentryLink)
        m_pdentryLink->Release();

    if (m_szConnectorName)
        FreePv(m_szConnectorName);

    if (m_szSMTPDomain)
        FreePv(m_szSMTPDomain);

    if (m_pILinkStateNotify)
        m_pILinkStateNotify->Release();

    _ASSERT(IsListEmpty(&m_liConnections) && "Leaked connections");

}

//---[ CLinkMsgQueue::HrInitialize ]-----------------------------------------
//
//
//  Description: Performs initialization that may return an error code
//
//  Parameters:
//      IN  paqinst              Server Instance Object
//      IN  pdmap        Domain Mapping of SMTP Domain this link is for
//      IN  cbSMTPDomain
//      IN  szSMTPDomain SMTP Domain that link is being created for
//      IN  paqsched     Schedule ID returned by routing sink
//      IN  szConnectorName
//  Returns: S_OK on success
//
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrInitialize(CAQSvrInst *paqinst,
                                    CDomainEntry *pdentryLink, DWORD cbSMTPDomain,
                                    LPSTR szSMTPDomain,
                                    LinkFlags lf,
                                    LPSTR szConnectorName)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrInitialize");
    HRESULT hr = S_OK;
    DWORD   cbConnectorName = 0;

    _ASSERT(szSMTPDomain);
    _ASSERT(cbSMTPDomain);
    _ASSERT(paqinst);

    m_paqinst = paqinst;
    if (m_paqinst)
    {
        m_paqinst->AddRef();
        m_paqinst->IncNextHopCount();
    }

    m_pdentryLink = pdentryLink;
    if (m_pdentryLink)
        m_pdentryLink->AddRef();

    m_szSMTPDomain = (LPSTR) pvMalloc(cbSMTPDomain+sizeof(CHAR));
    if (!m_szSMTPDomain)
    {
        hr = E_OUTOFMEMORY;
        ErrorTrace((LPARAM) this, "Error unable to allocate m_szSMTPDomain");
        goto Exit;
    }

    strcpy(m_szSMTPDomain, szSMTPDomain);
    m_cbSMTPDomain = cbSMTPDomain;

    if (szConnectorName)
    {
        cbConnectorName = lstrlen(szConnectorName) + sizeof(CHAR);
        m_szConnectorName = (LPSTR) pvMalloc(cbConnectorName);
        if (!m_szConnectorName)
        {
            hr = E_OUTOFMEMORY;
            ErrorTrace((LPARAM) this, "Error unable to allocate m_szConnectorName");
            goto Exit;
        }
        strcpy(m_szConnectorName, szConnectorName);

    }

    if (lf == eLinkFlagsInternalSMTPLinkInfo) {

        hr = m_paqinst->HrGetDefaultDomainInfo(&m_pIntDomainInfo);

    } else if (lf == eLinkFlagsExternalSMTPLinkInfo) {

        hr = m_paqinst->HrGetInternalDomainInfo(
                            cbSMTPDomain,
                            szSMTPDomain,
                            &m_pIntDomainInfo);
    } else {

        // linkInfoType can only be one of these 3 bits. Since we tested for
        // the above two, assert that it is the third type.

        _ASSERT(lf == eLinkFlagsAQSpecialLinkInfo);

    }

    m_dwLinkFlags |= lf;

    if (m_pIntDomainInfo &&
          m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
         (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY))
    {
        //Modify link flags to account for TURN/ETRN
        dwInterlockedSetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_CONFIG_TURN_ETRN);
    }

  Exit:

    //Turn off notifications if we failed
    if (FAILED(hr))
        dwModifyLinkState(LINK_STATE_LINK_NO_LONGER_USED, LINK_STATE_NO_ACTION);

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrDeinitialize ]-----------------------------------------
//
//
//  Description: Release link to m_paqinst object.
//
//  Parameters: -
//
//  Returns: S_OK on success
//
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrDeinitialize");
    HRESULT hr = S_OK;

    dwModifyLinkState(LINK_STATE_NO_ACTION,
                      LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY);
    RemoveAllQueues();

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::RemovedFromDMT ]-----------------------------------------
//
//
//  Description: Notification to the link that the DMT is removing it
//
//  Parameters: -
//
//  Returns: -
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemovedFromDMT()
{
    TraceFunctEnter("CLinkMsgQueue::RemovedFromDMT");

    // tell routing that this link is going away
    DWORD dw = dwModifyLinkState(LINK_STATE_LINK_NO_LONGER_USED, 0);
    if (!(dw & LINK_STATE_LINK_NO_LONGER_USED))
        SendLinkStateNotification();

    TraceFunctLeave();
}


//---[ CLinkMsgQueue::AddConnection ]----------------------------------------
//
//
//  Description:
//      Add a connection instance to this link
//  Parameters:
//      IN  pSMTPConn Connection to add to link
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::AddConnection(CSMTPConn *pSMTPConn)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrAddConnection");
    _ASSERT(pSMTPConn);

    _ASSERT(!(m_dwLinkStateFlags & LINK_STATE_PRIV_NO_CONNECTION));

    InterlockedIncrement((PLONG) &m_cConnections);

    m_slConnections.ExclusiveLock();
    pSMTPConn->InsertConnectionInList(&m_liConnections);
    m_slConnections.ExclusiveUnlock();

    DebugTrace((LPARAM) this, "Adding connection #%d to link", m_cConnections);
    TraceFunctLeave();
}
//---[ CLinkMsgQueue::RemoveConnection ]---------------------------------------
//
//
//  Description:
//      Remove a connection from the link
//  Parameters:
//      IN  pSMTPConn               Connection to remove from link
//      IN  fForceDSNGeneration     Force DSN generation
//  Returns:
//      - Always succeeds
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemoveConnection(IN CSMTPConn *pSMTPConn,
                                     IN BOOL fForceDSNGeneration)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::RemoveConnection");
    BOOL    fNoConnections = FALSE;
    BOOL    fMergeOnly = fFlagsAllowConnection(m_dwLinkStateFlags) &&
                         !fForceDSNGeneration;
    _ASSERT(pSMTPConn);

    _ASSERT(!(m_dwLinkStateFlags & LINK_STATE_PRIV_NO_CONNECTION));

    if (!m_paqinst)
        return;

    m_paqinst->RoutingShareLock();
    m_slConnections.ExclusiveLock();

    pSMTPConn->RemoveConnectionFromList();
    InterlockedDecrement((PLONG) &m_cConnections);

    fNoConnections = IsListEmpty(&m_liConnections);

    m_slConnections.ExclusiveUnlock();
    //Only generate DSNs if we have been kicked into retry
    if (fNoConnections)
    {
        //Generate DSNs if we cannot connect connect
        GenerateDSNsIfNecessary(TRUE, fMergeOnly);
        dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsConnectionVerifed);
    }
    m_paqinst->RoutingShareUnlock();
    DebugTrace((LPARAM) this, "Removing connection #%d from link", m_cConnections);
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::GenerateDSNsIfNecessary ]--------------------------------
//
//
//  Description:
//      Walks queues and generates DSNs if necessary.
//  Parameters:
//      BOOL    fCheckIfEmpty - check queues even if we think we are empty
//                          This is an optimization that should be used
//                          when we know there are no messages in the
//                          retry queues (like the Unreachable or
//                          CurrentlyUnreachable link)
//      BOOL    fMergeOnly - Only merge retry queues, do not walk for DSNs
//                          This improves perf for the cases were we have not
//                          had a connection error and really don't need to
//                          walk the queues.
//  Returns:
//      -
//  History:
//      1/27/99 - MikeSwa Created (pulled from RemoveConnection)
//      2/2/99 - MikeSwa Added fMergeOnly flag
//      11/10/1999 - MikeSwa Updated to be more release locks after generating
//              a max number of DSNs.
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::GenerateDSNsIfNecessary(BOOL fCheckIfEmpty, BOOL fMergeOnly)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::GenerateDSNsIfNecessary");
    DWORD   iQueues = 0;
    CDestMsgQueue *pdmq = NULL;
    PVOID   pvContext = NULL;
    HRESULT hrDSN = m_hrLastConnectionFailure;
    HRESULT hr = S_OK;
    BOOL    fRestartLater = FALSE;
    DWORD   dwDSNContext = 0;


    //If this link is configured as a TURN/ETRN link, we do not want to
    //immediately NDR the domain because if subject us to DOS attacks.
    //We only want to generate expire DSNs
    if (LINK_STATE_PRIV_CONFIG_TURN_ETRN & m_dwLinkStateFlags)
        hrDSN = AQUEUE_E_HOST_NOT_RESPONDING;

    //
    //  For servers within an orginization, there is an expectation that
    //  that authoritative DNS failures are network issues that need to be
    //  resolved by email administrators (as opposed to user errors in
    //  typing the email address).
    //
    //  This link state flag allows the router to control behavior in the
    //  face of authoritative DNS failures.
    //
    //  If the next hop is something derived from a user address (like
    //  direct DNS routing to external machines or a direct-DNS connector),
    //  then a router can use this flag to tell queuing to treat
    //  authoritative DNS failures as retryable.
    //
    //  The default behavior is to treat authoritative DNS failures as
    //  fatal errors (and NDR the messages).
    //
    if ((AQUEUE_E_SMTP_GENERIC_ERROR == hrDSN) &&
        (LINK_STATE_RETRY_ALL_DNS_FAILURES & m_dwLinkStateFlags))
    {
        hrDSN = AQUEUE_E_HOST_NOT_RESPONDING;
        ErrorTrace((LPARAM) this,
            "hard failure (DNS) made retryable for %s (flags 0x%08X)",
                    m_szSMTPDomain, m_dwLinkStateFlags);
    }

    // m_cMsgs doesn't include # of msgs in retry queue.
    if (!fCheckIfEmpty && !m_aqstats.m_cMsgs && !m_aqstats.m_cRetryMsgs)
        return;

    if (!(LINK_STATE_PRIV_GENERATING_DSNS &
        dwInterlockedSetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_GENERATING_DSNS)))
    {

        if (m_paqinst && m_paqinst->fTryShutdownLock())
        {
            //Don't attempt to requeue if we are shutting down
            m_slQueues.ShareLock();
            pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvContext);
            while (pdmq)
            {
                pdmq->AssertSignature();
                if (fMergeOnly)
                    pdmq->MergeRetryQueue();
                else
                    hr = pdmq->HrGenerateDSNsIfNecessary(&m_qlstQueues, hrDSN, &dwDSNContext);

                if (FAILED(hr) && (HRESULT_FROM_WIN32(E_PENDING) == hr))
                {
                    fRestartLater = TRUE;
                    break;
                }

                iQueues++;
                pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvContext);
                _ASSERT(iQueues <= m_cQueues);
            }

            m_slQueues.ShareUnlock();
            m_paqinst->ShutdownUnlock();
        }

        if (fRestartLater)
        {
            //We have hit our limit on the number of messages to process
            //at one time.  Schedule a callback to process more later
            DebugTrace((LPARAM) this,
                "Will continue DSN generation at a later time - 0x%X", hr);

            AddRef();  //Completion function will release on failure
            m_paqinst->HrQueueWorkItem(this,
                                   CLinkMsgQueue::fRestartDSNGenerationIfNecessary);
        }
        dwInterlockedUnsetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_GENERATING_DSNS);
    }
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetDomainInfo ]----------------------------------------
//
//
//  Description:
//      Returns domain info for SMTP connection.
//  Parameters:
//      OUT pcbSMTPDomain   String length of domain name
//      OUT pszSMTPDomain   String containing domain info (memory managed byt DMT)
//      OUT ppIntDomainInfo Internal Domain Info for link's next hop
//  Returns:
//      S_OK on success
//      AQUEUE_E_LINK_INVALID if link is no longer valud
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetDomainInfo(OUT DWORD *pcbSMTPDomain,
                        OUT LPSTR *pszSMTPDomain,
                        OUT CInternalDomainInfo **ppIntDomainInfo)
{
    HRESULT hr = S_OK;

    _ASSERT(pcbSMTPDomain);
    _ASSERT(pszSMTPDomain);
    _ASSERT(ppIntDomainInfo);

    hr = HrGetInternalInfo(ppIntDomainInfo);
    if (FAILED(hr))
    {
        goto Exit;
    }
    else if (!*ppIntDomainInfo)
    {
        //If HrGetInternalInfoFails the first time, it will return NULL
        //subsequent times.  Make sure we do not return success and a
        //NULL pointer.  When this happens, the link will go into retry
        hr = E_FAIL;
        goto Exit;
    }

    *pcbSMTPDomain = m_cbSMTPDomain;
    *pszSMTPDomain = m_szSMTPDomain;

  Exit:
    return hr;
}


//---[ CLinkMsgQueue::HrGetSMTPDomain ]----------------------------------------
//
//
//  Description:
//      Returns the SMTP Domain for this link.
//  Parameters:
//      OUT pcbSMTPDomain   String length of returned domain
//      OUT pszSMTPDomain   Returned SMTP Domain string.  The Link will manager
//                          The memory for this, and will remain valid as long
//                          as the link is in existance.
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetSMTPDomain(OUT DWORD *pcbSMTPDomain,
                                       OUT LPSTR *pszSMTPDomain)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrGetSMTPDomain");
    HRESULT hr = S_OK;
    _ASSERT(pcbSMTPDomain);
    _ASSERT(pszSMTPDomain);

    if (m_dwLinkFlags & eLinkFlagsInvalid)
    {
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }


    *pcbSMTPDomain = m_cbSMTPDomain;
    *pszSMTPDomain = m_szSMTPDomain;

    if (NULL == m_szSMTPDomain)
    {
        hr = AQUEUE_E_LINK_INVALID;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrAddQueue ]---------------------------------------------
//
//
//  Description:
//      Add DestMsgQueues to the link.
//  Parameters:
//
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate space to store queue
//      AQUEUE_E_LINK_INVALID Failed to add queue to link (link is invalid)
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrAddQueue(IN CDestMsgQueue *pdmqNew)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrAddQueue");
    HRESULT hr  = S_OK;
    DWORD   dwIndex = 0;
    CDestMsgQueue *pdmqOld = NULL;
    PVOID   pvContext = NULL;

    m_slQueues.ExclusiveLock();

    // Verify that this link is still in use (there exists a window
    // where we have decided to use this link but it still gets removed)
    if (LINK_STATE_LINK_NO_LONGER_USED & m_dwLinkStateFlags)
    {
        // Keep track of how often this failure occurs because it results
        // in a reset routes every time ...
        InterlockedIncrement((PLONG) &g_cFailedToAddQueueToRemovedLink);

        ErrorTrace((LPARAM) this, "Failed to add queue to removed link - this has occured %d times since startup", g_cFailedToAddQueueToRemovedLink);

        // Fail here and let the caller try putting the queue elsewhere
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }

    //
    //  Clear the marked as empty bit (if set)
    //
    dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsMarkedAsEmpty);

    _ASSERT(pdmqNew);

#ifdef DEBUG
    // We have seen cases where it looks like a DMQ has been added to a link
    // multiple times (via this call).  We need to make assert that this
    // is not the case here.
    for (dwIndex = 0; dwIndex < m_cQueues; dwIndex++)
    {
        pdmqOld = (CDestMsgQueue *) m_qlstQueues.pvGetItem(dwIndex, &pvContext);

        //If these match, it means that someone is adding this queue twice...
        if (pdmqOld == pdmqNew)
        {
            _ASSERT(0 && "Adding queue twice to link... get mikeswa");
        }
    }
#endif //DEBUG

    dwIndex = 0;
    pdmqOld = NULL;
    pvContext = NULL;
    pdmqNew->AddRef();
    hr =  m_qlstQueues.HrAppendItem(pdmqNew, &dwIndex);

    if (FAILED(hr))
        goto Exit;

    //Set DMQ's link context to index inserted in quick list
    pdmqNew->SetLinkContext(ULongToPtr(dwIndex));
    m_cQueues++;

  Exit:
    m_slQueues.ExclusiveUnlock();

    //Now that the first queue has been added, this can be deleted if empty
    dwModifyLinkState(LINK_STATE_NO_ACTION,
                      LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY);
    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::RemoveQueue ]--------------------------------------------
//
//
//  Description:
//      Removes a given queue from the link.  Queue *must* be associated with
//      link (this will be asserted).
//  Parameters:
//      IN  pdmq        DMQ to remove from link
//      IN  paqstats    Stats associated with DMQ
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Created
//      5/14/99 - MikeSwa Removed code to automatically remove link
//                from DMT if there are no queues.  This is now done in
//                CLinkMsgQueue::RemoveLinkIfEmpty
//      8/10/99 - MikeSwa added check of pdmqOther.  While operartions on
//                the quick list are thread safe, there is nothing procting us
//                from another thread calling RemoveQueue or RemoveAllQueues
//                before we get the lock.  If this is the case, then we have
//                the change to double-decrement m_cQueues, which could lead to
//                an AV in GetNextMessage
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemoveQueue(IN CDestMsgQueue *pdmq, IN CAQStats *paqstats)
{
    TraceFunctEnterEx((LPARAM) this, "RemoveQueue");
    _ASSERT(pdmq);
    CDestMsgQueue *pdmqOther = NULL;
    CDestMsgQueue *pdmqCheck = NULL;
    PVOID   pvContext = NULL;
    DWORD   dwIndex = 0;
    BOOL    fFoundQueue = FALSE;

    //Aquire exclusive lock and remove DMQ from list
    m_slQueues.ExclusiveLock();

    //While the follow line *may* produce a sundown warning is is 100% correct
    //The context is created and "owned" by this object.  Currently it is an
    //array index, but eventually it may be a pointer to more interesting context
    //structure.
    dwIndex = (DWORD) (DWORD_PTR)pdmq->pvGetLinkContext();

    pdmqOther = (CDestMsgQueue *) m_qlstQueues.pvGetItem(dwIndex, &pvContext);
    if (pdmqOther && (pdmqOther == pdmq))
    {
        fFoundQueue = TRUE;

        //Now that we found it... remove it from the link
        pdmqCheck = (CDestMsgQueue *) m_qlstQueues.pvDeleteItem(dwIndex, &pvContext);
        m_cQueues--;

        //The link context should be the index of the DMQ
        _ASSERT(pdmqCheck == pdmqOther);

        //Get new item at old index & update context
        pdmqOther = (CDestMsgQueue *) m_qlstQueues.pvGetItem(dwIndex, &pvContext);

        //If pdmqOther is NULL, then we have no more queues
        //(or it was the last in the list)
        _ASSERT(pdmqOther || !m_cQueues || (dwIndex == m_cQueues));

        //Update change in stats
        m_aqstats.UpdateStats(paqstats, FALSE);

        if (m_cQueues)
        {
            if (pdmqOther)
                pdmqOther->SetLinkContext(ULongToPtr(dwIndex));
        }
    }
    else
    {
        //While not technically an error, this means that another thread has removed
        //this (or all) queues, and it is not in the link
        ErrorTrace((LPARAM) this,
            "Found Queue 0x%0X instead of 0x%08X at index %d",
            (DWORD_PTR) pdmqOther, (DWORD_PTR) pdmq, dwIndex);
    }

    m_slQueues.ExclusiveUnlock();

    //Release reference to DMQ
    if (fFoundQueue)
        pdmq->Release();

    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetQueueListSnapshot ]---------------------------------
//
//
//  Description:
//      Gets a snapshot of the queue list - the caller is responsible for
//      deleting this list
//  Parameters:
//      IN / OUT : ppql - pp to place the new CQuickList in
//  Returns:
//      S_OK on success
//  History:
//      11/9/2000 - dbraun - created
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetQueueListSnapshot(CQuickList **ppql)
{
    HRESULT     hr      = S_OK;

    // Lock the queue list
    m_slQueues.ShareLock();

    // Get a clone of the queue list
    hr = m_qlstQueues.Clone(ppql);

    // Unlock the queue list
    m_slQueues.ShareUnlock();

    return hr;
}

//---[ CLinkMsgQueue::RemoveLinkIfEmpty ]--------------------------------------
//
//
//  Description:
//      Removes a link from the DomainEntry if it is empty.  This behavior
//      used to be part of RemoveQueue, but was removed because it could
//      lead to a link being removed from the DMT hash table, but still
//      creating connections.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/14/99 - MikeSwa Created (as potential Windows2000 Beta3 QFE fix)
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemoveLinkIfEmpty()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::RemoveLinkIfEmpty");
    DWORD dwLinkFlags = 0;
    DWORD dwRoutingInterestedFlags = LINK_STATE_CONNECT_IF_NO_MSGS |
                                     LINK_STATE_DO_NOT_DELETE |
                                     LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY |
                                     LINK_STATE_ADMIN_HALT |
                                     LINK_STATE_DO_NOT_DELETE_UNTIL_NEXT_NOTIFY;

    //Bail early if we know we don't need to grab the lock
    if (m_cQueues || !m_pdentryLink)
        return;

    if (m_slQueues.TryExclusiveLock())
    {
        if (!m_cQueues &&
            !(dwRoutingInterestedFlags & m_dwLinkStateFlags))
        {
            //It might be prudent to to delete this link if:
            // - There are no messages
            // - Routing has not shown a interest in this queue
            // - This link has also expired


            //
            //  Mark link as empty
            //
            dwLinkFlags = dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsMarkedAsEmpty);

            //
            //  If we set the flag, then set the expire timer.  Otherwise remove
            //  the link.
            //
            if (!(eLinkFlagsMarkedAsEmpty & dwLinkFlags))
            {
                m_paqinst->GetExpireTime(EMPTY_LMQ_EXPIRE_TIME_MINUTES,
                                        &m_ftEmptyExpireTime, NULL);
            }
            else if (m_paqinst->fInPast(&m_ftEmptyExpireTime, NULL))
            {
                if (m_pdentryLink)
                {
                    DebugTrace((LPARAM) this,
                               "Removing empty link %s with flags 0x%08X",
                               (m_szSMTPDomain ? m_szSMTPDomain : "(NULL)"),
                               m_dwLinkStateFlags);

                    // INSTRUMENTATION : Sleep to slow link removal
                    if (g_fEnableTestSettings && g_cDelayLinkRemovalSeconds)
                    {
                        // Delay the deletion to open up the window for
                        // adding a queue to this about-to-be removed link
                        StateTrace((LPARAM) this,
                               "Link expiring - delaying %d seconds", g_cDelayLinkRemovalSeconds);
                        Sleep (g_cDelayLinkRemovalSeconds * 1000);
                        StateTrace((LPARAM) this,
                               "Link expiring - proceeding with delete");
                    }
                    // END INSTRUMENTATION

                    m_pdentryLink->RemoveLinkMsgQueue(this);
                    m_pdentryLink->Release();
                    m_pdentryLink = NULL;
                }

                //We need to artificially increase the connection manager count
                //so it will not be enqueue'd in the connmgr again
                IncrementConnMgrCount();
            }
        }

        m_slQueues.ExclusiveUnlock();
    }
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetNextMsg ]-------------------------------------------
//
//
//  Description:
//      Gets the next message from the queue
//  Parameters:
//      IN OUT CDeliveryContext *pdcntxt - delivery context for connection
//      OUT IMailMsgProperties **ppIMailMsgProperties  - IMsg dequeued
//      OUT DWORD *pcIndexes          - size of array
//      OUT DWORD **prgdwRecipIndex   - Array of recipient indexes
//  Returns:
//      S_OK on success
//      E_INVALIDARG if invalid parameters are given
//
//  History:
//      6/17/98 - MikeSwa Modified to use connection's delivery context
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetNextMsg(IN OUT CDeliveryContext *pdcntxt,
                OUT IMailMsgProperties **ppIMailMsgProperties,
                OUT DWORD *pcIndexes, OUT DWORD **prgdwRecipIndex)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrGetNextMsg");
    Assert(ppIMailMsgProperties);
    Assert(pdcntxt);
    Assert(prgdwRecipIndex);
    Assert(pcIndexes);

    HRESULT           hr         = S_OK;
    CMsgRef          *pmsgref    = NULL;
    CMsgBitMap       *pmbmap     = NULL;
    DWORD             cDomains   = 0;
    BOOL              fLockedShutdown = FALSE;
    BOOL              fLockedQueues = FALSE;
    DWORD             iQueues    = 0;
    DWORD             dwCurrentRoundRobinIndex = m_dwRoundRobinIndex;
    CDestMsgQueue     *pdmq = NULL;
    CDestMsgRetryQueue *pdmrq = NULL;
    PVOID             pvContext = NULL;
    BOOL              fDoneWithQueue = FALSE;
    DWORD             dwCurrentPriority = eEffPriHigh;

    if (m_dwLinkFlags & eLinkFlagsInvalid)
    {
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }

    //Don't even bother to wait for queue lock if routing change is pending
    if (m_dwLinkFlags & eLinkFlagsRouteChangePending)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    //Make sure domain info is updated & we should still be sending messages
    //If we can't schedule... we still might be allowed to send messages because
    //of TURN.
    if (!fCanSchedule() && !(m_dwLinkStateFlags & LINK_STATE_PRIV_TURN_ENABLED))
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }


    if (!m_paqinst->fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    m_paqinst->RoutingShareLock();
    fLockedShutdown = TRUE;

    m_slQueues.ShareLock();
    fLockedQueues = TRUE;

    if (m_cQueues == 0)
    {
        //There are currently no queue associated with this link
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }


    //
    //  A priority ordering is imposed on these queues by first requesting
    //  only messages of a certain priority and then requesting lower priorities
    //
    do
    {
        //
        //  Sanity check our current priority
        //
        _ASSERT(dwCurrentPriority < NUM_PRIORITIES);

        for (iQueues = 0; iQueues < m_cQueues && SUCCEEDED(hr) && !pmsgref; iQueues++)
        {
            pmsgref = NULL;
            pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(
                            (iQueues+dwCurrentRoundRobinIndex)%m_cQueues, &pvContext);

            _ASSERT(pdmq);
            pdmq->AssertSignature();


            //Loop until the queue is empty or we get a message that hasn't
            //already been delivered by another queue on this link
            do
            {
                //Usually, we only want to attempt to dequeue from a queue once.
                fDoneWithQueue = TRUE;

                //Release retry interface if we have one
                if (pdmrq)
                {
                    pdmrq->Release();
                    pdmrq = NULL;
                }

                //get msg reference
                hr = pdmq->HrDequeueMsg(dwCurrentPriority, &pmsgref, &pdmrq);
                if (FAILED(hr))
                {

                    if (AQUEUE_E_QUEUE_EMPTY == hr)
                    {
                        hr = S_OK;
                        continue;  //get message from next queue
                    }
                    else
                    {
                        goto Exit;
                    }
                }

                //prepare for delivery and generate delivery context
                hr = pmsgref->HrPrepareDelivery(FALSE /*remote only */,
                                                FALSE /*not a Delay DSN */,
                                                &m_qlstQueues, pdmrq,
                                                pdcntxt, pcIndexes, prgdwRecipIndex);

                if (AQUEUE_E_MESSAGE_HANDLED == hr)
                {
                    //the message has already been handled for this queue
                    pmsgref->Release();
                    pmsgref = NULL;
                    hr = S_OK;

                    //We want to stay on this queue until it is empty
                    fDoneWithQueue = FALSE;
                }
                else if ((AQUEUE_E_MESSAGE_PENDING == hr) ||
                        ((FAILED(hr)) && pmsgref->fShouldRetry()))
                {
                    //AQUEUE_E_MESSAGE_PENDING means that the message
                    //is currently pending delivery for another connection
                    //on this link.  We will requeue it, and remove only after it
                    //has been completly delivered for this link
                    hr = pdmrq->HrRetryMsg(pmsgref);
                    if (FAILED(hr))
                        pmsgref->RetryOnDelete();

                    pmsgref->Release();
                    pmsgref = NULL;
                    hr = S_OK;

                    //We want to stay on this queue until it is empty
                    fDoneWithQueue = FALSE;
                }
                else if (FAILED(hr))
                {
                    //The message has been deleted out from underneath us
                    pmsgref->Release();
                    pmsgref = NULL;
                    hr = S_OK;

                    //We want to stay on this queue until it is empty
                    fDoneWithQueue = FALSE;
                }
            } while (!fDoneWithQueue);

        }

        //
        //  On to the next priority
        //
        if (dwCurrentPriority == eEffPriLow)
            break;
        dwCurrentPriority --;
    } while (dwCurrentPriority < NUM_PRIORITIES);

    //Visit a new queue on every GetNextMsg
    InterlockedIncrement((PLONG) &m_dwRoundRobinIndex);

    if (pmsgref && SUCCEEDED(hr)) //we got a message
    {
        *ppIMailMsgProperties = pmsgref->pimsgGetIMsg();
        pmsgref = NULL;
    }
    else //We have failed or do not have a message
    {
        *ppIMailMsgProperties = NULL;
        if (SUCCEEDED(hr)) //don't overwrite other error
            hr = AQUEUE_E_QUEUE_EMPTY;
        else
            ErrorTrace((LPARAM) this, "GetNextMsg returning hr - 0x%08X", hr);
    }

  Exit:

    if (pdmrq)
        pdmrq->Release();

    if (NULL != pmsgref)
        pmsgref->Release();

    if (fLockedQueues)
        m_slQueues.ShareUnlock();

    if (fLockedShutdown)
    {
        m_paqinst->RoutingShareUnlock();
        m_paqinst->ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrAckMsg ]-------------------------------------------------
//
//
//  Description:
//      Acknowledges the delivery of a message (success/error codes are put in
//      the envelope by the transport).
//
//  Parameters:
//      IN pIMsg        IMsg to acknowledge
//      IN dwMsgContext Context that was returned by GetNextMessage
//      IN eMsgStatus   Summary of Delivery status of message
//      IN dwStatusCode Status code returned by protocol
//      IN cbExtendedStatus Size of extended status buffer
//      IN szExtendedStatus String containing extended status returned by
//                      remote server
//  Returns:
//      S_OK on success
//      E_INVALIDARG if dwMsgContext is invalid
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrAckMsg(MessageAck *pMsgAck)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = NULL;
    _ASSERT(m_paqinst);

    if (NULL == pMsgAck->pvMsgContext)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (MESSAGE_STATUS_ALL_DELIVERED & pMsgAck->dwMsgStatus)
    {
        m_lConsecutiveMessageFailureCount = 0;
        if (!(m_dwLinkFlags & eLinkFlagsConnectionVerifed))
            dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsConnectionVerifed);
        if (LINK_STATE_PRIV_CONFIG_TURN_ETRN & m_dwLinkStateFlags)
        {
            //We delivered successfully as TURN/ETRN... we need to update count
            m_paqinst->IncTURNETRNDelivered();
        }
    }

    hr = HrGetInternalInfo(&pIntDomainInfo);
    if (SUCCEEDED(hr) && pIntDomainInfo)
    {
        if (DOMAIN_INFO_LOCAL_DROP &
            pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags)
        {
            pMsgAck->dwMsgStatus |= MESSAGE_STATUS_DROP_DIRECTORY;
        }
        pIntDomainInfo->Release();
    }
    hr = m_paqinst->HrAckMsg(pMsgAck);

  Exit:
    return hr;
}

//---[  CLinkMsgQueue::HrNotify ]----------------------------------------------
//
//
//  Description:
//      Recieve notification from one of our DestMsgQueues.
//  Parameters:
//      IN  paqstats    Notification object sent
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrNotify(IN CAQStats *paqstats, BOOL fAdd)
{
    HRESULT hr = S_OK;
    DWORD   dwTmp = 0;
    DWORD   dwNotifyType = 0;
    BOOL    fCheckIfNotifyShouldContinue = FALSE;
    _ASSERT(paqstats);

    //Update our own version of stats
    m_aqstats.UpdateStats(paqstats, fAdd);

    //Don't notify if we're configured not to
    if (LINK_STATE_PRIV_NO_NOTIFY & m_dwLinkStateFlags)
        return hr;

    //See if new message update
    if (paqstats->m_dwNotifyType & NotifyTypeDestMsgQueue)
    {
        //$$NOTE:
        //At some point it may be interesting to use the information passed by the
        //DMQ to adjust it's place in the queue (ie. priority).  Currently, we
        //don't care.
        fCheckIfNotifyShouldContinue = TRUE;
    }

    //
    //  If this is a reroute... this may be a new link (with no messages), we
    //  should make sure we add it to the connection manager.
    //
    if (paqstats->m_dwNotifyType & NotifyTypeReroute)
        fCheckIfNotifyShouldContinue = TRUE;

    if (fCheckIfNotifyShouldContinue && fAdd)
    {
        //Wait until we have messages or are rerouting before sending a
        //notification that might add this link to the connection manager
        if ((m_aqstats.m_cMsgs ||
             (paqstats->m_dwNotifyType & NotifyTypeReroute)) &&
           !(eLinkFlagsSentNewNotification & m_dwLinkFlags))
        {

            //Attempt to set first notification flag
            dwTmp = m_dwLinkFlags; //if already set before while, make sure IF fails
            while (!(eLinkFlagsSentNewNotification & m_dwLinkFlags))
            {
                dwTmp = m_dwLinkFlags;
                dwTmp = InterlockedCompareExchange((PLONG) &m_dwLinkFlags,
                    (LONG) (dwTmp | eLinkFlagsSentNewNotification),
                    (LONG) dwTmp);
            }
            if (!(dwTmp & eLinkFlagsSentNewNotification)) //this thread set it
            {

                // Set the type to notify new link so it will be added to
                // the connection manager
                dwNotifyType |= NotifyTypeNewLink;
            }
        }

    }

    if (fAdd) //only send notifcation on when we are adding a new message
    {
        //If we are adding messages... this should not be set
        _ASSERT(!(LINK_STATE_LINK_NO_LONGER_USED & m_dwLinkStateFlags));

        //Change into link notification
        //Connection manager needs to know, in case this link deserves another
        //connection
        paqstats->m_dwNotifyType = dwNotifyType | NotifyTypeLinkMsgQueue;
        paqstats->m_plmq = this;
        hr = m_paqinst->HrNotify(paqstats, fAdd);
    }

    return hr;
}

//---[  CLinkMsgQueue::HrNotify ]----------------------------------------------
//
//
//  Description:
//      Recieve notification from one of our DestMsgQueues that (only) retry queue has been enqueue/dequeue'd.
//      Unlike HrNotify, here we only need to update our stat without notifying m_paqinst and connection manager.
//  Parameters:
//      IN  BOOL fAdd: add or remove
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrNotifyRetryStatChange(BOOL fAdd)
{

    m_aqstats.UpdateRetryStats(fAdd);
    return S_OK;
}


//---[ CLinkMsgQueue::dwModifyLinkState ]--------------------------------------
//
//
//  Description:
//      Sets and unsets state flags for this link
//  Parameters:
//      IN  dwLinkStateToSet    Combination of flags to set
//      IN  dwLinkStateToUnset  Combination of flags to unset
//
//      NOTE: dwLinkStateToSet and dwLinkStateToUnset should not overlap
//  Returns:
//      Original state of links
//  History:
//      9/22/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD  CLinkMsgQueue::dwModifyLinkState(IN DWORD dwLinkStateToSet,
                                        IN DWORD dwLinkStateToUnset)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::dwModifyLinkState");
    DWORD   dwOrigState = m_dwLinkStateFlags;
    DWORD   dwIntermState = m_dwLinkStateFlags;
    DWORD   dwSetBits = dwLinkStateToSet & ~dwLinkStateToUnset;
    DWORD   dwUnsetBits = dwLinkStateToUnset & ~dwLinkStateToSet;

    //we shouldn't do this internally... lets make the operations cancel each other
    _ASSERT(!(dwLinkStateToSet & dwLinkStateToUnset));
    _ASSERT(dwSetBits == dwLinkStateToSet);
    _ASSERT(dwUnsetBits == dwLinkStateToUnset);

    //If info is being updated, we should let it set config-related bits
    m_slInfo.ShareLock();
    if (dwSetBits)
        dwOrigState = dwInterlockedSetBits(&m_dwLinkStateFlags, dwSetBits);

    if (dwUnsetBits)
        dwIntermState = dwInterlockedUnsetBits(&m_dwLinkStateFlags, dwUnsetBits);

    //Make sure we return the correct return value
    if (dwUnsetBits && !dwSetBits)
        dwOrigState = dwIntermState;

    m_slInfo.ShareUnlock();

    DebugTrace((LPARAM) this,
        "ModifyLinkState set:%08X unset:%08X orig:%08X new:%08X",
        dwLinkStateToSet, dwLinkStateToUnset, dwOrigState, m_dwLinkStateFlags);

    TraceFunctLeave();
    return dwOrigState;
}

//---[ CLinkMsgQueue::ScheduledCallback ]--------------------------------------
//
//
//  Description:
//      Callback function for scheduled connection callbacks
//  Parameters:
//      pvContext       this pointer for CLinkMsgQueue
//  Returns:
//      -
//  History:
//      1/16/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::ScheduledCallback(PVOID pvContext)
{
    CLinkMsgQueue  *plmq = (CLinkMsgQueue *) pvContext;
    HRESULT         hr = S_OK;
    IConnectionManager *pIConnectionManager = NULL;
    CConnMgr       *pConnMgr = NULL;
    DWORD           dwLinkState = 0;

    _ASSERT(plmq);
    _ASSERT(LINK_MSGQ_SIG == plmq->m_dwSignature);

    plmq->SendLinkStateNotification();
    dwLinkState = plmq->m_dwLinkStateFlags;


    //If connections are now allowed... we should kick the connection manager
    _ASSERT(plmq->m_paqinst);
    if (plmq->m_paqinst && plmq->fFlagsAllowConnection(dwLinkState))
    {
        hr = plmq->m_paqinst->HrGetIConnectionManager(&pIConnectionManager);
        if (SUCCEEDED(hr))
        {
            _ASSERT(pIConnectionManager);

            pConnMgr = (CConnMgr *) pIConnectionManager;
            if (pConnMgr)
                pConnMgr->KickConnections();
        }
    }

    //Release AddRef from callback
    plmq->Release();

}

//---[ CLinkMsgQueue::SendLinkStateNotification ]------------------------------
//
//
//  Description:
//      Sends notification if to scheduler/routing sink
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/11/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::SendLinkStateNotification()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::SendLinkStateNotification");
    HRESULT     hr              = S_OK;
    GUID        guidRouter      = GUID_NULL;
    DWORD       dwStateToSet    = LINK_STATE_NO_ACTION;
    DWORD       dwStateToUnset  = LINK_STATE_NO_ACTION;
    DWORD       dwResultingLinkState = LINK_STATE_NO_ACTION;
    DWORD       dwOriginalLinkState = LINK_STATE_NO_ACTION;
    DWORD       dwHiddenStateMask = ~(LINK_STATE_RESERVED |
                                      LINK_STATE_CONNECT_IF_NO_MSGS |
                                      LINK_STATE_DO_NOT_DELETE_UNTIL_NEXT_NOTIFY);
    FILETIME    ftNextAttempt;
    BOOL        fSendNotify = TRUE;
    DWORD       dwCurrentLinkState = m_dwLinkStateFlags;

    //
    // We should not send any notifications after we have notified routing
    // that we are going away.  We copy dwCurrentLinkState to a stack
    // variable so that this is thread safe.  If another thread sets
    // LINK_STATE_LINK_NO_LONGER_USED after this check, we will still pass
    // in the original value.
    //
    if (dwCurrentLinkState & LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED)
    {
        fSendNotify = FALSE;
    }
    else if (dwCurrentLinkState & LINK_STATE_LINK_NO_LONGER_USED)
    {
        //
        //  Try to be the first thread to set this.  If we are then we can
        //  continue with the notification
        //
        dwOriginalLinkState = dwModifyLinkState(LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED,
                                                LINK_STATE_NO_ACTION);
        if (dwOriginalLinkState & LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED)
            fSendNotify = FALSE;
    }


    if (m_pILinkStateNotify && fSendNotify)
    {
        ZeroMemory(&ftNextAttempt, sizeof(FILETIME));
        m_aqsched.GetGUID(&guidRouter);
        hr = m_pILinkStateNotify->LinkStateNotify(m_szSMTPDomain, guidRouter,
            m_aqsched.dwGetScheduleID(), m_szConnectorName,
            (dwHiddenStateMask & dwCurrentLinkState),
            (DWORD) m_lConsecutiveConnectionFailureCount, &ftNextAttempt,
            &dwStateToSet, &dwStateToUnset);

        DebugTrace((LPARAM) this,
            "LinkStateNotify set:0x%08X unset:0x%08X hr:0x%08x",
            dwStateToSet, dwStateToUnset, hr);
        //Modify link state only on success and when we aren't deleting it
        if (SUCCEEDED(hr) &&
            !(m_dwLinkStateFlags & LINK_STATE_LINK_NO_LONGER_USED))
        {
            // schedule a callback if one was requested
            if (ftNextAttempt.dwLowDateTime != 0 ||
                ftNextAttempt.dwHighDateTime != 0)
            {
                DebugTrace((LPARAM) this,
                    "Schedule with FileTime %x:%x provided",
                    ftNextAttempt.dwLowDateTime,
                    ftNextAttempt.dwHighDateTime);
                InternalUpdateFileTime(&m_ftNextScheduledCallback,
                                       &ftNextAttempt);
                //callback with next attempt
                AddRef(); //Addref self as context
                hr = m_paqinst->SetCallbackTime(
                        CLinkMsgQueue::ScheduledCallback,
                        this,
                        &ftNextAttempt);
                if (FAILED(hr))
                    Release(); //callback will not happen... release context
            }

            if (!(LINK_STATE_CONNECT_IF_NO_MSGS & dwStateToSet))
            {
                //Routing has not explicitly set LINK_STATE_CONNECT_IF_NO_MSGS.
                //We must unset it because we hid it from routing.  The reason
                //we do this is to allow Routers that are not interested in
                //link-lifetime managment to set LINK_STATE_CONNECT_IF_NO_MSGS
                //and not have to worry about race conditions that could
                //cause a link to be delted while they are requesting a ping
                dwStateToUnset  |= LINK_STATE_CONNECT_IF_NO_MSGS;
            }

            //
            //  If not explicitly set, this bit is reset.  Similar reasons
            //  as above.
            //
            if (!(LINK_STATE_DO_NOT_DELETE_UNTIL_NEXT_NOTIFY & dwStateToSet))
            {
                 dwStateToUnset |= LINK_STATE_DO_NOT_DELETE_UNTIL_NEXT_NOTIFY;
            }

            if (!(m_dwLinkStateFlags & LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION)) {
                dwStateToSet |= LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION;
            }
        }
    }
    else if (!m_pILinkStateNotify)
    {
        // Even if we don't have an ILinkStateNotify interface, we still
        // need to reset this flag to prevent looping on connect
        if (!(LINK_STATE_CONNECT_IF_NO_MSGS & dwStateToSet))
        {
            dwStateToUnset  |= LINK_STATE_CONNECT_IF_NO_MSGS;
        }
    }

    // Update the link state flags if we have any changes to make
    if ((LINK_STATE_NO_ACTION != dwStateToSet) ||
        (LINK_STATE_NO_ACTION != dwStateToUnset))
    {
        dwModifyLinkState(dwStateToSet, dwStateToUnset);
    }

    TraceFunctLeave();
}

//---[ CLinkMsgQueue::fShouldConnect ------------------------------------------
//
//
//  Description:
//      Function that is used to determine if a connection should be
//      made.
//      Uses a heursitic to decide if a connection should be made if multiple
//      queues are routed to this link.. and thus the message count may be
//      larger than it should be (since a message is counted once for each
//      DMQ it is on).
//  Parameters:
//      IN  cMaxLinkConnections         Maximum # of connections per link
//      IN  cMinMessagesPerConnection   Minimum # of messages per link before
//                                      creating an additional connection.
//  Returns:
//      TRUE    If a connection should be created
//      FALSE   Otherwise
//  History:
//      11/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fShouldConnect(IN DWORD cMaxLinkConnections,
                                   IN DWORD cMinMessagesPerConnection)
{
    BOOL    fConnect = FALSE;
    DWORD   cHeuristicMsgs = 0;
    DWORD   cHeuristicCheck = 0;
    DWORD   cCurrentMsgs = m_aqstats.m_cMsgs;
    DWORD   cTotalQueues = m_paqinst->cGetDestQueueCount();
    DWORD   cQueues = m_cQueues; //so it doesn't change on us

    //If we have more than 1 queue and there is a total of more than 1 queue
    //we can use a heurisitc to estimate actual # of messages to send, but
    //don't bother with Heuristic if we are already over our max # of
    //connections.
    if ((m_cConnections < cMaxLinkConnections) &&
        (1 < cTotalQueues) && (1 < cQueues) && cCurrentMsgs)
    {
        //m_aqstats.m_cOtherDomainsMsgSpread is the total # of *other* DMQs
        //a message is associated with (per DMQ).  If all of the DMQs for all
        //messages are on this link then:
        //      m_cOtherDomainsMsgSpread
        //is equal to:
        //      m_cMsgs*m_cMsgs*(cQueues-1).
        //The following function... uses a probabilistic estimate to
        //determine the number of messages that will be sent out this link.
        //Since we cannot always assume that all messages on this link were
        //queued to DMQ's assoicated with this link... we adjust the
        //counted value by a factor of:
        //      ((cQueues-1)/(cTotalQueues-1))
        //To determine the average # of domains per message (and hence the
        //# of times is it counted), we use:
        //  (m_cOtherDomainsMsgSpread+m_cMsgs)/m_cMsgs
        //To get a more accurate average, we modify the m_cOtherDomainsMsgSpread
        //by the probability factor above.
        //Finally:
        //To get our heuristic, we divide the number of msgs by the average
        //number of domains.
        cHeuristicCheck = cCurrentMsgs +
                          m_aqstats.m_cOtherDomainsMsgSpread *
                          ((cQueues-1)/(cTotalQueues-1));

        //This should be non-zero... but can happen if the counts are wrong and
        //m_aqstats.m_cOtherDomainsMsgSpread is negative
        _ASSERT(cHeuristicCheck);

        if (cHeuristicCheck) //but we might as well be defensive
        {
            cHeuristicMsgs = (cCurrentMsgs*cCurrentMsgs)/cHeuristicCheck;
            //Don't let the heuristic make us think there are no msgs to deliver
            if (!cHeuristicMsgs && cCurrentMsgs)
                cHeuristicMsgs = cCurrentMsgs;
        }
        else
        {
            cHeuristicMsgs = cCurrentMsgs;
        }


    }
    else
    {
        cHeuristicMsgs = cCurrentMsgs;
    }

    if ((m_cConnections < cMaxLinkConnections) &&
        (cHeuristicMsgs > m_cConnections*cMinMessagesPerConnection) &&
        fCanSchedule())
    {
        //If we have no had a successful message only open 1 connection
        if (!(m_dwLinkFlags & eLinkFlagsConnectionVerifed))
        {
            if (m_cConnections < 3)
                fConnect = TRUE;
        }
        else
            fConnect = TRUE;
    }
    else if (fCanSchedule() && !cHeuristicMsgs &&
             ((LINK_STATE_CONNECT_IF_NO_MSGS & m_dwLinkStateFlags) &&
             !m_cConnections))
    {
        //We want to create a connection to probe link state
        fConnect = TRUE;
    }

    return fConnect;
}

//---[ CLinkMsgQueue::HrCreateConnectionIfNeeded ]-----------------------------
//
//
//  Description:
//
//  Parameters:
//      IN  cMaxLinkConnections         Maximum # of connections per link
//      IN  cMinMessagesPerConnection   Minimum # of messages per link before
//                                      creating an additional connection.
//      IN  cMaxMessagesPerConnection   Max messages to send on a single
//                                      connection (0 is unlimited)
//      IN  pConnMgr                    Ptr to instance connection manger
//      OUT pSMTPConn                   New connection object for this link
//  Returns:
//      S_OK on success if connection is needed
//      S_FALSE on success if connection is not needed
//      E_OUTOFMEMORY if connection object could not be created
//  History:
//      11/5/98 - MikeSwa Created
//      12/7/1999 - MikeSwa Updated to make sure linkstate notify happens first
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrCreateConnectionIfNeeded(
                                       IN  DWORD cMaxLinkConnections,
                                       IN  DWORD cMinMessagesPerConnection,
                                       IN  DWORD cMaxMessagesPerConnection,
                                       IN  CConnMgr *pConnMgr,
                                       OUT CSMTPConn **ppSMTPConn)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrCreateConnectionIfNeeded");
    HRESULT hr = S_FALSE;
    _ASSERT(ppSMTPConn);
    *ppSMTPConn = NULL;
    CSMTPConn *pSMTPConn = NULL;

    //We cannot create a connection until we have done our link state
    //notification, because routing needs to have an opportunity to
    //set the schedule for a link
    SendLinkStateNotificationIfNew();

    //Should we create a connection?
    if (!fShouldConnect(cMaxLinkConnections, cMinMessagesPerConnection))
        goto Exit;

    //Try and be the thread that can create a connection
    if (((DWORD) InterlockedIncrement((PLONG) &m_cConnections)) > cMaxLinkConnections)
    {
        InterlockedDecrement((PLONG) &m_cConnections);
        goto Exit;
    }

    *ppSMTPConn = new CSMTPConn(pConnMgr, this, cMaxMessagesPerConnection);

    if (!*ppSMTPConn)
    {
        InterlockedDecrement((PLONG) &m_cConnections);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Grab lock and insert into list
    m_slConnections.ExclusiveLock();
    (*ppSMTPConn)->InsertConnectionInList(&m_liConnections);
    m_slConnections.ExclusiveUnlock();

  Exit:

    //Make sure our return result is correct.
    if (SUCCEEDED(hr))
    {
        if (*ppSMTPConn)
        {
            DebugTrace((LPARAM) this,
                "Creating connection - linkstate:0x%08X",
                m_dwLinkStateFlags);
            hr = S_OK;
        }
        else
        {
            DebugTrace((LPARAM) this,
                "Not creating connection - linkstate 0x%08X",
                m_dwLinkStateFlags);
            hr = S_FALSE;
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::RemoveAllQueues ]----------------------------------------
//
//
//  Description:
//      Removes all queues from a link, without deleting or invalidating a
//      link.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      11/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemoveAllQueues()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::RemoveAllQueues");
    PVOID   pvContext = NULL;
    CDestMsgQueue *pdmq = NULL;

    //Walk list of queues and release them
    dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsRouteChangePending);
    m_slQueues.ExclusiveLock();
    pdmq = (CDestMsgQueue *) m_qlstQueues.pvDeleteItem(0, &pvContext);
    while (pdmq)
    {
        m_cQueues--;
        pdmq->AssertSignature();
        pdmq->RemoveDMQFromLink(FALSE);
        pdmq->Release();
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvDeleteItem(0, &pvContext);
    }
    m_aqstats.Reset();
    dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsRouteChangePending);
    m_slQueues.ExclusiveUnlock();

    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetLinkInfo ]------------------------------------------
//
//
//  Description:
//      Fills in the details for a LINK_INFO struct.  RPC is resonsible for
//      freeing memory.
//  Parameters:
//      IN OUT pliLinkInfo  Ptr to link info struct to fill
//  Returns:
//      S_OK if successful
//      E_OUTOFMEMORY if unable to allocate memory
//  History:
//      12/3/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to be IQueueAdminLink method
//      6/10/99 - MikeSwa Modified to support new QueueAdmin functionality
//      7/1/99 - MikeSwa Added LinkDiagnostic
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrGetLinkInfo(LINK_INFO *pliLinkInfo,
                                          HRESULT   *phrLinkDiagnostic)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrGetLinkInfo");
    pliLinkInfo->cMessages = m_aqstats.m_cMsgs;
    pliLinkInfo->fStateFlags = 0;
    FILETIME ftCurrent;
    FILETIME ftOldest;
    FILETIME *pftNextConnection = NULL;
    BOOL     fFoundOldest = FALSE;
    DWORD    iQueues = 0;
    PVOID    pvContext = NULL;
    CDestMsgQueue *pdmq = NULL;
    HRESULT  hr = S_OK;

    //
    //Determine the state... check in order of most to least important
    //
    if (GetLinkType() == LI_TYPE_CURRENTLY_UNREACHABLE)
        pliLinkInfo->fStateFlags = LI_READY;
    else if (LINK_STATE_ADMIN_HALT & m_dwLinkStateFlags)
        pliLinkInfo->fStateFlags = LI_FROZEN;
    else if (m_cConnections)
        pliLinkInfo->fStateFlags = LI_ACTIVE;
    else if (!(LINK_STATE_RETRY_ENABLED & m_dwLinkStateFlags))
        pliLinkInfo->fStateFlags = LI_RETRY;
    else if (!(LINK_STATE_SCHED_ENABLED & m_dwLinkStateFlags))
        pliLinkInfo->fStateFlags = LI_SCHEDULED;
    else if (m_lConsecutiveConnectionFailureCount)
        pliLinkInfo->fStateFlags = LI_RETRY;
    else if (LINK_STATE_PRIV_CONFIG_TURN_ETRN & m_dwLinkStateFlags)
        pliLinkInfo->fStateFlags = LI_REMOTE;
    else //default to ready
        pliLinkInfo->fStateFlags = LI_READY;

    pliLinkInfo->fStateFlags |= GetLinkType();

    //Write diagnostic
    if (phrLinkDiagnostic)
        *phrLinkDiagnostic = m_hrDiagnosticError;

    //Get Size
    pliLinkInfo->cbLinkVolume.QuadPart = m_aqstats.m_uliVolume.QuadPart;

    //Find stOldestMessage
    m_slQueues.ShareLock();
    for (iQueues = 0;iQueues < m_cQueues; iQueues++)
    {
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvContext);

        if (!pdmq) continue;

        pdmq->GetOldestMsg(&ftCurrent);
        //
        //  If we got a valid time, and it is earlier than the time we have
        //  now, then use it as the oldest for the link
        //
        if ((ftCurrent.dwLowDateTime || ftCurrent.dwHighDateTime) &&
            (!fFoundOldest || (0 < CompareFileTime(&ftOldest, &ftCurrent))))
        {
            memcpy(&ftOldest, &ftCurrent, sizeof(FILETIME));
            fFoundOldest = TRUE;
        }

        //  Also count the failed messages (they're counted separately in the DMQ)
        pliLinkInfo->cMessages += pdmq->cGetFailedMsgs();
    }
    m_slQueues.ShareUnlock();


    //If we have not found an oldest, and the time is non-zero
    //and we have messages, then report it.
    if (fFoundOldest &&
       (ftOldest.dwLowDateTime || ftOldest.dwHighDateTime) &&
       pliLinkInfo->cMessages)
    {
        QueueAdminFileTimeToSystemTime(&ftOldest, &pliLinkInfo->stOldestMessage);
    }
    else
    {
        ZeroMemory(&pliLinkInfo->stOldestMessage, sizeof(SYSTEMTIME));
    }

    //
    //  Get next connection attempt time based on the state we are reporting
    //
    if (LI_RETRY & pliLinkInfo->fStateFlags)
    {
        pftNextConnection = &m_ftNextRetry;
    }
    else if (LI_SCHEDULED & pliLinkInfo->fStateFlags)
    {
        pftNextConnection = &m_ftNextScheduledCallback;
    }

    //
    //  If we are reporting a time, and it is non-zero, convert it to
    //  a system time.
    //
    if (pftNextConnection &&
        (pftNextConnection->dwHighDateTime || pftNextConnection->dwLowDateTime))
    {
        QueueAdminFileTimeToSystemTime(pftNextConnection,
                             &pliLinkInfo->stNextScheduledConnection);
        if (LI_SCHEDULED & pliLinkInfo->fStateFlags)
        {
            //
            //  Currently times are displayed at :02, :17, :32:, and :47... we will
            //  fudge the display time to that it actually says :00, :15, :30, :45
            //  to give the admin a better "admin experience" by rouding off to
            //  the nearest 5 minutes.
            //
            pliLinkInfo->stNextScheduledConnection.wMinute -=
                (pliLinkInfo->stNextScheduledConnection.wMinute % 5);
        }
    }
    else
    {
        //
        //  In this case, we don't have a time.
        //
        ZeroMemory(&pliLinkInfo->stNextScheduledConnection, sizeof(SYSTEMTIME));
    }

    if (m_szConnectorName)
    {
        pliLinkInfo->szLinkDN = wszQueueAdminConvertToUnicode(m_szConnectorName, 0);
        if (!pliLinkInfo->szLinkDN)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else
    {
        pliLinkInfo->szLinkDN = NULL;
    }

    //$$TODO - Fill in pliLinkInfo->szExtendedStateInfo as appropriate
    pliLinkInfo->szExtendedStateInfo = NULL;

    if (!fRPCCopyName(&pliLinkInfo->szLinkName))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pliLinkInfo->dwSupportedLinkActions = m_dwSupportedActions;

  Exit:
    if (FAILED(hr))
    {
        //Cleanup allocated memory
        if (pliLinkInfo->szLinkDN)
        {
            QueueAdminFree(pliLinkInfo->szLinkDN);
            pliLinkInfo->szLinkDN = NULL;
        }

        if (pliLinkInfo->szLinkName)
        {
            QueueAdminFree(pliLinkInfo->szLinkName);
            pliLinkInfo->szLinkName = NULL;
        }

        if (pliLinkInfo->szExtendedStateInfo)
        {
            QueueAdminFree(pliLinkInfo->szExtendedStateInfo);
            pliLinkInfo->szExtendedStateInfo = NULL;
        }
    }

    //
    // Sanity checks to make sure we aren't passing back a zero'd
    // FILETIME converted to a system time (which would have a
    // year of 1601).
    //
    _ASSERT(1601 != pliLinkInfo->stNextScheduledConnection.wYear);
    _ASSERT(1601 != pliLinkInfo->stOldestMessage.wYear);

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrGetLinkID ]---------------------------------------------
//
//
//  Description:
//      Fills in the QUEUELINK_ID structure for this link.  Caller must free
//      memory allocated for link name
//  Parameters:
//      IN OUT  pLinkID     Ptr to link id struct to fill in
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if memory allocation fails
//  History:
//      12/3/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to IQueueAdminLink method
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetLinkID(QUEUELINK_ID *pLinkID)
{
    pLinkID->qltType = QLT_LINK;
    pLinkID->dwId = m_aqsched.dwGetScheduleID();
    m_aqsched.GetGUID(&pLinkID->uuid);

    if (!fRPCCopyName(&pLinkID->szName))
        return E_OUTOFMEMORY;
    else
        return S_OK;
}

//---[ CLinkMsgQueue::HrGetQueueIDs ]--------------------------------------------
//
//
//  Description:
//      Gets the Queue IDs for DMQs associated with this link.  Used by Queue
//      Admin.
//  Parameters:
//      IN OUT pcQueues     Sizeof array/ number of queues found
//      IN OUT rgQueues     Array to dump queue info into
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY on out of memory failure
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//  History:
//      12/3/98 - MikeSwa Created
//      2/22/99 - MikeSwa Updated to IQueueAdminLink function
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrGetQueueIDs(DWORD *pcQueues, QUEUELINK_ID *rgQueues)
{
    _ASSERT(pcQueues);
    _ASSERT(rgQueues);
    HRESULT hr = S_OK;
    DWORD   iQueues = 0;
    PVOID   pvContext = NULL;
    CDestMsgQueue *pdmq = NULL;
    QUEUELINK_ID *pCurrentQueueID = rgQueues;

    m_slQueues.ShareLock();

    if (*pcQueues < m_cQueues)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *pcQueues = 0;

    //Iterate over all queues and get IDs
    for (iQueues = 0; iQueues < m_cQueues && SUCCEEDED(hr); iQueues++)
    {
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvContext);

        _ASSERT(pdmq);
        hr = pdmq->HrGetQueueID(pCurrentQueueID);
        if (FAILED(hr))
            goto Exit;

        pCurrentQueueID++;
        (*pcQueues)++;
    }


  Exit:
    m_slQueues.ShareUnlock();
    return hr;
}


//---[ CLinkMsgQueue::HrApplyQueueAdminFunction ]------------------------------
//
//
//  Description:
//      Used by queue admin to apply a function all queues on this link
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      12/11/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to IQueueAdminAction interface
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrApplyQueueAdminFunction(
                          IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    HRESULT hr = S_OK;
    DWORD   iQueues = 0;
    PVOID   pvListContext = NULL;
    CDestMsgQueue *pdmq = NULL;
    IQueueAdminAction *pIQueueAdminAction = NULL;

    m_slQueues.ShareLock();

    //Iterate over all queues and get IDs
    for (iQueues = 0; iQueues < m_cQueues && SUCCEEDED(hr); iQueues++)
    {
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvListContext);

        _ASSERT(pdmq);

        hr = pdmq->QueryInterface(IID_IQueueAdminAction,
                                  (void **) &pIQueueAdminAction);
        if (FAILED(hr))
            goto Exit;

        _ASSERT(pIQueueAdminAction);

        hr = pIQueueAdminAction->HrApplyQueueAdminFunction(
                                        pIQueueAdminMessageFilter);
        if (FAILED(hr))
            goto Exit;
    }

  Exit:
    m_slQueues.ShareUnlock();

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    return hr;
}


//---[ CLinkMsgQueue::InternalUpdateFileTime ]---------------------------------
//
//
//  Description:
//      Updates an internal filetime in a thread safe manner.  This does not
//      guarantee that the filetime will be updated, but does guarantee that
//      if it is updated, the filetime is not corrupt.
//
//      NOTE: these file times are used only for display purposes by the
//      Queue Admin
//  Parameters:
//      pftDest     Ptr to member variable to update
//      pftSrc      Pft to source filetime
//  Returns:
//      -
//  History:
//      1/11/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::InternalUpdateFileTime(FILETIME *pftDest, FILETIME *pftSrc)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::InternalUpdateFileTime");
    if (pftDest && pftSrc)
    {
        DebugTrace((LPARAM) this,
                    "Updating filetime from %x:%x to %x:%x",
                    pftDest->dwLowDateTime, pftDest->dwHighDateTime,
                    pftSrc->dwLowDateTime, pftSrc->dwHighDateTime);

        if (!(eLinkFlagsFileTimeSpinLock &
              dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsFileTimeSpinLock)))
        {
            //We got the spinlock
            memcpy(pftDest, pftSrc, sizeof(FILETIME));
            dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsFileTimeSpinLock);
        }
    }
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetNextMsgRef ]----------------------------------------
//
//
//  Description:
//      Returns the next MsgRef to be delivered without doing the
//      PrepareDelivery step.  This is used in gateway delivery to route the
//      message to the locally.  Additionally, this will mark all a the
//      gateway DMQ's as local on the msgref, so that a subsequent reroute
//      will only affect messages that have not already been put in the
//      local delivery queue.
//  Parameters:
//      IN      fRoutingLockHeld    TRUE is routing lock is already held
//      OUT     ppmsgref            Returned Msg
//  Returns:
//      S_OK on success
//      AQUEUE_E_QUEUE_EMPTY otherwise
//  History:
//      1/26/99 - MikeSwa Created
//      3/25/99 - MikeSwa Added fRoutingLockHeld to fix deadlock
//      2/17/2000 - MikeSwa Modified for gateway delivery reroute
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetNextMsgRef(IN  BOOL fRoutingLockHeld,
                                       OUT CMsgRef **ppmsgref)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrGetNextMsg");
    _ASSERT(ppmsgref);

    HRESULT           hr         = S_OK;
    BOOL              fLockedShutdown = FALSE;
    BOOL              fLockedQueues = FALSE;
    DWORD             iQueues    = 0;
    DWORD             dwCurrentRoundRobinIndex = m_dwRoundRobinIndex;
    CDestMsgQueue     *pdmq = NULL;
    PVOID             pvContext = NULL;

    if (m_dwLinkFlags & eLinkFlagsInvalid)
    {
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }

    //Don't even bother to wait for queue lock if routing change is pending
    if ((m_dwLinkFlags & eLinkFlagsRouteChangePending) || !m_aqstats.m_cMsgs)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    //Make sure domain info is updated & we should still be sending messages
    if (!m_paqinst->fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    //Current implementation of sharelocks are not share reentrant.  Only
    //grab lock if caller has not.
    if (!fRoutingLockHeld)
        m_paqinst->RoutingShareLock();

    fLockedShutdown = TRUE;

    m_slQueues.ShareLock();
    fLockedQueues = TRUE;

    if (m_cQueues == 0)
    {
        //There are currently no queue associated with this link
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    //$$TODO impose some ordering on these queues
    for (iQueues = 0;
         iQueues < m_cQueues && SUCCEEDED(hr) && !(*ppmsgref);
         iQueues++)
    {
        *ppmsgref = NULL;
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(
                        (iQueues+dwCurrentRoundRobinIndex)%m_cQueues, &pvContext);

        _ASSERT(pdmq);
        pdmq->AssertSignature();

        //get msg reference
        hr = pdmq->HrDequeueMsg(eEffPriLow, ppmsgref, NULL);
        if (FAILED(hr))
        {
            if (AQUEUE_E_QUEUE_EMPTY == hr)
                hr = S_OK;
            else
                goto Exit;
        }

        //
        //  Mark this as a local queue for this message
        //
        if (*ppmsgref)
            (*ppmsgref)->MarkQueueAsLocal(pdmq);
    }

    //Visit a new queue on every GetNextMsg
    InterlockedIncrement((PLONG) &m_dwRoundRobinIndex);

  Exit:

    if (fLockedQueues)
        m_slQueues.ShareUnlock();

    if (fLockedShutdown)
    {
        //If routing lock is not held by caller, then we must release it
        if (!fRoutingLockHeld)
            m_paqinst->RoutingShareUnlock();
        m_paqinst->ShutdownUnlock();
    }

    if (!*ppmsgref)
        hr = AQUEUE_E_QUEUE_EMPTY;

    TraceFunctLeave();
    return hr;
}


//---[ CLinkMsgQueue::HrPrepareDelivery ]--------------------------------------
//
//
//  Description:
//      Prepares delivery for a message for this link
//  Parameters:
//      IN      pmsgref     MsgRef to prepare for delivery
//      IN      fQueuesLock TRUE is m_slQueues is locked already
//      IN      fLocal      Prepare delivery for all domains with NULL queues
//      IN      fDelayDSN   Check/Set Delay bitmap (only send 1 Delay DSN).
//      IN      pqlstQueues QuickList of DMQ's
//      IN OUT  pdcntxt     context that must be returned on Ack
//      OUT     pcRecips    # of recips to deliver for
//      OUT     prgdwRecips Array of recipient indexes
//  Returns:
//      S_OK on success
//      Failure code from CMsgRef::HrPrepareDelivery
//  History:
//      1/26/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrInternalPrepareDelivery(
                                IN CMsgRef *pmsgref,
                                IN BOOL fQueuesLocked,
                                IN BOOL fLocal,
                                IN BOOL fDelayDSN,
                                IN OUT CDeliveryContext *pdcntxt,
                                OUT DWORD *pcRecips,
                                OUT DWORD **prgdwRecips)
{
    HRESULT hr = S_OK;
    BOOL    fQueuesLockedByUs = FALSE;

    _ASSERT(pmsgref);

    if (!pmsgref)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!fQueuesLocked)
    {
        m_slQueues.ShareLock();
        fQueuesLockedByUs = TRUE;
    }

    hr = pmsgref->HrPrepareDelivery(fLocal, fDelayDSN, &m_qlstQueues, NULL,
                                    pdcntxt, pcRecips, prgdwRecips);

    if (FAILED(hr))
        goto Exit;

  Exit:

    if (fQueuesLockedByUs)
        m_slQueues.ShareUnlock();

    return hr;

}

//---[ CLinkMsgQueue::SetDiagnosticInfo ]--------------------------------------
//
//
//  Description:
//      Sets the diagnostic information for this link
//  Parameters:
//      IN      hrDiagnosticError       Error code... if SUCCESS we thow away
//                                      the rest of the information
//      IN      szDiagnosticVerb        String pointing to the protocol
//                                      verb that caused the failure.
//      IN      szDiagnosticResponse    String that contains the remote
//                                      servers response.
//  Returns:
//      -
//  History:
//      2/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::SetDiagnosticInfo(
                    IN  HRESULT hrDiagnosticError,
                    IN  LPCSTR szDiagnosticVerb,
                    IN  LPCSTR szDiagnosticResponse)
{
    m_slInfo.ExclusiveLock();
    m_hrDiagnosticError = hrDiagnosticError;

    //zero original buffers
    ZeroMemory(&m_szDiagnosticVerb, sizeof(m_szDiagnosticVerb));
    ZeroMemory(&m_szDiagnosticResponse, sizeof(m_szDiagnosticResponse));

    //copy buffers
    if (szDiagnosticVerb)
        strncpy(m_szDiagnosticVerb, szDiagnosticVerb,
            sizeof(m_szDiagnosticVerb)-1);

    if (szDiagnosticResponse)
        strncpy(m_szDiagnosticResponse, szDiagnosticResponse,
            sizeof(m_szDiagnosticResponse)-1);

    m_slInfo.ExclusiveUnlock();
}

//---[ CLinkMsgQueue::GetDiagnosticInfo ]--------------------------------------
//
//
//  Description:
//      Gets the diagnostic information for this link
//  Parameters:
//      IN  LPSTR   szDiagnosticVerb    - buffer to receive the verb that
//                                        caused the error
//      IN  DWORD   cDiagnosticVerb     - length of the buffer
//      IN  LPSTR   szDiagnosticResponse- buffer to recieve the response
//                                        of the error
//      IN  DWORD   cbDiagnosticResponse- length of buffer
//      OUT HRESULT *phrDiagnosticError - HRESULT for error
//  Returns:
//      -
//  History:
//      3/9/99 - AWetmore Created
//      8/2/99 - Mikeswa...updated to use m_slInfo.
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::GetDiagnosticInfo(
                    IN  LPSTR   szDiagnosticVerb,
                    IN  DWORD   cbDiagnosticVerb,
                    IN  LPSTR   szDiagnosticResponse,
                    IN  DWORD   cbDiagnosticResponse,
                    OUT HRESULT *phrDiagnosticError)
{
    if (szDiagnosticVerb)
        ZeroMemory(szDiagnosticVerb, cbDiagnosticVerb);

    if (szDiagnosticResponse)
        ZeroMemory(szDiagnosticResponse, cbDiagnosticResponse);

    m_slInfo.ShareLock();
    if (phrDiagnosticError)
        *phrDiagnosticError = m_hrDiagnosticError;

    //copy buffers
    if (*m_szDiagnosticVerb && szDiagnosticVerb)
        strncpy(szDiagnosticVerb, m_szDiagnosticVerb, cbDiagnosticVerb);

    if (*m_szDiagnosticResponse && szDiagnosticResponse)
        strncpy(szDiagnosticResponse,
                m_szDiagnosticResponse,
                cbDiagnosticResponse);

    m_slInfo.ShareUnlock();
}

//---[ CLinkMsgQueue::HrApplyActionToMessage ]---------------------------------
//
//
//  Description:
//      Applies an action to this message for this queue.  This will be called
//      by the IQueueAdminMessageFilter during a queue enumeration function.
//
//      This code path is currently not executed... eventually me may consider
//      doing this to allow a DSN to be generated per link.
//
//      For this to be called.  CLinkMsgQueue::HrApplyActionToMessage would
//      need to iterate over the DMQ's queues with it's own IQueueAdminAction
//      iterface pointed to by the filter intead of the DMQ's.
//
//  Parameters:
//      IN  *pIUnknownMsg       ptr to message abstraction
//      IN  ma                  Message action to perform
//      IN  pvContext           Context set on IQueueAdminFilter
//      OUT pfShouldDelete      TRUE if the message should be deleted
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created
//      4/2/99 - MikeSwa Added context
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrApplyActionToMessage(
        IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
        BOOL *pfShouldDelete)
{
    _ASSERT(0 && "Not reachable");
    return E_NOTIMPL;
}

//---[ CLinkMsgQueue::HrApplyActionToLink ]------------------------------------
//
//
//  Description:
//      Applies the specified QueueAdmin action to this link
//  Parameters:
//      IN  la          Link action to apply
//  Returns:
//      S_OK on success
//      E_INVALIDARG if bogus action is given
//  History:
//      2/22/99 - MikeSwa Created (moved most of code from
//                          CAQSvrInst::SetLinkState)
//
//-----------------------------------------------------------------------------
STDMETHODIMP  CLinkMsgQueue::HrApplyActionToLink(LINK_ACTION la)
{
    DWORD   dwLinkFlagsToSet = LINK_STATE_NO_ACTION;
    DWORD   dwLinkFlagsToUnset = LINK_STATE_NO_ACTION;
    HRESULT hr = S_OK;

    //Is action supported?
    if (!fActionIsSupported(la))
        goto Exit;

    //figure out how we want to change the link state
    if (LA_KICK == la)
    {
        //kick the link
        dwLinkFlagsToSet = LINK_STATE_RETRY_ENABLED |
                           LINK_STATE_ADMIN_FORCE_CONN |
                           LINK_STATE_CONNECT_IF_NO_MSGS;
        dwLinkFlagsToUnset = LINK_STATE_ADMIN_HALT;
    }
    else if (LA_FREEZE == la)
    {
        //Admin wants this link to stop sending mail outbound
        dwLinkFlagsToSet = LINK_STATE_ADMIN_HALT;
        dwLinkFlagsToUnset = LINK_STATE_ADMIN_FORCE_CONN;
    }
    else if (LA_THAW == la)
    {
        //Unset frozen flags
        dwLinkFlagsToUnset = LINK_STATE_ADMIN_HALT;
    }
    else
    {
        //invalid arg
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwModifyLinkState(dwLinkFlagsToSet, dwLinkFlagsToUnset);

  Exit:
    return hr;

}

//---[ CLinkMsgQueue::QueryInterface ]-----------------------------------------
//
//
//  Description:
//      QueryInterface for CDestMsgQueue that supports:
//          - IQueueAdminAction
//          - IUnknown
//          - IQueueAdminLink
//  Parameters:
//
//  Returns:
//
//  History:
//      2/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminAction == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminLink == riid)
    {
        *ppvObj = static_cast<IQueueAdminLink *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CLinkMsgQueue::HrGetNumQueues ]-----------------------------------------
//
//
//  Description:
//      Returns the number of queues on this link
//  Parameters:
//      OUT pcQueues        # numbr of queues
//  Returns:
//      S_OK on success
//      E_POINTER if pcQueues is not valid
//  History:
//      2/22/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrGetNumQueues(DWORD *pcQueues)
{
    HRESULT hr = S_OK;

    _ASSERT(pcQueues);
    if (!pcQueues)
    {
        hr = E_POINTER;
        goto Exit;
    }

    *pcQueues = cGetNumQueues();
  Exit:
    return hr;
}



//---[ CLinkMsgQueue::fMatchesID ]---------------------------------------------
//
//
//  Description:
//      Used to determine if this link matches a given scheduleID/link pair
//  Parameters:
//      IN  QueueLinkID         ID to match against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CLinkMsgQueue::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    _ASSERT(pQueueLinkID);
    _ASSERT(pQueueLinkID->szName);
    CAQScheduleID aqsched(pQueueLinkID->uuid, pQueueLinkID->dwId);

    if (!fIsSameScheduleID(&aqsched))
        return FALSE;

    if (!fBiStrcmpi(m_szSMTPDomain, pQueueLinkID->szName))
        return FALSE;

    //Everything matched!
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\linkmsgq.h ===
//-----------------------------------------------------------------------------
//
//
//    File: linkmsgq.h
//
//    Description:
//        This provides a description of one of the external interfaces provided
//        by the CMT.  CLinkMsgQueue provides Route factoring with an interface
//        to get the next message for a given link.
//
//    Owner: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef _LINKMSGQ_H_
#define _LINKMSGQ_H_

#include "cmt.h"
#include <rwnew.h>
#include <baseobj.h>
#include <aqueue.h>
#include "domain.h"
#include "aqroute.h"
#include "smproute.h"
#include <listmacr.h>
#include "qwiklist.h"
#include "dcontext.h"
#include "aqstats.h"
#include "aqnotify.h"
#include "aqadmsvr.h"

class CAQSvrInst;
class CDestMsgQueue;
class CConnMgr;
class CSMTPConn;
class CInternalDomainInfo;

#define LINK_MSGQ_SIG ' QML'

//Define private link state flags
//NOTE - Be sure to add new private flags to AssertPrivateLinkStateFlags as well
#define LINK_STATE_PRIV_CONFIG_TURN_ETRN            0x80000000
#define LINK_STATE_PRIV_ETRN_ENABLED                0x40000000
#define LINK_STATE_PRIV_TURN_ENABLED                0x20000000
#define LINK_STATE_PRIV_NO_NOTIFY                   0x10000000
#define LINK_STATE_PRIV_NO_CONNECTION               0x08000000
#define LINK_STATE_PRIV_GENERATING_DSNS             0x04000000
#define LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY      0x02000000
#define LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION      0x01000000
#define LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED    0x00400000

#define EMPTY_LMQ_EXPIRE_TIME_MINUTES               2

//---[ enum LinkFlags ]--------------------------------------------------------
//
//
//  Hungarian: lf, pfl
//
//  Private link data flags
//-----------------------------------------------------------------------------
typedef enum _LinkFlags
{
    eLinkFlagsClear                 = 0x00000000,
    eLinkFlagsSentNewNotification   = 0x00000001,
    eLinkFlagsRouteChangePending    = 0x00000002,
    eLinkFlagsFileTimeSpinLock      = 0x00000004,
    eLinkFlagsDiagnosticSpinLock    = 0x00000008,
    eLinkFlagsConnectionVerifed     = 0x00000010,
    eLinkFlagsGetInfoFailed         = 0x00000020,
    eLinkFlagsAQSpecialLinkInfo     = 0x00000040,
    eLinkFlagsInternalSMTPLinkInfo  = 0x00000080,
    eLinkFlagsExternalSMTPLinkInfo  = 0x00000100,
    eLinkFlagsMarkedAsEmpty         = 0x00000200,
    eLinkFlagsInvalid               = 0x80000000,   //link has been tagged as invalid
} LinkFlags, *PLinkFlags;

//inline function to verify that private flags are only using reserved bits
inline void AssertPrivateLinkStateFlags()
{
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_CONFIG_TURN_ETRN));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_ETRN_ENABLED));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_TURN_ENABLED));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_NO_NOTIFY));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_NO_CONNECTION));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_GENERATING_DSNS));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED));
}

// {34E2DCCB-C91A-11d2-A6B1-00C04FA3490A}
static const GUID g_sDefaultLinkGuid =
{ 0x34e2dccb, 0xc91a, 0x11d2, { 0xa6, 0xb1, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

// Global count of failures : "failed to add queue to link because link was
// marked as no longer in use"
_declspec(selectany) DWORD g_cFailedToAddQueueToRemovedLink = 0;

//---[ CLinkMsgQueue ]---------------------------------------------------------
//
//
//    Hungarian: linkq, plinkq
//
//
//-----------------------------------------------------------------------------
class CLinkMsgQueue :
    public IQueueAdminAction,
    public IQueueAdminLink,
    public CBaseObject,
    public IAQNotify,
    public CQueueAdminRetryNotify
{
protected:
    DWORD           m_dwSignature;
    DWORD           m_dwLinkFlags;    //private data
    DWORD           m_dwLinkStateFlags; //Link state flags (private + eLinkStateFlagsf)
    CAQSvrInst     *m_paqinst;         //ptr to the virtual server intance object
    DWORD           m_cQueues;         //Number of queues on Link
    CQuickList      m_qlstQueues;
    CDomainEntry   *m_pdentryLink;     //Domain Entry for link
    DWORD           m_cConnections;    //Number of current connections
    DWORD           m_dwRoundRobinIndex; //Used to round-robin through queues
    CShareLockInst  m_slConnections; //lock to access connections
    CShareLockInst  m_slInfo;      //share lock for link info
    CShareLockInst  m_slQueues;   //lock to access queues
    DWORD           m_cbSMTPDomain;    //byte count of next hop domain name
    LPSTR           m_szSMTPDomain;    //ptr to string of next hop
    CInternalDomainInfo *m_pIntDomainInfo;  //internal config info for domain
    LONG            m_lConnMgrCount;   //Count used by connection manager

    //
    //  We have 2 failure counts to keep track of the 2 types of failures.
    //  m_lConsecutiveConnectionFailureCount keeps track of the number consecutive
    //  failures to make a connection to a remote machine.
    //  m_lConsecutiveMessageFailureCount tracks the number of failures to actually
    //  send a message.  They will be different if we can connect to a remote
    //  server but cannot (or have not) sent mail.  m_lConsecutiveConnectionFailureCount
    //  is reported to routing, so that mail will be routed to this link, while
    //  m_lConsecutiveMessageFailureCount is used to determine the retry interval.
    //  By doing this, we can avoid resetting our retry times if we successfully
    //  connect, but cannot actually send a message.
    //
    LONG            m_lConsecutiveConnectionFailureCount;
    LONG            m_lConsecutiveMessageFailureCount;

    LPSTR           m_szConnectorName;
    IMessageRouterLinkStateNotification *m_pILinkStateNotify;

    //Filetimes reported to queue admin
    FILETIME        m_ftNextRetry;
    FILETIME        m_ftNextScheduledCallback;

    //
    //  Used by RemoveLinkIfEmpty to make sure that we cache links for
    //  a period of time after them become empty.  This is only
    //  valid when the eLinkFlagsMarkedAsEmpty bit is set.
    //
    FILETIME        m_ftEmptyExpireTime;

    //Message statistics
    CAQStats        m_aqstats;

    CAQScheduleID   m_aqsched;    //ScheduleID returned by routing
    LIST_ENTRY      m_liLinks;     //linked list of links for this domain
    LIST_ENTRY      m_liConnections; //linked list of connections for this domain

    //Diagnostic information returned by SMTPSVC
    HRESULT         m_hrDiagnosticError;
    CHAR            m_szDiagnosticVerb[20];  //failed protocol VERB
    CHAR            m_szDiagnosticResponse[100]; //response from remote server


    //See comments near SetLinkType()/GetLinkType() and
    //SetSupportedActions()/fActionIsSupported() functions.
    DWORD           m_dwSupportedActions;
    DWORD           m_dwLinkType;

    //Gets & verifies internal domain info
    HRESULT HrGetInternalInfo(OUT CInternalDomainInfo **ppIntDomainInfo);
    static inline BOOL fFlagsAllowConnection(DWORD dwFlags);
    HRESULT         m_hrLastConnectionFailure;

    void            InternalUpdateFileTime(FILETIME *pftDest, FILETIME *pftSrc);

    void            InternalInit();

    HRESULT CLinkMsgQueue::HrInternalPrepareDelivery(
                                IN CMsgRef *pmsgref,
                                IN BOOL fQueuesLocked,
                                IN BOOL fLocal,
                                IN BOOL fDelayDSN,
                                IN OUT CDeliveryContext *pdcntxt,
                                OUT DWORD *pcRecips,
                                OUT DWORD **prgdwRecips);


    //Static callback used to restart DSN generation
    static BOOL     fRestartDSNGenerationIfNecessary(PVOID pvContext,
                                                    DWORD dwStatus);

public:
    CLinkMsgQueue(GUID guid = g_sDefaultLinkGuid) : m_aqsched(guid, 0)
            {InternalInit();};

    CLinkMsgQueue(DWORD dwScheduleID,
                  IMessageRouter *pIMessageRouter,
                  IMessageRouterLinkStateNotification *pILinkStateNotify);
    ~CLinkMsgQueue();

    void SetLinkType(DWORD dwLinkType) { m_dwLinkType = dwLinkType; }
    DWORD GetLinkType() { return m_dwLinkType; }

    //For some links, certain actions are not supported:
    //but they use the same class (CLinkMsgQueue) as others for which
    //the actions are supported. For example CurrentlyUnreachable does
    //not support freeze/thaw. So we need to maintain for the currently
    //unreachable object, a list of actions that are supported, so it
    //does not set the flags corresponding to an unsupported action
    //when that action is commanded.

    void SetSupportedActions(DWORD dwSupported) { m_dwSupportedActions = dwSupported; }
    DWORD fActionIsSupported(LINK_ACTION la) { return (m_dwSupportedActions & la); }

    BOOL    fCanSchedule()  //Can this link be scheduled
    {
        HrGetInternalInfo(NULL);  //make sure link state flags are up to date
        DWORD dwFlags = m_dwLinkStateFlags;
        return fFlagsAllowConnection(dwFlags);
    }

    BOOL    fCanSendCmd()  //Is this link scheduled to send command on next connection
    {
        //Logic :
        //  Every time we see this flag set, the connection that is created also will
        //  be used to send a command
        //
        DWORD dwFlags = m_dwLinkStateFlags;
        return (dwFlags & LINK_STATE_CMD_ENABLED);
    }

    BOOL    fShouldConnect(IN DWORD cMaxLinkConnections,
                           IN DWORD cMinMessagesPerConnection);

    //returns S_OK if connection is needed, S_FALSE if not.
    HRESULT HrCreateConnectionIfNeeded(IN  DWORD cMaxLinkConnections,
                                       IN  DWORD cMinMessagesPerConnection,
                                       IN  DWORD cMaxMessagesPerConnection,
                                       IN  CConnMgr *pConnMgr,
                                       OUT CSMTPConn **ppSMTPConn);

    LONG    IncrementConnMgrCount() {return InterlockedIncrement(&m_lConnMgrCount);}
    LONG    DecrementConnMgrCount() {return InterlockedDecrement(&m_lConnMgrCount);}

    //
    //  Connection failure API.  This is used by the connection manager.  We
    //  will always return the message failure count, since this is what we
    //  want to pass to the retry sink.  However, we will not allow the
    //  connection manager to reset this count since only we should during
    //  ack message.
    //
    LONG    IncrementFailureCounts()
    {
        InterlockedIncrement(&m_lConsecutiveConnectionFailureCount);
        return InterlockedIncrement(&m_lConsecutiveMessageFailureCount);
    }
    LONG    cGetMessageFailureCount() {return m_lConsecutiveMessageFailureCount;}
    void    ResetConnectionFailureCount(){InterlockedExchange(&m_lConsecutiveConnectionFailureCount, 0);}

    DWORD   cGetConnections() {return m_cConnections;};

    HRESULT HrInitialize(IN  CAQSvrInst *paqinst,
                         IN  CDomainEntry *pdentryLink,
                         IN  DWORD cbSMTPDomain,
                         IN  LPSTR szSMTPDomain,
                         IN  LinkFlags lf,
                         IN  LPSTR szConnectorName);

    HRESULT HrDeinitialize();

    void    AddConnection(IN CSMTPConn *pSMTPConn); //Add Connection to link
    void    RemoveConnection(IN CSMTPConn *pSMTPConn,
                             IN BOOL fForceDSNGeneration);

    HRESULT HrGetDomainInfo(OUT DWORD *pcbSMTPDomain,
                            OUT LPSTR *pszSMTPDomain,
                            OUT CInternalDomainInfo **ppIntDomainInfo);

    HRESULT HrGetSMTPDomain(OUT DWORD *pcbSMTPDomain,
                            OUT LPSTR *pszSMTPDomain);

    //Queue manipulation routines
    HRESULT HrAddQueue(IN CDestMsgQueue *pdmqNew);
    void    RemoveQueue(IN CDestMsgQueue *pdmq, IN CAQStats *paqstats);

    HRESULT HrGetQueueListSnapshot(CQuickList **ppql);

    void    RemoveLinkIfEmpty();

    //Called by DMT to signal complete routing change
    void    RemoveAllQueues();

    // Called by DMT when this link is orphaned
    void    RemovedFromDMT();


    // This function dequeues the next available message.The message
    // retrieved will be the top one approximatly ordered by quality/class
    // and arrival time.
    HRESULT HrGetNextMsg(
                IN OUT CDeliveryContext *pdcntxt, //delivery context for connection
                OUT IMailMsgProperties **ppIMailMsgProperties, //IMsg dequeued
                OUT DWORD *pcIndexes,           //size of array
                OUT DWORD **prgdwRecipIndex);   //Array of recipient indexes

    //Acknowledge the message ref.
    //There should be one Ack for every dequeue from a link.
    HRESULT HrAckMsg(IN MessageAck *pMsgAck);

    //Gets the next message ref without getting delivery context or
    //preparing for delivery
    HRESULT HrGetNextMsgRef(IN BOOL fRoutingLockHeld, OUT CMsgRef **ppmsgref);

    //Calls CMsgRef prepare delivery for all the messages
    HRESULT HrPrepareDelivery(
                IN CMsgRef *pmsgref,
                IN BOOL fLocal,
                IN BOOL fDelayDSN,
                IN OUT CDeliveryContext *pdcntxt,
                OUT DWORD *pcRecips,
                OUT DWORD **prgdwRecips)
    {
        return HrInternalPrepareDelivery(pmsgref, FALSE, fLocal, fDelayDSN,
                                         pdcntxt, pcRecips, prgdwRecips);
    }

    //Recieve notifications from contained queues
    HRESULT HrNotify(IN CAQStats *paqstats, BOOL fAdd);
    HRESULT HrNotifyRetryStatChange(BOOL fAdd);


    // Gather statistical information for link mangment
    DWORD cGetTotalMsgCount() {return m_aqstats.m_cMsgs;};
    DWORD cGetRetryMsgCount() {return m_aqstats.m_cRetryMsgs;};

    //functions used to manipulate lists of queues
    inline CAQScheduleID *paqschedGetScheduleID();
    inline BOOL     fIsSameScheduleID(CAQScheduleID *paqsched);
    static inline   CLinkMsgQueue *plmqIsSameScheduleID(
                                    CAQScheduleID *paqsched,
                                    PLIST_ENTRY pli);

    static inline   CLinkMsgQueue *plmqGetLinkMsgQueue(PLIST_ENTRY pli);

    inline PLIST_ENTRY pliGetNextListEntry();

    inline void     InsertLinkInList(PLIST_ENTRY pliHead);
    inline BOOL     fRemoveLinkFromList();

    DWORD  dwModifyLinkState(IN DWORD dwLinkStateToSet,
                             IN DWORD dwLinkStateToUnset);

    //Used to send notification to routing/scheduling sink
    void   SendLinkStateNotification();

    void   SendLinkStateNotificationIfNew() {
        if (m_pILinkStateNotify &&
            !(m_dwLinkStateFlags & LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION))
            SendLinkStateNotification();
    }

    DWORD  dwGetLinkState() {return m_dwLinkStateFlags;};

    void   SetLastConnectionFailure(HRESULT hrLastConnectionFailure)
        {m_hrLastConnectionFailure = hrLastConnectionFailure;};

    inline BOOL fRPCCopyName(OUT LPWSTR *pwszLinkName);

    DWORD  cGetNumQueues() {return m_cQueues;};

    virtual void SetNextRetry(FILETIME *pft)
    {
        _ASSERT(pft);
        InternalUpdateFileTime(&m_ftNextRetry, pft);
    };

    void SetNextScheduledConnection(FILETIME *pft)
    {
        _ASSERT(pft);
        InternalUpdateFileTime(&m_ftNextScheduledCallback, pft);
    };

    static void ScheduledCallback(PVOID pvContext);

    void GenerateDSNsIfNecessary(BOOL fCheckIfEmpty, BOOL fMergeOnly);

    void SetDiagnosticInfo(
                    IN  HRESULT hrDiagnosticError,
                    IN  LPCSTR szDiagnosticVerb,
                    IN  LPCSTR szDiagnosticResponse);
    void GetDiagnosticInfo(
                    IN  LPSTR   szDiagnosticVerb,
                    IN  DWORD   cDiagnosticVerb,
                    IN  LPSTR   szDiagnosticResponse,
                    IN  DWORD   cbDiagnosticResponse,
                    OUT HRESULT *phrDiagnosticError);

    virtual BOOL fIsRemote() {return TRUE;};

    //
    //  Returns the connector name.  Used by CSMTPConn.  Valid as long
    //  as the link is valid.
    //
    LPSTR szGetConnectorName() {return m_szConnectorName;};

  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) { return CBaseObject::AddRef(); };
    STDMETHOD_(ULONG, Release)(void) { return CBaseObject::Release(); };

  public: //IQueueAdminAction
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD(HrApplyActionToMessage)(
        IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
        BOOL *pfShouldDelete);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        return QueryDefaultSupportedActions(pdwSupportedActions,
                                            pdwSupportedFilterFlags);
    };

  public: //IQueueAdminLink
    STDMETHOD(HrGetLinkInfo)(
        LINK_INFO *pliLinkInfo,
        HRESULT   *phrLinkDiagnostic);

    STDMETHOD(HrApplyActionToLink)(
        LINK_ACTION la);

    STDMETHOD(HrGetLinkID)(
        QUEUELINK_ID *pLinkID);

    STDMETHOD(HrGetNumQueues)(
        DWORD *pcQueues);

    STDMETHOD(HrGetQueueIDs)(
        DWORD *pcQueues,
        QUEUELINK_ID *rgQueues);
};

//---[ CLinkMsgQueue::paqschedGetScheduleID ]----------------------------------
//
//
//  Description:
//      Returns the schedule ID for this link
//  Parameters:
//      -
//  Returns:
//      ScheduleID for this link
//  History:
//      6/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQScheduleID *CLinkMsgQueue::paqschedGetScheduleID()
{
    return (&m_aqsched);
}

//---[ CLinkMsgQueue::fIsSameScheduleID ]--------------------------------------
//
//
//  Description:
//      Checks if a given schedule ID is the same as ours
//  Parameters:
//      paqsched    - ScheduleID to check against
//  Returns:
//      TRUE if same schedule ID
//  History:
//      6/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fIsSameScheduleID(CAQScheduleID *paqsched)
{
    return (m_aqsched.fIsEqual(paqsched));
}

//---[ CLinkMsgQueue::plmqIsSameScheduleID ]-----------------------------------
//
//
//  Description:
//      Gets the link if it matches the given schedule ID
//  Parameters:
//      paqsched    - ScheduleID to check
//      pli         - list entry to get link for
//  Returns:
//      pointer to link if scheduleID matches..
//      NULL otherwise
//  History:
//      6/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CLinkMsgQueue::plmqIsSameScheduleID(
                                    CAQScheduleID *paqsched,
                                    PLIST_ENTRY pli)
{
    CLinkMsgQueue *plmq = CONTAINING_RECORD(pli, CLinkMsgQueue, m_liLinks);
    _ASSERT(LINK_MSGQ_SIG == plmq->m_dwSignature);

    if (!plmq->fIsSameScheduleID(paqsched))
        plmq = NULL;

    return plmq;
}

//---[ CLinkMsgQueue::plmqGetLinkMsgQueue ]------------------------------------
//
//
//  Description:
//      Returns the LinkMsgQueue associated with the given list entry
//  Parameters:
//      pli     - List entry to get Link for
//  Returns:
//      pointer to link for list entry
//  History:
//      6/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CLinkMsgQueue::plmqGetLinkMsgQueue(PLIST_ENTRY pli)
{
    _ASSERT(LINK_MSGQ_SIG == (CONTAINING_RECORD(pli, CLinkMsgQueue, m_liLinks))->m_dwSignature);
    return (CONTAINING_RECORD(pli, CLinkMsgQueue, m_liLinks));
}

//---[ CLinkMsgQueue::InsertLinkInList ]---------------------------------------
//
//
//  Description:
//      Inserts link in given linked list
//  Parameters:
//      pliHead     - Head of list to insert in
//  Returns:
//      -
//  History:
//      6/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::InsertLinkInList(PLIST_ENTRY pliHead)
{
    _ASSERT(NULL == m_liLinks.Flink);
    _ASSERT(NULL == m_liLinks.Blink);
    InsertHeadList(pliHead, &m_liLinks);
};

//---[ CLinkMsgQueue::fRemoveLinkFromList ]-------------------------------------
//
//
//  Description:
//      Remove link from link list
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/9/98 - MikeSwa Created
//      6/11/99 - MikeSwa Modified to allow multiple calls
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fRemoveLinkFromList()
{
    if (m_liLinks.Flink && m_liLinks.Blink)
    {
        RemoveEntryList(&m_liLinks);
        m_liLinks.Flink = NULL;
        m_liLinks.Blink = NULL;
        return TRUE;
    } else {
        return FALSE;
    }
};

//---[ CLinkMsgQueue::pliGetNextListEntry ]----------------------------------
//
//
//  Description:
//      Gets the pointer to the next list entry for this queue.
//  Parameters:
//      -
//  Returns:
//      The Flink of the queues LIST_ENTRY
//  History:
//      6/16/98 -  Created
//
//---------------------------------------------------------------------------
PLIST_ENTRY CLinkMsgQueue::pliGetNextListEntry()
{
    return m_liLinks.Flink;
};


//---[ CLinkMsgQueue::fFlagsAllowConnection ]---------------------------------
//
//
//  Description:
//      Static helper function that examines if a given set of flags will
//      allow a connection.  Used by fCanSchedule and the linkstate debugger
//      extension.
//  Parameters:
//      IN dwFlags      Flags to check
//  Returns:
//      TRUE if a connection can be made, FALSE otherwise
//  History:
//      9/30/98 - MikeSwa Created (separated out from fCanSchedule)
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fFlagsAllowConnection(DWORD dwFlags)
{
    //Logic :
    //  We make a connection for a link, if the admin has not specified an override and
    //  one of the following conditions is met
    //   -the force a connection NOW flag has been set
    //   -the command enable flag has been set
    //   -the ETRN or TURN enable flag has been set
    //   -the retry enable as well as the schedule enable flag has been set
    //      (and domain is not TURN only).
    //

    BOOL fRet = FALSE;
    if (dwFlags & LINK_STATE_ADMIN_HALT)
        fRet = FALSE;
    else if (dwFlags & LINK_STATE_PRIV_NO_CONNECTION)
        fRet = FALSE;
    else if (dwFlags & LINK_STATE_PRIV_GENERATING_DSNS)
        fRet = FALSE;
    else if (dwFlags & LINK_STATE_ADMIN_FORCE_CONN)
        fRet = TRUE;
    else if (dwFlags & LINK_STATE_PRIV_CONFIG_TURN_ETRN)
    {
        //Obey retry flag... even for ETRN domains
        if ((dwFlags & LINK_STATE_PRIV_ETRN_ENABLED) &&
            (dwFlags & LINK_STATE_RETRY_ENABLED))
            fRet = TRUE;
        else
            fRet = FALSE;
    }
    else if ((dwFlags & LINK_STATE_RETRY_ENABLED) &&
        (dwFlags & LINK_STATE_SCHED_ENABLED))
        fRet = TRUE;

    return fRet;
}


//---[ CLinkMsgQueue::fRPCCopyName ]--------------------------------------------
//
//
//  Description:
//      Used by Queue admin functions to copy the name of this link
//  Parameters:
//      IN  pszLinkName         UNICODE copy of name
//  Returns:
//      TRUE on success
//      FALSE on failure
//  History:
//      12/5/98 - MikeSwa Created
//      6/7/99 - MikeSwa Changed to UNICODE
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fRPCCopyName(OUT LPWSTR *pwszLinkName)
{
    _ASSERT(pwszLinkName);

    if (!m_cbSMTPDomain || !m_szSMTPDomain)
        return FALSE;

    *pwszLinkName = wszQueueAdminConvertToUnicode(m_szSMTPDomain,
                                                  m_cbSMTPDomain);
    if (!pwszLinkName)
        return FALSE;

    return TRUE;
}
#endif // _LINKMSGQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\localq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: localq.cpp
//
//  Description:  Implementation for local admin queues
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/23/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "localq.h"
#include "aqadmsvr.h"
#include "asyncq.inl"

//---[ CLocalLinkMsgQueue::CLocalLinkMsgQueue ]---------------------------------
//
//
//  Description: 
//      Default constructor for CLocalLinkMsgQueue
//  Parameters:
//      IN      paradmq         Local async queue
//      IN      guidLink        Router GUID to associate with this link
//      IN      paqinst         CAQSvrInst for VSI
//  Returns:
//      -
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CLocalLinkMsgQueue::CLocalLinkMsgQueue(
                       CAsyncAdminMsgRefQueue *paradmq, 
                       GUID guidLink, CAQSvrInst *paqinst) : CLinkMsgQueue(guidLink)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::CLocalLinkMsgQueue");
    //Initialize superclass with our own special GUID
    
    _ASSERT(paradmq);
    m_paradmq = paradmq;

    m_dwLocalLinkSig = LOCAL_LINK_MSG_QUEUE_SIG;

    m_AQNotify.Init(paqinst, (CLinkMsgQueue *) this);
    m_paradmq->SetAQNotify(&m_AQNotify);

    TraceFunctLeave();
}

#ifdef NEVER
//---[ CLinkMsgQueue::fSameNextHop ]-------------------------------------------
//
//
//  Description: 
//      Used to determine if this link matches a given scheduleID/link pair
//  Parameters:
//      IN  paqsched        ScheduleID to check against
//      IN  szDomain        Domain name to check against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CLocalLinkMsgQueue::fSameNextHop(CAQScheduleID *paqsched, LPSTR szDomain)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::fSameNextHop");
    _ASSERT(paqsched);

    if (!paqsched)
        return FALSE;

    if (!fIsSameScheduleID(paqsched))
        return FALSE;

    //Don't need to check domain name since there is a special GUID to 
    //identify the local link.  This will allow us to match both 
    //"LocalLink" (returned in LinkID) and whatever the current value of
    //the default domain is (we don't have to worry about the clients
    //version becoming outdated).
    
    //Everything matched!
    TraceFunctLeave();
    return TRUE;
}
#endif //NEVER
//---[ CLocalLinkMsgQueue::fMatchesID ]--------------------------------------
//
//
//  Description: 
//      Used to determine if this link matches a given scheduleID/link pair
//  Parameters:
//      IN  QueueLinkID         ID to match against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CLocalLinkMsgQueue::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    _ASSERT(pQueueLinkID);

    CAQScheduleID aqsched(pQueueLinkID->uuid, pQueueLinkID->dwId);

    if (!fIsSameScheduleID(&aqsched))
        return FALSE;

    //Don't need to check domain name since there is a special GUID to 
    //identify the local link.  This will allow us to match both 
    //"LocalLink" (returned in LinkID) and whatever the current value of
    //the default domain is (we don't have to worry about the clients
    //version becoming outdated).
    //Everything matched!

    return TRUE;
}

//---[ CLocalLinkMsgQueue::HrApplyQueueAdminFunction ]-------------------------
//
//
//  Description: 
//      Used by queue admin to apply a function all queues on this link
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrApplyQueueAdminFunction(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    HRESULT hr = S_OK;

    hr = CLinkMsgQueue::HrApplyQueueAdminFunction(pIQueueAdminMessageFilter);

    if (FAILED(hr))
        goto Exit;

    _ASSERT(m_paradmq);
    hr = m_paradmq->HrApplyQueueAdminFunction(pIQueueAdminMessageFilter);
    if (FAILED(hr))
        goto Exit;

  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ CLocalLinkMsgQueue::HrGetLinkInfo ]-------------------------------------
//
//
//  Description: 
//      Fills in the details for a LINK_INFO struct.  RPC is resonsible for
//      freeing memory.
//  Parameters:
//      IN OUT pliLinkInfo  Ptr to link info struct to fill
//  Returns:
//      S_OK if successful
//      E_OUTOFMEMORY if unable to allocate memory
//  History:
//      2/23/99 - MikeSwa Created 
//      7/1/99 - MikeSwa Added LinkDiagnostic
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrGetLinkInfo(LINK_INFO *pliLinkInfo,
                                               HRESULT   *phrLinkDiagnostic)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    HRESULT hr = S_OK;
    CRefCountedString *prstrDefaultDomain = NULL;
    hr = CLinkMsgQueue::HrGetLinkInfo(pliLinkInfo, phrLinkDiagnostic);
    QUEUE_INFO qi;
    FILETIME *pft = NULL;

    _ASSERT(m_paradmq);

    //
    //  Get our queue state from our base asyncq implementation
    //
    pliLinkInfo->fStateFlags = m_paradmq->dwQueueAdminLinkGetLinkState();

    //
    //  If we are in retry, update our next scheduled connection
    //
    if (LI_RETRY & pliLinkInfo->fStateFlags)
        QueueAdminFileTimeToSystemTime(&m_ftNextRetry, &(pliLinkInfo->stNextScheduledConnection));

    //This is the local link
    pliLinkInfo->fStateFlags |= LI_TYPE_LOCAL_DELIVERY;

    if (m_paqinst)
        prstrDefaultDomain = m_paqinst->prstrGetDefaultDomain();

        
    //Copy Default local domain name instead of "LocalLink"
    if (prstrDefaultDomain && 
        prstrDefaultDomain->cbStrlen() && 
        prstrDefaultDomain->szStr())
    {
        if (pliLinkInfo->szLinkName)
        {
            QueueAdminFree(pliLinkInfo->szLinkName);
            pliLinkInfo->szLinkName = NULL;
        }

        pliLinkInfo->szLinkName = wszQueueAdminConvertToUnicode(
                                        prstrDefaultDomain->szStr(),
                                        prstrDefaultDomain->cbStrlen());
        if (!pliLinkInfo->szLinkName)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pliLinkInfo->szLinkName[prstrDefaultDomain->cbStrlen()] = '\0';
    }

    //Get the queue info from the local queue for size totals
    ZeroMemory(&qi, sizeof(QUEUE_INFO));
    hr = m_paradmq->HrGetQueueInfo(&qi); 
    if (FAILED(hr))
        goto Exit;

    //Clean up allocated stuff
    if (qi.szQueueName)
        QueueAdminFree(qi.szQueueName);

    if (qi.szLinkName)
        QueueAdminFree(qi.szLinkName);

  Exit:

    if (prstrDefaultDomain)
        prstrDefaultDomain->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CLocalLinkMsgQueue::HrApplyActionToLink ]-------------------------------
//
//
//  Description: 
//      Applies the specified QueueAdmin action to this link
//  Parameters:
//      IN  la          Link action to apply
//  Returns:
//      S_OK on success
//      E_INVALIDARG if bogus action is given
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrApplyActionToLink(LINK_ACTION la)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    HRESULT hr = S_OK;

    //It is important to release that it does not make sense to re-apply these
    //actions back to the LMQ, becuase it is actually the CAsyncRetryQueue
    //that affects the state of this.
    _ASSERT(m_paradmq);

    if (LA_KICK == la)
    {
        //kick the link
        m_paradmq->StartRetry();
    }
    else if (LA_FREEZE == la)
    {
        //Admin wants this link to stop sending mail inbound to the store
        m_paradmq->FreezeQueue();
    }
    else if (LA_THAW == la)
    {
        //Thaw that which was previously frozen
        m_paradmq->ThawQueue();
    }
    else
    {
        //invalid arg
        hr = E_INVALIDARG;
        goto Exit;
    }

  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ CLocalLinkMsgQueue::HrGetNumQueues ]------------------------------------
//
//
//  Description: 
//      Returns the number of queues on this link
//  Parameters:
//      OUT pcQueues        # numbr of queues
//  Returns:
//      S_OK on success
//      E_POINTER if pcQueues is not valid
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrGetNumQueues(DWORD *pcQueues)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    HRESULT hr = S_OK;
    hr = CLinkMsgQueue::HrGetNumQueues(pcQueues);
    if (SUCCEEDED(hr))
    {
        _ASSERT(pcQueues);
        (*pcQueues)++; //Add extra count for local async queue
    }

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrGetQueueIDs ]--------------------------------------------
//
//
//  Description: 
//      Gets the Queue IDs for DMQs associated with this link.  Used by Queue
//      Admin.
//  Parameters:
//      IN OUT pcQueues     Sizeof array/ number of queues found
//      IN OUT rgQueues     Array to dump queue info into
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY on out of memory failure
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrGetQueueIDs(
                                    DWORD *pcQueues,
                                    QUEUELINK_ID *rgQueues)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    _ASSERT(pcQueues);
    _ASSERT(rgQueues);
    HRESULT hr = S_OK;
    
    //Check to make sure we have room for the additional queue ID
    if (*pcQueues < (m_cQueues+1))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    //Make sure that thread-safe check in CLinkMsgQueue allows room 
    //for our local queue.
    (*pcQueues)--;

    hr = CLinkMsgQueue::HrGetQueueIDs(pcQueues, rgQueues);
    if (FAILED(hr))
    {
        //Tell caller we need room for our queue as well
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
            (*pcQueues)++; 

        goto Exit;
    }

    hr = m_paradmq->HrGetQueueID(&rgQueues[*pcQueues]);
    if (FAILED(hr))
        goto Exit;

    (*pcQueues)++;
  Exit:

    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\hndlmgr.h ===
//-----------------------------------------------------------------------------
//
//
//    File: Hndlmgmr.h
//
//    Description:
//      Contains descriptions of the CQueueHandleManager class
//
//    Author: mikeswa
//
//    Copyright (C) 2001 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __HNDLMGMR_H__
#define __HNDLMGMR_H__

#define CQueueHandleManager_Sig 		'rgMH'
#define CQueueHandleManager_SigFree		'gMH!'

//---[ CQueueHandleManager ]---------------------------------------------------
//
//	Description:
//		Class that handles the details of handle management for a queue.
//
//		Currently this is designed exclusively for the async queues, but 
// 		it should be possible to expand this to include the concept of remote
//		queues as well.
//  Hungarian:
//		qhmgr pqhmgr
//
//-----------------------------------------------------------------------------
class CQueueHandleManager
{
  private:
   	DWORD			m_dwSignature;

	//
	//  State information for this particular queue instance
	//
	enum {
		QUEUE_STATE_UNITIALIZED = 0,
		QUEUE_STATE_NO_BACKLOG,
		QUEUE_STATE_LOW_BACKLOG,
		QUEUE_STATE_BACKLOG,
		QUEUE_STATE_ASYNC_BACKLOG,
	};
   	DWORD			m_dwCurrentState;

	//
	//  Number of items that this instance can process concurrently
	//	that is not part of a shared resource pool.  This might be 
	//	the number of synchronous threads... or based on async 
	//	completions.
	//
	//	$$REVIEW - How does this work for queues that have a
	//	potentially large number of pending async completions 
	//	(like the precar queue).  Currrently, this can eat of all
	//	of the handler managers resources and cannot be dynamically
	//	controlled.  For now, we will ignore this problem and
	//	only report the number of sync completions.  This will matter
	//  more when we implement async local delivery.
	//
	DWORD			m_cMaxPrivateConcurrentItems;

	//
	//  Max number of items that can be handles concurrently due
	//	to a shared resource (like a thread pool)
	//	
	DWORD			m_cMaxSharedConcurrentItems;

	//
	//  "Debug" counter that is updated in a non-thread safe
	//	manner.  Used to give an idea of the rough #of updates
	//	and state transitions
	//
	DWORD			m_cDbgStateTransitions;
	DWORD			m_cDbgCallsToUpdateStateIfNecessary;
	
	//
	//  Static data that is used to load balance across all
	//  instances
	//
	static DWORD	s_cNumQueueInstances;
	static DWORD	s_cNumQueueInstancesWithLowBackLog;

	//
	//  reserved so that empty queues have a better chance of
	//	not bouncing handles.
	//
	static DWORD	s_cReservedHandles; 
	static DWORD	s_cMaxSharedConcurrentItems;

	void DeinitializeStaticsAndStateIfNecessary();

	DWORD dwUpdateCurrentStateIfNeccessary(
	    		DWORD	cItemsPending,
	    		DWORD	cItemsPendingAsyncCompletions);

	//
	// Static function that gets state for a given set oflengths.  
	// This is used internally to determine the correct response 
	// for fShould CloseHandle	
	//
	static DWORD dwGetStateForLengths(
	    		DWORD	cItemsPending,
	    		DWORD	cItemsPendingAsyncCompletions);

    //
    // static function that can be used to get an effective handle
    // limit given the state.  This is used internally to determine
    // the correct response for fShould CloseHandle
    //
    static DWORD cGetHandleLimitForState(DWORD	dwState);
  public:
    CQueueHandleManager();
    ~CQueueHandleManager();

    BOOL fIsInitialized() 
        {return (QUEUE_STATE_UNITIALIZED != m_dwCurrentState);};

	//
	//  Each instance should call into this before using any of 
	//
    void SetMaxConcurrentItems(
        	DWORD	cMaxSharedConcurrentItems,  //ie - async threads pool limit
        	DWORD	cMaxPrivateConcurrentItems); //ie - sync threads limit    

	//
	//  Called by queue instances to determine if they should close handles.
	//
    BOOL fShouldCloseHandle(
        		DWORD cItemsPending,
        		DWORD cItemsPendingAsyncCompletions,
        		DWORD cCurrentMsgsOpen);
};

#endif //__HNDLMRMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\hndlmgr.cpp ===
//-----------------------------------------------------------------------------
//
//
//    File: Hndlmgmr.cpp
//
//    Description:
//      Contains implementation of the CQueueHandleManager class
//
//    Author: mikeswa
//
//    Copyright (C) 2001 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "hndlmgr.h"

//
//  Initialize statics
//
DWORD CQueueHandleManager::s_cNumQueueInstances = 0;
DWORD CQueueHandleManager::s_cNumQueueInstancesWithLowBackLog = 0;
DWORD CQueueHandleManager::s_cReservedHandles = 0;
DWORD CQueueHandleManager::s_cMaxSharedConcurrentItems = 0;


//---[ CQueueHandleManager::CQueueHandleManager ]------------------------------
//
//
//  Description:
//      Constructor for CQueueHandleManger
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      05/12/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQueueHandleManager::CQueueHandleManager() 
{
    m_dwSignature = CQueueHandleManager_Sig;

    //
    //  Users must call into ReportMaxConcurrentItems first
    //
    m_dwCurrentState  = QUEUE_STATE_UNITIALIZED;
    m_cMaxPrivateConcurrentItems = 0;
    m_cMaxSharedConcurrentItems = 0;
    m_cDbgStateTransitions = 0;
    m_cDbgCallsToUpdateStateIfNecessary = 0;
}

//---[ CQueueHandleManager::~CQueueHandleManager ]-----------------------------
//
//
//  Description:
//      Destructor for CQueueHandleManger
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      05/12/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQueueHandleManager::~CQueueHandleManager() 
{
    DeinitializeStaticsAndStateIfNecessary();
    m_dwSignature = CQueueHandleManager_Sig;
    m_dwCurrentState  = QUEUE_STATE_UNITIALIZED;
};

//---[ CQueueHandleManager::DeinitializeStaticsAndStateIfNecessary ]-----------
//
//
//  Description:
//       Update statics based on this queue instance's state.  This is used
//      in the desctructor and when the config is updated.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      05/12/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CQueueHandleManager::DeinitializeStaticsAndStateIfNecessary()
{
    DWORD dwOldState = QUEUE_STATE_UNITIALIZED;

    if (fIsInitialized())
    {
        if (m_cMaxPrivateConcurrentItems) 
        {
            dwInterlockedAddSubtractDWORD(&s_cReservedHandles, 
                m_cMaxPrivateConcurrentItems, FALSE);
        }

        dwOldState = InterlockedExchange((PLONG) &m_dwCurrentState, 
                                    QUEUE_STATE_UNITIALIZED);

        //
        // Update statics based on previous states
        //
        if ((QUEUE_STATE_LOW_BACKLOG == dwOldState) ||
             (QUEUE_STATE_ASYNC_BACKLOG == dwOldState))
            InterlockedDecrement((PLONG) &s_cNumQueueInstancesWithLowBackLog);    

        //
        //  The last one here gets to updated the shared count
        //
        if (0 == InterlockedDecrement((PLONG) &s_cNumQueueInstances) &&
            s_cMaxSharedConcurrentItems)
        {
            dwInterlockedAddSubtractDWORD(&s_cReservedHandles, 
                s_cMaxSharedConcurrentItems, FALSE);
        }

    }
}

//---[ CQueueHandleManager::SetMaxConcurrentItems ]-------------------------
//
//
//  Description:
//      Sets appropriate settings for this queue instance
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      05/12/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CQueueHandleManager::SetMaxConcurrentItems(
        	DWORD	cMaxSharedConcurrentItems,  
        	DWORD	cMaxPrivateConcurrentItems)
{
    DWORD dwRefCount = 0;
    DWORD dwOldState = QUEUE_STATE_UNITIALIZED;
    //
    //  Odd things will happen if this is called multiple times... since
    //  part of the initialization is undone before it is finalized
    //
    _ASSERT(!fIsInitialized() && "Already initialized");

    //
    //  I don't think this is possible (hence above assert), but this 
    //  will at least prevent the static data from becoming invald and
    //  will only lead to transient oddities.
    //
    DeinitializeStaticsAndStateIfNecessary();
    dwRefCount = InterlockedIncrement((PLONG) &s_cNumQueueInstances);

    dwOldState = InterlockedExchange((PLONG) &m_dwCurrentState, 
                                    QUEUE_STATE_NO_BACKLOG);

    _ASSERT(QUEUE_STATE_UNITIALIZED == dwOldState);
    //
    // Update statics based on previous states - again this 
    //  should not be necessary - firewall anyway
    //
    if ((QUEUE_STATE_LOW_BACKLOG == dwOldState) ||
         (QUEUE_STATE_ASYNC_BACKLOG == dwOldState))
        InterlockedDecrement((PLONG) &s_cNumQueueInstancesWithLowBackLog);    

    //
    //  Calculate the appropriate reserve handle  count.  Eaxh queue
    //  can handle a certain number of items concurrently.  Some of these
    //  are constrained by process-wide resources (such as a thread pool),
    //  but others are things like async completions and 
    //
    m_cMaxPrivateConcurrentItems = cMaxPrivateConcurrentItems;
    m_cMaxSharedConcurrentItems = cMaxSharedConcurrentItems;
    
    if (m_cMaxPrivateConcurrentItems) 
    {
        dwInterlockedAddSubtractDWORD(&s_cReservedHandles, 
                m_cMaxPrivateConcurrentItems, TRUE);
    }
    if (m_cMaxSharedConcurrentItems && (1 == dwRefCount)) 
    {
        //
        //  The expectation is that there will not be multiple threads
        //  bouncing the refcount off zero, since VSI start/stop is
        //  single threaded, and an instance has at least one static
        //  instance.
        //
        _ASSERT(s_cNumQueueInstances && "threading violation");
        s_cMaxSharedConcurrentItems = m_cMaxSharedConcurrentItems;
        dwInterlockedAddSubtractDWORD(&s_cReservedHandles, 
            s_cMaxSharedConcurrentItems, TRUE);
    }


}

//---[ CQueueHandleManager::fShouldCloseHandle ]-------------------------------
//
//
//  Description:
//      Called by queue instances to determine if they should close handles.
//      Must be preceeded by a call to SetMaxConcurrentItems to initialize
//      configuration.
//  Parameters:
//      IN      cItemsPending   Number of items currently waiting to be
//                              processed on this queue.
//      IN      cItemsPendingAsyncCompletions - Items that are actually opened
//                              and currently being processed
//      IN      cCurrentMsgsOpenInSystem - The current number of messages
//                              open in the process (ie - how much resources
//                              are being consumed).
//  Returns:
//      TRUE    -   Caller should close messages now
//      FALSE   -   Caller should *not* close messages now
//  History:
//      05/12/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CQueueHandleManager::fShouldCloseHandle(
        		DWORD cItemsPending,
        		DWORD cItemsPendingAsyncCompletions,
        		DWORD cCurrentMsgsOpenInSystem)
{
    TraceFunctEnterEx((LPARAM) this, "CQueueHandleManager::fShouldCloseHandle");
    _ASSERT(fIsInitialized());
    DWORD dwState = m_dwCurrentState;
    DWORD cHandleLimit = 0;
    BOOL  fShouldClose = TRUE;

    if (QUEUE_STATE_UNITIALIZED != dwState)
    {
        //
        //  See if state needs to be updated
        //
        dwState  = dwUpdateCurrentStateIfNeccessary(cItemsPending,
                                cItemsPendingAsyncCompletions);
        _ASSERT(QUEUE_STATE_UNITIALIZED != dwState);
    }

    //
    //  Code defensively - Assume worst case
    //
    if (QUEUE_STATE_UNITIALIZED == dwState)
    {
        ErrorTrace((LPARAM) this, "Queue state is unitialized");
        dwState = QUEUE_STATE_BACKLOG; //defensive code
    }

    cHandleLimit = cGetHandleLimitForState(dwState);

    //
    //  Now that we have the limit on the number of handles, the math is easy
    //
    if (cHandleLimit > cCurrentMsgsOpenInSystem)
        fShouldClose = FALSE;

    DebugTrace((LPARAM) this, 
            "%s Handle - %d pending, %d pending async, 0x%X state, %d open msgs, %d handle limit",
            (fShouldClose  ? "Closing" : "Not closing"), 
            cItemsPending, cItemsPendingAsyncCompletions, dwState, 
            cCurrentMsgsOpenInSystem, cHandleLimit);

    TraceFunctLeave();
    return fShouldClose;
}


//---[ CQueueHandleManager::cGetHandleLimitForState ]--------------------------
//
//
//  Description:
//      Called by queue instances to determine if they should close handles.
//      Must be preceeded by a call to SetMaxConcurrentItems to initialize
//      configuration.  - Static method
//  Parameters:
//      IN      dwState   The state to calculate the limit for
//  Returns:
//      The handle limti for the given state
//  History:
//      05/17/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CQueueHandleManager::cGetHandleLimitForState(DWORD	dwState)
{
    DWORD cHandleLimit = g_cMaxIMsgHandlesThreshold;
    DWORD cReserve = s_cReservedHandles;

    //
    //  Allow registry configurable limit
    //
    if (s_cReservedHandles > g_cMaxHandleReserve)
        cReserve = g_cMaxHandleReserve;

    //
    //  Our logic only makes sense if this is true
    //
    _ASSERT(g_cMaxIMsgHandlesThreshold >= g_cMaxIMsgHandlesLowThreshold);

    //
    //  If the handle limit is actually... zero, then close without 
    //  regard for the queue state.
    //
    if (!cHandleLimit)
        goto Exit;

    switch(dwState)
    {
        //
        //  The number of messages pending is equal to the number
        //  of messages that can be concurrently processed.  In this case,
        //  we should try hard not to close handles.  To accomplish this, 
        //  we will dip into our reserve.
        //
        //  Async backlog is a similar case...we have no backlog of items
        //  pending, but we have a large number of pending completions
        //
        case QUEUE_STATE_NO_BACKLOG:
        case QUEUE_STATE_ASYNC_BACKLOG:
            cHandleLimit += cReserve;
            break;

        //
        //  In the case where there are some of messages queued up (to
        //  a configured percentage of the max handle limit), we will
        //  continue closing handles normally
        //
        case QUEUE_STATE_LOW_BACKLOG:
            break; //use handle limit as-is

        //
        //  In the case where there is a significant backlog, we
        //  would like to use handles if available... but not to the
        //  determent of shorter queues.  If there are other queues 
        //  have a low backlog... we will defer to them.  Otherwise, 
        //  we will use as many handles as we can.
        //
        case QUEUE_STATE_BACKLOG:
            if (s_cNumQueueInstancesWithLowBackLog)
                cHandleLimit = g_cMaxIMsgHandlesLowThreshold;
            break;

        //
        //  Queue is either non initialized or in an invalid state.
        //  We will err on the side of caution and treat this as 
        //
        default:
            _ASSERT(0 && "Invalid Queue State");
            cHandleLimit = 0;
    }
     
  Exit:
    return cHandleLimit;
}

//---[ CQueueHandleManager::dwUpdateCurrentStateIfNeccessary ]----------------
//
//
//  Description:
//      Will update this queues state if necessary and return the resulting
//      state.
//  Parameters:
//      IN      cItemsPending   Number of items currently waiting to be
//                              processed on this queue.
//      IN      cItemsPendingAsyncCompletions - Items that are actually opened
//                              and currently being processed
//  Returns:
//      The state for given lengths
//  History:
//      05/17/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CQueueHandleManager::dwUpdateCurrentStateIfNeccessary(
	    		DWORD	cItemsPending,
	    		DWORD	cItemsPendingAsyncCompletions)
{
    TraceFunctEnterEx((LPARAM) this, 
        "CQueueHandleManager::dwUpdateCurrentStateIfNeccessary");
    DWORD dwOldState = m_dwCurrentState;
    DWORD dwNewState = dwOldState;
    DWORD dwCompare = dwOldState;
    
    _ASSERT(fIsInitialized());

    if (!fIsInitialized())
    {
        ErrorTrace((LPARAM) this, "Queue is not initialized");
        goto Exit;
    }

    m_cDbgCallsToUpdateStateIfNecessary++;
    dwNewState = dwGetStateForLengths(cItemsPending, cItemsPendingAsyncCompletions);

    //
    //  We need to update the state... do this in a thread-safe manner
    //
    do
    {
        dwOldState = m_dwCurrentState;
        if (dwNewState == dwOldState)
            goto Exit;
        
        dwCompare = InterlockedCompareExchange((PLONG) &m_dwCurrentState,
                          dwNewState, dwOldState);
        
    } while (dwCompare != dwOldState);

    //
    //  Now that we have changed state, we are responsible for updating
    //  the static counters for the old and new states
    //
    if ((QUEUE_STATE_LOW_BACKLOG == dwNewState) ||
         (QUEUE_STATE_ASYNC_BACKLOG == dwNewState))
        InterlockedIncrement((PLONG) &s_cNumQueueInstancesWithLowBackLog);    

    if ((QUEUE_STATE_LOW_BACKLOG == dwOldState) ||
         (QUEUE_STATE_ASYNC_BACKLOG == dwOldState))
        InterlockedDecrement((PLONG) &s_cNumQueueInstancesWithLowBackLog);    

    m_cDbgStateTransitions++;
    
  Exit:
    TraceFunctLeave();
    return dwNewState;
}

//---[ CQueueHandleManager::dwGetStateForLengths ]-----------------------------
//
//
//  Description:
//      Static method to determine the appropriate state for a given
//      set of lenghts
//  Parameters:
//      IN      cItemsPending   Number of items currently waiting to be
//                              processed on this queue.
//      IN      cItemsPendingAsyncCompletions - Items that are actually opened
//                              and currently being processed
//  Returns:
//      The state for given lengths
//  History:
//      05/17/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CQueueHandleManager::dwGetStateForLengths(
	    		DWORD	cItemsPending,
	    		DWORD	cItemsPendingAsyncCompletions)
{
    DWORD dwState = QUEUE_STATE_BACKLOG;

    //
    //  If we are at or less than our max number of concurrent items
    //
    if (cItemsPending <= s_cReservedHandles)
        dwState = QUEUE_STATE_NO_BACKLOG;
    else if (cItemsPending <= g_cMaxIMsgHandlesLowThreshold)
        dwState = QUEUE_STATE_LOW_BACKLOG;

    //
    //  Async completions are slightly tricky.  We don't want to bounce
    //  a handle simply because we have a large number of async completions.
    //  We also want to identify ourselves as a potential user of handles.
    //
    //  We have a state (QUEUE_STATE_ASYNC_BACKLOG) that is used to 
    //  indicate that while there is no backlog of items pending, there
    //  may be a large number of items owned by this queue (with open
    //  handles).  This state has the effect of:
    //      - Flagging this queue has one with a low backlog
    //      - Managing handles for *this* queue as if there was no backlog
    //
    //  If there is any backlog of any kind for cItemsPending, we will 
    //  treat the queue based on those results
    //
    if ((QUEUE_STATE_NO_BACKLOG == dwState) && 
         (cItemsPendingAsyncCompletions >= s_cReservedHandles))
        dwState = QUEUE_STATE_ASYNC_BACKLOG;
    
    return dwState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\localq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: localq.h
//
//  Description:  Header file for CLocalLinkMsgQueue class... a subclass of 
//      CLinkMsgQueue that provides the additional functionality need to 
//      admin a local queue
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/23/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __LOCALQ_H__
#define __LOCALQ_H__

#include "linkmsgq.h"

#define LOCAL_LINK_MSG_QUEUE_SIG 'QMLL'

//---[ CLocalLinkNotifyWrapper ]-----------------------------------------------
//
//
//  Description: 
//      Implements IAQNotify for the local link.  This is encapsulated in a 
//      different class, because QAPI functions need to call also update
//      the perfcounters when a message is removed. We cannot call directly
//      into the HrNotify on CLinkMsgQueue... and we cannot override the
//      basic HrNotify functionality (because we only need it for QAPI 
//      functionality).
//  
//-----------------------------------------------------------------------------
class CLocalLinkNotifyWrapper : public IAQNotify
{
  private:
    CAQSvrInst      *m_paqinst;
    CLinkMsgQueue   *m_plmq;
  public:
    CLocalLinkNotifyWrapper()
    {
        m_paqinst = NULL;
        m_plmq = NULL;
    }

    inline void Init(CAQSvrInst *paqinst, CLinkMsgQueue *plmq)
    {
        _ASSERT(paqinst);
        _ASSERT(plmq);
        m_paqinst = paqinst;
        m_plmq = plmq;
    }

    virtual HRESULT HrNotify(CAQStats *paqstats, BOOL fAdd)
    {
        UpdateCountersForLinkType(m_paqinst, LI_TYPE_LOCAL_DELIVERY);
        
        if (m_plmq)
            return m_plmq->HrNotify(paqstats, fAdd);
        else
            return S_OK;
    }

};


//---[ CLocalLinkMsgQueue ]----------------------------------------------------
//
//
//  Description: 
//      Derived class of CLinkMsgQueue that provides that additional queue 
//      admin functionality required to handle local delivery
//  Hungarian: 
//      llmq, pllmq
//  
//-----------------------------------------------------------------------------
class CLocalLinkMsgQueue :
    public CLinkMsgQueue
{
  protected:
    DWORD                            m_dwLocalLinkSig;
    CAsyncAdminMsgRefQueue          *m_paradmq;
    CLocalLinkNotifyWrapper          m_AQNotify;                       
  public:
    CLocalLinkMsgQueue(CAsyncAdminMsgRefQueue *paradmq, 
                       GUID guidLink,
                       CAQSvrInst *paqinst);

    virtual BOOL fIsRemote() {return FALSE;};

  public: //IQueueAdminAction
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        return QueryDefaultSupportedActions(pdwSupportedActions, 
                                            pdwSupportedFilterFlags);
    };

  public: //IQueueAdminLink
    STDMETHOD(HrGetLinkInfo)(
        LINK_INFO *pliLinkInfo,
        HRESULT   *phrLinkDiagnostic);

    STDMETHOD(HrApplyActionToLink)(
        LINK_ACTION la);

    STDMETHOD(HrGetNumQueues)(
        DWORD *pcQueues);

    STDMETHOD(HrGetQueueIDs)(
        DWORD *pcQueues,
        QUEUELINK_ID *rgQueues);

};

#endif //__LOCALQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\mailadmq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: mailadmq.cpp
//
//  Description:  Implementation for CMailMsgAdminLink
//
//  Author: Gautam Pulla (GPulla)
//
//  History:
//      6/24/1999 - GPulla Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "linkmsgq.h"
#include "mailadmq.h"
#include "dcontext.h"
#include "dsnevent.h"
#include "asyncq.inl"
#include "asyncadm.inl"

//---[ CAsyncAdminMailMsgQueue::HrDeleteMsgFromQueueNDR ]-----------------------
//
//
//  Description:
//      Wraps call to NDR MailMsg
//  Parameters:
//      *pIUnknown - IUnkown of MailMsg
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrDeleteMsgFromQueueNDR(
                                            IUnknown *pIUnknownMsg)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMailMsgQueue::HrDeleteMsgFromQueueNDR");
    HRESULT hr = S_OK;
    IMailMsgProperties *pIMailMsgProperties = NULL;
    CDSNParams  dsnparams;


    _ASSERT(pIUnknownMsg);
    _ASSERT(m_paqinst);

    hr = pIUnknownMsg->QueryInterface(IID_IMailMsgProperties,
                                      (void **) &pIMailMsgProperties);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a MailMsg!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MailMsg failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Initialize DSN params
    //
    SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
    dsnparams.dwStartDomain = 0;
    dsnparams.dwDSNActions = DSN_ACTION_FAILURE_ALL;
    dsnparams.pIMailMsgProperties = pIMailMsgProperties;
    dsnparams.hrStatus = AQUEUE_E_QADMIN_NDR;

    //
    //  Attempt to NDR message
    //
    hr = HrLinkAllDomains(pIMailMsgProperties);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to link all domains for DSN generation", hr);
        goto Exit;
    }

    //
    // Fire DSN Generation event
    //
    hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to NDR message via QAPI 0x%08X", hr);
        goto Exit;
    }


    //
    //  Now that we have generated an NDR... we need to delete the
    //  Message.
    //
    hr = HrDeleteMsgFromQueueSilent(pIUnknownMsg);
    if (FAILED(hr))
        goto Exit;

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMailMsgQueue::HrDeleteMsgFromQueueSilent ]--------------------
//
//
//  Description:
//      Wrapper function to silently delete a message from a queue
//  Parameters:
//      *pIUnknown - IUnkown of MailMsg
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrDeleteMsgFromQueueSilent(
                                            IUnknown *pIUnknownMsg)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMailMsgQueue::HrDeleteMsgFromQueueSilent");
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;

    _ASSERT(pIUnknownMsg);

    hr = pIUnknownMsg->QueryInterface(IID_IMailMsgQueueMgmt,
                                      (void **) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a MailMsg!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MailMsg failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Attempt to delete the message
    //
    hr = pIMailMsgQueueMgmt->Delete(NULL);
    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "Unable to delete msg 0x%08X", hr);

  Exit:
    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMailMsgQueue::HrFreezeMsg ]-----------------------------------
//
//
//  Description:
//      Wrapper to freeze a pIMailMsgProperties
//  Parameters:
//      *pIUnknown - IUnkown of MailMsg
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrFreezeMsg(IUnknown *pIUnknownMsg)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMailMsgQueue::HrFreezeMsg");
    HRESULT hr = S_OK;
    IMailMsgProperties *pIMailMsgProperties = NULL;

    _ASSERT(pIUnknownMsg);

    hr = pIUnknownMsg->QueryInterface(IID_IMailMsgProperties,
                                      (void **) &pIMailMsgProperties);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a MailMsg!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MailMsg failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  $$TODO - Attempt to freeze the message -- Not supported for this type of queue
    //

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMailMsgQueue::HrThawMsg ]-------------------------------------
//
//
//  Description:
//      Wrapper function to thaw a message
//  Parameters:
//      *pIUnknown - IUnkown of MailMsg
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrThawMsg(IUnknown *pIUnknownMsg)
{
    TraceFunctEnterEx((LPARAM) this, "AsyncAdminMailMsgQueue::HrThawMsg");
    HRESULT hr = S_OK;
    IMailMsgProperties *pIMailMsgProperties = NULL;

    _ASSERT(pIUnknownMsg);

    hr = pIUnknownMsg->QueryInterface(IID_IMailMsgProperties,
                                      (void **) &pIMailMsgProperties);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a MailMsg!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MailMsg failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  $$TODO - Attempt to thaw message -- Not supported for this type of queue
    //

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMailMsgQueue::HrGetStatsForMsg ]------------------------------
//
//
//  Description:
//      Wrapper function to fill in the CAQStats struct for a message
//  Parameters:
//      *pIUnknown - IUnkown of MailMsg
//      *paqstats - Ptr to aqstats struction to fill in.
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrGetStatsForMsg(
                                            IUnknown *pIUnknownMsg,
                                            CAQStats *paqstats)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMailMsgQueue::HrGetStatsForMsg");
    HRESULT hr = S_OK;
    IMailMsgProperties *pIMailMsgProperties = NULL;

    _ASSERT(pIUnknownMsg);
    _ASSERT(paqstats);

    hr = pIUnknownMsg->QueryInterface(IID_IMailMsgProperties,
                                      (void **) &pIMailMsgProperties);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a MailMsg!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MailMsg failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    // $$TODO - GetStats for Msg -- Not supported for this type of queue
    //

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAsyncAdminMailMsgQueue::HrSendDelayOrNDR ]-----------------------------
//
//
//  Description:
//      Checks the MailMsg to see if it has expired or needs a delay DSN sent
//      and acts accordingly
//  Parameters:
//      IMailMsgProperties - The MailMsg that needs to be checked
//  Returns:
//      S_OK    : OK, may have sent delay NDR
//      S_FALSE : OK, MailMsg handled (NDR'd or nothing left to do)
//      Or returns error from called fnct.
//  History:
//      5/15/2001 - dbraun Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrSendDelayOrNDR(IMailMsgProperties *pIMailMsgProperties)
{
    HRESULT     hr  = S_OK;
    DWORD       cbProp = 0;
    DWORD       dwTimeContext = 0;
    CDSNParams  dsnparams;
    BOOL        fSentDelay = FALSE;
    BOOL        fSentNDR = FALSE;

    FILETIME    ftExpireTimeNDR;
    FILETIME    ftExpireTimeDelay;


    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMailMsgQueue::HrSendDelayOrNDR");

    _ASSERT(m_paqinst);

    // Try to get the expire time from the message, otherwise calculate it
    // from the file time
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_NDR,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTimeNDR);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        // Prop not set ... calculate it from the file time
        hr = pIMailMsgProperties->GetProperty(IMMPID_MP_ARRIVAL_FILETIME,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTimeNDR);
        if (FAILED(hr))
        {
            // Message should not make it this far without being stamped
            _ASSERT(MAILMSG_E_PROPNOTFOUND != hr);

            // Prop not set or other failure, we cannot expire this message
            goto Exit;
        }

        m_paqinst->CalcExpireTimeNDR(ftExpireTimeNDR, TRUE, &ftExpireTimeNDR);
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_DELAY,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTimeDelay);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        // Prop not set ... calculate it from the file time
        hr = pIMailMsgProperties->GetProperty(IMMPID_MP_ARRIVAL_FILETIME,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTimeDelay);
        if (FAILED(hr))
        {
            // Message should not make it this far without being stamped
            _ASSERT(MAILMSG_E_PROPNOTFOUND != hr);

            // Prop not set or other failure, we cannot expire this message
            goto Exit;
        }

        m_paqinst->CalcExpireTimeDelay(ftExpireTimeDelay, TRUE, &ftExpireTimeDelay);
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

    //
    //  Initialize DSN params
    //
    SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
    dsnparams.dwStartDomain = 0;
    dsnparams.dwDSNActions = 0;
    dsnparams.pIMailMsgProperties = pIMailMsgProperties;
    dsnparams.hrStatus = 0;

    // Check if we have passed either expire time
    if (m_paqinst->fInPast(&ftExpireTimeNDR, &dwTimeContext))
    {
        dsnparams.dwDSNActions |= DSN_ACTION_FAILURE_ALL;
        dsnparams.hrStatus = AQUEUE_E_MSG_EXPIRED;
        fSentNDR = TRUE;
    }
    else if (m_paqinst->fInPast(&ftExpireTimeDelay, &dwTimeContext))
    {
        dsnparams.dwDSNActions |= DSN_ACTION_DELAYED;
        dsnparams.hrStatus = AQUEUE_E_MSG_EXPIRED;
        fSentDelay = TRUE;
    }

    // If we are going to generate an NDR
    if (dsnparams.hrStatus)
    {
        //
        //  Attempt to NDR message
        //
        hr = HrLinkAllDomains(pIMailMsgProperties);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "Unable to link all domains for DSN generation", hr);
            goto Exit;
        }

        //
        // Fire DSN Generation event
        //
        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "Unable to NDR message via QAPI 0x%08X", hr);
            goto Exit;
        }

        // Return based on what we did
        if (fSentNDR)
        {
            // This message has been handled, delete it
            hr = HrDeleteMsgFromQueueSilent(pIMailMsgProperties);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this,
                    "Failed to delete message after sending NDR", hr);
                goto Exit;
            }

            // NDR'd and successfully deleted message
            hr = S_FALSE;
        }
        else if (fSentDelay)
        {
            hr = S_OK;
        }
    }

  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ CAsyncAdminMailMsgQueue::fHandleCompletionFailure ]---------------------
//
//
//  Description:
//      Overrides base class and checks to see if message has expired before
//      putting it on the retry queue
//  Parameters:
//      IMailMsgProperties - The MailMsg that triggered failure
//  Returns:
//      -
//  History:
//      5/15/2001 - dbraun Created
//
//-----------------------------------------------------------------------------
BOOL CAsyncAdminMailMsgQueue::fHandleCompletionFailure(IMailMsgProperties *pIMailMsgProperties)
{
    HRESULT  hr     = S_OK;

    // Has this message expired?
    hr = HrSendDelayOrNDR (pIMailMsgProperties);

    if (hr == S_FALSE)
    {
        // This message was NDR'd, we are done
        return TRUE;
    }
    else
    {
        return  CAsyncAdminQueue<IMailMsgProperties *, ASYNC_QUEUE_MAILMSG_SIG>::fHandleCompletionFailure(pIMailMsgProperties);
    }
}


//---[ CAsyncAdminMailMsgQueue::HrQueueRequest ]-------------------------------
//
//
//  Description:
//      Function that will queue a request to the async queue and close
//      the handles associated with a message if we are above our simple
//      "throttle" limit.
//  Parameters:
//      pIMailMsgProperties The IMailMsgProperties interface to queue
//      fRetry              TRUE - if this message is being retried
//                          FALSE - otherwise
//      cMsgsInSystem       The total number of messages in the system
//  Returns:
//      S_OK on success
//      Error code from async queue on failure.
//  History:
//      10/7/1999 - MikeSwa Created
//      12/7/2000 - MikeSwa Moved to CAsyncAdminMailMsgQueue from asyncq.cpp
//      4/6/2001 - MikeSwa Modified to take into account queue length
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrQueueRequest(IMailMsgProperties *pIMailMsgProperties,
                                           BOOL  fRetry,
                                           DWORD cMsgsInSystem)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMailMsgQueue::HrQueueRequest");
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    HRESULT hr = S_OK;
    DWORD   cThresholdUsed = g_cMaxIMsgHandlesThreshold;
    DWORD   cItemsPending = dwGetTotalThreads()+m_cItemsPending;

    if (m_qhmgr.fShouldCloseHandle(cItemsPending, m_cPendingAsyncCompletions,
                                   cMsgsInSystem))
    {
        DebugTrace((LPARAM) this,
            "INFO: Closing IMsg Content - %d messsages in system", cMsgsInSystem);
        hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt,
                                                (void **) &pIMailMsgQueueMgmt);
        if (SUCCEEDED(hr))
        {
            //bounce usage count off of zero
            pIMailMsgQueueMgmt->ReleaseUsage();
            pIMailMsgQueueMgmt->AddUsage();
            pIMailMsgQueueMgmt->Release();
        }
        else
        {
            ErrorTrace((LPARAM) this,
                "Unable to QI for IMailMsgQueueMgmt - hr 0x%08X", hr);
        }
    }
    TraceFunctLeave();
    return CAsyncAdminQueue<IMailMsgProperties *, ASYNC_QUEUE_MAILMSG_SIG>::HrQueueRequest(pIMailMsgProperties, fRetry);
}

//---[ CAsyncAdminMailMsgQueue::HrQueueRequest ]-------------------------------
//
//
//  Description:
//      Since we inherit from AsyncQueue who implmenents this, we should assert
//      so that a dev adding a new call to this class later on, will use the
//      version that closes handles.
//
//      In RTL this will force the handles closed and queue the request
//  Parameters:
//      pIMailMsgProperties The IMailMsgProperties interface to queue
//      fRetry              TRUE - if this message is being retried
//                          FALSE - otherwise
//  Returns:
//      returns return value from proper version of HrQueueRequest
//  History:
//      10/7/1999 - MikeSwa Created
//      12/7/2000 - MikeSwa Moved to CAsyncAdminMailMsgQueue from asyncq.cpp
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrQueueRequest(IMailMsgProperties *pIMailMsgProperties,
                                           BOOL  fRetry)
{
    _ASSERT(0 && "Should use HrQueueRequest with 3 parameters");
    return HrQueueRequest(pIMailMsgProperties, fRetry,
                          g_cMaxIMsgHandlesThreshold+1);
}


//---[ CAsyncAdminMailMsgQueue::HrApplyQueueAdminFunction ]--------------------
//
//
//  Description:
//      Will call the IQueueAdminMessageFilter::Process message for every
//      message in this queue.  If the message passes the filter, then
//      HrApplyActionToMessage on this object will be called.
//
//      This is different from other implemenentations in that the
//      location of the message implies something about the state of the
//      message.  Messages in the retry... or frozen queue are considered
//      failed or frozen.
//
//      We do this instead of writing a mailmsg property, because of the
//      *huge* perf hit (we would ruin our async message flow by blocking
//      to check if a message is frozen).  We already have the retry
//      queue, so it makes sense to use it in a similar manner
//
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created
//      12/7/2000 - MikeSwa Modified - Made template base class
//      12/13/2000 - MikeSwa Modified  from CAsyncAdminQueue
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncAdminMailMsgQueue::HrApplyQueueAdminFunction(
                     IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    HRESULT hr = S_OK;
    CQueueAdminContext qapictx(m_pAQNotify, m_paqinst);

    _ASSERT(pIQueueAdminMessageFilter);
    hr = pIQueueAdminMessageFilter->HrSetQueueAdminAction(
                                    (IQueueAdminAction *) this);

    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetQueueAdminAction");

    if (FAILED(hr))
        goto Exit;

    hr = pIQueueAdminMessageFilter->HrSetCurrentUserContext(&qapictx);
    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetCurrentUserContext");
    if (FAILED(hr))
        goto Exit;

    //
    //  Iterate over messages in the base queue
    //
    qapictx.SetQueueState(LI_READY);
    hr = HrMapFnBaseQueue(m_pfnMessageAction, pIQueueAdminMessageFilter);

    //
    //  Iterate over messages in the retry queue
    //
    qapictx.SetQueueState(LI_RETRY);
    hr = HrMapFnRetryQueue(m_pfnMessageAction, pIQueueAdminMessageFilter);

    hr = pIQueueAdminMessageFilter->HrSetCurrentUserContext(NULL);
    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetCurrentUserContext");
    if (FAILED(hr))
        goto Exit;

  Exit:
    return hr;
}



//-----------------------------------------------------------------------------
//  Description:
//      Used to query the admin interfaces for CMailMsgAdminLink
//  Parameters:
//      IN  REFIID   riid    GUID for interface
//      OUT LPVOID   *ppvObj Ptr to Interface.
//
//  Returns:
//      S_OK            Interface supported by this class.
//      E_POINTER       NULL parameter.
//      E_NOINTERFACE   No such interface exists.
//  History:
//      6/25/1999 - GPulla Created
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminLink::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminAction == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminLink == riid)
    {
        *ppvObj = static_cast<IQueueAdminLink *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CMailMsgAdminLink::CMailMsgAdminLink]---------------------------------
//
//
//  Description:
//      Default constructor for CMailMsgAdminLink
//  Parameters:
//      IN  guidLink            GUID to associate with this object
//      IN  szQueueName         Name to associate with admin object
//      IN  *pasyncmmq          Async MailMsg queue for precat or prerouting
//      IN  dwLinkType          Bit-Field identifying this admin object
//      IN  paqinst             CAQSvrInst object
//
//  Returns:
//      -
//  History:
//      6/25/1999 - GPulla Created
//
//-----------------------------------------------------------------------------

CMailMsgAdminLink::CMailMsgAdminLink(
                                       GUID guid,
                                       LPSTR szQueueName,
                                       CAsyncAdminMailMsgQueue *pasyncmmq,
                                       DWORD dwLinkType,
                                       CAQSvrInst *paqinst
                                       )
                                            : m_aqsched(guid, 0)
{
    _ASSERT(pasyncmmq);
    _ASSERT(szQueueName);
    _ASSERT(paqinst);

    m_guid = guid;
    m_cbQueueName = lstrlen(szQueueName);

    m_szQueueName = (LPSTR) pvMalloc(m_cbQueueName+1);
    _ASSERT(m_szQueueName);

    if(m_szQueueName)
        lstrcpy(m_szQueueName, szQueueName);

    m_pasyncmmq = pasyncmmq;

    m_dwLinkType = dwLinkType;

    m_dwSignature = MAIL_MSG_ADMIN_QUEUE_VALID_SIGNATURE;

    if (m_pasyncmmq)
        m_pasyncmmq->SetAQNotify((IAQNotify *) this);

    m_paqinst = paqinst;

    ZeroMemory(&m_ftRetry, sizeof(m_ftRetry));
}

//---[CMailMsgAdminLink::~CMailMsgAdminLink]---------------------------------
//  Description:
//      Destructor.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------

CMailMsgAdminLink::~CMailMsgAdminLink()
{
    if (m_szQueueName)
        FreePv(m_szQueueName);
    m_dwSignature = MAIL_MSG_ADMIN_QUEUE_INVALID_SIGNATURE;
}


//---[ CMailMsgAdminLink::HrApplyQueueAdminFunction ]---------------------------
//
//
//  Description:
//      Wrapper to call into underlying queue's implementation
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//      S_FALSE if no contained queue (will assert as well)
//  History:
//      12/11/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminLink::HrApplyQueueAdminFunction(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    HRESULT hr = S_FALSE;
    _ASSERT(m_pasyncmmq);

    if (m_pasyncmmq)
        hr = m_pasyncmmq->HrApplyQueueAdminFunction(pIQueueAdminMessageFilter);

    return hr;
}


//---[ CMailMsgAdminLink::HrApplyActionToMessage ]-----------------------------
//
//
//  Description:
//      Wrapper function to pass call on to queue implementation
//  Parameters:
//      IN  *pIUnknownMsg       ptr to message abstraction
//      IN  ma                  Message action to perform
//      IN  pvContext           Context set on IQueueAdminFilter
//      OUT pfShouldDelete      TRUE if the message should be deleted
//  Returns:
//      S_OK on success
//      S_FALSE if no contained queue (will assert as well)
//  History:
//      12/11/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminLink::HrApplyActionToMessage(
        IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
        BOOL *pfShouldDelete)
{
    HRESULT hr = S_FALSE;
    _ASSERT(m_pasyncmmq);

    if (m_pasyncmmq)
    {
        hr = m_pasyncmmq->HrApplyActionToMessage(pIUnknownMsg, ma,
                                            pvContext, pfShouldDelete);
    }

    return hr;
}


//---[CMailMsgAdminLink::HrGetLinkInfo]---------------------------------------
//  Description:
//      Gets information about this admin object. Note that the diagnostic error
//      is not implemented for this object but the parameter is supported purely
//      to support the IQueueAction interface.
//  Parameters:
//      OUT LINK_INFO *pliLinkInfo Struct to fill information into.
//      OUT HRESULT   *phrDiagnosticError Diagnostic error if any, for this link
//  Returns:
//      S_OK on success
//      E_POINTER if argument is NULL
//      E_OUTOFMEMORY if unable to allocate memory for returning information.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------

STDMETHODIMP CMailMsgAdminLink::HrGetLinkInfo(LINK_INFO *pliLinkInfo, HRESULT *phrDiagnosticError)
{
    TraceFunctEnterEx((LPARAM) this, "CMailMsgAdminLink::HrGetLinkInfo");
    HRESULT hr = S_OK;

    _ASSERT(m_pasyncmmq);
    _ASSERT(pliLinkInfo);

    if(!m_pasyncmmq)
    {
        hr = S_FALSE;
        goto Exit;
    }

    if(!pliLinkInfo)
    {
        hr = E_POINTER;
        goto Exit;
    }

    //
    //  Get the link state from our base queue implementation
    //
    pliLinkInfo->fStateFlags = m_pasyncmmq->dwQueueAdminLinkGetLinkState();

    //
    //  If we are in retry... try to report the time
    //
    if (LI_RETRY & pliLinkInfo->fStateFlags)
        QueueAdminFileTimeToSystemTime(&m_ftRetry, &(pliLinkInfo->stNextScheduledConnection));

    pliLinkInfo->fStateFlags |= GetLinkType();
    pliLinkInfo->szLinkName = wszQueueAdminConvertToUnicode(m_szQueueName, m_cbQueueName);

    if (!pliLinkInfo->szLinkName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //We return 0 since size statistics are not calculated
    pliLinkInfo->cbLinkVolume.QuadPart = 0;

    //
    // Include the items queued for retry in the total count
    //
    pliLinkInfo->cMessages = m_pasyncmmq->cQueueAdminGetNumItems();

    pliLinkInfo->dwSupportedLinkActions = LA_KICK | LA_THAW | LA_FREEZE;

    //Write diagnostic
    *phrDiagnosticError = S_OK;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[CMailMsgAdminLink::HrGetNumQueues]-------------------------------------
//  Description:
//      Used to query number of queues in object. Since this class does not
//      expose the one queue it contains, 0 is returned,
//  Parameters:
//      OUT DWORD *pcQueues     # of queues (0) written to this.
//  Returns:
//      S_OK unless...
//      E_POINTER parameter is not allocated
//  History:
//      6/24/1999 - GPulla created
//      12/11/2000 - MikeSwa Updated to support sub-queues
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminLink::HrGetNumQueues(DWORD *pcQueues)
{
    _ASSERT (pcQueues);
    if (!pcQueues)
        return E_POINTER;

    *pcQueues = 1;
    return S_OK;
}

//---[CMailMsgAdminLink::HrApplyActionToLink]---------------------------------
//  Description:
//      Applies action to the embedded queue. Only kicking the queue is supported.
//  Parameters:
//      IN LINK_ACTION  la  Action to apply.
//  Returns:
//      S_OK            Action was successfully applied.
//      S_FALSE         Action not supported or severe error.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminLink::HrApplyActionToLink(LINK_ACTION la)
{
    HRESULT hr = S_OK;

    _ASSERT(m_pasyncmmq);
    if (!m_pasyncmmq)
    {
        hr = S_FALSE;
        goto Exit;
    }

    if (LA_KICK == la)
        m_pasyncmmq->StartRetry(); //kick off processing
    else if (LA_FREEZE == la)
        m_pasyncmmq->FreezeQueue();
    else if (LA_THAW == la)
        m_pasyncmmq->ThawQueue();
    else
        hr = S_FALSE;

Exit:
    return hr;
}

//---[CMailMsgAdminLink::HrGetQueueIDs]---------------------------------------
//  Description:
//      Returns an enumeration of embedded queues in this object. Since the one
//      emmbedded queue is not exposed, zero queues are returned.
//  Parameters:
//      OUT DWORD           *pcQueues   Number of queues (0)
//      OUT QUEUELINK_ID    *rgQueues   Array into which queueIDs are returned.
//  Returns:
//      S_OK        Success
//      E_POINTER   pcQueues is NULL
//  History:
//      6/24/1999 - GPulla created
//      12/11/2000 - MikeSwa Modified to expose queues
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminLink::HrGetQueueIDs(DWORD *pcQueues, QUEUELINK_ID *rgQueues)
{
    TraceFunctEnterEx((LPARAM) this, "CMailMsgAdminLink::HrGetQueueIDs");
    _ASSERT(pcQueues);
    _ASSERT(rgQueues);
    HRESULT hr = S_OK;
    QUEUELINK_ID* pCurrentQueueID = rgQueues;

    if(!pcQueues)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (*pcQueues < 1)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *pcQueues = 0;

    _ASSERT(m_pasyncmmq);
    hr = m_pasyncmmq->HrGetQueueID(pCurrentQueueID);
    if (FAILED(hr))
        goto Exit;

    *pcQueues = 1;

Exit:
    TraceFunctLeave();
    return hr;
}

//---[CMailMsgAdminLink::fMatchesID]------------------------------------------
//  Description:
//      Checks if this admin object matches a specified ID.
//  Parameters:
//      IN  QUEUELINK_ID    *pQueueLinkID   Ptr to ID to be matched against.
//  Returns:
//      TRUE    on match.
//      FALSE   if did not matched or unrecoverable error (m_szQueueName not alloced)
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CMailMsgAdminLink::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    _ASSERT(pQueueLinkID);
    _ASSERT(pQueueLinkID->szName);
    _ASSERT(m_szQueueName);

    if(!m_szQueueName)
        return FALSE;

    CAQScheduleID aqsched(pQueueLinkID->uuid, pQueueLinkID->dwId);

    if (!fIsSameScheduleID(&aqsched))
        return FALSE;

    if (!fBiStrcmpi(m_szQueueName, pQueueLinkID->szName))
        return FALSE;

    //Everything matched!
    return TRUE;
}


//---[ CMailMsgAdminLink::QuerySupportedActions ]------------------------------
//
//
//  Description:
//      Returns the actions and filters that this implementation supports
//  Parameters:
//      pdwSupportedActions     - QAPI MsgActions that this queue suppprts
//      pdwSupportedFilterFlags - QAPI filter flags that this queue supports
//  Returns:
//      S_OK on success
//  History:
//      12/12/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminLink::QuerySupportedActions(
                                   DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
{
    HRESULT hr = S_OK;
    _ASSERT(m_pasyncmmq);
    if (m_pasyncmmq)
    {
        hr = m_pasyncmmq->QuerySupportedActions(pdwSupportedActions,
                                            pdwSupportedFilterFlags);
    }

    return hr;
}


//---[CMailMsgAdminLink::fIsSameScheduleID]-----------------------------------
//  Description:
//      Helper function for fMatchesID()
//  Parameters:
//  Returns:
//      TRUE    if schedule IDs are identical
//      FALSE   otherwise.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
BOOL CMailMsgAdminLink::fIsSameScheduleID(CAQScheduleID *paqsched)
{
    return (m_aqsched.fIsEqual(paqsched));
}

//---[CMailMsgAdminLink::HrGetLinkID]-----------------------------------------
//  Description:
//      Get the ID for this admin object.
//  Parameters:
//      OUT QUEUELINK_ID *pLinkID   struct into which to put ID.
//  Returns:
//      S_OK            Successfully copied out ID.
//      E_POINTER       out struct is NULL.
//      E_OUTOFMEMORY   Cannot allocate memory for output of ID name.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
HRESULT CMailMsgAdminLink::HrGetLinkID(QUEUELINK_ID *pLinkID)
{
    HRESULT hr = S_OK;

    _ASSERT(pLinkID);
    if(!pLinkID)
    {
        hr = E_POINTER;
        goto Exit;
    }

    pLinkID->qltType = QLT_LINK;
    pLinkID->dwId = m_aqsched.dwGetScheduleID();
    m_aqsched.GetGUID(&pLinkID->uuid);

    if (!fRPCCopyName(&pLinkID->szName))
        hr = E_OUTOFMEMORY;
    else
        hr = S_OK;

Exit:
    return hr;
}

//---[CMailMsgAdminLink::fRPCCopyName]----------------------------------------
//  Description:
//      Helper function to create a unicode copy of the string identifying
//      this admin object. The unicode string is de-allocated by RPC.
//  Parameters:
//      OUT LPWSTR  *pwszLinkName    Ptr to wchar string allocated and written
//                                   into by this function.
//  Returns:
//      TRUE    On success.
//      FALSE   if there is no name for this object
//      FALSE   if memory cannot be allocated for unicode string.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
BOOL CMailMsgAdminLink::fRPCCopyName(OUT LPWSTR *pwszLinkName)
{
    _ASSERT(pwszLinkName);

    if (!m_cbQueueName || !m_szQueueName)
        return FALSE;

    *pwszLinkName = wszQueueAdminConvertToUnicode(m_szQueueName,
                                                  m_cbQueueName);
    if (!*pwszLinkName)
        return FALSE;

    return TRUE;
}


//---[ CAsyncAdminMailMsgLink::HrNotify ]--------------------------------------
//
//
//  Description:
//      Notification for stats purposes
//  Parameters:
//
//  Returns:
//
//  History:
//      1/10/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMailMsgAdminLink::HrNotify(CAQStats *aqstats, BOOL fAdd)
{
    UpdateCountersForLinkType(m_paqinst, m_dwLinkType);
    return S_OK;
}


//---[ CMailMsgAdminLink::SetNextRetry ]---------------------------------------
//
//
//  Description:
//      Updates internal retry time
//  Parameters:
//      pft     Filetime to update to
//  Returns:
//      -
//  History:
//      1/16/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMailMsgAdminLink::SetNextRetry(FILETIME *pft)
{
    if (pft)
        memcpy(&m_ftRetry, pft, sizeof(FILETIME));
}


//--------[ CAsyncAdminMailMsgQueue::fMatchesQueueAdminFilter ]-----------------
//
//  Description:
//      Checks a message against a queue admin message filter to see if it
//      is a match
//  Parameters:
//      IN pIMailMsgProperties   mail msg object to perform check on
//      IN paqmf                 Message Filter to check against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      8/8/00 - t-toddc created
//      12/11/2000 - MikeSwa Merged for checkin
//
//-----------------------------------------------------------------------------
BOOL CAsyncAdminMailMsgQueue::fMatchesQueueAdminFilter(
                        IN IMailMsgProperties* pIMailMsgProperties,
                        IN CAQAdminMessageFilter* paqmf)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties,
        "CAsyncAdminMailMsgQueue::fMatchesQueueAdminFilter");
    BOOL fMatch = TRUE;
    DWORD dwFilterFlags = 0;
    DWORD cbMsgSize = 0;
    DWORD cbProp = 0;
    FILETIME ftQueueEntry = {0, 0};
    LPSTR   szSender = NULL;
    LPSTR   szMsgId = NULL;
    LPSTR   szRecip = NULL;
    BOOL    fFoundRecipString = FALSE;
    HRESULT hr = S_OK;
    DWORD   cOpenHandlesForMsg = 1; //don't close by default

    _ASSERT(pIMailMsgProperties);
    _ASSERT(paqmf);

    dwFilterFlags = paqmf->dwGetMsgFilterFlags();

    if (!dwFilterFlags)
    {
        fMatch = FALSE;
        goto Exit;
    }

    if (AQ_MSG_FILTER_ALL & dwFilterFlags)
    {
        fMatch = TRUE;
        goto Exit;
    }

    // check size.
    if (AQ_MSG_FILTER_LARGER_THAN & dwFilterFlags)
    {

        //Get the size of the message
        hr = HrQADMGetMsgSize(pIMailMsgProperties, &cbMsgSize);
        if (FAILED(hr))
        {
            fMatch = FALSE;
            goto Exit;
        }

        fMatch = paqmf->fMatchesSize(cbMsgSize);
        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_OLDER_THAN & dwFilterFlags)
    {

    //Get time message was queued
        hr = pIMailMsgProperties->GetProperty(IMMPID_MP_ARRIVAL_FILETIME,
                                              sizeof(FILETIME),
                                              &cbProp,
                                              (BYTE *) &ftQueueEntry);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) pIMailMsgProperties,
                "Unable to get arrival time 0x%08X", hr);
            fMatch = FALSE;
            goto Exit;
        }

        fMatch = paqmf->fMatchesTime(&ftQueueEntry);
        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_FROZEN & dwFilterFlags)
    {
        // obtaining state information about freezing/thawing not supported yet.
        fMatch = FALSE;
        if (AQ_MSG_FILTER_INVERTSENSE & dwFilterFlags)
            fMatch = !fMatch;

        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_FAILED & dwFilterFlags)
    {
        // fMatch was originally set to TRUE
        // currently, no information about failures is available
        // for IMailMsgProperties mail msg objects
        fMatch = FALSE;

        if (AQ_MSG_FILTER_INVERTSENSE & dwFilterFlags)
            fMatch = !fMatch;

        if (!fMatch)
            goto Exit;
    }

    //If we haven't failed by this point, we may need to AddUsage and read
    //props from the mailmsg.  Double-check to make sure that we need to
    //add usage.
    if (!((AQ_MSG_FILTER_MESSAGEID | AQ_MSG_FILTER_SENDER | AQ_MSG_FILTER_RECIPIENT) &
        dwFilterFlags))
        goto Exit;

    //
    //  Check to see if the message is already open
    //
    hr = pIMailMsgProperties->GetDWORD(
            IMMPID_MPV_MESSAGE_OPEN_HANDLES,
            &cOpenHandlesForMsg);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties, "Not running SP1 of W2K");
        cOpenHandlesForMsg = 0;
        hr = S_OK;

    }

    if (AQ_MSG_FILTER_MESSAGEID & dwFilterFlags)
    {
        hr = HrQueueAdminGetStringProp(pIMailMsgProperties,
                                       IMMPID_MP_RFC822_MSG_ID,
                                       &szMsgId);
        if (FAILED(hr))
            szMsgId = NULL;
        fMatch = paqmf->fMatchesId(szMsgId);
        if (!fMatch)
            goto Exit;
    }


    if (AQ_MSG_FILTER_SENDER & dwFilterFlags)
    {
        fMatch = paqmf->fMatchesMailMsgSender(pIMailMsgProperties);

        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_RECIPIENT & dwFilterFlags)
    {
        fMatch = paqmf->fMatchesMailMsgRecipient(pIMailMsgProperties);

        if (!fMatch)
            goto Exit;
    }

Exit:

    //
    //  If this operation resulted in opening the message, we should close it
    //  The message is not dirty (we did not write anything), so it should not
    //  need to commit
    //
    if (!cOpenHandlesForMsg)
    {
        HRESULT hrTmp = S_OK;
        hrTmp = HrReleaseIMailMsgUsageCount(pIMailMsgProperties);
        if (SUCCEEDED(hrTmp))
            HrIncrementIMailMsgUsageCount(pIMailMsgProperties);
    }

    if (szMsgId)
        QueueAdminFree(szMsgId);

    TraceFunctLeave();
    return fMatch;

}

//---[ CAsyncAdminMailMsgQueue::HrGetQueueAdminMsgInfo ]-----------------------
//
//  Description:
//      Fills out a queue admin MESSAGE_INFO structure.  All allocations are
//      done with pvQueueAdminAlloc to be freed by the RPC code
//  Parameters:
//      IN pIMailMsgProperties   mail msg object to get info from
//      IN OUT pMsgInfo          MESSAGE_INFO struct to dump data to
//  Returns:
//      S_OK on success
//      AQUEUE_E_MESSAGE_HANDLED if the underlying message has been deleted
//      E_OUTOFMEMORY if an allocation failure
//  History:
//      8/8/00 - t-toddc created
//      12/11/2000 - MikeSwa Merged for checkin
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrGetQueueAdminMsgInfo(
                         IMailMsgProperties* pIMailMsgProperties,
                         MESSAGE_INFO* pMsgInfo,
                         PVOID pvContext)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties,
        "CAsyncAdminMailMsgQueue::HrGetQueueAdminMsgInfo");
    HRESULT hr = S_OK;
    DWORD   cbProp = 0;
    DWORD   cOpenHandlesForMsg = 0;
    LPSTR   szRecipients = NULL;
    LPSTR   szCCRecipients = NULL;
    LPSTR   szBCCRecipients = NULL;
    FILETIME ftSubmitted    = {0,0}; //Origination time property buffer
    FILETIME ftQueueEntry   = {0,0};
    FILETIME ftExpire       = {0,0};
    DWORD cbMsgSize = 0;
    CQueueAdminContext *pqapictx = (CQueueAdminContext *) pvContext;


    _ASSERT(pIMailMsgProperties);
    _ASSERT(pMsgInfo);
    _ASSERT(pqapictx);
    _ASSERT(pqapictx->fIsValid());

    //
    //  If we have a context... it better be valid
    //
    if (pqapictx && !pqapictx->fIsValid()) {
        _ASSERT(FALSE && "CQueueAdminContext is not valid");
        pqapictx = NULL;  //be defensive... don't use it.
    }

    //
    //  Check to see if the message is already open
    //
    hr = pIMailMsgProperties->GetDWORD(
            IMMPID_MPV_MESSAGE_OPEN_HANDLES,
            &cOpenHandlesForMsg);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties, "Not running SP1 of W2K");
        cOpenHandlesForMsg = 0;
        hr = S_OK;
    }


    //
    //  Extract properties that are stored only on mailmsg (this is shared
    //  with all QAPI code).
    //
    hr = HrGetMsgInfoFromIMailMsgProperty(pIMailMsgProperties,
                                          pMsgInfo);
    if (FAILED(hr))
        goto Exit;

    //can't report the number of failures from IMailMsgProperties
    pMsgInfo->cFailures = 0;

    //Get the size of the message
    hr = HrQADMGetMsgSize(pIMailMsgProperties, &cbMsgSize);
    if (FAILED(hr))
        goto Exit;

    pMsgInfo->cbMessageSize = cbMsgSize;

    //Get time message was queued
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_ARRIVAL_FILETIME,
                                          sizeof(FILETIME),
                                          &cbProp,
                                          (BYTE *) &ftQueueEntry);
    if (FAILED(hr))
    {
        // there is a possibility that the msg will not have entry time
        // (i.e. presubmission queue)
        if (MAILMSG_E_PROPNOTFOUND == hr)
        {
            ZeroMemory(&ftQueueEntry, sizeof(FILETIME));
            hr = S_OK;
        }
        else
            goto Exit;
    }

    //Get submission and expiration times
    QueueAdminFileTimeToSystemTime(&ftQueueEntry,
                               &pMsgInfo->stReceived);

    //Get the time the message entered the org
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_ORIGINAL_ARRIVAL_TIME,
                    sizeof(FILETIME), &cbProp, (BYTE *) &ftSubmitted);
    if (FAILED(hr))
    {
        //Time was not written... use entry time.
        hr = S_OK;
        memcpy(&ftSubmitted, &ftQueueEntry, sizeof(FILETIME));
    }

    QueueAdminFileTimeToSystemTime(&ftSubmitted, &pMsgInfo->stSubmission);

    // Try to get the expire time from the message, otherwise calculate it
    // from the file time
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_NDR,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpire);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        if (pqapictx->paqinstGetAQ())
        {
            // Prop not set ... calculate it from the file time
            pqapictx->paqinstGetAQ()->CalcExpireTimeNDR(ftQueueEntry, TRUE, &ftExpire);

            // This is OK
            hr = S_OK;
        }
        else
        {
            // This shouldn't happen but we don't want to crash in RTL over it
            _ASSERT(FALSE && "AQInst was not set in context!");

            // We can return this field blank
            ZeroMemory(&ftExpire, sizeof(FILETIME));
            hr = S_OK;
        }
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

    QueueAdminFileTimeToSystemTime(&ftExpire, &pMsgInfo->stExpiry);

    //
    //  Get the state of the message
    //
    pMsgInfo->fMsgFlags = MP_NORMAL;
    if (pqapictx)
    {
        if (LI_RETRY == pqapictx->lfGetQueueState())
            pMsgInfo->fMsgFlags |= MP_MSG_RETRY;
        else if (LI_FROZEN == pqapictx->lfGetQueueState())
            pMsgInfo->fMsgFlags |= MP_MSG_FROZEN;

    }

Exit:

    //
    //  If this operation resulted in opening the message, we should close it
    //  The message is not dirty (we did not write anything), so it should not
    //  need to commit
    //
    if (!cOpenHandlesForMsg)
    {
        HRESULT hrTmp = S_OK;
        hrTmp = HrReleaseIMailMsgUsageCount(pIMailMsgProperties);
        if (SUCCEEDED(hrTmp))
            HrIncrementIMailMsgUsageCount(pIMailMsgProperties);
    }

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMailMsgQueue::HrInternalQuerySupportedActions ]---------------
//
//
//  Description:
//      Returns the actions and filters that this implementation supports
//  Parameters:
//      pdwSupportedActions     - QAPI MsgActions that this queue suppprts
//      pdwSupportedFilterFlags - QAPI filter flags that this queue supports
//  Returns:
//      S_OK on success
//  History:
//      12/12/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMailMsgQueue::HrInternalQuerySupportedActions(
                                DWORD  *pdwSupportedActions,
                                DWORD  *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMailMsgQueue::HrInternalQuerySupportedActions");
    HRESULT hr = S_OK;

    hr = QueryDefaultSupportedActions(pdwSupportedActions, pdwSupportedFilterFlags);
    if (FAILED(hr))
        goto Exit;

    //
    //  This queue implementation does not support all of the default flags.
    //
    _ASSERT(pdwSupportedActions);
    _ASSERT(pdwSupportedFilterFlags);

    //
    //  We don't support:
    //      - Freeze global - No status to set on a mailmsg
    //      - Thaw global - can't freeze... therefore cannot thaw
    //
    *pdwSupportedActions &= ~(MA_FREEZE_GLOBAL | MA_THAW_GLOBAL);

    //
    //  We don't support
    //      - Checking for frozen messages (we have no status to indicate
    //          that a message is frozen)
    //
    *pdwSupportedFilterFlags &= ~(MF_FROZEN);

  Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\mailadmq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: mailadmq.h
//
//  Description:
//      Header file that provides basic functionality of the QAPI for mailmsg
//      based links.
//
//      All internal queues (precat, prerouting,...) are thread-pool fed
//      async queues of the type CAsyncAdminMailMsgQueue.  This corresponds
//      to the concept of a "queue" (final destination).
//
//      For each internal queue exposed by the API, there is an corresponding
//      CMailMsgAdminLink that represents a "link" and provides the
//      link-level functionality.
//
//  Author: Gautam Pulla(GPulla)
//
//  History:
//      6/23/1999 - GPulla Created
//      12/7/2000 - MikeSwa Adding CAsyncAdminMailMsgQueue
//                          Rename CMailMsgAdminQueue to CMailMsgAdminLink
//
//  Copyright (C) 1999, 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __MAILMSGADMQ_H__
#define __MAILMSGADMQ_H__

#include <asyncadm.h>

//---[ CAsyncAdminMailMSgQueue ]-----------------------------------------------
//
//
//  Description:
//      Implements QAPI queue-level functionality that is specific to the
//      IMailMsgProperties object.
//
//      Also implements handle-throttling logic on enqueue
//  Hungarian:
//      asyncmmq, pasyncmmq
//
//
//-----------------------------------------------------------------------------
class CAsyncAdminMailMsgQueue :
    public CAsyncAdminQueue<IMailMsgProperties *, ASYNC_QUEUE_MAILMSG_SIG>
{
  private:

    //Send Delay or NDR DSN's if the message has expired
    HRESULT HrSendDelayOrNDR(IMailMsgProperties *pIMailMsgProperties);

  public:
    CAsyncAdminMailMsgQueue(LPCSTR szDomain, LPCSTR szLinkName,
        const GUID *pguid, DWORD dwID, CAQSvrInst *paqinst) :
            CAsyncAdminQueue<IMailMsgProperties *, ASYNC_QUEUE_MAILMSG_SIG>(szDomain,
                szLinkName, pguid, dwID, paqinst,
                HrQADMApplyActionToIMailMessages) {};

    //
    //  The following methods are IMailMsgProperties specific QAPI function.
    //  The MsgRef-specific versions of these functions are implemented by the
    //  CMsgRef object itself
    //
    static BOOL fMatchesQueueAdminFilter(IMailMsgProperties *pIMailMsgProperties,
                                  CAQAdminMessageFilter *paqmf);
    static HRESULT HrGetQueueAdminMsgInfo(IMailMsgProperties *pIMailMsgProperties,
                                  MESSAGE_INFO *pMsgInfo,
                                  PVOID pvContext);

  protected: // Virutal functions used to implement msg specific actions
    virtual HRESULT HrDeleteMsgFromQueueNDR(IUnknown *pIUnknownMsg);
    virtual HRESULT HrDeleteMsgFromQueueSilent(IUnknown *pIUnknownMsg);
    virtual HRESULT HrFreezeMsg(IUnknown *pIUnknownMsg);
    virtual HRESULT HrThawMsg(IUnknown *pIUnknownMsg);
    virtual HRESULT HrGetStatsForMsg(IUnknown *pIUnknownMsg, CAQStats *paqstats);
    virtual HRESULT HrInternalQuerySupportedActions(
                                DWORD  *pdwSupportedActions,
                                DWORD  *pdwSupportedFilterFlags);

    //
    //  Statics used to dynamically adjust mailmsg load
    //
    static  DWORD s_cTotalAsyncMailMsgQs;
    static  DWORD s_cTotalAsyncMailMsgQsBelowLowThreshold;
    static  DWORD s_cTotalasyncMailMsgQsAboveMaxThreshold;

    //
    // The possible states for this queue to be in  (depending on 
    //	how much work is left for this queue)
    //  
    typedef enum _eAsyncMailMsgQThreshold
    {
    		ASYNC_MAILMSG_Q_BELOW_LOW_THRESHOLD,
    		ASYNC_MAILMSG_Q_BETWEEN_THRESHOLDS,
    		ASYNC_MAILMSG_Q_ABOVE_MAX_THRESHOLD
    } eAsyncMailMsgQThreahold;

  public:

    // We override this fnct so that we can check to see if the message
    // has expired (and possibly NDR) before putting it in the retry queue
    BOOL    fHandleCompletionFailure(IMailMsgProperties *pIMailMsgProperties);

    //Queues request & closes handles if total number of messages
    //in system is over the limit.
    HRESULT HrQueueRequest(IMailMsgProperties *pIMailMsgProperties,
                           BOOL  fRetry,
                           DWORD cMsgsInSystem);

    //Since we inherit from someone who implmenents this, assert so that
    //a dev adding a new call later on, will use the version that
    //closes handles
    HRESULT HrQueueRequest(IMailMsgProperties *pIMailMsgProperties,
                           BOOL  fRetry = FALSE);

    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

};

#define MAIL_MSG_ADMIN_QUEUE_VALID_SIGNATURE 'QAMM'
#define MAIL_MSG_ADMIN_QUEUE_INVALID_SIGNATURE '!QAM'

//-----------------------------------------------------------------------------
//
//  CMailMsgAdminLink
//
//  Hungarian: pmmaq, mmaq
//
//  This class is a wrapper for CAsyncAdminMailMsgQueue to provide objects of that
//  class (precat, prerouting) with an admin interface. Only a limited amount
//  of the admin functionality (compared to the locallink or other links) is
//  provided.
//-----------------------------------------------------------------------------

class CMailMsgAdminLink :
    public CBaseObject,
    public IQueueAdminAction,
    public IQueueAdminLink,
    public IAQNotify,
    public CQueueAdminRetryNotify
{
protected:
	DWORD							 m_dwSignature;
    GUID                             m_guid;
    DWORD                            m_cbQueueName;
    LPSTR                            m_szQueueName;
    CAsyncAdminMailMsgQueue         *m_pasyncmmq;
    DWORD                            m_dwLinkType;
    CAQScheduleID                    m_aqsched;
    CAQSvrInst                       *m_paqinst;
    FILETIME                         m_ftRetry;

public:
    CMailMsgAdminLink (GUID  guid,
                        LPSTR szLinkName,
                        CAsyncAdminMailMsgQueue *pasyncmmq,
                        DWORD dwLinkType,
                        CAQSvrInst *paqinst);
    ~CMailMsgAdminLink();

public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

public: //IQueueAdminAction

    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD(HrApplyActionToMessage)(
        IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
        BOOL *pfShouldDelete);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags);
public: //IQueueAdminLink
    STDMETHOD(HrGetLinkInfo)(
        LINK_INFO *pliLinkInfo, HRESULT *phrDiagnosticError);

    STDMETHOD(HrApplyActionToLink)(
        LINK_ACTION la);

    STDMETHOD(HrGetLinkID)(
        QUEUELINK_ID *pLinkID);

    STDMETHOD(HrGetNumQueues)(
        DWORD *pcQueues);

    STDMETHOD(HrGetQueueIDs)(
        DWORD *pcQueues,
        QUEUELINK_ID *rgQueues);

public: //IAQNotify
    virtual HRESULT HrNotify(CAQStats *aqstats, BOOL fAdd);

public: //CQueueAdminRetryNotify
    virtual void SetNextRetry(FILETIME *pft);
public:

    DWORD GetLinkType() { return m_dwLinkType; }
    BOOL fRPCCopyName(OUT LPWSTR *pwszLinkName);
    BOOL fIsSameScheduleID(CAQScheduleID *paqsched);
};

#endif __MAILMSGADMQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\intrnlqa.h $(O)\intrnlqa_i.c : intrnlqa.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\intrnlqa_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\intrnlqa_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqadmin.h $(O)\aqadmin_i.c : $(STAXINC)\export\aqadmin.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqadmin_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqadmin_i.c \
    -header $@ \
    -tlb $(O)\aqadmin.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqadmrpc.h $(O)\aqadmrpc_s.c : ..\inc\aqadmrpc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -client none \
    -sstub $(O)\aqadmrpc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqmsg.h $(O)\aqmsg.rc $(O)\aqmsg.bin: $(STAXINC)\export\aqerr.mc $(STAXINC)\export\caterr.mc $(STAXINC)\export\phatqmsg.mc
    copy /a $(STAXINC)\export\aqerr.mc + /a $(STAXINC)\export\caterr.mc + /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqmsg.rc
    del  $(O)\tmp.rc
    copy $(O)\msg00001.bin $(O)\aqmsg.bin

$(O)\aqerr.h $(O)\aqerr.rc $(O)\aqerr.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc
    copy $(O)\msg00001.bin $(O)\aqerr.bin

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00003.bin: ..\..\server\smtpmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a ..\..\server\smtpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\mem.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: mem.cpp
//
//  Description:  
//    File that initializes required staxmem globals
//
//  Author: Mike Swafford (MikeSwa)
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "aqprecmp.h"

HANDLE g_hTransHeap = NULL;
PVOID  g_pvHeapReserve = NULL;
BOOL   g_fNoHeapFree = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgguid.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: msgguid.cpp
//
//  Description: Implementation of AQMsgGuidList and CAQMsgGuidListEntry
//      classes which provide the functionality to supersede outdated
//      msg ID's.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/10/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "msgguid.h"

CPool CAQMsgGuidListEntry::s_MsgGuidListEntryPool(MSGGUIDLIST_ENTRY_SIG);
//
//  A brief note about locks for thess classes.
//
//  The CAMsgGuidList* classes are protected by a single per-virtual server
//  ShareLock (m_slPrivateData of course).  These locks are non-reentrant, so
//  it is critical that we do not hold these locks while doing something that
//  may cause a locking call back into us (like releasing a CMsgReference).
//

//---[ CAQMsgGuidListEntry::CAQMsgGuidListEntry ]------------------------------
//
//
//  Description: 
//      Constructor for CAQMsgGuidListEntry
//  Parameters:
//      pmsgref         Ptr to CMsgRef for this ID
//      pguid           GUID ID of this message
//      pliHead         Head of list to add to
//      pmgl            List this entry belongs to
//  Returns:
//      -
//  History:    
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidListEntry::CAQMsgGuidListEntry(CMsgRef *pmsgref, GUID *pguid, 
                                         PLIST_ENTRY pliHead, CAQMsgGuidList *pmgl) 
{
    _ASSERT(pmsgref);
    _ASSERT(pguid);
    _ASSERT(pmgl);
    _ASSERT(pliHead);

    m_dwSignature = MSGGUIDLIST_ENTRY_SIG;
    m_pmsgref = pmsgref;
    m_pmsgref->AddRef();
    m_pmgl = pmgl;

    memcpy(&m_guidMsgID, pguid, sizeof(GUID));

    InsertHeadList(pliHead, &m_liMsgGuidList);
}


//---[ CAQMsgGuidListEntry::~CAQMsgGuidListEntry ]-----------------------------
//
//
//  Description: 
//      Destructor for CAQMsgGuidListEntry
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidListEntry::~CAQMsgGuidListEntry()
{
    //we should not still be in a list
    _ASSERT(!m_liMsgGuidList.Flink);
    _ASSERT(!m_liMsgGuidList.Blink);

    m_dwSignature = MSGGUIDLIST_ENTRY_SIG_INVALID;

    //It is safe to release the message ref here, since there is no way it 
    //can call back into use (unless there is a ref-counting bug).
    if (m_pmsgref)
        m_pmsgref->Release();

    m_pmgl = NULL;
}

//---[ CAQMsgGuidListEntry::pmgleGetEntry ]------------------------------------
//
//
//  Description: 
//      Static function to get entry from LIST_ENTRY
//
//      NOTE: inline function for use by CAQMsgGuidList only
//  Parameters:
//      pli         LIST ENTRY
//  Returns:
//      pointer to associated CAQMsgGuidListEntry
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidListEntry *CAQMsgGuidListEntry::pmgleGetEntry(PLIST_ENTRY pli)
{
    _ASSERT(pli);
    CAQMsgGuidListEntry *pmgle = CONTAINING_RECORD(pli, 
                CAQMsgGuidListEntry, m_liMsgGuidList);
    ASSERT(pmgle->m_dwSignature == MSGGUIDLIST_ENTRY_SIG);
    return pmgle;
}
    
//---[ CAQMsgGuidListEntry::fCompareGuid ]-------------------------------------
//
//
//  Description: 
//      Function used by CAQMsgGuidList to determine if this has a the GUID
//      matching the superseded ID.
//
//      NOTE: inline function for use by CAQMsgGuidList only
//  Parameters:
//      pguid       GUID to check against
//  Returns:
//      TRUE if they match
//      FALSE otherwise
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQMsgGuidListEntry::fCompareGuid(GUID *pguid)
{
    _ASSERT(pguid);
    return (0 == memcmp(pguid, &m_guidMsgID, sizeof(GUID)));
}

//---[ CAQMsgGuidListEntry::RemoveFromList ]-----------------------------------
//
//
//  Description: 
//      Used by CMsgRef to remove an entry from the list once delivery is 
//      complete.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMsgGuidListEntry::RemoveFromList()
{
    _ASSERT(m_pmgl);
    m_pmgl->RemoveFromList(&m_liMsgGuidList);
}

//---[ CAQMsgGuidListEntry::pmsgrefGetAndClearMsgRef ]-------------------------
//
//
//  Description: 
//      First phase shutdown/deletion of object. Will set to NULL and return 
//      orginal msgref pointer.  When caller releases lock, they should release
//      the returned msgref.
// 
//      NOTE: Releasing the msgref while holding onto m_slPrivateData can 
//      lead to a deadlock.  m_slPrivateData should be held while this 
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CMsgRef *CAQMsgGuidListEntry::pmsgrefGetAndClearMsgRef()
{
    CMsgRef *pmsgref = m_pmsgref;
    m_pmsgref = NULL;
    return pmsgref;
}

//---[ CAQMsgGuidListEntry::SupersedeMsg ]-------------------------------------
//
//
//  Description: 
//      Function to supersede msg associated with this object.  Will flag the
//      associated CMsgRef as "non-deliverable"
//
//      NOTE: Should have MsgGuidList Write lock when calling
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMsgGuidListEntry::SupersedeMsg()
{
    m_pmsgref->SupersedeMsg();
    m_pmsgref->Release();
    m_pmsgref = NULL;
}

//---[ CAQMsgGuidList::CAQMsgGuidList ]-----------------------------------------
//
//
//  Description: 
//      Constructor for CAQMsgGuidList.
//  Parameters:
//      pcSupersededMsgs        Ptr to DWORD to InterlockedIncrement for
//                              a count of superseded messages.
//                              (can be NULL if no counters are wanted)
//  Returns:
//      -
//  History:    
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidList::CAQMsgGuidList(DWORD *pcSupersededMsgs)
{
    m_dwSignature = MSGGUIDLIST_SIG;
    m_pcSupersededMsgs = pcSupersededMsgs;
    InitializeListHead(&m_liMsgGuidListHead);
}

//---[ CAQMsgGuidList::~CAQMsgGuidList ]---------------------------------------
//
//
//  Description: 
//      Desctructor for CAQMsgGuidList
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidList::~CAQMsgGuidList()
{
    Deinitialize(NULL);
    _ASSERT(IsListEmpty(&m_liMsgGuidListHead));
}

//---[ CAQMsgGuidList::pmgleAddMsgGuid ]---------------------------------------
//
//
//  Description: 
//      Adds a message ID/Msg to the list of msg GUIDs.  Will also search for 
//      the superseded msg GUID ID from the tail of the list.
//
//      This is meant as a server-side optimization.  There is *no* attempt
//      to recover from out of memory situations.
//  Parameters:
//      pmsgref             MsgRef associated with this ID
//      pguidID             GUID ID of this message
//      pguidSuperseded     GUID ID of message superseded by this message
//      
//  Returns:
//      Pointer to list entry for this msg (caller *must* Release)
//      NULL if no entry allocated
//  History:
//      10/11/98 - MikeSwa Created 
//      05/08/99 - MikeSwa Fixed AV 
//
//-----------------------------------------------------------------------------
CAQMsgGuidListEntry *CAQMsgGuidList::pmgleAddMsgGuid(CMsgRef *pmsgref, 
                                                     GUID *pguidID, 
                                                     GUID *pguidSuperseded)
{
    _ASSERT(pmsgref);
    _ASSERT(pguidID);
    CAQMsgGuidListEntry *pmgle = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    CMsgRef *pmsgrefSuperseded = NULL;

    //First search list for matching GUID
    m_slPrivateData.ShareLock();
    pliCurrent = m_liMsgGuidListHead.Blink;
    while (pliCurrent && (pliCurrent != &m_liMsgGuidListHead))
    {
        pmgle = CAQMsgGuidListEntry::pmgleGetEntry(pliCurrent);
        if (pguidSuperseded && pmgle->fCompareGuid(pguidSuperseded))
        {
            //we found a match... addref it and stop looking
            pmgle->AddRef();
            break;
        }

        //NOTE: We may want to consider adding functionality that 
        //would allow us to supersede messages that are added to the 
        //system later... if some layer of abstaction (like the pickup dir)
        //causes out of order submission, this would allow us to handle
        //that case.  It could require:
        //  - Additional check of current ID against all superseded ID's (2x cost)
        //  - Additional storage of original superseded ID's.

        pmgle = NULL;
        pliCurrent = pliCurrent->Blink;
    }
    m_slPrivateData.ShareUnlock();

    m_slPrivateData.ExclusiveLock();
    if (pmgle)
    {
        //make sure someone else hasn't removed it from the list
        if (pliCurrent->Blink && pliCurrent->Flink)
        {
            //If we found a match supersede
            if (m_pcSupersededMsgs)
                InterlockedIncrement((PLONG) m_pcSupersededMsgs);
            pmgle->SupersedeMsg();
            RemoveEntryList(pliCurrent);
            pliCurrent->Flink = NULL;
            pliCurrent->Blink = NULL;

            pmsgrefSuperseded = pmgle->pmsgrefGetAndClearMsgRef();
            //Release once for entry in list, and once for AddRef above
            _VERIFY(pmgle->Release());
            pmgle->Release();
        }
    }

    pmgle = new CAQMsgGuidListEntry(pmsgref, pguidID, &m_liMsgGuidListHead, this);
    if (pmgle)
        pmgle->AddRef();

    m_slPrivateData.ExclusiveUnlock();

    if (pmsgrefSuperseded)
        pmsgrefSuperseded->Release();

    return pmgle;
}

//---[ CAQMsgGuidList::Deinitialize ]------------------------------------------
//
//
//  Description: 
//      Walks list and released all msg id objects.  Calls server stop hint 
//      function if provided.
//  Parameters:
//      painst      Ptr to virtual server object to call stop hint function
//  Returns:
//      -
//  History:
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMsgGuidList::Deinitialize(CAQSvrInst *paqinst)
{
    PLIST_ENTRY pliCurrent = NULL;
    CAQMsgGuidListEntry *pmgle = NULL;
    CMsgRef *pmsgref = NULL;

    m_slPrivateData.ExclusiveLock();

    //Walk entire list and release all objects
    while (!IsListEmpty(&m_liMsgGuidListHead))
    {
        pliCurrent = m_liMsgGuidListHead.Flink;
        _ASSERT(pliCurrent);
        pmgle = CAQMsgGuidListEntry::pmgleGetEntry(pliCurrent);
        _ASSERT(pmgle);
        RemoveEntryList(pliCurrent);
        pliCurrent->Flink = NULL;
        pliCurrent->Blink = NULL;
    
        //we must unlock to Deinitalize and release won't deadlock
        m_slPrivateData.ExclusiveUnlock();
        //Send shutdown hint
        if (paqinst)
            paqinst->ServerStopHintFunction();

        pmsgref = pmgle->pmsgrefGetAndClearMsgRef();
        if (pmsgref)
            pmsgref->Release();

        pmgle->Release();

        //Lock so we can check if list is empty
        m_slPrivateData.ExclusiveLock();
    }
    m_slPrivateData.ExclusiveUnlock();
}

//---[ CAQMsgGuidList::RemoveFromList ]----------------------------------------
//
//
//  Description: 
//      Used by a CAQMsgGuidListEntry to remove itself from the list in a 
//      thread-safe manner.  The CAQMsgGuidListEntry is called by the CMsgRef
//      when it is completely handled.
//  Parameters:
//      pli         PLIST_ENTRY to remove from list
//  Returns:
//      -
//  History:
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMsgGuidList::RemoveFromList(PLIST_ENTRY pli)
{
    _ASSERT(pli);
    CAQMsgGuidListEntry *pmgle = CAQMsgGuidListEntry::pmgleGetEntry(pli);
    CMsgRef *pmsgref = NULL;
    m_slPrivateData.ExclusiveLock();

    if (pli->Flink && pli->Blink)
    {
        //Only remove from list once
        RemoveEntryList(pli);
        pli->Flink = NULL;
        pli->Blink = NULL;
        pmsgref = pmgle->pmsgrefGetAndClearMsgRef();
        //Caller must still have reference
        _VERIFY(pmgle->Release());
    }
    m_slPrivateData.ExclusiveUnlock();

    //Do not release while holding lock
    if (pmsgref)
        pmsgref->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgrefadm.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: msgrefadm.cpp
//
//  Description:
//      Implements CAsyncAdminMsgRefQueue class
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/7/2000 - MikeSwa Created 
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "msgrefadm.h"
#include "asyncadm.inl"


//---[ CAsyncAdminMsgRefQueue::HrDeleteMsgFromQueueNDR ]-----------------------
//
//
//  Description: 
//      Wraps call to NDR MsgRef
//  Parameters:
//      *pIUnknown - IUnkown of Msgref
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMsgRefQueue::HrDeleteMsgFromQueueNDR(
                                            IUnknown *pIUnknownMsg)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMsgRefQueue::HrDeleteMsgFromQueueNDR");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;

    _ASSERT(pIUnknownMsg);

    hr = pIUnknownMsg->QueryInterface(IID_CMsgRef, (void **) &pmsgref);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a CMsgRef!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MsgRef failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Attempt to NDR message
    //
    hr = pmsgref->HrQueueAdminNDRMessage(NULL);

  Exit:
    if (pmsgref)
        pmsgref->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMsgRefQueue::HrDeleteMsgFromQueueSilent ]--------------------
//
//
//  Description: 
//      Wrapper function to silently delete a message from a queue
//  Parameters:
//      *pIUnknown - IUnkown of Msgref
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMsgRefQueue::HrDeleteMsgFromQueueSilent(
                                            IUnknown *pIUnknownMsg)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMsgRefQueue::HrDeleteMsgFromQueueSilent");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;

    _ASSERT(pIUnknownMsg);

    hr = pIUnknownMsg->QueryInterface(IID_CMsgRef, (void **) &pmsgref);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a CMsgRef!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MsgRef failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Attempt to remove the message from the queue
    //
    hr = pmsgref->HrRemoveMessageFromQueue(NULL);

  Exit:
    if (pmsgref)
        pmsgref->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMsgRefQueue::HrFreezeMsg ]-----------------------------------
//
//
//  Description: 
//      Wrapper to freeze a pmsgref
//  Parameters:
//      *pIUnknown - IUnkown of Msgref
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMsgRefQueue::HrFreezeMsg(IUnknown *pIUnknownMsg)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMsgRefQueue::HrFreezeMsg");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;

    _ASSERT(pIUnknownMsg);

    hr = pIUnknownMsg->QueryInterface(IID_CMsgRef, (void **) &pmsgref);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a CMsgRef!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MsgRef failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Attempt to freeze the message
    //
    pmsgref->GlobalFreezeMessage();

  Exit:
    if (pmsgref)
        pmsgref->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMsgRefQueue::HrThawMsg ]-------------------------------------
//
//
//  Description: 
//      Wrapper function to thaw a message
//  Parameters:
//      *pIUnknown - IUnkown of Msgref
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMsgRefQueue::HrThawMsg(IUnknown *pIUnknownMsg)
{
    TraceFunctEnterEx((LPARAM) this, "AsyncAdminMsgRefQueue::HrThawMsg");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;

    _ASSERT(pIUnknownMsg);

    hr = pIUnknownMsg->QueryInterface(IID_CMsgRef, (void **) &pmsgref);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a CMsgRef!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MsgRef failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Attempt to thaw message
    //
    pmsgref->GlobalThawMessage();

  Exit:
    if (pmsgref)
        pmsgref->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMsgRefQueue::HrGetStatsForMsg ]------------------------------
//
//
//  Description: 
//      Wrapper function to fill in the CAQStats struct for a message
//  Parameters:
//      *pIUnknown - IUnkown of Msgref
//      *paqstats - Ptr to aqstats struction to fill in.
//  Returns:
//      S_OK on success
//  History:
//      12/7/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMsgRefQueue::HrGetStatsForMsg(
                                            IUnknown *pIUnknownMsg,
                                            CAQStats *paqstats)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMsgRefQueue::HrGetStatsForMsg");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;

    _ASSERT(pIUnknownMsg);
    _ASSERT(paqstats);

    hr = pIUnknownMsg->QueryInterface(IID_CMsgRef, (void **) &pmsgref);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a CMsgRef!!");
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "QI for MsgRef failed with hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Attempt to get stats from MsgRef
    //
    pmsgref->GetStatsForMsg(paqstats);

  Exit:
    if (pmsgref)
        pmsgref->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncAdminMsgRefQueue::HrInternalQuerySupportedActions ]---------------
//
//
//  Description: 
//      Returns the actions and filters that this implementation supports
//  Parameters:
//      pdwSupportedActions     - QAPI MsgActions that this queue suppprts
//      pdwSupportedFilterFlags - QAPI filter flags that this queue supports
//  Returns:
//      S_OK on success
//  History:
//      12/12/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncAdminMsgRefQueue::HrInternalQuerySupportedActions(
                                DWORD  *pdwSupportedActions,
                                DWORD  *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncAdminMsgRefQueue::HrInternalQuerySupportedActions");
    HRESULT hr = S_OK;

    //
    //  This queue implementation supports all of the default flags.  
    //
    hr = QueryDefaultSupportedActions(pdwSupportedActions, pdwSupportedFilterFlags);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgguid.h ===
//-----------------------------------------------------------------------------
//
//
//  File: msgguid.h
//
//  Description: Contains definitions of CAQMsgGuidList and CAQMsgGuidListEntry 
//      which provide functionality to supersede outdated msg ID's
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/10/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __MSGGUID_H__
#define __MSGGUID_H__

#include <cpool.h>

class CMsgRef;
class CAQMsgGuidList;
class CAQSvrInst;

#define MSGGUIDLIST_SIG                 ' LGM'
#define MSGGUIDLIST_ENTRY_SIG           'EgsM'
#define MSGGUIDLIST_ENTRY_SIG_INVALID   'sgM!'

//---[ CAQMsgGuidListEntry ]---------------------------------------------------
//
//
//  Description: 
//      Entry for CAQMsgGuidList
//  Hungarian: 
//      mgle, pmgle
//  
//-----------------------------------------------------------------------------
class CAQMsgGuidListEntry : public CBaseObject
{
  protected:
    DWORD           m_dwSignature;
    CMsgRef        *m_pmsgref;
    LIST_ENTRY      m_liMsgGuidList;
    CAQMsgGuidList *m_pmgl;
    GUID            m_guidMsgID;
  public:
    static  CPool   s_MsgGuidListEntryPool;
    void * operator new (size_t stIgnored); //should not be used
    void operator delete(void *p, size_t size);

    CAQMsgGuidListEntry(CMsgRef *pmsgref, GUID *pguid, PLIST_ENTRY pliHead,
                        CAQMsgGuidList *pmgl);
    ~CAQMsgGuidListEntry();

    //Used by CAQMsgGuidList
    static inline CAQMsgGuidListEntry * pmgleGetEntry(PLIST_ENTRY pli);
    inline BOOL fCompareGuid(GUID *pguid);
    inline CMsgRef *pmsgrefGetAndClearMsgRef();

    //Used by CMsgRef to remove from list when done delivering msg
    void        RemoveFromList();

    void        SupersedeMsg();
};

//---[ CAQMsgGuidList ]--------------------------------------------------------
//
//
//  Description: 
//      Class that exposes functionality to store and search for message ID's.
//      Used to provide "supersedes msg ID" functionality
//  Hungarian: 
//      mgl, pmgl
//  
//-----------------------------------------------------------------------------
class CAQMsgGuidList 
{
  protected:
    DWORD           m_dwSignature;
    DWORD          *m_pcSupersededMsgs;
    LIST_ENTRY      m_liMsgGuidListHead;
    CShareLockNH    m_slPrivateData;
  public:
    CAQMsgGuidList(DWORD *pcSupersededMsgs = NULL);
    ~CAQMsgGuidList();

    CAQMsgGuidListEntry *pmgleAddMsgGuid(CMsgRef *pmsgref, 
                                         GUID *pguidID, 
                                         GUID *pguidSuperseded);
    void Deinitialize(CAQSvrInst *paqinst);
    void RemoveFromList(PLIST_ENTRY pli);
    
};

inline void *CAQMsgGuidListEntry::operator new(size_t size) 
{
    return s_MsgGuidListEntryPool.Alloc();
}

inline void CAQMsgGuidListEntry::operator delete(void *p, size_t size) 
{
    s_MsgGuidListEntryPool.Free(p);
}

#endif //__MSGGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgref.h ===
//-----------------------------------------------------------------------------
//
//
//  File: msgref.h
//
//  Description: Definition of Queueing MsgRef object
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _MSGREF_H_
#define _MSGREF_H_

#include "cmt.h"
#include "baseobj.h"
#include "bitmap.h"
#include "domain.h"
#include "aqueue.h"
#include "aqroute.h"
#include "qwiklist.h"
#include "dcontext.h"
#include <mailmsg.h>
#include "msgguid.h"
#include "aqutil.h"
#include "aqadmsvr.h"
#include <aqerr.h>
#include <aqreg.h>

class CDestMsgQueue;
class CAQSvrInst;
class CAQStats;

// {34E2DCC8-C91A-11d2-A6B1-00C04FA3490A}
static const GUID IID_CMsgRef =
{ 0x34e2dcc8, 0xc91a, 0x11d2, { 0xa6, 0xb1, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

//FLAGS that say which IMsg data we care about
#define MSGREF_VALID_FLAGS  (eMsgSize | eMsgArriveTime | eMsgPriority)

//MsgRef signature
#define MSGREF_SIG          'feRM'

//max number of domains for CPool allocator
#define MSGREF_STANDARD_DOMAINS 12

//
// Make sure the "standard" CPool size is
//  - large enough to accommidate any padding in the CPoolMsgRef struct
//  - QWORD alligned so 64-bit machines are happy
//
#define MSGREF_STANDARD_CPOOL_SIZE \
    (((sizeof(CPoolMsgRef) - sizeof(CMsgRef) + \
      CMsgRef::size(MSGREF_STANDARD_DOMAINS)) + 0x10) & ~0xF)

//A Note about bitmaps
//The Recips bitmap represents the responsible recipients for a destination,
//or message request. 1 means that the tansport should attempt to deliver for
//this connection.

#ifdef DEBUG
_declspec(selectany) DWORD g_cDbgMsgRefsCpoolAllocated = 0;
_declspec(selectany) DWORD g_cDbgMsgRefsExchmemAllocated = 0;
_declspec(selectany) DWORD g_cDbgMsgRefsCpoolFailed = 0;
_declspec(selectany) DWORD g_cDbgMsgIdHashFailures = 0;
_declspec(selectany) DWORD g_cDbgMsgRefsPendingRetryOnDelete = 0;
#endif //DEBUG

//define reserved message status codes ... should be in MESSAGE_STATUS_RESERVED
#define MESSAGE_STATUS_LOCAL_DELIVERY   0x80000000
#define MESSAGE_STATUS_DROP_DIRECTORY   0x40000000

//---[ CMsgRef ]---------------------------------------------------------------
//
//
//    Hungarian: msgref, pmsgref
//
//    Persistable message reference object used throughout advanced queuing
//-----------------------------------------------------------------------------
class CMsgRef :
    public IUnknown,
    public CBaseObject
{
public:
    static  CPool   s_MsgRefPool;
    //override the new operator
    void * operator new (size_t stIgnored,
                    unsigned int cDomains); //Number of domains in message
    void * operator new (size_t stIgnored); //should not be used
    void operator delete(void *p, size_t size);

    CMsgRef(DWORD cDomains, IMailMsgQueueMgmt *pIMailMsg,
        IMailMsgProperties *pIMailMsgProperties, CAQSvrInst *paqinst,
        DWORD dwMessageType, GUID guidMessageRouter);
    ~CMsgRef();

    //perform initialization and determine the queues for this message.
    //A NULL Queue signifies local delivery
    HRESULT HrInitialize(
                IN  IMailMsgRecipients *pIRecipList, //recipient interface for msg
                IN  IMessageRouter *pIMessageRouter, //Router for this message
                IN  DWORD  dwMessageType,
                OUT DWORD *pcLocalRecips,
                OUT DWORD *pcRemoteRecips,
                OUT DWORD *pcQueues,       //# of queues for this message
                OUT CDestMsgQueue **rgpdmqQueues);   //array of queue ptrs

    //Get the effective priority of the message
    inline  EffectivePriority PriGetPriority()
        {return (EffectivePriority) (MSGREF_PRI_MASK & m_dwDataFlags);};

    inline IMailMsgProperties *pimsgGetIMsg()
        {Assert(m_pIMailMsgProperties);m_pIMailMsgProperties->AddRef();return m_pIMailMsgProperties;};

    inline BOOL fIsMyMailMsg(IMailMsgProperties *pIMailMsgProperties)
        {return (pIMailMsgProperties == m_pIMailMsgProperties);};

    //get the size of the message content
    inline DWORD    dwGetMsgSize()
        {return(m_cbMsgSize);};

    inline DWORD    cGetNumDomains() {return(m_cDomains);};

    //get the size of the class (including all extras)
    inline  size_t   size()
        {return (size(m_cDomains));};

    //Return the delivery context needed for delivery over a given link
    //Do NOT free prgdwRecips... it will disappear with the AckMessage
    HRESULT HrPrepareDelivery(
                IN BOOL fLocal,             //prepare for local domains as well
                IN BOOL fDelayDSN,          //Check/Set DelayDSN bitmap
                IN CQuickList *pqlstQueues,  //array of DestMsgQueues
                IN CDestMsgRetryQueue* pdmrq, //retry interface for message
                IN OUT CDeliveryContext *pdcntxt, //context that must be returned on Ack
                OUT DWORD *pcRecips,           //#of recips to deliver
                OUT DWORD **prgdwRecips);  //array of recip indexes

    //Acknowledge (non)delivery of a msg
    HRESULT HrAckMessage(
                IN CDeliveryContext *pdcntxt,  //Delivery context of message
                IN MessageAck *pMsgAck); //Delivery status of message

    CAQMessageType *paqmtGetMessageType() {return &m_aqmtMessageType;};

    //size that can be used by new operator
    static inline  size_t  size(DWORD cDomains)
    {
        return (sizeof(CMsgRef) +
                (cDomains-1)*sizeof(CDestMsgQueue *) +  //cDomains dmq ptrs
                (cDomains + 3) * (CMsgBitMap::size(cDomains)) + //bitmaps
                (cDomains*2) * sizeof(DWORD));
    };

    //Send Delay or NDR DSN's if the message has expired
    HRESULT HrSendDelayOrNDR(
                IN  DWORD dwDSNOptions,      //Flags for DSN generation
                IN  CQuickList *pqlstQueues, //list of DestMsgQueues
                IN  HRESULT hrStatus,        //Status to Pass to DSN generation
                OUT DWORD *pdwDSNFlags);     //description of what the result was

    //bit flag return values for HrSendDelayOrNDR
    enum
    {
        MSGREF_DSN_SENT_NDR     = 0x00000001, //Message NDR-expired and NDR was sent
        MSGREF_DSN_SENT_DELAY   = 0x00000002, //Message Delay-expired and Delay DSN was sent
        MSGREF_HANDLED          = 0x00000004, //Message has been completely handled
        MSGREF_HAS_NOT_EXPIRED  = 0x00000008, //Message younger than it's exipiration dates
    };

    //bit flag options for DSN generation
    enum
    {
        MSGREF_DSN_LOCAL_QUEUE      = 0x00000001, //This is for a local queue
        MSGREF_DSN_SEND_DELAY       = 0x00000002, //Allow Delay DSNs
        MSGREF_DSN_CHECK_IF_STALE   = 0x00000004, //Force open handle to check if stale
        MSGREF_DSN_HAS_ROUTING_LOCK = 0x80000000, //This thread holds the routing lock
    };

    void SupersedeMsg();

    BOOL fMatchesQueueAdminFilter(CAQAdminMessageFilter *paqmf);
    HRESULT HrGetQueueAdminMsgInfo(MESSAGE_INFO *pMsgInfo, 
                                   IQueueAdminAction *pIQueueAdminAction);
    HRESULT HrRemoveMessageFromQueue(CDestMsgQueue *pdmq);
    HRESULT HrQueueAdminNDRMessage(CDestMsgQueue *pdmq);
    void GlobalFreezeMessage();
    void GlobalThawMessage();

    BOOL fIsMsgFrozen() {return(MSGREF_MSG_FROZEN & m_dwDataFlags);};
    FILETIME *pftGetAge() {return &m_ftQueueEntry;};

    void RetryOnDelete();

    void PrepareForShutdown() {ReleaseMailMsg(FALSE);};

    //Checks if the message can be retried (the backing storage may
    //have been deleted).
    BOOL fShouldRetry();

    void GetStatsForMsg(IN OUT CAQStats *paqstat);

    void MarkQueueAsLocal(IN CDestMsgQueue *pdmq);

    void CountMessageInRemoteTotals();

    // 
    // Determines if a message is a "problem" message.  Currently this is based purely on the number
    // of failures per message, but we may wish to add more logic at a later time.
    //
    BOOL fIsProblemMsg() 
        {return (g_cMsgFailuresBeforeMarkingMsgAsProblem && 
                 (m_cTimesRetried >= g_cMsgFailuresBeforeMarkingMsgAsProblem));};
    
  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

  protected:
    DWORD            m_dwSignature;
    CAQSvrInst      *m_paqinst;
    DWORD            m_dwDataFlags;  //private data flags
    DWORD            m_cbMsgSize;    //Size of message content in bytes
    FILETIME         m_ftQueueEntry; //time that message was enqueued
    FILETIME         m_ftLocalExpireDelay;
    FILETIME         m_ftLocalExpireNDR;
    FILETIME         m_ftRemoteExpireDelay;
    FILETIME         m_ftRemoteExpireNDR;

    CAQMsgGuidListEntry *m_pmgle;
    DWORD            m_cDomains;     //number of DOMAINS this message is destined for
    CAQMessageType   m_aqmtMessageType; //Message type
    IMailMsgQueueMgmt  *m_pIMailMsgQM;    //Reference to message Queue mgmt
    IMailMsgProperties *m_pIMailMsgProperties; //reference to message
    IMailMsgRecipients *m_pIMailMsgRecipients;
    DWORD            m_cTimesRetried;
    DWORD            m_dwMsgIdHash;
    volatile DWORD   m_cInternalUsageCount;
    CDestMsgQueue   *m_rgpdmqDomains[1]; //Actual size is m_cDomains

    static inline   BOOL    fIsStandardSize(DWORD cDomains)
    {
        return (MSGREF_STANDARD_DOMAINS >= cDomains);
    }

    HRESULT HrOneTimeInit();
    HRESULT HrPrvRetryMessage(CDeliveryContext *pdcntxt, DWORD dwMsgStatus);
    HRESULT HrPromoteMessageStatusToMailMsg(CDeliveryContext *pdcntxt,
                                            MessageAck *pMsgAck);

    HRESULT HrUpdateExtendedStatus(DWORD cbCurrentStatus,
                                   LPSTR szCurrentStatus,
                                   LPSTR *pszNewStatus);

    //private methods to get at "hidden" data.
    CMsgBitMap      *pmbmapGetDomainBitmap(DWORD iDomain);
    CMsgBitMap      *pmbmapGetHandled();
    CMsgBitMap      *pmbmapGetPending();
    CMsgBitMap      *pmbmapGetDSN();
    DWORD           *pdwGetRecipIndexStart();
    void             SetRecipIndex(DWORD iDomain, DWORD iLowRecip, DWORD iHighRecip);
    void             GetRecipIndex(DWORD iDomain, DWORD *piLowRecip, DWORD *piHighRecip);
    void             BounceUsageCount();
    static BOOL      fBounceUsageCountCompletion(PVOID pvContext, DWORD dwStatus);
    void             ReleaseAndBounceUsageOnMsgAck(DWORD dwMsgStatus);
    void             ReleaseMailMsg(BOOL fForceRelease);
    void             SyncBounceUsageCount();  //synchronous version of BounceUsageCount

    //Checks to see if the backing mailmsg has been deleted (or is about to
    //be deleted).
    BOOL             fMailMsgMarkedForDeletion()
        {return ((MSGREF_MAILMSG_DELETE_PENDING | MSGREF_MAILMSG_DELETED) & m_dwDataFlags);};

    //Marks the mailmsg for deletion.  MailMsg will be deleted when the usage
    //count drops.
    void             MarkMailMsgForDeletion();

    //Used to make sure that calling thread is the only one that will call Delete()
    //on the MailMsg.  Will set the MSGREF_MAILMSG_DELETED and call Delete().
    //Only called in ReleaseMailMsg() and InternalReleaseUsage().  The caller is
    //responsible for making sure that other threads are not reading the mailmsg or
    //have a usage count
    VOID             ThreadSafeMailMsgDelete();

    //Internal versions of AddUsage/ReleaseUsage.  Wraps the actual mailmsg calls, and
    //allows the CMsgRef to call delete on the MailMsg while there are still outstanding
    //references on it.  Uses m_cInternalUsageCount to maintain a count.
    HRESULT          InternalAddUsage();
    HRESULT          InternalReleaseUsage();

    enum //bitmasks for private flags
    {
        MSGREF_VERSION_MASK             = 0xE0000000,
        MSGREF_MSG_COUNTED_AS_REMOTE    = 0x08000000,
        MSGREF_MSG_LOCAL_RETRY          = 0x04000000,
        MSGREF_MSG_REMOTE_RETRY         = 0x02000000,
        MSGREF_USAGE_COUNT_IN_USE       = 0x01000000,
        MSGREF_SUPERSEDED               = 0x00800000, //Msg has been superseed
        MSGREF_MSG_INIT                 = 0x00400000, //HrInitialize has been called
        MSGREF_MSG_FROZEN               = 0x00200000,
        MSGREF_MSG_RETRY_ON_DELETE      = 0x00100000,
        MSGREF_ASYNC_BOUNCE_PENDING     = 0x00040000,
        MSGREF_MAILMSG_RELEASED         = 0x00020000,
        MSGREF_MAILMSG_DELETE_PENDING   = 0x00010000, //A delete is pending on this msg
        MSGREF_MAILMSG_DELETED          = 0x00008000, //The backing store for the mailmsg
                                                      //has been deleted.
        MSGREF_PRI_MASK                 = 0x0000000F,
        MSGREF_VERSION                  = 0x00000000,

        //used by allocators
        MSGREF_CPOOL_SIG_MASK   = 0xFFFF0000,
        MSGREF_CPOOL_SIG        = 0xC0070000,
        MSGREF_CPOOL_ALLOCATED  = 0x00000001,
        MSGREF_STANDARD_SIZE    = 0x00000002,
    };


    static  DWORD   s_cMsgsPendingBounceUsage;

    //Messages that have been marked pending delete, but have not been deleted
    static  DWORD   s_cCurrentMsgsPendingDelete;

    //Total number of messages that have been marked pending delete
    static  DWORD   s_cTotalMsgsPendingDelete;

    //Total number of messages that have been deleted after being marked
    //for delete pending
    static  DWORD   s_cTotalMsgsDeletedAfterPendingDelete;

    //Total number of messages that have had ::Deleted, but are still in
    //memory because someone has an outstanding reference to the msgref
    static  DWORD   s_cCurrentMsgsDeletedNotReleased;
};

//-----------------------------------------------------------------------------
//  Description:
//      Checks if the DSN HRESULT status is a fatal one, i.e. one for which an
//      NDR should be generated.
//-----------------------------------------------------------------------------
inline BOOL fIsFatalError(HRESULT hrStatus)
{
     return
       ((AQUEUE_E_NDR_ALL            == hrStatus) ||
        (AQUEUE_E_LOOPBACK_DETECTED  == hrStatus) ||
        (AQUEUE_E_ACCESS_DENIED      == hrStatus) ||
        (AQUEUE_E_MESSAGE_TOO_LARGE  == hrStatus) ||
        (AQUEUE_E_SMTP_GENERIC_ERROR == hrStatus) ||
        (AQUEUE_E_QADMIN_NDR         == hrStatus) ||
        (AQUEUE_E_NO_ROUTE           == hrStatus));
}

//---[ CPoolMsgRef ]-----------------------------------------------------------
//
//
//  Description:
//      Struct used as a hidden wrapper for CMsgRef allocation... used
//      exclusively by the CMsgRef new and delete operators
//  Hungarian:
//      cpmsgref, pcpmsgref
//
//-----------------------------------------------------------------------------
typedef struct _CPoolMsgRef
{
    DWORD   m_dwAllocationFlags;
    CMsgRef m_msgref;
} CPoolMsgRef;

//Cannot use default CMsgRef new operator
inline void * CMsgRef::operator new(size_t stIgnored)
{
    _ASSERT(0 && "Use new that specifies # of domains");
    return NULL;
}

inline void CMsgRef::operator delete(void *p, size_t size)
{
    CPoolMsgRef *pcpmsgref = CONTAINING_RECORD(p, CPoolMsgRef, m_msgref);
    _ASSERT((pcpmsgref->m_dwAllocationFlags & MSGREF_CPOOL_SIG_MASK) == MSGREF_CPOOL_SIG);

    if (pcpmsgref->m_dwAllocationFlags & MSGREF_CPOOL_ALLOCATED)
    {
        s_MsgRefPool.Free((void *) pcpmsgref);
    }
    else
    {
        FreePv((void *) pcpmsgref);
    }
}


// Layout of private data bit fields
// -------------------------------------
// |332|2222222221111111111987654|3210|
// |109|8765432109876543210      |    |
// -------------------------------------
// |   |                         |  ^--- Effective routing priority (max 16)
// |   |                         |       (Keep least significant so it can be
// |   |                         |       used as an array index)
// |   |           ^-------------------- General msgref flags
// | ^---------------------------------- Version number


//Actual data is variable-sized and extends beyond the class structure.
//Use the public functions to access it.  When persisting, be sure to persist
//the entire thing (use size() to see how big it really is).

// +----------+
// |          |
// |          | constant-size data structure CMsgRef
// |          |
// +----------+
// |          |
// |          | m_cDomains CDestMsgQueue pointers - Tells which queues this
// |          |   message is on.
// +----------+
// |          | Handled bitmap           \
// |          | Delivery pending bitmap   >- bitmaps are variable sized
// |          | Delay DSN's sent bitmap  /    (up to 32 domains fit in a DWORD)
// +----------+
// |          |
// |          | m_cDomains Domain responsibility bitmaps - used with
// |          |   the concept of "compressed" queues... not fully supported yet
// +----------+
// |          |
// |          | m_cDomains (x2) Recipient Index (start and stop... inclusive)
// |          |
// +----------+

#endif //_MSGREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\ntpch.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ntpch.cpp
//
//  Description:  NT PCH File - Includes the real .cpp file.  This lets us
//                 generate a seperate obj file to satisfy the NT build env.
//
//
//-----------------------------------------------------------------------------

#include <aqprecmp.h>

#include "aqprecmp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgref.cpp ===
//-----------------------------------------------------------------------------
//
//
//	File: msgref.cpp
//
//	Description:
//		Implementation of CMT Message reference
//
//	Author: mikeswa
//
//	Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "dcontext.h"
#include "dsnevent.h"
#include "aqutil.h"

CPool CMsgRef::s_MsgRefPool(MSGREF_SIG);
DWORD CMsgRef::s_cMsgsPendingBounceUsage = 0;
DWORD CMsgRef::s_cCurrentMsgsPendingDelete = 0;
DWORD CMsgRef::s_cTotalMsgsPendingDelete = 0;
DWORD CMsgRef::s_cTotalMsgsDeletedAfterPendingDelete = 0;
DWORD CMsgRef::s_cCurrentMsgsDeletedNotReleased = 0;

#ifndef DEBUG
#define _VERIFY_RECIPS_HANDLED(pIRecipList, iStartRecipIndex, cRecipCount)
#else
#define _VERIFY_RECIPS_HANDLED(pIRecipList, iStartRecipIndex, cRecipCount) \
    VerifyRecipsHandledFn(pIRecipList, iStartRecipIndex, cRecipCount);

//---[ VerifyRecipsHandleFn ]--------------------------------------------------
//
//
//  Description:
//      Verifies that all recipients in a given range have been handled.
//  Parameters:
//      pIRecipList         IMailMsgRecipients Interface for message
//      iStartRecipIndex    The first recipient to verify
//      cRecipCount         The count of recipients to verify
//  Returns:
//      -
//      Asserts on failures
//  History:
//      10/5/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void VerifyRecipsHandledFn(IMailMsgRecipients *pIRecipList,
                          DWORD iStartRecipIndex,
                          DWORD cRecipCount)
{
    HRESULT hr = S_OK;
    DWORD   dwCurrentRecipFlags = 0;
    for (DWORD j = iStartRecipIndex; j < cRecipCount + iStartRecipIndex; j++)
    {
        dwCurrentRecipFlags = 0;
        hr = pIRecipList->GetDWORD(j, IMMPID_RP_RECIPIENT_FLAGS,
                                        &dwCurrentRecipFlags);
        if (SUCCEEDED(hr))
            _ASSERT(RP_HANDLED & dwCurrentRecipFlags);
    }
}

#endif //DEBUG

//#ifndef DEBUG
#if 1
#define _VERIFY_QUEUE_PTR(paqinst, szCurrentDomain, pdmq, cQueues, rgpdmqQueues)
#else //DEBUG defined
#define _VERIFY_QUEUE_PTR(paqinst, szCurrentDomain, pdmq, cQueues, rgpdmqQueues) \
    VerifyQueuePtrFn(paqinst, szCurrentDomain, pdmq, cQueues, rgpdmqQueues)


//---[ VerifyQueuePtrFn ]-------------------------------------------------------
//
//
//  Description:
//      Debug function to verify that the queue ptr returned by HrMapDomain is
//      valid and does not confict with previous queue pointers.
//  Parameters:
//      paqinst - ptr to CMQ object
//      szCurrentDomain - Domain that ptr is for
//      pdmq    - Queue ptr to verify
//      cQueues - Number of queues so far
//      rgpdmqQueues    - Array of queues so far
//  Returns:
//      -
//  History:
//      6/1/98 - MikeSwa Created
//      8/14/98 - MikeSwa Modified to handled shutdown
//
//-----------------------------------------------------------------------------
void VerifyQueuePtrFn(CAQSvrInst *paqinst, LPSTR szCurrentDomain, CDestMsgQueue *pdmq,
                 DWORD cQueues, CDestMsgQueue **rgpdmqQueues)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pDomainInfo = NULL;
    DWORD j;

    //verify that non-local domains have queue ptrs
    hr = paqinst->HrGetInternalDomainInfo(strlen(szCurrentDomain), szCurrentDomain,
                                &pDomainInfo);

    if (AQUEUE_E_SHUTDOWN == hr)
        return;

    _ASSERT(SUCCEEDED(hr));
    if (!(pDomainInfo->m_DomainInfo.dwDomainInfoFlags & DOMAIN_INFO_LOCAL_MAILBOX))
        _ASSERT(pdmq && "NULL DesMsgQueue returned for NON-LOCAL domain");

    pDomainInfo->Release();

    //verify that Recip list is not returning domains out of order
    if (pdmq)
    {
        for (j = 0; j < cQueues; j++)
        {
            //check if ptr has been used yet
            if (rgpdmqQueues[j] == pdmq)
            {
                _ASSERT(0 && "IMailMsg Domain interface is broken");
            }
        }
    }

}
#endif //DEBUG

//---[ fAllRecipsInRangeHandled ]----------------------------------------------
//
//
//  Description:
//      Utility function that iterates through recipients in a range (usually
//      a single domain) and determines if all the recipients have been handled.
//  Parameters:
//      pIRecipList         IMailMsgRecipients Interface for message
//      iStartRecipIndex    The first recipient to verify
//      cRecipCount         The count of recipients to verify
//  Returns:
//      TRUE    if *all* of the recipients in the range are handle
//      FALSE   if one or more of the recipients in the range are not handled,
//  History:
//      10/25/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fAllRecipsInRangeHandled(IMailMsgRecipients *pIRecipList,
                          DWORD iStartRecipIndex,
                          DWORD cRecipCount)
{
    HRESULT hr = S_OK;
    DWORD   dwCurrentRecipFlags = 0;
    BOOL    fAreHandled = TRUE;

    _ASSERT(cRecipCount);

    for (DWORD j = iStartRecipIndex; j < cRecipCount + iStartRecipIndex; j++)
    {
        dwCurrentRecipFlags = 0;
        hr = pIRecipList->GetDWORD(j, IMMPID_RP_RECIPIENT_FLAGS,
                                        &dwCurrentRecipFlags);
        if (FAILED(hr) || !(RP_HANDLED & dwCurrentRecipFlags))
        {
                fAreHandled = FALSE;
                break;
        }
    }

    if (fAreHandled) {
        _VERIFY_RECIPS_HANDLED(pIRecipList, iStartRecipIndex, cRecipCount);
    }

    return fAreHandled;
}

//---[ CMsgRef::new ]----------------------------------------------------------
//
//
//  Description:
//      Overide the new operator to allow for the variable size of this class.
//      CPool is used for the 90% case allocations, while exchmem is used
//      for odd-size allocations.
//  Parameters:
//      cDomains    the number of domains this message is being delivered to.
//  Returns:
//      -
//-----------------------------------------------------------------------------
void * CMsgRef::operator new(size_t stIgnored, unsigned int cDomains)
{
    CPoolMsgRef *pcpmsgref = NULL;
    DWORD   dwAllocationFlags = MSGREF_CPOOL_SIG;
    if (fIsStandardSize(cDomains))
    {
        dwAllocationFlags |= MSGREF_STANDARD_SIZE;
        //if our expected standard size... then use cpool allocator
        pcpmsgref = (CPoolMsgRef *) s_MsgRefPool.Alloc();
        if (pcpmsgref)
        {
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &g_cDbgMsgRefsCpoolAllocated));
            dwAllocationFlags |= MSGREF_CPOOL_ALLOCATED;
        }
        else
        {
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &g_cDbgMsgRefsCpoolFailed));
        }
    }

    if (!pcpmsgref)
    {
        //
        //  Sanity check size.  If cDomains is ~-1 size() will wrap.
        //  This will firewall us against corrupt messages.
        //
        if (size(cDomains) >= cDomains)
        {
            pcpmsgref = (CPoolMsgRef *) pvMalloc(sizeof(CPoolMsgRef) - sizeof(CMsgRef) + size(cDomains));
            if (pcpmsgref)
            {
                DEBUG_DO_IT(InterlockedIncrement((PLONG) &g_cDbgMsgRefsExchmemAllocated));
            }
        }
    }

    if (pcpmsgref)
    {
        pcpmsgref->m_dwAllocationFlags = dwAllocationFlags;
        return ((void *) &(pcpmsgref->m_msgref));
    }
    else
    {
        return NULL;
    }
}


//---[ CMsgRef::CMsgRef ]------------------------------------------------------
//
//
//  Description:
//      Constructor for CMsgRef
//  Parameters:
//      cDomains    the number of domains this msg is being delivered to
//      pimsg       ptr to the imsg object for this message
//  Returns:
//
//
//-----------------------------------------------------------------------------
CMsgRef::CMsgRef(DWORD cDomains, IMailMsgQueueMgmt *pIMailMsgQM,
                 IMailMsgProperties *pIMailMsgProperties,
                 CAQSvrInst *paqinst, DWORD dwMessageType, GUID guidRouter)
                 : m_aqmtMessageType(guidRouter, dwMessageType)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::CMsgRef");
    _ASSERT(pIMailMsgQM);
    _ASSERT(pIMailMsgProperties);
    _ASSERT(paqinst);

    pIMailMsgQM->AddRef();
    pIMailMsgProperties->AddRef();
    paqinst->AddRef();

    m_dwSignature       = MSGREF_SIG;
    m_dwDataFlags       = MSGREF_VERSION;
    m_cDomains          = cDomains;
    m_pIMailMsgQM       = pIMailMsgQM;
    m_pIMailMsgProperties = pIMailMsgProperties;
    m_pIMailMsgRecipients = NULL;
    m_paqinst           = paqinst;
    m_pmgle             = NULL;
    m_cbMsgSize         = 0; //initialize from IMsg
    m_dwMsgIdHash       = dwQueueAdminHash(NULL);
    m_cTimesRetried     = 0;
    m_cInternalUsageCount = 1;  //Initialize to 1 like the mailmsg usage count

    //initialize stuff that is past traditional end of object
    ZeroMemory(m_rgpdmqDomains, (size(cDomains)+sizeof(CDestMsgQueue *)-sizeof(CMsgRef)));
    TraceFunctLeave();
}

//---[ CMsgRef::~CMsgRef ]------------------------------------------------------------
//
//
//  Description:
//      CMsgRef Destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CMsgRef::~CMsgRef()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::~CMsgRef");
    HRESULT hr = S_OK;
    DWORD i = 0;

    _ASSERT(m_paqinst);

    _ASSERT(!(MSGREF_USAGE_COUNT_IN_USE & m_dwDataFlags));  //this should never remain set

    //There should be corresponding calls to AddUsage/ReleaseUsage
    _ASSERT(m_cInternalUsageCount == 1);

    //Release MsgGuidListEntry if we have one
    if (m_pmgle)
    {
        m_pmgle->RemoveFromList();
        m_pmgle->Release();
    }

    ReleaseMailMsg(TRUE);  //Force commit/delete/release of associated mailmsg

    //Update count of messages that have had ::Delete called on them
    //but not been released.
    if ((MSGREF_MAILMSG_DELETE_PENDING & m_dwDataFlags) &&
        (MSGREF_MAILMSG_DELETED & m_dwDataFlags))
    {
        InterlockedDecrement((PLONG) &s_cCurrentMsgsDeletedNotReleased);
    }
    //Release references to DestMsgQueues
    for (i = 0; i < m_cDomains; i++)
    {
        if (m_rgpdmqDomains[i])
        {
            m_rgpdmqDomains[i]->Release();
            m_rgpdmqDomains[i] = NULL;
        }
    }

    m_paqinst->Release();
    TraceFunctLeave();
}


//---[ CMsgRef::ReleaseMailMsg ]-----------------------------------------------
//
//
//  Description:
//      Release this objects mailmsg... do the necessary commit/delete
//  Parameters:
//      fForceRelease       TRUE mailmsg must be released (used by desctructor)
//                          FALSE release mailmsg if shutdown is happening
//  Returns:
//      -
//  History:
//      7/7/99 - MikeSwa Created
//      10/8/99 - MikeSwa Fixed problem when SpinLock fials
//
//-----------------------------------------------------------------------------
void CMsgRef::ReleaseMailMsg(BOOL fForceRelease)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::ReleaseMailMsg");
    HRESULT hr = S_OK;

    if (!fForceRelease && !m_paqinst->fShutdownSignaled())
        return; //we'll let the actual release handle this case

    //Make sure no one is trying to bounce usage
    if (!fTrySpinLock(&m_dwDataFlags, MSGREF_USAGE_COUNT_IN_USE))
    {
        //Someone is... this should not happen on the final release
        DebugTrace((LPARAM) this, "Someone else using mailmsg... bailing");
        _ASSERT(!fForceRelease);
        return;
    }

    if (MSGREF_MAILMSG_RELEASED &
        dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MAILMSG_RELEASED))
    {
        //Someone else has already come along and done this
        ReleaseSpinLock(&m_dwDataFlags, MSGREF_USAGE_COUNT_IN_USE);
        return;
    }

    if (NULL != m_pIMailMsgQM)
    {
        if ((m_dwDataFlags & MSGREF_SUPERSEDED) ||
            pmbmapGetHandled()->FAllSet(m_cDomains))
        {
            //The message has been handled (or superseded)... we can delete it
            ThreadSafeMailMsgDelete();
        }

        //Releasing the message will commit it if dirty (and not-deleted)
        m_pIMailMsgQM->Release();
        m_pIMailMsgQM = NULL;

        m_paqinst->DecMsgsInSystem(
                m_dwDataFlags & MSGREF_MSG_REMOTE_RETRY,
                m_dwDataFlags & MSGREF_MSG_COUNTED_AS_REMOTE,
                m_dwDataFlags & MSGREF_MSG_LOCAL_RETRY);
    }

    if (m_dwDataFlags & MSGREF_MSG_RETRY_ON_DELETE)
    {
        //Retry msg
        DEBUG_DO_IT(InterlockedDecrement((PLONG) &g_cDbgMsgRefsPendingRetryOnDelete));
        m_paqinst->HandleAQFailure(AQ_FAILURE_MSGREF_RETRY,
                    E_FAIL, m_pIMailMsgProperties);
    }

    if (NULL != m_pIMailMsgProperties)
    {
        m_pIMailMsgProperties->Release();
        m_pIMailMsgProperties = NULL;
    }

    if (NULL != m_pIMailMsgRecipients)
    {
        m_pIMailMsgRecipients->Release();
        m_pIMailMsgRecipients = NULL;
    }

    ReleaseSpinLock(&m_dwDataFlags, MSGREF_USAGE_COUNT_IN_USE);
    TraceFunctLeave();
}

//---[ CMsgRef::HrInitialize() ]-----------------------------------------------
//
//
//  Description:
//      Perform initialization for the msgref object.  Queries the DMT for
//      queues for each of the domains that this message is being sent to.
//
//      Can be called multiple times if needed (e.g., if the DMT version
//      changes before the messages are queued).
//  Parameters:
//      IN     paqinst      Ptr to CMQ object
//      IN     pIRecipList  interface for recipients of msg
//      IN     pIMessageRouter Router for this message
//      IN     dwMessageType Msg Type for message
//      OUT    pcLocalRecips - # of local recipients
//      OUT    pcRemoteRecips - # of remote recipients
//      OUT    pcQueues     # of queues for this message
//      IN OUT rgdmqQueues  Array of queue ptrs
//          Allocated by calling routine (to ease memory management)
//          must be at least cDomains long
//
//  Returns:
//      S_OK on success
//      E_INVALIDARG if the data we need is not preset
//      AQUEUE_E_INVALID_MSG_ID if the message id is too long??
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrInitialize(IN  IMailMsgRecipients *pIRecipList,
                              IN  IMessageRouter *pIMessageRouter,
                              IN  DWORD dwMessageType,
                              OUT DWORD *pcLocalRecips,
                              OUT DWORD *pcRemoteRecips,
                              OUT DWORD *pcQueues,
                              IN  OUT CDestMsgQueue **rgpdmqQueues)
{
    const DWORD     IMSG_MAX_DOMAIN_LEN = 512;
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrInitialize");
    HRESULT         hr  = S_OK;
    CDomainMapping  dmap;  //value returned by DMT
    CDestMsgQueue  *pdmq = NULL;   //ptr to queue returned by DMT
    DWORD           i;           //tmp counter
    BOOL            fUsed = FALSE;
    BOOL            fLocked = FALSE;  //has the aqinst been locked?
    char            szCurrentDomain[IMSG_MAX_DOMAIN_LEN +1];  //Current Domain name
    DWORD           iCurrentLowRecip = 0;  //current low recip index
    DWORD           cCurrentRecipCount = 0; //current recipient count
    DWORD           cQueues = 0;
    DWORD           cCachedIMsgHandles = 0;

    _ASSERT(m_paqinst);
    _ASSERT(pcQueues);
    _ASSERT(rgpdmqQueues);
    _ASSERT(m_pIMailMsgQM);
    _ASSERT(m_pIMailMsgProperties);
    _ASSERT(pIMessageRouter);
    _ASSERT(pcLocalRecips);
    _ASSERT(pcRemoteRecips);
    _ASSERT(pIRecipList);

    *pcLocalRecips = 0;
    *pcRemoteRecips = 0;

    pIRecipList->AddRef();

    //If being called for a 2nd time... release old info
    //even though it might be the same... we don't want to leak
    if (m_pIMailMsgRecipients)
        m_pIMailMsgRecipients->Release();

    m_pIMailMsgRecipients = pIRecipList;

    //Reset Message type in case it was updated
    m_aqmtMessageType.SetMessageType(dwMessageType);

    if (!m_paqinst->fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    if (!(MSGREF_MSG_INIT & m_dwDataFlags))
    {
        hr = HrOneTimeInit();
        if (FAILED(hr))
            goto Exit;
    }

    for (i = 0; i < m_cDomains; i++)
    {
        //$$REVIEW: When to we need to check and make sure that it is a
        //  properly formatted Domain Name... currently X400 will work too!!

        hr = pIRecipList->DomainItem(i, IMSG_MAX_DOMAIN_LEN +1, szCurrentDomain,
                &iCurrentLowRecip, &cCurrentRecipCount);
        if (FAILED(hr))
            goto Exit;

        //
        // This is a quick fix for Milestone 2 so that we can send
        // mail to external X400 addresses.  Their szCurrentDomain
        // will be empty string.  Substitute that with " " which is
        // added as a local domain
        //
        if(*szCurrentDomain == '\0') {
            //
            // jstamerj 1998/07/24 12:24:48:
            //   We can't handle an empty string, so translate this to " "
            //
            szCurrentDomain[0] = ' ';
            szCurrentDomain[1] = '\0';
        }

        if (fAllRecipsInRangeHandled(pIRecipList, iCurrentLowRecip, cCurrentRecipCount))
        {
            //All recipients for this domain have been handled, we do not need to
            //queue it up for delivery.  Typical reasons for this are:
            // - address that have been rejected by cat, but there are valid
            //   local recips
            // - On restart if some recipients for a message still have not been
            //   delivered
            pmbmapGetHandled()->HrMarkBits(m_cDomains, 1, &i, TRUE);
            if (FAILED(hr))
                ErrorTrace((LPARAM) this, "HrMarkBits returned hr 0x%08X", hr);

            pdmq = NULL;
        }
        else
        {
            hr = m_paqinst->pdmtGetDMT()->HrMapDomainName(szCurrentDomain, &m_aqmtMessageType,
                                        pIMessageRouter, &dmap, &pdmq);
            if (FAILED(hr))
            {
                if (PHATQ_BAD_DOMAIN_SYNTAX == hr)
                {
                    //The domain name is malformed... we should not attempt delivery
                    //for this domain, but  should deliver rest of message
                    _VERIFY_RECIPS_HANDLED(pIRecipList, iCurrentLowRecip, cCurrentRecipCount);

                    ErrorTrace((LPARAM) this,
                        "Encountered invalid domain %s", szCurrentDomain);

                    //Set this domain as handled
                    pmbmapGetHandled()->HrMarkBits(m_cDomains, 1, &i, TRUE);
                    if (FAILED(hr))
                        ErrorTrace((LPARAM) this, "HrMarkBits returned hr 0x%08X", hr);
                }
                else
                    goto Exit;
            }
        }

        //HrInitialize is being called a 2nd time... release old queues so we don't leak
        if (m_rgpdmqDomains[i])
            m_rgpdmqDomains[i]->Release();

        m_rgpdmqDomains[i] = pdmq;

        //keep track of local/remote recip counts
        if (pdmq)
            *pcRemoteRecips += cCurrentRecipCount;
        else
            *pcLocalRecips += cCurrentRecipCount;

        _ASSERT(cCurrentRecipCount);

        _VERIFY_QUEUE_PTR(m_paqinst, szCurrentDomain, pdmq, cQueues, rgpdmqQueues);

        rgpdmqQueues[cQueues] = pdmq;    //save new ptr
        SetRecipIndex(cQueues, iCurrentLowRecip, cCurrentRecipCount + iCurrentLowRecip -1);
        cQueues++;

        //set bit in bitmap
        hr = pmbmapGetDomainBitmap(i)->HrMarkBits(m_cDomains, 1, &i, TRUE);
        _ASSERT(SUCCEEDED(hr) && "Bitmap code failed");

    }

    *pcQueues = cQueues;
  Exit:

    if (FAILED(hr))
    {
        //Release references to DestMsgQueues
        for (i = 0; i < m_cDomains; i++)
        {
            if (m_rgpdmqDomains[i])
            {
                m_rgpdmqDomains[i]->Release();
                m_rgpdmqDomains[i] = NULL;
            }
        }
    }

    if (fLocked)
    {
        m_paqinst->ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::HrOneTimeInit ]------------------------------------------------
//
//
//  Description:
//      Perform 1-time message initialization (HrInitialize can be called
//      multiple times... this function encapuslates that things that only
//      need to be done once).
//
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//  History:
//      10/12/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrOneTimeInit()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrOneTimeInit");
    HRESULT hr = S_OK;
    DWORD   cbProp = 0;
    GUID    guidID = GUID_NULL;
    GUID    *pguidID = NULL;
    GUID    guidSupersedes;
    GUID    *pguidSupersedes = NULL;
    BOOL    fFoundMsgID = FALSE;
    CHAR    szBuffer[300];


    _ASSERT(!(MSGREF_MSG_INIT & m_dwDataFlags));

    //get data we want from the IMsg
    //The info we want to include follows
    //  -Time IMsg entered the system (creation time)
    //  -Message Priority
    //  -Message Size
    //  -Supersedeable message ID
    //  -Hash of Message ID

    szBuffer[(sizeof(szBuffer)-1)/sizeof(CHAR)] = '\0';
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_MSG_ID,
                                sizeof(szBuffer), &cbProp,(BYTE *) szBuffer);
    //$$REVIEW - do we care about MsgID's bigger than 300 bytes
    if (SUCCEEDED(hr))
        fFoundMsgID = TRUE;

    //Don't pass on error
    hr = S_OK;

    //Get Hash of message ID.
    if (fFoundMsgID)
        m_dwMsgIdHash = dwQueueAdminHash(szBuffer);

    if (!m_pmgle)
    {
        //Although, we know that this function has not successfully
        //completed... it is possible that it failed, so we check
        //to make sure we don't leak a m_pmgle
        hr = m_pIMailMsgProperties->GetStringA(IMMPID_MP_MSG_GUID,
                sizeof(szBuffer), szBuffer);
        if (SUCCEEDED(hr))
        {
            //Try to parse GUID from the string
            if (fAQParseGuidString(szBuffer, sizeof(szBuffer), &guidID))
            {
                pguidID = &guidID;

                hr = m_pIMailMsgProperties->GetStringA(IMMPID_MP_SUPERSEDES_MSG_GUID,
                    sizeof(szBuffer), szBuffer);
                if (SUCCEEDED(hr))
                {
                    if (fAQParseGuidString(szBuffer, sizeof(szBuffer),
                                            &guidSupersedes))
                    {
                        pguidSupersedes = &guidSupersedes;
                    }
                }
            }
        }


        //If this message has a GUID... add it to the superseded this
        if (pguidID)
        {
            _ASSERT(m_paqinst);
            m_pmgle = m_paqinst->pmglGetMsgGuidList()->pmgleAddMsgGuid(this,
                                pguidID, pguidSupersedes);

            //We don't care about the return results... if the allocation
            //fails, then we just treat it as if it did not have an ID.
        }
    }

    //Get time message was queued
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_ARRIVAL_FILETIME,
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftQueueEntry);
    if (FAILED(hr))
    {
        //Message should not make it this far without being stamped with
        _ASSERT(MAILMSG_E_PROPNOTFOUND != hr);
        goto Exit;
    }

    //Get Various expire times
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_DELAY,
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftLocalExpireDelay);
    if (hr == MAILMSG_E_PROPNOTFOUND)
    {
        // If this is not set, zero it so it will be calculated on demand
        memset(&m_ftLocalExpireDelay, 0, sizeof(FILETIME));
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_NDR,
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftLocalExpireNDR);
    if (hr == MAILMSG_E_PROPNOTFOUND)
    {
        // If this is not set, zero it so it will be calculated on demand
        memset(&m_ftLocalExpireNDR, 0, sizeof(FILETIME));
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_EXPIRE_DELAY,
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftRemoteExpireDelay);
    if (hr == MAILMSG_E_PROPNOTFOUND)
    {
        // If this is not set, zero it so it will be calculated on demand
        memset(&m_ftRemoteExpireDelay, 0, sizeof(FILETIME));
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_EXPIRE_NDR,
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftRemoteExpireNDR);
    if (hr == MAILMSG_E_PROPNOTFOUND)
    {
        // If this is not set, zero it so it will be calculated on demand
        memset(&m_ftRemoteExpireNDR, 0, sizeof(FILETIME));
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

    //Get the size of the message
    hr = HrQADMGetMsgSize(m_pIMailMsgProperties, &m_cbMsgSize);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "Failed to Get Message Size 0x%08X", hr);

        hr = S_OK; //This really is not a fatal error
    }

    //$$TODO: Map to effective routing priority - just use Normal now
    m_dwDataFlags |= (eEffPriNormal & MSGREF_PRI_MASK);

    m_dwDataFlags |= MSGREF_MSG_INIT;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::HrPrepareDelivery ]--------------------------------------------
//
//
//  Description:
//      Prepares a msgreference for delivery on the given list of queues.
//
//      Caller is NOT responsible for freeing prgdwRecips,
//      This should automatically be freed with the message context.
//
//      If this function succeeds, then a usage count will have been added
//      to this mailmsg.  The caller is responsible for calling AckMessage
//      (which releases the usage count) or calling ReleaseUsage explicitly.
//  Parameters:
//      IN BOOL fLocal  Prepare delivery for all domains with NULL queues
//      IN BOOL fDelayDSN - Check/Set Delay bitmap (only send 1 Delay DSN).
//      IN CQuickList *pqlstQueues   array of DMQ's
//      IN CDestMsgRetryQueue *pmdrq - Retry interface for this delivery attempt
//          Will be NULL for local delivery, becasue we will never requeue a local
//          message to its original DMQ.
//      IN OUT CDeliveryContext *pdcntxt context that must be returned on Ack
//      OUT DWORD       *pcRecips      # of recips to deliver for
//      OUT CMsgBitMap **prgdwRecips  Array of recipient indexes
//  Returns:
//      S_OK on success
//      AQUEUE_E_MESSAGE_HANDLED if the message has already been handled
//      AQUEUE_E_MESSAGE_PENDING if all the the requested recipients are
//              either handled or currently pending delivery for another thread
//      E_FAIL if any of the M1 requirements are not met
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrPrepareDelivery(IN BOOL fLocal, IN BOOL fDelayDSN,
                                   IN CQuickList *pqlstQueues,
                                   IN CDestMsgRetryQueue* pdmrq,
                                   OUT CDeliveryContext *pdcntxt,
                                   OUT DWORD *pcRecips, OUT DWORD **prgdwRecips)

{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrPrepareDelivery");

    //assert IN parameters
    _ASSERT(fLocal || pqlstQueues);

    //assert OUT parameters
    _ASSERT(pdcntxt);
    _ASSERT(prgdwRecips);
    _ASSERT(pcRecips);

    //assume average of 4 recips per domain for return list
    const DWORD RECIPIENT_PREALLOCATION_FACTOR = 4;  //we may need to tweak this.
    HRESULT     hr              = S_OK;
    CMsgBitMap *pmbmapTmp       = NULL;
    CMsgBitMap *pmbmapCurrent   = NULL;
    DWORD       i,j,k           = 0;    //loop variables
    DWORD       *pdwRecipBuffer = NULL; //The buffer for recipient indexes
    DWORD       iCurrentIndex   = 0;    //Current index into the buffer
    DWORD       cdwRecipBuffer  = 0;    //current size of recipient buffer (in DWORDS)
    DWORD       iRecipLow       = 0;    //Recipient index limits
    DWORD       iRecipHigh      = 0;
    CDestMsgQueue *pdmq         = NULL;
    PVOID       pvContext       = NULL;
    DWORD       cDest           = pqlstQueues ? pqlstQueues->dwGetCount() : 0;
    DWORD       dwStartDomain   = 0;
    DWORD       dwLastDomain    = 0;
    BOOL        fAddedUsage     = FALSE;
    BOOL        fRecipsPending  = FALSE;

    _ASSERT((fLocal || cDest) && "We must deliver somewhere");
    _ASSERT(m_pIMailMsgRecipients);

    //check if msg has been superseded
    if (m_dwDataFlags & MSGREF_SUPERSEDED)
    {
        hr = AQUEUE_E_MESSAGE_HANDLED;
        goto Exit;
    }

    //Pre-allocate recipient buffer.  It would be very interesting to determine
    //the best way to do this.  It might involve tuning the default factor, or
    //using CPOOL to allocate the 90% case.
    cdwRecipBuffer = cDest * RECIPIENT_PREALLOCATION_FACTOR;
    pdwRecipBuffer = (DWORD *) pvMalloc(cdwRecipBuffer * sizeof(DWORD));
    if (NULL == pdwRecipBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //HOW IT WORKS:
    //  Here are the steps used to prepare a msgref for delivery
    //  1-Determine which domains it needs to be delivered for on this queue
    //  2-Filter out any domains that have already been handled
    //  3-Mark the domains as pending (and make sure we aren't delivering
    //      to domains that are pending).
    //  The above accomplished by using logical operations on bitmap objects

    pmbmapTmp = new(m_cDomains) CMsgBitMap(m_cDomains);
    if (NULL == pmbmapTmp)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (cDest == 0)
    {
        //make sure local makes it through the loop once
        _ASSERT(fLocal);
        cDest = 1;
    }

    //Use group operation to group together like domains
    //Both lists of domain mappings must be strictly sorted
    for (i = 0; i < m_cDomains; i++)
    {
        for (j = 0; j < cDest; j++)
        {
            //$$NOTE: Currently this nested loop is O(n^2)
            if (pqlstQueues)
            {
                pdmq = (CDestMsgQueue *) pqlstQueues->pvGetItem(j, &pvContext);

                if(pdmq)
                    pdmq->AssertSignature();
                else
                    _ASSERT(fLocal);
            }

            if ((m_rgpdmqDomains[i] == pdmq) ||
                (fLocal && !m_rgpdmqDomains[i]))
            {
                pmbmapCurrent = pmbmapGetDomainBitmap(i);

                //The order of the following 5 bitmap operations is important
                //to ensure that 2 threads do not get the same recipients
                //The ACK performs the following similar operations:
                //  - Sets handled bits
                //  - Unsets pending bits

                //Check against handled
                if (pmbmapGetHandled()->FTest(m_cDomains, pmbmapCurrent))
                    continue;

                //Check against DSN
                if (fDelayDSN && pmbmapGetDSN()->FTest(m_cDomains,pmbmapCurrent))
                    continue;

                //Check (and set) against pending
                if (!pmbmapGetPending()->FTestAndSet(m_cDomains, pmbmapCurrent))
                {
                    fRecipsPending = TRUE;
                    continue;
                }

                // Recheck against handled.  If we remove this re-check, then
                // there is a possibility that a thread will come along
                // check handle, another thread will ack (setting handled
                // and unsetting pending), then the first thread comes
                // along and sets pending thereby defeating our locking
                // mechanism.
                if (pmbmapGetHandled()->FTest(m_cDomains, pmbmapCurrent))
                {
                    //We need to unset the pending bit we just set
                    hr = pmbmapCurrent->HrFilterUnset(m_cDomains, pmbmapGetPending());
                    DebugTrace((LPARAM) this,
                        "Backout pending bits in PrepareForDelivery - hr", hr);

                    //This will succeed unless another thread has munged the
                    //bitmap
                    _ASSERT(SUCCEEDED(hr));

                    hr = S_OK; //caller can do nothing about this
                    continue;
                }

                //Check (and set) against DSN
                if (fDelayDSN)
                {
                    //This should not be able to happen, since another thread
                    //must have come along and sent pending to get this far
                    _VERIFY(pmbmapGetDSN()->FTestAndSet(m_cDomains,pmbmapCurrent));
                }

                //Everything checks out... we can deliver to this domain
                hr = pmbmapTmp->HrGroupOr(m_cDomains, 1, &pmbmapCurrent);
                if (FAILED(hr))
                   goto Exit;

                //Create list of recipients.
                GetRecipIndex(i, &iRecipLow, &iRecipHigh);  //get the limits
                //make sure we have enough room to do this
                if ((iCurrentIndex + (iRecipHigh - iRecipLow) + 1) >= cdwRecipBuffer)
                {
                    DWORD       *pdwTemp = NULL; // Temp ptr for realloc

                    //reallocate generously (enough for now + our estimate for future)
                    cdwRecipBuffer += (iRecipHigh - iRecipLow) + 1
                                   + RECIPIENT_PREALLOCATION_FACTOR* (cDest-(j+1));
                    pdwTemp = (DWORD *) pvRealloc((void *) pdwRecipBuffer,
                                                    cdwRecipBuffer*sizeof(DWORD));
                    if (!pdwTemp)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    // Allocation succeeded, set the ptr.
                    pdwRecipBuffer = pdwTemp;
                }

                //Make sure we have the usage count to call SetNextDomain
                if (!fAddedUsage)
                {
                    hr = InternalAddUsage();
                    if (FAILED(hr))
                        goto Exit;

                    fAddedUsage = TRUE;
                }

                //Check to see if this message is marked for deletion
                if (fMailMsgMarkedForDeletion())
                {
                    hr = AQUEUE_E_MESSAGE_HANDLED;
                    goto Exit;
                }

                if (!iCurrentIndex) //first domain
                {
                    dwStartDomain = i;
                }
                else
                {
                    hr = m_pIMailMsgRecipients->SetNextDomain(dwLastDomain, i,
                        FLAG_OVERWRITE_EXISTING_LINKS);
                    if (FAILED(hr))
                    {
                        ErrorTrace((LPARAM) this, "ERROR: SetNextDomain Failed - hr 0x%08X", hr);
                        goto Exit;
                    }
                }

                //save last valid domain
                dwLastDomain = i;

                DebugTrace((LPARAM) this, "INFO: Sending recipients %d thru %d for domain %d:%d", iRecipLow, iRecipHigh, j, i);
                for (k = iRecipLow; k <= iRecipHigh; k++)
                {
                    pdwRecipBuffer[iCurrentIndex] = k;
                    iCurrentIndex++;
                }

                _ASSERT(iCurrentIndex <= cdwRecipBuffer);
            }
        }
    }


    if (pmbmapTmp->FAllClear(m_cDomains))
    {
        //there is nothing to do for this message
        if (fRecipsPending)
            hr = AQUEUE_E_MESSAGE_PENDING;
        else
            hr = AQUEUE_E_MESSAGE_HANDLED;
        goto Exit;
    }

    _ASSERT(fAddedUsage);
    if (dwStartDomain == dwLastDomain)
    {
        //There is only 1 domain... we never called SetNextDomain.. we need to
        //overwrite any previous domain link information
        hr = m_pIMailMsgRecipients->SetNextDomain(dwStartDomain, dwStartDomain,
                                                FLAG_SET_FIRST_DOMAIN);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: SetNextDomain for first domain Failed - hr 0x%08X", hr);
            goto Exit;
        }
    }

    //Initialize delivery context
    pdcntxt->Init(this, pmbmapTmp, iCurrentIndex, pdwRecipBuffer, dwStartDomain, pdmrq);

    //Write other OUT parameters
    *pcRecips = iCurrentIndex;
    *prgdwRecips = pdwRecipBuffer;

    //set pointers to NULL so we don't delete them
    pdwRecipBuffer = NULL;
    pmbmapTmp = NULL;

Exit:

    if (FAILED(hr) && pmbmapTmp && !pmbmapTmp->FAllClear(m_cDomains))
    {
        //We need to unset the DNS and pending bits we have set
        pmbmapTmp->HrFilterUnset(m_cDomains, pmbmapGetPending());

        if (fDelayDSN)
            pmbmapTmp->HrFilterUnset(m_cDomains, pmbmapGetDSN());

    }

    if (pmbmapTmp)
        delete pmbmapTmp;

    if (pdwRecipBuffer)
        FreePv(pdwRecipBuffer);

    //Make sure we don't leave an extra usage count on failure
    if (fAddedUsage && FAILED(hr))
        InternalReleaseUsage();

    TraceFunctLeave();
    return hr;
}


//---[ CMsgRef::HrAckMessage ]-------------------------------------------------
//
//
//  Description:
//      Acknowledges (un)delivery attempts for a message.  Will look at the
//      IMsg and determine which queues the msgref needs to be requeued to.
//  Parameters:
//      IN pdcntxt      Delivery context of message
//      IN pMsgAck      Delivery status of message
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrAckMessage(IN CDeliveryContext *pdcntxt,
                              IN MessageAck *pMsgAck)

{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrAckMessage");
    _ASSERT(pdcntxt);
    _ASSERT(pdcntxt->m_pmbmap);
    _ASSERT(pMsgAck);

    HRESULT     hr          = S_OK;
    CDSNParams  dsnparams;
    dsnparams.dwStartDomain = pdcntxt->m_dwStartDomain;

    //Do we need to send DSN's?
    if (MESSAGE_STATUS_CHECK_RECIPS & pMsgAck->dwMsgStatus)
    {
        //recipients need to be handled by the DSN code
        dsnparams.dwDSNActions = DSN_ACTION_FAILURE;

        //we may need to send relay DSN's as well
        dsnparams.dwDSNActions |= DSN_ACTION_RELAYED;

        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;

        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;
    }
    else if (((MESSAGE_STATUS_DROP_DIRECTORY |
               MESSAGE_STATUS_LOCAL_DELIVERY)
              & pMsgAck->dwMsgStatus) &&
             !(MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus))
    {
        //This was a successful local (or drop) delivery
        //  - NDR all undelivered
        //  - Generate any success DSNs if necessary
        dsnparams.dwDSNActions = DSN_ACTION_FAILURE_ALL |
                                 DSN_ACTION_DELIVERED |
                                 DSN_ACTION_RELAYED;
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;

        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;
    }
    else if (MESSAGE_STATUS_NDR_ALL & pMsgAck->dwMsgStatus)
    {
        //
        //  NDR all undelivered recipients
        //

        //
        //  Use specific extended status codes if there is no
        //  detailed per-recipient information
        //
        hr = HrPromoteMessageStatusToMailMsg(pdcntxt, pMsgAck);
        if (FAILED(hr))
        {
            //
            //  This is a non-fatal error, we should still attempt
            //  DSN generation... otherwise the sender will get
            //  no indication of the failure.
            //
            ErrorTrace((LPARAM) this,
                "HrPromoteMessageStatusToMailMsg failed with 0x%08X", hr);
            hr = S_OK;
        }

        dsnparams.dwDSNActions = DSN_ACTION_FAILURE_ALL;
        if (MESSAGE_STATUS_DSN_NOT_SUPPORTED & pMsgAck->dwMsgStatus)
            dsnparams.dwDSNActions |= DSN_ACTION_RELAYED;

        dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;

        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;

    }
    else if (((MESSAGE_STATUS_DROP_DIRECTORY |
               MESSAGE_STATUS_LOCAL_DELIVERY)
              & pMsgAck->dwMsgStatus) &&
             (MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus))
    {
        //This was a retryable local (or drop) delivery failure
        //  - NDR all hard failures
        //  - Generate any success DSNs if necessary
        dsnparams.dwDSNActions = DSN_ACTION_FAILURE |
                                 DSN_ACTION_DELIVERED |
                                 DSN_ACTION_RELAYED;
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;
        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;
    }

    //See if we also need to retry this message
    if (MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus)
    {
        _ASSERT(!((MESSAGE_STATUS_ALL_DELIVERED | MESSAGE_STATUS_NDR_ALL) & pMsgAck->dwMsgStatus));
        hr = HrPrvRetryMessage(pdcntxt, pMsgAck->dwMsgStatus);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        //If retry is not specifically requested, we set the handled bits
        hr = pdcntxt->m_pmbmap->HrFilterSet(m_cDomains, pmbmapGetHandled());
        if (FAILED(hr))
            goto Exit;

        //If this message has a supersedable ID... remove it from list if
        //we are done
        if (m_pmgle && pmbmapGetHandled()->FAllSet(m_cDomains))
        {
            m_pmgle->RemoveFromList();
        }
        //There should be something that was not set in the handled bitmap
        _ASSERT(! pdcntxt->m_pmbmap->FAllClear(m_cDomains));
    }


    //Unset Pending bitmap
    hr = pdcntxt->m_pmbmap->HrFilterUnset(m_cDomains, pmbmapGetPending());
    if (FAILED(hr))
        goto Exit;

  Exit:

    ReleaseAndBounceUsageOnMsgAck(pMsgAck->dwMsgStatus);

    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::HrSendDelayOrNDR ]---------------------------------------------
//
//
//  Description:
//      Determines if a message has expired (for Delay or NDR) and generates
//      a DSN if neccessary.
//  Parameters:
//      IN  dwDSNOptions Flags describing DSN generation
//          MSGREF_DSN_LOCAL_QUEUE      This is for a local queue
//          MSGREF_DSN_SEND_DELAY       Allow Delay DSNs
//          MSGREF_DSN_HAS_ROUTING_LOCK This thread holds the routing lock
//      IN  pqlstQueues List of DestMsgQueues to DSN
//      IN  hrStatus    Status to Pass to DSN generation
//                      (if Status is AQUEUE_E_NDR_ALL... then message will
//                      be NDR'd regardless of timeout).
//      OUT pdwDSNFlags Reports disposition of message
//          MSGREF_DSN_SENT_NDR     Message NDR-expired and NDR was sent
//          MSGREF_DSN_SENT_DELAY   Message Delay-expired and Delay DSN was sent
//          MSGREF_HANDLED          Message has been completely handled
//          MSGREF_HAS_NOT_EXPIRED  Message younger than it's exipiration dates
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//  History:
//      7/13/98 - MikeSwa Created
//      8/14/98 - MikeSwa Modified to add support for local expire
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrSendDelayOrNDR(
                IN  DWORD dwDSNOptions,
                IN  CQuickList *pqlstQueues,
                IN  HRESULT hrStatus,
                OUT DWORD *pdwDSNFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrSendDelayOrNDR");
    HRESULT hr = S_OK;
    BOOL        fSendDSN    = FALSE;
    BOOL        fSendNDR    = FALSE;
    DWORD       dwTimeContext = 0;
    DWORD       dwFlags = 0;
    FILETIME    ftExpireTime;
    CDSNParams  dsnparams;
    CDeliveryContext dcntxt;
    BOOL        fPendingSet = FALSE;  //pending bitmap has been set
    BOOL        fReleaseUsageNeeded = FALSE; //has an extra usage count been added by Prepare Delivery?
    BOOL        fShouldRetryMsg = TRUE;

    //any allocations done in PrepareDelivery will be freed by ~CDeliveryContext
    DWORD       cRecips = 0;
    DWORD       *rgdwRecips = NULL;


    _ASSERT(pdwDSNFlags);
    _ASSERT(MSGREF_SIG == m_dwSignature);

    *pdwDSNFlags = 0;

    //Shutdown lock should already be aquired... but lets make sure that the
    //service shutdown thread is not waiting for it.
    if (!m_paqinst->fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }
    m_paqinst->ShutdownUnlock();


    //
    //  We need to open up the file and see what is going on.  This will
    //  force a RFC822 rendering of the message content and open
    //  the content file.
    //
    if (dwDSNOptions & MSGREF_DSN_CHECK_IF_STALE)
    {
        //
        //  If we cannot retry the message, it is stale and we shold
        //  drop it.  This will open the handles for a message, but
        //  we will always call BounceUsageCount at the end of this call
        //
        InternalAddUsage();
        fShouldRetryMsg = fShouldRetry();
        InternalReleaseUsage();

        if (!fShouldRetryMsg)
        {
            *pdwDSNFlags = MSGREF_HANDLED;
            goto Exit;
        }
    }

    //if this message has been superseded... remove it from the running
    //Also if the message has already been marked for deletion
    if ((m_dwDataFlags & MSGREF_SUPERSEDED) || fMailMsgMarkedForDeletion())
    {
        *pdwDSNFlags = MSGREF_HANDLED;
        goto Exit;
    }

    //Make sure we check the correct local/remote expire time
    if (MSGREF_DSN_LOCAL_QUEUE & dwDSNOptions)
        memcpy(&ftExpireTime, &m_ftLocalExpireNDR, sizeof(FILETIME));
    else
        memcpy(&ftExpireTime, &m_ftRemoteExpireNDR, sizeof(FILETIME));

    // If this wasn't set we need to calculate it
    if (!((ULARGE_INTEGER*)&ftExpireTime)->QuadPart)
    {
        m_paqinst->CalcExpireTimeNDR(m_ftQueueEntry,
                                     MSGREF_DSN_LOCAL_QUEUE & dwDSNOptions,
                                     &ftExpireTime);
    }

    //
    //  Default to status passed in
    //
    dsnparams.hrStatus = hrStatus;

    if (fIsFatalError(hrStatus))
    {
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        *pdwDSNFlags |= MSGREF_DSN_SENT_NDR;
        fSendDSN = TRUE;
        fSendNDR = TRUE;
        dsnparams.dwDSNActions |= DSN_ACTION_FAILURE_ALL;
    }
    else if (m_paqinst->fInPast(&ftExpireTime, &dwTimeContext))
    {
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        *pdwDSNFlags |= MSGREF_DSN_SENT_NDR;
        fSendDSN = TRUE;
        fSendNDR = TRUE;
        dsnparams.dwDSNActions |= DSN_ACTION_FAILURE_ALL;
        dsnparams.hrStatus = AQUEUE_E_MSG_EXPIRED;
    }
    else if (MSGREF_DSN_SEND_DELAY & dwDSNOptions)
    {
        //NDR is not needed, but perhaps delay is

        //Make sure we check the correct local/remote expire time
        if (MSGREF_DSN_LOCAL_QUEUE & dwDSNOptions)
            memcpy(&ftExpireTime, &m_ftLocalExpireDelay, sizeof(FILETIME));
        else
            memcpy(&ftExpireTime, &m_ftRemoteExpireDelay, sizeof(FILETIME));

        // If this wasn't set we need to calculate it
        if (!((ULARGE_INTEGER*)&ftExpireTime)->QuadPart)
        {
            m_paqinst->CalcExpireTimeDelay(m_ftQueueEntry,
                                        MSGREF_DSN_LOCAL_QUEUE & dwDSNOptions,
                                        &ftExpireTime);
        }

        if (m_paqinst->fInPast(&ftExpireTime, &dwTimeContext))
        {
            SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
            *pdwDSNFlags |= MSGREF_DSN_SENT_DELAY;
            fSendDSN = TRUE;
            dsnparams.dwDSNActions |= DSN_ACTION_DELAYED;
            dsnparams.hrStatus = AQUEUE_E_MSG_EXPIRED;
        }
    }

    if (!fSendDSN)
    {
        //message has not expired for Delay or NDR
        *pdwDSNFlags |= MSGREF_HAS_NOT_EXPIRED;
        goto Exit;
    }

    //Prepare delivery for NDR/DSN's (setting DSN bitmap for delays)
    hr = HrPrepareDelivery(MSGREF_DSN_LOCAL_QUEUE & dwDSNOptions,
                           ((*pdwDSNFlags) & MSGREF_DSN_SENT_DELAY) ? TRUE : FALSE,
                           pqlstQueues, NULL, &dcntxt,
                           &cRecips, &rgdwRecips);

    //make sure we don't delete ourselves when stack context goes away
    dcntxt.m_pmsgref = NULL;

    if (AQUEUE_E_MESSAGE_HANDLED == hr)
    {
        //nothing to do for the message
        //if *not* filtering against Delay...
        //then there are no undelivered recips.  Return this info
        if (!((*pdwDSNFlags) & MSGREF_DSN_SENT_DELAY))
            *pdwDSNFlags = MSGREF_HANDLED;
        else
            *pdwDSNFlags = MSGREF_HAS_NOT_EXPIRED; //delay wasn't actually sent

        hr = S_OK;
        goto Exit;
    }
    else if (AQUEUE_E_MESSAGE_PENDING == hr)
    {
        //This message is currently being processed by other threads
        //It has not been handled (so it should not be removed from the queue),
        //but it is not an error condition
        *pdwDSNFlags = 0;
        hr = S_OK;
        goto Exit;
    }
    else if (FAILED(hr))
    {
        *pdwDSNFlags = 0;

        goto Exit;
    }

    fPendingSet = TRUE; //we will need to unset the pending bitmap
    fReleaseUsageNeeded = TRUE;

    dsnparams.dwStartDomain = dcntxt.m_dwStartDomain;
    dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;
    hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams,
                            MSGREF_DSN_HAS_ROUTING_LOCK & dwDSNOptions);
    if (FAILED(hr))
    {
        *pdwDSNFlags = 0;
        goto Exit;
    }

    if (S_FALSE == hr) //no DSN generated
    {
        if (fSendNDR) //Expire has passed...remove message from queue
            *pdwDSNFlags = MSGREF_HANDLED;
        else
            *pdwDSNFlags = 0;
        hr = S_OK;
        //continue through function... still remove from queue even if NOTIFY=NEVER
    }

    //if NDR was generated, set handled bits
    if (fSendNDR)
    {
        //Set Handled bitmap
        hr = dcntxt.m_pmbmap->HrFilterSet(m_cDomains, pmbmapGetHandled());
        if (FAILED(hr))
            goto Exit;

        //If this message has a supersedable ID... remove it from list if
        //we are done
        if (m_pmgle && pmbmapGetHandled()->FAllSet(m_cDomains))
        {
            m_pmgle->RemoveFromList();
        }

        //There should be something that was not set in the handled bitmap
        _ASSERT(! dcntxt.m_pmbmap->FAllClear(m_cDomains));
    }


  Exit:
    //Unset Pending bitmap
    if (fPendingSet)
    {
        dcntxt.m_pmbmap->HrFilterUnset(m_cDomains, pmbmapGetPending());
    }

    _ASSERT(m_pIMailMsgQM);
    if (fReleaseUsageNeeded)
    {
        //we called HrPrepareDelivery which added an extra usage count
        InternalReleaseUsage();
    }

    //While we are walking queues... bounce usage count - this will conserve handles
    BounceUsageCount();

    TraceFunctLeave();
    return hr;
}

//---[ HrPrvRetryMessage ]-----------------------------------------------------
//
//
//  Description:
//      Queues Message for retry
//  Parameters:
//      pdcntxt     Delivery context set by HrPrepareDelivery
//      dwMsgStatus Status flags passed back with Ack
//  Returns:
//      S_OK on success
//  History:
//      7/13/98 - MikeSwa Created (separated from HrAckMessage())
//      5/25/99 - MikeSwa Modified - Now we requeue only to DMQ that message
//                  was originally dequeued from.  This is for X5:105384, so
//                  that we do not double-count messages that have been
//                  ack'd retry
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrPrvRetryMessage(CDeliveryContext *pdcntxt, DWORD dwMsgStatus)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrPrvRetryMessage");
    _ASSERT(pdcntxt);
    HRESULT hr = S_OK;
    DWORD   i = 0;
    DWORD   j = 0;
    BOOL    fLocked = FALSE;
    BOOL    fLocal = (MESSAGE_STATUS_LOCAL_DELIVERY & dwMsgStatus) ? TRUE : FALSE;
    DWORD   dwNewFlags = fLocal ? MSGREF_MSG_LOCAL_RETRY : MSGREF_MSG_REMOTE_RETRY;
    CDestMsgRetryQueue *pdmrq = NULL;

    //make sure retry flags are set for this message
    DWORD   dwOldFlags = dwInterlockedSetBits(&m_dwDataFlags, dwNewFlags);

    DebugTrace((LPARAM) this, "INFO: Message queued for retry");
    InterlockedIncrement((PLONG) &m_cTimesRetried);

    //update global counters if first retry attempt
    if (!(dwNewFlags & dwOldFlags)) //this is the first time for this type of retry
        m_paqinst->IncRetryCount(fLocal);

    if (fLocal)
        goto Exit;

    //
    //  Check and see if we should even bother requeuing the message.
    //
    if (!fShouldRetry())
    {
        DebugTrace((LPARAM) this, "Message is no longer valid... dropping");

        //
        //  Since we have found a stale message on this queue, we should
        //  tell it to scan on its next DSN generation pass
        //
        pdmrq = pdcntxt->pdmrqGetDMRQ();
        pdmrq->CheckForStaleMsgsNextDSNGenerationPass();
        goto Exit;
    }

    //Requeue Message for remote delivery
    if (m_paqinst->fTryShutdownLock())
    {
        //Don't retry messages if shutdown is happening
        fLocked = TRUE;

        pdmrq = pdcntxt->pdmrqGetDMRQ();
        _ASSERT(pdmrq && "Delivery Context not initialized correctly");

        if (pdmrq)
        {
            hr = pdmrq->HrRetryMsg(this);
            if (FAILED(hr))
                goto Exit;
        }
    }
    else
    {
        hr = S_OK;  //shutdown is happening, not a real failure case
    }

  Exit:
    if (fLocked)
        m_paqinst->ShutdownUnlock();

    TraceFunctLeave();
    return hr;
}
//---[ CMsgRef::pmbmapGetDomainBitmap]-----------------------------------------
//
//
//  Description:
//      Protected method to get the Domain Bitmap for a given domain
//  Parameters:
//      iDomain index to the domain wanted
//  Returns:
//      ptr to the domain bitmap for the given domain
//
//-----------------------------------------------------------------------------
CMsgBitMap *CMsgRef::pmbmapGetDomainBitmap(DWORD iDomain)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::pmbmapGetDomainBitmap");
    CMsgBitMap     *pmbmap = NULL;
    _ASSERT(iDomain < m_cDomains);

    //recall structure of memory, responsibility maps start 3 after end of
    //domain mappings
    pmbmap = (CMsgBitMap *) (m_rgpdmqDomains + m_cDomains);

    pmbmap = (CMsgBitMap *) ((DWORD_PTR) pmbmap + (3+iDomain)*CMsgBitMap::size(m_cDomains));

    TraceFunctLeave();
    return pmbmap;
}

//---[ CMsgRef::pmbmapGetHandled]------------------------------------------------------------
//
//
//  Description:
//      Protected method to get the Handled  Bitmap
//  Parameters:
//      -
//  Returns:
//      ptr to the handled bitmap
//
//-----------------------------------------------------------------------------
CMsgBitMap *CMsgRef::pmbmapGetHandled()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::pmbmapGetHandled");
    CMsgBitMap     *pmbmap = NULL;

    //recall structure of memory, responsibility maps start after end of
    //domain mappings
    pmbmap = (CMsgBitMap *) (m_rgpdmqDomains + m_cDomains);

    TraceFunctLeave();
    return pmbmap;
}

//---[ CMsgRef::pmbmapGetPending]------------------------------------------------------------
//
//
//  Description:
//      Protected method to get the pending Bitmap
//  Parameters:
//      -
//  Returns:
//      ptr to the pending bitmap
//
//-----------------------------------------------------------------------------
CMsgBitMap *CMsgRef::pmbmapGetPending()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::pmbmapGetPending");
    CMsgBitMap     *pmbmap = NULL;

    //recall structure of memory, responsibility maps start 1 after end of
    //domain mappings
    pmbmap = (CMsgBitMap *) (m_rgpdmqDomains + m_cDomains);

    pmbmap = (CMsgBitMap *) ((DWORD_PTR) pmbmap + CMsgBitMap::size(m_cDomains));

    TraceFunctLeave();
    return pmbmap;
}

//---[ CMsgRef::pmbmapGetDSN]------------------------------------------------------------
//
//
//  Description:
//      Protected method to get the Handled Bitmap
//  Parameters:
//      -
//  Returns:
//      ptr to the DSN bitmap
//
//-----------------------------------------------------------------------------
CMsgBitMap *CMsgRef::pmbmapGetDSN()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::pmbmapGetDSN");
    CMsgBitMap     *pmbmap = NULL;

    //recall structure of memory, responsibility maps start 3 after end of
    //domain mappings
    pmbmap = (CMsgBitMap *) (m_rgpdmqDomains + m_cDomains);

    pmbmap = (CMsgBitMap *) ((DWORD_PTR) pmbmap + 2*CMsgBitMap::size(m_cDomains));

    TraceFunctLeave();
    return pmbmap;
}

//---[ CMsgRef::pdwGetRecipIndexStart ]----------------------------------------
//
//
//  Description:
//      Returns the start index of the Array of recipient indexes
//  Parameters:
//      -
//  Returns:
//      See above
//
//-----------------------------------------------------------------------------
DWORD *CMsgRef::pdwGetRecipIndexStart()
{
    DWORD_PTR   dwTmp = 0;
    _ASSERT(m_cDomains);

    //Array of Recipient Indexes start after last CMsgBitmap
    dwTmp = (DWORD_PTR) pmbmapGetDomainBitmap(m_cDomains-1);  //will assert if arg larger
    dwTmp += CMsgBitMap::size(m_cDomains);

    _ASSERT(((DWORD_PTR) this + size(m_cDomains)) > dwTmp);
    _ASSERT(dwTmp);

    return (DWORD *) dwTmp;
}

//---[ CMsgRef::SetRecipIndex ]-----------------------------------------------
//
//
//  Description:
//      Set the starting and stoping recipient index for a given domain. Each
//      Domain in the message has an inclusive range of recipients associated
//      with it.  When the message is prepared for delivery, these ranges are
//      expanded into a list of recipient indexes.
//  Parameters:
//      IN  iDomain     Index of Domain to set range for
//      IN  iLowRecip   Index of lower recipient
//      IN  iHighRecip  Index of higher recipient
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CMsgRef::SetRecipIndex(DWORD iDomain, DWORD iLowRecip, DWORD iHighRecip)
{
    _ASSERT(iDomain < m_cDomains);
    _ASSERT(iLowRecip <= iHighRecip);
    DWORD   *rgdwRecipIndex = pdwGetRecipIndexStart();

    rgdwRecipIndex[2*iDomain] = iLowRecip;
    rgdwRecipIndex[2*iDomain+1] = iHighRecip;
}


//---[ CMsgRef::GetRecipIndex ]------------------------------------------------
//
//
//  Description:
//      Get the recipient index for a given Domain index.  Used when generating
//      a list of recipient indexes to delivery for.
//  Parameters:
//      IN  iDomain     Index of Domain to get range for
//      OUT piLowRecip  Returned lower index of recipient range
//      OUT piHighRecip Returned higher index of recipient range
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CMsgRef::GetRecipIndex(DWORD iDomain, DWORD *piLowRecip, DWORD *piHighRecip)
{
    _ASSERT(iDomain < m_cDomains);
    _ASSERT(piLowRecip && piHighRecip);
    DWORD   *rgdwRecipIndex = pdwGetRecipIndexStart();

    *piLowRecip = rgdwRecipIndex[2*iDomain];
    *piHighRecip = rgdwRecipIndex[2*iDomain+1];

    _ASSERT(*piLowRecip <= *piHighRecip);
}

//---[ CMsgRef::SupersedeMsg ]-------------------------------------------------
//
//
//  Description:
//      Used to flag this message as superseded by a newer msg
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMsgRef::SupersedeMsg()
{
    dwInterlockedSetBits(&m_dwDataFlags, MSGREF_SUPERSEDED);
}

//---[ CMsgRef::fMatchesQueueAdminFilter ]--------------------------------------
//
//
//  Description:
//      Checks a message against a queue admin message filter to see if it
//      is a match
//  Parameters:
//      IN paqmf        Message Filter to check against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      12/7/98 - MikeSwa Created
//      2/17/99 - MikeSwa updated with better recipient checking
//
//-----------------------------------------------------------------------------
BOOL CMsgRef::fMatchesQueueAdminFilter(CAQAdminMessageFilter *paqmf)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::fMatchesQueueAdminFilter");
    _ASSERT(paqmf);
    HRESULT hr = S_OK;
    BOOL    fMatch = TRUE;
    BOOL    fUsageAdded = FALSE;
    DWORD   dwFilterFlags = paqmf->dwGetMsgFilterFlags();
    LPSTR   szMsgId = NULL;

    //Check to see if this message is marked for deletion
    if (fMailMsgMarkedForDeletion())
    {
        fMatch = FALSE;
        goto Exit;
    }

    if (!dwFilterFlags)
    {
        fMatch = FALSE;
        goto Exit;
    }

    if (AQ_MSG_FILTER_ALL & dwFilterFlags)
    {
        fMatch = TRUE;
        goto Exit;
    }

    //Check MsgRef props first
    if (AQ_MSG_FILTER_LARGER_THAN & dwFilterFlags)
    {
        fMatch = paqmf->fMatchesSize(m_cbMsgSize);
        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_OLDER_THAN & dwFilterFlags)
    {
        fMatch = paqmf->fMatchesTime(&m_ftQueueEntry);
        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_FROZEN & dwFilterFlags)
    {
        fMatch = fIsMsgFrozen();
        if (AQ_MSG_FILTER_INVERTSENSE & dwFilterFlags)
            fMatch = !fMatch;

        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_FAILED & dwFilterFlags)
    {
        if (m_cTimesRetried)
            fMatch = TRUE;
        else
            fMatch = FALSE;

        if (AQ_MSG_FILTER_INVERTSENSE & dwFilterFlags)
            fMatch = !fMatch;

        if (!fMatch)
            goto Exit;
    }

    //If we haven't failed by this point, we may need to AddUsage and read
    //props from the mailmsg.  Double-check to make sure that we need to
    //add usage.
    if (!((AQ_MSG_FILTER_MESSAGEID | AQ_MSG_FILTER_SENDER | AQ_MSG_FILTER_RECIPIENT) &
           dwFilterFlags))
        goto Exit;  //don't have to check props

    //If we are only interested in MSGID... check hash first
    if (AQ_MSG_FILTER_MESSAGEID & dwFilterFlags)
    {
        //If we are  interested in ID & hash doesn't match then leave
        if (!paqmf->fMatchesIdHash(m_dwMsgIdHash))
        {
            fMatch = FALSE;
            goto Exit;
        }
    }

    hr = InternalAddUsage();
    if (FAILED(hr))
        goto Exit;
    fUsageAdded = TRUE;

    //Check to see if this message is marked for deletion
    if (fMailMsgMarkedForDeletion())
    {
        fMatch = FALSE;
        goto Exit;
    }

    if (AQ_MSG_FILTER_MESSAGEID & dwFilterFlags)
    {
        hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, IMMPID_MP_RFC822_MSG_ID,
                                       &szMsgId);
        if (FAILED(hr))
            szMsgId = NULL;
        fMatch = paqmf->fMatchesId(szMsgId);
        if (!fMatch)
        {
            DEBUG_DO_IT(g_cDbgMsgIdHashFailures++);
            goto Exit;
        }
    }


    if (AQ_MSG_FILTER_SENDER & dwFilterFlags)
    {
        fMatch = paqmf->fMatchesMailMsgSender(m_pIMailMsgProperties);

        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_RECIPIENT & dwFilterFlags)
    {
        fMatch = paqmf->fMatchesMailMsgRecipient(m_pIMailMsgProperties);

        if (!fMatch)
            goto Exit;
    }

  Exit:
    if (szMsgId)
        QueueAdminFree(szMsgId);

    if (fUsageAdded)
    {
        InternalReleaseUsage();
        BounceUsageCount();
    }
    TraceFunctLeave();
    return fMatch;
}

//---[ CMsgRef::HrGetQueueAdminMsgInfo ]----------------------------------------
//
//
//  Description:
//      Fills out a queue admin MESSAGE_INFO structure.  All allocations are
//      done with pvQueueAdminAlloc to be freed by the RPC code
//  Parameters:
//      IN OUT pMsgInfo     MESSAGE_INFO struct to dump data to
//      IN     pIQueueAdminAction - Action interface that is requesting info
//                  used to determine if local or remote info should be
//                  reported.
//  Returns:
//      S_OK on success
//      AQUEUE_E_MESSAGE_HANDLED if the underlying message has been deleted
//      E_OUTOFMEMORY if an allocation failu
//  History:
//      12/7/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrGetQueueAdminMsgInfo(MESSAGE_INFO *pMsgInfo,
                                        IQueueAdminAction *pIQueueAdminAction)
{
    HRESULT hr = S_OK;
    BOOL    fUsageAdded = FALSE;
    FILETIME ftSubmitted;   //Origination time property buffer
    FILETIME ftExpire;      // Expiry time property buffer
    DWORD   cbProp = 0;

    if (fNormalPri(m_dwDataFlags & MSGREF_PRI_MASK))
        pMsgInfo->fMsgFlags = MP_NORMAL;
    else if (fHighPri(m_dwDataFlags & MSGREF_PRI_MASK))
        pMsgInfo->fMsgFlags = MP_HIGH;
    else
        pMsgInfo->fMsgFlags = MP_LOW;

    if (MSGREF_MSG_FROZEN & m_dwDataFlags)
        pMsgInfo->fMsgFlags |= MP_MSG_FROZEN;

    //Report the number of failures
    pMsgInfo->cFailures = m_cTimesRetried;
    if (pMsgInfo->cFailures)
        pMsgInfo->fMsgFlags |= MP_MSG_RETRY;

    hr = InternalAddUsage();
    if (FAILED(hr))
        goto Exit;
    fUsageAdded = TRUE;

    //Check to see if this message is marked for deletion
    if (fMailMsgMarkedForDeletion())
    {
        hr = AQUEUE_E_MESSAGE_HANDLED;
        goto Exit;
    }

    //
    //  Extract properties that are stored only on mailmsg (this is shared
    //  with all QAPI code).
    //
    hr = HrGetMsgInfoFromIMailMsgProperty(m_pIMailMsgProperties,
                                          pMsgInfo);
    if (FAILED(hr))
        goto Exit;

    pMsgInfo->cbMessageSize = m_cbMsgSize;

    //Get submission and expiration times
    QueueAdminFileTimeToSystemTime(&m_ftQueueEntry, &pMsgInfo->stReceived);

    //
    //  Report local expire time if we are on the local queue
    //
    if (m_paqinst && m_paqinst->fIsLocalQueueAdminAction(pIQueueAdminAction))
    {
        if (((ULARGE_INTEGER*)&m_ftLocalExpireNDR)->QuadPart)
        {
            memcpy(&ftExpire, &m_ftLocalExpireNDR, sizeof(FILETIME));
        }
        else
        {
            m_paqinst->CalcExpireTimeNDR(m_ftQueueEntry, TRUE, &ftExpire);
        }
    }
    else
    {
        if (((ULARGE_INTEGER*)&m_ftRemoteExpireNDR)->QuadPart)
        {
            memcpy(&ftExpire, &m_ftRemoteExpireNDR, sizeof(FILETIME));
        }
        else
        {
            m_paqinst->CalcExpireTimeNDR(m_ftQueueEntry, FALSE, &ftExpire);
        }
    }
    QueueAdminFileTimeToSystemTime(&ftExpire, &pMsgInfo->stExpiry);

    //Get the time the message entered the org
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_ORIGINAL_ARRIVAL_TIME,
                    sizeof(FILETIME), &cbProp, (BYTE *) &ftSubmitted);
    if (FAILED(hr))
    {
        //Time was not written... use entry time.
        hr = S_OK;
        memcpy(&ftSubmitted, &m_ftQueueEntry, sizeof(FILETIME));
    }

    QueueAdminFileTimeToSystemTime(&ftSubmitted, &pMsgInfo->stSubmission);

  Exit:

    if (fUsageAdded)
    {
        InternalReleaseUsage();
        BounceUsageCount();
    }

    return hr;
}


//---[ CMsgRef::BounceUsageCount ]---------------------------------------------
//
//
//  Description:
//      Bounces usage count off of 0 to close handles.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/7/98 - MikeSwa Created
//      7/6/99 - MikeSwa Modified - made async
//      10/27/1999 - MikeSwa - spun-pff SyncBounceUsageCount()
//
//-----------------------------------------------------------------------------
void CMsgRef::BounceUsageCount()
{
    DWORD dwFlags = 0;

    //Bounce usage count - this will conserve handles
    dwFlags = dwInterlockedSetBits(&m_dwDataFlags, MSGREF_ASYNC_BOUNCE_PENDING);

    //If the bit was *not* already set, then it is safe to call release usage
    if (!(MSGREF_ASYNC_BOUNCE_PENDING & dwFlags))
    {
        if (m_paqinst)
        {
            if (g_cMaxIMsgHandlesAsyncThreshold >
                (DWORD) InterlockedIncrement((PLONG)&s_cMsgsPendingBounceUsage))
            {
                AddRef();
                m_paqinst->HrQueueWorkItem(this,
                                      CMsgRef::fBounceUsageCountCompletion);
                //Completion function is still called on failure
            }
            else
            {
                //There are too many messages pending async commit.  We
                //should force a synchronous bounce
                SyncBounceUsageCount();
            }
        }
    }
}

//---[ CMsgRef::SyncBounceUsageCount ]-----------------------------------------
//
//
//  Description:
//      Forces synchronous bounce usage.  Can be used when there are too many
//      messages pending async bounce usage or if you want to bounce usage
//      immediately (to force deletion of a message marked for deletion).
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/27/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMsgRef::SyncBounceUsageCount()
{
    BOOL  fCompletionRet = FALSE;

    AddRef();

    //Call the async bounce usage function directly
    fCompletionRet = fBounceUsageCountCompletion(this,
                                            ASYNC_WORK_QUEUE_NORMAL);
    _ASSERT(fCompletionRet); //This is hardcoded to return TRUE
    if (!fCompletionRet)
        Release();
}

//---[ CMsgRef::fBounceUsageCountCompletion ]----------------------------------
//
//
//  Description:
//      Async completion for BounceUsageCount
//  Parameters:
//      IN      pvContext   CMsgRef to bounce usage count on
//  Returns:
//      TRUE always
//  History:
//      7/6/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CMsgRef::fBounceUsageCountCompletion(PVOID pvContext, DWORD dwStatus)
{
    CMsgRef *pmsgref = (CMsgRef *) pvContext;

    _ASSERT(pmsgref);
    _ASSERT(MSGREF_SIG == pmsgref->m_dwSignature);

    //Don't bounce usage while where are trying to shutdown
    if (ASYNC_WORK_QUEUE_SHUTDOWN != dwStatus)
    {
        //NOTE - Make sure 2 threads don't call ReleaseUsage before AddUsage
        //(which might cause the usage count to drop below 0).
        if (fTrySpinLock(&(pmsgref->m_dwDataFlags), MSGREF_USAGE_COUNT_IN_USE))
        {
            //Make sure another thread has not released the mailmsg
            //for shutdown.
            if (  pmsgref->m_pIMailMsgQM &&
                !(MSGREF_MAILMSG_RELEASED & pmsgref->m_dwDataFlags))
            {
                pmsgref->InternalReleaseUsage();
                pmsgref->InternalAddUsage();
            }

            //Unset the lock usage count bit (since this thread set it)
            ReleaseSpinLock(&(pmsgref->m_dwDataFlags), MSGREF_USAGE_COUNT_IN_USE);
        }
    }

    //Unset the bit set in BounceUsageCount
    dwInterlockedUnsetBits(&(pmsgref->m_dwDataFlags), MSGREF_ASYNC_BOUNCE_PENDING);
    InterlockedDecrement((PLONG)&s_cMsgsPendingBounceUsage);

    pmsgref->Release();
    return TRUE;  //This function never retries
}


//---[ CMsgRef::HrRemoveMessageFromQueue ]-------------------------------------
//
//
//  Description:
//      Remove a message from the specified queue
//  Parameters:
/