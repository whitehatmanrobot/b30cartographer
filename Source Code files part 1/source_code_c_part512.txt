size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // keep the app informed (if requested to do so)
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE,
                               NULL,
                               0
                               );
    }

    fsm.m_dwReadFlags = fsm.m_dwFlags;

    //
    // Loop Through our Reads, assembling enough unencrypted bytes
    //  to return back to the client.  In the non-SSL/PCT case, we should
    //  be able to quit after one iteration.
    //

    do {

        LPVOID * lplpReadBuffer;
        LPDWORD lpdwReadBufferLength;
        LPDWORD lpdwReadBufferLeft;
        LPDWORD lpdwReadBufferReceived;

        //
        // If we're attempting to read SSL/PCT data, we need examine, whether
        // we have all the bytes decrypted and read already in our scratch buffer.
        //

        if (m_dwFlags & SF_DECRYPT) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Decrypting data..\n"
                        ));

            if (m_pdblbufBuffer != NULL) {

                DEBUG_DUMP_API(SOCKETS,
                               "About to decrypt this data:\n",
                               (LPBYTE)m_pdblbufBuffer->GetInputBufferPointer(),
                               m_pdblbufBuffer->GetInputBufferSize()
                               );

            }

            fsm.m_dwDecryptError = DecryptData(&fsm.m_dwInputBytesLeft,
                                               (LPBYTE)fsm.m_hBuffer,
                                               &fsm.m_dwBufferLeft,
                                               &fsm.m_dwBytesReceived,
                                               &fsm.m_dwBytesRead
                                               );

            if (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE &&
                fsm.m_bEof &&
                m_pdblbufBuffer->GetInputBufferSize() > 0) {

                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
                goto error_exit;

            }
            else if (fsm.m_dwDecryptError == SEC_I_RENEGOTIATE) {

                CredHandle hDummyCreds;

                //
                // BUGBUG - don't have to do this - Receive() called from
                //          SSPINegotiateLoop() won't come back through here
                //

                m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
                ClearCreds(hDummyCreds);

                fsm.SetFunctionState(FSM_STATE_2);
                error = SSPINegotiateLoop(m_pdblbufBuffer,
                                          fsm.m_dwFlags,
                                          hDummyCreds,
                                          FALSE,
                                          FALSE);
                if (error == ERROR_IO_PENDING) {
                    goto error_exit;
                }

negotiate_continue:

                m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);

                if (error != ERROR_SUCCESS) {
                    break;
                }

                fsm.m_dwDecryptError = (ULONG)SEC_E_INCOMPLETE_MESSAGE;

                //
                // If there was extra data, and it was shoved back into
                // dblbuffer, then we should redo the decryption, since
                // it now has extra input data to process.
                //

                if (m_pdblbufBuffer->GetInputBufferSize() > 0) {
                    continue;
                }

                //
                // Okay, here we've received 0 bytes, so so we have to
                // receive more data, and process it.  Do this by zero-ing
                // out the input buffer, and setting the decrypt_error to be
                // Incomplete.
                //

            }

            //
            // If we have no buffer left to fill, or the caller ask for a single recv
            // and we've managed to read something into the buffer, then return by breaking.
            //

            if ((fsm.m_dwBufferLeft == 0)
            || (!(fsm.m_dwFlags & SF_RECEIVE_ALL) && (fsm.m_dwBytesRead > 0))) {
                break;  // we're done.
            }

            INET_ASSERT(error == ERROR_SUCCESS);

            //
            // BUGBUG [arthurbi] GetInputBufferSize needs to be called before getting
            //   the pointer, because the pointer may be moved around while generating
            //   the size.
            //

            DWORD remaining;
            DWORD inputSize;

            inputSize = m_pdblbufBuffer->GetInputBufferSize();
            remaining = m_pdblbufBuffer->GetInputBufferRemaining();
            fsm.m_dwBufferLengthDummy = inputSize + remaining;
            fsm.m_dwBufferLeftDummy = remaining;
            fsm.m_dwBufferReceivedDummy = inputSize;
            fsm.m_lpBufferDummy = m_pdblbufBuffer->GetInputBufferPointer();

            //
            // We need to be careful, and only recv one block of data at a time
            // if we're not we break keep-alive by doing too many reads.
            //
            // So unless we know ( by the non-0 return ) exactly how many bytes
            // to read, we shut off SF_RECEIVE_ALL.
            //

            fsm.m_dwReadFlags &= ~(SF_RECEIVE_ALL
                                   | SF_INDICATE
                                   | SF_EXPAND
                                   | SF_COMPRESS
                                   );

            if (fsm.m_dwInputBytesLeft != 0) {

                //
                // don't add RECEIVE_ALL if NO_WAIT already set by caller - they
                // are mutually exclusive
                //

                if (!(fsm.m_dwReadFlags & SF_NO_WAIT)) {
                    fsm.m_dwReadFlags |= SF_RECEIVE_ALL;
                }
                fsm.m_dwBufferLeftDummy = min(fsm.m_dwInputBytesLeft,
                                              fsm.m_dwBufferLeftDummy);
            }
            lplpReadBuffer = (LPVOID *)&fsm.m_lpBufferDummy;
            lpdwReadBufferLength = &fsm.m_dwBufferLengthDummy;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeftDummy;
            lpdwReadBufferReceived = &fsm.m_dwBufferReceivedDummy;
        } else {
            lplpReadBuffer = &fsm.m_hBuffer;
            lpdwReadBufferLength = &fsm.m_dwBufferLength;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeft;
            lpdwReadBufferReceived = &fsm.m_dwBytesReceived;
        }

        //
        // receive some data, assuming the socket is not closed.
        //

        if (!fsm.m_bEof) {
            //fsm.m_dwBytesReceivedPre = *lpdwReadBufferReceived;
            fsm.SetFunctionState(FSM_STATE_3);
            error = ICSocket::Receive(lplpReadBuffer,
                                      lpdwReadBufferLength,
                                      lpdwReadBufferLeft,
                                      lpdwReadBufferReceived,
                                      fsm.m_dwExtraSpace,
                                      fsm.m_dwReadFlags,
                                      &fsm.m_bEof
                                      );
            if (error == ERROR_IO_PENDING) {
                goto error_exit;
            }

receive_continue:

            //fsm.m_dwBytesRead += fsm.m_dwByReceived - fsm.m_dwDCBufferRecvPre;
            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            //
            // Once again, for SSL/PCT we need to update our input buffer after the read.
            //

            if (m_dwFlags & SF_DECRYPT) {
                m_pdblbufBuffer->SetInputBufferSize(fsm.m_dwBufferReceivedDummy);
            }
        }
    } while ((m_dwFlags & SF_DECRYPT)
             && (error == ERROR_SUCCESS)
             && (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE)
             && (!fsm.m_bEof || (m_pdblbufBuffer->GetInputBufferSize() > 0)));

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) 
        {
            DWORD dwBytesRead = fsm.m_dwBytesRead;
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED,
                                   &dwBytesRead,
                                   sizeof(dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT_API(SOCKETS,
                        INFO,
                        ("read %d bytes @ %#x from socket %#x\n",
                        fsm.m_dwBytesRead,
                        (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                        m_Socket
                        ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

    }

quit:

    //
    // if we failed but allocated a buffer then we need to free it (we were
    // leaking this buffer if the request was cancelled)
    //

    if ((error != ERROR_SUCCESS) && fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {
//dprintf("SocketReceive() freeing allocated buffer %#x\n", hBuffer);
        fsm.m_hBuffer = (HLOCAL)FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;

    //
    // Hack, we hide eof's from caller, since we may have buffered data sitting around
    //

    if ((m_dwFlags & SF_DECRYPT) && (fsm.m_dwBytesRead != 0)) {
        fsm.m_bEof = FALSE;
    }

    *fsm.m_lpbEof = fsm.m_bEof;

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

error_exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SetHostName(
    IN LPSTR lpszHostName,
    IN SECURITY_CACHE_LIST *pCertCache
    )

/*++

Routine Description:

    Set name of server we are connected to. Find or create a security cache
    entry for this name

Arguments:

    lpszHostName    - name to set

    pCertCache      - SSL cert cache reference (global vs. session)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SetHostName",
                 "{%#x [%q %#x/%d]} %q, %#x",
                 this,
                 m_lpszHostName,
                 GetSocket(),
                 GetSourcePort(),
                 lpszHostName,
                 pCertCache
                 ));

    INET_ASSERT(IsSecure());
    INET_ASSERT((lpszHostName != NULL) || (m_lpszHostName == NULL));

    DWORD error = ERROR_SUCCESS;

    if (lpszHostName != NULL) {
        if (m_lpszHostName != NULL) {
            m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);

            INET_ASSERT(m_lpszHostName == NULL);

        }
        m_pCertCache = pCertCache;
        m_lpszHostName = NewString(lpszHostName);
        if (m_lpszHostName == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        } else if (m_pSecurityInfo == NULL) {
            /* SCLE ref */
            if (pCertCache)
                m_pSecurityInfo = pCertCache->Find(lpszHostName);
            if (m_pSecurityInfo == NULL) {
                /* SCLE ref */
                m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(lpszHostName);
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private ICSecureSocket methods
//


DWORD
ICSecureSocket::EncryptData(
    IN LPVOID lpBuffer,
    IN DWORD dwInBufferLen,
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwOutBufferLen,
    OUT LPDWORD lpdwInBufferBytesEncrypted
    )

/*++

Routine Description:

    This function encrypts data in the lplpbuffer.

Arguments:

    lpBuffer         - pointer to buffer containing unencrypted user data

    dwInBufferLen    - length of input buffer

    lplpBuffer       - pointer to pointer to encrypted user buffer

    lpdwOutBufferLen - pointer to length of output lplpbuffer

    lpdwInBufferBytesEncrypted - pointer to length of bytes read and encrypted in output buffer

Return Value:

    Error Code

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::EncryptData",
                 "%#x, %d, %#x, %#x, %#x",
                 lpBuffer,
                 dwInBufferLen,
                 lplpBuffer,
                 lpdwOutBufferLen,
                 lpdwInBufferBytesEncrypted
                 ));

    SECURITY_STATUS scRet = STATUS_SUCCESS;
    SecBufferDesc Buffer;
    SecBuffer Buffers[3];
    HLOCAL hBuffer;
    DWORD error;
    DWORD dwMaxDataBufferSize;
    DWORD dwExtraInputBufferLen;
    SecPkgContext_StreamSizes Sizes;

    INET_ASSERT(IsSecure());
    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT(dwInBufferLen != 0);
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwOutBufferLen != NULL);
    INET_ASSERT(lpdwInBufferBytesEncrypted != NULL);

    hBuffer = (HLOCAL) *lplpBuffer;
    *lpdwOutBufferLen = 0;
    *lpdwInBufferBytesEncrypted = 0;

    //INET_ASSERT(hBuffer == NULL );

    //
    //  find the header and trailer sizes
    //

    scRet = g_QueryContextAttributes(&m_hContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );
    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned, %s [%x] (%s)\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet,
                    InternetMapError(scRet)
                    ));

        error = MapInternetError((DWORD) scRet);
        goto quit;
    } else {

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned header=%d, trailer=%d, maxmessage=%d\n",
                    Sizes.cbHeader,
                    Sizes.cbTrailer,
                    Sizes.cbMaximumMessage
                    ));
    }

    INET_ASSERT(Sizes.cbMaximumMessage > (Sizes.cbHeader + Sizes.cbTrailer));

    //
    // Figure out the max SSL packet we can send over the wire.
    //  If the data is too big to send, then remeber how much
    //  we did send, and how much we didn't send.
    //

    dwMaxDataBufferSize = Sizes.cbMaximumMessage - (Sizes.cbHeader + Sizes.cbTrailer);

    dwExtraInputBufferLen =
            (dwMaxDataBufferSize < dwInBufferLen ) ?
                (dwInBufferLen - dwMaxDataBufferSize) : 0;

    dwInBufferLen =
            ( dwExtraInputBufferLen > 0 ) ?
            dwMaxDataBufferSize :
            dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("resizing %#x to %d\n",
                hBuffer,
                dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer
                ));

    hBuffer = ResizeBuffer(hBuffer,
                           dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer,
                           FALSE );

    if (hBuffer == (HLOCAL)NULL) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        goto quit;
    }

    //
    // prepare data for SecBuffer
    //

    Buffers[0].pvBuffer = hBuffer;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_TOKEN;

    Buffers[1].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader;
    memcpy(Buffers[1].pvBuffer,
           lpBuffer,
           dwInBufferLen);

    Buffers[1].cbBuffer = dwInBufferLen;
    Buffers[1].BufferType = SECBUFFER_DATA;

    //
    // check if security pkg supports trailer: PCT does
    //

    if ( Sizes.cbTrailer ) {
         Buffers[2].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader + dwInBufferLen;
         Buffers[2].cbBuffer = Sizes.cbTrailer;
         Buffers[2].BufferType = SECBUFFER_TOKEN;
    } else {
         Buffers[2].pvBuffer = NULL;
         Buffers[2].cbBuffer = 0;
         Buffers[2].BufferType = SECBUFFER_EMPTY;
    }

    Buffer.cBuffers = 3;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    scRet = g_SealMessage(&m_hContext,
                          0,
                          &Buffer,
                          0);

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned, %s [%x]\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet
                ));


    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("SealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));

        error = MapInternetError((DWORD) scRet);

        if (hBuffer != NULL) {
            FREE_MEMORY(hBuffer);
        }
        goto quit;
    } else {
        error = ERROR_SUCCESS;
    }

    *lplpBuffer = Buffers[0].pvBuffer;
    *lpdwOutBufferLen = Sizes.cbHeader + Buffers[1].cbBuffer +
                        Buffers[2].cbBuffer;
    *lpdwInBufferBytesEncrypted = dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned Buffer = %x, EncryptBytes = %d, UnencryptBytes=%d\n",
                *lplpBuffer,
                *lpdwOutBufferLen,
                dwInBufferLen
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


#define SSLPCT_SMALLESTHEADERCHUNK      3


DWORD
ICSecureSocket::DecryptData(
    OUT DWORD * lpdwBytesNeeded,
    OUT LPBYTE lpOutBuffer,
    IN OUT LPDWORD lpdwOutBufferLeft,
    IN OUT LPDWORD lpdwOutBufferReceived,
    IN OUT LPDWORD lpdwOutBufferBytesRead
    )

/*++

Routine Description:

    This function decrypts data into the lpOutBuffer. It attempts to fill lpOutBuffer.
    If it fails, it may do so because more bytes are
    needed to fill lplpEncDecBuffer or lplpEndDecBuffer is not big enough to fully
    contain a complete server generated SSL/PCT message.


Return Value:

    Error Code

--*/

{
    INET_ASSERT(IsSecure());
    INET_ASSERT(lpOutBuffer);
    INET_ASSERT(lpdwOutBufferBytesRead);
    INET_ASSERT(lpdwBytesNeeded);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::DecryptData",
                 "{%#x [%#x:%#x], %#x} %#x [%d], %#x, %#x [%d], %#x [%d], %#x [%d]",
                 &m_hContext,
                 m_hContext.dwUpper,
                 m_hContext.dwLower,
                 m_pdblbufBuffer,
                 lpdwBytesNeeded,
                 *lpdwBytesNeeded,
                 lpOutBuffer,
                 lpdwOutBufferLeft,
                 *lpdwOutBufferLeft,
                 lpdwOutBufferReceived,
                 *lpdwOutBufferReceived,
                 lpdwOutBufferBytesRead,
                 *lpdwOutBufferBytesRead
                 ));

    SecBufferDesc Buffer;
    SecBuffer Buffers[4];   // the 4 buffers are: header, data, trailer, extra
    DWORD scRet = ERROR_SUCCESS;

    *lpdwBytesNeeded = 0;

    //
    //  HOW THIS THING WORKS:
    //  We sit in a loop, attempting to fill our passed in buffer with
    //  decrypted data.  If there is no decrypted data we check to
    //  see if there is encrypted data sitting in our buffer.
    //
    //  Assuming there is enough we decrypt a chunk, and place it in the
    //  output buffer of our double buffer class. We reloop and try to
    //  copy it to our passed in byffer.
    //
    //  If there is more encrypted data, and more space to fill in
    //  the user buffer, we attempt to decrypt the next chunk of this.
    //
    //  If we do not have enough data, we return with an error, and
    //  expect a network read to be done.
    //

    do {

        //
        // Check to see if we can fill up User buffer.
        //

        m_pdblbufBuffer->CopyOut(
            lpOutBuffer,
            lpdwOutBufferLeft,
            lpdwOutBufferReceived,
            lpdwOutBufferBytesRead
        );

        //
        // If we've filled our output buffer, than exit with ERROR_SUCCESS
        //

        if ( *lpdwOutBufferLeft == 0)
        {
            break;
        }

        //
        // If we've got less than ~3 bytes return so we can read more data.
        //

        if (m_pdblbufBuffer->GetInputBufferSize() < SSLPCT_SMALLESTHEADERCHUNK) {
            scRet = (DWORD) SEC_E_INCOMPLETE_MESSAGE;
            break;
        }

        //
        // prepare data the SecBuffer for a call to SSL/PCT decryption code.
        //

        Buffers[0].pvBuffer = m_pdblbufBuffer->GetInputBufferPointer( );
        Buffers[0].cbBuffer = m_pdblbufBuffer->GetInputBufferSize(); // # of bytes to decrypt
        Buffers[0].BufferType = SECBUFFER_DATA;

        int i;

        for ( i = 1; i < 4; i++ )
        {
            //
            // clear other 3 buffers for receving result from SSPI package
            //

            Buffers[i].pvBuffer = NULL;
            Buffers[i].cbBuffer = 0;
            Buffers[i].BufferType = SECBUFFER_EMPTY;
        }

        Buffer.cBuffers = 4; // the 4 buffers are: header, data, trailer, extra
        Buffer.pBuffers = Buffers;
        Buffer.ulVersion = SECBUFFER_VERSION;

        //
        // Decrypt the DATA !!!
        //

        scRet = g_UnsealMessage(&m_hContext,
                                &Buffer,
                                0,
                                NULL );

        DEBUG_PRINT(API,
                    INFO,
                    ("UnsealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));



        if ( scRet != ERROR_SUCCESS &&
             scRet != SEC_I_RENEGOTIATE)
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("UnsealMessage failed, error %lx\n",
                        scRet
                        ));

            INET_ASSERT( scRet != SEC_E_MESSAGE_ALTERED );

            if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
            {
                DWORD dwAddlBufferNeeded = Buffers[1].cbBuffer;

                DEBUG_PRINT(API,
                             INFO,
                             ("UnsealMessage short of %d bytes\n",
                             dwAddlBufferNeeded
                             ));

                 //
                 // If we're missing data, return to get the missing data.
                 // But make sure we have enough room first!
                 //

                if (!m_pdblbufBuffer->ResizeBufferIfNeeded(dwAddlBufferNeeded)) {
                    scRet = ERROR_NOT_ENOUGH_MEMORY;
                }
                *lpdwBytesNeeded = dwAddlBufferNeeded;
                break;
            }
            else if ( scRet == 0x00090317 /*SEC_I_CONTEXT_EXPIRED*/)
            {
                //
                // Ignore this error and treat this like a simple terminator
                //  to end the connection.
                //

                scRet = ERROR_SUCCESS;
            }
            else
            {
                break;
            }
        }



        //
        // Success we decrypted a block
        //

        LPBYTE  lpExtraBuffer;
        DWORD   dwExtraBufferSize;
        LPBYTE  lpDecryptedBuffer;
        DWORD   dwDecryptedBufferSize;


        lpDecryptedBuffer       =   (LPBYTE) Buffers[1].pvBuffer;
        dwDecryptedBufferSize   =   Buffers[1].cbBuffer;

        //
        // BUGBUG [arthurbi] this is hack to work with the OLD SSLSSPI.DLL .
        //  They return extra on the second buffer instead of the third.
        //

        if ( Buffers[2].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[2].pvBuffer;
            dwExtraBufferSize = Buffers[2].cbBuffer;
        }
        else if ( Buffers[3].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[3].pvBuffer;
            dwExtraBufferSize = Buffers[3].cbBuffer;
        }
        else
        {
            lpExtraBuffer = NULL;
            dwExtraBufferSize = 0;
        }


        m_pdblbufBuffer->SetOutputInputBuffer(
            lpDecryptedBuffer,
            dwDecryptedBufferSize,
            lpExtraBuffer,
            dwExtraBufferSize,
            FALSE // don't combine.
        );

        if ( dwDecryptedBufferSize == 0 )
            break;  // No more data to process

        INET_ASSERT( *lpdwOutBufferLeft );  // don't expect to get here this way.

    } while ( *lpdwOutBufferLeft && scRet == ERROR_SUCCESS );



    DEBUG_PRINT(API,
         INFO,
         ("DecryptData returning, "
          "OutBuffer = %x, DecryptBytesRecv = %d\n",
         lpOutBuffer,
         *lpdwOutBufferBytesRead
         ));

    DEBUG_LEAVE((DWORD)scRet);

    return ( scRet );
}


VOID
ICSecureSocket::TerminateSecConnection(
    VOID
    )

/*++

Routine Description:

    This function deletes the security context handle which result
    in deleting the local data structures with which they are associated.

Arguments:

    None

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ICSecureSocket::TerminateSecConnection",
                 "{%#x [%#x:%#x]}",
                 this,
                 m_hContext.dwUpper,
                 m_hContext.dwLower
                 ));

    INET_ASSERT(IsSecure());

    //INET_ASSERT(m_hContext.dwLower != 0);
    //INET_ASSERT(m_hContext.dwUpper != 0);

    if (GlobalSecFuncTable)
    {
        if (!((m_hContext.dwLower == 0) && (m_hContext.dwUpper == 0)))
        {
            // There are cases where because of circular dependencies
            // schannel could get unloaded before wininet. In that case
            // this call could fault. This usually happens when the process 
            // is shutting down.
            SAFE_WRAP_REVERT_USER_VOID(g_DeleteSecurityContext, (&m_hContext));

            m_hContext.dwLower = m_hContext.dwUpper = 0;
        }
    }
    else
    {

        DEBUG_PRINT(API,
                    ERROR,
                    ("Attempting to Delete a security context, with a NULL SSPI func table!(missing SCHANNEL.DLL?)\n"
                    ));

    }

    DEBUG_LEAVE(0);
}

#ifdef SECPKG_ATTR_PROTO_INFO
/*++

ProtoInfoToString:

    This routine converts an SSPI SecPkgContext_ProtoInfo structure into a
    string.  The returned string must be released via LocalFree.

Arguments:

    pProtoInfo supplies the SecPkgContext_ProtoInfo structure to be converted to
    string representation.

Return Value:

    Non-NULL is the address of the returned string.  This must be freed via
        LocalFree once it is no longer needed.

    NULL implies no memory is available.

Author:

    Doug Barlow (dbarlow) 4/23/1996

--*/


PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo)
{
    TCHAR
        szValue[32],
        szSep[8];
    LPTSTR
        szFinal
            = NULL;
    DWORD
        length;

    length = GetLocaleInfo(
                LOCALE_USER_DEFAULT,
                LOCALE_SDECIMAL,
                szSep,
                sizeof(szSep) / sizeof(TCHAR));
    if (0 >= length)
        lstrcpy(szSep, TEXT("."));

    length = wsprintf(
                szValue,
                TEXT("%d%s%d"),
                pProtoInfo->majorVersion,
                szSep,
                pProtoInfo->minorVersion);
    INET_ASSERT(sizeof(szValue) / sizeof(TCHAR) > length);

    length = lstrlen(pProtoInfo->sProtocolName);
    length += 2;                    // Space and Trailing NULL
    length += lstrlen(szValue);
    szFinal = (LPTSTR)ALLOCATE_MEMORY(LMEM_FIXED, length * sizeof(TCHAR));
    if (NULL != szFinal)
    {
        lstrcpy(szFinal, pProtoInfo->sProtocolName);
        lstrcat(szFinal, TEXT(" "));
        lstrcat(szFinal, szValue);
    }
    return szFinal;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\serialst.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.cxx

Abstract:

    Functions to deal with a serialized list. These are replaced by macros in
    the retail version, except for functions no longer inlined due to critsec
    wrapper

    Contents:
        [InitializeSerializedList]
        [TerminateSerializedList]
        [LockSerializedList]
        [UnlockSerializedList]
        [InsertAtHeadOfSerializedList]
        [InsertAtTailOfSerializedList]
        [RemoveFromSerializedList]
        [IsSerializedListEmpty]
        [HeadOfSerializedList]
        [TailOfSerializedList]
        [CheckEntryOnSerializedList]
        [(CheckEntryOnList)]
        SlDequeueHead
        SlDequeueTail
        IsOnSerializedList

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win-32 user level

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>

#if INET_DEBUG

//
// manifests
//

#define SERIALIZED_LIST_SIGNATURE   'tslS'

//
// private prototypes
//

PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

//
// data
//

BOOL fCheckEntryOnList = FALSE;
BOOL ReportCheckEntryOnListErrors = FALSE;

//
// functions
//


DEBUG_FUNCTION
BOOL
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    initializes a serialized list

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);

    SerializedList->Signature = SERIALIZED_LIST_SIGNATURE;
    SerializedList->LockCount = 0;

    INITIALIZE_RESOURCE_INFO(&SerializedList->ResourceInfo);

    InitializeListHead(&SerializedList->List);
    SerializedList->ElementCount = 0;
    return SerializedList->Lock.Init();
}


DEBUG_FUNCTION
VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Undoes InitializeSerializeList

Arguments:

    SerializedList  - pointer to serialized list to terminate

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ElementCount == 0);

    if (SerializedList->ElementCount != 0) {

        DEBUG_PRINT(SERIALST,
                    ERROR,
                    ("list @ %#x has %d elements, first is %#x\n",
                    SerializedList,
                    SerializedList->ElementCount,
                    SerializedList->List.Flink
                    ));

    } else {

        INET_ASSERT(IsListEmpty(&SerializedList->List));

    }
    SerializedList->Lock.FreeLock();
}


DEBUG_FUNCTION
BOOL
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Acquires a serialized list locks

Arguments:

    SerializedList  - SERIALIZED_LIST to lock

Return Value:

    Success if able to acquire a lock.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->LockCount >= 0);

    if ((!SerializedList->Lock.IsInitialized() && !SerializedList->Lock.Init()) ||
         !SerializedList->Lock.Lock())
    {
        return FALSE;
    }
    else
    {
        if (SerializedList->LockCount != 0)
        {
            INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
        }
    }
    ++SerializedList->LockCount;
    SerializedList->ResourceInfo.Tid = GetCurrentThreadId();

    return TRUE;
}


DEBUG_FUNCTION
VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Releases a serialized list lock

Arguments:

    SerializedList  - SERIALIZED_LIST to unlock

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
    INET_ASSERT(SerializedList->LockCount > 0);

    --SerializedList->LockCount;
    SerializedList->Lock.Unlock();
}


DEBUG_FUNCTION
BOOL
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    FALSE - only if unable to acquire the lock

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList)
        {
            CheckEntryOnList(&SerializedList->List, Entry, FALSE);
        }
        InsertHeadList(&SerializedList->List, Entry);
        ++SerializedList->ElementCount;

        INET_ASSERT(SerializedList->ElementCount > 0);

        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


DEBUG_FUNCTION
BOOL
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    FALSE - only if not enough memory was available to insert an item.

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList) {
            CheckEntryOnList(&SerializedList->List, Entry, FALSE);
        }
        InsertTailList(&SerializedList->List, Entry);
        ++SerializedList->ElementCount;

        INET_ASSERT(SerializedList->ElementCount > 0);

        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    return FALSE;
}


BOOL
DEBUG_FUNCTION
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Removes the entry from a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to remove entry from

    Entry           - pointer to entry to remove

Return Value:

    FALSE if unable sycnhronize access to the list due to low-memory.

--*/

{
    INET_ASSERT((Entry->Flink != NULL) && (Entry->Blink != NULL));

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList)
        {
            CheckEntryOnList(&SerializedList->List, Entry, TRUE);
        }

        INET_ASSERT(SerializedList->ElementCount > 0);

        RemoveEntryList(Entry);
        --SerializedList->ElementCount;
        Entry->Flink = NULL;
        Entry->Blink = NULL;
        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


DEBUG_FUNCTION
BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Checks if a serialized list contains any elements

Arguments:

    SerializedList  - pointer to list to check

Return Value:

    BOOL

--*/

{
    // For simplicity, don't worry about returning additional status.
    // Due to this always being tied to additional manipulation,
    // the lock has already been acquired in all current cases.
    if (!LockSerializedList(SerializedList))
        return TRUE;

    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    BOOL empty;

    if (IsListEmpty(&SerializedList->List)) {

        INET_ASSERT(SerializedList->ElementCount == 0);

        empty = TRUE;
    } else {

        INET_ASSERT(SerializedList->ElementCount != 0);

        empty = FALSE;
    }

    UnlockSerializedList(SerializedList);

    return empty;
}


DEBUG_FUNCTION
PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Flink;
}


DEBUG_FUNCTION
PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Blink;
}


DEBUG_FUNCTION
BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )

/*++

Routine Description:

    Checks an entry exists (or doesn't exist) on a list

Arguments:

    SerializedList  - pointer to serialized list

    Entry           - pointer to entry

    ExpectedResult  - TRUE if expected on list, else FALSE

Return Value:

    BOOL
        TRUE    - expected result

        FALSE   - unexpected result

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    if (!LockSerializedList(SerializedList))
        return FALSE;

    BOOL result;

    __try {
        result = CheckEntryOnList(&SerializedList->List, Entry, ExpectedResult);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(SERIALST,
                    FATAL,
                    ("List @ %#x (%d elements) is bad\n",
                    SerializedList,
                    SerializedList->ElementCount
                    ));

        result = FALSE;
    }
    ENDEXCEPT
    UnlockSerializedList(SerializedList);

    return result;
}


PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != ExpectedResult) {
        if (ReportCheckEntryOnListErrors) {

            LPSTR description;

            description = found
                        ? "Entry %#x already on list %#x\n"
                        : "Entry %#x not found on list %#x\n"
                        ;

            DEBUG_PRINT(SERIALST,
                        ERROR,
                        (description,
                        Entry,
                        List
                        ));

            DEBUG_BREAK(SERIALST);

        }
        return FALSE;
    }
    return TRUE;
}

#else  // else !INET_DEBUG

BOOL
InitializeSerializedList(LPSERIALIZED_LIST pList)
{
    InitializeListHead(&(pList)->List);
    (pList)->ElementCount = 0;
    return (pList->Lock).Init();
}


BOOL
InsertAtHeadOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        InsertHeadList(&(list)->List, entry);
        ++(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
InsertAtTailOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        InsertTailList(&(list)->List, entry);
        ++(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
RemoveFromSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        RemoveEntryList(entry);
        --(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

#endif // INET_DEBUG

//
// functions that are always functions
//


LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the head of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry = NULL;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                entry = (LPVOID)HeadOfSerializedList(SerializedList);
                if (!RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry))
                    entry = NULL;
            }
            UnlockSerializedList(SerializedList);
        }
    }

    return entry;
}


LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the tail of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry = NULL;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                entry = (LPVOID)TailOfSerializedList(SerializedList);
                if (!RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry))
                    entry = NULL;
            }
            UnlockSerializedList(SerializedList);
        }
    } else {
        entry = NULL;
    }
    return entry;
}


BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Checks if an entry is on a serialized list. Useful to call before
    RemoveFromSerializedList() if multiple threads can remove the element

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

    Entry           - pointer to element to check

Return Value:

    BOOL
        TRUE    - Entry is on SerializedList

        FALSE   -   "    " not on     "

--*/

{
    BOOL onList = FALSE;
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                for (PLIST_ENTRY entry = HeadOfSerializedList(SerializedList);
                    entry != (PLIST_ENTRY)SlSelf(SerializedList);
                    entry = entry->Flink) {

                    if (entry == Entry) {
                       onList = TRUE;
                       break;
                    }
                }
            }
            UnlockSerializedList(SerializedList);
        }
    }
    return onList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\parsers.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.cxx

Abstract:

    Common text parsing functions (generally moved here from other protocols)

    Contents:
        ExtractWord
        ExtractDword
        ExtractInt
        SkipWhitespace
        SkipSpaces
        SkipLine
        FindToken
        NiceNum

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned short
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    WORD number;
    BOOL exact;
    LPSTR string;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("65535") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    number = 0;
    string = *pString;
    while (NumberLength && isdigit(*string)) {
        number = number * 10 + (WORD)((BYTE)(*string++) - (BYTE)'0');
        --NumberLength;
    }
    *pConvertedNumber = number;
    *pString = string;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned long
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    DWORD number;
    BOOL exact;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("4294967295") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength--; ) {
        number = number * 10 + (DWORD)((BYTE)*((*pString)++) - (BYTE)'0');
    }
    *pConvertedNumber = number;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an signed integer (32-bits)

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    int number;
    int sign;
    BOOL exact;

    if ((**pString == '-') || (**pString == '+')) {
        sign = (**pString == '-') ? -1 : +1;
        if (NumberLength) {
            --NumberLength;
        }
        ++*pString;
    } else {
        sign = 1;
    }

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("2147483647") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength; ) {
        number = number * 10 + (INT)(((BYTE)**pString) - (BYTE)'0');
        ++*pString;
        --NumberLength;
    }
    *pConvertedNumber = number * sign;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any whitespace characters

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any space characters. We only look for the actual space character

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer == ' ')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Positions text pointer at start of next non-empty line

Arguments:

    lpBuffer        - pointer to string. Updated on output

    lpBufferLength  - pointer to remaining length of string. Updated on output

Return Value:

    BOOL
        TRUE    - found start of next non-empty line

        FALSE   - ran out of buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer != '\r') && (**lpBuffer != '\n')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && ((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


#undef  isspace
#define isspace(ch) ((ch==0x20) || ((ch >= 0x09) && (ch <= 0x0d)))

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Moves over the current token, past any spaces, and to the start of the next
    token

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && !isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    )

/*++

Routine Description:

    Converts a number to a string. The string is very human-sensible (i.e.
    1,234,567 instead of 1234567. Sometimes its hard to make out these numbers
    when your salary is so large)

Arguments:

    Buffer      - place to put resultant string

    Number      - to convert

    FieldWidth  - maximum width of the field, or 0 for "don't care"

Return Value:

    LPSTR
        pointer to Buffer

--*/

{
    int i;

    if (Number == 0) {
        if (FieldWidth == 0) {
            Buffer[0] = '0';
            Buffer[1] = '\0';
        } else {
            memset(Buffer, ' ', FieldWidth);
            Buffer[FieldWidth - 1] = '0';
            Buffer[FieldWidth] = '\0';
        }
    } else {

        //
        // if the caller specified zero for the field width then work out how
        // many characters the string will occupy
        //

        if (FieldWidth == 0) {

            SIZE_T n;

            n = Number;
            ++FieldWidth;
            while (n >= 10) {
                n /= 10;
                ++FieldWidth;
            }

            FieldWidth += (FieldWidth / 3) - (((FieldWidth % 3) == 0) ? 1 : 0);
        }

        //
        // now create the representation
        //

        Buffer[FieldWidth] = '\0';
        Buffer += FieldWidth;
        i = 0;
        while (Number && FieldWidth) {
            *--Buffer = (char)((Number % 10) + '0');
            --FieldWidth;
            Number /= 10;
            if ((++i == 3) && FieldWidth) {
                if (Number) {
                    *--Buffer = ',';
                    --FieldWidth;
                    i = 0;
                }
            }
        }
        while (FieldWidth--) {
            *--Buffer = ' ';
        }
    }
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\secinit.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    secinit.cxx

Abstract:

    Contains load function for security.dll on NT and secur32.dll on win95
    Also handles WinTrust.dll function loading.

Author:

    Sophia Chung (sophiac)  6-Feb-1996

Environment:

    User Mode - Win32

Revision History:

--*/
#include <wininetp.h>

//
// InitializationLock - protects against multiple threads loading security.dll
// (secur32.dll) and entry points
//

CCritSec InitializationSecLock;

HCRYPTPROV  GlobalFortezzaCryptProv;

//
// GlobalSecFuncTable - Pointer to Global Structure of Pointers that are used
//  for storing the entry points into the SCHANNEL.dll
//

PSecurityFunctionTable GlobalSecFuncTable = NULL;

//
// pWinVerifyTrust - Pointer to Entry Point in WINTRUST.DLL
//

WIN_VERIFY_TRUST_FN pWinVerifyTrust;
WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;

//
// hSecurity - NULL when security.dll/secur32.dll  is not loaded
//

HINSTANCE hSecurity = NULL;

//
// hWinTrust - NULL when WinTrust DLL is not loaded.
//

HINSTANCE hWinTrust = NULL;

HCERTSTORE g_hMyCertStore = NULL;

BOOL g_bFortezzaInstalled = FALSE;
BOOL g_bCheckedForFortezza = FALSE;

CRYPT_INSTALL_DEFAULT_CONTEXT_FN g_CryptInstallDefaultContext = NULL;
CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN g_CryptUninstallDefaultContext = NULL;
CERT_FIND_CHAIN_IN_STORE_FN g_CertFindChainInStore = NULL;
CERT_FREE_CERTIFICATE_CHAIN_FN g_CertFreeCertificateChain = NULL;


DWORD
LoadWinTrust(
    VOID
    )

/*++

Routine Description:

    This function loads the WinTrust.DLL and binds a pointer to a function
    that is needed in the WinTrust DLL.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (!LOCK_SECURITY())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if( hWinTrust == NULL )
    {
        LPSTR lpszDllFileName = WINTRUST_DLLNAME;
        pWinVerifyTrust = NULL;

        //
        // Load the DLL
        //

        hWinTrust       = LoadLibrary(lpszDllFileName);

        if ( hWinTrust )
        {
            pWinVerifyTrust = (WIN_VERIFY_TRUST_FN)
                            GetProcAddress(hWinTrust, WIN_VERIFY_TRUST_NAME);
            pWTHelperProvDataFromStateData = (WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN)
                            GetProcAddress(hWinTrust, WT_HELPER_PROV_DATA_FROM_STATE_DATA_NAME);
        }


        if ( !hWinTrust || !pWinVerifyTrust )
        {
            error = GetLastError();

            if ( error == ERROR_SUCCESS )
            {
                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        }
    }

    INET_ASSERT(pWinVerifyTrust);


    if ( error != ERROR_SUCCESS )
    {
        if (hWinTrust)
        {
            FreeLibrary(hWinTrust);
            hWinTrust = NULL;
        }
    }

    UNLOCK_SECURITY();

    return error;
}



BOOL
SecurityInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    return InitializationSecLock.Init();
}

VOID
SecurityTerminate(
    VOID
    )
/*++

Routine Description:

    This function Deletes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    InitializationSecLock.FreeLock();
}


VOID
UnloadSecurity(
    VOID
    )

/*++

Routine Description:

    This function terminates the global data required for the security
    pkgs and dynamically unloads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD i;

    if (!LOCK_SECURITY())
    {
        INET_ASSERT(FALSE);
        return;
    }

    //
    //  free all security pkg credential handles
    //

    for (i = 0; SecProviders[i].pszName != NULL; i++) {
         if (SecProviders[i].fEnabled)  {
             if (SecProviders[i].pCertCtxt == NULL && !IsCredClear(SecProviders[i].hCreds)) {
                // Beta1 Hack. Because of some circular dependency between dlls
                // both crypt32 and schannel's PROCESS_DETACH gets called before wininet.
                // This is catastrophic if we have a cert context attached to the credentials
                // handle. In this case we will just leak the handle since the process is dying
                // anyway. We really need to fix this.
                WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle,
                                      (&SecProviders[i].hCreds));
            }
         }
#if 0 // See comments above.
         if (SecProviders[i].pCertCtxt != NULL) {
            CertFreeCertificateContext(SecProviders[i].pCertCtxt);
            SecProviders[i].pCertCtxt = NULL;
        }
#endif

    }

    //
    // close cert store. Protect against fault if DLL already unloaded
    //

    if (g_hMyCertStore != NULL)
    {
        SAFE_WRAP_REVERT_USER_VOID(CertCloseStore,
                                   (g_hMyCertStore, CERT_CLOSE_STORE_FORCE_FLAG));
        g_hMyCertStore = NULL;
    } 

    // IMPORTANT : Don't free GlobalFortezzaCryptProv. When we free the cert context
    // from the SecProviders[] array above it gets freed automatically.
    if (GlobalFortezzaCryptProv != NULL)
    {
        GlobalFortezzaCryptProv = NULL;
    }


    //
    // unload dll
    //

    if (hSecurity != NULL) {
        FreeLibrary(hSecurity);
        hSecurity = NULL;
    }

    UNLOCK_SECURITY();

}


DWORD
LoadSecurity(
    VOID
    )
/*++

Routine Description:

    This function dynamically loads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.
--*/
{
    DWORD Error = ERROR_SUCCESS;
    INITSECURITYINTERFACE pfInitSecurityInterface = NULL;

    if (!LOCK_SECURITY())
        return ERROR_NOT_ENOUGH_MEMORY;

    if (g_hMyCertStore == NULL)
    {

        //
        // CRYPT32.DLL is delayloaded. Need SEH in case it fails.
        //
        // Don't worry about an error, because not supporting
        // client auth shouldn't stop us from scenarios
        // which do not require it as part of the SSL handshake.
        //

        SAFE_WRAP_REVERT_USER(CertOpenSystemStore, (0, "MY"), g_hMyCertStore);

    }
    if (Error == ERROR_SUCCESS)
    {
        Error = LoadWinTrust();
    }
    if ( Error != ERROR_SUCCESS )
    {
        goto quit;
    }

    if( hSecurity != NULL )
    {
        goto quit;
    }

        //
        // load dll.
        //

       //
       // This is better for performance. Rather than call through
       //    SSPI, we go right to the DLL doing the work.
       //

       hSecurity = LoadLibrary( "schannel" );

        if ( hSecurity == NULL ) {
            Error = GetLastError();
            goto quit;
        }

        //
        // get function addresses.
        //

#ifdef UNICODE
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( hSecurity,
                                                     "InitSecurityInterfaceW" );
#else
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( hSecurity,
                                                     "InitSecurityInterfaceA" );
#endif


        if ( pfInitSecurityInterface == NULL )
        {
             Error = GetLastError();
             goto quit;
        }


    GlobalSecFuncTable = (SecurityFunctionTable*) ((*pfInitSecurityInterface) ());

    if ( GlobalSecFuncTable == NULL ) {
         Error = GetLastError(); // BUGBUG does this work?
         goto quit;
    }

    HMODULE hCrypt32;
    hCrypt32 = GetModuleHandle("crypt32");

    INET_ASSERT(hCrypt32 != NULL);

    // We don't error out here because not finding these entry points
    // just affects Fortezza. The rest will still work fine.
    if (hCrypt32)
    {
        g_CryptInstallDefaultContext = (CRYPT_INSTALL_DEFAULT_CONTEXT_FN)
                                    GetProcAddress(hCrypt32, CRYPT_INSTALL_DEFAULT_CONTEXT_NAME);

        g_CryptUninstallDefaultContext = (CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN)
                                    GetProcAddress(hCrypt32, CRYPT_UNINSTALL_DEFAULT_CONTEXT_NAME);

        g_CertFindChainInStore = (CERT_FIND_CHAIN_IN_STORE_FN)
                                    GetProcAddress(hCrypt32, CERT_FIND_CHAIN_IN_STORE_NAME);

        g_CertFreeCertificateChain = (CERT_FREE_CERTIFICATE_CHAIN_FN)
                                    GetProcAddress(hCrypt32, CERT_FREE_CERTIFICATE_CHAIN_NAME);
    }

quit:

    if ( Error != ERROR_SUCCESS )
    {
        FreeLibrary( hSecurity );
        hSecurity = NULL;
    }

    UNLOCK_SECURITY();

    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\servinfo.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    servinfo.cxx

Abstract:

    Class implementation for global server info list

    Contents:
        INTERNET_HANDLE_OBJECT::GetServerInfo
        INTERNET_HANDLE_OBJECT::FindServerInfo
        ReleaseServerInfo
        INTERNET_HANDLE_OBJECT::PurgeServerInfoList
        CServerInfo::CServerInfo
        CServerInfo::~CServerInfo
        CServerInfo::Reference
        CServerInfo::Dereference
        CServerInfo::UpdateConnectTime
        CServerInfo::UpdateRTT
        CServerInfo::GetConnection
        CFsm_GetConnection::RunSM
        CServerInfo::GetConnection_Fsm
        CServerInfo::ReleaseConnection
        CServerInfo::RemoveWaiter
        (CServerInfo::FindKeepAliveConnection)
        (CServerInfo::KeepAliveWaiters)
        (CServerInfo::RunOutOfConnections)
        (CServerInfo::UpdateConnectionLimit)
        CServerInfo::PurgeKeepAlives
        ContainingServerInfo

Author:

    Richard L Firth (rfirth) 07-Oct-1996

Revision History:

    07-Oct-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private macros
//

//#define CHECK_CONNECTION_COUNT() \
//    INET_ASSERT(!UnlimitedConnections() \
//        ? (TotalAvailableConnections() <= ConnectionLimit()) : TRUE)

#define CHECK_CONNECTION_COUNT()    /* NOTHING */

//#define RLF_DEBUG   1

#if INET_DEBUG
#ifdef RLF_DEBUG
#define DPRINTF dprintf
#else
#define DPRINTF (void)
#endif
#else
#define DPRINTF (void)
#endif

//
// functions
//


DWORD
INTERNET_HANDLE_OBJECT::GetServerInfo(
    IN LPSTR lpszHostName,
    IN DWORD dwServiceType,
    IN BOOL bDoResolution,
    OUT CServerInfo * * lplpServerInfo
    )

/*++

Routine Description:

    Finds or creates a CServerInfo entry

Arguments:

    lpszHostName    - pointer to server name to get info for

    dwServiceType   - type of service for which CServerInfo requested

    bDoResolution   - TRUE if we are to resolve host name

    lplpServerInfo  - pointer to created/found CServerInfo if successful

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create the CServerInfo

                  ERROR_WINHTTP_NAME_NOT_RESOLVED
                    We were asked to resolve the name, but failed

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "GetServerInfo",
                 "%q, %s (%d), %B, %#x",
                 lpszHostName,
                 InternetMapService(dwServiceType),
                 dwServiceType,
                 bDoResolution,
                 lplpServerInfo
                 ));

    ICSTRING hostName(lpszHostName);
    CServerInfo * lpServerInfo = NULL;
    BOOL bCreated = FALSE;
    DWORD error = ERROR_SUCCESS;

    if (hostName.HaveString()) {
        hostName.MakeLowerCase();

        LPSTR lpszHostNameLower = hostName.StringAddress();

        if (!LockSerializedList(&_ServerInfoList))
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        lpServerInfo = FindServerInfo(lpszHostNameLower);

        if (lpServerInfo == NULL) 
        {
            lpServerInfo = New CServerInfo(&_ServerInfoList,
                                           lpszHostNameLower,
                                           &error,
                                           dwServiceType,
                                           GetMaxConnectionsPerServer(WINHTTP_OPTION_MAX_CONNS_PER_SERVER)
                                           );
            if (lpServerInfo != NULL)
            {
                if (error != ERROR_SUCCESS)
                {
                    delete lpServerInfo;
                    lpServerInfo = NULL;
                }
                else
                {
                    bCreated = TRUE;
                    // Reference this to keep it alive beyond the unlock/
                    lpServerInfo->Reference();
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        UnlockSerializedList(&_ServerInfoList);
    } else {

        //
        // failed to create ICSTRING
        //

        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        lpServerInfo = NULL;
    }

    //
    // if we created a new CServerInfo and we are instructed to resolve the host
    // name then do it now, outside of the global server info list lock. This
    // operation may take some time
    //

    if (bDoResolution && (lpServerInfo != NULL)) {
        //error = lpServerInfo->ResolveHostName();
        if (error != ERROR_SUCCESS) {
            ReleaseServerInfo(lpServerInfo);
            lpServerInfo = NULL;
        }
    }

quit:
    *lplpServerInfo = lpServerInfo;

    DEBUG_LEAVE(error);

    return error;
}


CServerInfo *
INTERNET_HANDLE_OBJECT::FindServerInfo(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    Walks the server info list looking for the requested server

Arguments:

    lpszHostName    - pointer to server name to find (IN LOWER CASE!)

Return Value:

    CServerInfo *
        Success - pointer to found list entry

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "FindServerInfo",
                 "%q",
                 lpszHostName
                 ));

    DWORD hashHostName = CalculateHashValue(lpszHostName);

    CServerInfo * lpServerInfo = NULL;
    BOOL found = FALSE;

    if (!LockSerializedList(&_ServerInfoList))
    {
        goto quit;
    }

    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&_ServerInfoList);
        lpServerInfo != (CServerInfo *)SlSelf(&_ServerInfoList);
        lpServerInfo = lpServerInfo->Next()) {

        if (lpServerInfo->Match(hashHostName, lpszHostName)) {
            found = TRUE;
            break;
        }
    }

    if (!found) 
    {
        lpServerInfo = NULL;
    }

    // Need to keep this alive beyond the lock.
    if (lpServerInfo)
    {
        lpServerInfo->Reference();
    }
    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(lpServerInfo);
    return lpServerInfo;
}



VOID
ReleaseServerInfo(
    IN CServerInfo * lpServerInfo
    )

/*++

Routine Description:

    Release a CServerInfo by dereferencing it. If the reference count goes to
    zero, the CServerInfo will be destroyed

Arguments:

    lpServerInfo    - pointer to CServerInfo to release

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "ReleaseServerInfo",
                 "%#x [%q]",
                 lpServerInfo,
                 lpServerInfo->GetHostName()
                 ));

    lpServerInfo->Dereference();

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::PurgeServerInfoList(
    IN BOOL bForce
    )

/*++

Routine Description:

    Throw out any CServerInfo entries that have expired or any KEEP_ALIVE
    entries (for any CServerInfo) that have expired

Arguments:

    bForce  - TRUE if we forcibly remove entries which have not yet expired but
              which have a reference count of 1, else FALSE to remove only
              entries that have expired

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeServerInfoList",
                 "%B",
                 bForce
                 ));

    if (!LockSerializedList(&_ServerInfoList))
    {
        // Can't purge list if unable to obtain the lock.
        goto quit;
    }

    PLIST_ENTRY pEntry = HeadOfSerializedList(&_ServerInfoList);
    PLIST_ENTRY pPrevious = (PLIST_ENTRY)SlSelf(&_ServerInfoList);

    while (TRUE) {
        if (pEntry == (PLIST_ENTRY)SlSelf(&_ServerInfoList)) {
            break;
        }

        CServerInfo * pServerInfo;

        //pServerInfo = (CServerInfo *)pEntry;
        //pServerInfo = CONTAINING_RECORD(pEntry, CONNECTION_LIMIT, m_List);
        pServerInfo = ContainingServerInfo(pEntry);

        BOOL deleted = FALSE;

        if (pServerInfo->ReferenceCount() == 1) {
            if (bForce || pServerInfo->Expired()) {
//dprintf("purging server info entry for %q\n", pServerInfo->GetHostName());
                deleted = pServerInfo->Dereference();
            } else {
                pServerInfo->PurgeKeepAlives(PKA_NO_FORCE);
            }
        }
        if (!deleted) {
            pPrevious = pEntry;
        }
        pEntry = pPrevious->Flink;
    }

    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Throw out any KEEP_ALIVE entries from any CServerInfo that have expired or
    which have failed authentication or which are unused, depending on dwForce

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeKeepAlives",
                 "%s [%d]",
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    if (!LockSerializedList(&_ServerInfoList))
    {
        goto quit;
    }

    PLIST_ENTRY pEntry = HeadOfSerializedList(&_ServerInfoList);

    while (pEntry != (PLIST_ENTRY)SlSelf(&_ServerInfoList)) {

        CServerInfo * lpServerInfo = ContainingServerInfo(pEntry);

        lpServerInfo->PurgeKeepAlives(dwForce);
        pEntry = pEntry->Flink;
    }

    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(0);
}


//
// methods
//


CServerInfo::CServerInfo(
    IN SERIALIZED_LIST * ServerInfoList,
    IN LPSTR lpszHostName,
    OUT DWORD* pdwError,
    IN DWORD dwService,
    IN DWORD dwMaxConnections
    )

/*++

Routine Description:

    CServerInfo constructor

Arguments:

    lpszHostName        - server for which to create CServerInfo

    dwService           - which service to create CServerInfo for

    dwMaxConnections    - maximum number of simultaneous connections to this
                          server

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::CServerInfo",
                 "%q, %s (%d), %d",
                 lpszHostName,
                 InternetMapService(dwService),
                 dwService,
                 dwMaxConnections
                 ));

    INIT_SERVER_INFO();

    m_ServerInfoList = ServerInfoList;
    *pdwError = ERROR_SUCCESS;

    InitializeListHead(&m_List);
    m_Expires = 0;
    m_Wrap = 0;
    m_ReferenceCount = 1;
    m_HostName = lpszHostName;
    if (!m_HostName.StringAddress())
    {
        goto error;
    }
    
    m_HostName.MakeLowerCase();
    m_Hash = CalculateHashValue(m_HostName.StringAddress());
    m_Services.Word = 0;
    m_HttpSupport.Word = 0;
    m_Flags.Word = 0;
    m_ProxyLink = NULL;

    INET_ASSERT(dwService == INTERNET_SERVICE_HTTP);
    SetHTTP();

    //
    // only initialize the keep-alive and connection limit lists if we are
    // creating the server info entry for a HTTP server (or CERN proxy)
    //

    //
    // BUGBUG - we only want to do this on demand
    //

    //if (IsHTTP()) {
    InitializeSerializedList(&m_KeepAliveList);
    SetKeepAliveListInitialized();

    //
    // the maximum number of connections per server is initialized to the
    // default (registry) value unless overridden by the caller
    //

    if (dwMaxConnections == 0) 
    {
        dwMaxConnections = DEFAULT_MAX_CONNECTIONS_PER_SERVER;
    }
    
    m_ConnectionLimit = dwMaxConnections;
    //} else {
    //    m_ConnectionLimit = UNLIMITED_CONNECTIONS;
    //}
    //dprintf("*** %s: limit = %d\n", GetHostName(), m_ConnectionLimit);
    //
    // BUGBUG - only create event if limiting connections. Need method to manage
    //          connection limit count/event creation
    //

    m_NewLimit = m_ConnectionLimit;
    m_ConnectionsAvailable = m_ConnectionLimit;
    //m_ActiveConnections = 0;
    m_LastActiveTime = 0;
    m_ConnectTime = (DWORD)-1;
    m_RTT = 0;
    m_dwError = ERROR_SUCCESS;

    //
    // add to the global list. We are assuming here that the caller has already
    // checked for dupes
    //

    if (!InsertAtHeadOfSerializedList(m_ServerInfoList, &m_List))
        *pdwError = ERROR_NOT_ENOUGH_MEMORY;

quit:
    DEBUG_LEAVE(0);
    return;

error:
    *pdwError = ERROR_NOT_ENOUGH_MEMORY;
    goto quit;
    
}


CServerInfo::~CServerInfo()

/*++

Routine Description:

    CServerInfo destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::~CServerInfo",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();

    //GlobalServerInfoDeAllocCount++;

    // unlink if we have a nested obj
    if ( m_ProxyLink )
    {
        CServerInfo *pDerefObj = NULL;

        // will leak if unable to dereference
        if (LockSerializedList(m_ServerInfoList))
        {
            pDerefObj = m_ProxyLink;
            m_ProxyLink = NULL;
            UnlockSerializedList(m_ServerInfoList);
        }

        if (pDerefObj)
        {
            pDerefObj->Dereference();
        }
    }

    RemoveFromSerializedList(m_ServerInfoList, &m_List);

    INET_ASSERT(m_ReferenceCount == 0);

    if (IsKeepAliveListInitialized() && LockSerializedList(&m_KeepAliveList))
    {
        while (!IsSerializedListEmpty(&m_KeepAliveList))
        {
//dprintf("%#x ~S-I killing K-A %#x\n", GetCurrentThreadId(), HeadOfSerializedList(&m_KeepAliveList));

            LPVOID pEntry = SlDequeueHead(&m_KeepAliveList);

            INET_ASSERT(pEntry != NULL);

            if (pEntry != NULL) {

                ICSocket * pSocket = ContainingICSocket(pEntry);

//dprintf("~CServerInfo: destroying socket %#x\n", pSocket->GetSocket());
                pSocket->Destroy();
            }
        }
        UnlockSerializedList(&m_KeepAliveList);
        TerminateSerializedList(&m_KeepAliveList);
    }

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::Reference(
    VOID
    )

/*++

Routine Description:

    Increments the reference count for the CServerInfo

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Reference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    InterlockedIncrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    DEBUG_LEAVE(0);
}


BOOL
CServerInfo::Dereference(
    VOID
    )

/*++

Routine Description:

    Dereferences the SESSION_INFO. If the reference count goes to zero then this
    entry is deleted. If the reference count goes to 1 then the expiry timer is
    started

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - entry was deleted

        FALSE   - entry was not deleted

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Dereference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    //
    // we need to grab the list - we may be removing this entry or updating
    // the reference count and expiry fields which must be done atomically
    //

    SERIALIZED_LIST *   ServerInfoList = m_ServerInfoList;
    BOOL deleted = FALSE;

    if (!LockSerializedList(ServerInfoList))
        goto quit;

    LONG result = InterlockedDecrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    if (result == 0) {
        delete this;
        deleted = TRUE;
    } else if (result == 1) {

        //
        // start expiration proceedings...
        //

        SetExpiryTime();
    }

    UnlockSerializedList(ServerInfoList);

quit:
    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD    
CServerInfo::SetCachedProxyServerInfo(
    IN CServerInfo * pProxyServer,
    IN DWORD dwProxyVersion,
    IN BOOL fUseProxy,
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    IN INTERNET_SCHEME ProxyScheme,
    IN INTERNET_PORT ProxyPort
    )
/*++

Routine Description:

    If the Version information match up, copies
     the proxy information and links this server object
     to the appopriate proxy server object

    Assumes that this is called on successful use of the proxy
      object.

Arguments:

    None.

Return Value:

    DWORD
        ERROR_SUCCESS

        ERROR_NOT_ENOUGH_MEMORY   - entry was not deleted because there
                                    wasn't available memory to obtain lock

--*/


{
    DWORD error=ERROR_SUCCESS;

    if (!LockSerializedList(m_ServerInfoList))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if ( dwProxyVersion != GlobalProxyVersionCount ) 
    {
        SetProxyScriptCached(FALSE);
        goto cleanup; // bail, we don't accept out of date additions to the cache
    }

    if ( m_ProxyLink )
    {
        if ( IsProxyScriptCached() && 
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort &&
             fUseProxy )
        {
            if ( pProxyServer == m_ProxyLink ) {            
                INET_ASSERT(dwProxyVersion == GlobalProxyVersionCount);
                m_dwProxyVersion = dwProxyVersion; // we're now up to date
                goto cleanup; // match, no version or host changes
            }

            INET_ASSERT(pProxyServer != m_ProxyLink );            
        }
        //
        // unlink, because we have a new entry to save,
        //  and the previous entry is bad
        //
        m_ProxyLink->Dereference();
        m_ProxyLink = NULL;
    }

    //
    // Add new cached entry
    //

    SetProxyScriptCached(TRUE);

    m_HostScheme     = HostScheme;
    m_HostPort       = HostPort;

    m_dwProxyVersion = dwProxyVersion; // we're now up to date

    if ( fUseProxy )
    {
        INET_ASSERT(this != pProxyServer);

        m_ProxyLink = pProxyServer;
        m_ProxyLink->Reference();

        m_ProxyLink->m_HostScheme = ProxyScheme;
        m_ProxyLink->m_HostPort   = ProxyPort;

        switch (ProxyScheme)
        {
            case INTERNET_SCHEME_HTTP:
                m_ProxyLink->SetCernProxy();
                break;
            case INTERNET_SCHEME_SOCKS: 
                m_ProxyLink->SetSocksGateway();
                break;
        }
    }

cleanup:

    UnlockSerializedList(m_ServerInfoList);        

quit:

    return error;
}

CServerInfo * 
CServerInfo::GetCachedProxyServerInfo(
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    OUT BOOL *pfCachedEntry
    )

/*++

Routine Description:

   Retrieves a cached server object, that indicates
    a probable proxy to use

   On Success, the return has an additional increment
    on its ref count, assumition that caller derefs

Arguments:

    None.

Return Value:

    CServerInfo *     
        NULL on failure

--*/

{
    CServerInfo *pProxyServer = NULL;

    if (!LockSerializedList(m_ServerInfoList))
        return NULL;

    *pfCachedEntry = FALSE; 

    if ( IsProxyScriptCached() )
    {        
        //
        // Examine Version Count
        //

        if ( GlobalProxyVersionCount == m_dwProxyVersion &&
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort
             )
        {
            *pfCachedEntry = TRUE;

            if ( m_ProxyLink ) {
                // matched cached entry
                m_ProxyLink->Reference();
                pProxyServer = m_ProxyLink;                    
            }
        }
        else
        {
            // version is expired, remove reference
            SetProxyScriptCached(FALSE);
            if ( m_ProxyLink ) {                
                m_ProxyLink->Dereference();
                m_ProxyLink = NULL;
            }
        }            
    }
        
    UnlockSerializedList(m_ServerInfoList);        
    return pProxyServer;
}

BOOL    
CServerInfo::CopyCachedProxyInfoToProxyMsg(
    IN OUT AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )

/*++

Routine Description:

   Retrieves Cached Proxy info from object

Arguments:

    None.

Return Value:

    BOOL
        TRUE - sucess

--*/

{
    BOOL fSuccess = FALSE;

    // really only need to lock to proctect m_HostPort && m_HostScheme
    if (!LockSerializedList(m_ServerInfoList))
        return FALSE;

    pQueryForProxyInfo->SetUseProxy(FALSE);
    pQueryForProxyInfo->_lpszProxyHostName =  
        m_HostName.StringAddress() ? 
        NewString(m_HostName.StringAddress()) :
        NULL;

    if ( pQueryForProxyInfo->_lpszProxyHostName != NULL ) {
        // copy out cached entry to proxy message structure
        pQueryForProxyInfo->_nProxyHostPort        = m_HostPort;
        pQueryForProxyInfo->_tProxyScheme          = m_HostScheme;
        pQueryForProxyInfo->_bFreeProxyHostName    = TRUE;
        pQueryForProxyInfo->_dwProxyHostNameLength = 
            strlen((pQueryForProxyInfo)->_lpszProxyHostName);
        pQueryForProxyInfo->SetUseProxy(TRUE);
        fSuccess = TRUE; // success
    }

    UnlockSerializedList(m_ServerInfoList);        
    return fSuccess;
}




VOID
CServerInfo::UpdateConnectTime(
    IN DWORD dwConnectTime
    )

/*++

Routine Description:

    Calculates average connect time

Arguments:

    dwConnectTime   - current connect time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectTime",
                 "{%q} %d",
                 GetHostName(),
                 dwConnectTime
                 ));

    DWORD connectTime = m_ConnectTime;

    if (connectTime == (DWORD)-1) {
        connectTime = dwConnectTime;
    } else {
        connectTime = (connectTime + dwConnectTime) / 2;
    }
//dprintf("%s: connect time = %d, ave = %d\n", GetHostName(), dwConnectTime, connectTime);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average connect time = %d mSec\n",
                connectTime
                ));

    InterlockedExchange((LPLONG)&m_ConnectTime, connectTime);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateRTT(
    IN DWORD dwRTT
    )

/*++

Routine Description:

    Calculates rolling average round-trip time

Arguments:

    dwRTT   - current round-trip time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateRTT",
                 "{%q} %d",
                 GetHostName(),
                 dwRTT
                 ));

    DWORD RTT = m_RTT;

    if (RTT == 0) {
        RTT = dwRTT;
    } else {
        RTT = (RTT + dwRTT) / 2;
    }
//dprintf("%s: RTT = %d, ave = %d\n", GetHostName(), dwRTT, RTT);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average round trip time = %d mSec\n",
                RTT
                ));

    InterlockedExchange((LPLONG)&m_RTT, RTT);

    DEBUG_LEAVE(0);
}



DWORD
CFsm_GetConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_GetConnection state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
//dprintf("%#x: %s FSM %#x state %s\n", GetCurrentThreadId(), Fsm->MapType(), Fsm, Fsm->MapState());
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_GetConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    CServerInfo * pServerInfo = (CServerInfo *)Fsm->GetContext();
    CFsm_GetConnection * stateMachine = (CFsm_GetConnection *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        stateMachine->StartTimer();

        //
        // fall through
        //

    case FSM_STATE_CONTINUE:

#ifdef NEW_CONNECTION_SCHEME
    case FSM_STATE_ERROR:
#endif
        error = pServerInfo->GetConnection_Fsm(stateMachine);
        break;

#ifndef NEW_CONNECTION_SCHEME

    case FSM_STATE_ERROR:

        INET_ASSERT((Fsm->GetError() == ERROR_WINHTTP_TIMEOUT)
                    || (Fsm->GetError() == ERROR_WINHTTP_OPERATION_CANCELLED));

        pServerInfo->RemoveWaiter((DWORD_PTR)Fsm);
        error = Fsm->GetError();
        Fsm->SetDone();
//dprintf("%#x: FSM_STATE_ERROR - %d\n", GetCurrentThreadId(), error);
        break;

#endif

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
CServerInfo::GetConnection_Fsm(
    IN CFsm_GetConnection * Fsm
    )

/*++

Routine Description:

    Tries to get a connection of requested type for caller. If no connection is
    available then one of the following happens:

        * If there are available keep-alive connections of a different type then
          one is closed and the caller allowed to create a new connection

        * If this is an async request, the FSM is blocked and the thread returns
          to the pool if a worker, or back to the app if an app thread

        * If this is a sync request, we wait on an event for a connection to be
          made available, or the connect timeout to elapse

Arguments:

    Fsm - get connection FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Depending on *lplpSocket, we either returned the socket to
                    use, or its okay to create a new connection

                  ERROR_IO_PENDING
                    Request will complete asynchronously

        Failure - ERROR_WINHTTP_TIMEOUT
                    Failed to get connection in time allowed

                  ERROR_WINHTTP_INTERNAL_ERROR
                    Something unexpected happened

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::GetConnection_Fsm",
                 "{%q [%d+%d/%d]} %#x(%#x, %d, %d)",
                 GetHostName(),
                 m_ConnectionsAvailable,
                 ElementsOnSerializedList(&m_KeepAliveList),
                 m_ConnectionLimit,
                 Fsm,
                 Fsm->m_dwSocketFlags,
                 Fsm->m_nPort,
                 Fsm->m_dwTimeout
                 ));

    PERF_ENTER(GetConnection);

    BOOL bFound = FALSE;
    DWORD error = ERROR_SUCCESS;
    CFsm_GetConnection & fsm = *Fsm;
    ICSocket * pSocket = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    HANDLE hEvent = NULL;
    BOOL bUnlockList = TRUE;
    BOOL bKeepAliveWaiters;

    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                GetHandleType() == TypeHttpRequestHandle);

    if ((lpThreadInfo == NULL) || (lpThreadInfo->hObjectMapped == NULL)) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    BOOL bAsyncRequest;

    bAsyncRequest = lpThreadInfo->IsAsyncWorkerThread
                    || ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                        IsAsyncHandle();

    *fsm.m_lplpSocket = NULL;

try_again:

    bUnlockList = TRUE;

    //
    // use m_Waiters to serialize access. N.B. - we will acquire m_KeepAliveList
    // from within m_Waiters
    //

    if (!m_Waiters.Acquire()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }
    bKeepAliveWaiters = KeepAliveWaiters();
    if (fsm.m_dwSocketFlags & SF_KEEP_ALIVE) {

        //
        // maintain requester order - if there are already waiters then queue
        // this request, else try to satisfy the requester. HOWEVER, only check
        // for existing requesters the FIRST time through. If we're here with
        // FSM_STATE_CONTINUE then we've been unblocked and we can ignore any
        // waiters that came after us
        //

        if ((fsm.GetState() == FSM_STATE_CONTINUE) || !bKeepAliveWaiters) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no current waiters for K-A connections\n"
                        ));

            while (pSocket = FindKeepAliveConnection(fsm.m_dwSocketFlags,
                                                     fsm.m_nPort,
                                                     fsm.m_lpszSecureTunnelHost)) {
                if (pSocket->IsReset() || pSocket->HasExpired()) {

                    DPRINTF("%#x: %#x: ********* socket %#x is closed already\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("K-A connection %#x [%#x/%d] is reset (%B) or expired (%B)\n",
                                pSocket,
                                pSocket->GetSocket(),
                                pSocket->GetSourcePort(),
                                pSocket->IsReset(),
                                pSocket->HasExpired()
                                ));

                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
//dprintf("GetConnection: destroying reset socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                } else {

                    DPRINTF("%#x: %#x: *** matched %#x, %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags()
                            );

                    break;
                }
            }
            if (pSocket == NULL) {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("no available K-A connections\n"
                            ));

                /*
                //
                // if all connections are in use as keep-alive connections then
                // since we're here, we want a keep-alive connection that doesn't
                // match the currently available keep-alive connections. Terminate
                // the oldest keep-alive connection (at the head of the queue)
                // and generate a new connection
                //

                LockSerializedList(&m_KeepAliveList);
                if (ElementsOnSerializedList(&m_KeepAliveList) == m_ConnectionLimit) {
                    pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
                    pSocket->Destroy();
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                }
                UnlockSerializedList(&m_KeepAliveList);
                */
            }
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("%d waiters for K-A connection to %q\n",
                        ElementsOnSerializedList(&m_KeepAliveList),
                        GetHostName()
                        ));

        }
    }

    //
    // if we found a matching keep-alive connection or we are not limiting
    // connections then we're done
    //

    if ((pSocket != NULL) || UnlimitedConnections()) {

        INET_ASSERT(error == ERROR_SUCCESS);

        goto exit;
    }

    //
    // no keep-alive connections matched, or there are already waiters for
    // keep-alive connections
    //

    INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

    if (m_ConnectionsAvailable > 0) {

        if (fsm.m_lpszSecureTunnelHost)
            goto exit;  // don't create a connection here for SSL tunneling

        //
        // can create a connection
        //

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("OK to create new connection\n"
                    ));

        DPRINTF("%#x: %#x: *** %s OK to create connection %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                GetHostName(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        --m_ConnectionsAvailable;
    } else if (fsm.GetElapsedTime() > fsm.m_dwTimeout) {
        error = ERROR_WINHTTP_TIMEOUT;
    } else {
        
        //
        // if there are keep-alive connections but no keep-alive waiters
        // then either we don't want a keep-alive connection, or the ones
        // available don't match our requirements.
        // If we need a connection of a different type - e.g. SSL when all
        // we have is non-SSL then close a connection & generate a new one.
        // If we need a non-keep-alive connection then its okay to return
        // a current keep-alive connection, the understanding being that the
        // caller will not add Connection: Keep-Alive header (HTTP 1.0) or
        // will add Connection: Close header (HTTP 1.1)
        //

        //
        // BUGBUG - what about waiters for non-keep-alive connections?
        //
        // scenario - limit of 1 connection:
        //
        //  A. request for k-a
        //      continue & create connection
        //  B. request non-k-a
        //      none available; wait
        //  C. release k-a connection; unblock sync waiter B
        //  D. request non-k-a
        //      k-a available; return it; caller converts to non-k-a
        //  E. unblocked waiter B request non-k-a
        //      none available; wait
        //
        // If this situation continues, eventually B will time-out, whereas it
        // could have had the connection taken by D. Request D is younger and
        // therefore can afford to wait while B continues with the connection
        //

        BOOL fHaveConnection = FALSE;

        if (!bKeepAliveWaiters || (fsm.GetState() == FSM_STATE_CONTINUE)) {
            if (!LockSerializedList(&m_KeepAliveList)) {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
            if (ElementsOnSerializedList(&m_KeepAliveList) != 0) {
                pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                fHaveConnection = TRUE;

#define SOCK_FLAGS  (SF_ENCRYPT | SF_DECRYPT | SF_SECURE | SF_TUNNEL)

                DWORD dwSocketTypeFlags = pSocket->GetFlags() & SOCK_FLAGS;
                DWORD dwRequestTypeFlags = fsm.m_dwSocketFlags & SOCK_FLAGS;

                if ((dwSocketTypeFlags ^ dwRequestTypeFlags)
                    || (fsm.m_nPort != pSocket->GetPort())) {

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("different socket types (%#x, %#x) or ports (%d, %d) requested\n",
                                fsm.m_dwSocketFlags,
                                pSocket->GetFlags(),
                                fsm.m_nPort,
                                pSocket->GetPort()
                                ));

                    DPRINTF("%#x: %#x: *** closing socket %#x: %#x vs. %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags(),
                            fsm.m_dwSocketFlags
                            );

                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
//dprintf("GetConnection: destroying different type socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    // If we were trying to wait for established SSL tunnel,
                    // but one wasn't found, then this connection is open
                    // for anyone.
                    if (!UnlimitedConnections() && fsm.m_lpszSecureTunnelHost) {
                        ++m_ConnectionsAvailable;
                    }
                } else {

                    DPRINTF("%#x: %#x: *** returning k-a connection %#x as non-k-a\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );

                }
                CHECK_CONNECTION_COUNT();
            }
            UnlockSerializedList(&m_KeepAliveList);
            if (fHaveConnection) {
                goto exit;
            }
        }

        DPRINTF("%#x: %#x: blocking %s FSM %#x state %s %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                Fsm->MapType(),
                Fsm,
                Fsm->MapState(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        //
        // we have to wait for a connection to become available. If we are an
        // async request then we queue this FSM & return the thread to the pool
        // or, if app thread, return pending indication to the app. If this is
        // a sync request (in an app thread) then we block on an event waiting
        // for a connection to become available
        //

        if (!bAsyncRequest) {

            //
            // create unnamed, initially unsignalled, auto-reset event
            //

            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (hEvent == NULL) {
                error = GetLastError();
                goto exit;
            }
        }

        CConnectionWaiter * pWaiter;
        DWORD dwStatus = ERROR_SUCCESS;

#if INET_DEBUG

        for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
             pWaiter != (CConnectionWaiter *)m_Waiters.Self();
             pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

            INET_ASSERT(pWaiter->Id() != (DWORD_PTR)(bAsyncRequest ? (DWORD_PTR)Fsm : lpThreadInfo->ThreadId));
        }
#endif

        pWaiter = New CConnectionWaiter(&m_Waiters,
                                        !bAsyncRequest,
                                        (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                                            ? TRUE
                                            : FALSE,
                                        bAsyncRequest
                                            ? (DWORD_PTR)Fsm
                                            : lpThreadInfo->ThreadId,
                                        hEvent,

                                        //
                                        // priority in request handle object
                                        // controls relative position in list
                                        // of waiters
                                        //

                                        ((HTTP_REQUEST_HANDLE_OBJECT *)
                                            lpThreadInfo->hObjectMapped)->
                                                GetPriority(),

                                        &dwStatus
                                        );

        DPRINTF("%#x: %#x: new waiter %#x: as=%B, K-A=%B, id=%#x, hE=%#x, pri=%d, status=%#x, sf=%#x, preq=%#x ssl=%s\n",
                GetCurrentThreadId(),
                Fsm,
                pWaiter,
                bAsyncRequest,
                (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                    ? TRUE
                    : FALSE,
                bAsyncRequest
                    ? (DWORD_PTR)Fsm
                    : lpThreadInfo->ThreadId,
                hEvent,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                    GetPriority(),
                dwStatus,
                fsm.m_dwSocketFlags,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped),
                fsm.m_lpszSecureTunnelHost ? fsm.m_lpszSecureTunnelHost : ""
                );

        if (pWaiter == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        else if (dwStatus != ERROR_SUCCESS) {
            error = dwStatus;
            delete pWaiter;  // free since it wasn't inserted
            goto exit;
        }
        
        if (bAsyncRequest) {

            //
            // ensure that when the FSM is unblocked normally, the new state
            // is STATE_CONTINUE
            //

            Fsm->SetState(FSM_STATE_CONTINUE);
            error = BlockWorkItem(Fsm,
                                  (DWORD_PTR)pWaiter,
                                  fsm.m_dwTimeout
                                  );
            if (error == ERROR_SUCCESS) {
                error = ERROR_IO_PENDING;
            }
        } 
        else
        {
            m_Waiters.Release();
            bUnlockList = FALSE;

            DPRINTF("%#x: %#x: %s FSM %#x %s waiting %d msec\n",
                    GetCurrentThreadId(),
                    Fsm,
                    Fsm->MapType(),
                    Fsm,
                    Fsm->MapState(),
                    fsm.m_dwTimeout
                    );

            DWORD dwWaitTime = (fsm.m_dwTimeout != INFINITE) ? 
                                (fsm.m_dwTimeout - fsm.GetElapsedTime()) : 
                                  INFINITE;

            if (((int)dwWaitTime <= 0) && (dwWaitTime != INFINITE)) {

                DEBUG_PRINT(SESSION,
                            ERROR,
                            ("SYNC wait timed out (%d mSec)\n",
                            fsm.m_dwTimeout
                            ));

                error = ERROR_WINHTTP_TIMEOUT;
            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("waiting %d mSec for SYNC event %#x\n",
                            dwWaitTime,
                            hEvent
                            ));

                //
                // we'd better not be doing a sync wait if we are in the
                // context of an app thread making an async request
                //

                INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                            || !((INTERNET_HANDLE_OBJECT *)lpThreadInfo->
                                hObjectMapped)->IsAsyncHandle());

                //INET_ASSERT(dwWaitTime <= 60000);

                error = WaitForSingleObject(hEvent, dwWaitTime);

                DPRINTF("%#x: %#x: sync waiter unblocked - error = %d\n",
                        GetCurrentThreadId(),
                        Fsm,
                        error
                        );

            }
            if (error == STATUS_TIMEOUT) {

                DPRINTF("%#x: %#x: %s: %d+%d/%d: timed out %#x (%s FSM %#x %s)\n",
                        GetCurrentThreadId(),
                        Fsm,
                        GetHostName(),
                        m_ConnectionsAvailable,
                        ElementsOnSerializedList(&m_KeepAliveList),
                        m_ConnectionLimit,
                        GetCurrentThreadId(),
                        Fsm->MapType(),
                        Fsm,
                        Fsm->MapState()
                        );

                RemoveWaiter(lpThreadInfo->ThreadId);
                error = ERROR_WINHTTP_TIMEOUT;
            }

            BOOL bOk;

            bOk = CloseHandle(hEvent);

            INET_ASSERT(bOk);

            if (error == WAIT_OBJECT_0) {

                DPRINTF("%#x: %#x: sync requester trying again\n",
                        GetCurrentThreadId(),
                        Fsm
                        );

                fsm.SetState(FSM_STATE_CONTINUE);
                goto try_again;
            }
        }
    }

exit:

    //
    // if we are returning a (keep-alive) socket that has a different blocking
    // mode from that requested, change it
    //

    if (pSocket != NULL) {
        if ((pSocket->GetFlags() & SF_NON_BLOCKING)
            ^ (fsm.m_dwSocketFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("different blocking modes requested: %#x, %#x\n",
                        fsm.m_dwSocketFlags,
                        pSocket->GetFlags()
                        ));

            DPRINTF("%#x: %#x: *** changing socket %#x to %sBLOCKING\n",
                    GetCurrentThreadId(),
                    Fsm,
                    pSocket->GetSocket(),
                    fsm.m_dwSocketFlags & SF_NON_BLOCKING ? "NON-" : ""
                    );

            if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                pSocket->SetNonBlockingMode(fsm.m_dwSocketFlags & SF_NON_BLOCKING);
            }
        }
        *fsm.m_lplpSocket = pSocket;
    }

    if (bUnlockList) {
        m_Waiters.Release();
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DPRINTF("%#x: %#x: %s: %d+%d/%d: get: %d, %#x, %d\n",
            GetCurrentThreadId(),
            Fsm,
            GetHostName(),
            m_ConnectionsAvailable,
            ElementsOnSerializedList(&m_KeepAliveList),
            m_ConnectionLimit,
            error,
            pSocket ? pSocket->GetSocket() : 0,
            m_Waiters.Count()
            );

    PERF_LEAVE(GetConnection);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CServerInfo::ReleaseConnection(
    IN ICSocket * lpSocket OPTIONAL
    )

/*++

Routine Description:

    Returns a keep-alive connection to the pool, or allows another requester to
    create a connection

Arguments:

    lpSocket    - pointer to ICSocket if we are returning a keep-alive connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::ReleaseConnection",
                 "{%q [%d+%d/%d]} %#x [%#x]",
                 GetHostName(),
                 AvailableConnections(),
                 KeepAliveConnections(),
                 ConnectionLimit(),
                 lpSocket,
                 lpSocket ? lpSocket->GetSocket() : 0
                 ));

    PERF_ENTER(ReleaseConnection);

    DWORD error = ERROR_SUCCESS;
    BOOL bRelease = FALSE;

    if (!m_Waiters.Acquire()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // quite often (at least with catapult proxy based on IIS) the server may
    // drop the connection even though it indicated it would keep it open. This
    // typically happens on 304 (frequent) and 302 (less so) responses. If we
    // determine the server has dropped the connection then throw it away and
    // allow the app to create a new one
    //

    if (lpSocket != NULL) {
        if (lpSocket->IsClosed() || lpSocket->IsReset()) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("socket %#x already dead - throwing it out\n",
                        lpSocket->GetSocket()
                        ));

            DPRINTF("%#x: socket %#x: already reset\n",
                    GetCurrentThreadId(),
                    lpSocket->GetSocket()
                    );

//dprintf("ReleaseConnection: destroying already closed socket %#x\n", lpSocket->GetSocket());
            BOOL bDestroyed = lpSocket->Dereference();

            INET_ASSERT(bDestroyed);

            lpSocket = NULL;
        } else {

            //
            // if we are returning a keep-alive socket, put it in non-blocking
            // mode if not already. Typically, Internet Explorer uses non-blocking
            // sockets. In the infrequent cases where we want a blocking socket
            // - mainly when doing java downloads - we will convert the socket
            // to blocking mode when we get it from the pool
            //

            if (!lpSocket->IsNonBlocking()) {

                DPRINTF("%#x: ***** WARNING: releasing BLOCKING k-a socket %#x\n",
                        GetCurrentThreadId(),
                        lpSocket->GetSocket()
                        );

                if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                    lpSocket->SetNonBlockingMode(TRUE);
                }
            }
        }
    }
    if (lpSocket != NULL) {

        DPRINTF("%#x: releasing K-A %#x (%d+%d/%d)\n",
                GetCurrentThreadId(),
                lpSocket ? lpSocket->GetSocket() : 0,
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        INET_ASSERT(lpSocket->IsOpen());
        INET_ASSERT(!lpSocket->IsOnList());
        //INET_ASSERT(!lpSocket->IsReset());

        lpSocket->SetKeepAlive();

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("releasing keep-alive socket %#x\n",
                    lpSocket->GetSocket()
                    ));

        lpSocket->SetExpiryTime(GlobalKeepAliveSocketTimeout);

        INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, lpSocket->List()));

        if (!InsertAtTailOfSerializedList(&m_KeepAliveList, lpSocket->List()))
        {
            DEBUG_PRINT(SESSION,
                        INFO,
                        ("not enough memory to release %#x to k-a pool\n",
                        lpSocket->GetSocket()
                        ));

            lpSocket->Dereference();

            if (!UnlimitedConnections())
            {
                ++m_ConnectionsAvailable;
            }
        }

        lpSocket = NULL;

        INET_ASSERT(UnlimitedConnections()
            ? TRUE
            : (KeepAliveConnections() <= ConnectionLimit()));

        bRelease = TRUE;
    } else {

        DPRINTF("%#x: releasing connection (%d+%d/%d)\n",
                GetCurrentThreadId(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        if (!UnlimitedConnections()) {
            ++m_ConnectionsAvailable;
        }

        CHECK_CONNECTION_COUNT();

        bRelease = TRUE;
    }
    if (bRelease && !UnlimitedConnections()) {

        CHECK_CONNECTION_COUNT();

        CConnectionWaiter * pWaiter = (CConnectionWaiter *)m_Waiters.RemoveHead();

        if (pWaiter != NULL) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("unblocking %s waiter %#x, pri=%d\n",
                        pWaiter->IsSync() ? "SYNC" : "ASYNC",
                        pWaiter->Id(),
                        pWaiter->GetPriority()
                        ));

            DPRINTF("%#x: Unblocking %s connection waiter %#x, pri=%d\n",
                    GetCurrentThreadId(),
                    pWaiter->IsSync() ? "Sync" : "Async",
                    pWaiter->Id(),
                    pWaiter->GetPriority()
                    );

            if (pWaiter->IsSync()) {
                pWaiter->Signal();
            } else {

                DWORD n = UnblockWorkItems(1, (DWORD_PTR)pWaiter, ERROR_SUCCESS);

                //INET_ASSERT(n == 1);
            }
            delete pWaiter;
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no waiters\n"
                        ));

            DPRINTF("%#x: !!! NOT unblocking connection waiter\n",
                    GetCurrentThreadId()
                    );

        }
    } else {

        DPRINTF("%#x: !!! NOT releasing or unlimited?\n",
                GetCurrentThreadId()
                );

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("bRelease = %B, UnlimitedConnections() = %B\n",
                    bRelease,
                    UnlimitedConnections()
                    ));

    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("avail+k-a/limit = %d+%d/%d\n",
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }

    m_Waiters.Release();

quit:
    PERF_LEAVE(ReleaseConnection);

    DEBUG_LEAVE(error);

    DPRINTF("%#x: %s: %d+%d/%d: rls %#x: %d, %d\n",
            GetCurrentThreadId(),
            GetHostName(),
            AvailableConnections(),
            KeepAliveConnections(),
            ConnectionLimit(),
            lpSocket ? lpSocket->GetSocket() : 0,
            error,
            m_Waiters.Count()
            );

    return error;
}



VOID
CServerInfo::RemoveWaiter(
    IN DWORD_PTR dwId
    )

/*++

Routine Description:

    Removes a CConnectionWaiter corresponding to the FSM

Arguments:

    dwId    - waiter id to match

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::RemoveWaiter",
                 "%#x",
                 dwId
                 ));

    if (!m_Waiters.Acquire())
        goto quit;

    CConnectionWaiter * pWaiter;
    BOOL found = FALSE;

    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->Id() == dwId) {
            m_Waiters.Remove((CPriorityListEntry *)pWaiter);
            delete pWaiter;
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

quit:
    //INET_ASSERT(found);

    DEBUG_LEAVE(0);
}

//
// private CServerInfo methods
//


ICSocket *
CServerInfo::FindKeepAliveConnection(
    IN DWORD dwSocketFlags,
    IN INTERNET_PORT nPort,
    IN LPSTR pszTunnelServer
    )

/*++

Routine Description:

    Find a keep-alive connection with the requested attributes and port number

Arguments:

    dwSocketFlags   - socket type flags (e.g. SF_SECURE)

    nPort           - port to server

    pszTunnelServer - hostname of server through SSL tunnel, or
                      NULL if not checked.

Return Value:

    ICSocket *

--*/

{
    DPRINTF("%#x: *** looking for K-A connection\n", GetCurrentThreadId());

    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "CServerInfo::FindKeepAliveConnection",
                 "{%q} %#x, %d",
                 GetHostName(),
                 dwSocketFlags,
                 nPort
                 ));

    ICSocket * pSocket = NULL;
    BOOL bFound = FALSE;

    //
    // don't check whether socket is non-blocking - we only really want to match
    // on secure/non-secure. Possible flags to check on are:
    //
    //  SF_ENCRYPT          - should be subsumed by SF_SECURE
    //  SF_DECRYPT          - should be subsumed by SF_SECURE
    //  SF_NON_BLOCKING     - this isn't criterion for match
    //  SF_CONNECTIONLESS   - not implemented?
    //  SF_AUTHORIZED       - must be set if authorized & in pool
    //  SF_SECURE           - opened for SSL/PCT if set
    //  SF_KEEP_ALIVE       - must be set
    //  SF_TUNNEL           - must be set if we're looking for a CONNECT tunnel to proxy
    //

    dwSocketFlags &= ~SF_NON_BLOCKING;

    if (!LockSerializedList(&m_KeepAliveList))
        goto quit;

    PLIST_ENTRY pEntry;

    for (pEntry = HeadOfSerializedList(&m_KeepAliveList);
         pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
         pEntry = pEntry->Flink) {

        pSocket = ContainingICSocket(pEntry);

        INET_ASSERT(pSocket->IsKeepAlive());

        //
        // We make sure the socket we request is the correct socket,
        //  Match() is a bit confusing and needs a bit of explaining,
        //  Match IS NOT AN EXACT MATCH, it mearly checks to make sure 
        //  that the requesting flags (dwSocketFlags) are found in the 
        //  socket flags.  So this can lead to a secure socket being returned
        //  on a non-secure open request, now realistically this doesn't happen
        //  because of the port number.  But in the case of tunnelling this may be
        //  an issue, so we add an additional check to make sure that we only
        //  get a tunneled socket to a proxy if we specifically request one.
        //

        if (pSocket->Match(dwSocketFlags)
        && (pSocket->GetPort() == nPort)
        &&  pSocket->MatchTunnelSemantics(dwSocketFlags, pszTunnelServer)
        &&  RemoveFromSerializedList(&m_KeepAliveList, pSocket->List())) {

            INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, pSocket->List()));

            bFound = TRUE;

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("returning keep-alive socket %#x\n",
                        pSocket->GetSocket()
                        ));

            DPRINTF("%#x: *** %s keep-alive connection %#x (%d/%d), wantf=%#x, gotf=%#x\n",
                    GetCurrentThreadId(),
                    GetHostName(),
                    pSocket->GetSocket(),
                    AvailableConnections(),
                    ConnectionLimit(),
                    dwSocketFlags,
                    pSocket->GetFlags()
                    );

            break;
        }
    }
    UnlockSerializedList(&m_KeepAliveList);
    if (!bFound) {
        pSocket = NULL;
    }

quit:
    DEBUG_LEAVE(pSocket);

    return pSocket;
}


BOOL
CServerInfo::KeepAliveWaiters(
    VOID
    )

/*++

Routine Description:

    Determine if any of the waiters on the list are for keep-alive connections

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Bool,
                 "CServerInfo::KeepAliveWaiters",
                 NULL
                 ));

    BOOL found = FALSE;
    CConnectionWaiter * pWaiter;

    if (!m_Waiters.Acquire())
        goto quit;

    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->IsKeepAlive()) {
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

quit:
    DEBUG_LEAVE(found);

    return found;
}



VOID
CServerInfo::UpdateConnectionLimit(
    VOID
    )

/*++

Routine Description:

    Change connection limit to new limit

    Assumes: 1. Caller has acquired this object before calling this function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectionLimit",
                 "{%q: %d=>%d (%d+%d)}",
                 GetHostName(),
                 ConnectionLimit(),
                 GetNewLimit(),
                 AvailableConnections(),
                 KeepAliveConnections()
                 ));

    LONG difference = GetNewLimit() - ConnectionLimit();

    //
    // BUGBUG - only handling increases in limit for now
    //

    INET_ASSERT(difference > 0);

    if (difference > 0) {
        m_ConnectionsAvailable += difference;
    }
    m_ConnectionLimit = m_NewLimit;

    DEBUG_PRINT(SESSION,
                INFO,
                ("%q: new: %d+%d/%d\n",
                GetHostName(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Purges any timed-out keep-alive connections

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
//dprintf("%#x PurgeKeepAlives(%d)\n", GetCurrentThreadId(), dwForce);
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::PurgeKeepAlives",
                 "{%q [ref=%d, k-a=%d]} %s [%d]",
                 GetHostName(),
                 ReferenceCount(),
                 KeepAliveConnections(),
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    if (IsKeepAliveListInitialized()) {

        INET_ASSERT(ReferenceCount() >= 1);

        if (!m_Waiters.Acquire())
            goto quit;

        if (!LockSerializedList(&m_KeepAliveList))
            goto Cleanup;

        PLIST_ENTRY last = (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
        DWORD ticks = GetTickCountWrap();

        for (PLIST_ENTRY pEntry = HeadOfSerializedList(&m_KeepAliveList);
            pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
            pEntry = last->Flink) {

            ICSocket * pSocket = ContainingICSocket(pEntry);
            BOOL bDelete;

            if (pSocket->IsReset()) {
//dprintf("%q: socket %#x/%d CLOSE-WAIT\n", GetHostName(), pSocket->GetSocket(), pSocket->GetSourcePort());
                bDelete = TRUE;
            } else if (dwForce == PKA_NO_FORCE) {
                bDelete = pSocket->HasExpired(ticks);
            } else if (dwForce == PKA_NOW) {
                bDelete = TRUE;
            } else if (dwForce == PKA_AUTH_FAILED) {
                bDelete = pSocket->IsAuthorized();
            } else {
                INET_ASSERT(FALSE); // invalid value for dwForce!
                bDelete = TRUE;
            }
            if (bDelete) {
//dprintf("%q: socket %#x/%d. Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
//        GetHostName(),
//        pSocket->GetSocket(),
//        pSocket->GetSourcePort(),
//        pSocket->IsReset(),
//        pSocket->HasExpired(ticks),
//        (dwForce == PKA_NOW),
//        (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
//        );

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("purging keep-alive socket %#x/%d: Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->IsReset(),
                            pSocket->HasExpired(ticks),
                            (dwForce == PKA_NOW),
                            (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
                            ));

                if (RemoveFromSerializedList(&m_KeepAliveList, pEntry))
                {
                    BOOL bDestroyed;

                    bDestroyed = pSocket->Dereference();

                    INET_ASSERT(bDestroyed);

                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;

                        INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

                    }
                }
                else
                {
                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("k-a socket %#x couldn't be removed from the list\n",
                                pSocket->GetSocket()
                                ));
                }
            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("socket %#x/%d expires in %d mSec\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->GetExpiryTime() - ticks
                            ));

                last = pEntry;
            }
        }

        UnlockSerializedList(&m_KeepAliveList);
Cleanup:
        m_Waiters.Release();
    }

quit:
    DEBUG_LEAVE(0);
}

//
// friend functions
//


CServerInfo *
ContainingServerInfo(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of CServerInfo given address of m_List

Arguments:

    lpAddress   - address of m_List

Return Value:

    CServerInfo *

--*/

{
    return CONTAINING_RECORD(lpAddress, CServerInfo, m_List);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\debug\dbghandle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains function to return number of open handles owned by this process

    Contents:
        InternetHandleCount

Author:

    Richard L Firth (rfirth) 02-May-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-May-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// private types
//

typedef (*NT_QUERY_SYSTEM_INFORMATION)(ULONG, PVOID, ULONG, PULONG);

//
// functions
//


DWORD
InternetHandleCount(
    VOID
    )

/*++

Routine Description:

    Gets the number of system handles owned by this process. We LoadLibrary()
    NTDLL.DLL so that the debug version of this DLL still works on Win95

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    static HINSTANCE hNtdll = NULL;
    static NT_QUERY_SYSTEM_INFORMATION _NtQuerySystemInformation;

    if (IsPlatformWin95()) {
        return 0;
    }

    if (hNtdll == NULL) {
        hNtdll = LoadLibrary("ntdll");
        if (hNtdll == NULL) {
            return 0;
        }
        _NtQuerySystemInformation = (NT_QUERY_SYSTEM_INFORMATION)GetProcAddress(hNtdll, "NtQuerySystemInformation");
        if (_NtQuerySystemInformation == 0) {
            FreeLibrary(hNtdll);
            hNtdll = NULL;
        }
    }

    if (_NtQuerySystemInformation) {

        DWORD idProcess;
        NTSTATUS status;
        ULONG outputLength;
        BYTE buffer[32768];
        PSYSTEM_PROCESS_INFORMATION info;

        status = _NtQuerySystemInformation(SystemProcessInformation,
                                           (PVOID)buffer,
                                           sizeof(buffer),
                                           &outputLength
                                           );
        if (!NT_SUCCESS(status)) {
            return 0;
        }
        info = (PSYSTEM_PROCESS_INFORMATION)buffer;
        idProcess = GetCurrentProcessId();
        while (TRUE) {
            if ((DWORD_PTR)info->UniqueProcessId == idProcess) {
                return info->HandleCount;
            }
            if (info->NextEntryOffset == 0) {
                return 0;
            }
            info = (PSYSTEM_PROCESS_INFORMATION)((PCHAR)info + info->NextEntryOffset);
        }
    }
    return 0;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\debug\exceptn.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    exceptn.cxx

Abstract:

    Contains exception-handling code for debug version

    Contents:
        SetExceptionHandler
        (WininetExceptionFilter)
        (MapX86ProcessorFlags)

Author:

    Richard L Firth (rfirth) 18-Feb-1997

Revision History:

    18-Feb-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// private prototypes
//

PRIVATE
LONG
WininetExceptionFilter(
    IN PEXCEPTION_POINTERS pExPtrs
    );

#if defined(_X86_)

PRIVATE
LPSTR
MapX86ProcessorFlags(
    IN DWORD Flags
    );

#endif // defined(_X86_)

//
// functions
//


VOID
SetExceptionHandler(
    VOID
    )

/*++

Routine Description:

    Just sets the unhandled exception filter for this process

Arguments:

    None.

Return Value:

    None.

--*/

{
    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)WininetExceptionFilter);
}


PRIVATE
LONG
WininetExceptionFilter(
    IN PEXCEPTION_POINTERS pExPtrs
    )

/*++

Routine Description:

    We get to look at unhandled exceptions, and dump them to the debug log

Arguments:

    pExPtrs - pointer to exception pointers structure

Return Value:

    LONG

--*/

{
    //
    // don't bother if we are not logging
    //

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    LPSTR text;
    LONG disposition = EXCEPTION_EXECUTE_HANDLER;
    DWORD eipOffset = 0;

    switch (pExPtrs->ExceptionRecord->ExceptionCode) {
    case EXCEPTION_ACCESS_VIOLATION:
        text = "Access Violation";
        break;

    case EXCEPTION_DATATYPE_MISALIGNMENT:
        text = "Data Misalignment Exception";
        break;

    case EXCEPTION_BREAKPOINT:
        text = "Breakpoint Exception";
        disposition = EXCEPTION_CONTINUE_EXECUTION;
        eipOffset = 1;
        break;

    case EXCEPTION_SINGLE_STEP:
        text = "Single Step Exception";
        break;

    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
        text = "Array Bounds Exceeded Exception";
        break;

    case EXCEPTION_FLT_DENORMAL_OPERAND:
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
    case EXCEPTION_FLT_INEXACT_RESULT:
    case EXCEPTION_FLT_INVALID_OPERATION:
    case EXCEPTION_FLT_OVERFLOW:
    case EXCEPTION_FLT_STACK_CHECK:
    case EXCEPTION_FLT_UNDERFLOW:
        text = "Floating Point Exception";
        break;

    case EXCEPTION_INT_DIVIDE_BY_ZERO:
        text = "Integer Divide-By-Zero Exception";
        break;

    case EXCEPTION_INT_OVERFLOW:
        text = "Integer Overflow Exception";
        break;

    case EXCEPTION_PRIV_INSTRUCTION:
        text = "Privileged Instruction Exception";
        break;

    case EXCEPTION_IN_PAGE_ERROR:
        text = "In-Page Error";
        break;

    case EXCEPTION_ILLEGAL_INSTRUCTION:
        text = "Illegal Instruction";
        break;

    case EXCEPTION_NONCONTINUABLE_EXCEPTION:
        text = "Non-Continuable Exception";
        break;

    case EXCEPTION_STACK_OVERFLOW:
        text = "Stack Overflow";
        break;

    case EXCEPTION_INVALID_DISPOSITION:
        text = "Invalid Disposition Exception";
        break;

    case EXCEPTION_GUARD_PAGE:
        text = "Guard Page Exception";
        break;

    case EXCEPTION_INVALID_HANDLE:
        text = "Invalid Handle Exception";
        break;

    case CONTROL_C_EXIT:
        text = "Control-C Exception";
        break;

    default:
        text = "Unknown Exception";
        break;
    }

    InitSymLib();

    
    DWORD dwCodeOffset;
    // BUGBUG: Not 64b compatible
    LPSTR lpszDebugSymbol = GetDebugSymbol(PtrToUlong(pExPtrs->ExceptionRecord->ExceptionAddress),
                                           &dwCodeOffset
                                           );

    char buffer[512];
    int offset;
    BOOL needCrLf = FALSE;

    offset = rsprintf(buffer,
                      "\n"
                      "********************************************************************************\n"
                      "Thread %#x\n"
                      "%s at %#08x",
                      GetCurrentThreadId(),
                      text,
                      pExPtrs->ExceptionRecord->ExceptionAddress
                      );
    if (dwCodeOffset != (DWORD_PTR)pExPtrs->ExceptionRecord->ExceptionAddress) {
        offset += rsprintf(&buffer[offset],
                           " (%s+%#x)\n",
                           lpszDebugSymbol,
                           dwCodeOffset
                           );
    } else {
        buffer[offset++] = ' ';
        needCrLf = TRUE;
    }
    if (pExPtrs->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
        rsprintf(&buffer[offset],
                 "%sing %#08x\n",
                 pExPtrs->ExceptionRecord->ExceptionInformation[0]
                    ? "writ"
                    : "read",
                 pExPtrs->ExceptionRecord->ExceptionInformation[1]
                 );
    } else if (needCrLf) {
        buffer[offset++] = '\r';
        buffer[offset++] = '\n';
        buffer[offset] = '\0';
    }
    InternetDebugOut(buffer, FALSE);

#if defined(_X86_)

    if ((pExPtrs->ContextRecord->ContextFlags & CONTEXT_FULL) == CONTEXT_FULL) {
        rsprintf(buffer,
                 "\n"
                 "Processor Context:\n"
                 "eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n"
                 "eip=%08x esp=%08x ebp=%08x iopl=%d         %s\n"
                 "cs=%04x ss=%04x ds=%04x es=%04x fs=%04x gs=%04x                  efl=%08x\n",
                 pExPtrs->ContextRecord->Eax,
                 pExPtrs->ContextRecord->Ebx,
                 pExPtrs->ContextRecord->Ecx,
                 pExPtrs->ContextRecord->Edx,
                 pExPtrs->ContextRecord->Esi,
                 pExPtrs->ContextRecord->Edi,
                 pExPtrs->ContextRecord->Eip,
                 pExPtrs->ContextRecord->Esp,
                 pExPtrs->ContextRecord->Ebp,
                 ((pExPtrs->ContextRecord->EFlags & 0x00003000) >> 12),
                 MapX86ProcessorFlags(pExPtrs->ContextRecord->EFlags),
                 pExPtrs->ContextRecord->SegCs,
                 pExPtrs->ContextRecord->SegSs,
                 pExPtrs->ContextRecord->SegDs,
                 pExPtrs->ContextRecord->SegEs,
                 pExPtrs->ContextRecord->SegFs,
                 pExPtrs->ContextRecord->SegGs,
                 pExPtrs->ContextRecord->EFlags
                 );
        InternetDebugOut(buffer, FALSE);
    }

    //
    // dump out the stack, debug style
    //

    LPBYTE Address = (LPBYTE)pExPtrs->ContextRecord->Esp;

    rsprintf(buffer,
             "\n"
             "256 bytes of process stack at %04x:%08x:\n\n",
             pExPtrs->ContextRecord->SegSs,
             Address
             );
    InternetDebugOut(buffer, FALSE);

    for (DWORD Size = 256; Size; ) {

        DWORD nDumped = InternetDebugDumpFormat(Address, 16, sizeof(DWORD), buffer);

        InternetDebugOut(buffer, FALSE);
        Size -= nDumped;
        Address += nDumped;
    }

    //
    // dump call stack
    //

    LPVOID backtrace[16];

    memset(&backtrace, 0, sizeof(backtrace));

    x86SleazeCallStack((LPVOID *)backtrace,
                       ARRAY_ELEMENTS(backtrace),
                       (LPVOID *)pExPtrs->ContextRecord->Ebp
                       );

    BOOL ok = FALSE;

    for (int i = 0; i < ARRAY_ELEMENTS(backtrace); ++i) {
        if (backtrace[i] != NULL) {
            ok = TRUE;
            break;
        }
    }
    if (ok) {
        rsprintf(buffer,
                 "\n"
                 "Stack back-trace:\n\n"
                 );
        InternetDebugOut(buffer, FALSE);
        for (int i = 0; i < ARRAY_ELEMENTS(backtrace); ++i) {
            if (backtrace[i] == NULL) {
                break;
            }
            lpszDebugSymbol = GetDebugSymbol((DWORD)backtrace[i], &dwCodeOffset);
            rsprintf(buffer,
                     "%08x %s+%#x\n",
                     backtrace[i],
                     lpszDebugSymbol,
                     dwCodeOffset
                     );
            InternetDebugOut(buffer, FALSE);
        }
    }

#endif // defined(_X86_)

    InternetDebugOut("\r\n********************************************************************************\r\n\r\n", FALSE);

    InternetFlushDebugFile();

#if defined(_X86_)

    if (disposition == EXCEPTION_CONTINUE_EXECUTION) {
        pExPtrs->ContextRecord->Eip += eipOffset;
    }

#endif // defined(_X86_)

    return disposition;
}

#if defined(_X86_)


PRIVATE
LPSTR
MapX86ProcessorFlags(
    IN DWORD Flags
    )
{
    //
    // BUGBUG - not re-entrant
    //

    static char buf[32 * 3 + 1];

    rsprintf(buf,
             "%s %s %s %s %s %s %s %s",
             (Flags & 0x00000800) ? "ov" : "nv",    // Overflow:    Overflow or No-overflow
             (Flags & 0x00000400) ? "dn" : "up",    // Direction:   Up or Down
             (Flags & 0x00000200) ? "ei" : "di",    // Interrupts:  Enabled or Disabled
             (Flags & 0x00000080) ? "ng" : "pl",    // Sign:        Negative or Positive
             (Flags & 0x00000040) ? "zr" : "nz",    // Zero:        Zero or Not-zero
             (Flags & 0x00000010) ? "ac" : "na",    // Aux-Carry:   Aux-carry or No-aux-carry
             (Flags & 0x00000004) ? "pe" : "po",    // Parity:      Parity-even or Parity-odd
             (Flags & 0x00000001) ? "cy" : "nc"     // Carry:       Carry or No-carry
             );
    return buf;
}

#endif // defined(_X86_)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\debug\debugmem.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.cxx

Abstract:

    Debug memory allocator

    Contents:
        InternetDebugMemInitialize
        InternetDebugMemTerminate
        InternetDebugAllocMem
        InternetDebugFreeMem
        InternetDebugReAllocMem
        InternetDebugSizeMem
        InternetDebugCheckMemFreed
        InternetDebugMemReport
        (InternetDebugCheckMemBlock)
        (DebugFillMem)
        (InternetAlloc)
        (InternetFree)
        (InternetReAlloc)
        (InternetSize)
        (InternetHeapAlloc)
        (InternetHeapReAlloc)
        (InternetHeapFree)
        (InternetHeapSize)
        (InternetDebugMemTest)
        (ReportMemoryUsage)
        (ReportMemoryBlocks)
        (DumpDeferredFreeList)
        (DumpMemoryList)
        (FindAndDumpDeferredBlock)
        (DumpBlock)
        (DumpDebugMemoryHeader)
        (DumpDebugMemoryFooter)
        (DumpUserData)
        (MapLastAccessOperation)
        (MapMemoryFlags)
        (DbgMemGetDebugSymbol)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if defined(USE_DEBUG_MEMORY)

//
// manifests
//

#define DEFAULT_INITIAL_HEAP_SIZE   (64 K)
#define DEFAULT_MAXIMUM_HEAP_SIZE   (1 M)
#define DEFAULT_HEADER_GUARD_SIZE   32
#define DEFAULT_FOOTER_GUARD_SIZE   32
#define DEFAULT_ALLOC_ALIGNMENT     4
#define HEADER_SIGNATURE            0x414d454d  // "MEMA"
#define FOOTER_SIGNATURE            0x434f4c4c  // "LLOC"
#define DWORD_ALLOC_FILL            0xc5c5c5c5
#define BYTE_ALLOC_FILL             0xc5
#define BYTE_ALLOC_FILL_EXTRA       0x88
#define GUARD_DWORD_FILL            0x44524147  // "GARD"
#define DWORD_FREE_FILL             0xb7b7b7b7
#define BYTE_FREE_FILL              0xb7
#define DEFAULT_MAX_BLOCKS_DUMPED   1024
#define DEFAULT_MAX_DATA_DUMPED     65536
#define DEFAULT_BACKTRACE_DEPTH     2

//
// only perform stack dump for x86 (or other stack-based processors)
//

#if defined(i386)
#define DUMP_STACK  1
#else
#define DUMP_STACK  0
#endif

//
// just using one stack these days
//

#define ONE_STACK   1

//
// private types
//

typedef enum {
    MemAllocate = 0x6f6c6c41,   // "Allo"
    MemReallocate = 0x6c416552, // "ReAl"
    MemLock = 0x6b636f4c,       // "Lock"
    MemUnlock = 0x6f6c6e55,     // "Unlo"
    MemFree = 0x65657246,       // "Free"
    MemSize = 0x657a6953        // "Size"
} MEMORY_ACTION;

typedef enum {
    HEAP_COMPACT_NEVER = 0,
    HEAP_COMPACT_ON_ALLOC_FAIL,
    HEAP_COMPACT_ON_FREE
} HEAP_COMPACT_TYPE;

typedef enum {
    HEAP_VALIDATE_NEVER = 0,
    HEAP_VALIDATE_ON_ALLOC,
    HEAP_VALIDATE_ON_FREE
} HEAP_VALIDATE_TYPE;

//
// DEBUG_MEMORY_HEADER - keeps debug memory on list
//

typedef struct {
    LIST_ENTRY List;
    DWORD ThreadId;
    LPSTR CreatedFile;
    DWORD CreatedLine;
    LPSTR AccessedFile;
    DWORD AccessedLine;
    SIZE_T RequestedLength;
    SIZE_T BlockLength;
    SIZE_T ActualLength;
    DWORD Signature;
    DWORD Flags;
    DWORD TimeDeferred;
    LONG ClashTest;
    MEMORY_ACTION LastAccessOperation;
#if DUMP_STACK
#if ONE_STACK
    LPVOID Stack[8];    // should be variable
#else
    LPVOID CreateStack[4];
    LPVOID LastAccessStack[4];
#endif // ONE_STACK
#endif // DUMP_STACK
    DWORD Guard[2];

    //
    // sizeof(MEMORY_SIGNATURE) currently 24 DWORDs in Win32
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

//
// DEBUG_MEMORY_FOOTER - used to check for overwrites
//

typedef struct {
    DWORD Guard[4];
    DWORD Signature;
    SIZE_T BlockLength;  // should be the same as the header
    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs in Win32
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// private data
//

PRIVATE BOOL MemoryPackageInitialized = FALSE;

//
// InternetDebugMemFlags - bitfield of flags controlling debug memory usage.
// The default is no debug alloc (don't create header + footers) and to use
// LocalAlloc() etc.
//

//
// BUGBUG - I'm making an assumption that the compiler thinks the bits have the
//          same values as I think they have. If not, it could mess up the
//          registry/environment flags
//

PRIVATE struct {                                            // default value
    DWORD bNoDebugAlloc             : 1;    //  0x00000001          TRUE
    DWORD bUseLocalAlloc            : 1;    //  0x00000002          TRUE
    DWORD bUseSymbols               : 1;    //  0x00000004          FALSE
    DWORD bAssertOnMemoryErrors     : 1;    //  0x00000008          FALSE
    DWORD bFillMemoryOnAlloc        : 1;    //  0x00000010          FALSE
    DWORD bFillMemoryOnFree         : 1;    //  0x00000020          FALSE
    DWORD bReportMemoryUsage        : 1;    //  0x00000040          FALSE
    DWORD bReportUnfreedBlocks      : 1;    //  0x00000080          FALSE
    DWORD bReportMemoryFooters      : 1;    //  0x00000100          FALSE
    DWORD bReportUserData           : 1;    //  0x00000200          FALSE
    DWORD bStopDumpIfBadBlock       : 1;    //  0x00000400          FALSE
    DWORD bLimitUnfreedBlocks       : 1;    //  0x00000800          FALSE
    DWORD bLimitUserData            : 1;    //  0x00001000          FALSE
    DWORD bDumpAsDwords             : 1;    //  0x00002000          FALSE
    DWORD bHeapNoSerialize          : 1;    //  0x00004000          FALSE
    DWORD bHeapGenerateExceptions   : 1;    //  0x00008000          FALSE
    DWORD bHeapIsGrowable           : 1;    //  0x00010000          FALSE
    DWORD bDeferFree                : 1;    //  0x00020000          FALSE
    DWORD bDumpToFile               : 1;    //  0x00040000          FALSE
} InternetDebugMemFlags = {
    TRUE,   // no debug alloc
    TRUE,   // use LocalAlloc()
    FALSE,  // don't load debug symbols
    FALSE,  // don't assert on memory errors
    FALSE,  // don't fill memory on alloc
    FALSE,  // don't fill memory on free
    FALSE,  // don't report memory usage (stats)
    FALSE,  // don't report unfreed blocks
    FALSE,  // don't report memory footers (irrelevant)
    FALSE,  // don't report user data (irrelevant)
    FALSE,  // don't stop dump if bad block (irrelevant)
    FALSE,  // don't limit dump of unfreed blocks (irrelevant)
    FALSE,  // don't limit dump of user data (irrelevant)
    FALSE,  // don't dump user data as DWORDs (irrelevant)
    FALSE,  // serialize access to heap (irrelevant)
    FALSE,  // don't generate heap exceptions (irrelevant)
    TRUE,   // heap is growable (irrelevant)
    FALSE,  // don't defer frees
    FALSE   // don't dump to WinHttp log file
};

//
// defines to make using InternetDebugMemFlags easier
//

#define bNoDebugAlloc           InternetDebugMemFlags.bNoDebugAlloc
#define bUseLocalAlloc          InternetDebugMemFlags.bUseLocalAlloc
#define bUseSymbols             InternetDebugMemFlags.bUseSymbols
#define bAssertOnMemoryErrors   InternetDebugMemFlags.bAssertOnMemoryErrors
#define bFillMemoryOnAlloc      InternetDebugMemFlags.bFillMemoryOnAlloc
#define bFillMemoryOnFree       InternetDebugMemFlags.bFillMemoryOnFree
#define bReportMemoryUsage      InternetDebugMemFlags.bReportMemoryUsage
#define bReportUnfreedBlocks    InternetDebugMemFlags.bReportUnfreedBlocks
#define bReportMemoryFooters    InternetDebugMemFlags.bReportMemoryFooters
#define bReportUserData         InternetDebugMemFlags.bReportUserData
#define bStopDumpIfBadBlock     InternetDebugMemFlags.bStopDumpIfBadBlock
#define bLimitUnfreedBlocks     InternetDebugMemFlags.bLimitUnfreedBlocks
#define bLimitUserData          InternetDebugMemFlags.bLimitUserData
#define bDumpAsDwords           InternetDebugMemFlags.bDumpAsDwords
#define bHeapNoSerialize        InternetDebugMemFlags.bHeapNoSerialize
#define bHeapGenerateExceptions InternetDebugMemFlags.bHeapGenerateExceptions
#define bHeapIsGrowable         InternetDebugMemFlags.bHeapIsGrowable
#define bDeferFree              InternetDebugMemFlags.bDeferFree
#define bDumpToFile             InternetDebugMemFlags.bDumpToFile

PRIVATE DWORD MaxBlocksDumped = DEFAULT_MAX_BLOCKS_DUMPED;
PRIVATE DWORD MaxUserDataDumped = DEFAULT_MAX_DATA_DUMPED;
PRIVATE DWORD StackBacktraceDepth = DEFAULT_BACKTRACE_DEPTH;

//
// heap variables
//

PRIVATE HANDLE hDebugHeap = NULL;
PRIVATE DWORD InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
PRIVATE DWORD MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
PRIVATE HEAP_COMPACT_TYPE HeapCompactControl = HEAP_COMPACT_NEVER;
PRIVATE HEAP_VALIDATE_TYPE HeapValidateControl = HEAP_VALIDATE_NEVER;

//
// debug mem signatures etc.
//

PRIVATE DWORD AllocAlignment = DEFAULT_ALLOC_ALIGNMENT;
PRIVATE DWORD HeaderGuardSize = DEFAULT_HEADER_GUARD_SIZE;
PRIVATE DWORD FooterGuardSize = DEFAULT_FOOTER_GUARD_SIZE;
PRIVATE DWORD AllocMemoryFiller = DWORD_ALLOC_FILL;
PRIVATE DWORD FreeMemoryFiller = DWORD_FREE_FILL;

//
// usage variables - access using some sort of lock (critsec/interlocked)
//

PRIVATE CRITICAL_SECTION MemoryVarsCritSec;
PRIVATE SIZE_T TotalActualMemoryAllocated = 0;  // cumulative
PRIVATE SIZE_T TotalBlockMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalRealMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalActualMemoryFreed = 0;      //     "
PRIVATE SIZE_T TotalBlockMemoryFreed = 0;        //     "
PRIVATE SIZE_T TotalRealMemoryFreed = 0;         //     "
PRIVATE SIZE_T ActualMemoryAllocated = 0;        // difference
PRIVATE SIZE_T BlockLengthAllocated = 0;         //     "
PRIVATE SIZE_T RealLengthAllocated = 0;          //     "
PRIVATE DWORD MemoryAllocations = 0;            // cumulative
PRIVATE DWORD GoodMemoryAllocations = 0;        //     "
PRIVATE DWORD MemoryReAllocations = 0;          //     "
PRIVATE DWORD GoodMemoryReAllocations = 0;      //     "
PRIVATE DWORD MemoryFrees = 0;                  //     "
PRIVATE DWORD GoodMemoryFrees = 0;              //     "
PRIVATE SIZE_T LargestBlockRequested = 0;
PRIVATE SIZE_T LargestBlockAllocated = 0;
PRIVATE LPSTR LargestBlockRequestedFile = NULL;
PRIVATE DWORD LargestBlockRequestedLine = 0;
PRIVATE SIZE_T SmallestBlockRequested = (SIZE_T)-1;
PRIVATE SIZE_T SmallestBlockAllocated = (SIZE_T)-1;
PRIVATE LPSTR SmallestBlockRequestedFile = NULL;
PRIVATE DWORD SmallestBlockRequestedLine = 0;
PRIVATE DWORD DeferFreeTime = 0;

//
// lists
//

PRIVATE SERIALIZED_LIST AllocatedBlockList;
PRIVATE SERIALIZED_LIST DeferredFreeList;

//
// macros
//

#define MEMORY_ASSERT(x) \
    if (bAssertOnMemoryErrors) { \
        INET_ASSERT(x); \
    } else { \
        /* NOTHING */ \
    }

//
// private prototypes
//

PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    );

PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    );

PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
VOID
InternetDebugMemTest(
    VOID
    );

PRIVATE
VOID
ReportMemoryUsage(
    VOID
    );

PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    );

PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    );

PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    );

PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    );

PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    );

PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    );

PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

//
// functions
//


VOID
InternetDebugMemInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes debug memory allocator

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL init;

    init = (BOOL)InterlockedExchange((LPLONG)&MemoryPackageInitialized, TRUE);
    if (init) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

        return;
    }

    InitializeSerializedList(&AllocatedBlockList);
    InitializeSerializedList(&DeferredFreeList);
    InitializeCriticalSection(&MemoryVarsCritSec);

    //
    // sleaze: disable any debug output until we finish this. Debug log
    // routines want to allocate memory(!). InternetReadRegistryDword()
    // (called from InternetGetDebugVariable()) wants to perform DEBUG_ENTER
    // etc.
    //

    DWORD debugControlFlags = InternetDebugControlFlags;

    InternetDebugControlFlags = DBG_NO_DEBUG;

    //
    // if "WinHttpMem" is set then we set up to use debug memory - we use our
    // own heap, full debugging & reporting etc. (basically max memory debugging
    // as defined by me)
    //

    DWORD useDefaultDebugMemoryFlags = FALSE;

    InternetGetDebugVariable("WinHttpMem",
                             &useDefaultDebugMemoryFlags
                             );
    if (useDefaultDebugMemoryFlags) {
        bNoDebugAlloc = FALSE;          // use full debug allocator (header + footers, etc.)
        bUseLocalAlloc = FALSE;         // use our own heap
        bUseSymbols = FALSE;            // don't load debug symbols
        bAssertOnMemoryErrors = TRUE;   // assert to debugger/log if memory errors
        bFillMemoryOnAlloc = TRUE;      // fill user data w/ signature if not zeroinit
        bFillMemoryOnFree = TRUE;       // fill freed memory (useful on Win95/non-debug on NT)
        bReportMemoryUsage = TRUE;      // dump memory usage stats
        bReportUnfreedBlocks = TRUE;    // dump unfreed blocks (headers)
        bReportMemoryFooters = TRUE;    // dump unfreed block footers
        bReportUserData = TRUE;         // dump unfreed block user data
        bStopDumpIfBadBlock = TRUE;     // stop dumping if error occurs
        bLimitUnfreedBlocks = TRUE;     // limit block dump in case of loop in list
        bLimitUserData = TRUE;          // limit user data dump in case of bad length
        bDumpAsDwords = TRUE;           // dump data in dc format vs. db
        bHeapNoSerialize = FALSE;       // heap functions are serialized
        bHeapGenerateExceptions = FALSE;// heap functions return errors
        bHeapIsGrowable = FALSE;        // limit heap to maximum size (1 Meg)
        if (useDefaultDebugMemoryFlags == 2) {
            bDumpToFile = TRUE;
        }
    } else {

        //
        // no use-debug-mem override, see if there are any specific flags set
        //

        InternetGetDebugVariable("WinHttpDebugMemFlags",
                                 (LPDWORD)&InternetDebugMemFlags
                                 );
    }

    //
    // we used to load IMAGEHLP.DLL here and not use its functions until we were
    // dumping still in-use memory during DLL shutdown. Problem is that the
    // system has probably already freed IMAGEHLP.DLL by the time we come to use
    // it, resulting in GPF, so now we only load it at the time we're about to
    // use it
    //

    //if (bUseSymbols) {
    //    InitSymLib();
    //}

    if (!bUseLocalAlloc) {

        //
        // not using LocalAlloc(), using HeapAlloc(). Create heap
        //

        InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
        InternetGetDebugVariable("WinHttpDebugHeapInitialSize",
                                 &InitialHeapSize
                                 );

        MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
        InternetGetDebugVariable("WinHttpDebugHeapMaximumSize",
                                 &MaximumHeapSize
                                 );

        if (bHeapIsGrowable) {
            MaximumHeapSize = 0;
        }

        hDebugHeap = HeapCreate((bHeapGenerateExceptions
                                    ? HEAP_GENERATE_EXCEPTIONS
                                    : 0)
                                | (bHeapNoSerialize
                                    ? HEAP_NO_SERIALIZE
                                    : 0),
                                InitialHeapSize,
                                MaximumHeapSize
                                );
        if (hDebugHeap == NULL) {

            DEBUG_PUT(("HeapCreate() failed - %d\n",
                        GetLastError()
                        ));

            bUseLocalAlloc = TRUE;
        } else {
            HeapCompactControl = HEAP_COMPACT_NEVER;
            InternetGetDebugVariable("WinHttpDebugHeapCompactControl",
                                     (LPDWORD)&HeapCompactControl
                                     );

            HeapValidateControl = HEAP_VALIDATE_NEVER;
            InternetGetDebugVariable("WinHttpDebugHeapValidateControl",
                                     (LPDWORD)&HeapValidateControl
                                     );

            DEBUG_PUT(("WinHttp heap = %#x\n",
                        hDebugHeap
                        ));

        }
    }

    //
    // restore default debug flags
    //

    InternetDebugControlFlags = debugControlFlags;

    //InternetDebugMemTest();
}


VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    )

/*++

Routine Description:

    Frees resources allocated in InternetDebugMemInitialize, after checking that
    all memory is freed

Arguments:

    bReport - TRUE if in-use blocks reported at termination

Return Value:

    None.

--*/

{
    BOOL bOpened = bReport ? InternetDebugMemReport(TRUE, FALSE) : FALSE;

    InternetDebugCheckMemFreed(FALSE);
    DeleteCriticalSection(&MemoryVarsCritSec);
    TerminateSerializedList(&AllocatedBlockList);
    TerminateSerializedList(&DeferredFreeList);

    if (hDebugHeap != NULL) {

        //
        // any future allocations(!) must use process heap
        //

        bUseLocalAlloc = TRUE;

        if (!HeapDestroy(hDebugHeap)) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapDestroy(%#x) returns %s (%d)\n",
                        hDebugHeap,
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    }
    if (bOpened) {
        InternetCloseDebugFile();
    }
    MemoryPackageInitialized = FALSE;
}


HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Debug memory allocator. If this succeeds, then the real block is put on our
    list and has its head & tail (& possibly contents) initialized. The caller
    gets an pointer which is an offset to the user area in the block

Arguments:

    Flags   - controlling flags (normally passed to LocalAlloc)

    Size    - of block to allocate

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to caller's start of allocated block

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugAllocMem(%#x, %d) = ", Flags, Size);
    InterlockedIncrement((LPLONG)&MemoryAllocations);

    //
    // keep these tests separate so we don't have to look up the flags #defines
    //

    INET_ASSERT(!(Flags & LMEM_MOVEABLE));
    INET_ASSERT(!(Flags & LMEM_DISCARDABLE));

    if (Size == 0) {

        DEBUG_PRINT(MEMALLOC,
                    WARNING,
                    ("InternetDebugAllocMem(%#x, %d)\n",
                    Flags,
                    Size
                    ));

        MEMORY_ASSERT(FALSE);

    }

    SIZE_T blockLength;

    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }

    //
    // possible problem: if Size + signatures would overflow UINT. Only really
    // problematic on 16-bit platforms
    //

    if (blockLength < Size) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)Size
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    //
    // BUGBUG - allocating 0 bytes?
    //

    HLOCAL hLocal = InternetAlloc(Flags, blockLength);

    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryAllocations);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    SIZE_T actualLength = InternetSize(hLocal);
    SIZE_T requestedLength;

    if (bNoDebugAlloc) {
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        requestedLength = Size;
        if (actualLength > LargestBlockAllocated) {
            LargestBlockAllocated = actualLength;
        } else if (actualLength < SmallestBlockAllocated) {
            SmallestBlockAllocated = actualLength;
        }
    }

    EnterCriticalSection(&MemoryVarsCritSec);
    TotalActualMemoryAllocated += actualLength;
    TotalBlockMemoryAllocated += blockLength;
    TotalRealMemoryAllocated += requestedLength;
    ActualMemoryAllocated += actualLength;
    BlockLengthAllocated += blockLength;
    RealLengthAllocated += requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);

    if (bNoDebugAlloc || (hLocal == NULL)) {
        if ((hLocal != NULL) && !(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
            DebugFillMem(hLocal, Size, AllocMemoryFiller);
        }
//dprintf("%#x\n", hLocal);
        return hLocal;
    }

    LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

    //InitializeListHead(&lpHeader->List);
    lpHeader->ThreadId = GetCurrentThreadId();
    lpHeader->CreatedFile = File;
    lpHeader->CreatedLine = Line;
    lpHeader->AccessedFile = File;
    lpHeader->AccessedLine = Line;
    lpHeader->RequestedLength = Size;
    lpHeader->BlockLength = blockLength;
    lpHeader->ActualLength = actualLength;
    lpHeader->Signature = HEADER_SIGNATURE;
    lpHeader->Flags = Flags;
    lpHeader->TimeDeferred = 0;
    lpHeader->ClashTest = -1;
    lpHeader->LastAccessOperation = MemAllocate;

#if DUMP_STACK
#if ONE_STACK

    memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
    GET_CALL_STACK(lpHeader->Stack);

#else

    GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                        &lpHeader->CreateStack[1]
                        );

    memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

    GET_CALL_STACK(lpHeader->CreateStack);

    memcpy(lpHeader->LastAccessStack,
           lpHeader->CreateStack,
           sizeof(lpHeader->LastAccessStack)
           );

#endif // ONE_STACK
#endif // DUMP_STACK

    UINT i;

    for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
        lpHeader->Guard[i] = GUARD_DWORD_FILL;
    }

    //
    // BUGBUG - should be using AllocAlignment - could be > sizeof(DWORD)
    //

    if (!(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
        DebugFillMem(lpHeader + 1, Size, AllocMemoryFiller);
    }

    UINT bFillLength2 = (Size % sizeof(DWORD)) ? (sizeof(DWORD) - (Size % sizeof(DWORD))) : 0;
    LPBYTE lpbUserPointer = (LPBYTE)(lpHeader + 1) + Size;

    for (i = 0; i < bFillLength2; ++i) {
        *lpbUserPointer++ = BYTE_ALLOC_FILL_EXTRA;
    }

    LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)lpbUserPointer;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
        lpFooter->Guard[i] = GUARD_DWORD_FILL;
    }

    lpFooter->BlockLength = blockLength;
    lpFooter->Signature = FOOTER_SIGNATURE;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
        lpFooter->Guard2[i] = GUARD_DWORD_FILL;
    }

    if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, FALSE)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugAllocMem(%d): %#x already on list?\n",
                    Size,
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

    }

    //
    // put at the tail of list so we can view unfreed blocks in chronological
    // order
    //

    if (!InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List))
    {
        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugAllocMem(%d): %#x couldn't be appended to unfreed list\n",
                    Size,
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);
    }

//dprintf("%#x\n", lpHeader + 1);
    return (HLOCAL)(lpHeader + 1);
}


HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Frees a block of memory allocated by InternetDebugAllocMem(). Checks that
    the block is on our allocated block list, and that the header and footer
    areas are still intact

Arguments:

    hLocal  - handle (pointer) of block to free

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugFreeMem(%#x)\n", hLocal);
    InterlockedIncrement((LPLONG)&MemoryFrees);

    if (hLocal == NULL) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(NULL)\n"
                    ));

        MEMORY_ASSERT(FALSE);

        return InternetFree(hLocal);
    }

    HLOCAL hLocalOriginal = hLocal;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T realLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        realLength = actualLength;
    } else {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
        actualLength = InternetSize(hLocal);

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

        if (CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE) &&
            RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {

            if (!((lpHeader->ActualLength == actualLength)
            && (lpHeader->BlockLength <= actualLength)
            && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
            && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("InternetDebugFreeMem(%#x): block lengths mismatch\n",
                            hLocalOriginal
                            ));

                MEMORY_ASSERT(FALSE);
            }
            if (InternetDebugCheckMemBlock(lpHeader)) {
                blockLength = lpHeader->BlockLength;
                realLength = lpHeader->RequestedLength;
            } else {
                blockLength = 0;
                realLength = 0;
            }
            if (bDeferFree) {

#if DUMP_STACK
#if ONE_STACK

                memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
                GET_CALL_STACK(lpHeader->Stack);

#else

                GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                                    &lpHeader->CreateStack[1]
                                    );

                memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

                GET_CALL_STACK(lpHeader->CreateStack);

                memcpy(lpHeader->LastAccessStack,
                       lpHeader->CreateStack,
                       sizeof(lpHeader->LastAccessStack)
                       );

#endif // ONE_STACK
#endif // DUMP_STACK

                if (!InsertAtTailOfSerializedList(&DeferredFreeList, &lpHeader->List))
                {
                    DEBUG_PRINT(MEMALLOC,
                                ERROR,
                                ("InternetDebugFreeMem(%#x): couldn't add to deferred free list %#x\n",
                                hLocalOriginal,
                                &lpHeader->List
                                ));

                    MEMORY_ASSERT(FALSE);
                }
                hLocal = NULL;
            }
        } else {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugFreeMem(%#x): can't find %#x or couldn't free from list\n",
                        hLocalOriginal,
                        &lpHeader->List
                        ));

            MEMORY_ASSERT(FALSE);

            FindAndDumpDeferredBlock(hLocal);
        }
    }

    if (hLocal && bFillMemoryOnFree) {
        DebugFillMem(hLocal, actualLength, FreeMemoryFiller);
    }

    hLocal = InternetFree(hLocal);

    if (hLocal == NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryFrees);
        EnterCriticalSection(&MemoryVarsCritSec);
        TotalActualMemoryFreed += actualLength;
        TotalBlockMemoryFreed += blockLength;
        TotalRealMemoryFreed += realLength;
        ActualMemoryAllocated -= actualLength;
        BlockLengthAllocated -= blockLength;
        RealLengthAllocated -= realLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(%#x) failed\n",
                    hLocalOriginal
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = hLocalOriginal;
    }

    return hLocal;
}


HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Reallocates a debug memory block allocated by InternetDebugAllocMem()

Arguments:

    hLocal  - the handle (pointer) of the allocated block

    Size    - requested size of new block; can be larger or smaller than current
              size

    Flags   - controlling flags (normally passed to LocalReAlloc)

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to new block. May be same or different than previous
                  pointer, depending on flags

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugReAllocMem(%#x, %d, %#x)\n", hLocal, Size, Flags);
    InterlockedIncrement((LPLONG)&MemoryReAllocations);

    //
    // we can't handle the following flags
    //

    INET_ASSERT(!(Flags & LMEM_MODIFY));

    //
    // can't handle reallocating down to zero
    //

    if (Size == 0) {

        MEMORY_ASSERT(FALSE);

    }

    HLOCAL hLocalOriginal = hLocal;
    LPDEBUG_MEMORY_HEADER lpHeader;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T requestedLength;
    SIZE_T oldRequestedLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        hLocal = (HLOCAL)lpHeader;
        if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE) ||
             RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): can't find %#x or couldn't remove from list\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);

            return hLocalOriginal;
        }
        InternetDebugCheckMemBlock(lpHeader);
        actualLength = InternetSize((HLOCAL)lpHeader);
        blockLength = lpHeader->BlockLength;
        requestedLength = lpHeader->RequestedLength;
        oldRequestedLength = requestedLength;
        if (!((lpHeader->ActualLength == actualLength)
        && (lpHeader->BlockLength <= actualLength)
        && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
        && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): block lengths mismatch\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);
        }
    }
    EnterCriticalSection(&MemoryVarsCritSec);
    ActualMemoryAllocated -= actualLength;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);
    requestedLength = Size;
    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }
    hLocal = InternetReAlloc(hLocal, blockLength, Flags);
    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryReAllocations);
        actualLength = InternetSize(hLocal);
        if (bNoDebugAlloc) {
            blockLength = actualLength;
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
            //InitializeListHead(&lpHeader->List);
            lpHeader->ThreadId = GetCurrentThreadId();
            lpHeader->AccessedFile = File;
            lpHeader->AccessedLine = Line;
            lpHeader->RequestedLength = requestedLength;
            lpHeader->BlockLength = blockLength;
            lpHeader->ActualLength = actualLength;
            lpHeader->Flags = Flags;
            lpHeader->TimeDeferred = 0;
            lpHeader->ClashTest = -1;
            lpHeader->LastAccessOperation = MemReallocate;

#if DUMP_STACK
#if ONE_STACK
#else

            //GET_CALLERS_ADDRESS(&lpHeader->LastAccessStack[0],
            //                    &lpHeader->LastAccessStack[1]
            //                    );

            memset(lpHeader->LastAccessStack, 0, sizeof(lpHeader->LastAccessStack));

            GET_CALL_STACK(lpHeader->LastAccessStack);

#endif // ONE_STACK
#endif // DUMP_STACK

            LPBYTE extraPointer;
            UINT dwFillLength;
            UINT i;

            if ((requestedLength > oldRequestedLength)
            && bFillMemoryOnAlloc && !(Flags & LMEM_ZEROINIT)) {

                extraPointer = (LPBYTE)(lpHeader + 1) + oldRequestedLength;

                SIZE_T difference = requestedLength - oldRequestedLength;
                DWORD dwFiller = AllocMemoryFiller;
                SIZE_T syncLength = oldRequestedLength & (sizeof(DWORD) - 1);

                if (syncLength) {
                    syncLength = sizeof(DWORD) - syncLength;
                    syncLength = min(syncLength, difference);
                    difference -= syncLength;
                    for (i = 0; i < syncLength; ++i) {
                        *extraPointer++ = ((LPBYTE)&dwFiller)[i];
                    }
                }

                //dwFillLength = difference / sizeof(DWORD);
                //difference %= sizeof(DWORD);
                //while (dwFillLength--) {
                //    *(LPDWORD)extraPointer = 0;
                //    extraPointer += sizeof(DWORD);
                //}
                //while (difference--) {
                //    *extraPointer++ = 0;
                //}

                if (difference) {
                    DebugFillMem(extraPointer, difference, dwFiller);
                    extraPointer += difference;
                }
            } else {
                extraPointer = (LPBYTE)(lpHeader + 1) + requestedLength;
            }

            SIZE_T bFillLength = (sizeof(DWORD) - (requestedLength % sizeof(DWORD))) & (sizeof(DWORD) - 1);

            while (bFillLength--) {
                *extraPointer++ = BYTE_ALLOC_FILL_EXTRA;
            }

            LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)extraPointer;

            INET_ASSERT(lpFooter == (LPDEBUG_MEMORY_FOOTER)
                ((LPBYTE)(lpHeader + 1) + ROUND_UP_DWORD(requestedLength)));

            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
                lpFooter->Guard[i] = GUARD_DWORD_FILL;
            }
            lpFooter->Signature = FOOTER_SIGNATURE;
            lpFooter->BlockLength = blockLength;
            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
                lpFooter->Guard2[i] = GUARD_DWORD_FILL;
            }
            if (!InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List)) {
                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("failed to append to allocated block list.\n"
                            ));

                DEBUG_BREAK(MEMALLOC);
            }
            hLocal = (HLOCAL)(lpHeader + 1);
        }
        EnterCriticalSection(&MemoryVarsCritSec);
        ActualMemoryAllocated += actualLength;
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += requestedLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Returns actual allocated block size

Arguments:

    hLocal  - pointer to allocated block

    File    - from where alloc called

    Line    - in File

Return Value:

    SIZE_T
        size of allocated block

--*/

{
    if (!MemoryPackageInitialized) {
        return 0;
    }

//dprintf("InternetDebugSizeMem(%#x)\n", hLocal);
    SIZE_T size = InternetSize(hLocal);

    if (!bNoDebugAlloc) {

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        SIZE_T sizeInHeader = lpHeader->BlockLength
                          - (sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER));

        INET_ASSERT((sizeInHeader <= size)
                    && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                    && (lpHeader->ActualLength == size)
                    );

        size = sizeInHeader;
    }

    return size;
}


BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    )

/*++

Routine Description:

    Called when we're about to quit. Checks that all allocated memory has been
    cleaned up

Arguments:

    bReport - TRUE if in-use blocks reported

Return Value:

    BOOL
        TRUE    - all allocated memory freed

        FALSE   - we failed to clean up

--*/

{
    if (bReport) {
        if (bReportMemoryUsage) {
            ReportMemoryUsage();
        }
        if (bReportUnfreedBlocks) {
            ReportMemoryBlocks();
        }
    }
    if (ElementsOnSerializedList(&AllocatedBlockList) != 0) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugCheckMemFreed(): %d memory blocks still allocated\n",
                    MemoryAllocations - MemoryFrees
                    ));

        MEMORY_ASSERT(FALSE);

        return FALSE;
    }
    return TRUE;
}


BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    )

/*++

Routine Description:

    Dumps in-use blocks to debugger and/or file

Arguments:

    bTerminateSymbols   - TRUE if we are to terminate symbols here

    bCloseFile          - TRUE if we are to close debug log file here

Return Value:

    BOOL    - TRUE if we opened debug log file

--*/

{
    BOOL bOpened = FALSE;

    if (bDumpToFile) {
        bOpened = InternetOpenDebugFile();
        if (bOpened) {
            InternetDebugResetControlFlags(DBG_NO_DEBUG);
            InternetDebugSetControlFlags(DBG_TO_FILE | DBG_NO_ASSERT_BREAK);
        }
    }
    ReportMemoryUsage();
    ReportMemoryBlocks();
    if (bUseSymbols && bTerminateSymbols) {
        TermSymLib();
    }
    if (bOpened && bCloseFile) {
        InternetCloseDebugFile();
    }
    return bOpened;
}

//
// private functions
//


PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    )

/*++

Routine Description:

    Fills memory with repeating debug pattern. Performs DWORD fill then finishes
    off any remaining bytes with character fill (rep movsd/rep movsb (ideally)
    (x86!))

Arguments:

    Pointer     - memory to fill

    Size        - of Pointer in bytes

    dwFiller    - DWORD value to use

Return Value:

    None.

--*/

{
    INET_ASSERT(((DWORD_PTR)Pointer & (sizeof(DWORD) - 1)) == 0);

    SIZE_T dwFillLength = Size / sizeof(DWORD);
    SIZE_T bFillLength = Size % sizeof(DWORD);

    //
    // assume > 0 DWORDs to fill
    //

    LPDWORD lpdwPointer = (LPDWORD)Pointer;
    SIZE_T i;

    for (i = 0; i < dwFillLength; ++i) {
        *lpdwPointer++ = dwFiller;
    }

    if (bFillLength) {

        LPBYTE lpbPointer = (LPBYTE)lpdwPointer;

        for (i = 0; i < bFillLength; ++i) {
            *lpbPointer++ = ((LPBYTE)&dwFiller)[i];
        }
    }
}


PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalAlloc(Flags, Size);
    } else {
        return InternetHeapAlloc(Flags, Size);
    }
}


PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Deallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to deallocate

Return Value:

    HLOCAL
        Success - NULL

        Failure - pointer to still allocated block

--*/

{
    if (bUseLocalAlloc) {
        return LocalFree(hLocal);
    } else {
        return InternetHeapFree(hLocal);
    }
}


PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to reallocate

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalReAlloc(hLocal, Size, Flags);
    } else {
        return InternetHeapReAlloc(hLocal, Size, Flags);
    }
}


PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Block sizer - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    if (bUseLocalAlloc) {
        return LocalSize(hLocal);
    } else {
        return InternetHeapSize(hLocal);
    }
}


PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocate memory from debug heap

Arguments:

    Flags   - passed to LocalAlloc

    Size    - of block to allocate

Return Value:

    HLOCAL

--*/

{
    HLOCAL hLocal;

    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapAlloc(hDebugHeap,
                                   (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                   | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                   | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                   Size
                                   );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = LocalAlloc(Flags, Size);
    }
    if (hLocal == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocate memory from debug heap

Arguments:

    hLocal  - pointer to block to reallocate

    Size    - new size

    Flags   - to LocalReAlloc

Return Value:

    HLOCAL
        Success - pointer to new block

        Failure - NULL

--*/

{
    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapReAlloc(hDebugHeap,
                                     (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                     | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                     | ((Flags & LMEM_MOVEABLE)
                                        ? 0
                                        : HEAP_REALLOC_IN_PLACE_ONLY)
                                     | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                     (LPVOID)hLocal,
                                     Size
                                     );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapReAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        //
        // block still allocated
        //

        hLocal = NULL;
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Free memory to debug heap

Arguments:

    hLocal  - to free

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    BOOL ok;

    if (hDebugHeap != NULL) {
        ok = HeapFree(hDebugHeap,
                      bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                      (LPVOID)hLocal
                      );
        if (!ok) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapFree() returns %s (%d)\n",
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapFree(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        ok = FALSE;
    }
    return ok ? NULL : hLocal;
}


PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines size of block allocated from debug heap

Arguments:

    hLocal  - handle (pointer) of block for which to get size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    SIZE_T size;

    if (hDebugHeap != NULL) {
        size = HeapSize(hDebugHeap,
                        bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                        (LPCVOID)hLocal
                        );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapSize(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        size = (SIZE_T)-1;
    }
    if (size == (SIZE_T)-1) {
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    } else {
        return size;
    }
}


PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )

/*++

Routine Description:

    Checks the consistency of a debug memory block

Arguments:

    lpHeader    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    BOOL result;

    __try {
        LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)
            ((LPBYTE)lpHeader
                + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)));

        BOOL headerGuardOverrun = FALSE;
        UINT i;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuardOverrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuard2Overrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        LPBYTE lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RequestedLength;
        BOOL extraMemoryOverrun = FALSE;
        SIZE_T byteLength = ROUND_UP_DWORD(lpHeader->RequestedLength) - lpHeader->RequestedLength;

        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_ALLOC_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %#x\n",
                        lpHeader
                        ));

            MEMORY_ASSERT(FALSE);

            result = FALSE;
        } else {
            result = TRUE;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %#x - exception occurred\n",
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
InternetDebugMemTest(
    VOID
    )
{
    //
    // test
    //

    LPVOID p;

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 1);
    *((LPBYTE)p + 1) = 'X';
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 1);
    p = (LPVOID)REALLOCATE_MEMORY(p, 1111, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 439, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 720, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 256, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 16, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 128, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 32, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 4, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 63, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 8);
    p = (LPVOID)REALLOCATE_MEMORY(p, 8, LMEM_FIXED);
    p = (LPVOID)REALLOCATE_MEMORY(p, 100000, LMEM_FIXED);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    InternetDebugCheckMemFreed(TRUE);
}


PRIVATE
VOID
ReportMemoryUsage(
    VOID
    )
{
    //
    // make copies of variables in case debug print functions want to allocate
    // debug memory (!)
    //

    SIZE_T totalActualMemoryAllocated;
    SIZE_T totalBlockMemoryAllocated;
    SIZE_T totalRealMemoryAllocated;
    SIZE_T totalActualMemoryFreed;
    SIZE_T totalBlockMemoryFreed;
    SIZE_T totalRealMemoryFreed;
    SIZE_T actualMemoryAllocated;
    SIZE_T blockLengthAllocated;
    SIZE_T realLengthAllocated;
    DWORD memoryAllocations;
    DWORD goodMemoryAllocations;
    DWORD memoryReAllocations;
    DWORD goodMemoryReAllocations;
    DWORD memoryFrees;
    DWORD goodMemoryFrees;
    SIZE_T largestBlockRequested;
    SIZE_T largestBlockAllocated;
    SIZE_T smallestBlockRequested;
    SIZE_T smallestBlockAllocated;

    EnterCriticalSection(&MemoryVarsCritSec);

    totalActualMemoryAllocated = TotalActualMemoryAllocated;
    totalBlockMemoryAllocated = TotalBlockMemoryAllocated;
    totalRealMemoryAllocated = TotalRealMemoryAllocated;
    totalActualMemoryFreed = TotalActualMemoryFreed;
    totalBlockMemoryFreed = TotalBlockMemoryFreed;
    totalRealMemoryFreed = TotalRealMemoryFreed;
    actualMemoryAllocated = ActualMemoryAllocated;
    blockLengthAllocated = BlockLengthAllocated;
    realLengthAllocated = RealLengthAllocated;
    memoryAllocations = MemoryAllocations;
    goodMemoryAllocations = GoodMemoryAllocations;
    memoryReAllocations = MemoryReAllocations;
    goodMemoryReAllocations = GoodMemoryReAllocations;
    memoryFrees = MemoryFrees;
    goodMemoryFrees = GoodMemoryFrees;
    largestBlockRequested = LargestBlockRequested;
    largestBlockAllocated = LargestBlockAllocated;
    smallestBlockRequested = SmallestBlockRequested;
    smallestBlockAllocated = SmallestBlockAllocated;

    LeaveCriticalSection(&MemoryVarsCritSec);

#ifdef _WIN64
    char numBuf[64];
#else
    char numBuf[32];
#endif

    DEBUG_PUT(("********************************************************************************\n"
               "\n"
               "WinHttp Debug Memory Usage:\n"
               "\n"
               "\tInternetDebugMemFlags = %#08x\n"
               "\n",
               InternetDebugMemFlags
               ));
    DEBUG_PUT(("\tTotal Memory Allocated. . . , . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Block Length Allocated. . . . . %s\n", NiceNum(numBuf, totalBlockMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal User Length Allocated . . . . . %s\n", NiceNum(numBuf, totalRealMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Memory Freed. . . . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal Block Length Freed. . . . . . . %s\n", NiceNum(numBuf, totalBlockMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal User Length Freed . . . . . . . %s\n", NiceNum(numBuf, totalRealMemoryFreed, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, actualMemoryAllocated, 0)));
    DEBUG_PUT(("\tBlock Length Still Allocated. . . . . %s\n", NiceNum(numBuf, blockLengthAllocated, 0)));
    DEBUG_PUT(("\tUser Length Still Allocated . . . . . %s\n", NiceNum(numBuf, realLengthAllocated, 0)));
    DEBUG_PUT(("\tAttempted Memory Allocations. . . . . %s\n", NiceNum(numBuf, memoryAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Allocations . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Reallocations. . . . %s\n", NiceNum(numBuf, memoryReAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Reallocations . . . . . . %s\n", NiceNum(numBuf, goodMemoryReAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Frees. . . . . . . . %s\n", NiceNum(numBuf, memoryFrees, 0)));
    DEBUG_PUT(("\tGood Memory Frees . . . . . . . . . . %s\n", NiceNum(numBuf, goodMemoryFrees, 0)));
    DEBUG_PUT(("\tLargest Block Requested . . . . . . . %s\n", NiceNum(numBuf, largestBlockRequested, 0)));
    DEBUG_PUT(("\tLargest Block Allocated . . . . . . . %s\n", NiceNum(numBuf, largestBlockAllocated, 0)));
    DEBUG_PUT(("\tLargest Block Requested From. . . . . %s!%d\n", SourceFilename(LargestBlockRequestedFile), LargestBlockRequestedLine));
    DEBUG_PUT(("\tSmallest Block Requested. . . . . . . %s\n", NiceNum(numBuf, smallestBlockRequested, 0)));
    DEBUG_PUT(("\tSmallest Block Allocated. . . . . . . %s\n", NiceNum(numBuf, smallestBlockAllocated, 0)));
    DEBUG_PUT(("\tSmallest Block Requested From . . . . %s!%d\n", SourceFilename(SmallestBlockRequestedFile), SmallestBlockRequestedLine));
    DEBUG_PUT(("\n"
               "\tBlocks Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations - goodMemoryFrees, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated - totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\n"
               "********************************************************************************\n"
               "\n"));
}


PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    )
{
    DEBUG_PUT(("ReportMemoryBlocks\n\n"));

    DEBUG_PUT(("AllocatedBlockList:\n\n"));

    DumpMemoryList(&AllocatedBlockList);
    if (bDeferFree) {
        DumpDeferredFreeList();
    }
}


PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    )
{
    DEBUG_PUT(("DeferredFreeList:\n\n"));

    DumpMemoryList(&DeferredFreeList);
}


PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;
    int counter = 1;

    if (bUseSymbols) {

        //
        // have to load IMAGEHLP.DLL here because we're in DLL_PROCESS_DETACH
        // and if we loaded it earlier, there's a good chance the system has
        // already freed it
        //

        InitSymLib();
    }

    LockSerializedList(lpList);
    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(lpList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(lpList)) {

        DEBUG_PUT(("Block # %d\n", counter));


        if (!DumpBlock(lpHeader)) {
            break;
        }

        DEBUG_PUT(("********************************************************************************\n\n"));

        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
        ++counter;
    }
    UnlockSerializedList(lpList);
}


PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;

    LockSerializedList(&DeferredFreeList);

    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(&DeferredFreeList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(&DeferredFreeList)) {
        if (hLocal == (HLOCAL)lpHeader) {
            DumpBlock(lpHeader);
            break;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
    }

    UnlockSerializedList(&DeferredFreeList);
}


PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    BOOL ok = DumpDebugMemoryHeader(lpHeader);

    if (!ok && bStopDumpIfBadBlock) {

        DEBUG_PUT(("*** stopping block dump: header @ %#x is bad\n", lpHeader));

        return FALSE;
    }
    if (bReportUserData) {
        DumpUserData(lpHeader);
    }
    if (bReportMemoryFooters) {

        LPDEBUG_MEMORY_FOOTER lpFooter;

        lpFooter = (LPDEBUG_MEMORY_FOOTER)
                        ((LPBYTE)lpHeader
                        + sizeof(*lpHeader)
                        + ROUND_UP_DWORD(lpHeader->RequestedLength));
        ok = DumpDebugMemoryFooter(lpFooter);
        if (!ok && bStopDumpIfBadBlock) {

            DEBUG_PUT(("*** stopping block dump: footer @ %#x is bad\n", lpFooter));

            return FALSE;
        }
    }
    return TRUE;
}


PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    char numBuf[32];
    BOOL result;
    LPSTR symbol;
    DWORD offset;
    int i;
    char flagsBuf[256];

    __try {
        DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x:\n"
                   "\n",
                   lpHeader
                   ));
        DEBUG_PUT(("\tList. . . . . . . . . F=%#x B=%#x\n",
                   lpHeader->List.Flink,
                   lpHeader->List.Blink
                   ));
        DEBUG_PUT(("\tThread. . . . . . . . %#x\n",
                   lpHeader->ThreadId
                   ));
        DEBUG_PUT(("\tAllocated From. . . . %s!%d\n",
                   SourceFilename(lpHeader->CreatedFile),
                   lpHeader->CreatedLine
                   ));
        DEBUG_PUT(("\tLast Accessed From. . %s!%d\n",
                   SourceFilename(lpHeader->AccessedFile),
                   lpHeader->AccessedLine
                   ));
        DEBUG_PUT(("\tRequested Length. . . %s\n",
                   NiceNum(numBuf, lpHeader->RequestedLength, 0)
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpHeader->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tActual Length . . . . %s\n",
                   NiceNum(numBuf, lpHeader->ActualLength, 0)
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpHeader->Signature,
                   (lpHeader->Signature == HEADER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tFlags . . . . . . . . %08x %s\n",
                   lpHeader->Flags,
                   MapMemoryFlags(lpHeader->Flags, flagsBuf)
                   ));
        DEBUG_PUT(("\tTime Deferred . . . . %08x\n",
                   lpHeader->TimeDeferred
                   ));
        DEBUG_PUT(("\tClash Test. . . . . . %d\n",
                   lpHeader->ClashTest
                   ));
        DEBUG_PUT(("\tLast Operation. . . . %s\n",
                   MapLastAccessOperation(lpHeader->LastAccessOperation)
                   ));

#if DUMP_STACK
#if ONE_STACK

        if (lpHeader->Stack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tStack . . . . . . . . %08x %s+%#x\n",
                   lpHeader->Stack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->Stack); ++i) {
            //if (!lpHeader->lpHeader->Stack[i]) {
            //    break;
            //}
            if (lpHeader->Stack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->Stack[i],
                       symbol,
                       offset
                       ));
        }

#else

        if (lpHeader->LastAccessStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tLastAccessStack . . . %08x %s+%#x\n",
                   lpHeader->LastAccessStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->LastAccessStack); ++i) {
            //if (!lpHeader->LastAccessStack[i]) {
            //    break;
            //}
            if (lpHeader->LastAccessStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->LastAccessStack[i],
                       symbol,
                       offset
                       ));
        }
        if (lpHeader->CreateStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tCreateStack . . . . . %08x %s+%#x\n",
                   lpHeader->CreateStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->CreateStack); ++i) {
            //if (!lpHeader->lpHeader->CreateStack[i]) {
            //    break;
            //}
            if (lpHeader->CreateStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->CreateStack[i],
                       symbol,
                       offset
                       ));
        }

#endif // ONE_STACK
#endif // DUMP_STACK

        DEBUG_PUT(("\tGuard . . . . . . . . %08x\n"
                   "\n",
                   lpHeader->Guard[0]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x is BAD\n", lpHeader));

        result = FALSE;
    }
    return result;
}


PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    )
{
    char numBuf[32];
    BOOL result;

    _try {
        DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x:\n"
                   "\n",
                   lpFooter
                   ));
        DEBUG_PUT(("\tGuard . . . . . . . . %08x %08x %08x %08x\n",
                   lpFooter->Guard[0],
                   lpFooter->Guard[1],
                   lpFooter->Guard[2],
                   lpFooter->Guard[3]
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpFooter->Signature,
                   (lpFooter->Signature == FOOTER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpFooter->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tGuard2. . . . . . . . %08x %08x\n"
                   "\n",
                   lpFooter->Guard2[0],
                   lpFooter->Guard2[1]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x is BAD\n", lpFooter));

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    static char spaces[] = "                                              ";    // 15 * 3 + 2
    SIZE_T userSize = lpHeader->RequestedLength;
    SIZE_T Size = ROUND_UP_DWORD(userSize);
    LPBYTE Address = (LPBYTE)(lpHeader + 1);

    DEBUG_PUT(("\t%d (%#x) bytes of user data (rounded to %d (%#x)) @ %#x\n\n",
               userSize,
               userSize,
               Size,
               Size,
               Address
               ));

    if (bLimitUserData && (Size > MaxUserDataDumped)) {

        DEBUG_PUT(("*** User data length %d too large: limited to %d (probably bad block)\n",
                   Size,
                   MaxUserDataDumped
                   ));

        Size = MaxUserDataDumped;
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        char buf[128];
        int len;
        int clen;

        rsprintf(buf, "\t%08x  ", Address);

        clen = (int)min(Size, 16);
        if (bDumpAsDwords) {
            len = clen / 4;
        } else {
            len = clen;
        }

        //
        // dump the hex representation of each character - up to 16 per line
        //

        int i;

        for (i = 0; i < len; ++i) {
            if (bDumpAsDwords) {
                rsprintf(&buf[11 + i * 9], "%08x ", ((LPDWORD)Address)[i]);
            } else {
                rsprintf(&buf[11 + i * 3],
                         ((i & 15) == 7) ? "%02.2x-" : "%02.2x ",
                         Address[i] & 0xff
                         );
            }
        }

        //
        // write as many spaces as required to tab to ASCII field
        //

        int offset;

        if (bDumpAsDwords) {
            memcpy(&buf[11 + i * 9], spaces, (4 - len) * 9 + 2);
            offset = 49;
        } else {
            memcpy(&buf[11 + i * 3], spaces, (16 - len) * 3 + 2);
            offset = 60;
        }

        //
        // dump ASCII representation of each character
        //

        for (i = 0; i < clen; ++i) {

            char ch;

            ch = Address[i];
            buf[offset + i] = ((ch < 32) || (ch > 127)) ? '.' : ch;
        }

        buf[offset + i++] = '\r';
        buf[offset + i++] = '\n';
        buf[offset + i] = 0;

        //
        // InternetDebugOut() - no printf expansion (%s in data!), no prefixes
        //

        InternetDebugOut(buf, FALSE);

        Address += clen;
        Size -= clen;
    }

    InternetDebugOut("\r\n", FALSE);
}


PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    )
{
    switch (Action) {
    case MemAllocate:
        return "Alloc";

    case MemReallocate:
        return "Realloc";

    case MemLock:
        return "Lock";

    case MemUnlock:
        return "Unlock";

    case MemFree:
        return "Free";

    case MemSize:
        return "Size";
    }
    return "?";
}


PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    )
{
    LPSTR buf = Buffer;
    int i = 0;

    *buf++ = '(';
    if (Flags & LMEM_DISCARDABLE) {
        buf += wsprintf(buf, "DISCARDABLE");
        ++i;
    }
    if (Flags & LMEM_ZEROINIT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "ZEROINIT");
    }
    if (Flags & LMEM_NODISCARD) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NODISCARD");
    }
    if (Flags & LMEM_NOCOMPACT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NOCOMPACT");
    }
    if (i) {
        buf += wsprintf(buf, ", ");
    }
    ++i;
    buf += wsprintf(buf, (Flags & LMEM_MOVEABLE) ? "MOVEABLE" : "FIXED");
    *buf++ = ')';
    *buf++ = '\0';
    return Buffer;
}


PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    ) {
    //if (!bUseSymbols) {
    //    return "?";
    //}

    //
    // RLF 04/14/98 - IMAGEHLP blowing up probably because we are doing this at
    //                process detach time. Just return offset and run convsym
    //                utility on WinHttp.log
    //

    //return GetDebugSymbol(Address, Offset);
    *Offset = Address;
    return "";
}

#endif // defined(USE_DEBUG_MEMORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\debug\rprintf.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rprintf.cxx

Abstract:

    Contains my own version of printf(), sprintf() and vprintf(). Useful since
    adding new printf escape sequences becomes easy

    Contents:
        rprintf     limited re-entrant version of printf
        rsprintf    limited re-entrant version of sprintf
        _sprintf    routine which does the work

Author:

    Richard L Firth (rfirth) 20-Jun-1995

Revision History:

    29-Aug-1989 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

//
// defines for flags word
//

#define F_SPACES        0x00000001  // prefix field with spaces
#define F_ZEROES        0x00000002  // prefix field with zeroes
#define F_MINUS         0x00000004  // field is left justified
#define F_HASH          0x00000008  // hex field is prefixed with 0x/0X
#define F_XUPPER        0x00000010  // hex field has upper case letters
#define F_LONG          0x00000020  // long int/hex/oct prefix
#define F_PLUS          0x00000040  // prefix +'ve signed number with +
#define F_DOT           0x00000080  // separator for field and precision
#define F_NEAR          0x00000100  // far pointer has near prefix
#define F_FAR           0x00000200  // near pointer has far prefix
#define F_SREPLICATE    0x00000400  // this field replicated
#define F_EREPLICATE    0x00000800  // end of replications
#define F_UNICODE       0x00001000  // string is wide character (%ws/%wq)
#define F_QUOTING       0x00002000  // strings enclosed in double quotes
#define F_ELLIPSE       0x00004000  // a sized, quoted string ends in "..."

#define BUFFER_SIZE     1024

//
// minimum field widths for various ASCII representations of numbers
//

#define MIN_BIN_WIDTH   16          // minimum field width in btoa
#define MIN_HEX_WIDTH   8           // minimum field width in xtoa
#define MIN_INT_WIDTH   10          // minimum field width in itoa
#define MIN_LHEX_WIDTH  8           // minimum field width in long xtoa
#define MIN_LINT_WIDTH  10          // minimum field width in long itoa
#define MIN_LOCT_WIDTH  11          // minimum field width in long otoa
#define MIN_OCT_WIDTH   11          // minimum field width in otoa
#define MIN_UINT_WIDTH  10          // minimum field width in utoa

//
// character defines
//

#define EOSTR           '\0'
#define CR              '\x0d'
#define LF              '\x0a'

#if !defined(min)

#define min(a, b)   ((a)<(b)) ? (a) : (b)

#endif

PRIVATE int     _atoi(char**);
PRIVATE void    convert(char**, ULONG_PTR, int, int, unsigned, char(*)(ULONG_PTR*));
PRIVATE char    btoa(ULONG_PTR *);
PRIVATE char    otoa(ULONG_PTR *);
PRIVATE char    utoa(ULONG_PTR *);
PRIVATE char    xtoa(ULONG_PTR *);
PRIVATE char    Xasc(ULONG_PTR *);

/***    rprintf - a re-entrant cut-down version of printf. Understands usual
 *                  printf format characters introduced by '%' plus one or
 *                  two additions
 *
 *      ENTRY   format  - pointer to buffer containing format string defining
 *                        the output. As per usual printf the arguments to
 *                        fill in the blanks in the format string are on the
 *                        the stack after the format string
 *
 *              <args>  - arguments on stack, size and type determined from
 *                        the format string
 *
 *      EXIT    format string used to convert arguments (if any) and print
 *              the results to stdout.
 *              The number of character copied is the value returned
 */

#ifdef UNUSED
int cdecl rprintf(char* format, ...) {

    int charsPrinted = 0;
    char buffer[BUFFER_SIZE];
    DWORD nwritten;
    va_list args;

    /* print the output into  buffer then print the formatted buffer to the
     * screen
     */

    va_start(args, format);
    charsPrinted = _sprintf(buffer, format, args);
    va_end(args);

    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                              buffer,
                              charsPrinted,
                              &nwritten,
                              0
                              );
    return nwritten;
}
#endif

/***    rsprintf - a re-entrant cut-down version of sprintf. See rprintf for
 *                  details
 *
 *      ENTRY   buffer  - pointer to the buffer which will receive the
 *                        formatted output
 *
 *              format  - pointer to buffer which defines the formatted
 *                        output. Consists of normal printing characters
 *                        and printf-style format characters (see rprintf)
 *
 *      EXIT    characters from format string and arguments converted to
 *              character format based on format string are copied into the
 *              buffer
 *              The number of character copied is the value returned
 */

int cdecl rsprintf(char* buffer, char* format, ...) {

    va_list args;
    int n;

    va_start(args, format);
    n = _sprintf(buffer, format, args);
    va_end(args);
    return n;
}

/***    _sprintf - performs the sprintf function. Receives an extra parameter
 *                  on the stack which is the pointer to the variable argument
 *                  list of rprintf and rsprintf
 *
 *      ENTRY   buffer  - pointer to buffer which will receive the output
 *
 *              format  - pointer to the format string
 *
 *              args    - variable argument list which will be used to fill in
 *                        the escape sequences in the format string
 *
 *      EXIT    The characters in the format string are used to convert the
 *              arguments and copy them to the buffer.
 *              The number of character copied is the value returned
 */

int cdecl _sprintf(char* buffer, char* format, va_list args) {

    char*       original = buffer;
    int         FieldWidth;
    int         FieldPrecision;
    int         FieldLen;
    BOOL        SubDone;
    int         StrLen;
    int         i;
    DWORD       flags;
    int         replications;

    while (*format) {
        switch ((unsigned)*format) {
        case '\n':

            //
            // convert line-feed to carriage-return, line-feed. But only if the
            // format string doesn't already contain a carriage-return directly
            // before the line-feed! This way we can make multiple calls into
            // this function, with the same buffer, and only once expand the
            // line-feed
            //

            if (*(buffer - 1) != CR) {
                *buffer++ = CR;
            }
            *buffer++ = LF;
            break;

        case '%':
            SubDone = FALSE;
            flags = 0;
            FieldWidth = 0;
            FieldPrecision = 0;
            replications = 1;   /* default replication is 1 */
            while (!SubDone) {
                switch ((unsigned)*++format) {
                case '%':
                    *buffer++ = '%';
                    SubDone = TRUE;
                    break;

                case ' ':
                    flags |= F_SPACES;
                    break;

                case '#':
                    flags |= F_HASH;
                    break;

                case '-':
                    flags |= F_MINUS;
                    break;

                case '+':
                    flags |= F_PLUS;
                    break;

                case '.':
                    flags |= F_DOT;
                    break;

                case '*':
                    if (flags & F_DOT) {
                        FieldPrecision = va_arg(args, int);
                    } else {
                        FieldWidth = va_arg(args, int);
                    }
                    break;

                case '@':
                    replications = _atoi(&format);
                    break;

                case '[':
                    flags |= F_SREPLICATE;
                    break;

                case ']':
                    flags |= F_EREPLICATE;
                    break;

                case '0':
                    /* if this is leading zero then caller wants
                     * zero prefixed number of given width (%04x)
                     */
                    if (!(flags & F_ZEROES)) {
                        flags |= F_ZEROES;
                        break;
                    }

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (flags & F_DOT) {
                        FieldPrecision = _atoi(&format);
                    } else {
                        FieldWidth = _atoi(&format);
                    }
                    break;

                case 'b':

                    //
                    // Binary representation
                    //

                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned int),
                                (FieldWidth) ? FieldWidth : MIN_BIN_WIDTH,
                                MIN_BIN_WIDTH,
                                flags,
                                btoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'B':

                    //
                    // Boolean representation
                    //

                    if (va_arg(args, BOOL)) {
                        *buffer++ = 'T';
                        *buffer++ = 'R';
                        *buffer++ = 'U';
                        *buffer++ = 'E';
                    } else {
                        *buffer++ = 'F';
                        *buffer++ = 'A';
                        *buffer++ = 'L';
                        *buffer++ = 'S';
                        *buffer++ = 'E';
                    }
                    SubDone = TRUE;
                    break;

                case 'c':

                    //
                    // assume that a character is the size of the
                    // width of the stack which in turn has the same
                    // width as an integer
                    //

                    --FieldWidth;
                    while (replications--) {
                        for (i = 0; i < FieldWidth; i++) {
                            *buffer++ = ' ';
                        }
                        *buffer++ = (char) va_arg(args, int);
                    }
                    SubDone = TRUE;
                    break;

                case 'd':
                case 'i':
                    while (replications--) {

                        long l;

                        l = (flags & F_LONG) ? va_arg(args, long) : (long)va_arg(args, int);
                        if (l < 0) {
                            *buffer++ = '-';
                            if (flags & F_LONG) {
                                l = -(long)l;
                            } else {
                                l = -(int)l;
                            }
                        } else if (flags & F_PLUS) {
                            *buffer++ = '+';
                        }
                        convert(&buffer,
                                l,
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LINT_WIDTH : MIN_INT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'e':
                    /* not currently handled */
                    break;

                case 'f':
                    /* not currently handled */
                    break;

                case 'F':
                    flags |= F_FAR;
                    break;

                case 'g':
                case 'G':
                    /* not currently handled */
                    break;

                case 'h':
                    /* not currently handled */
                    break;

                case 'l':
                    flags |= F_LONG;
                    break;

                case 'L':
                    /* not currently handled */
                    break;

                case 'n':
                    *(va_arg(args, int*))  = (int)(buffer - original);
                    SubDone = TRUE;
                    break;

                case 'N':
                    flags |= F_NEAR;
                    break;

                case 'o':
                    while (replications--) {
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : (unsigned long)va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LOCT_WIDTH : MIN_OCT_WIDTH,
                                flags,
                                otoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'p':
                    while (replications--) {

                        void* p;

                        if (!(flags & F_NEAR)) {
                            convert(&buffer,
                                    (ULONG_PTR) va_arg(args, char near *),
                                    MIN_HEX_WIDTH,
                                    MIN_HEX_WIDTH,
                                    flags | F_XUPPER,
                                    Xasc
                                    );
                            *buffer++ = ':';
                        }
                        convert(&buffer,
                                (ULONG_PTR)va_arg(args, unsigned),
                                MIN_HEX_WIDTH,
                                MIN_HEX_WIDTH,
                                flags | F_XUPPER,
                                Xasc
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'Q':       // quoted unicode string
                    flags |= F_UNICODE;
                    // *** FALL THROUGH ***

                case 'q':
                    *buffer++ = '"';
                    flags |= F_QUOTING;

                    //
                    // *** FALL THROUGH ***
                    //

                case 's':
                    while (replications--) {

                        char* s;

                        s = va_arg(args, char*);
                        if (s != NULL) {
                            // darrenmi 2/24/00 Note that if the string has a field precision,
                            // it's not always null terminated!! Don't depend on it being psz
                            // and stop when we hit our max length.
                            StrLen = 0;

                            if (flags & F_UNICODE) {
                                WCHAR   *pWork = (LPWSTR)s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            } else {
                                CHAR    *pWork = s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            }
                            
                            FieldLen = (FieldPrecision)
                                        ? min(StrLen, FieldPrecision)
                                        : StrLen
                                        ;
                            if ((flags & F_QUOTING) && (FieldPrecision > 3) && (FieldLen < StrLen)) {
                                FieldLen -= 3;
                                flags |= F_ELLIPSE;
                            }

                            for (i = 0; i < (FieldWidth - FieldLen); i++) {
                                *buffer++ = ' ';
                            }

                            if (flags & F_UNICODE) {

                                char wbuf[4096];
                                int wi;

                                WideCharToMultiByte(CP_ACP, 0,
                                        (LPWSTR)s, -1,
                                        wbuf, 4096,
                                        NULL, NULL);

                                for (wi = 0; wbuf[wi] && FieldLen; ++wi) {
                                    *buffer = wbuf[wi];

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            } else {
                                while (*s && FieldLen) {
                                    *buffer = *s++;

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            }
                            if (flags & F_ELLIPSE) {
                                *buffer++ = '.';
                                *buffer++ = '.';
                                *buffer++ = '.';
                            }
                        } else if (!(flags & F_QUOTING)) {
                            *buffer++ = '(';
                            *buffer++ = 'n';
                            *buffer++ = 'u';
                            *buffer++ = 'l';
                            *buffer++ = 'l';
                            *buffer++ = ')';
                        }
                    }
                    if (flags & F_QUOTING) {
                        *buffer++ = '"';
                    }
                    SubDone = TRUE;
                    break;

                case 'S':
                    break;

                case 'u':
                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned),
                                FieldWidth,
                                MIN_UINT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'w':
                    flags |= F_UNICODE;
                    break;

                case 'X':
                    flags |= F_XUPPER;

                    //
                    // *** FALL THROUGH ***
                    //

                case 'x':
                    while (replications--) {
                        if (flags & F_HASH) {
                            *buffer++ = '0';
                            *buffer++ = (flags & F_XUPPER) ? (char)'X' : (char)'x';
                        }
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LHEX_WIDTH : MIN_HEX_WIDTH,
                                flags,
                                (flags & F_XUPPER) ? Xasc : xtoa
                                );
                    }
                    SubDone = TRUE;
                    break;
                } /* switch <%-specifier> */
            }
            break;

        default:
            *buffer++ = *format;
        } /* switch <character> */
        ++format;
    } /* while */
    *buffer = EOSTR;
    return (int)(buffer - original);
}

/***    _atoi - ascii to integer conversion used to get the field width out
 *              of the format string
 *
 *      ENTRY   p - pointer to pointer to format string
 *
 *      EXIT    returns the number found in the prefix string as a (16-bit)
 *              int format string pointer is updated past the field width
 */

PRIVATE
int _atoi(char** p) {

    int n = 0;
    int i = 5;

    while ((**p >= '0' && **p <= '9') && i--) {
        n = n*10+((int)(*(*p)++)-(int)'0');
    }

    /* put the format pointer back one since the major loop tests *++format */

    --*p;
    return n;
}

/***    convert - convert number to representation defined by procedure
 *
 *      ENTRY   buffer  - pointer to buffer to receive conversion
 *              n       - number to convert
 *              width   - user defined field width
 *              mwidth  - minimum width for representation
 *              flags   - flags controlling conversion
 *              proc    - pointer to conversion routine
 *
 *      EXIT    buffer is updated to point past the number representation
 *              just put into it
 */

PRIVATE
void
convert(
    char** buffer,
    ULONG_PTR n,
    int width,
    int mwidth,
    unsigned flags,
    char (*proc)(ULONG_PTR*)
    )
{
    char    numarray[33];
    int     MinWidth;
    int     i;

    MinWidth = (width < mwidth) ? mwidth : width;
    i = MinWidth;
    do {
        numarray[--i] = (*proc)(&n);
    } while (n);
    while (width > MinWidth-i) {
        numarray[--i] = (char)((flags & F_SPACES) ? ' ' : '0');
    }
    while (i < MinWidth) {
        *(*buffer)++ = numarray[i++];
    }
}

/***    btoa - return next (least significant) char in a binary to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char btoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)(*pn&1)+'0';
    *pn >>= 1;
    return rch;
}

/***    otoa - return next (least significant) char in an octal to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char otoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn&7);
    *pn >>= 3;
    return rch;
}

/***    utoa - return next (least significant) char in an unsigned int to
 *              ASCII conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char utoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn%10);
    *pn /= 10;
    return rch;
}

/***    xtoa - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns lower case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char xtoa(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9) /* decimal digit? */
                      ? (char)n+'0'
                      : (char)n+'0'+('a'-'9'-1);

    *pn >>= 4;
    return rch;
}

/***    Xasc - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns upper case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char Xasc(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9) /* decimal digit? */
                        ? (char)n+'0'
                        : (char)n+'0'+('A'-'9'-1);

    *pn >>= 4;
    return rch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains utility functions

    Contents:
        new
        delete
        NewString
        CatString
        ResizeBuffer
        _memrchr
        strnistr
        PrivateStrChr
        PlatformType
        PlatformSupport
        GetTimeoutValue
        ProbeReadBuffer
        ProbeWriteBuffer
        ProbeAndSetDword
        ProbeString
        LoadDllEntryPoints
        UnloadDllEntryPoints
        MapInternetError
        CalculateHashValue
        GetCurrentGmtTime
        GetFileExtensionFromUrl
        FTtoString
        PrintFileTimeInInternetFormat
        CertHashToStr
        ConvertSecurityInfoIntoCertInfoStruct
        UnicodeToUtf8
        CountUnicodeToUtf8
        ConvertUnicodeToUtf8
        StringContainsHighAnsi

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>

#if !defined(PAGE_SIZE)
#define PAGE_SIZE   4096
#endif
#define DEFAULT_MAX_EXTENSION_LENGTH    8

//
// private prototypes
//


#ifndef WINHTTP_FOR_MSXML
//
// functions
//
void * __cdecl operator new(size_t Size) {
    return (void *)ALLOCATE_FIXED_MEMORY((UINT)Size);
}

void __cdecl operator delete(void * Pointer) {
    FREE_MEMORY((HLOCAL)Pointer);
}
#endif //!WINHTTP_FOR_MSXML

#ifdef USE_ROCKALL
#ifdef New
#undef New


#define SIZE_DIFF 1

#if INET_DEBUG
#   include <DebugHeap.hpp>
#   define ROCKALL_HEAP    DEBUG_HEAP
#else
#   include <SmpHeap.hpp>
#   define ROCKALL_HEAP    SMP_HEAP
#endif

ROCKALL_HEAP * s_pRockAllHeap;

BYTE           s_RockAllHeapStaticBuffer[sizeof(ROCKALL_HEAP)];


void INITIALIZE_MEMORY_MANAGER()
{
    s_pRockAllHeap = (ROCKALL_HEAP *) s_RockAllHeapStaticBuffer;
    s_pRockAllHeap->ROCKALL_HEAP::ROCKALL_HEAP();
}

void TERMINATE_MEMORY_MANAGER(BOOL bReport)
{
    if (s_pRockAllHeap)
    {
#if INET_DEBUG
        if (bReport)
        {
            s_pRockAllHeap->HeapLeaks();
        }
#endif
        s_pRockAllHeap->ROCKALL_HEAP::~ROCKALL_HEAP();
        s_pRockAllHeap = NULL;
        ZeroMemory(s_RockAllHeapStaticBuffer, sizeof(s_RockAllHeapStaticBuffer));
    }
}

void *
ALLOCATOR(int Flags, int Size)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    return s_pRockAllHeap->New(Size, NULL, ((Flags & LMEM_ZEROINIT) ? true : false));
}

void *
DEALLOCATOR(void * hLocal)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    DWORD error = GetLastError();
    void * p = (s_pRockAllHeap->Delete(hLocal) ? NULL : hLocal);
    SetLastError(error);
    return p;
}

void *
REALLOCATOR(void * hLocal, int Size, int Flags)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    return s_pRockAllHeap->Resize(hLocal, 
                    Size, 
                    ((Flags & LMEM_MOVEABLE) ? SIZE_DIFF : 0), 
                    NULL, 
                    false, 
                    ((Flags & LMEM_ZEROINIT) ? true : false));
}

int
MEMORYSIZER(void * hLocal)
{
    int Size;
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    s_pRockAllHeap->Details(hLocal, &Size);
    return Size;
}
#endif
#endif

LPSTR
NewString(
    IN LPCSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : strlen(lpszIn));
    LPSTR lpszOut;

    if (lpszOut = (LPSTR)ALLOCATE_FIXED_MEMORY(len+1)) {
        memcpy(lpszOut, lpszIn, len);
        *(lpszOut + len) = '\0';
    }
    return lpszOut;
}

LPWSTR
NewStringW(
    IN LPCWSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : lstrlenW(lpszIn));
    LPWSTR lpszOut;

    if (lpszOut = (LPWSTR)ALLOCATE_FIXED_MEMORY((sizeof(WCHAR)*(len+1)))) {
        memcpy(lpszOut, lpszIn, len*sizeof(WCHAR));
        *(lpszOut + len) = L'\0';
    }
    return lpszOut;
}

/*++

Routine Description:

    kind of version of strcat() but using LocalAlloc to allocate memory

Arguments:

    strings to concatenate

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    )
{
    int cbLeft  = strlen(lpszLeft);
    int cbRight = strlen(lpszRight) + 1; // include null termination
    LPSTR lpszOut;

    if (lpszOut = (LPSTR) ALLOCATE_FIXED_MEMORY (cbLeft + cbRight)) {
        memcpy (lpszOut, lpszLeft, cbLeft);
        memcpy (lpszOut + cbLeft, lpszRight, cbRight);
    }
    return lpszOut;
}



HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    )

/*++

Routine Description:

    Allocate, reallocate or free a buffer. If the buffer is moveable memory
    then it must be unlocked. If reallocating, the buffer can be grown or
    shrunk, depending on the current and required sizes

    Caveat Programmer:

    Regardless of whether a pre-existing buffer is moveable or fixed memory,
    it will be reallocated with the LMEM_MOVEABLE flag, possibly causing the
    output pointer to be different from the pre-existing pointer

Arguments:

    BufferHandle    - current handle of memory buffer. If NULL, a buffer will
                      be allocated

    Size            - size of buffer to allocate (or shrink to). If 0, the
                      buffer will be freed

    Moveable        - if TRUE and allocating memory then allocates a moveable
                      memory buffer, else fixed

Return Value:

    HLOCAL
        Success - handle of moveable memory buffer

        Failure - NULL;

--*/

{
    INET_ASSERT(!Moveable);

    if (BufferHandle == NULL) {

        //
        // don't allocate anything if no size - LocalAlloc() will return pointer
        // to memory object marked as discarded if we request a zero-length
        // moveable buffer. But I know that if Size is also 0, I don't want a
        // buffer at all, discarded or otherwise
        //

        if (Size != 0) {
            BufferHandle = ALLOCATE_MEMORY(Moveable ? LMEM_MOVEABLE : LMEM_FIXED, Size);
        }
    } else if (Size == 0) {
        BufferHandle = FREE_MEMORY(BufferHandle);

        INET_ASSERT(BufferHandle == NULL);

    } else {
        BufferHandle = REALLOCATE_MEMORY(BufferHandle, Size, LMEM_MOVEABLE);
    }
    return BufferHandle;
}


LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    )

/*++

Routine Description:

    Reverse find character in string

Arguments:

    lpString    - pointer to string in which to locate character

    cTarget     - target character to find

    iLength     - length of string

Return Value:

    LPSTR   - pointer to located character or NULL

--*/

{
    for (--iLength; (iLength >= 0) && (lpString[iLength] != cTarget); --iLength) {

        //
        // empty loop
        //

    }
    return (iLength < 0) ? NULL : &lpString[iLength];
}


LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    )

/*++

Routine Description:

    Case-insensitive search for substring

Arguments:

    str1    - string to search in

    str2    - substring to find

    Length  - of str1

Return Value:

    LPSTR   - pointer to located str2 in str1 or NULL

--*/

{
    if (!*str2) {
        return str1;
    }

    for (LPSTR cp = str1; *cp && Length; ++cp, --Length) {

        LPSTR s1 = cp;
        LPSTR s2 = str2;
        DWORD l2 = Length;

        while (*s1 && *s2 && l2 && (toupper(*s1) == toupper(*s2))) {
            ++s1;
            ++s2;
            --l2;
        }

        if (!*s2) {
            return cp;
        }

        if (!l2) {
            break;
        }
    }

    return NULL;
}

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    )
/*++

Routine Description:

    Find first occurrence of character in string

    Private implimentation of StrChrA, this code is based on
     a code snipet from ShlWapi, but by placing it here,
     we can remove the extra NLS support that was needed
     in SHLWAPI.   This piece of code is over twice as fast
     as the call into SHLWAPI.

Arguments:

    lpStart - points to start of null terminated string

    wMatch  - the character to match

Return Value:

    LPSTR   - ptr to the first occurrence of ch in str, NULL if not found.

--*/
{
    for ( ; *lpStart; lpStart++)
    {
        if ((BYTE)*lpStart == LOBYTE(wMatch)) {
            return((LPSTR)lpStart);
        }
    }

    return (NULL);
}


DWORD
GetTickCountWrap()
{
#ifdef DEBUG_GETTICKCOUNT
    static BOOL fInit = FALSE;
    static DWORD dwDelta = 0;
    static DWORD dwBasis = 0;

    if (!fInit)
    {
        HKEY clientKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                                 0, // reserved
                                 KEY_QUERY_VALUE,
                                 &clientKey))
        {
            DWORD dwSize = sizeof(dwDelta);
            RegQueryValueEx(clientKey, "RollOverDelta", NULL, NULL, (LPBYTE)&dwDelta, &dwSize);
        }
        dwBasis = GetTickCount();
        fInit = TRUE;
    }
    DWORD dwResult = GetTickCount() - dwBasis + dwDelta;
    return dwResult;
#else
    return GetTickCount();
#endif
}


DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os
    )

/*++

Routine Description:

    Returns the platform type based on the operating system information. We use
    our own platform types

Arguments:

    lpdwVersion5os - optional pointer to value, set to TRUE if we on NT 5

Return Value:

    DWORD
        Failure - PLATFORM_TYPE_UNKNOWN
                    either GetVersionEx() failed, or we are running on an
                    unrecognized operating system

        Success - PLATFORM_TYPE_WIN95
                    The world's favourite desktop O/S

                  PLATFORM_TYPE_WINNT
                    The world's best O/S on top of anything

--*/

{
#ifndef UNIX
    OSVERSIONINFO versionInfo;

    *lpdwVersion5os = FALSE;

    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (GetVersionEx(&versionInfo)) {
        switch (versionInfo.dwPlatformId) {
        case VER_PLATFORM_WIN32_WINDOWS:
            if(versionInfo.dwMinorVersion >= 90) {
                GlobalPlatformMillennium = TRUE;
            }
            return PLATFORM_TYPE_WIN95;

        case VER_PLATFORM_WIN32_NT:

            if ( lpdwVersion5os && 
                versionInfo.dwMajorVersion >= 5 ) {                
                *lpdwVersion5os = TRUE;
            }            
            return PLATFORM_TYPE_WINNT;

        }

    }
    return PLATFORM_TYPE_UNKNOWN;
#else
    return PLATFORM_TYPE_UNIX;
#endif /* UNIX */
}

//
//DWORD
//PlatformSupport(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Returns a bitmap of capabilities supported by this operating system
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//
//--*/
//
//{
//    switch (PlatformType()) {
//    case PLATFORM_TYPE_WINNT:
//        return PLATFORM_SUPPORTS_UNICODE;
//    }
//    return 0;
//}


DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    )

/*++

Routine Description:

    Gets a timeout value. The timeout is retrieved from the current handle. If
    it is not available in the current handle then the parent handle is checked
    (actually the current handle is derived from the parent, so this doesn't
    really do anything). If the value is still not available, then the global
    default is used

Arguments:

    TimeoutOption   - WINHTTP_OPTION_ value used to specify the timeout value

Return Value:

    DWORD
        Requested timeout value

--*/

{
    HINTERNET hInternet;
    DWORD timeout;
    DWORD error;
    HINTERNET_HANDLE_TYPE handleType;
    
    hInternet = InternetGetMappedObjectHandle();
    
    if (hInternet) 
    {
        error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
        
        if (error == ERROR_SUCCESS) 
        {
            error = RGetHandleType(hInternet, &handleType);

            if (error == ERROR_SUCCESS)
            {
                switch(handleType)
                {
                case TypeHttpRequestHandle:
                    //no error possible here
                    timeout = ((HTTP_REQUEST_HANDLE_OBJECT*)hInternet)->GetTimeout(TimeoutOption);
                    break;
                case TypeHttpConnectHandle:
                    //no timeouts on this handle
                    //go up to parent
                    hInternet = (HINTERNET)GetRootHandle((INTERNET_HANDLE_OBJECT *)hInternet);
                    //fall through
                case TypeInternetHandle:            
                    //either there was an error in allocing memory for OPTIONAL_PARAMS struct
                    //or the option may not have been set
                    //in either case, force the global timeout choice by setting an error (not propagated)
                    if (! ((INTERNET_HANDLE_OBJECT*)hInternet)->GetTimeout(TimeoutOption, &timeout) )
                        error = E_FAIL;
                    break;
                default:
                    error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
                    break;
                }
            }
        }
    }
    
    if ( !hInternet || (error != ERROR_SUCCESS)) 
    {
    //should this ever happen?
        INET_ASSERT(FALSE);
        switch (TimeoutOption) {
        case WINHTTP_OPTION_RESOLVE_TIMEOUT:
            timeout = GlobalResolveTimeout;
            break;

        case WINHTTP_OPTION_CONNECT_TIMEOUT:
            timeout = GlobalConnectTimeout;
            break;

        case WINHTTP_OPTION_CONNECT_RETRIES:
            timeout = GlobalConnectRetries;
            break;

        case WINHTTP_OPTION_SEND_TIMEOUT:
            timeout = GlobalSendTimeout;
            break;

        case WINHTTP_OPTION_RECEIVE_TIMEOUT:
            timeout = GlobalReceiveTimeout;
            break;
        default:
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            timeout = 0;
            break;
        }
    }
    return timeout;
}


DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for readability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_INVALID_PARAMETER;
    }

    return error;
}


DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for writeability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;
            *end = b;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
                *p = b;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_SUCCESS;
    }

    return error;
}


DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    )

/*++

Routine Description:

    Probes a single DWORD buffer for writeability, and as a side-effect sets it
    to a default value. Used as part of API parameter validation

Arguments:

    lpDword - pointer to DWORD buffer to test

    dwValue - default value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    __try {
        *lpDword = dwValue;
        error = ERROR_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
    return error;
}


DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a wide string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}


DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Dynamically loads a DLL and the entry points described in lpDllEntryPoints

    Assumes:    1. Any thread serialization taken care of by caller

                2. Module handle, entry point addresses and reference count
                   already set to 0 if this is first time the DLL_INFO is
                   being used to load the DLL

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and entry points to load

    dwFlags     - flags controlling how this function operates:

                    LDEP_PARTIAL_LOAD_OK
                        - not fatal if we can't load all entry points

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "LoadDllEntryPoints",
                 "%x [%q, %d], %#x",
                 lpDllInfo,
                 lpDllInfo->lpszDllName,
                 lpDllInfo->dwNumberOfEntryPoints,
                 dwFlags
                 ));

    DWORD error = ERROR_SUCCESS;

    if (lpDllInfo->hModule == NULL) {

        DWORD dwMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        HMODULE hDll = LoadLibrary(lpDllInfo->lpszDllName);

        if (hDll != NULL) {
            lpDllInfo->hModule = hDll;
            lpDllInfo->LoadCount = 1;

            for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {

                FARPROC proc = GetProcAddress(
                                    hDll,
                                    lpDllInfo->lpEntryPoints[i].lpszProcedureName
                                    );

                *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = proc;
                if ((proc == NULL) && !(dwFlags & LDEP_PARTIAL_LOAD_OK)) {
                    error = GetLastError();
                    UnloadDllEntryPoints(lpDllInfo, TRUE);
                    break;
                }
            }
        } else {
            error = GetLastError();
        }
        SetErrorMode(dwMode);
    } else {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("info for %q already loaded\n",
                    lpDllInfo->lpszDllName
                    ));

        InterlockedIncrement(&lpDllInfo->LoadCount);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    )

/*++

Routine Description:

    Undoes the work of LoadDllEntryPoints()

    Assumes:    1. Any thread serialization taken care of by caller

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and (loaded) entry points

    bForce      - TRUE if the DLL will be unloaded irrespective of the usage
                  count

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "UnloadDllEntryPoints",
                "%x [%q, %d], %B",
                lpDllInfo,
                lpDllInfo->lpszDllName,
                lpDllInfo->dwNumberOfEntryPoints,
                bForce
                ));

    DWORD error = ERROR_SUCCESS;

    if (bForce) {
        lpDllInfo->LoadCount = 0;
    } else if (InterlockedDecrement(&lpDllInfo->LoadCount) == 0) {
        bForce = TRUE;
    }
    if (bForce && (lpDllInfo->hModule != NULL)) {
        if (!FreeLibrary(lpDllInfo->hModule)) {
            error = GetLastError();
        }

        //
        // even if FreeLibrary() failed we clear out the load info
        //

        lpDllInfo->hModule = NULL;
        for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {
            *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = NULL;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

#ifndef CERT_E_WRONG_USAGE
#   define CERT_E_WRONG_USAGE              _HRESULT_TYPEDEF_(0x800B0110)
#endif


DWORD
MapInternetError(
    IN DWORD dwErrorCode,
    IN LPDWORD lpdwStatus /* = NULL */
    )

/*++

Routine Description:

    Maps a winsock/RPC/transport error into a more user-friendly WinInet error,
    and stores the original error in the per-thread context so that the app can
    retrieve it if it really cares

    N.B. We should no longer be receiving winsock errors directly at the WinInet
    interface. They are available via InternetGetLastResponseInfo()

Arguments:

    dwErrorCode - original (winsock) error code to map

Return Value:

    DWORD
        Mapped error code, or the orignal error if its not one that we handle

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD dwStatus = 0;

    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "MapInternetError",
                "%#x [%s]",
                dwErrorCode,
                InternetMapError(dwErrorCode)
                ));

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo) {
        lpThreadInfo->dwMappedErrorCode = dwErrorCode;
    }

    switch (dwErrorCode) {

    case SEC_E_INSUFFICIENT_MEMORY        :
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case SEC_E_INVALID_HANDLE             :
    case SEC_E_UNSUPPORTED_FUNCTION       :
    case SEC_E_TARGET_UNKNOWN             :
    case SEC_E_INTERNAL_ERROR             :
    case SEC_E_SECPKG_NOT_FOUND           :
    case SEC_E_NOT_OWNER                  :
    case SEC_E_CANNOT_INSTALL             :
    case SEC_E_INVALID_TOKEN              :
    case SEC_E_CANNOT_PACK                :
    case SEC_E_QOP_NOT_SUPPORTED          :
    case SEC_E_NO_IMPERSONATION           :
    case SEC_E_LOGON_DENIED               :
    case SEC_E_UNKNOWN_CREDENTIALS        :
    case SEC_E_NO_CREDENTIALS             :
    case SEC_E_MESSAGE_ALTERED            :
    case SEC_E_OUT_OF_SEQUENCE            :
    case SEC_E_NO_AUTHENTICATING_AUTHORITY:
    case SEC_I_CONTINUE_NEEDED            :
    case SEC_I_COMPLETE_NEEDED            :
    case SEC_I_COMPLETE_AND_CONTINUE      :
    case SEC_I_LOCAL_LOGON                :
    case SEC_E_BAD_PKGID                  :
    case SEC_E_CONTEXT_EXPIRED            :
    case SEC_E_INCOMPLETE_MESSAGE         :
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR;
        break;

    // Cert and Encryption errors

    case CERT_E_EXPIRED:
    case CERT_E_VALIDITYPERIODNESTING:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID;
        break;

    case CERT_E_UNTRUSTEDROOT:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA;
        break;

    case CERT_E_CN_NO_MATCH:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID;
        break;

    case CRYPT_E_REVOKED:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED;
        break;

    // ignore revocation if the certificate does not have a CDP
    case CRYPT_E_NO_REVOCATION_CHECK:
        dwErrorCode = ERROR_SUCCESS;
        break;

    case CRYPT_E_REVOCATION_OFFLINE:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED;
        break;

    case CERT_E_ROLE:
    case CERT_E_PATHLENCONST:
    case CERT_E_CRITICAL:
    case CERT_E_PURPOSE:
    case CERT_E_ISSUERCHAINING:
    case CERT_E_MALFORMED:
    case CERT_E_CHAINING:
    // We can't allow connection if server doesn't have a server auth certificate.
    // To force CERT_E_WRONG_USAGE to error out we map it to the error below.
    // In the future we need to map it to it's own non-recoverable error, so we can 
    // give the user a specific error message.
    case CERT_E_WRONG_USAGE:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT;
        break;

    case WSAEINTR:
    case WSAEBADF:
    case WSAEACCES:
    case WSAEFAULT:
    case WSAEINVAL:
    case WSAEMFILE:
    case WSAEADDRINUSE:
    case WSAEADDRNOTAVAIL:
        dwErrorCode = ERROR_WINHTTP_INTERNAL_ERROR;
        break;

    case WSAENOTSOCK:

        //
        // typically, if we see this error its because we tried to use a closed
        // socket handle
        //
        dwErrorCode = ERROR_WINHTTP_OPERATION_CANCELLED;
        break;

    case WSAEWOULDBLOCK:
    case WSAEINPROGRESS:
    case WSAEALREADY:
    case WSAEDESTADDRREQ:
    case WSAEPROTOTYPE:
    case WSAENOPROTOOPT:
    case WSAEPROTONOSUPPORT:
    case WSAESOCKTNOSUPPORT:
    case WSAEOPNOTSUPP:
    case WSAEISCONN:
    case WSAETOOMANYREFS:
    case WSAELOOP:
    case WSAENAMETOOLONG:
    case WSAENOTEMPTY:
    case WSAEPROCLIM:
    case WSAEUSERS:
    case WSAEDQUOT:
    case WSAESTALE:
    case WSAEREMOTE:
    case WSAEDISCON:
    case WSASYSNOTREADY:
    case WSAVERNOTSUPPORTED:
    case WSANOTINITIALISED:

        //
        // currently unmapped errors
        //

        break;

    case WSAEMSGSIZE:
        dwErrorCode = ERROR_INSUFFICIENT_BUFFER;
        break;

    case WSAEPFNOSUPPORT:
    case WSAEAFNOSUPPORT:
        dwErrorCode = ERROR_NOT_SUPPORTED;
        break;

    case WSAECONNABORTED:
    case WSAESHUTDOWN:

    case WSAECONNRESET:
    case WSAENETRESET:
        dwErrorCode = ERROR_WINHTTP_CONNECTION_ERROR;
        break;

    case WSAENOBUFS:
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case WSAETIMEDOUT:
        dwErrorCode = ERROR_WINHTTP_TIMEOUT;
        break;

    case WSAENETDOWN:
    case WSAECONNREFUSED:
    case WSAENETUNREACH:
    case WSAENOTCONN:
        dwErrorCode = ERROR_WINHTTP_CANNOT_CONNECT;
        break;

    case WSAEHOSTDOWN:
    case WSAEHOSTUNREACH:
    case WSAHOST_NOT_FOUND:
    case WSATRY_AGAIN:
    case WSANO_RECOVERY:
    case WSANO_DATA:
        dwErrorCode = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        break;

    default:

        DEBUG_PRINT(UTIL,
                    WARNING,
                    ("MapInternetError(): unmapped error code %d [%#x]\n",
                    dwErrorCode,
                    dwErrorCode
                    ));

        break;
    }

    if (lpdwStatus)
    {
        *lpdwStatus = dwStatus;
        DEBUG_PRINT(UTIL,
                    INFO,
                    ("MapInternetError(): mapped status flag %#x\n",
                    *lpdwStatus
                    ));
    }

    DEBUG_LEAVE(dwErrorCode);

    return dwErrorCode;
}


DWORD
CalculateHashValue(
    IN LPSTR lpszString
    )

/*++

Routine Description:

    Calculate a hash number given a string

Arguments:

    lpszString  - string to hash

Return Value:

    DWORD

--*/

{
    DWORD hashValue = 0;
    DWORD position = 1;

    while (*lpszString) {
        hashValue += *lpszString * position;
        ++lpszString;
        ++position;
    }
    return hashValue;
}



VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    )
/*++

Routine Description:
    This routine returns the current GMT time

Arguments:

    lpFt    FILETIME strucutre in which this is returned

Returns:

Comments:

--*/
{
    SYSTEMTIME sSysT;

    GetSystemTime(&sSysT);
    SystemTimeToFileTime(&sSysT, lpFt);
}



LPTSTR
FTtoString(
    IN FILETIME *pftTime)

/*++

FTtoString:

    This routine converts a given FILETIME structure to a string representing
    the given date and time in the local format.

Arguments:

    pftTime supplies the FILETIME structure to convert.

Return Value:

    NULL - Memory allocation failure.
    Otherwise, the address of the string, allocated via LocalAlloc.

Author:

    Doug Barlow (dbarlow) 4/12/1996

--*/

{
    LONG cchTotal, cchNeeded;
    SYSTEMTIME stTime, stLocal;
    LPTSTR szDateTime = NULL;


    //
    // Convert the FILETIME to a SYSTEMTIME.
    //

    if (!FileTimeToSystemTime(pftTime, &stTime))
        goto ErrorExit;

    //
    // For now, leave it in GMT time, function not implimented in Win'95.
    //

    //if ( IsPlatformWinNT() )
    //{
    //    if (!SystemTimeToTzSpecificLocalTime(NULL, &stTime, &stLocal))
    //        goto ErrorExit;
    //}
    //else
    {
        stLocal = stTime;
    }


    //
    // Calculate how long the date string will be.
    //

    cchTotal =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchTotal)
        goto ErrorExit;
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchNeeded)
        goto ErrorExit;
    cchTotal += cchNeeded;
    cchTotal += 4 * sizeof(TCHAR);  // space, trailing NULL, and two extra.
    szDateTime = (LPTSTR)ALLOCATE_MEMORY(LMEM_FIXED, cchTotal);
    if (NULL == szDateTime)
        goto ErrorExit;


    //
    // Fill in the time string.
    //

    cchNeeded =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            szDateTime,
            cchTotal);
    if (0 >= cchNeeded)
        goto ErrorExit;
    lstrcat(szDateTime, TEXT(" "));
    cchNeeded = lstrlen(szDateTime);
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            &szDateTime[cchNeeded],
            cchTotal - cchNeeded);
    if (0 >= cchNeeded)
        goto ErrorExit;
    return szDateTime;


ErrorExit:
    if (NULL != szDateTime)
        FREE_MEMORY(szDateTime);
    return NULL;
}


BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    )
/*++

Routine Description:

    Converts a set of bytes into a neatly formated string of ':' (colon) seperated
      hex digits that can be shown to the user.

Arguments:

    lpMD5Hash - ptr to set of hash bytes

    dwMD5HashSize - size of lpMD5Hash

    lplpszHashStr - ptr to ptr where newly allocated return string will be stored.

Return Value:

    BOOL

--*/

{

    DWORD dwStrSize = (2*dwMD5HashSize) + dwMD5HashSize;
    LPSTR lpszHashStr;

    *lplpszHashStr = new CHAR[dwStrSize];

    if ( *lplpszHashStr == NULL )
    {
        return FALSE;
    }

    lpszHashStr = *lplpszHashStr;

    for ( DWORD i = 0 ; i < dwMD5HashSize; i++ )
    {
        unsigned char uHashByte;

        if ( i != 0 )
        {
            *lpszHashStr = ':';
            lpszHashStr++;
        }

        uHashByte = (unsigned char) * ( ((unsigned char * ) lpMD5Hash) + i);

        wsprintf( lpszHashStr, "%02X", uHashByte);

        lpszHashStr += 2;

    }

    INET_ASSERT( *lpszHashStr == '\0' );

    return TRUE;
}


//
// private functions
//

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    )
/*++

Routine Description:

    Converts an X509 Certificate Structure into a WININET struct
    used for storing the same info.

Arguments:

    hContext        - Context handle of the active SSPI session.

    pCertInfo       - Pointer to Structure where info is returned in.

Return Value:

    DWORD
    ERROR_SUCCESS   - if cert cannot be converted

    ERROR_NOT_ENOUGH_MEMORY

--*/

{


    DWORD   error = ERROR_SUCCESS;
    PCERT_INFO pCertInfo = NULL;
    DWORD cbCert = sizeof(INTERNET_CERTIFICATE_INFO),
          cbSubject = 0,
          cbIssuer = 0;

    BOOL fCanAlloc = FALSE;

    if(pSecInfo == NULL)
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    if(pCertificate == NULL || *pcbCertificate == 0)
    {
        *pcbCertificate = sizeof(INTERNET_CERTIFICATE_INFO);
        goto quit;
    }

    if(*pcbCertificate < sizeof(INTERNET_CERTIFICATE_INFO) )
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    ZeroMemory(pCertificate, sizeof(INTERNET_CERTIFICATE_INFO));
    fCanAlloc = TRUE;

    if(pSecInfo->pCertificate &&
       pSecInfo->pCertificate->pCertInfo )
    {
        pCertInfo = pSecInfo->pCertificate->pCertInfo;

        //
        // Now Convert Structures from SSPI format to WININET style.
        //  While in the process, we'll role them all into one
        //  big structure that we'll return to the user.
        //

        cbSubject = CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);


        if ( cbSubject > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszSubjectInfo = (LPSTR) LocalAlloc(LPTR, cbSubject);

            if ( pCertificate->lpszSubjectInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     pCertificate->lpszSubjectInfo,
                                     cbSubject);

        }

        cbIssuer = CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);

        if ( cbIssuer > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszIssuerInfo = (LPSTR) LocalAlloc(LPTR, cbIssuer);

            if ( pCertificate->lpszIssuerInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     pCertificate->lpszIssuerInfo,
                                     cbIssuer);

        }

        CopyMemory(
                (PVOID) &pCertificate->ftStart,
                (PVOID) &pCertInfo->NotBefore,
                sizeof(FILETIME)
                );

        CopyMemory(
                (PVOID) &pCertificate->ftExpiry,
                (PVOID) &pCertInfo->NotAfter,
                sizeof(FILETIME)
                );

    }

    /*if(pSecInfo->dwProtocol)
    {
        DWORD dwProtocolID;
        TCHAR lpszProtocol[100];

        ATTR_MAP ProtocolAttrMap[] =
        {
            {SP_PROT_SSL2_CLIENT, IDS_PROTOCOL_SSL2},
            {SP_PROT_SSL3_CLIENT, IDS_PROTOCOL_SSL3},
            {SP_PROT_PCT1_CLIENT, IDS_PROTOCOL_PCT1},
            {SP_PROT_TLS1_CLIENT, IDS_PROTOCOL_TLS1}
        };


        for(j=0; j < sizeof(ProtocolAttrMap)/sizeof(ProtocolAttrMap[0]); j++)
        {
            if(ProtocolAttrMap[j].dwAttr == pSecInfo->dwProtocol)
            {
                dwProtocolID = ProtocolAttrMap[j].dwStringID;
                break;
            }
        }
        if(LoadString(GlobalDllHandle,
                   dwProtocolID,
                   lpszProtocol,
                   sizeof(lpszProtocol)/sizeof(lpszProtocol[0])))
        {
            pCertificate->lpszProtocolName  = NewString(lpszProtocol);
        }
    } */

    pCertificate->dwKeySize = pSecInfo->dwCipherStrength;

quit:

    if ( error != ERROR_SUCCESS &&
         fCanAlloc
        )
    {

        if ( pCertificate->lpszSubjectInfo )
        {
            LocalFree(pCertificate->lpszSubjectInfo);
            pCertificate->lpszSubjectInfo = NULL;
        }

        if ( pCertificate->lpszIssuerInfo )
        {
            LocalFree(pCertificate->lpszIssuerInfo);
            pCertificate->lpszIssuerInfo = NULL;
        }
    }

    return error;
}


#ifdef DONT_USE_IERT
/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokEx (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/

double StrToDbl(const char *str, char **strStop)
{
    double dbl = 0;
    char *psz;
    int iMult = 1;
    int iKB = 1;
    int iVal = 0;
    BOOL bHaveDot = FALSE;

    psz = (char*)str;
    while(*psz)
    {
        if((*psz >= '0') && (*psz <= '9'))
        {
            iVal = (iVal * 10) + (*psz - '0');
            if(bHaveDot)
                iMult *= 10;
        }
        else if((*psz == '.') && !bHaveDot)
        {
            bHaveDot = TRUE;
        }
        else if((*psz == 'k') || (*psz == 'K'))
        {
            iKB = 1024;
            psz++;
            break;
        }
        else
        {
            break;
        }
        psz++;
    }
    *strStop = psz;

    dbl = (double) (iVal * iKB) / iMult;
    
    return(dbl);
}
#endif  // DONT_USE_IERT


/*
 *  WideCharToAsciiString
 *
 *  Purpose:
 *      Create an ascii string from a wide-char string.
 *      Output ascii string is allocated using New, so use delete[] to free.
 *
 */

DWORD
WideCharToAscii(PCWSTR pszW, char ** ppszA)
{
    DWORD cchA;
    DWORD cchW;

    *ppszA = NULL;

    if (!pszW)
        return ERROR_SUCCESS;

    cchW = lstrlenW(pszW);

    // Determine how big the ascii string will be
    cchA = WideCharToMultiByte(CP_ACP, 0, pszW, cchW, NULL, 0, NULL, NULL);

    *ppszA = new char[cchA + 1];

    if (!*ppszA)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Determine how big the ascii string will be
    cchA = WideCharToMultiByte(CP_ACP, 0, pszW, cchW, *ppszA, cchA, NULL, NULL);

    (*ppszA)[cchA] = '\0';
    
    return ERROR_SUCCESS;
}


DWORD
AsciiToWideChar_UsingGlobalAlloc(const char * pszA, LPWSTR * ppszW)
{
    DWORD cchA;
    DWORD cchW;

    *ppszW = NULL;

    if (!pszA)
        return ERROR_SUCCESS;

    cchA = lstrlenA(pszA);

    // Determine how big the widechar string will be
    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, NULL, 0);

    *ppszW = (PWSTR) GlobalAlloc(GPTR, (cchW + 1) * sizeof(WCHAR));

    if (!*ppszW)
        return ERROR_NOT_ENOUGH_MEMORY;

    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, *ppszW, cchW * sizeof(WCHAR));

    (*ppszW)[cchW] = 0;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\debug\perfdiag.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    perfdiag.cxx

Abstract:

    Performance diagnostics

    Contents:
        WininetPerfLog
        PerfSleep
        PerfSelect
        PerfWaitForSingleObject
        (CPerfDiag::get_next_record)
        CPerfDiag::CPerfDiag
        CPerfDiag::~CPerfDiag
        CPerfDiag::Log(DWORD, DWORD)
        CPerfDiag::Log(DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Log(DWORD, DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Dump
        (map_perf_event)
        (map_callback_status)
        (map_async_request)
        (map_thread_pri)
        (map_length)

Author:

    Richard L Firth (rfirth) 24-Jan-1997

Revision History:

    24-Jan-1997 rfirth
        Created

--*/

#include <wininetp.h>

#if defined(USE_PERF_DIAG)

#include <perfdiag.hxx>

//
// global data
//

GLOBAL CPerfDiag * GlobalPerfDiag = NULL;
GLOBAL BOOL GlobalDumpPerfToFile = TRUE;

//
// private prototypes
//

PRIVATE LPSTR map_perf_event(DWORD dwEvent);
PRIVATE LPSTR map_callback_status(DWORD dwStatus);
PRIVATE LPSTR map_async_request(DWORD dwRequest);
PRIVATE LPSTR map_thread_pri(DWORD dwPriority);
PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf);

//
// APIs
//

INTERNETAPI
VOID
WINAPI
WininetPerfLog(
    IN DWORD dwEvent,
    IN DWORD dwInfo1,
    IN DWORD dwInfo2,
    IN HINTERNET hInternet
    ) {
    if (!GlobalPerfDiag) {
        GlobalPerfDiag = New CPerfDiag;
    }
    if (GlobalPerfDiag) {
        GlobalPerfDiag->Log(dwEvent, dwInfo1, dwInfo2, GetCurrentThreadId(), hInternet);
    }
}

//
// functions
//

VOID PerfSleep(DWORD dwMilliseconds) {
    PERF_LOG(PE_YIELD_SLEEP_START);
    Sleep(dwMilliseconds);
    PERF_LOG(PE_YIELD_SLEEP_END);
}

int PerfSelect(int nfds,	
    fd_set FAR * readfds,	
    fd_set FAR * writefds,	
    fd_set FAR * exceptfds,	
    const struct timeval FAR * timeout 	
    ) {
    PERF_LOG(PE_YIELD_SELECT_START);

    int n = _I_select(nfds, readfds, writefds, exceptfds, timeout);

    PERF_LOG(PE_YIELD_SELECT_END);
    return n;
}

DWORD PerfWaitForSingleObject(
    HANDLE hObject,
    DWORD dwTimeout
    ) {
    PERF_LOG(PE_YIELD_OBJECT_WAIT_START);

    DWORD result = WaitForSingleObject(hObject, dwTimeout);

    PERF_LOG(PE_YIELD_OBJECT_WAIT_END);

    return result;
}

//
// private methods
//

LPPERF_INFO CPerfDiag::get_next_record(VOID) {

    if (!m_lpbPerfBuffer || m_bFull) {
        return NULL;
    }

    LPBYTE lpbCurrent;
    LPBYTE lpbNext;
    LPBYTE result;

    do {
        lpbCurrent = m_lpbNext;
        lpbNext = lpbCurrent + sizeof(PERF_INFO);
        result = (LPBYTE)InterlockedExchangePointer((PVOID*)&m_lpbNext, lpbNext);
    } while ((result != (LPBYTE)lpbCurrent) && (lpbCurrent < m_lpbEnd));
    if (lpbCurrent >= m_lpbEnd) {
        m_bFull = TRUE;
        OutputDebugString("*** Wininet performance log is full!\n");
        lpbCurrent = NULL;
    }
    return (LPPERF_INFO)lpbCurrent;
}

//
// public methods
//

CPerfDiag::CPerfDiag() {
    m_lpbPerfBuffer = NULL;
    m_dwPerfBufferLen = 0;
    m_lpbEnd = NULL;
    m_lpbNext = NULL;
    m_bFull = FALSE;
    m_bStarted = FALSE;
    m_bStartFinished = FALSE;
    m_liStartTime.QuadPart = 0i64;
    perf_start();
}

CPerfDiag::~CPerfDiag() {
    free_perf_buffer();
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo) {

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo) {
        Log(dwEvent, dwInfo, 0, lpThreadInfo->ThreadId, lpThreadInfo->hObject);
    }
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwThreadId, HINTERNET hInternet) {
    Log(dwEvent, dwInfo, 0, dwThreadId, hInternet);
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwInfo2, DWORD dwThreadId, HINTERNET hInternet) {

    //if (!m_bStarted) {
    //    perf_start();
    //}

    LPPERF_INFO lpInfo = get_next_record();

    if (!lpInfo) {
        return;
    }

    lpInfo->hInternet = hInternet;
    lpInfo->dwThreadId = dwThreadId;
    lpInfo->dwThreadPriority = GetThreadPriority(GetCurrentThread());
    lpInfo->dwEvent = dwEvent;
    lpInfo->dwInfo = dwInfo;
    lpInfo->dwInfo2 = dwInfo2;
    get_time(lpInfo);
}

VOID CPerfDiag::Dump(VOID) {

    HANDLE hFile = INVALID_HANDLE_VALUE;
    static const char PerfFileName[] = "WININET.PRF";

    if (GlobalDumpPerfToFile) {
        hFile = CreateFile((LPCSTR)PerfFileName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           INVALID_HANDLE_VALUE
                           );
        if (hFile == INVALID_HANDLE_VALUE) {
            OutputDebugString("failed to create perf file ");
            OutputDebugString((LPCSTR)PerfFileName);
            OutputDebugString("\n");
            GlobalDumpPerfToFile = FALSE;
        }
    }

    LARGE_INTEGER liFrequency;
    LONGLONG div1;
    LONGLONG div2;

    QueryPerformanceFrequency(&liFrequency);
    div1 = liFrequency.QuadPart;
    div2 = div1 / 1000000;

    LPPERF_INFO lpInfo;
    int record = 1;

    for (lpInfo = (LPPERF_INFO)m_lpbPerfBuffer; lpInfo != (LPPERF_INFO)m_lpbNext; ++lpInfo) {

        char buf[1024];
        LONGLONG ticks;
        DWORD microseconds;
        DWORD seconds;
        DWORD minutes;

        ticks = lpInfo->liTime.QuadPart - m_liStartTime.QuadPart;
        seconds = (DWORD)(ticks / div1);
        microseconds = (DWORD)((ticks % div1) / div2);

        //
        // don't understand why I have to do this? Win95 only (you could have guessed)
        // rounding error?
        //

        while (microseconds >= 1000000) {
            microseconds -= 1000000;
            ++seconds;
        }
        minutes = seconds / 60;
        seconds = seconds % 60;

        char lenbuf[32];
        char lenbuf2[32];

        int nChars = wsprintf(buf,
                              "%5d: Delta=%.2d:%.2d.%.6d TID=%08x Pri=%-8s hReq=%06x Info=%08x %-24s %-22s %s\r\n",
                              record,
                              minutes,
                              seconds,
                              microseconds,
                              lpInfo->dwThreadId,
                              map_thread_pri(lpInfo->dwThreadPriority),
                              lpInfo->hInternet,
                              lpInfo->dwInfo,
                              map_perf_event(lpInfo->dwEvent),
                              ((lpInfo->dwEvent == PE_APP_CALLBACK_START)
                              || (lpInfo->dwEvent == PE_APP_CALLBACK_END))
                                 ? map_callback_status(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_WORKER_REQUEST_START)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_START)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_QUEUED))
                                 ? map_async_request(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_SEND_END)
                              || (lpInfo->dwEvent == PE_RECEIVE_END))
                                 ? map_length(lpInfo->dwInfo2, lenbuf)
                              : (((lpInfo->dwEvent == PE_ENTER_PATH)
                              || (lpInfo->dwEvent == PE_LEAVE_PATH)
                              || (lpInfo->dwEvent == PE_TRACE_PATH))
                                 ? (LPSTR)lpInfo->dwInfo2
                                 : ""))),
                              (((lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END))
                              && ((lpInfo->dwInfo == AR_INTERNET_READ_FILE)
                              || (lpInfo->dwInfo == AR_INTERNET_QUERY_DATA_AVAILABLE)))
                                 ? map_length(lpInfo->dwInfo2, lenbuf2)
                                 : ""
                             );
        if (GlobalDumpPerfToFile) {

            DWORD nWritten;

            WriteFile(hFile, buf, nChars, &nWritten, NULL);
        } else {
            OutputDebugString(buf);
        }
        ++record;
    }
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}


PRIVATE LPSTR map_perf_event(DWORD dwEvent) {
    switch (dwEvent) {
    case PE_START:                      return "START";
    case PE_END:                        return "END";
    case PE_CLIENT_REQUEST_START:       return "CLIENT_REQUEST_START";
    case PE_CLIENT_REQUEST_END:         return "CLIENT_REQUEST_END";
    case PE_CLIENT_REQUEST_QUEUED:      return "CLIENT_REQUEST_QUEUED";
    case PE_WORKER_REQUEST_START:       return "WORKER_REQUEST_START";
    case PE_WORKER_REQUEST_END:         return "WORKER_REQUEST_END";
    case PE_APP_CALLBACK_START:         return "APP_CALLBACK_START";
    case PE_APP_CALLBACK_END:           return "APP_CALLBACK_END";
    case PE_NAMERES_START:              return "NAMERES_START";
    case PE_NAMERES_END:                return "NAMERES_END";
    case PE_CONNECT_START:              return "CONNECT_START";
    case PE_CONNECT_END:                return "CONNECT_END";
    case PE_SEND_START:                 return "SEND_START";
    case PE_SEND_END:                   return "SEND_END";
    case PE_RECEIVE_START:              return "RECEIVE_START";
    case PE_RECEIVE_END:                return "RECEIVE_END";
    case PE_PEEK_RECEIVE_START:         return "PEEK_RECEIVE_START";
    case PE_PEEK_RECEIVE_END:           return "PEEK_RECEIVE_END";
    case PE_SOCKET_CLOSE_START:         return "SOCKET_CLOSE_START";
    case PE_SOCKET_CLOSE_END:           return "SOCKET_CLOSE_END";
    case PE_ACQUIRE_KEEP_ALIVE:         return "ACQUIRE_KEEP_ALIVE";
    case PE_RELEASE_KEEP_ALIVE:         return "RELEASE_KEEP_ALIVE";
    case PE_SOCKET_ERROR:               return "SOCKET_ERROR";
    case PE_CACHE_READ_CHECK_START:     return "CACHE_READ_CHECK_START";
    case PE_CACHE_READ_CHECK_END:       return "CACHE_READ_CHECK_END";
    case PE_CACHE_WRITE_CHECK_START:    return "CACHE_WRITE_CHECK_START";
    case PE_CACHE_WRITE_CHECK_END:      return "CACHE_WRITE_CHECK_END";
    case PE_CACHE_RETRIEVE_START:       return "CACHE_RETRIEVE_START";
    case PE_CACHE_RETRIEVE_END:         return "CACHE_RETRIEVE_END";
    case PE_CACHE_READ_START:           return "CACHE_READ_START";
    case PE_CACHE_READ_END:             return "CACHE_READ_END";
    case PE_CACHE_WRITE_START:          return "CACHE_WRITE_START";
    case PE_CACHE_WRITE_END:            return "CACHE_WRITE_END";
    case PE_CACHE_CREATE_FILE_START:    return "CACHE_CREATE_FILE_START";
    case PE_CACHE_CREATE_FILE_END:      return "CACHE_CREATE_FILE_END";
    case PE_CACHE_CLOSE_FILE_START:     return "CACHE_CLOSE_FILE_START";
    case PE_CACHE_CLOSE_FILE_END:       return "CACHE_CLOSE_FILE_END";
    case PE_CACHE_EXPIRY_CHECK_START:   return "CACHE_EXPIRY_CHECK_START";
    case PE_CACHE_EXPIRY_CHECK_END:     return "CACHE_EXPIRY_CHECK_END";
    case PE_YIELD_SELECT_START:         return "YIELD_SELECT_START";
    case PE_YIELD_SELECT_END:           return "YIELD_SELECT_END";
    case PE_YIELD_OBJECT_WAIT_START:    return "YIELD_OBJECT_WAIT_START";
    case PE_YIELD_OBJECT_WAIT_END:      return "YIELD_OBJECT_WAIT_END";
    case PE_YIELD_SLEEP_START:          return "YIELD_SLEEP_START";
    case PE_YIELD_SLEEP_END:            return "YIELD_SLEEP_END";
    case PE_TRACE:                      return "TRACE";
    case PE_ENTER_PATH:                 return "ENTER_PATH";
    case PE_LEAVE_PATH:                 return "LEAVE_PATH";
    case PE_TRACE_PATH:                 return "TRACE_PATH";
    }
    return "?";
}

PRIVATE LPSTR map_callback_status(DWORD dwStatus) {
    switch (dwStatus) {
    case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:        return "RESOLVING_NAME";
    case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:         return "NAME_RESOLVED";
    case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:  return "CONNECTING_TO_SERVER";
    case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:   return "CONNECTED_TO_SERVER";
    case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:       return "SENDING_REQUEST";
    case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:          return "REQUEST_SENT";
    case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:    return "RECEIVING_RESPONSE";
    case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:     return "RESPONSE_RECEIVED";
    case WINHTTP_CALLBACK_STATUS_CTL_RESPONSE_RECEIVED: return "CTL_RESPONSE_RECEIVED";
    case WINHTTP_CALLBACK_STATUS_PREFETCH:              return "PREFETCH";
    case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:    return "CLOSING_CONNECTION";
    case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:     return "CONNECTION_CLOSED";
    case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:        return "HANDLE_CREATED";
    case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:        return "HANDLE_CLOSING";
    case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:      return "REQUEST_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_REDIRECT:              return "REDIRECT";
    case WINHTTP_CALLBACK_STATUS_STATE_CHANGE:          return "STATE_CHANGE";
    case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:     return "HEADERS_AVAILABLE";
    case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:        return "DATA_AVAILABLE";
    case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:         return "READ_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:        return "WRITE_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:         return "REQUEST_ERROR";
    }
    return "?";
}

PRIVATE LPSTR map_async_request(DWORD dwRequest) {
    switch (dwRequest) {
    case AR_INTERNET_CONNECT:               return "InternetConnect";
    case AR_INTERNET_OPEN_URL:              return "InternetOpenUrl";
    case AR_INTERNET_READ_FILE:             return "InternetReadFile";
    case AR_INTERNET_WRITE_FILE:            return "InternetWriteFile";
    case AR_INTERNET_QUERY_DATA_AVAILABLE:  return "InternetQueryDataAvailable";
    case AR_INTERNET_FIND_NEXT_FILE:        return "InternetFindNextFile";
    case AR_FTP_FIND_FIRST_FILE:            return "FtpFindFirstFile";
    case AR_FTP_GET_FILE:                   return "FtpGetFile";
    case AR_FTP_PUT_FILE:                   return "FtpPutFile";
    case AR_FTP_DELETE_FILE:                return "FtpDeleteFile";
    case AR_FTP_RENAME_FILE:                return "FtpRenameFile";
    case AR_FTP_OPEN_FILE:                  return "FtpOpenFile";
    case AR_FTP_CREATE_DIRECTORY:           return "FtpCreateDirectory";
    case AR_FTP_REMOVE_DIRECTORY:           return "FtpRemoveDirectory";
    case AR_FTP_SET_CURRENT_DIRECTORY:      return "FtpSetCurrentDirectory";
    case AR_FTP_GET_CURRENT_DIRECTORY:      return "FtpGetCurrentDirectory";
    case AR_GOPHER_FIND_FIRST_FILE:         return "GopherFindFirstFile";
    case AR_GOPHER_OPEN_FILE:               return "GopherOpenFile";
    case AR_GOPHER_GET_ATTRIBUTE:           return "GopherGetAttribute";
    case AR_HTTP_SEND_REQUEST:              return "HttpSendRequest";
    case AR_READ_PREFETCH:                  return "READ_PREFETCH";
    case AR_SYNC_EVENT:                     return "SYNC_EVENT";
    case AR_TIMER_EVENT:                    return "TIMER_EVENT";
    }
    return "?";
}

PRIVATE LPSTR map_thread_pri(DWORD dwPriority) {
    switch (dwPriority) {
    case THREAD_PRIORITY_ABOVE_NORMAL:
        return "ABOVE";

    case THREAD_PRIORITY_BELOW_NORMAL:
        return "BELOW";

    case THREAD_PRIORITY_HIGHEST:
        return "HIGHEST";

    case THREAD_PRIORITY_IDLE:
        return "IDLE";

    case THREAD_PRIORITY_LOWEST:
        return "LOWEST";

    case THREAD_PRIORITY_NORMAL:
        return "NORMAL";

    case THREAD_PRIORITY_TIME_CRITICAL:
        return "TIMECRIT";
    }
    return "?";
}

PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf) {
    wsprintf(lpBuf, "%d", dwLength);
    return lpBuf;
}

#endif // defined(USE_PERF_DIAG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\debug\memalloc.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    memalloc.cxx

Abstract:

    Debug-only memory allocation routines

    Contents:
        InetInitializeDebugMemoryPackage
        InetTerminateDebugMemoryPackage
        InetAllocateMemory
        InetReallocateMemory
        (InetIsBlockMoveable)
        InetFreeMemory
        (InetCheckBlockConsistency)
        InetLockMemory
        InetUnlockMemory
        InetMemorySize
        InetCheckDebugMemoryFreed
        (x86SleazeCallersAddress)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// manifests
//

#define HEADER_SIGNATURE    0x414d454d  // 'MEMA'
#define FOOTER_SIGNATURE    0x434f4c4c  // 'LLOC'
#define DWORD_FILL          0xa9a9a9a9
#define BYTE_FILL           0xa9
#define BYTE_FILL_EXTRA     0xcb
#define GUARD_DWORD_FILL    0xcccd21f4
#define DWORD_FREE_FILL     0xb7b7b7b7
#define BYTE_FREE_FILL      0xb7

//
// private types
//

typedef struct {

    //
    // hMoveable - local handle of moveable memory that this tag links
    //

    HLOCAL hMoveable;

} DEBUG_MOVEABLE_TAG, *LPDEBUG_MOVEABLE_TAG;

typedef struct {

    //
    // List - maintains a list of allocated blocks
    //

    LIST_ENTRY List;

    //
    // BlockLength - the size of this block, *including* all headers, footers
    // and padding
    //

    UINT BlockLength;

    //
    // RealLength - the original caller request
    //

    UINT RealLength;

    //
    // Signature - just used as a sanity check to ensure that what we are
    // dealing with is actually a block we allocated
    //

    DWORD Signature;

    //
    // LockCount - if this is moveable memory, keeps the number of times this
    // block has been locked
    //

    LONG LockCount;

    //
    // Flags - what type of memory this is, etc.
    //

    DWORD Flags;

    //
    // LastAccessOperation - the operation caller at LastAccessReturnAddress
    // performed
    //

    MEMALLOC_ACTION LastAccessOperation;

    //
    // LastAccessReturnAddress - caller of last function to perform memory
    // function operation (alloc, lock, realloc, unlock, etc) on this block
    //

    LPVOID LastAccessReturnAddress[2];

    //
    // CreatorReturnAddress - return EIP (x86-only) of caller of allocator
    // and caller of caller
    //

    LPVOID CreatorReturnAddress[2];

    //
    // Tag - if this is moveable memory, we can't add this block to the allocated
    // block list, we have to allocate a DEBUG_MOVEABLE_TAG, link that and point
    // to it from here
    //

    LPDEBUG_MOVEABLE_TAG Tag;

    //
    // Guard - just a sentinel to find out if the caller is writing before the
    // start of this block
    //

    DWORD Guard[4];

    //
    // sizeof(MEMORY_SIGNATURE) currently 17 DWORDs
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

typedef struct {

    //
    // Guard - allows us to determine if the end of allocated memory was
    // overwritten
    //

    DWORD Guard[4];

    //
    // Signature - should be the footer signature
    //

    DWORD Signature;

    //
    // BlockLength - should be the same as the header
    //

    DWORD BlockLength;

    //
    // Guard2 - to make sure the end of the block is coherent
    //

    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// data
//

LONG ActualMemoryAllocated = 0;
LONG BlockLengthAllocated = 0;
LONG RealLengthAllocated = 0;
DWORD MemoryAllocations = 0;
DWORD MemoryFrees = 0;
SERIALIZED_LIST AllocatedBlockList;

//
// macros
//

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)

#else

#define GET_CALLERS_ADDRESS(p, pp)

#endif // defined(i386)

//
// private prototypes
//

PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    );

PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    );

PRIVATE
VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

//
// functions
//


VOID
InetInitializeDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Just initializes data items in this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    static BOOL MemoryPackageInitialized = FALSE;

    if (!MemoryPackageInitialized) {
        InitializeSerializedList(&AllocatedBlockList);
        MemoryPackageInitialized = TRUE;
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


VOID
InetTerminateDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Undoes any resource allocation in InetInitializeDebugMemoryPackage, after
    checking that all memory is freed

Arguments:

    None.

Return Value:

    None.

--*/

{
    InetCheckDebugMemoryFreed();
    TerminateSerializedList(&AllocatedBlockList);
}


HLOCAL
InetAllocateMemory(
    IN UINT LocalAllocFlags,
    IN UINT NumberOfBytes
    )

/*++

Routine Description:

    Debug memory allocator: allocates memory with head & tail. Fills memory
    with signature unless otherwise requested. If this is moveable memory
    then the caller must lock the memory with InetLockMemory(), else a pointer
    will be returned to the head of the heap's real start-of-block, and the
    caller will probably nuke the signature contents (but we should discover
    this when the block is freed)

Arguments:

    LocalAllocFlags - flags to be passed on to LocalAlloc
    NumberOfBytes   - to allocate for caller

Return Value:

    LPVOID
        Success - pointer to memory after DEBUG_MEMORY_HEADER
        Failure - NULL

--*/

{
    HLOCAL hLocal;
    UINT blockLength;
    BOOL isMoveable;

    isMoveable = (LocalAllocFlags & LMEM_MOVEABLE) ? TRUE : FALSE;
    blockLength = ROUND_UP_DWORD(NumberOfBytes)
                + sizeof(DEBUG_MEMORY_HEADER)
                + sizeof(DEBUG_MEMORY_FOOTER)
                ;

    //
    // possible problem: if NumberOfBytes + signatures would overflow UINT.
    // Only really problematic on 16-bit platforms
    //

    if (blockLength < NumberOfBytes) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)NumberOfBytes
                    ));

        DEBUG_BREAK(MEMALLOC);

        return (HLOCAL)NULL;
    }

    hLocal = LocalAlloc(LocalAllocFlags, blockLength);
    if (hLocal != NULL) {

        LPVOID lpMem;
        LPDEBUG_MEMORY_HEADER lpHeader;
        DWORD dwFiller;
        BYTE bFiller;
        UINT dwFillLength;
        UINT bFillLength1;
        UINT bFillLength2;
        UINT i;
        LPVOID userPointer;

        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += NumberOfBytes;
        ++MemoryAllocations;

        if (isMoveable) {
            lpMem = (LPVOID)LocalLock(hLocal);
            if (lpMem == NULL) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalLock(%x) failed: %d\n",
                            hLocal,
                            GetLastError()
                            ));

                DEBUG_BREAK(MEMALLOC);

            }
        } else {
            lpMem = (LPVOID)hLocal;
        }

        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMem;
        InitializeListHead(&lpHeader->List);
        lpHeader->BlockLength = blockLength;
        lpHeader->RealLength = NumberOfBytes;
        lpHeader->Signature = HEADER_SIGNATURE;
        lpHeader->LockCount = 0;
        lpHeader->Flags = LocalAllocFlags;

        GET_CALLERS_ADDRESS(&lpHeader->CreatorReturnAddress[0],
                            &lpHeader->CreatorReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemAllocate;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            lpHeader->Guard[i] = GUARD_DWORD_FILL;
        }

        if (LocalAllocFlags & LMEM_ZEROINIT) {
            dwFiller = 0;
            bFiller = 0;
        } else {
            dwFiller = DWORD_FILL;
            bFiller = BYTE_FILL;
        }
        dwFillLength = NumberOfBytes / sizeof(DWORD);
        bFillLength1 = NumberOfBytes % sizeof(DWORD);
        bFillLength2 = bFillLength1 ? (sizeof(DWORD) - bFillLength1) : 0;
        userPointer = (LPVOID)(lpHeader + 1);

        LPDWORD lpdwUserPointer = (LPDWORD)userPointer;

        for (i = 0; i < dwFillLength; ++i) {
            *lpdwUserPointer++ = dwFiller;
        }

        LPBYTE lpbUserPointer = (LPBYTE)lpdwUserPointer;

        for (i = 0; i < bFillLength1; ++i) {
            *lpbUserPointer++ = bFiller;
        }
        for (i = 0; i < bFillLength2; ++i) {
            *lpbUserPointer++ = BYTE_FILL_EXTRA;
        }

        userPointer = (LPVOID)lpbUserPointer;

        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard[i] = GUARD_DWORD_FILL;
        }
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->BlockLength = blockLength;
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->Signature = FOOTER_SIGNATURE;
        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2[i] = GUARD_DWORD_FILL;
        }

        //
        // if this is moveable memory, then we can't link it into the allocated
        // block list because if it moves, the list gets nuked. So we have to
        // allocate a DEBUG_MOVEABLE_TAG, link that and point to it from here
        //

        if (isMoveable) {

            LPDEBUG_MOVEABLE_TAG lpTag;

            lpTag = (LPDEBUG_MOVEABLE_TAG)InetAllocateMemory(LMEM_FIXED, sizeof(DEBUG_MOVEABLE_TAG));

            INET_ASSERT(lpTag != NULL);

            lpTag->hMoveable = hLocal;
            lpHeader->Tag = lpTag;
        } else {
            if (!InsertAtHeadOfSerializedList(&AllocatedBlockList, &lpHeader->List)) {
                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("InetAllocateMemory(%x): Unable to insert to allocated block list\n",
                            hLocal
                            ));

                DEBUG_BREAK(MEMALLOC);
            }
        }

        if (isMoveable) {
            if (LocalUnlock(hLocal)) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalUnlock(%x): memory still locked\n",
                            hLocal
                            ));

                DEBUG_BREAK(MEMALLOC);

            } else {

                DWORD err;

                err = GetLastError();
                if (err != NO_ERROR) {

                    DEBUG_PRINT(MEMALLOC,
                                ERROR,
                                ("LocalUnlock(%x) returns %d\n",
                                hLocal,
                                err
                                ));

                    DEBUG_BREAK(MEMALLOC);

                }
            }
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


HLOCAL
InetReallocateMemory(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Reallocates previously allocated block

    BUGBUG - this doesn't handle the more exotic LocalReAlloc stuff, like
             DISCARDABLE memory, allocating/freeing through realloc etc

Arguments:

    hLocal      - block to reallocate
    Size        - new size
    Flags       - new flags
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to find out from hLocal whether this
                  memory is moveable or fixed

Return Value:

    HLOCAL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    UINT realLength;
    UINT heapLength;

    //
    // can't handle reallocating down to zero
    //

    INET_ASSERT(Size != 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        heapLength = LocalSize(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        heapLength = LocalSize((HLOCAL)lpHeader);
    }

    InetCheckBlockConsistency((LPVOID)lpHeader);

    if (IsMoveable) {
        LocalUnlock(hLocal);
    }

    realLength = Size;

    Size = ROUND_UP_DWORD(Size)
         + sizeof(DEBUG_MEMORY_HEADER)
         + sizeof(DEBUG_MEMORY_FOOTER)
         ;

    ActualMemoryAllocated -= heapLength;
    BlockLengthAllocated -= lpHeader->BlockLength;
    RealLengthAllocated -= lpHeader->RealLength;

    hLocal = LocalReAlloc(hLocal, Size, Flags);
    if (hLocal != NULL) {

        LPBYTE extraPointer;
        UINT extraLength;
        UINT i;
        LPDEBUG_MEMORY_FOOTER lpFooter;

        if (IsMoveable) {
            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
        }

        lpHeader->BlockLength = Size;
        lpHeader->RealLength = realLength;
        lpHeader->Flags = Flags;

        GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                            &lpHeader->LastAccessReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemReallocate;

        extraPointer = (LPBYTE)(lpHeader + 1) + realLength;
        extraLength = (sizeof(DWORD) - (realLength % sizeof(DWORD)))
                    & (sizeof(DWORD) - 1)
                    ;
        for (i = 0; i < extraLength; ++i) {
            *extraPointer++ = BYTE_FILL_EXTRA;
        }
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)(lpHeader + 1)
                 + ROUND_UP_DWORD(realLength)
                 );
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            lpFooter->Guard[i] = GUARD_DWORD_FILL;
        }
        lpFooter->Signature = FOOTER_SIGNATURE;
        lpFooter->BlockLength = Size;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            lpFooter->Guard2[i] = GUARD_DWORD_FILL;
        }
        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += Size;
        RealLengthAllocated += lpHeader->RealLength;
        if (IsMoveable) {
            LocalUnlock(hLocal);
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines if hLocal is moveable or fixed memory

Arguments:

    hLocal  -

Return Value:

    BOOL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;

    //
    // BUGBUG - this method won't work for Win32s unless it supports SEH. But
    //          there is another method...
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
    __try {
        if (lpHeader->Signature == HEADER_SIGNATURE) {
            isMoveable = FALSE;
        } else {

            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

            INET_ASSERT(lpHeader != NULL);

            isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
            LocalUnlock(hLocal);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // yeowww! hLocal must be a handle to moveable memory. Either that, or
        // it is completely bogus
        //

        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
        LocalUnlock(hLocal);
    }
    return isMoveable;
}


HLOCAL
InetFreeMemory(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Debug memory deallocator: checks memory is already allocated and that the
    head and tail structures are still ok. Fills freed memory with signature

Arguments:

    hLocal  - address/handle of memory to free
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to determine if the memory is moveable
                  or fixed

Return Value:

    HLOCAL
        Success - NULL
        Failure - hLocal

--*/

{
    UINT memFlags;
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;
    UINT memSize;
    UINT blockLength;
    UINT realLength;

    if (!IsMoveable) {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
    }

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) == 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
    }

    memSize = LocalSize(hLocal);

    INET_ASSERT((lpHeader->BlockLength <= memSize)
                && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
                && (lpHeader->RealLength < lpHeader->BlockLength)
                );

    InetCheckBlockConsistency((LPVOID)lpHeader);

    //
    // if this is moveable memory then we didn't link it to the allocated
    // block list, but allocated a DEBUG_MOVEABLE_TAG to do the job. We
    // must remove it
    //

    if (IsMoveable) {

        LPDEBUG_MOVEABLE_TAG lpTag;

        lpTag = lpHeader->Tag;

        INET_ASSERT(lpTag->hMoveable == hLocal);

        InetFreeMemory(lpTag, FALSE);
    } else {
        if (!RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {
            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Couldn't remove %#x from allocated block list\n",
                        hLocal
                        ));

            DEBUG_BREAK(MEMALLOC);

            return hLocal;
        }
    }

    if (IsMoveable) {

        BOOL stillLocked;

        stillLocked = LocalUnlock(hLocal);

        INET_ASSERT(!stillLocked);
        INET_ASSERT(GetLastError() == NO_ERROR);

    }

    blockLength = lpHeader->BlockLength;
    realLength = lpHeader->RealLength;
    hLocal = LocalFree(hLocal);

    INET_ASSERT(hLocal == NULL);

    ActualMemoryAllocated -= memSize;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= realLength;
    ++MemoryFrees;

    return hLocal;
}


PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    )

/*++

Routine Description:

    Checks that what we think is a valid allocated block (allocated by
    InetAllocateMemory), really is

Arguments:

    lpMemory    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    LPDEBUG_MEMORY_FOOTER lpFooter;
    UINT i;
    BOOL headerGuardOverrun;
    BOOL footerGuardOverrun;
    BOOL footerGuard2Overrun;
    BOOL extraMemoryOverrun;
    LPBYTE lpExtraMemory;
    UINT byteLength;

    __try {
        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMemory;
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)lpMemory
                 + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)))
                 ;

        headerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuard2Overrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RealLength;
        extraMemoryOverrun = FALSE;
        byteLength = ROUND_UP_DWORD(lpHeader->RealLength) - lpHeader->RealLength;
        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %x\n",
                        lpMemory
                        ));

            DEBUG_BREAK(MEMALLOC);

        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %x - exception occurred\n",
                    lpMemory
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


LPVOID
InetLockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Locks a moveable memory block and increments the lock count. Checks block
    consistency

Arguments:

    hLocal  - handle of moveable memory to lock

Return Value:

    LPVOID
        pointer to locked memory

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader = NULL;
    UINT memFlags;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

    INET_ASSERT(lpHeader != NULL);

    InetCheckBlockConsistency((LPVOID)lpHeader);
    ++lpHeader->LockCount;

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemLock;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT((memFlags != LMEM_INVALID_HANDLE)
                && (lpHeader->LockCount == (LONG)(memFlags & LMEM_LOCKCOUNT))
                );

    return ++lpHeader;
}


BOOL
InetUnlockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Unlocks a (locked!) moveable memory block

Arguments:

    hLocal  - handle (pointer) of block to unlock

Return Value:

    None.

--*/

{
    UINT memFlags;
    BOOL stillLocked;
    LPDEBUG_MEMORY_HEADER lpHeader;
    DWORD lockCount;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) >= 1);

    //
    // memory must be locked or LocalFlags would have returned error.
    // Lock memory again to get pointer to block, then unlock it.
    // There should still be at least one lock on the block
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
    LocalUnlock(hLocal);

    InetCheckBlockConsistency((LPVOID)lpHeader);

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemUnlock;

    lockCount = --lpHeader->LockCount;
    stillLocked = LocalUnlock(hLocal);

    INET_ASSERT(stillLocked ? (lockCount > 0) : GetLastError() == NO_ERROR);

    return stillLocked;
}


UINT
InetMemorySize(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Returns allocated block size

Arguments:

    hLocal      - memory handle
    IsMoveable  - TRUE if hLocal is a handle to moveable memory >>> THAT IS NOT
                  LOCKED <<<

Return Value:

    UINT

--*/

{
    UINT size;
    UINT sizeInHeader;
    LPDEBUG_MEMORY_HEADER lpHeader;

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize(hLocal);
        LocalUnlock(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize((HLOCAL)lpHeader);
    }

    INET_ASSERT((sizeInHeader <= size)
                && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                );

    return sizeInHeader;
}


BOOL
InetCheckDebugMemoryFreed(
    VOID
    )

/*++

Routine Description:

    Check that we don't have any memory allocated

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    if (ActualMemoryAllocated || (MemoryFrees != MemoryAllocations)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("MemoryAllocated = %ld, MemoryAllocations = %lu, MemoryFrees = %lu\n",
                    ActualMemoryAllocated,
                    MemoryAllocations,
                    MemoryFrees
                    ));

        DEBUG_BREAK(MEMALLOC);

        return FALSE;
    }
    return TRUE;
}

#if defined(i386)


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\debug\inetdbg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inetdbg.cxx

Abstract:

    Debugging functions for internet DLL

    Contents:
        InternetDebugInitialize
        InternetDebugTerminate
        InternetGetDebugInfo
        InternetSetDebugInfo
        InternetOpenDebugFile
        InternetReopenDebugFile
        InternetCloseDebugFile
        InternetFlushDebugFile
        InternetDebugSetControlFlags
        InternetDebugResetControlFlags
        InternetDebugEnter
        InternetDebugLeave
        InternetDebugError
        InternetDebugPrint
        (InternetDebugPrintString)
        InternetDebugPrintf
        InternetDebugOut
        InternetDebugDump
        InternetDebugDumpFormat
        InternetAssert
        InternetGetDebugVariable
        (InternetGetDebugVariableString)
        InternetMapError
        InternetMapStatus
        InternetMapOption
        InternetMapHttpOption
        InternetMapHttpState
        InternetMapHttpStateFlag
        InternetMapAsyncRequest
        InternetMapHandleType
        InternetMapScheme
        InternetMapOpenType
        InternetMapService
        (ExtractFileName)
        (SetDebugPrefix)
        SourceFilename
        InitSymLib
        TermSymLib
        GetDebugSymbol
        x86SleazeCallStack
        x86SleazeCallersAddress

Author:

    Richard L Firth (rfirth) 13-Feb-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    13-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <ntverp.h>

#ifdef WINHTTP_FOR_MSMXL
#include <ieverp.h>
#endif

#include "rprintf.h"
#include <imagehlp.h>

#ifdef ENABLE_DEBUG

//
// private manifests
//

#define SWITCH_VARIABLE_NAME        "WinHttpDebugging"
#define CONTROL_VARIABLE_NAME       "WinHttpControl"
#define CATEGORY_VARIABLE_NAME      "WinHttpCategory"
#define ERROR_VARIABLE_NAME         "WinHttpError"
#define BREAK_VARIABLE_NAME         "WinHttpBreak"
//#define DEFAULT_LOG_VARIABLE_NAME   "WinHttpxLog"
#define CHECK_LIST_VARIABLE_NAME    "WinHttpCheckSerializedList"
#define LOG_FILE_VARIABLE_NAME      "WinHttpLogFile"
#define INDENT_VARIABLE_NAME        "WinHttpLogIndent"

#define DEFAULT_LOG_FILE_NAME       "WINHTTP5.LOG"

#define ENVIRONMENT_VARIABLE_BUFFER_LENGTH  80

#define PRINTF_STACK_BUFFER_LENGTH  (4 K)

//
// private macros
//

#define CASE_OF(constant)   case constant: return # constant

//
// private prototypes
//

PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    );

PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    );

PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    );
//
//
// these variables are employed in macros, so must be public
//

PUBLIC DWORD InternetDebugErrorLevel = DBG_ERROR;
PUBLIC DWORD InternetDebugControlFlags = DBG_NO_DEBUG;
PUBLIC DWORD InternetDebugCategoryFlags = 0;
PUBLIC DWORD InternetDebugBreakFlags = 0;

//
// these variables are only accessed in this module, so can be private
//

PRIVATE int InternetDebugIndentIncrement = 2;
PRIVATE HANDLE InternetDebugFileHandle = INVALID_HANDLE_VALUE;
PRIVATE char InternetDebugFilename[MAX_PATH + 1] = DEFAULT_LOG_FILE_NAME;
PRIVATE BOOL InternetDebugEnabled = TRUE;
PRIVATE DWORD InternetDebugStartTime = 0;

extern "C" {
BOOL UrlcacheDebugEnabled = FALSE;
#if defined(UNIX) && defined(ux10)
/* Temporary fix for Apogee Compiler bug on HP only */
extern BOOL fCheckEntryOnList;
#else
BOOL fCheckEntryOnList;
#endif /* UNIX */
}

//
// high frequency performance counter globals
//


PRIVATE LONGLONG ftInit;  // initial local time
PRIVATE LONGLONG pcInit;  // initial perf counter
PRIVATE LONGLONG pcFreq;  // perf counter frequency

//
// functions
//


VOID
InternetDebugInitialize(
    VOID
    )

/*++

Routine Description:

    reads environment INETDBG flags and opens debug log file if required

Arguments:

    None.

Return Value:

    None.

--*/

{
#ifndef WININET_SERVER_CORE
    //
    // ensure registry key open (normally done in GlobalDataInitialize() later)
    //

#endif //!WININET_SERVER_CORE
    
    OpenInternetSettingsKey();

    //
    // record the starting tick count for cumulative deltas
    //

    InternetDebugStartTime = GetTickCountWrap();

    if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq) {

        QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
        SYSTEMTIME st;
        GetLocalTime (&st);
        SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
    }

    //
    // check see if there are any debug variable overrides in the environment
    // or the registry. If "WinHttpLog=<!0>" is set then we use the flags that
    // are most commonly used to generate WININET.LOG, with no console or
    // debugger output. We allow the other variables to be overridden
    //

    char WinHttpVer[16] = {0};
    BOOL defaultDebugVariables = FALSE;
    rsprintf(WinHttpVer, 
            "WinHttp%dLog", 
            InternetVersionInfo.dwMajorVersion);


    InternetGetDebugVariable(WinHttpVer, (LPDWORD)&defaultDebugVariables);
    if (!defaultDebugVariables)
    {
        InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&defaultDebugVariables);
    }

    if (defaultDebugVariables) {
        InternetDebugEnabled = TRUE;
        InternetDebugControlFlags = INTERNET_DEBUG_CONTROL_DEFAULT;
        InternetDebugCategoryFlags = INTERNET_DEBUG_CATEGORY_DEFAULT;
        InternetDebugErrorLevel = INTERNET_DEBUG_ERROR_LEVEL_DEFAULT;
        InternetDebugBreakFlags = 0;
    }
    
    // InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&InternetDebugEnabled);
    InternetGetDebugVariable(CONTROL_VARIABLE_NAME, &InternetDebugControlFlags);
    InternetGetDebugVariable(CATEGORY_VARIABLE_NAME, &InternetDebugCategoryFlags);
    InternetGetDebugVariable(ERROR_VARIABLE_NAME, &InternetDebugErrorLevel);
    InternetGetDebugVariable(BREAK_VARIABLE_NAME, &InternetDebugBreakFlags);
    InternetGetDebugVariable(CHECK_LIST_VARIABLE_NAME, (LPDWORD)&fCheckEntryOnList);
    InternetGetDebugVariable(INDENT_VARIABLE_NAME, (LPDWORD)&InternetDebugIndentIncrement);
    InternetGetDebugVariableString(LOG_FILE_VARIABLE_NAME,
                                   InternetDebugFilename,
                                   sizeof(InternetDebugFilename)
                                   );

    UrlcacheDebugEnabled = InternetDebugEnabled &&
        (InternetDebugCategoryFlags & DBG_CACHE);

    if ((InternetDebugIndentIncrement < 0) || (InternetDebugIndentIncrement > 32)) {
        InternetDebugIndentIncrement = 2;
    }

    //
    // quit now if debugging is disabled
    //

    if (!InternetDebugEnabled) {
        InternetDebugControlFlags |= (DBG_NO_DEBUG | DBG_NO_DATA_DUMP);
        return;
    }

    //
    // if we want to write debug output to file, open WININET.LOG in the current
    // directory. Open it in text mode, for write-only (by this process)
    //

    if (InternetDebugControlFlags & DBG_TO_FILE) {
        if (!InternetReopenDebugFile(InternetDebugFilename)) {
            InternetDebugControlFlags &= ~DBG_TO_FILE;
        }
    }

    //
    // install the debug exception handler
    //

    SetExceptionHandler();
}


VOID
InternetDebugTerminate(
    VOID
    )

/*++

Routine Description:

    Performs any required debug termination

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_TO_FILE) {
        InternetCloseDebugFile();
    }
    InternetDebugControlFlags = DBG_NO_DEBUG;

    CloseInternetSettingsKey();
}

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the internal debug variables

Arguments:

    lpBuffer            - pointer to structure that receives the variables

    lpdwBufferLength    - IN: Length of buffer
                          OUT: length of returned data if successful, else
                          required length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS;

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD requiredLength;
    DWORD error;
    int filenameLength;

    filenameLength = ((InternetDebugFileHandle != INVALID_HANDLE_VALUE)
                        ? strlen(InternetDebugFilename) : 0) + 1;

    requiredLength = sizeof(*lpBuffer) + filenameLength;
    if ((lpBuffer != NULL) && (*lpdwBufferLength >= requiredLength)) {
        lpBuffer->ErrorLevel = InternetDebugErrorLevel;
        lpBuffer->ControlFlags = InternetDebugControlFlags;
        lpBuffer->CategoryFlags = InternetDebugCategoryFlags;
        lpBuffer->BreakFlags = InternetDebugBreakFlags;
        lpBuffer->IndentIncrement = InternetDebugIndentIncrement;
        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
            memcpy(lpBuffer->Filename, InternetDebugFilename, filenameLength);
        } else {
            lpBuffer->Filename[0] = '\0';
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the internal debugging variables to the values in the buffer. To make
    incrmental changes, the caller must first read the variables, change the
    bits they're interested in, then change the whole lot at one go

Arguments:

    lpBuffer        - pointer to structure that contains the variables

    dwBufferLength  - size of lpBuffer. Ignored

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    InternetDebugErrorLevel = lpBuffer->ErrorLevel;
    InternetDebugCategoryFlags = lpBuffer->CategoryFlags;
    InternetDebugControlFlags = lpBuffer->ControlFlags;
    InternetDebugBreakFlags = lpBuffer->BreakFlags;
    InternetDebugIndentIncrement = lpBuffer->IndentIncrement;

    //
    // handle the debug file. If we get an empty string, then (if we are logging
    // to a file), close the file.
    //
    // If the filename is exactly the same as we're already using, then the
    // caller doesn't want to change the log file
    //
    // If the filename is different, then we are being asked to create a new log
    // file: close the old and open the new. If we cannot open the new file then
    // set the filename to the NUL string in the debug buffer
    //

    if (lpBuffer->Filename[0]) {
        if (strcmp(InternetDebugFilename, lpBuffer->Filename) != 0) {
            InternetCloseDebugFile();
            InternetReopenDebugFile(lpBuffer->Filename);
            if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
                strcpy(InternetDebugFilename, lpBuffer->Filename);
            } else {
                lpBuffer->Filename[0] = '\0';
            }
        }
    } else {
        InternetCloseDebugFile();
    }
    return ERROR_SUCCESS;
}


BOOL
InternetOpenDebugFile(
    VOID
    )

/*++

Routine Description:

    Opens debug filename if not already open. Use InternetDebugFilename

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - file was opened

        FALSE   - file not opened (already open or error)

--*/

{
    if (InternetDebugFileHandle == INVALID_HANDLE_VALUE) {
        InternetDebugFileHandle = CreateFile(
            InternetDebugFilename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );
        return InternetDebugFileHandle != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}


BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    )

/*++

Routine Description:

    (Re)opens a debug log file. Closes the current one if it is open

Arguments:

    Filename    - new file to open

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        InternetCloseDebugFile();
    }
    if (Filename && *Filename) {
        InternetDebugFileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );

        //
        // put our start info in the log file. Mainly useful when we're
        // appending to the file
        //

        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {

            SYSTEMTIME currentTime;
            char filespec[MAX_PATH + 1];
            LPSTR filename;

            if (GetModuleFileName(NULL, filespec, sizeof(filespec))) {
                filename = strrchr(filespec, '\\');
                if (filename != NULL) {
                    ++filename;
                } else {
                    filename = filespec;
                }
            } else {
                filename = "";
            }

            InternetDebugGetLocalTime(&currentTime, NULL);

            InternetDebugPrintf("\n"
                                ">>>> WinHttpX Version %d.%d Build %s.%d " __DATE__ " " __TIME__ "\n"
                                ">>>> Process %s [%d (%#x)] started at %02d:%02d:%02d.%03d %02d/%02d/%d\n",
                                InternetVersionInfo.dwMajorVersion,
                                InternetVersionInfo.dwMinorVersion,
#ifdef WINHTTP_FOR_MSXML // fix MSXML build
                                "5.00",
#else
                                VER_PRODUCTVERSION_STRING,
#endif
                                InternetBuildNumber,
                                filename,
                                GetCurrentProcessId(),
                                GetCurrentProcessId(),
                                currentTime.wHour,
                                currentTime.wMinute,
                                currentTime.wSecond,
                                currentTime.wMilliseconds,
                                currentTime.wMonth,
                                currentTime.wDay,
                                currentTime.wYear
                                );

            InternetDebugPrintf(">>>> Command line = %q\n", GetCommandLine());

            InternetDebugPrintf("\n"
                                "     InternetDebugErrorLevel      = %s [%d]\n"
                                "     InternetDebugControlFlags    = %#08x\n"
                                "     InternetDebugCategoryFlags   = %#08x\n"
                                "     InternetDebugBreakFlags      = %#08x\n"
                                "     InternetDebugIndentIncrement = %d\n"
                                "\n",
                                (InternetDebugErrorLevel == DBG_INFO)       ? "Info"
                                : (InternetDebugErrorLevel == DBG_WARNING)  ? "Warning"
                                : (InternetDebugErrorLevel == DBG_ERROR)    ? "Error"
                                : (InternetDebugErrorLevel == DBG_FATAL)    ? "Fatal"
                                : (InternetDebugErrorLevel == DBG_ALWAYS)   ? "Always"
                                : "?",
                                InternetDebugErrorLevel,
                                InternetDebugControlFlags,
                                InternetDebugCategoryFlags,
                                InternetDebugBreakFlags,
                                InternetDebugIndentIncrement
                                );
            return TRUE;
        }
    }
    return FALSE;
}


VOID
InternetCloseDebugFile(
    VOID
    )

/*++

Routine Description:

    Closes the current debug log file

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
        CloseHandle(InternetDebugFileHandle);
        InternetDebugFileHandle = INVALID_HANDLE_VALUE;
    }
}


VOID
InternetFlushDebugFile(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(InternetDebugFileHandle);
    }
}


VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets debug control flags

Arguments:

    dwFlags - flags to set

Return Value:

    None.

--*/

{
    InternetDebugControlFlags |= dwFlags;
}


VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resets debug control flags

Arguments:

    dwFlags - flags to reset

Return Value:

    None.

--*/

{
    InternetDebugControlFlags &= ~dwFlags;
}


VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    IN ...
    )

/*++

Routine Description:

    Creates an INTERNET_DEBUG_RECORD for the current function and adds it to
    the per-thread (debug) call-tree

Arguments:

    Category        - category flags, e.g. DBG_FTP

    ReturnType      - type of data it returns

    Function        - name of the function. Must be global, static string

    ParameterList   - string describing parameters to function, or NULL if none

    ...             - parameters to function

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = NEW(INTERNET_DEBUG_RECORD);

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    pRecord->Stack = pThreadInfo->Stack;
    pRecord->Category = Category;
    pRecord->ReturnType = ReturnType;
    pRecord->Function = Function;
    pRecord->LastTime = GetTickCountWrap();
    pThreadInfo->Stack = pRecord;
    ++pThreadInfo->CallDepth;

    //
    // if the function's category (FTP, GOPHER, HTTP) is selected in the
    // category flags, then we dump the function entry information
    //

    if (InternetDebugCategoryFlags & Category) {

        char buf[4096];
        LPSTR bufptr;

        bufptr = buf;
        bufptr += rsprintf(bufptr, "%s(", Function);
        if (ARGUMENT_PRESENT(ParameterList)) {

            va_list parms;

            va_start(parms, ParameterList);
            bufptr += _sprintf(bufptr, (char*)ParameterList, parms);
            va_end(parms);
        }
        rsprintf(bufptr, ")\n");
        InternetDebugPrintString(buf);

        //
        // only increase the indentation if we will display debug information
        // for this category
        //

        pThreadInfo->IndentIncrement += InternetDebugIndentIncrement;
    }
}


VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Destroys the INTERNET_DEBUG_RECORD for the current function and dumps info
    about what the function is returning, if requested to do so

Arguments:

    Variable    - variable containing value being returned by function

    Filename    - name of file where DEBUG_LEAVE() invoked

    LineNumber  - and line number in Filename

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR format;
    LPSTR errstr;
    BOOL noVar;
    char formatBuf[128];
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    //
    // we are about to output a diagnostic message to the debug log, debugger,
    // or console. First check that we are required to display messages at
    // this level. The level for function ENTER and LEAVE is INFO
    //

    if (InternetDebugErrorLevel <= DBG_INFO) {

        //
        // only display the string and reduce the indent if we are requested
        // for information about this category
        //

        errstr = NULL;
        noVar = FALSE;
        if (InternetDebugCategoryFlags & pRecord->Category) {
            switch (pRecord->ReturnType) {
            case None:
                format = "%s() returning VOID";
                noVar = TRUE;
                break;

            case Bool:
                Variable = (DWORD_PTR)(Variable ? "TRUE" : "FALSE");

                //
                // *** FALL THROUGH ***
                //

            case String:
                format = "%s() returning %s";
                break;

            case Int:
                format = "%s() returning %d";
                break;

            case Dword:
                format = "%s() returning %u";
                errstr = InternetMapError((DWORD)Variable);
                if (errstr != NULL) {
                    if (*errstr == '?') {
                        rsprintf(hexnumBuf, "%#x", Variable);
                        errstr = hexnumBuf;
                        format = "%s() returning %u [?] (%s)";
                    } else {
                        format = "%s() returning %u [%s]";
                    }
                }
                break;

            case Handle:
            case Pointer:
                if (Variable == 0) {
                    format = "%s() returning NULL";
                    noVar = TRUE;
                } else {
                    if (pRecord->ReturnType == Handle) {
                        format = "%s() returning handle %#x";
                    } else {
                        format = "%s() returning %#x";
                    }
                }
                break;

            default:

                INET_ASSERT(FALSE);

                break;
            }

            pThreadInfo->IndentIncrement -= InternetDebugIndentIncrement;
            if (pThreadInfo->IndentIncrement < 0) {
                pThreadInfo->IndentIncrement = 0;
            }

            //
            // add line number info, if requested
            //

            strcpy(formatBuf, format);
            if (!(InternetDebugControlFlags & DBG_NO_LINE_NUMBER)) {
                strcat(formatBuf, " (line %d)");
            }
            strcat(formatBuf, "\n");

            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {
                strcat(formatBuf, "\n");
            }

            //
            // dump the line, depending on requirements and number of arguments
            //

            if (noVar) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   LineNumber
                                   );
            } else if (errstr != NULL) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   errstr,
                                   LineNumber
                                   );
            } else {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   LineNumber
                                   );
            }
/*
            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {

                //
                // don't call InternetDebugPrint - we don't need timing, thread,
                // level etc. information just for the separator
                //

                InternetDebugOut("\n", FALSE);
            }
*/
        }
    }

    //
    // regardless of whether we are outputting debug info for this category,
    // remove the debug record and reduce the call-depth
    //

    --pThreadInfo->CallDepth;
    pThreadInfo->Stack = pRecord->Stack;

    DEL(pRecord);

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugError(
    IN DWORD Error
    )

/*++

Routine Description:

    Used to display that a function is returning an error. We try to display a
    symbolic name for the error too (as when we are returning a DWORD from a
    function, using DEBUG_LEAVE)

    Displays a string of the form:

        Foo() returning error 87 [ERROR_INVALID_PARAMETER]

Arguments:

    Error   - the error code

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR errstr;
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);
    INET_ASSERT(GetLastError() == lastError);

    if (pThreadInfo == NULL) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (pRecord == NULL) {
        return;
    }

    errstr = InternetMapError(Error);
    if ((errstr == NULL) || (*errstr == '?')) {
        rsprintf(hexnumBuf, "%#x", Error);
        errstr = hexnumBuf;
    }
    InternetDebugPrint("%s() returning %d [%s]\n",
                       pRecord->Function,
                       Error,
                       errstr
                       );

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    )

/*++

Routine Description:

    Internet equivalent of printf()

Arguments:

    Format  - printf format string

    ...     - any extra args

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    va_list list;

    va_start(list, Format);
    _sprintf(bufptr, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    )

/*++

Routine Description:

    Internet equivalent of printf(), but takes valist as the args

Arguments:

    Format  - printf format string

    list    - stack frame of variable arguments

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    _sprintf(bufptr, Format, list);

    InternetDebugOut(buf, FALSE);
}


PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), except we perform no expansion on the string

Arguments:

    String  - already formatted string (may contain %s)

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    strcpy(bufptr, String);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), but we don't access the per-thread info
    (because we may not have any)

Arguments:

    Format  - printf format string

    ...     - any extra args


Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    va_list list;
    char buf[PRINTF_STACK_BUFFER_LENGTH];

    va_start(list, Format);
    _sprintf(buf, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    )

/*++

Routine Description:

    Writes a string somewhere - to the debug log file, to the console, or via
    the debugger, or any combination

Arguments:

    Buffer  - pointer to formatted buffer to write

    Assert  - TRUE if this function is being called from InternetAssert(), in
              which case we *always* write to the debugger. Of course, there
              may be no debugger attached, in which case no action is taken

Return Value:

    None.

--*/

{
    int buflen;
    DWORD written;

    buflen = strlen(Buffer);
    if ((InternetDebugControlFlags & DBG_TO_FILE)
    && (InternetDebugFileHandle != INVALID_HANDLE_VALUE)) {
        WriteFile(InternetDebugFileHandle, Buffer, buflen, &written, NULL);
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
    }

    if (InternetDebugControlFlags & DBG_TO_CONSOLE) {
        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                     Buffer,
                     buflen,
                     &written,
                     0
                     );
    }

    if (Assert || (InternetDebugControlFlags & DBG_TO_DEBUGGER)) {
        OutputDebugString(Buffer);
    }
}


VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    )

/*++

Routine Description:

    Dumps Size bytes at Address, in the time-honoured debug tradition

Arguments:

    Text    - to display before dumping data

    Address - start of buffer

    Size    - number of bytes

Return Value:

    None.

--*/

{
    //
    // if flags say no data dumps then quit
    //

    if (InternetDebugControlFlags & (DBG_NO_DEBUG | DBG_NO_DATA_DUMP)) {
        return;
    }

    //
    // display the introduction text, if any
    //

    if (Text) {
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrint(Text);
        } else {
            InternetDebugOut(Text, FALSE);
        }
    }

    char buf[128];

    //
    // display a line telling us how much data there is, if requested to
    //

    if (InternetDebugControlFlags & DBG_DUMP_LENGTH) {
        rsprintf(buf, "%d (%#x) bytes @ %#x\n", Size, Size, Address);
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        int len = InternetDebugDumpFormat(Address, Size, sizeof(BYTE), buf);

        //
        // if we are to indent the data to the current level, then display the
        // buffer via InternetDebugPrint() which will apply all the thread id,
        // indentation, and other options selected, else just display the data
        // via InternetDebugOut(), which will simply send it to the output media
        //

        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }

        Address += len;
        Size -= len;
    }
}


DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    )

/*++

Routine Description:

    Formats Size bytes at Address, in the time-honoured debug tradition, for
    data dump purposes

Arguments:

    Address     - start of buffer

    Size        - number of bytes

    ElementSize - size of each word element in bytes

    Buffer      - pointer to output buffer, assumed to be large enough

Return Value:

    DWORD   - number of bytes formatted

--*/

{
    //
    // we (currently) only understand DWORD, WORD and BYTE dumps
    //

    if ((ElementSize != sizeof(DWORD)) && (ElementSize != sizeof(WORD))) {
        ElementSize = sizeof(BYTE);
    }

    static char spaces[] = "                                               ";    // 15 * 3 + 2
    int i, len;

    len = min(Size, 16);
    rsprintf(Buffer, "%08x  ", Address);

    //
    // dump the hex representation of each character or word - up to 16 per line
    //

    DWORD offset = 10;

    for (i = 0; i < len; i += ElementSize) {

        DWORD value;
        LPSTR formatString;

        switch (ElementSize) {
        case 4:
            formatString = "%08x ";
            value = *(LPDWORD)&Address[i];
            break;

        case 2:
            formatString = "%04x ";
            value = *(LPWORD)&Address[i] & 0xffff;
            break;

        default:
            formatString = ((i & 15) == 7) ? "%02.2x-" : "%02.2x ";
            value = Address[i] & 0xff;
            break;
        }
        rsprintf(&Buffer[offset], formatString, value);
        offset += ElementSize * 2 + 1;
    }

    //
    // write as many spaces as required to tab to ASCII field
    //

    memcpy(&Buffer[offset], spaces, (16 - len) * 3 + 2);
    offset += (16 - len) * 3 + 2;

    //
    // dump ASCII representation of each character
    //

    for (i = 0; i < len; ++i) {

        char ch;

        ch = Address[i];
        Buffer[offset + i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
    }

    Buffer[offset + i++] = '\r';
    Buffer[offset + i++] = '\n';
    Buffer[offset + i] = '\0';

    return len;
}


VOID
InternetAssert(
    IN LPSTR Assertion,
    IN LPSTR FileName,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    displays assertion message at debugger and raised breakpoint exception

Arguments:

    Assertion   - string describing assertion which failed

    FileName    - module where assertion failure occurred

    LineNumber  - at this line number

Return Value:

    None.

--*/

{
    char buffer[512];

    rsprintf(buffer,
             "\n"
             "*** WinHttp Assertion failed: %s\n"
             "*** Source file: %s\n"
             "*** Source line: %d\n"
             "*** Thread %08x\n"
             "\n",
             Assertion,
             FileName,
             LineNumber,
             GetCurrentThreadId()
             );
    InternetDebugOut(buffer, TRUE);

    //
    // break to the debugger, unless it is requested that we don't
    //

    if (!(InternetDebugControlFlags & DBG_NO_ASSERT_BREAK)) {
        DebugBreak();
    }
}


VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    )

/*++

Routine Description:

    Get debug variable. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpdwVariable        - returned variable

Return Value:

    None.

--*/

{
    DWORD len;
    char varbuf[ENVIRONMENT_VARIABLE_BUFFER_LENGTH];

    //
    // get the debug variables first from the environment, then - if not there -
    // from the registry
    //

    len = GetEnvironmentVariable(lpszVariableName, varbuf, sizeof(varbuf));
    if (len && len < sizeof(varbuf)) {
        *lpdwVariable = (DWORD)strtoul(varbuf, NULL, 0);
    } else {
        InternetReadRegistryDword(lpszVariableName, lpdwVariable);
    }
}


PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    )

/*++

Routine Description:

    Get debug variable string. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpszVariable        - returned string variable

    dwVariableLen       - size of buffer

Return Value:

    None.

--*/

{
    if (GetEnvironmentVariable(lpszVariableName, lpszVariable, dwVariableLen) == 0) {

        char buf[MAX_PATH + 1];
        DWORD len = min(sizeof(buf), dwVariableLen);

        if (InternetReadRegistryString(lpszVariableName, buf, &len) == ERROR_SUCCESS) {
            memcpy(lpszVariable, buf, len + 1);
        }
    }
}

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN_VALUE eToken
    )
{
    switch(eToken)
    {
        CASE_OF(CHUNK_TOKEN_DIGIT);
        CASE_OF(CHUNK_TOKEN_DATA);
        CASE_OF(CHUNK_TOKEN_COLON);
        CASE_OF(CHUNK_TOKEN_CR);
        CASE_OF(CHUNK_TOKEN_LF);

        default:
            return "?";

    }
}

LPSTR
InternetMapChunkState(
    IN CHUNK_DECODE_STATE eState
    )
{
    switch(eState)
    {
        CASE_OF(CHUNK_DECODE_STATE_START);
        CASE_OF(CHUNK_DECODE_STATE_SIZE);
        CASE_OF(CHUNK_DECODE_STATE_SIZE_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_EXT);
        CASE_OF(CHUNK_DECODE_STATE_DATA);
        CASE_OF(CHUNK_DECODE_STATE_DATA_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_FOOTER_NAME);
        CASE_OF(CHUNK_DECODE_STATE_FOOTER_VALUE);
        CASE_OF(CHUNK_DECODE_STATE_FINAL_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_ERROR);

        default:
            return "?";

    }
}


LPSTR
InternetMapError(
    IN DWORD Error
    )

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error) {

    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);


    //
    // WINHTTP errors
    //

    CASE_OF(ERROR_WINHTTP_OUT_OF_HANDLES);
    CASE_OF(ERROR_WINHTTP_TIMEOUT);
    CASE_OF(ERROR_WINHTTP_INTERNAL_ERROR);
    CASE_OF(ERROR_WINHTTP_INVALID_URL);
    CASE_OF(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_WINHTTP_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_WINHTTP_INVALID_OPTION);
    CASE_OF(ERROR_WINHTTP_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_WINHTTP_SHUTDOWN);
    CASE_OF(ERROR_WINHTTP_INCORRECT_PASSWORD);
    CASE_OF(ERROR_WINHTTP_LOGIN_FAILURE);
    CASE_OF(ERROR_WINHTTP_OPERATION_CANCELLED);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_WINHTTP_CANNOT_CONNECT);
    CASE_OF(ERROR_WINHTTP_CONNECTION_ERROR);
    CASE_OF(ERROR_WINHTTP_FORCE_RETRY);
    CASE_OF(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_WINHTTP_NOT_INITIALIZED);
    CASE_OF(ERROR_WINHTTP_SECURE_FAILURE);

    CASE_OF(ERROR_HTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_HTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_HTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_HTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_HTTP_NOT_REDIRECTED);

    //
    // SSPI errors
    //

    CASE_OF(SEC_E_INSUFFICIENT_MEMORY);
    CASE_OF(SEC_E_INVALID_HANDLE);
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION);
    CASE_OF(SEC_E_TARGET_UNKNOWN);
    CASE_OF(SEC_E_INTERNAL_ERROR);
    CASE_OF(SEC_E_SECPKG_NOT_FOUND);
    CASE_OF(SEC_E_NOT_OWNER);
    CASE_OF(SEC_E_CANNOT_INSTALL);
    CASE_OF(SEC_E_INVALID_TOKEN);
    CASE_OF(SEC_E_CANNOT_PACK);
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED);
    CASE_OF(SEC_E_NO_IMPERSONATION);
    CASE_OF(SEC_E_LOGON_DENIED);
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS);
    CASE_OF(SEC_E_NO_CREDENTIALS);
    CASE_OF(SEC_E_MESSAGE_ALTERED);
    CASE_OF(SEC_E_OUT_OF_SEQUENCE);
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE);
    CASE_OF(SEC_I_LOCAL_LOGON);
    CASE_OF(SEC_E_BAD_PKGID);
    CASE_OF(SEC_E_CONTEXT_EXPIRED);
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE);


    //
    // WINSOCK errors
    //

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

#if 0
    //
    // RAS errors
    //

    CASE_OF(PENDING);
    CASE_OF(ERROR_INVALID_PORT_HANDLE);
    CASE_OF(ERROR_PORT_ALREADY_OPEN);
    CASE_OF(ERROR_BUFFER_TOO_SMALL);
    CASE_OF(ERROR_WRONG_INFO_SPECIFIED);
    CASE_OF(ERROR_CANNOT_SET_PORT_INFO);
    CASE_OF(ERROR_PORT_NOT_CONNECTED);
    CASE_OF(ERROR_EVENT_INVALID);
    CASE_OF(ERROR_DEVICE_DOES_NOT_EXIST);
    CASE_OF(ERROR_BUFFER_INVALID);
    CASE_OF(ERROR_ROUTE_NOT_AVAILABLE);
    CASE_OF(ERROR_ROUTE_NOT_ALLOCATED);
    CASE_OF(ERROR_INVALID_COMPRESSION_SPECIFIED);
    CASE_OF(ERROR_OUT_OF_BUFFERS);
    CASE_OF(ERROR_PORT_NOT_FOUND);
    CASE_OF(ERROR_ASYNC_REQUEST_PENDING);
    CASE_OF(ERROR_ALREADY_DISCONNECTING);
    CASE_OF(ERROR_PORT_NOT_OPEN);
    CASE_OF(ERROR_PORT_DISCONNECTED);
    CASE_OF(ERROR_NO_ENDPOINTS);
    CASE_OF(ERROR_CANNOT_OPEN_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY);
    CASE_OF(ERROR_CANNOT_WRITE_PHONEBOOK);
    CASE_OF(ERROR_CORRUPT_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_STRING);
    CASE_OF(ERROR_KEY_NOT_FOUND);
    CASE_OF(ERROR_DISCONNECTION);
    CASE_OF(ERROR_REMOTE_DISCONNECTION);
    CASE_OF(ERROR_HARDWARE_FAILURE);
    CASE_OF(ERROR_USER_DISCONNECTION);
    CASE_OF(ERROR_INVALID_SIZE);
    CASE_OF(ERROR_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_CANNOT_PROJECT_CLIENT);
    CASE_OF(ERROR_UNKNOWN);
    CASE_OF(ERROR_WRONG_DEVICE_ATTACHED);
    CASE_OF(ERROR_BAD_STRING);
    CASE_OF(ERROR_REQUEST_TIMEOUT);
    CASE_OF(ERROR_CANNOT_GET_LANA);
    CASE_OF(ERROR_NETBIOS_ERROR);
    CASE_OF(ERROR_SERVER_OUT_OF_RESOURCES);
    CASE_OF(ERROR_NAME_EXISTS_ON_NET);
    CASE_OF(ERROR_SERVER_GENERAL_NET_FAILURE);
    CASE_OF(WARNING_MSG_ALIAS_NOT_ADDED);
    CASE_OF(ERROR_AUTH_INTERNAL);
    CASE_OF(ERROR_RESTRICTED_LOGON_HOURS);
    CASE_OF(ERROR_ACCT_DISABLED);
    CASE_OF(ERROR_PASSWD_EXPIRED);
    CASE_OF(ERROR_NO_DIALIN_PERMISSION);
    CASE_OF(ERROR_SERVER_NOT_RESPONDING);
    CASE_OF(ERROR_FROM_DEVICE);
    CASE_OF(ERROR_UNRECOGNIZED_RESPONSE);
    CASE_OF(ERROR_MACRO_NOT_FOUND);
    CASE_OF(ERROR_MACRO_NOT_DEFINED);
    CASE_OF(ERROR_MESSAGE_MACRO_NOT_FOUND);
    CASE_OF(ERROR_DEFAULTOFF_MACRO_NOT_FOUND);
    CASE_OF(ERROR_FILE_COULD_NOT_BE_OPENED);
    CASE_OF(ERROR_DEVICENAME_TOO_LONG);
    CASE_OF(ERROR_DEVICENAME_NOT_FOUND);
    CASE_OF(ERROR_NO_RESPONSES);
    CASE_OF(ERROR_NO_COMMAND_FOUND);
    CASE_OF(ERROR_WRONG_KEY_SPECIFIED);
    CASE_OF(ERROR_UNKNOWN_DEVICE_TYPE);
    CASE_OF(ERROR_ALLOCATING_MEMORY);
    CASE_OF(ERROR_PORT_NOT_CONFIGURED);
    CASE_OF(ERROR_DEVICE_NOT_READY);
    CASE_OF(ERROR_READING_INI_FILE);
    CASE_OF(ERROR_NO_CONNECTION);
    CASE_OF(ERROR_BAD_USAGE_IN_INI_FILE);
    CASE_OF(ERROR_READING_SECTIONNAME);
    CASE_OF(ERROR_READING_DEVICETYPE);
    CASE_OF(ERROR_READING_DEVICENAME);
    CASE_OF(ERROR_READING_USAGE);
    CASE_OF(ERROR_READING_MAXCONNECTBPS);
    CASE_OF(ERROR_READING_MAXCARRIERBPS);
    CASE_OF(ERROR_LINE_BUSY);
    CASE_OF(ERROR_VOICE_ANSWER);
    CASE_OF(ERROR_NO_ANSWER);
    CASE_OF(ERROR_NO_CARRIER);
    CASE_OF(ERROR_NO_DIALTONE);
    CASE_OF(ERROR_IN_COMMAND);
    CASE_OF(ERROR_WRITING_SECTIONNAME);
    CASE_OF(ERROR_WRITING_DEVICETYPE);
    CASE_OF(ERROR_WRITING_DEVICENAME);
    CASE_OF(ERROR_WRITING_MAXCONNECTBPS);
    CASE_OF(ERROR_WRITING_MAXCARRIERBPS);
    CASE_OF(ERROR_WRITING_USAGE);
    CASE_OF(ERROR_WRITING_DEFAULTOFF);
    CASE_OF(ERROR_READING_DEFAULTOFF);
    CASE_OF(ERROR_EMPTY_INI_FILE);
    CASE_OF(ERROR_AUTHENTICATION_FAILURE);
    CASE_OF(ERROR_PORT_OR_DEVICE);
    CASE_OF(ERROR_NOT_BINARY_MACRO);
    CASE_OF(ERROR_DCB_NOT_FOUND);
    CASE_OF(ERROR_STATE_MACHINES_NOT_STARTED);
    CASE_OF(ERROR_STATE_MACHINES_ALREADY_STARTED);
    CASE_OF(ERROR_PARTIAL_RESPONSE_LOOPING);
    CASE_OF(ERROR_UNKNOWN_RESPONSE_KEY);
    CASE_OF(ERROR_RECV_BUF_FULL);
    CASE_OF(ERROR_CMD_TOO_LONG);
    CASE_OF(ERROR_UNSUPPORTED_BPS);
    CASE_OF(ERROR_UNEXPECTED_RESPONSE);
    CASE_OF(ERROR_INTERACTIVE_MODE);
    CASE_OF(ERROR_BAD_CALLBACK_NUMBER);
    CASE_OF(ERROR_INVALID_AUTH_STATE);
    CASE_OF(ERROR_WRITING_INITBPS);
    CASE_OF(ERROR_X25_DIAGNOSTIC);
    CASE_OF(ERROR_ACCT_EXPIRED);
    CASE_OF(ERROR_CHANGING_PASSWORD);
    CASE_OF(ERROR_OVERRUN);
    CASE_OF(ERROR_RASMAN_CANNOT_INITIALIZE);
    CASE_OF(ERROR_BIPLEX_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_NO_ACTIVE_ISDN_LINES);
    CASE_OF(ERROR_NO_ISDN_CHANNELS_AVAILABLE);
    CASE_OF(ERROR_TOO_MANY_LINE_ERRORS);
    CASE_OF(ERROR_IP_CONFIGURATION);
    CASE_OF(ERROR_NO_IP_ADDRESSES);
    CASE_OF(ERROR_PPP_TIMEOUT);
    CASE_OF(ERROR_PPP_REMOTE_TERMINATED);
    CASE_OF(ERROR_PPP_NO_PROTOCOLS_CONFIGURED);
    CASE_OF(ERROR_PPP_NO_RESPONSE);
    CASE_OF(ERROR_PPP_INVALID_PACKET);
    CASE_OF(ERROR_PHONE_NUMBER_TOO_LONG);
    CASE_OF(ERROR_IPXCP_NO_DIALOUT_CONFIGURED);
    CASE_OF(ERROR_IPXCP_NO_DIALIN_CONFIGURED);
    CASE_OF(ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE);
    CASE_OF(ERROR_ACCESSING_TCPCFGDLL);
    CASE_OF(ERROR_NO_IP_RAS_ADAPTER);
    CASE_OF(ERROR_SLIP_REQUIRES_IP);
    CASE_OF(ERROR_PROJECTION_NOT_COMPLETE);
    CASE_OF(ERROR_PROTOCOL_NOT_CONFIGURED);
    CASE_OF(ERROR_PPP_NOT_CONVERGING);
    CASE_OF(ERROR_PPP_CP_REJECTED);
    CASE_OF(ERROR_PPP_LCP_TERMINATED);
    CASE_OF(ERROR_PPP_REQUIRED_ADDRESS_REJECTED);
    CASE_OF(ERROR_PPP_NCP_TERMINATED);
    CASE_OF(ERROR_PPP_LOOPBACK_DETECTED);
    CASE_OF(ERROR_PPP_NO_ADDRESS_ASSIGNED);
    CASE_OF(ERROR_CANNOT_USE_LOGON_CREDENTIALS);
    CASE_OF(ERROR_TAPI_CONFIGURATION);
    CASE_OF(ERROR_NO_LOCAL_ENCRYPTION);
    CASE_OF(ERROR_NO_REMOTE_ENCRYPTION);
    CASE_OF(ERROR_REMOTE_REQUIRES_ENCRYPTION);
    CASE_OF(ERROR_IPXCP_NET_NUMBER_CONFLICT);
    CASE_OF(ERROR_INVALID_SMM);
    CASE_OF(ERROR_SMM_UNINITIALIZED);
    CASE_OF(ERROR_NO_MAC_FOR_PORT);
    CASE_OF(ERROR_SMM_TIMEOUT);
    CASE_OF(ERROR_BAD_PHONE_NUMBER);
    CASE_OF(ERROR_WRONG_MODULE);
    CASE_OF(ERROR_INVALID_CALLBACK_NUMBER);
    CASE_OF(ERROR_SCRIPT_SYNTAX);
#endif // 0
    default:
        return "?";
    }
}


LPSTR
InternetMapStatus(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert WINHTTP_CALLBACK_STATUS_ value to symbolic name

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME);
    CASE_OF(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REDIRECT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_READ_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_ERROR);
    }
    return "?";
}


LPSTR
InternetMapSSPIError(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert a SSL/PCT SSPI Error Code to a string.

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {

    CASE_OF(STATUS_SUCCESS);
    CASE_OF(SEC_E_INSUFFICIENT_MEMORY        );
    CASE_OF(SEC_E_INVALID_HANDLE             );
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION       );
    CASE_OF(SEC_E_TARGET_UNKNOWN             );
    CASE_OF(SEC_E_INTERNAL_ERROR             );
    CASE_OF(SEC_E_SECPKG_NOT_FOUND           );
    CASE_OF(SEC_E_NOT_OWNER                  );
    CASE_OF(SEC_E_CANNOT_INSTALL             );
    CASE_OF(SEC_E_INVALID_TOKEN              );
    CASE_OF(SEC_E_CANNOT_PACK                );
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED          );
    CASE_OF(SEC_E_NO_IMPERSONATION           );
    CASE_OF(SEC_E_LOGON_DENIED               );
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS        );
    CASE_OF(SEC_E_NO_CREDENTIALS             );
    CASE_OF(SEC_E_MESSAGE_ALTERED            );
    CASE_OF(SEC_E_OUT_OF_SEQUENCE            );
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE      );
    CASE_OF(SEC_I_LOCAL_LOGON                );
    CASE_OF(SEC_E_BAD_PKGID                  );
    CASE_OF(SEC_E_CONTEXT_EXPIRED            );
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE         );
//    CASE_OF(SEC_E_NO_SPM                     );
//    CASE_OF(SEC_E_NOT_SUPPORTED              );

    }
    return "?";
}




LPSTR
InternetMapHttpOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert HTTP_QUERY_ option value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(HTTP_QUERY_MIME_VERSION);               // 0
    CASE_OF(HTTP_QUERY_CONTENT_TYPE);               // 1
    CASE_OF(HTTP_QUERY_CONTENT_TRANSFER_ENCODING);  // 2
    CASE_OF(HTTP_QUERY_CONTENT_ID);                 // 3
    CASE_OF(HTTP_QUERY_CONTENT_DESCRIPTION);        // 4
    CASE_OF(HTTP_QUERY_CONTENT_LENGTH);             // 5
    CASE_OF(HTTP_QUERY_CONTENT_LANGUAGE);           // 6
    CASE_OF(HTTP_QUERY_ALLOW);                      // 7
    CASE_OF(HTTP_QUERY_PUBLIC);                     // 8
    CASE_OF(HTTP_QUERY_DATE);                       // 9
    CASE_OF(HTTP_QUERY_EXPIRES);                    // 10
    CASE_OF(HTTP_QUERY_LAST_MODIFIED);              // 11
    CASE_OF(HTTP_QUERY_MESSAGE_ID);                 // 12
    CASE_OF(HTTP_QUERY_URI);                        // 13
    CASE_OF(HTTP_QUERY_DERIVED_FROM);               // 14
    CASE_OF(HTTP_QUERY_COST);                       // 15
    CASE_OF(HTTP_QUERY_LINK);                       // 16
    CASE_OF(HTTP_QUERY_PRAGMA);                     // 17
    CASE_OF(HTTP_QUERY_VERSION);                    // 18
    CASE_OF(HTTP_QUERY_STATUS_CODE);                // 19
    CASE_OF(HTTP_QUERY_STATUS_TEXT);                // 20
    CASE_OF(HTTP_QUERY_RAW_HEADERS);                // 21
    CASE_OF(HTTP_QUERY_RAW_HEADERS_CRLF);           // 22
    CASE_OF(HTTP_QUERY_CONNECTION);                 // 23
    CASE_OF(HTTP_QUERY_ACCEPT);                     // 24
    CASE_OF(HTTP_QUERY_ACCEPT_CHARSET);             // 25
    CASE_OF(HTTP_QUERY_ACCEPT_ENCODING);            // 26
    CASE_OF(HTTP_QUERY_ACCEPT_LANGUAGE);            // 27
    CASE_OF(HTTP_QUERY_AUTHORIZATION);              // 28
    CASE_OF(HTTP_QUERY_CONTENT_ENCODING);           // 29
    CASE_OF(HTTP_QUERY_FORWARDED);                  // 30
    CASE_OF(HTTP_QUERY_FROM);                       // 31
    CASE_OF(HTTP_QUERY_IF_MODIFIED_SINCE);          // 32
    CASE_OF(HTTP_QUERY_LOCATION);                   // 33
    CASE_OF(HTTP_QUERY_ORIG_URI);                   // 34
    CASE_OF(HTTP_QUERY_REFERER);                    // 35
    CASE_OF(HTTP_QUERY_RETRY_AFTER);                // 36
    CASE_OF(HTTP_QUERY_SERVER);                     // 37
    CASE_OF(HTTP_QUERY_TITLE);                      // 38
    CASE_OF(HTTP_QUERY_USER_AGENT);                 // 39
    CASE_OF(HTTP_QUERY_WWW_AUTHENTICATE);           // 40
    CASE_OF(HTTP_QUERY_PROXY_AUTHENTICATE);         // 41
    CASE_OF(HTTP_QUERY_ACCEPT_RANGES);              // 42
    CASE_OF(HTTP_QUERY_SET_COOKIE);                 // 43
    CASE_OF(HTTP_QUERY_COOKIE);                     // 44
    CASE_OF(HTTP_QUERY_REQUEST_METHOD);             // 45
    CASE_OF(HTTP_QUERY_REFRESH);                    // 46
    CASE_OF(HTTP_QUERY_CONTENT_DISPOSITION);        // 47
    CASE_OF(HTTP_QUERY_AGE);                        // 48
    CASE_OF(HTTP_QUERY_CACHE_CONTROL);              // 49
    CASE_OF(HTTP_QUERY_CONTENT_BASE);               // 50
    CASE_OF(HTTP_QUERY_CONTENT_LOCATION);           // 51
    CASE_OF(HTTP_QUERY_CONTENT_MD5);                // 52
    CASE_OF(HTTP_QUERY_CONTENT_RANGE);              // 53
    CASE_OF(HTTP_QUERY_ETAG);                       // 54
    CASE_OF(HTTP_QUERY_HOST);                       // 55
    CASE_OF(HTTP_QUERY_IF_MATCH);                   // 56
    CASE_OF(HTTP_QUERY_IF_NONE_MATCH);              // 57
    CASE_OF(HTTP_QUERY_IF_RANGE);                   // 58
    CASE_OF(HTTP_QUERY_IF_UNMODIFIED_SINCE);        // 59
    CASE_OF(HTTP_QUERY_MAX_FORWARDS);               // 60
    CASE_OF(HTTP_QUERY_PROXY_AUTHORIZATION);        // 61
    CASE_OF(HTTP_QUERY_RANGE);                      // 62
    CASE_OF(HTTP_QUERY_TRANSFER_ENCODING);          // 63
    CASE_OF(HTTP_QUERY_UPGRADE);                    // 64
    CASE_OF(HTTP_QUERY_VARY);                       // 65
    CASE_OF(HTTP_QUERY_VIA);                        // 66
    CASE_OF(HTTP_QUERY_WARNING);                    // 67
    CASE_OF(HTTP_QUERY_EXPECT);                     // 68
    CASE_OF(HTTP_QUERY_PROXY_CONNECTION);           // 69
    CASE_OF(HTTP_QUERY_UNLESS_MODIFIED_SINCE);      // 70
    CASE_OF(HTTP_QUERY_ECHO_REQUEST);               // 71
    CASE_OF(HTTP_QUERY_ECHO_REPLY);                 // 72
    CASE_OF(HTTP_QUERY_ECHO_HEADERS);               // 73
    CASE_OF(HTTP_QUERY_ECHO_HEADERS_CRLF);          // 74
    CASE_OF(HTTP_QUERY_CUSTOM);                     // 65535
    }
    return "?";
}


LPSTR
InternetMapHttpState(
    IN WORD State
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ to symbolic name

Arguments:

    State   - to map

Return Value:

    LPSTR

--*/

{
    switch (State & ~HTTPREQ_FLAG_MASK)
    {
    CASE_OF(HttpRequestStateCreating);
    CASE_OF(HttpRequestStateOpen);
    CASE_OF(HttpRequestStateRequest);
    CASE_OF(HttpRequestStateResponse);
    CASE_OF(HttpRequestStateObjectData);
    CASE_OF(HttpRequestStateError);
    CASE_OF(HttpRequestStateClosing);
    CASE_OF(HttpRequestStateReopen);
    }
    return "?";
}

LPSTR
InternetMapHttpStateFlag(
    IN WORD Flag
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ flag to symbolic name

Arguments:

    Flag    - to map

Return Value:

    LPSTR

--*/

{
    switch (Flag & ~HTTPREQ_FLAG_MASK)
    {
    case HTTPREQ_STATE_ANYTHING_OK:
        return "ANYTHING";

    case HTTPREQ_STATE_CLOSE_OK:
        return "CLOSE";

    case HTTPREQ_STATE_ADD_OK:
        return "ADD";

    case HTTPREQ_STATE_SEND_OK:
        return "SEND";

    case HTTPREQ_STATE_READ_OK:
        return "READ";

    case HTTPREQ_STATE_QUERY_REQUEST_OK:
        return "QUERY_REQUEST";

    case HTTPREQ_STATE_QUERY_RESPONSE_OK:
        return "QUERY_RESPONSE";

    case HTTPREQ_STATE_REUSE_OK:
        return "REUSE";
    }
    return "?";
}


LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    )

/*++

Routine Description:

    Convert AR_TYPE to symbolic name

Arguments:

    Type    - Async request type

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Type) {
    CASE_OF(AR_INTERNET_CONNECT);
    CASE_OF(AR_INTERNET_OPEN_URL);
    CASE_OF(AR_INTERNET_READ_FILE);
    CASE_OF(AR_INTERNET_WRITE_FILE);
    CASE_OF(AR_INTERNET_QUERY_DATA_AVAILABLE);
    CASE_OF(AR_INTERNET_FIND_NEXT_FILE);
    CASE_OF(AR_FTP_FIND_FIRST_FILE);
    CASE_OF(AR_FTP_GET_FILE);
    CASE_OF(AR_FTP_PUT_FILE);
    CASE_OF(AR_FTP_DELETE_FILE);
    CASE_OF(AR_FTP_RENAME_FILE);
    CASE_OF(AR_FTP_OPEN_FILE);
    CASE_OF(AR_FTP_CREATE_DIRECTORY);
    CASE_OF(AR_FTP_REMOVE_DIRECTORY);
    CASE_OF(AR_FTP_SET_CURRENT_DIRECTORY);
    CASE_OF(AR_FTP_GET_CURRENT_DIRECTORY);
    CASE_OF(AR_GOPHER_FIND_FIRST_FILE);
    CASE_OF(AR_GOPHER_OPEN_FILE);
    CASE_OF(AR_GOPHER_GET_ATTRIBUTE);
    CASE_OF(AR_HTTP_SEND_REQUEST);
    CASE_OF(AR_HTTP_BEGIN_SEND_REQUEST);
    CASE_OF(AR_HTTP_END_SEND_REQUEST);
    CASE_OF(AR_READ_PREFETCH);
    CASE_OF(AR_SYNC_EVENT);
    CASE_OF(AR_TIMER_EVENT);
    CASE_OF(AR_HTTP_REQUEST1);
    CASE_OF(AR_FILE_IO);
    CASE_OF(AR_INTERNET_READ_FILE_EX);
    }
    return "?";
}


LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    )

/*++

Routine Description:

    Map handle type to symbolic name

Arguments:

    HandleType  - from handle object

Return Value:

    LPSTR

--*/

{
    switch (HandleType) {
    CASE_OF(TypeGenericHandle);
    CASE_OF(TypeInternetHandle);
    CASE_OF(TypeFtpConnectHandle);
    CASE_OF(TypeFtpFindHandle);
    CASE_OF(TypeFtpFindHandleHtml);
    CASE_OF(TypeFtpFileHandle);
    CASE_OF(TypeFtpFileHandleHtml);
    CASE_OF(TypeGopherConnectHandle);
    CASE_OF(TypeGopherFindHandle);
    CASE_OF(TypeGopherFindHandleHtml);
    CASE_OF(TypeGopherFileHandle);
    CASE_OF(TypeGopherFileHandleHtml);
    CASE_OF(TypeHttpConnectHandle);
    CASE_OF(TypeHttpRequestHandle);
    CASE_OF(TypeFileRequestHandle);
    CASE_OF(TypeWildHandle);
    }
    return "?";
}


LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps INTERNET_SCHEME_ to symbolic name

Arguments:

    Scheme  - to map

Return Value:

    LPSTR

--*/

{
    switch (Scheme) {
    CASE_OF(INTERNET_SCHEME_UNKNOWN);
    CASE_OF(INTERNET_SCHEME_DEFAULT);
    CASE_OF(INTERNET_SCHEME_HTTP);
    CASE_OF(INTERNET_SCHEME_HTTPS);
    }
    return "?";
}


LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    )

/*++

Routine Description:

    Maps INTERNET_OPEN_TYPE_ to symbolic name

Arguments:

    OpenType    - to map

Return Value:

    LPSTR

--*/

{
    switch (OpenType) {
    CASE_OF(INTERNET_OPEN_TYPE_DIRECT);
    CASE_OF(INTERNET_OPEN_TYPE_PROXY);
    CASE_OF(INTERNET_OPEN_TYPE_PRECONFIG);
    }
    return "?";
}


LPSTR
InternetMapService(
    IN DWORD Service
    )

/*++

Routine Description:

    Maps INTERNET_SERVICE_ to symbolic name

Arguments:

    Service - to map

Return Value:

    LPSTR

--*/

{
    switch (Service)
    {
        CASE_OF(INTERNET_SERVICE_HTTP);
    }
    return "?";
}

//
// private functions
//


PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    )
{
    LPSTR filename;
    LPSTR extension;
    int   len;

    filename = strrchr(Module, '\\');
    extension = strrchr(Module, '.');
    if (filename) {
        ++filename;
    } else {
        filename = Module;
    }
    if (!extension) {
        extension = filename + strlen(filename);
    }
    len = (int) (extension - filename);
    memcpy(Buf, filename, len);
    Buf[len] = '\0';
    return Buf;
}


PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    )
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(lpThreadInfo != NULL);

    if (!lpThreadInfo) {
        return NULL;
    }

    LPINTERNET_DEBUG_RECORD lpRecord;

    lpRecord = lpThreadInfo->Stack;

    if (InternetDebugControlFlags & DBG_ENTRY_TIME) {
        if ((InternetDebugControlFlags & (DBG_DELTA_TIME | DBG_CUMULATIVE_TIME))
        && lpRecord) {

            DWORD ticks;
            DWORD ticksNow;

            ticksNow = GetTickCountWrap();
            ticks = ticksNow -  ((InternetDebugControlFlags & DBG_CUMULATIVE_TIME)
                                    ? InternetDebugStartTime
                                    : lpRecord->LastTime);

            Buffer += rsprintf(Buffer,
                               "% 5d.%3d ",
                               ticks / 1000,
                               ticks % 1000
                               );
            if (InternetDebugControlFlags & DBG_DELTA_TIME) {
                lpRecord->LastTime = ticksNow;
            }
        } else {

            SYSTEMTIME timeNow;

            InternetDebugGetLocalTime(&timeNow, NULL);

            Buffer += rsprintf(Buffer,
                               "%02d:%02d:%02d.%03d ",
                               timeNow.wHour,
                               timeNow.wMinute,
                               timeNow.wSecond,
                               timeNow.wMilliseconds
                               );
        }
    }

/*
    if (InternetDebugControlFlags & DBG_LEVEL_INDICATOR) {
        Buffer += rsprintf(Buffer, );
    }
*/

    if (InternetDebugControlFlags & DBG_THREAD_INFO) {

        //
        // thread id
        //

        Buffer += rsprintf(Buffer, "%08x", lpThreadInfo->ThreadId);

        //
        // INTERNET_THREAD_INFO address
        //

        if (InternetDebugControlFlags & DBG_THREAD_INFO_ADR) {
            Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo);
        }

        //
        // ARB address
        //

        //if (InternetDebugControlFlags & DBG_ARB_ADDR) {
        //    Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo->lpArb);
        //}

        //
        // FIBER address
        //

        //if (InternetDebugControlFlags & DBG_FIBER_INFO) {
        //
        //    LPVOID p;
        //
        //    p = (lpThreadInfo->lpArb != NULL)
        //      ? lpThreadInfo->lpArb->Header.lpFiber
        //      : NULL
        //      ;
        //    Buffer += rsprintf(Buffer, ":%08x", p);
        //}

        //
        // async ID
        //

        if (InternetDebugControlFlags & DBG_ASYNC_ID) {
            if (lpThreadInfo->IsAsyncWorkerThread) {
                Buffer += rsprintf(Buffer, ":<--->");
            } else if (lpThreadInfo->InCallback) {

                //
                // async worker thread calling back into the app; any WinInet
                // API requests during this time treated as though from the
                // app context
                //

                Buffer += rsprintf(Buffer, ":<c-b>");
            }
            else
            {

                //
                // this is an app thread
                //

                Buffer += rsprintf(Buffer, ":<app>");
            }
        }

        //
        // request handle
        //

        if (InternetDebugControlFlags & DBG_REQUEST_HANDLE) {
            Buffer += rsprintf(Buffer, ":%6X", lpThreadInfo->hObject);
        }

        *Buffer++ = ' ';
    }

    if (InternetDebugControlFlags & DBG_CALL_DEPTH) {
        Buffer += rsprintf(Buffer, "%03d ", lpThreadInfo->CallDepth);
    }

    for (int i = 0; i < lpThreadInfo->IndentIncrement; ++i) {
        *Buffer++ = ' ';
    }

    //
    // if we are not debugging the category - i.e we got here via a requirement
    // to display an error, or we are in a function that does not have a
    // DEBUG_ENTER - then prefix the string with the current function name
    // (obviously misleading if the function doesn't have a DEBUG_ENTER)
    //

    if (lpRecord != NULL) {
        if (!(lpRecord->Category & InternetDebugCategoryFlags)) {
            Buffer += rsprintf(Buffer, "%s(): ", lpRecord->Function);
        }
    }

    return Buffer;
}

int dprintf(char * format, ...) {

    va_list args;
    char buf[PRINTF_STACK_BUFFER_LENGTH];
    int n;

    va_start(args, format);
    n = _sprintf(buf, format, args);
    va_end(args);
    OutputDebugString(buf);

    return n;
}


LPSTR
SourceFilename(
    LPSTR Filespec
    )
{
    if (!Filespec) {
        return "?";
    }

    LPSTR p;

    if (p = strrchr(Filespec, '\\')) {

        //
        // we want e.g. common\debugmem.cxx, but get
        // common\..\win32\debugmem.cxx. Bah!
        //

        //LPSTR q;
        //
        //if (q = strrchr(p - 1, '\\')) {
        //    p = q;
        //}
    }
    return p ? p + 1 : Filespec;
}

typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

PRIVATE HMODULE hSymLib = NULL;
PRIVATE SYMINITIALIZE pSymInitialize = NULL;
PRIVATE SYMLOADMODULE pSymLoadModule = NULL;
PRIVATE SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
PRIVATE SYMCLEANUP pSymCleanup = NULL;


VOID
InitSymLib(
    VOID
    )
{
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "WININET.DLL", "WININET", 0, 0);
    }
}


VOID
TermSymLib(
    VOID
    )
{
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}


LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    )
{
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    //
    // BUGBUG - only one caller at a time please
    //

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}

#ifndef DONT_RIP
BOOL fRip = TRUE;
#else
BOOL fRip = FALSE;
#endif

#define _TEXTW(x) L##x
#define TEXTW(x)  _TEXTW(x)
#define SZ_MODULE "WINHTTP5"
#define ARRAYSIZE(pArray) (sizeof(pArray)/sizeof(pArray[0]))
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";



static
LPCSTR
_PathFindFileNameA(
    LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


static
LPCWSTR
_PathFindFileNameW(
    LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
{
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
    {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
        {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, ((cchBuf)*sizeof(WCHAR)));
        }
        else
        {
            // No; use the provided buffer
            pwsz = pwszBuf;
        }

        if (pwsz)
        {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
        }
        else
        {
            bRet = FALSE;
        }

        *ppwszWide = pwsz;
    }
    else
    {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
        {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
        }
        bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellRipA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach, c_szRipNoFn, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (fRip)
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
            
            // MSDEV USERS:  This is not the real RIP.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

*/
BOOL
CcshellRipW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[256];

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  
    // We can get this if we get an assert in some of the W functions in 
    // shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellRipA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszRipNoFn, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (fRip)
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}

EXTERN_C const CHAR  FAR c_szRipMsg[] = SZ_MODULE "  RIP: ";
EXTERN_C const CHAR  FAR c_szNewline[] = "\n";

BOOL
__cdecl 
CcshellRipMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        OutputDebugStringA(c_szRipMsg);

        va_start(vArgs, pszMsg);
        wvsprintfA(ach, pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (fRip)
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

BOOL
__cdecl
CcshellRipMsgW(
    BOOL f, 
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        LPWSTR pwsz;
        WCHAR wszBuf[128];
        OutputDebugStringA(c_szRipMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        ach[0] = L'\0';     // In case this fails
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, ARRAYSIZE(wszBuf)))
        {
            va_start(vArgs, pszMsg);
            wvsprintfW(ach, pwsz, vArgs);
            va_end(vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        OutputDebugStringW(ach);
        OutputDebugStringA(c_szNewline);

        if (fRip)
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

#if defined(i386)


VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    )

/*++

Routine Description:

    Similar to x86SleazeCallersAddress but gathers a variable number of return
    addresses. We assume all functions have stack frame

Arguments:

    lplpvStack      - pointer to returned array of caller's addresses

    dwStackCount    - number of elements in lplpvStack

    Ebp             - starting Ebp if not 0, else use current stack

Return Value:

    None.

--*/

{
    DWORD my_esp;

    _asm mov my_esp, esp;

    __try {
        if (Ebp == 0) {
            Ebp = (LPVOID *)(&lplpvStack - 2);
        }
        while (dwStackCount--) {
            if (((DWORD)Ebp > my_esp + 0x10000) || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
            *lplpvStack++ = *(Ebp + 1);
            Ebp = (LPVOID *)*Ebp;
            if (((DWORD)Ebp <= 0x10000)
            || ((DWORD)Ebp >= 0x80000000)
            || ((DWORD)Ebp & 3)
            || ((DWORD)Ebp > my_esp + 0x10000)
            || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
}


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // ENABLE_DEBUG

INTERNETAPI
BOOL
WINAPI
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
)
{
#ifndef ENABLE_DEBUG
    // QUICK HACK TO KEEP THINGS CLEAN AND STILL MEASURE WITH HIGH PERFORMANCE
    // COUNTER

    static BOOL pcTested = FALSE;
    static LONGLONG ftInit;  // initial local time
    static LONGLONG pcInit;  // initial perf counter
    static LONGLONG pcFreq;  // perf counter frequency

    if (!pcTested)
    {
        pcTested = TRUE;
        if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq)
        {
            QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
            SYSTEMTIME st;
            GetLocalTime (&st);
            SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
        }
    }

    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#else
    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#endif // ENABLE_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\debug\rprintf.h ===
/*****************************************************************************
 *
 *  RPRINTF.C   RLF 06/15/89
 *
 *  CONTENTS    rprintf     limited re-entrant version of printf
 *              rsprintf    limited re-entrant version of sprintf
 *              _sprintf    routine which does the work
 *
 *  NOTES       Tab Stops = 4
 *
 *  $Log:   T:/pvcs/h/rprintf.h_v  $
 *
 *    Rev 1.1   29 Oct 1989 11:50:16   Richard Firth
 * Added defines for PRINTF and SPRINTF to allow easy modification when MS gets
 * the real thing working for multi-threaded programs
 *
 *    Rev 1.0   29 Aug 1989 20:04:40   RICHARDF
 * Initial revision.
 *
 ****************************************************************************/

#ifdef UNUSED
// UNUSED - causes unneed crt bloat
int cdecl rprintf(char*, ...);
#endif
int cdecl rsprintf(char*, char*, ...);
int cdecl _sprintf(char*, char*, va_list);

#define SPRINTF rsprintf
#define PRINTF  rprintf

//#define rsprintf wsprintf
//#define _sprintf wsprintf

#define RPRINTF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\dll\makefile.inc ===
!if "$(BUILD_PRODUCT)" == "IE"
MC_INC = -A
!endif

$(O)\inetmsg.rc $(O)\inetmsg.h $(O)\msg00001.bin : inetmsg.mc
    mc $(MC_INC) -v -d -r $(O) -h $(O) inetmsg.mc

winhttp.rc : $(O)\selfreg_winhttp.inf

$(O)\selfreg_winhttp.inf : selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\dll\dllentry.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dllentry.cxx

Abstract:

    Entry point for WinInet Internet client DLL

    Contents:
        WinInetDllEntryPoint

Author:

    Richard L Firth (rfirth) 10-Nov-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    10-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include <process.h>
#include <perfdiag.hxx>
#include <shlwapi.h>
#include <advpub.h>
#include <olectl.h>

#ifdef WINHTTP_STATIC_LIBRARY
#error dllentry.cxx should not be built in the static winhttpx.lib!!
#endif

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );


#if defined(__cplusplus)
}
#endif

//
// global data
//

GLOBAL CCritSec GeneralInitCritSec;

//
// functions
//


BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )

/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    if (Reason != DLL_PROCESS_ATTACH) {

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

    }

    DWORD error;

    //
    // perform global dll initialization, if any.
    //
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        INITIALIZE_DEBUG_REGKEY();
        INITIALIZE_MEMORY_MANAGER();

        GlobalDllHandle = DllHandle;
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        if (!GeneralInitCritSec.Init())
        {
            return FALSE;
        }
        
        if (!g_pAsyncCount)
        {
            g_pAsyncCount = New CAsyncCount();

            if (!g_pAsyncCount)
                return FALSE;
        }

        INET_DEBUG_START();

        if (!GlobalDllInitialize() || !InternetCreateThreadInfo(TRUE))
        {
            return FALSE;
        }

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

        // LOG_EVENT(WINHTTP_INFO, "WinHttp5 loaded");

        DEBUG_LEAVE(TRUE);

        break;

    case DLL_PROCESS_DETACH:

        // LOG_EVENT(WINHTTP_INFO, "WinHttp5 unloaded");
        
        //
        // signal to all APIs (and any other function that might have an
        // interest) that the DLL is being shutdown
        //

        GlobalDynaUnload = (Reserved == NULL) ? TRUE : FALSE;
        InDllCleanup = TRUE;

        DEBUG_PRINT(DLL,
                    INFO,
                    ("DLL Terminated\n"
                    ));

        DEBUG_LEAVE(TRUE);

        if (GlobalDynaUnload) {
            if (GlobalDataInitialized) {
                GlobalDataTerminate();
            }
            GlobalDllTerminate();
            InternetTerminateThreadInfo();
        }

        PERF_DUMP();

        PERF_END();

        //TERMINATE_DEBUG_MEMORY(FALSE);
        INET_DEBUG_FINISH();
        TERMINATE_DEBUG_REGKEY();

        //InternetDestroyThreadInfo();

        if (g_pAsyncCount)
        {
            delete g_pAsyncCount;
            g_pAsyncCount = NULL;
        }

        TERMINATE_MEMORY_MANAGER(TRUE);

        GeneralInitCritSec.FreeLock();
        break;

    case DLL_THREAD_DETACH:

        //
        // kill the INTERNET_THREAD_INFO
        //

        DEBUG_LEAVE(TRUE);

        InternetDestroyThreadInfo();
        break;

    case DLL_THREAD_ATTACH:

        //
        // we do nothing for thread attach - if we need an INTERNET_THREAD_INFO
        // then it gets created by the function which realises we need one
        //

        AllowCAP();

        DEBUG_LEAVE(TRUE);

        break;
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////
HRESULT RegisterTypeLib()
{
    ITypeLib *  pTypeLib;
    char        szPath[MAX_PATH];
    OLECHAR     wszPath[MAX_PATH];
    HRESULT     hr;

    GetModuleFileName(GlobalDllHandle, szPath, MAX_PATH);
    
    MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);

    hr = LoadTypeLib(wszPath, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = ::RegisterTypeLib(pTypeLib, wszPath, NULL);
        
        pTypeLib->Release();
    }

    if (FAILED(hr))
    {
        hr = SELFREG_E_TYPELIB;
    }

    return hr;
}

HRESULT UnregisterTypeLib()
{
    ITypeLib *  pTypeLib;
    TLIBATTR *  pTLibAttr;
    char        szPath[MAX_PATH];
    OLECHAR     wszPath[MAX_PATH];
    HRESULT     hr = NOERROR;


    GetModuleFileName(GlobalDllHandle, szPath, MAX_PATH);
    
    MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);

    hr = LoadTypeLib(wszPath, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = pTypeLib->GetLibAttr(&pTLibAttr);

        if (SUCCEEDED(hr))
        {
            hr = ::UnRegisterTypeLib(pTLibAttr->guid, pTLibAttr->wMajorVerNum,
                        pTLibAttr->wMinorVerNum,
                        pTLibAttr->lcid,
                        pTLibAttr->syskind);

            pTypeLib->ReleaseTLibAttr(pTLibAttr);
        }

        pTypeLib->Release();
    }

    return hr;
}


HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(GlobalDllHandle, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer()
{

    HRESULT hr;
    
    hr = CallRegInstall("Reg");

    if (SUCCEEDED(hr))
    {
        hr = RegisterTypeLib();
    }

    return hr;
}



STDAPI DllUnregisterServer()
{
    HRESULT hr;

    UnregisterTypeLib();

    hr = CallRegInstall("Unreg");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\handles\connect.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    Contains methods for INTERNET_CONNECT_HANDLE_OBJECT class

    Contents:
        RMakeInternetConnectObjectHandle
        INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT
        INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeInternetConnectObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN LPSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags, // dead
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates an INTERNET_CONNECT_HANDLE_OBJECT. Wrapper function callable from
    C code

Arguments:

    ParentHandle    - parent InternetOpen() handle

    ChildHandle     - IN: protocol-specific child handle
                      OUT: address of handle object

    lpszServerName  - pointer to server name

    nServerPort     - server port to connect to

    dwFlags         - various open flags from InternetConnect()

    dwContext       - app-supplied context value to associate with the handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    INTERNET_CONNECT_HANDLE_OBJECT * hConnect;

    hConnect = New INTERNET_CONNECT_HANDLE_OBJECT(
                                (INTERNET_HANDLE_BASE *)ParentHandle,
                                *ChildHandle,
                                lpszServerName,
                                nServerPort,
                                dwFlags,
                                dwContext
                                );

    if (hConnect != NULL) {
        error = hConnect->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hConnect);

            //
            // ERROR_WINHTTP_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);

                hConnect = NULL;
            }
        } else {
            delete hConnect;
            hConnect = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hConnect;

    return error;
}


//
// INTERNET_CONNECT_HANDLE_OBJECT class implementation
//


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *InternetConnectObj
    ) : INTERNET_HANDLE_BASE((INTERNET_HANDLE_BASE *)InternetConnectObj)

/*++

Routine Description:

    Constructor that creates a copy of an INTERNET_CONNECT_HANDLE_OBJECT when
    generating a derived handle object, such as a HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    InternetConnectObj  - INTERNET_CONNECT_HANDLE_OBJECT to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x",
                 InternetConnectObj
                 ));

    //
    // copy the name objects and server port
    //

    _HostName = InternetConnectObj->_HostName;
    _HostPort = InternetConnectObj->_HostPort;

    //
    // _SchemeType is actual scheme we use. May be different than original
    // object type when going via CERN proxy. Initially set to default (HTTP)
    //

    _SchemeType = InternetConnectObj->_SchemeType;

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_HANDLE_BASE * Parent,
    HINTERNET Child,
    LPTSTR lpszServerName,
    INTERNET_PORT nServerPort,
    DWORD dwFlags,
    DWORD_PTR dwContext
    ) : INTERNET_HANDLE_BASE(Parent)

/*++

Routine Description:

    Constructor for direct-to-net INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    Parent          - pointer to parent handle (INTERNET_HANDLE_BASE as
                      created by InternetOpen())

    Child           - handle of child object - typically an identifying value
                      for the protocol-specific code

    lpszServerName  - name of the server we are connecting to. May also be the
                      IP address expressed as a string

    nServerPort     - the port number at the server to which we connect

    dwFlags         - creation flags from InternetConnect():

    dwContext       - context value for call-backs

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x, %#x, %q, %d, %#x, %#x",
                 Parent,
                 Child,
                 lpszServerName,
                 nServerPort,
                 dwFlags,
                 dwContext
                 ));


    // record the parameters, making copies of string buffers
    _HostName = lpszServerName;
    _HostPort = nServerPort;
    SetSchemeType(INTERNET_SCHEME_HTTP);
    SetObjectType(TypeHttpConnectHandle);
    _Context = dwContext;
    _Status = ERROR_SUCCESS; // BUGBUG: what if we fail to allocate _HostName?

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT(VOID)

/*++

Routine Description:

    Destructor for INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    // Nothing to see here, people; move along!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\handles\hinet.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hinet.cxx

Abstract:

    contains methods for INTERNET_HANDLE_BASE class

    Contents:
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::Reference()
        HANDLE_OBJECT::Dereference()
        HANDLE_OBJECT::IsValid()
        INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(LPCSTR, ...)
        INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(INTERNET_HANDLE_BASE*)
        INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE()
        INTERNET_HANDLE_BASE::SetAbortHandle(ICSocket)
        INTERNET_HANDLE_BASE::ResetAbortHandle()
        INTERNET_HANDLE_BASE::AbortSocket()
        INTERNET_HANDLE_BASE::SetProxyInfo()
        INTERNET_HANDLE_BASE::GetProxyInfo(LPVOID, LPDWORD)
        INTERNET_HANDLE_BASE::GetProxyInfo(INTERNET_SCHEME, LPINTERNET_SCHEME, LPSTR *, LPDWORD, LPINTERNET_PORT)

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private manifests
//

#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// methods
//


HANDLE_OBJECT::HANDLE_OBJECT(
    IN HANDLE_OBJECT * Parent
    )

/*++

Routine Description:

    HANDLE_OBJECT constructor

Arguments:

    Parent  - pointer to parent HANDLE_OBJECT

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "HANDLE_OBJECT",
                "%#x",
                this
                ));

    //InitializeListHead(&_List);
    _Parent = Parent;
    if (_Parent)
        _Parent->Reference();
    _Status = AllocateHandle(this, &_Handle);
    _ObjectType = TypeGenericHandle;
    _ReferenceCount = 1;
    _Invalid = FALSE;
    _Error = ERROR_SUCCESS;
    _Signature = OBJECT_SIGNATURE;
    _Context = NULL;
    if (!InsertAtTailOfSerializedList(&GlobalObjectList, &_List))
        _Status = ERROR_NOT_ENOUGH_MEMORY;

    //
    // if AllocateHandle() failed then we cannot create this handle object.
    // Invalidate it ready for the destructor
    //

    if (_Status != ERROR_SUCCESS) {
        _Invalid = TRUE;
        _ReferenceCount = 0;
    }

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x created; address %#x; %d objects\n",
                _Handle,
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


HANDLE_OBJECT::~HANDLE_OBJECT(VOID)

/*++

Routine Description:

    HANDLE_OBJECT destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HANDLE_OBJECT",
                "%#x",
                this
                ));

    //
    // remove this object from global object list
    //

    if (LockSerializedList(&GlobalObjectList))
    {
        // should always succeed since we already have the lock
        RemoveFromSerializedList(&GlobalObjectList, &_List);
        UnlockSerializedList(&GlobalObjectList);
    }

    INET_DEBUG_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    //
    // inform the app that this handle is completely closed
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    HINTERNET hCurrent = _InternetGetObjectHandle(lpThreadInfo);
    HINTERNET hCurrentMapped = _InternetGetMappedObjectHandle(lpThreadInfo);

    _InternetSetObjectHandle(lpThreadInfo, _Handle, (HINTERNET)this);

    HINTERNET hTemp = _Handle;
    InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING,
                           (LPVOID)&hTemp,
                           sizeof(hTemp)
                           );

    _InternetSetObjectHandle(lpThreadInfo, hCurrent, hCurrentMapped);

    if (_Parent != NULL)
        _Parent->Dereference();
        
    //
    // now we can free up the API handle value
    //

    if (_Handle != NULL) {
        _Status = FreeHandle(_Handle);

        INET_ASSERT(_Status == ERROR_SUCCESS);

    }

    //
    // set the signature to a value that indicates the handle has been
    // destroyed (not useful in debug builds)
    //

    _Signature = DESTROYED_OBJECT_SIGNATURE;

    INET_ASSERT((_ReferenceCount == 0) && _Invalid);

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x destroyed; type %s; address %#x; %d objects\n",
                _Handle,
                InternetMapHandleType(_ObjectType),
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


DWORD
HANDLE_OBJECT::Reference(
    VOID
    )

/*++

Routine Description:

    Increases the reference count on the HANDLE_OBJECT

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Handle has already been invalidated
                  ERROR_ACCESS_DENIED
                    Handle object is being destroyed, cannot use it

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "HANDLE_OBJECT::Reference",
                 "{%#x}",
                 _Handle
                 ));

    DWORD error;

    if (_Invalid) {

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("handle object %#x [%#x] is invalid\n",
                    _Handle,
                    this
                    ));

        error = ERROR_INVALID_HANDLE;
    } else {
        error = ERROR_SUCCESS;
    }

    //
    // even if the handle has been invalidated (i.e. closed), we allow it
    // to continue to be referenced. The caller should return the fact
    // that the handle has been invalidated, but may require information
    // from the object in order to do so (e.g. in async thread)
    //

    do
    {
        LONG lRefCountBeforeIncrement = _ReferenceCount;

        //
        // refcount is > 0 means that the object's destructor has not been called yet
        //
        if (lRefCountBeforeIncrement > 0)
        {
            //
            // try to increment the refcount using compare-exchange
            //
#ifndef _WIN64
            LONG lRefCountCurrent = (LONG)SHInterlockedCompareExchange((LPVOID*)&_ReferenceCount,
                                                                       (LPVOID)(lRefCountBeforeIncrement + 1),
                                                                       (LPVOID)lRefCountBeforeIncrement);
#else
            //
            // can't use SHInterlockedCompareExchange on win64 because the values are really LONG's (32-bits) but they
            // are treated as pointers (64-bits) because SHInterlockedCompareExchange should really be called 
            // SHInterlockedCompareExchangePointer (sigh...).
            //
            LONG lRefCountCurrent = InterlockedCompareExchange(&_ReferenceCount,
                                                               lRefCountBeforeIncrement + 1,
                                                               lRefCountBeforeIncrement);
#endif        
            if (lRefCountCurrent == lRefCountBeforeIncrement)
            {
                //
                // since SHInterlockedCompareExchange returns the value in _ReferenceCount 
                // before the exchange, we know the exchange sucessfully took place (i.e. we 
                // sucessfully incremented the refrence count of the object by one)
                //
                INET_ASSERT(lRefCountCurrent > 0);
                break;
            }
        }
        else
        {
            //
            // the refcount dropped to zero before we could increment it,
            // so the object is being destroyed. 
            //
            error = ERROR_ACCESS_DENIED;
            break;
        }

    } while (TRUE);

    DEBUG_PRINT(REFCOUNT,
                INFO,
                ("handle object %#x [%#x] ReferenceCount = %d\n",
                _Handle,
                this,
                _ReferenceCount
                ));

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HANDLE_OBJECT::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count on the HANDLE_OBJECT, and if it goes to zero,
    the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - this object was deleted

        FALSE   - this object is still valid

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Bool,
                 "HANDLE_OBJECT::Dereference",
                 "{%#x}",
                 _Handle
                 ));

    //
    // by the time we get here, the reference count should not be 0. There
    // should be 1 call to Dereference() for each call to Reference()
    //

    INET_ASSERT(_ReferenceCount != 0);

    BOOL deleted = FALSE;

    if (InterlockedDecrement(&_ReferenceCount) == 0)
    {
        deleted = TRUE;
    }


    if (deleted)
    {
        //
        // if we are calling the destructor, the handle had better be invalid!
        //
        INET_ASSERT(_Invalid);
        
        //
        // this handle has now been closed. If there is no activity on it
        // then it will be destroyed
        //

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));

        delete this;
    } else {

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));
    }

    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD
HANDLE_OBJECT::IsValid(
    IN HINTERNET_HANDLE_TYPE ExpectedHandleType
    )

/*++

Routine Description:

    Checks a HANDLE_OBJECT for validity

Arguments:

    ExpectedHandleType  - type of object we are testing for. Can be
                          TypeWildHandle which matches any valid handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    The handle object is invalid

                  ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    The handle object is valid, but not the type we want

--*/

{
    DWORD error;
    BOOL IsOkHandle = TRUE;

    //
    // test handle object within try..except in case we are given a bad address
    //

    __try {
        if (_Signature == OBJECT_SIGNATURE) {

            error = ERROR_SUCCESS;

            //
            // check handle type if we are asked to do so.
            //

            if (ExpectedHandleType != TypeWildHandle) {
                if (ExpectedHandleType != this->GetHandleType()) {
                    error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
                }
            }
        } else {
            error = ERROR_INVALID_HANDLE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_HANDLE;
    }
    ENDEXCEPT
    return error;
}


INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(
    LPCSTR UserAgent,
    DWORD AccessMethod,
    LPSTR ProxyServerList,
    LPSTR ProxyBypassList,
    DWORD Flags
    ) : HANDLE_OBJECT(NULL)

/*++

Routine Description:

    Creates the handle object for InternetOpen()

Arguments:

    UserAgent       - name of agent (user-agent string for HTTP)

    AccessMethod    - DIRECT, PROXY or PRECONFIG

    ProxyServerList - one or more proxy servers. The string has the form:

                        [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

    ProxyBypassList - zero or more addresses which if matched will result in
                      requests NOT going via the proxy (only if PROXY access).
                      The string has the form:

                        bp_entry ::= [<scheme>"://"]<server>[":"<port>]
                        bp_macro ::= "<local>"
                        bp_list ::= [<> | bp_entry bp_macro][";"*]

    Flags           - various open flags:

                        WINHTTP_FLAG_ASYNC - not support in WinHttpX

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE",
                 NULL
                 ));


    //
    // if the HANDLE_OBJECT constructor failed then bail out now
    //

    if (_Status != ERROR_SUCCESS) {

        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("early-exit: _Status = %d\n",
                    _Status
                    ));

        DEBUG_LEAVE(0);

        return;
    }

    _PPContext = 0;

    _ThreadToken = 0;
    
    _IsCopy = FALSE;
    _UserAgent = (LPSTR)UserAgent;
    _ProxyInfo = NULL;
    _dwInternetOpenFlags = Flags;
    _WinsockLoaded = FALSE;

    _Context = NULL;

    _MaxConnectionsPerServer    = WINHTTP_CONNS_PER_SERVER_UNLIMITED;
    _MaxConnectionsPer1_0Server = WINHTTP_CONNS_PER_SERVER_UNLIMITED;
    
    //
    // set _Async based on the WINHTTP_FLAG_ASYNC supplied to InternetOpen()
    //

    _dwCodePage                 = CP_UTF8;
    _Async = (Flags & WINHTTP_FLAG_ASYNC) ? TRUE : FALSE;

    //
    // no data available yet
    //

    SetAvailableDataLength(0);

    //
    // not yet end of file
    //

    ResetEndOfFile();

    //
    // no status callback by default
    //

    _StatusCallback = NULL;
    _StatusCallbackType = FALSE;
    _dwStatusCallbackFlags = 0;

    SetObjectType(TypeInternetHandle);

    _ProxyInfoResourceLock.Initialize();

    _Status = SetProxyInfo(AccessMethod, ProxyServerList, ProxyBypassList);

    //
    // if _pICSocket is not NULL then this is the socket that this object handle
    // is currently working on. We close it to cancel the operation
    //

    _pICSocket = NULL;

    
    if (::OpenThreadToken(
                GetCurrentThread(),
                TOKEN_READ | TOKEN_IMPERSONATE,
                FALSE,
                &_ThreadToken
                ) == FALSE)
    {
        _ThreadToken = 0;
    }
    //
    // load winsock now.
    //

    if (_Status == ERROR_SUCCESS) {
    
        _Status = LoadWinsock();
        _WinsockLoaded = (_Status == ERROR_SUCCESS);

        if ( _Status == ERROR_SUCCESS )
        {
             LONG lOpenHandleCnt;

             LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

             if ( lpThreadInfo )
             {
                 lOpenHandleCnt = InterlockedIncrement((LPLONG)&GlobalInternetOpenHandleCount);

                 if ( lOpenHandleCnt == 0 )
                 {
                    DWORD fAlreadyInInit = (DWORD) InterlockedExchange((LPLONG) &GlobalAutoProxyInInit, TRUE);

                    INET_ASSERT (! fAlreadyInInit );

                    g_pGlobalProxyInfo->ReleaseQueuedRefresh();

                    InterlockedExchange((LPLONG)&GlobalAutoProxyInInit, FALSE);
                 }
             }
        }
    }

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(
    INTERNET_HANDLE_BASE *INetObj
    ) : HANDLE_OBJECT((HANDLE_OBJECT*)INetObj)

/*++

Routine Description:

    Constructor for derived handle object. We are creating this handle as part
    of an INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    INetObj - pointer to INTERNET_HANDLE_BASE to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE",
                 "{IsCopy}"
                 ));

    _PPContext = INetObj->_PPContext;
    _ThreadToken = INetObj->_ThreadToken;
    
    _IsCopy = TRUE;

    //
    // copy user agent string
    //

    //
    // BUGBUG - compiler generated copy constructor (no new string)
    //

    _UserAgent = INetObj->_UserAgent;

    //
    // do not inherit the proxy info - code must go to parent handle
    //

    _ProxyInfo = NULL;

    _dwInternetOpenFlags = INetObj->_dwInternetOpenFlags;

    //
    // creating this handle didn't load winsock
    //

    _WinsockLoaded = FALSE;

    //
    // inherit the context, async flag and status callback from
    // the parent object handle
    //

    _Context = INetObj->_Context;
 
    _MaxConnectionsPerServer    = INetObj->_MaxConnectionsPerServer;
    _MaxConnectionsPer1_0Server = INetObj->_MaxConnectionsPer1_0Server;

    _dwCodePage = INetObj->_dwCodePage;

    _Async = INetObj->_Async;

    //
    // inherit callback function
    //

    SetAvailableDataLength(0);
    ResetEndOfFile();
    _StatusCallback = INetObj->_StatusCallback;
    _StatusCallbackType = INetObj->_StatusCallbackType;
    _dwStatusCallbackFlags = INetObj->_dwStatusCallbackFlags;


    //
    // no socket operation to abort yet
    //

    _pICSocket = NULL;

    //
    // BUGBUG - this overwrites status set above?
    //

    _Status = INetObj->_Status;

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE(
    VOID
    )

/*++

Routine Description:

    INTERNET_HANDLE_BASE destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE",
                 ""
                 ));


    if (_ProxyInfo && !IsProxyGlobal() && (_ProxyInfo != PROXY_INFO_DIRECT))
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Free-ing ProxyInfo\n"
                    ));

        delete _ProxyInfo;
        _ProxyInfo = NULL;
    }


    //
    // if this handle is not a copy (i.e., it is a Session handle), then delete
    // the Passport context
    //

    if (!IsCopy()) {

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Not a Copy...\n"
                    ));

        if (_PPContext)
        {
            ::PP_FreeContext(_PPContext);
        }

        //
        // don't unload winsock. There really is no need to unload separately
        // from process detach and if we do unload, we first have to terminate
        // async support. Dynaloading and unloading winsock is vestigial
        //

        //if (_WinsockLoaded) {
        //    UnloadWinsock();
        //}

        if (_ThreadToken)
        {
            ::CloseHandle(_ThreadToken);
            _ThreadToken = NULL;
        }
    }

    DEBUG_LEAVE(0);
}

DWORD
INTERNET_HANDLE_BASE::ExchangeStatusCallback(
    LPWINHTTP_STATUS_CALLBACK lpStatusCallback,
    BOOL fType,
    DWORD dwFlags
    )
{
    DWORD error;


    WINHTTP_STATUS_CALLBACK callback;

    // exchange new and current callbacks
    callback = _StatusCallback;
    _StatusCallback = *lpStatusCallback;
    *lpStatusCallback = callback;
    _StatusCallbackType = fType;
    _dwStatusCallbackFlags = dwFlags;
    error = ERROR_SUCCESS;

    return error;
}


VOID
INTERNET_HANDLE_BASE::SetAbortHandle(
    IN ICSocket * Socket
    )

/*++

Routine Description:

    Associates with this request handle the ICSocket object currently being used
    for network I/O

Arguments:

    Socket  - pointer to ICSocket

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::SetAbortHandle",
                 "{%#x} %#x [sock=%#x ref=%d]",
                 GetPseudoHandle(),
                 Socket,
                 Socket ? Socket->GetSocket() : 0,
                 Socket ? Socket->ReferenceCount() : 0
                 ));

    INET_ASSERT(Socket != NULL);

    //
    // first off, increase the socket reference count to stop any other threads
    // killing it whilst we are performing the socket operation. The only way
    // another thread can dereference the socket is by calling our AbortSocket()
    // method
    //

    Socket->Reference();

    //
    // now associate the socket object with this handle object. We should not
    // have a current association
    //

    ICSocket * pSocket;

    pSocket = (ICSocket *) InterlockedExchangePointer((PVOID*)&_pICSocket, Socket);

    //
    // because ConnectSocket() can call this method multiple times without
    // intervening calls to ResetAbortHandle(), pSocket can legitimately be
    // non-NULL at this point
    //

    //INET_ASSERT(pSocket == NULL);

    //
    // if the handle was invalidated on another thread before we got
    // chance to set the socket to close, then abort the request now
    //

    //
    // BUGBUG - screws up normal FTP close handle processing - we
    //          have to communicate with the server in order to
    //          drop the connection
    //

    //if (IsInvalidated()) {
    //    AbortSocket();
    //}

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_BASE::ResetAbortHandle(
    VOID
    )

/*++

Routine Description:

    Disassociates this request handle and the ICSocket object when the network
    operation has completed

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::ResetAbortHandle",
                 "{%#x}",
                 GetPseudoHandle()
                 ));

    //
    // there really should be a ICSocket associated with this object, otherwise
    // our handle close/invalidation logic is broken
    //

    //
    // however, we can call ResetAbortHandle() from paths where we completed
    // early, not having called SetAbortHandle()
    //

    //INET_ASSERT(pSocket != NULL);

    //
    // so if there was a ICSocket associated with this object then remove the
    // reference added in SetAbortHandle()
    //


    ICSocket * pICSocket;

    pICSocket = (ICSocket *)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pICSocket != NULL) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket=%#x ref=%d\n",
                    pICSocket->GetSocket(),
                    pICSocket->ReferenceCount()
                    ));

        pICSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_BASE::AbortSocket(
    VOID
    )

/*++

Routine Description:

    If there is a ICSocket associated with this handle object then abort it. This
    forces the current network operation aborted and the request to complete
    with ERROR_WINHTTP_OPERATION_CANCELLED

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::AbortSocket",
                 "{%#x, %#x [sock=%#x, ref=%d]}",
                 GetPseudoHandle(),
                 (_pICSocket != NULL)
                    ? (LPVOID)_pICSocket
                    : (LPVOID)_pICSocket,
                 _pICSocket
                    ? _pICSocket->GetSocket()
                    : (_pICSocket
                        ? _pICSocket->GetSocket()
                        : 0),
                 _pICSocket
                    ? _pICSocket->ReferenceCount()
                    : (_pICSocket
                        ? _pICSocket->ReferenceCount()
                        : 0)
                 ));

    //
    // get the associated ICSocket. It may have already been removed by a call
    // to ResetAbortHandle()
    //

    //
    // if there is an associated ICSocket then abort it (close the socket handle)
    // which will complete the current network I/O (if active) with an error.
    // Once the ICSocket is aborted, we reduce the reference count that was added
    // in SetAbortHandle(). This may cause the ICSocket to be deleted
    //

    LPVOID pAddr;

    pAddr = (LPVOID)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pAddr != NULL) {

        ICSocket * pSocket = (ICSocket *)pAddr;
//dprintf(">>>>>>>> %#x AbortSocket %#x [%#x]\n", GetCurrentThreadId(), pSocket, pSocket->GetSocket());
        pSocket->Abort();
        pSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


DWORD
INTERNET_HANDLE_BASE::Refresh()
/*++

Routine Description:

    Refreshes the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Return Value:

    DWORD
        Success - ERROR_SUCCESS

--*/
{

    DWORD error;

    //
    // Reload the proxy info from registry into the GlobalProxyInfo object,
    // unless it was changed in-process to something else.
    //

    if (!g_pGlobalProxyInfo->IsModifiedInProcess()) {

        return LoadProxySettings();

    } else {

        //
        // not using global proxy or it has been set to something other
        // than the registry contents. Just return success
        //

        return ERROR_SUCCESS;
    }
}



DWORD
INTERNET_HANDLE_BASE::SetProxyInfo(
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL
    )

/*++

Routine Description:

    Sets the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    dwAccessType    - type of proxy access required

    lpszProxy       - pointer to proxy server list

    lpszProxyBypass - pointer to proxy bypass list

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_BASE::SetProxyInfo",
                "%s (%d), %#x (%q), %#x (%q)",
                InternetMapOpenType(dwAccessType),
                dwAccessType,
                lpszProxy,
                lpszProxy,
                lpszProxyBypass,
                lpszProxyBypass
                ));

    //
    // Session and HTTP Request objects can have proxy information
    //

    INET_ASSERT((GetHandleType()==TypeInternetHandle) || (GetHandleType()==TypeHttpRequestHandle));

/*

    We are setting the proxy information for an InternetOpen() handle. Based on
    the current and new settings we do the following (Note: the handle is
    initialized to DIRECT operation):

                                        current access
                +---------------------------------------------------------------
        new     |      DIRECT        |       PROXY        |      PRECONFIG
       access   |                    |                    |
    +-----------+--------------------+--------------------+---------------------
    | DIRECT    | No action          | Delete proxy info  | Remove reference to
    |           |                    |                    | global proxy info
    +-----------+--------------------+--------------------+---------------------
    | PROXY     | Set new proxy info | Delete proxy info. | Remove reference to
    |           |                    | Set new proxy info | global proxy info.
    |           |                    |                    | Set new proxy info
    +-----------+--------------------+--------------------+---------------------
    | PRECONFIG | Set proxy info to  | Delete proxy info. | No action
    |           | global proxy info  | Set proxy info to  |
    |           |                    | global proxy info  |
    +-----------+--------------------+--------------------+---------------------
*/

    DWORD error = ERROR_SUCCESS;
    PROXY_INFO * proxyInfo = NULL;

    //
    // acquire proxy info for exclusive access
    //

    if (!AcquireProxyInfo(TRUE))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (IsProxy()) {

        //
        // delete private proxy info, or unlink from global proxy info
        //

        SafeDeleteProxyInfo();
    }

    //
    // Map Various Proxy types to their internal counterparts,
    //   note that I've ordered them in what I think is their 
    //   use frequency (how often each one is most likely to get hit).
    //

    switch (dwAccessType)
    {
#ifndef WININET_SERVER_CORE
        // In WinHttpX, INTERNET_OPEN_TYPE_PRECONFIG is equivalent 
        // to INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY.
        case INTERNET_OPEN_TYPE_PRECONFIG:
            proxyInfo = g_pGlobalProxyInfo;
            break;
#endif
        case INTERNET_OPEN_TYPE_DIRECT:
            proxyInfo = PROXY_INFO_DIRECT;
            break;

        case INTERNET_OPEN_TYPE_PROXY:     
            {
                INET_ASSERT(!IsProxy());

                INTERNET_HANDLE_OBJECT * pSession;

                if (IsCopy())
                {
                    pSession = GetRootHandle(this);
                }
                else
                {
                    pSession = static_cast<INTERNET_HANDLE_OBJECT *>(this);
                    INET_ASSERT(pSession->IsValid(TypeInternetHandle) == ERROR_SUCCESS);
                }

                proxyInfo = New PROXY_INFO;
                if (proxyInfo != NULL) {
                    proxyInfo->InitializeProxySettings();
                    proxyInfo->SetSessionObject(pSession);
                    error = proxyInfo->GetError();
                    if (error == ERROR_SUCCESS &&
                        lpszProxy ) 
                    {

                        INTERNET_PROXY_INFO_EX info;
                        memset(&info, 0, sizeof(info));
                        info.dwStructSize = sizeof(info);
                        info.dwFlags = (PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY);

                        info.lpszProxy = lpszProxy;
                        info.lpszProxyBypass = lpszProxyBypass;

                        error = proxyInfo->SetProxySettings(&info, TRUE /*modified*/);

                    }
                    if (error != ERROR_SUCCESS) {
                        delete proxyInfo;
                        proxyInfo = NULL;
                    }
                } else {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }

                break;
            }

        case INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY:
            {
                // Refresh global proxy info.
                Refresh();

                proxyInfo = New PROXY_INFO_GLOBAL_WRAPPER;
                if (proxyInfo == NULL)
                    error = ERROR_NOT_ENOUGH_MEMORY;
                else
                    proxyInfo->SetSessionObject(static_cast<INTERNET_HANDLE_OBJECT *>(this));
                    
                break;
            }

        default:
            proxyInfo = NULL;
            break;
    }

    SetProxyInfo(proxyInfo);

    ReleaseProxyInfo();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_BASE::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the current proxy information for this INTERNET_HANDLE_BASE

Arguments:

    lpBuffer            - pointer to buffer where WINHTTP_PROXY_INFOA will be
                          written, and any proxy strings (if sufficient space)

    lpdwBufferLength    - IN: number of bytes in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer doesn't have enough space to hold the proxy
                    information. *lpdwBufferLength has the required size

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_BASE::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                lpdwBufferLength ? *lpdwBufferLength : 0
                ));

    INET_ASSERT(!IsCopy());

    AcquireProxyInfo(FALSE);

    DWORD error;

    if (IsProxy()) {
        error = _ProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
    } else {
        if (*lpdwBufferLength >= sizeof(WINHTTP_PROXY_INFOA)) {

            WINHTTP_PROXY_INFOA * lpInfo = (WINHTTP_PROXY_INFOA *)lpBuffer;

            lpInfo->dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
            lpInfo->lpszProxy = NULL;
            lpInfo->lpszProxyBypass = NULL;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        *lpdwBufferLength = sizeof(WINHTTP_PROXY_INFOA);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_BASE::GetProxyInfo(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Returns all proxy information based on a protocol scheme

Arguments:

    tProtocol           - protocol to get proxy info for

    lptScheme           - returned scheme

    lplpszHostName      - returned proxy name

    lpdwHostNameLength  - returned length of proxy name

    lpHostPort          - returned proxy port

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "INTERNET_HANDLE_BASE::GetProxyInfo",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT((GetHandleType() == TypeInternetHandle) ||
                (GetHandleType() == TypeHttpRequestHandle));

    DWORD error;
    BOOL rc;

    AcquireProxyInfo(FALSE);

    if ( _ProxyInfo && _ProxyInfo != PROXY_INFO_DIRECT )
    {
        error = _ProxyInfo->QueryProxySettings(ppQueryForProxyInfo);
    }
    else
    {
        error = ERROR_SUCCESS;
        (*ppQueryForProxyInfo)->SetUseProxy(FALSE);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
INTERNET_HANDLE_BASE::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN DWORD dwSecureStatus,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
{

    INET_ASSERT(!IsCopy());

    BOOL rc;

   AcquireProxyInfo(FALSE);

    if ( _ProxyInfo )
    {
        rc = _ProxyInfo->RedoSendRequest(
                                         lpdwError,
                                         dwSecureStatus,
                                         pQueryForProxyInfo,
                                         pOriginServer,
                                         pProxyServer
                                         );
    }
    else
    {
        rc = FALSE;
    }

    ReleaseProxyInfo();

    return rc;
}

INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT
    (LPCSTR ua, DWORD access, LPSTR proxy, LPSTR bypass, DWORD flags)
        : INTERNET_HANDLE_BASE (ua, access, proxy, bypass, flags)
{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT",
                 NULL
                 ));
                 
    InterlockedIncrement(&g_cSessionCount);
    if (g_pAsyncCount)
    {
        if (flags & WINHTTP_FLAG_ASYNC)
        {
            g_pAsyncCount->AddRef();
        }
    }
    else
    {
        RIP(FALSE);
    }

    InitializeSerializedList(&_ServerInfoList);
    //
    // WinHttpX supports session cookies. Each session has it's own
    // cookie jar, instead of a shared global cookie jar as in WinInet.
    //
    _CookieJar = NULL;
    _pOptionalParams = NULL;

    _pResolverCache = New CResolverCache(&_Status);
    if (!_pResolverCache)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    if (_Status == ERROR_SUCCESS)
    {
        _CookieJar = CreateCookieJar();
        if (_CookieJar == NULL)
            _Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    _fUseSessionCertCache = FALSE;
    _SessionCertCache.Initialize();

    DEBUG_LEAVE(0);
};

INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT ( )
{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT",
                 NULL
                 ));
                 
    PurgeServerInfoList(TRUE);

    TerminateSerializedList(&_ServerInfoList);

    if (_pResolverCache)
    {
        _pResolverCache->EmptyHandlesList();
        delete _pResolverCache;
    }
    
    delete _pOptionalParams;
    _pOptionalParams = NULL;
    // Delete Cookie Jar
    CloseCookieJar(_CookieJar);
    _CookieJar = NULL;

    _SessionCertCache.Terminate();

    if (g_pAsyncCount)
    {
        g_pAsyncCount->Release();
    }
    else
    {
        RIP(FALSE);
    }
        
    DEBUG_LEAVE(0);
}

//
// This function walks up to the InternetOpen handle from either
// a connect handle (child) or a request handle (grandchild).
// We only go one or two hops rather than recurse.
//

INTERNET_HANDLE_OBJECT* GetRootHandle (HANDLE_OBJECT* pHandle)
{
    pHandle = (HANDLE_OBJECT*) pHandle->GetParent();
    INET_ASSERT (pHandle);
    if (pHandle->GetHandleType() == TypeInternetHandle)
        return (INTERNET_HANDLE_OBJECT*) pHandle;

    pHandle =  (HANDLE_OBJECT*) pHandle->GetParent();
    INET_ASSERT (pHandle);
    INET_ASSERT (pHandle->GetHandleType() == TypeInternetHandle);
    return (INTERNET_HANDLE_OBJECT*) pHandle;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::SetTimeout(
    IN DWORD dwTimeoutOption,
    IN DWORD dwTimeoutValue
    )
{
    BOOL bRetval = TRUE;
    
    if (!_pOptionalParams)
    {
        _pOptionalParams = New OPTIONAL_SESSION_PARAMS();

        if (!_pOptionalParams)
        {
            bRetval = FALSE;
            goto quit;
        }
    }

    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        _pOptionalParams->dwResolveTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        _pOptionalParams->dwConnectTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_CONNECT_RETRIES:
        _pOptionalParams->dwConnectRetries = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_SEND_TIMEOUT:
        _pOptionalParams->dwSendTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        _pOptionalParams->dwReceiveTimeout = dwTimeoutValue;
        break;

    default:
        bRetval = FALSE;
    }

quit:
    return bRetval;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::SetTimeouts(
    IN DWORD        dwResolveTimeout,
    IN DWORD        dwConnectTimeout,
    IN DWORD        dwSendTimeout,
    IN DWORD        dwReceiveTimeout
    )
{
    BOOL bRetval = TRUE;
    
    if (!_pOptionalParams)
    {
        _pOptionalParams = New OPTIONAL_SESSION_PARAMS();

        if (!_pOptionalParams)
        {
            bRetval = FALSE;
            goto quit;
        }
    }

    _pOptionalParams->dwResolveTimeout = dwResolveTimeout;
    _pOptionalParams->dwConnectTimeout = dwConnectTimeout;
    _pOptionalParams->dwSendTimeout = dwSendTimeout;
    _pOptionalParams->dwReceiveTimeout = dwReceiveTimeout;
            
quit:
    return bRetval;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::GetTimeout(
    IN DWORD dwTimeoutOption,
    OUT DWORD* pdwTimeoutValue
    )
{
    BOOL bRetval = TRUE;
    if (!_pOptionalParams)
    {
        bRetval = FALSE;
        goto quit;
    }
    
    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        *pdwTimeoutValue = _pOptionalParams->dwResolveTimeout;
        break;
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        *pdwTimeoutValue = _pOptionalParams->dwConnectTimeout;
        break;
    case WINHTTP_OPTION_CONNECT_RETRIES:
        *pdwTimeoutValue = _pOptionalParams->dwConnectRetries;
        break;
    case WINHTTP_OPTION_SEND_TIMEOUT:
        *pdwTimeoutValue = _pOptionalParams->dwSendTimeout;
        break;
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        *pdwTimeoutValue = _pOptionalParams->dwReceiveTimeout;
        break;
    default:
        bRetval = FALSE;
        break;
    }

quit:    
    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\handles\autoprox.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    autoprox.cxx

Abstract:

    Contains class implementation for auto-proxy DLLs which can extent WININET's
        abilities (logic) for deciding what proxies to use.

    How auto-proxy works:
        By offloading requests to a specialized Win32 Thread which picks
        up queued up message requests for Queries, Shutdown, and Initialization


    Contents:
        AUTO_PROXY_ASYNC_MSG

Author:

    Arthur L Bierer (arthurbi) 17-Dec-1996

Revision History:

    17-Dec-1996 arthurbi
        Created

--*/

#include <wininetp.h>



AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{
    URL_COMPONENTS urlComponents;

    Initalize();

    if ( lpszUrl )
    {
        _lpszUrl      = lpszUrl;
        _dwUrlLength  = lstrlen(lpszUrl);
        _tUrlProtocol = isUrlScheme;
        _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
        _pmaAllocMode = MSG_ALLOC_STACK_ONLY;

        memset(&urlComponents, 0, sizeof(urlComponents));
        urlComponents.dwStructSize = sizeof(urlComponents);
        urlComponents.lpszHostName = lpszUrlHostName;
        urlComponents.dwHostNameLength = dwUrlHostNameLength;

        //
        // parse out the host name and port. The host name will be decoded; the
        // original URL will not be modified
        //

        if (WinHttpCrackUrlA(lpszUrl, 0, ICU_DECODE, &urlComponents))
        {
           _nUrlPort            = urlComponents.nPort;
           _lpszUrlHostName     = urlComponents.lpszHostName;
           _dwUrlHostNameLength = urlComponents.dwHostNameLength;

           if ( _tUrlProtocol == INTERNET_SCHEME_UNKNOWN )
           {
               _tUrlProtocol = urlComponents.nScheme;
           }

        }
        else
        {
            _Error = GetLastError();
        }
    }
    else
    {
        _Error = ERROR_NOT_ENOUGH_MEMORY;
    }
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{

    Initalize();

    _tUrlProtocol = isUrlScheme;
    _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode = MSG_ALLOC_STACK_ONLY;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    Initalize();

    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;

}

VOID
AUTO_PROXY_ASYNC_MSG::SetProxyMsg(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;
}


AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN PROXY_MESSAGE_TYPE pmProxyQuery
    )
{
    Initalize();

    _pmaAllocMode = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pmProxyQuery = pmProxyQuery;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN AUTO_PROXY_ASYNC_MSG *pStaticAutoProxy
    )
{
    Initalize();

    _tUrlProtocol          = pStaticAutoProxy->_tUrlProtocol;
    _lpszUrl               = (pStaticAutoProxy->_lpszUrl) ? NewString(pStaticAutoProxy->_lpszUrl) : NULL;
    _dwUrlLength           = pStaticAutoProxy->_dwUrlLength;
    _lpszUrlHostName       =
                (pStaticAutoProxy->_lpszUrlHostName ) ?
                NewString(pStaticAutoProxy->_lpszUrlHostName, pStaticAutoProxy->_dwUrlHostNameLength) :
                NULL;
    _dwUrlHostNameLength   = pStaticAutoProxy->_dwUrlHostNameLength;
    _nUrlPort              = pStaticAutoProxy->_nUrlPort;
    _tProxyScheme          = pStaticAutoProxy->_tProxyScheme;

    //
    // ProxyHostName is something that is generated by the request,
    //   therefore it should not be copied OR freed.
    //

    INET_ASSERT( pStaticAutoProxy->_lpszProxyHostName == NULL );
    //_lpszProxyHostName     = (pStaticAutoProxy->_lpszProxyHostName ) ? NewString(pStaticAutoProxy->_lpszProxyHostName) : NULL;


    _dwProxyHostNameLength = pStaticAutoProxy->_dwProxyHostNameLength;
    _nProxyHostPort        = pStaticAutoProxy->_nProxyHostPort;
    _pmProxyQuery          = pStaticAutoProxy->_pmProxyQuery;
    _pmaAllocMode          = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pProxyState           = pStaticAutoProxy->_pProxyState;

    INET_ASSERT(_pProxyState == NULL);

    _dwQueryResult         = pStaticAutoProxy->_dwQueryResult;
    _Error                 = pStaticAutoProxy->_Error;
    _MessageFlags.Dword    = pStaticAutoProxy->_MessageFlags.Dword;
    _dwProxyVersion        = pStaticAutoProxy->_dwProxyVersion;
}

AUTO_PROXY_ASYNC_MSG::~AUTO_PROXY_ASYNC_MSG(
    VOID
    )
{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~AUTO_PROXY_ASYNC_MSG",
                NULL
                ));

    if ( IsAlloced() )
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Freeing Allocated MSG ptr=%x\n",
                    this
                    ));


        if ( _lpszUrl )
        {
            //DEBUG_PRINT(OBJECTS,
            //            INFO,
            //            ("Url ptr=%x, %q\n",
            //            _lpszUrl,
            //            _lpszUrl
            //            ));

            FREE_MEMORY(_lpszUrl);
        }

        if ( _lpszUrlHostName )
        {
            FREE_MEMORY(_lpszUrlHostName);
        }


        if ( _pProxyState )
        {
            delete _pProxyState;
        }
    }
    if (_bFreeProxyHostName && (_lpszProxyHostName != NULL)) {
        FREE_MEMORY(_lpszProxyHostName);
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\chunkflt.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    chunkflt.cxx

Abstract:

    Contains a filter for encoding and decoding chunked transfers.

    Contents:
        FILTER_LIST::Insert
        FILTER_LIST::RemoveAll
        FILTER_LIST::Decode
        ChunkFilter::Reset
        ChunkFilter::Decode
        ChunkFilter::Encode
        ChunkFilter::RegisterContext
        ChunkFilter::UnregisterContext

Revision History:

    Created 13-Feb-2001

--*/

#include <wininetp.h>

// Global lookup table to map 0x0 - 0x7f bytes for obtaining mapping to its
// token value.  All values above 0x7f are considered to be data.
const BYTE g_bChunkTokenTable[] =
{
    /* 0x00 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_LF,    CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_CR,    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x10 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x20 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x30 */
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_COLON, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x40 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x50 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x60 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x70 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA
};

// Look-up table to map a token in a given state to the next state
const CHUNK_DECODE_STATE g_eMapChunkTokenToNextState[CHUNK_DECODE_STATE_LAST+1][CHUNK_TOKEN_LAST+1] =
{
/*
    |---------DIGIT----------|-------------CR-------------|-------------LF------------|----------COLON----------|-----------DATA----------|
*/
    // CHUNK_DECODE_STATE_START
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE,     CHUNK_DECODE_STATE_SIZE,    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE,

    // CHUNK_DECODE_STATE_SIZE
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_EXT,

    // CHUNK_DECODE_STATE_SIZE_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_DATA,    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_EXT
    CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_EXT,

    // CHUNK_DECODE_STATE_DATA
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_DATA_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_DATA,  CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_DATA_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_DATA_CRLF,CHUNK_DECODE_STATE_SIZE,    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_FOOTER_NAME
    CHUNK_DECODE_STATE_FOOTER_NAME, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FOOTER_VALUE, CHUNK_DECODE_STATE_FOOTER_NAME,
    
    // CHUNK_DECODE_STATE_FOOTER_VALUE
    CHUNK_DECODE_STATE_FOOTER_VALUE, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FOOTER_VALUE,
    
    // CHUNK_DECODE_STATE_FINAL_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_FINISHED, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_ERROR
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,    CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_FINISHED -- force client to reset before reuse
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,    CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR
};

// Helper macros

// Where to next?
#define MAP_CHUNK_TOKEN_TO_NEXT_STATE(eCurState, chToken) \
    (g_eMapChunkTokenToNextState[(eCurState)][(chToken)])
    
// Given a byte, what does it represent w/regards to chunked responses
#define GET_CHUNK_TOKEN(ch)  ((ch) & 0x80 ? CHUNK_TOKEN_DATA : g_bChunkTokenTable[ch])

// Should only be used with digit tokens.
// Expects byte in range 0x30-0x39 (digits), 0x41-0x46 (uppercase hex),
// or 0x61-0x66 (lowercase hex)
#define GET_VALUE_FROM_ASCII_HEX(ch)  ((ch) - ((ch) & 0xf0) + (((ch) & 0x40) ? 9 : 0))


HRESULT ChunkFilter::Reset(DWORD_PTR dwContext)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::Reset",
                 "%#x",
                 dwContext
                 ));
   
    if (dwContext)
        (reinterpret_cast<ChunkDecodeContext *>(dwContext))->Reset();

    DEBUG_LEAVE(TRUE);

    return S_OK;
}

HRESULT
ChunkFilter::Decode(
    DWORD_PTR dwContext,
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
/*++

Routine Description:

    Decode downloaded chunked data based on the inputted context and
    its current state

Arguments:

    dwContext       - registered encode/decode context for this filter

    pInBuffer       - input data buffer to be processed

    dwInBufSize     - byte count of pInBuffer

    ppOutBuffer     - allocated buffer containing encoded/decoded data if
                      not done in place with pInBuffer.

    pdwOutBufSize   - size of allocated output buffer, or 0 if pInBuffer holds
                      the processed data

    pdwBytesRead    - Number of input buffer bytes used

    pdwBytesWritten - Number of output buffer bytes written
                      
Return Value:

    HRESULT
        Success - S_OK

        Failure - E_FAIL

--*/
{
    HRESULT hResult = S_OK;
    LPBYTE pCurrentLoc = pInBuffer;
    LPBYTE pStartOfChunk = pInBuffer;
    ChunkDecodeContext * pCtx = reinterpret_cast<ChunkDecodeContext *>(dwContext);
    CHUNK_DECODE_STATE ePreviousState; 
    BYTE chToken;

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::Decode",
                 "%x, [%x, %.10q], %u, %x, %u, %x, %x",
                 dwContext,
                 pInBuffer,
                 *pInBuffer,
                 dwInBufSize,
                 ppOutBuffer,
                 pdwOutBufSize,
                 pdwBytesRead,
                 pdwBytesWritten
                 ));

    if (!dwContext)
    {
        hResult = E_INVALIDARG;
        goto quit;
    }
    else if (!pdwBytesRead || !pdwBytesWritten || !pInBuffer ||
        (ppOutBuffer && !pdwOutBufSize))
    {
        hResult = E_POINTER;
        goto quit;
    }

    *pdwBytesRead  = 0;
    *pdwBytesWritten = 0;
    
    while (*pdwBytesRead < dwInBufSize &&
           pCtx->GetState() != CHUNK_DECODE_STATE_ERROR)
    {
        chToken = GET_CHUNK_TOKEN(*pCurrentLoc);
        ePreviousState = pCtx->GetState();

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("ChunkFilter::Decode: %q, %q, %u/%u\n",
                    InternetMapChunkState(ePreviousState),
                    InternetMapChunkToken((CHUNK_TOKEN_VALUE)chToken),
                    *pdwBytesRead,
                    dwInBufSize
                    ));
        
        INET_ASSERT(pCurrentLoc < pInBuffer + dwInBufSize);

        switch (pCtx->GetState())
        {
            case CHUNK_DECODE_STATE_START:
                pCtx->Reset();
                pCtx->SetState(CHUNK_DECODE_STATE_SIZE);

                // fall through
                    
            case CHUNK_DECODE_STATE_SIZE:
            {
                if (chToken == CHUNK_TOKEN_DIGIT)
                {
                    if (pCtx->m_dwParsedSize & 0xF0000000)
                    {
                        // Don't allow overflow if by some chance
                        // the server is trying to send a chunk over
                        // 4 gigs worth in size.
                        pCtx->SetState(CHUNK_DECODE_STATE_ERROR);
                        break;
                    }
                            
                    pCtx->m_dwParsedSize <<= 4;
                    pCtx->m_dwParsedSize  += GET_VALUE_FROM_ASCII_HEX(*pCurrentLoc);
                }
                else
                {
                    pCtx->SetState(MAP_CHUNK_TOKEN_TO_NEXT_STATE(
                            CHUNK_DECODE_STATE_SIZE,
                            chToken));
                }
                break;
            }
            case CHUNK_DECODE_STATE_SIZE_CRLF:
                // Handle the zero case which can take us to the footer or final CRLF
                // If it's the final CRLF, then this should be the end of the data.
                if (pCtx->m_dwParsedSize == 0 && chToken == CHUNK_TOKEN_LF)
                {
                    pCtx->SetState(CHUNK_DECODE_STATE_FOOTER_NAME);
                }
                else
                {
                    pCtx->SetState(MAP_CHUNK_TOKEN_TO_NEXT_STATE(
                            CHUNK_DECODE_STATE_SIZE_CRLF,
                            chToken));
                }
                break;
            case CHUNK_DECODE_STATE_DATA:
            {
                INET_ASSERT(pCtx->m_dwParsedSize);
                    
                // account for EOB
                if (pCurrentLoc + pCtx->m_dwParsedSize < pInBuffer + dwInBufSize)
                {
                    const DWORD dwParsedSize = pCtx->m_dwParsedSize;

                    // Move or skip the parsed size and crlf, if needed.
                    // The start of the chunk could be equal this time if
                    // spread across multiple decode calls.
                    if (pStartOfChunk != pCurrentLoc)
                    {
                        MoveMemory(pStartOfChunk,
                                   pCurrentLoc,
                                   dwParsedSize);
                    }

                    // -1 so we can look at the first byte after the data
                    // in the next pass.
                    pCurrentLoc += dwParsedSize - 1;
                    *pdwBytesRead += dwParsedSize - 1;
                    *pdwBytesWritten += dwParsedSize;
                    pStartOfChunk += dwParsedSize;
                    pCtx->m_dwParsedSize = 0;

                    // Should be CRLF terminated
                    pCtx->SetState(CHUNK_DECODE_STATE_DATA_CRLF);
                }
                else 
                {
                    const DWORD dwSlice = dwInBufSize - (DWORD)(pCurrentLoc - pInBuffer);

                    // We're reaching the end of the buffer before
                    // the end of the chunk.  Update the parsed
                    // size remaining, so it will be carried over
                    // to the next call.
                    if (pStartOfChunk != pCurrentLoc)
                    {
                        // Skip over preceding size info.
                        MoveMemory(pStartOfChunk,
                                   pCurrentLoc,
                                   dwSlice);
                    }

                    // -1 so we can look at the first byte after the data
                    // in the next pass.  Offset should never be bigger than DWORD since
                    // since that's the biggest chunk we can handle.
                    *pdwBytesWritten += dwSlice;
                    pCtx->m_dwParsedSize -= dwSlice;
                    *pdwBytesRead += dwSlice - 1;
                    pCurrentLoc = pInBuffer + dwInBufSize - 1;
                }
                break;
            }
            
            // All remaining states simply parse over the value and
            // change state, depending on the token.
            default:
            {
                pCtx->SetState(MAP_CHUNK_TOKEN_TO_NEXT_STATE(
                        ePreviousState,
                        chToken));
                break;
            }
        }
        (*pdwBytesRead)++;
        pCurrentLoc++;
    }

    if (pCtx->GetState() == CHUNK_DECODE_STATE_ERROR)
    {
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("ChunkFilter::Decode entered error state\n"
                    ));
        hResult = E_FAIL;
    }
    
quit:
    DEBUG_LEAVE(hResult == S_OK ? TRUE : FALSE);
    
    return hResult;
}

HRESULT
ChunkFilter::Encode(
    DWORD_PTR dwContext,
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
/*++

Routine Description:

    Chunk data for uploading based on the inputted context and current state

Arguments:

    dwContext       - registered encode/decode context for this filter

    pInBuffer       - input data buffer to be processed

    dwInBufSize     - byte count of pInBuffer

    ppOutBuffer     - allocated buffer containing encoded/decoded data if
                      not done in place with pInBuffer.

    pdwOutBufSize   - size of allocated output buffer, or 0 if pInBuffer holds
                      the processed data

    pdwBytesRead    - Number of input buffer bytes used

    pdwBytesWritten - Number of output buffer bytes written
                      
Return Value:

    HRESULT
        E_NOTIMPL - currently no chunked upload support

--*/
{
    // We don't support chunked uploads...yet
    return E_NOTIMPL;
}


HRESULT
ChunkFilter::RegisterContext(OUT DWORD_PTR *pdwContext)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::RegisterContext",
                 "%#x",
                 pdwContext
                 ));

    HRESULT hr = S_OK;

    if (!pdwContext || IsBadWritePtr(pdwContext, sizeof(DWORD_PTR)))
    {
        hr = E_POINTER;
        goto quit;
    }

    *pdwContext = (DWORD_PTR) New ChunkDecodeContext;

    if (!*pdwContext)
    {
        hr = E_OUTOFMEMORY;
    }

quit:
    DEBUG_LEAVE(hr == S_OK ? TRUE : FALSE);

    return hr;
}

HRESULT
ChunkFilter::UnregisterContext(IN DWORD_PTR dwContext)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::UnregisterContext",
                 "%#x",
                 dwContext
                 ));

    HRESULT hr = S_OK;
    
    if (!dwContext)
    {
        hr = E_INVALIDARG;
        goto quit;
    }
    
    delete reinterpret_cast<ChunkDecodeContext *>(dwContext);

quit:
    DEBUG_LEAVE(hr == S_OK ? TRUE : FALSE);
    return hr;
}


// Always inserts as the beginning of the list
BOOL
FILTER_LIST::Insert(IN BaseFilter *pFilter, IN DWORD_PTR dwContext)
{
    LPFILTER_LIST_ENTRY pNewEntry;
    pNewEntry = New FILTER_LIST_ENTRY;
        
    if (pNewEntry != NULL)
    {
        pNewEntry->pFilter = pFilter;
        pNewEntry->dwContext = dwContext;
        pNewEntry->pNext = _pFilterEntry;
        _pFilterEntry = pNewEntry;
        _uFilterCount++;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


VOID
FILTER_LIST::ClearList()
{
    LPFILTER_LIST_ENTRY pEntry = _pFilterEntry;
    while (pEntry)
    {
        pEntry->pFilter->UnregisterContext(pEntry->dwContext);
        pEntry = pEntry->pNext;
        delete _pFilterEntry;
        _pFilterEntry = pEntry;
    }
    _uFilterCount = 0;
}


DWORD
FILTER_LIST::Decode(
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
{
    LPFILTER_LIST_ENTRY pEntry = _pFilterEntry;
    HRESULT hr = S_OK;
    DWORD dwBytesRead = 0;
    DWORD dwBytesWritten = 0;
    LPBYTE pLocalInBuffer = pInBuffer;
    DWORD dwLocalInBufSize = dwInBufSize;

    *pdwBytesRead = 0;
    *pdwBytesWritten = 0;
      
    // Loop through filters which should be in the proper order
    while (pEntry)
    {
        dwBytesRead = 0;
        dwBytesWritten = 0;
        // At a minimum, we're guaranteed the decode method parses
        // the input buffer until one of the following is met:
        //
        // - Input buffer is fully parsed and processed
        // - Output buffer is filled up
        // - Decoder reaches a finished state
        // - Error occurs while processing input data
        //
        // Currently, only 1, 3, and 4 are possible since chunked
        // transfers are decoded in place.  We also don't need
        // to loop since chunked decoding is always fully done
        // in the first pass.
        do
        {
            pLocalInBuffer = pLocalInBuffer + dwBytesRead;
            dwLocalInBufSize = dwLocalInBufSize - dwBytesRead;
            dwBytesWritten = 0;
            dwBytesRead = 0;
            hr =  pEntry->pFilter->Decode(pEntry->dwContext,
                                          pLocalInBuffer,
                                          dwLocalInBufSize,
                                          ppOutBuffer,
                                          pdwOutBufSize,
                                          &dwBytesRead,
                                          &dwBytesWritten
                                          );

            *pdwBytesWritten += dwBytesWritten;
            *pdwBytesRead += dwBytesRead;
              
            if (hr == S_OK && dwBytesRead < dwLocalInBufSize)
            {
                // Given the current requirements we shouldn't be here
                // if there's still input buffer data to process.
                RIP(FALSE);
                hr = E_FAIL;
                goto quit;
            }
        } while  (hr == S_OK &&
                  dwLocalInBufSize > 0 &&
                  dwBytesRead < dwLocalInBufSize);
        pEntry = pEntry->pNext;
    }
    INET_ASSERT(hr != S_OK || dwBytesRead == dwLocalInBufSize);
quit:
    switch (hr)
    {
        case S_OK:
            return ERROR_SUCCESS;

        case E_OUTOFMEMORY:
            return ERROR_NOT_ENOUGH_MEMORY;

        default:
            return ERROR_WINHTTP_INTERNAL_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\handles\hutil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hutil.cxx

Abstract:

    contains outdated c-c++ interface functions

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle, // dead
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    )
{
    INTERNET_HANDLE_OBJECT* HandleObj = (INTERNET_HANDLE_OBJECT*) Handle;
    DWORD Error = HandleObj->IsValid(ExpectedHandleType);
    if (Error != ERROR_SUCCESS)
        return Error;
    *IsAsyncHandle = HandleObj->IsAsyncHandle();
    return ERROR_SUCCESS;
}


DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // find the handle type.
        //

        *HandleType = HandleObj->GetHandleType();
    }
    return error;
}

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpdwContext = ((INTERNET_HANDLE_OBJECT*)hInternet)->GetContext();
    }
    return error;
}

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT*)hInternet)->SetContext(dwContext);
    }
    return error;
}

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback
    )
{
    //
    // NULL handle should have been caught before we got here
    // (its in WINHTTPQueryOption())
    //

    INET_ASSERT(Handle != NULL);

    *lpStatusCallback = ((INTERNET_HANDLE_OBJECT *)Handle)->GetStatusCallback();
    return ERROR_SUCCESS;
}

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType,
    IN DWORD dwFlags)
{
    DWORD error;

    //
    // NULL handle value should have been caught already
    // (in WINHTTPSetStatusCallback())
    //

    INET_ASSERT(Handle != NULL);

    error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        error = ((INTERNET_HANDLE_OBJECT *)Handle)->
                                ExchangeStatusCallback(lpStatusCallback, fType, dwFlags);
    }
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\cookiejar.h ===
#ifndef _COOKIE_JAR_H_
#define _COOKIE_JAR_H_

#include <wininetp.h>
#include "httpp.h"

//---------------------------------------------------------------------------
//
// CCookieBase
//
// Provides operator new which allocates extra memory
// after object and initializes the memory to zero.
//
//---------------------------------------------------------------------------

class CCookieBase
{
public:

    void * operator new(size_t cb, size_t cbExtra);
    void operator delete(void *pv);
};

//---------------------------------------------------------------------------
//
// CCookie
//
// Holds a single cookie value.
//
//---------------------------------------------------------------------------


class CCookie : public CCookieBase
{
public:

    ~CCookie();
    static CCookie *Construct(const char *pchName);

    BOOL            SetValue(const char *pchValue);
    BOOL            CanSend(BOOL fSecure);
    BOOL            IsPersistent() { return (_dwFlags & COOKIE_SESSION) == 0; }

    BOOL            PurgeAll(void *);

    DWORD           _dwFlags;
    CCookie *       _pCookieNext;
    char *          _pchName;
    char *          _pchValue;
    FILETIME        _ftExpiry;
};

//---------------------------------------------------------------------------
//
// CCookieLocation
//
// Holds all cookies for a given domain and path.
//
//---------------------------------------------------------------------------

class CCookieLocation : public CCookieBase
{
public:

    ~CCookieLocation();
    static CCookieLocation *Construct(const char *pchRDomain, const char *pchPath);

    CCookie *       GetCookie(const char *pchName, BOOL fCreate);
    BOOL            ReadCacheFile();
    BOOL            ReadCacheFileIfNeeded();
    void            Purge(BOOL (CCookie::*)(void *), void *);
    BOOL            IsMatch(const char *pchRDomain, const char *pchPath);

    FILETIME        _ftCacheFileLastModified;
    CCookie *       _pCookieKids;
    CCookieLocation*_pLocationNext;
    char *          _pchRDomain;
    char *          _pchPath;
    int             _cchPath;
    BYTE            _fReadFromCacheFileNeeded;
};


//---------------------------------------------------------------------------
//
// CCookieJar
//
// Maintains fixed size hash table of cookie location objects.
//
//---------------------------------------------------------------------------
enum SET_COOKIE_RESULT
{
    SET_COOKIE_FAIL     = 0,
    SET_COOKIE_SUCCESS  = 1,
    SET_COOKIE_DISALLOW = 2,
    SET_COOKIE_PENDING  = 3
};

class CCookieJar : public CCookieBase
{
public:

    static CCookieJar * Construct();

     CCookieJar();
    ~CCookieJar();

    DWORD             SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader, DWORD dwFlags);
    CCookieLocation*  GetCookies(const char *pchRDomain, const char *pchPath, CCookieLocation *pLast, FILETIME *ftCurrentTime);

    void              Purge();
    CCookieLocation** GetBucket(const char *pchRDomain);
    CCookieLocation * GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate);
    void              Serialize(HANDLE hCookieFile);

    enum { htsize=32 };
    CCookieLocation * _apLocation[htsize];

    CCritSec          _csCookieJar;

private:
   void serializeCookie(const CCookie *pCookie, HANDLE hCookieFile, const char *pchDomain, const char *pchPath);
   void expireCookies(CCookieLocation *pLocation, FILETIME *ftRefTime);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\handles\proxysup.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    proxysup.cxx

Abstract:

    Contains class implementation for proxy server and proxy bypass list

    Contents:
        IsLocalMacro

        PROXY_SERVER_LIST_ENTRY::WriteEntry

        PROXY_SERVER_LIST::AddList
        PROXY_SERVER_LIST::Find
        PROXY_SERVER_LIST::Add
        PROXY_SERVER_LIST::ProxyScheme
        PROXY_SERVER_LIST::GetProxyHostName
        PROXY_SERVER_LIST::AddToBypassList
        PROXY_SERVER_LIST::GetList

        PROXY_BYPASS_LIST_ENTRY::WriteEntry

        PROXY_BYPASS_LIST::AddList
        PROXY_BYPASS_LIST::Find
        PROXY_BYPASS_LIST::Add
        PROXY_BYPASS_LIST::IsBypassed
        PROXY_BYPASS_LIST::IsHostInBypassList
        PROXY_BYPASS_LIST::GetList

        PROXY_INFO::GetProxyStringInfo
        PROXY_INFO::HostBypassesProxy
        PROXY_INFO::RedoSendRequest
        PROXY_INFO::Terminate
        PROXY_INFO::CleanOutLists

        PROXY_STATE::GetNextProxy

        (GetRegistryProxyParameter)

Author:

    Richard L Firth (rfirth) 03-Feb-1996

Revision History:

    03-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define DEFAULT_PROXY_BUFFER_LENGTH     (4 K)
#define MAX_IP_ADDRESS_STRING_LENGTH    (4 * 4 - 1) // ###.###.###.###
#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// private types
//

typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;


//
// private prototypes
//

PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    );





//
// functions
//


BOOL
IsLocalMacro(
    IN LPSTR lpszMetaName,
    IN DWORD dwMetaNameLength
    )

/*++

Routine Description:

    Checks for local macro name

Arguments:

    lpszMetaName        - name to check

    dwMetaNameLength    - length

Return Value:

    BOOL
        TRUE    - it is <local>

        FALSE   - not

--*/

{
    INET_ASSERT(lpszMetaName != NULL);

    static const char s_local[] = "<local>";

    return (strnicmp(s_local, lpszMetaName, dwMetaNameLength) == 0);
}


//
// member functions
//


BOOL
PROXY_SERVER_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy server list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR protocolName;
    DWORD protocolNameLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude = 1;

    protocolName = MapUrlScheme(_Protocol, &protocolNameLength);
    if (protocolName != NULL) {
        requiredLength = protocolNameLength + 1;    // for '='
    } else {
        requiredLength = 0;
    }
    schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
    if (schemeName != NULL) {
        requiredLength += schemeNameLength + sizeof("://") - 1;
    }
    requiredLength += _ProxyName.StringLength();
    if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_ProxyPort / n) {
                requiredLength += i + 1;    // for ':'
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (protocolName != NULL) {
            memcpy(lpszBuffer, protocolName, protocolNameLength);
            lpszBuffer += protocolNameLength;
            *lpszBuffer++ = '=';
        }
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        _ProxyName.CopyTo(lpszBuffer);
        lpszBuffer += _ProxyName.StringLength();
        if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _ProxyPort, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_SERVER_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy servers and creates a PROXY_SERVER_LIST_ENTRY for
    each one

Arguments:

    lpszList    - pointer to list of proxies of the form:

                    [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    At least one entry in lpszList is bogus

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR protocolName;
    DWORD protocolLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    protocolName = lpszList;
    protocolLength = 0;
    schemeName = NULL;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_PROTOCOL;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case '=':
            if ((state == STATE_PROTOCOL) && (entryLength != 0)) {
                protocolLength = entryLength;
                entryLength = 0;
                state = STATE_SCHEME;
                schemeName = lpszList;
            } else {

                //
                // '=' can't legally appear anywhere else
                //

                state = STATE_ERROR;
            }
            break;

        case ':':
            switch (state) {
            case STATE_PROTOCOL:
                if (*lpszList == '/') {
                    schemeName = protocolName;
                    protocolName = NULL;
                    schemeLength = entryLength;
                    protocolLength = 0;
                    state = STATE_SCHEME;
                } else if (*lpszList != '\0') {
                    serverName = protocolName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = (schemeName != NULL)
                        ? schemeName
                        : protocolName;
                }

                INET_ASSERT(serverName != NULL);

                INTERNET_SCHEME protocol;

                if (protocolLength != 0) {
                    protocol = MapUrlSchemeName(protocolName, protocolLength);
                } else {
                    protocol = INTERNET_SCHEME_DEFAULT;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((protocol != INTERNET_SCHEME_UNKNOWN)
                && (scheme != INTERNET_SCHEME_UNKNOWN)

                //
                // we can only currently handle CERN (secure or unsecure) and
                // FTP proxies, so kick out anything that wants to go via any
                // other proxy scheme
                //

                && ((scheme == INTERNET_SCHEME_DEFAULT)
                || (scheme == INTERNET_SCHEME_HTTP)
                || (scheme == INTERNET_SCHEME_HTTPS))) {
                    if (!Find(protocol)) {

                        //
                        // don't worry if Add() fails - we just continue
                        //

                        Add(protocol, scheme, serverName, serverLength, port);
                    }
                }
            }
            entryLength = 0;
            protocolName = lpszList;
            protocolLength = 0;
            schemeName = NULL;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_PROTOCOL;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_SERVER_LIST::Find(
    IN INTERNET_SCHEME tScheme
    )

/*++

Routine Description:

    Find a PROXY_SERVER_LIST_ENTRY based on the scheme

Arguments:

    tScheme - protocol scheme to find

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_SERVER_LIST::Find",
                "%s",
                InternetMapScheme(tScheme)
                ));

    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        if (info->_Protocol == tScheme) {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::Add(
    IN INTERNET_SCHEME tProtocol,
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create an add a PROXY_SERVER_LIST_ENTRY to the PROXY_SERVER_LIST

Arguments:

    tProtocol           - protocol which uses the proxy

    tScheme             - scheme used to talk to the proxy

    lpszHostName        - proxy host name

    dwHostNameLength    - length of proxy host name

    nPort               - port at proxy host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::Add",
                "%s, %s, %.*q, %d, %d",
                InternetMapScheme(tProtocol),
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_SERVER_LIST_ENTRY * entry;

    entry = New PROXY_SERVER_LIST_ENTRY(tProtocol,
                                        tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error = ERROR_SUCCESS;

    if (entry != NULL) {
        //error = entry->ResolveAddress();
        //if (error == ERROR_SUCCESS) {
        //    InsertAtTailOfSerializedList(&_List, &entry->_List);
        //}
        if (entry->_Protocol == INTERNET_SCHEME_DEFAULT) {
            if (!InsertAtTailOfSerializedList(&_List, &entry->_List)) {
                delete entry;
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            if (!InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                delete entry;
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNET_SCHEME
PROXY_SERVER_LIST::ProxyScheme(
    IN INTERNET_SCHEME tProtocol
    )

/*++

Routine Description:

    Determines protocol over which tScheme goes through proxy

Arguments:

    tProtocol   - protocol scheme used to retrieve data (e.g. FTP)

Return Value:

    INTERNET_SCHEME
        Success - scheme by which protocol goes via proxy

        Failure - INTERNET_SCHEME_UNKNOWN
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Int,
                "PROXY_SERVER_LIST::ProxyScheme",
                "%s",
                InternetMapScheme(tProtocol)
                ));

    INTERNET_SCHEME tScheme = INTERNET_SCHEME_UNKNOWN;

    if (!LockSerializedList(&_List))
        goto quit;

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //

        if ((info->_Protocol == tProtocol)
        || (info->_Protocol == INTERNET_SCHEME_DEFAULT)) {
            tScheme = info->_Scheme;

            //
            // the default scheme is HTTP (CERN proxy)
            //

            if (tScheme == INTERNET_SCHEME_DEFAULT) {
                tScheme = INTERNET_SCHEME_HTTP;
            }
            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(tScheme);

    return tScheme;
}


BOOL
PROXY_SERVER_LIST::GetProxyHostName(
    IN INTERNET_SCHEME tProtocol,
    IN OUT LPINTERNET_SCHEME lptScheme,
    OUT LPSTR * lplpszHostName,
    OUT LPBOOL lpbFreeHostName,
    OUT LPDWORD lpdwHostNameLength,
    OUT LPINTERNET_PORT lpHostPort
    )

/*++

Routine Description:

    Given a protocol, map it to the proxy we use to retrieve the data

Arguments:

    tProtocol           - protocol to map (e.g. find the proxy for FTP)

    lptScheme           - IN: preferred scheme if INTERNET_SCHEME_DEFAULT
                          OUT: returned scheme

    lplpszHostName      - pointer to returned pointer to host name

    lpbFreeHostName     - returned TRUE if *lplpszHostName allocated

    lpdwHostNameLength  - pointer to returned host name length

    lpHostPort          - pointer to returned host port

Return Value:

    BOOL
        TRUE    - requested info has been returned

        FALSE   - requested info was not found

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_SERVER_LIST::GetProxyHostName",
                 "%s, %#x, %#x, %#x, %#x, %#x",
                 InternetMapScheme(tProtocol),
                 lptScheme,
                 lplpszHostName,
                 lpbFreeHostName,
                 lpdwHostNameLength,
                 lpHostPort
                 ));

    INET_ASSERT(tProtocol != INTERNET_SCHEME_UNKNOWN);

    //
    // *lptScheme must now be one of the recognized schemes, or the default
    //

    INET_ASSERT((*lptScheme == INTERNET_SCHEME_DEFAULT)
                || (*lptScheme == INTERNET_SCHEME_HTTP)
                || (*lptScheme == INTERNET_SCHEME_HTTPS)
                || (*lptScheme == INTERNET_SCHEME_SOCKS)
                );

    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //
        // Hack: But make sure its NOT socks since, socks must be
        //  an exact match !!! No defaults.
        //

        if ((info->_Protocol == tProtocol)
        || ((info->_Protocol == INTERNET_SCHEME_DEFAULT)
                && (tProtocol != INTERNET_SCHEME_SOCKS)  )) {

            INTERNET_SCHEME scheme = info->_Scheme;

            //
            // the returned scheme is the input preferred scheme unless it was
            // the default scheme in which case we return HTTP (CERN proxy)
            //

            if (scheme == INTERNET_SCHEME_DEFAULT) {
                scheme = (*lptScheme == INTERNET_SCHEME_DEFAULT)
                            ? INTERNET_SCHEME_HTTP
                            : *lptScheme;
            }
            *lptScheme = scheme;
            *lpbFreeHostName = FALSE;
            *lpdwHostNameLength = 0;
            *lplpszHostName = NewString(info->_ProxyName.StringAddress(),
                                        info->_ProxyName.StringLength()
                                        );
            if (*lplpszHostName != NULL) {
                *lpbFreeHostName = TRUE;
                *lpdwHostNameLength = info->_ProxyName.StringLength();
            }

            INTERNET_PORT port = info->_ProxyPort;

            //
            // map the default port value
            //

            if (port == INTERNET_INVALID_PORT_NUMBER) {
                switch (scheme) {
                case INTERNET_SCHEME_HTTP:
                    port = INTERNET_DEFAULT_HTTP_PORT;
                    break;

                case INTERNET_SCHEME_HTTPS:
                    port = INTERNET_DEFAULT_HTTPS_PORT;
                    break;

                case INTERNET_SCHEME_SOCKS:
                    port = INTERNET_DEFAULT_SOCKS_PORT;
                    break;
                }
            }
            *lpHostPort = port;
            found = TRUE;

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("proxy = %s://%s:%d\n",
                        MapUrlSchemeToName(scheme),
                        info->_ProxyName.StringAddress(),
                        port
                        ));

            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::AddToBypassList(
    IN PROXY_BYPASS_LIST * lpBypassList
    )

/*++

Routine Description:

    For all proxy servers in the server list, we add the details to the bypass
    list. By default, an app mustn't send a request to the proxy via the proxy!
    Additionally, the app should not have to specifically nominate the proxy
    server(s) as bypassing the proxy

Arguments:

    lpBypassList    - pointer to bypass proxy list where proxy servers will be
                      added

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error = ERROR_SUCCESS;
    PLIST_ENTRY entry = HeadOfSerializedList(&_List);

    while ((entry != (PLIST_ENTRY)SlSelf(&_List)) && (error == ERROR_SUCCESS)) {

        PROXY_SERVER_LIST_ENTRY * info = (PROXY_SERVER_LIST_ENTRY *)entry;

        if (!lpBypassList->Find(info->_Scheme,
                                info->_ProxyName.StringAddress(),
                                info->_ProxyName.StringLength(),
                                info->_ProxyPort)) {
            error = lpBypassList->Add(info->_Scheme,
                                      info->_ProxyName.StringAddress(),
                                      info->_ProxyName.StringLength(),
                                      info->_ProxyPort
                                      );
        }
        entry = entry->Flink;
    }
    return error;
}


VOID
PROXY_SERVER_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy servers to a buffer, and/or returns the required
    buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.

--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    if (!LockSerializedList(&_List))
        return;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;

    UnlockSerializedList(&_List);
}


BOOL
PROXY_BYPASS_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy bypass list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude = 1;

    if (_Scheme != INTERNET_SCHEME_DEFAULT) {
        schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
        requiredLength = schemeNameLength + sizeof("://") - 1;
    } else {
        schemeName = NULL;
        requiredLength = 0;
    }
    if (IsLocal()) {
        requiredLength += sizeof("<local>") - 1;
    } else {
        requiredLength += _Name.StringLength();
    }
    if (_Port != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_Port / n) {
                requiredLength += i + 1;
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        if (IsLocal()) {
            memcpy(lpszBuffer, "<local>", sizeof("<local>") - 1);
            lpszBuffer += sizeof("<local>") - 1;
        } else {
            _Name.CopyTo(lpszBuffer);
            lpszBuffer += _Name.StringLength();
        }
        if (_Port != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _Port, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_BYPASS_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy bypass specifiers and adds them to the list

Arguments:

    lpszList    - pointer to string containing list of proxy bypass specifiers.
                  The format is:

                    [<scheme>"://"][<server>][":"<port>"]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    schemeName = lpszList;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_SCHEME;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case ':':
            switch (state) {
            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    if (serverLength == 0) {
                        serverLength = 1;
                        serverName = "*";
                    }
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
                if ((serverLength == 0)
                && ((state == STATE_SERVER) || (state == STATE_PORT))) {

                    //
                    // we found e.g. "http://" or "http://:80". We allow this as
                    // "http://*" or "http://*:80"
                    //

                    serverLength = 1;
                    serverName = "*";
                }
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = schemeName;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((scheme != INTERNET_SCHEME_UNKNOWN)
                && !Find(scheme, serverName, serverLength, port)) {

                    //
                    // don't worry if Add() fails - we just continue
                    //

                    Add(scheme, serverName, serverLength, port);
                }
            }
            entryLength = 0;
            schemeName = lpszList;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_SCHEME;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::Find(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName OPTIONAL,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a proxy bypass entry matches the criteria.

    Currently, name matching is simplistic: e.g. "*.com" and "**.com" are
    treated as 2 separate strings, where we should collapse multiple wildcard
    specifiers, etc. Also: "w*" should replace "ww*", etc.

Arguments:

    tScheme             - scheme for this entry

    lpszHostName        - host name or address. May contain wildcards (*)

    dwHostNameLength    - length of host name or address

    nPort               - port

Return Value:

    BOOL
        TRUE    - an entry corresponding to the arguments was found

        FALSE   - didn't find entry

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::Find",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    BOOL isLocal = IsLocalMacro(lpszHostName, dwHostNameLength);
    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check for name match
        //

        if (info->_LocalSemantics) {
            if (isLocal) {
                found = TRUE;
                break;
            } else {
                continue;
            }
        }

        //
        // not local semantics, have to match target
        //

        //
        // BUGBUG - we only do simplistic matching. If the strings don't match
        //          exactly, except for case, they are deemed to be different
        //

        if (info->_Name.Strnicmp(lpszHostName, (int)dwHostNameLength) != 0) {
            continue;
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    info->_Name.StringAddress()
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_BYPASS_LIST::Add(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create and add a PROXY_BYPASS_LIST_ENTRY to the PROXY_BYPASS_LIST

Arguments:

    tScheme             - scheme to bypass. May be 0 meaning any protocol

    lpszHostName        - name of host to bypass. May be name or IP address and
                          may contain wildcard characters

    dwHostNameLength    - length of bypass name string

    nPort               - port to bypass. May be 0, meaning any port

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::Add",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_BYPASS_LIST_ENTRY * entry;

    entry = New PROXY_BYPASS_LIST_ENTRY(tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error = ERROR_SUCCESS;

    if (entry != NULL) {

        //
        // if the bypass entry uses local name matching semantics, then we add
        // it to the end of the list, else the head. The reason we do this is
        // to allow <local> to be a default after all other (possibly also
        // local) entries are checked
        //

        if (entry->IsLocal()) {
            if (!InsertAtTailOfSerializedList(&_List, &entry->_List)) {
                delete entry;
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            if (!InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                delete entry;
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::IsBypassed(
    IN INTERNET_HANDLE_OBJECT* pSessionObject,
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a scheme/name/port is bypassed

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    dwHostNameLength    - length of name/address part. May be 0, meaning match
                          any name/address

    nPort               - can be 0, meaning match any port

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::IsBypassed",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    INET_ASSERT(lpszHostName != NULL);
    INET_ASSERT(dwHostNameLength != 0);

    //
    // determine if what we were given is an address, in which case we don't
    // perform <local> semantics matching
    //

    BOOL isAddress = FALSE;
    LPSTR mappedName = NULL;
    LPSTR allocedName = NULL;

    if (dwHostNameLength <= MAX_IP_ADDRESS_STRING_LENGTH) {

        char addressBuffer[MAX_IP_ADDRESS_STRING_LENGTH + 1];

        //
        // make the host name/address an ASCIIZ string
        //

        memcpy((LPVOID)addressBuffer, (LPVOID)lpszHostName, dwHostNameLength);
        addressBuffer[dwHostNameLength] = '\0';
        if (_I_inet_addr(addressBuffer) != INADDR_NONE) {

            //
            // looks like we were given an IP address
            //

            //
            // maybe this is the IP address of a known server (in cache)
            //

            mappedName = MapNetAddressToName(pSessionObject, addressBuffer, &allocedName);
            if (mappedName == addressBuffer) {

                //
                // BUGBUG - transport independence?
                //

                isAddress = TRUE;
            } else {
                lpszHostName = mappedName;
                dwHostNameLength = lstrlen(lpszHostName);
            }
        }
    }

    BOOL found;
    found = IsHostInBypassList (
                tScheme,
                lpszHostName,
                dwHostNameLength,
                nPort,
                isAddress);

    if (allocedName != NULL) {

        allocedName = (LPSTR)FREE_MEMORY(allocedName);
        INET_ASSERT(allocedName == NULL);
    }

    DEBUG_LEAVE(found);
    return found;
}


BOOL
PROXY_BYPASS_LIST::IsHostInBypassList(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort,
    IN BOOL isAddress
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    tScheme             -
    lpszHostName        -
    dwHostNameLength    -
    nPort               -
    isAddress           -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_BYPASS_LIST::IsHostInBypassList",
                 "%d (%s), %.*q, %d, %d, %B",
                 tScheme,
                 InternetMapScheme(tScheme),
                 dwHostNameLength,
                 lpszHostName,
                 dwHostNameLength,
                 nPort,
                 isAddress
                 ));

    BOOL found = FALSE;

    //
    // if not an address, determine if the name contains at least one dot
    //

    BOOL isDot;

    if (!isAddress) {
        isDot = FALSE;
        for (DWORD i = 0; i < dwHostNameLength; ++i) {
            if (lpszHostName[i] == '.') {
                isDot = TRUE;
                break;
            }
        }
    } else {

        //
        // addresses have dots
        //

        isDot = TRUE;
    }

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check local semantics
        //

        if (info->_LocalSemantics) {
            if (!isDot) {

                DEBUG_PRINT(PROXY,
                            INFO,
                            ("%q matched by <local>\n",
                            lpszHostName
                            ));

                found = TRUE;

                //
                // <local> is in the bypass list and the name does not contain a
                // dot. It bypasses the proxy
                //

                break;
            } else {

                //
                // the name contains a dot, but it may be matched by another
                // proxy bypass entry
                //

                continue;
            }
        }

        //
        // check for name match. Note that we take no special action if the host
        // name contains wildcard characters
        //

        LPSTR target = info->_Name.StringAddress();

        //
        // NULL target name matches any server name/address
        //

        if (target != NULL) {

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("trying to match %q with %q\n",
                        lpszHostName,
                        target
                        ));

            DWORD i = 0;
            DWORD j = 0;
            DWORD i_back = (DWORD)-1;

            while ((target[i] != '\0') && (j < dwHostNameLength)) {
                if (target[i] == tolower(lpszHostName[j])) {
                    ++i;
                    ++j;
                } else if (target[i] == '*') {
                    while (target[i + 1] == '*') {
                        ++i;
                    }
                    i_back = i;
                    ++i;
                    while ((tolower(lpszHostName[j]) != target[i])
                    && (j < dwHostNameLength)) {
                        ++j;
                    }
                } else if (i_back != (DWORD)-1) {

                    //
                    // '*' is greedy closure. We already saw a '*' but later we
                    // discovered a mismatch. We will go back and try to eat as
                    // many characters as we can till the next match, or we hit
                    // the end of the string
                    //

                    i = i_back;
                } else {

                    //
                    // no match; quit
                    //

                    j = 0;
                    break;
                }

                //
                // if we reached the end of the target, but not the host name
                // AND we already met a '*' then back up
                //

                if ((target[i] == '\0')
                && (j != dwHostNameLength)
                && (i_back != (DWORD)-1)) {
                    i = i_back;
                }
            }

            //
            // if we hit the end of the host name while matching any character,
            // bump the target to the next non-star character
            //

            while (target[i] == '*') {
                ++i;
            }

            //
            // the host name matched if we reached the end of the target and end
            // of the host name
            //

            if (!((target[i] == '\0') && (j == dwHostNameLength))) {
                continue;
            }
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    target
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);


    //
    // "localhost", "loopback" and "127.0.0.1" always bypass proxy
    //

    if (!found)
    {
        if ((strnicmp(lpszHostName, "localhost", dwHostNameLength) == 0) ||
            (strnicmp(lpszHostName, "loopback", dwHostNameLength) == 0))
        {
            found = TRUE;
        }
        else //
             // if the host name length is of reasonable size, it may represent
             // the IP address of loopback (127.0.0.1 or its variations).
             //
             if (dwHostNameLength < 16) 
        {
            static ULONG ipAddr127_0_0_1 = INADDR_NONE;
            char         szHostName[16];

            INET_ASSERT(dwHostNameLength < 16);

            lstrcpyn(szHostName,
                lpszHostName,
                (dwHostNameLength + 1) // must add in "+1" for the NULL char
                );

            //
            // convert "127.0.0.1" to a DWORD once, and save it.
            //
            if (ipAddr127_0_0_1 == INADDR_NONE)
            {
                ipAddr127_0_0_1 = _I_inet_addr("127.0.0.1");
                INET_ASSERT(ipAddr127_0_0_1 != INADDR_NONE);
            }

            found = (_I_inet_addr(szHostName) == ipAddr127_0_0_1);
        }
    }

quit:
    DEBUG_LEAVE(found);

    return found;
}


VOID
PROXY_BYPASS_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy bypass servers to a buffer, and/or returns the
    required buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.
--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    if (!LockSerializedList(&_List))
        return;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;
    UnlockSerializedList(&_List);
}

//
// PROXY_INFO - methods are defined below
//

VOID 
PROXY_INFO::InitializeProxySettings(
    VOID
    )    

/*++

Routine Description:

    Initalizes Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    _ProxyServerList    = NULL;
    _ProxyBypassList    = NULL;
    _fDisableDirect     = FALSE;
    _fModifiedInProcess = FALSE;

    _Lock.Initialize();
    _Error = _Lock.IsInitialized()
                ? ERROR_SUCCESS
                : ERROR_WINHTTP_INTERNAL_ERROR;
}


VOID 
PROXY_INFO::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Cleans up and destroys Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    //DEBUG_ENTER((DBG_OBJECTS,
    //             None,
    //             "PROXY_INFO::TerminateProxySettings",
    //             NULL
    //             ));

    Lock(TRUE);
    CleanOutLists();
    Unlock();

    //DEBUG_LEAVE(0);
}




DWORD
PROXY_INFO::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info. Either creates new proxy server and bypass lists, or
    removes them (proxy to direct)

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE, if this object keeps a seperate set of values from those
                            stored in the registry store



Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    //
    // parameters should already be validated by caller
    //

    BOOL newList;
    BOOL possibleNewAutoProxy;
    LPCTSTR serverList;
    LPCTSTR bypassList;

    DWORD error = ERROR_SUCCESS;

    serverList = NULL;
    bypassList = NULL;
    newList = FALSE;
    _fModifiedInProcess = fModifiedInProcess;
    _dwSettingsVersion  = lpProxySettings->dwCurrentSettingsVersion;

    UPDATE_GLOBAL_PROXY_VERSION();

    if ( lpProxySettings->dwFlags & PROXY_TYPE_PROXY ) 
    {        
        serverList = lpProxySettings->lpszProxy;
        bypassList = lpProxySettings->lpszProxyBypass;

        if (serverList != NULL) {            
            newList = TRUE;
        }
    }

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    // remember disable direct flag...
    SetDisableDirect( (lpProxySettings->dwFlags & PROXY_TYPE_DIRECT) ? FALSE : TRUE  );

    //
    // clear out current contents,
    //

    CleanOutLists();

    //
    // Set the Static Proxy Lists
    //
        
    if (newList) 
    {

        INET_ASSERT((serverList != NULL) && (*serverList != 0));

        _ProxyServerList = New PROXY_SERVER_LIST(serverList);
        _ProxyBypassList = New PROXY_BYPASS_LIST(bypassList);

        if ((_ProxyServerList != NULL) && (_ProxyBypassList != NULL)) {
            _Error = _ProxyServerList->GetError();
            if (_Error == ERROR_SUCCESS) {
                _Error = _ProxyBypassList->GetError();
                if (_Error == ERROR_SUCCESS) {

                    //
                    // add all proxy servers to bypass list
                    //

                    _ProxyServerList->AddToBypassList(_ProxyBypassList);
                }
            }
        } else {
            _Error = ERROR_NOT_ENOUGH_MEMORY;
            CleanOutLists();
        }
        error = _Error;
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::GetProxySettings(
    OUT LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gets the proxy info. 

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - ignored 


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    DWORD error = ERROR_SUCCESS;

    if ( fCheckVersion == TRUE )
    {
        INET_ASSERT(FALSE);
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    if ( ! IsDisableDirect() ) {
        lpProxySettings->dwFlags |= PROXY_TYPE_DIRECT;
    }

    if ( IsProxySettingsConfigured() ) 
    {   
        lpProxySettings->dwFlags |= PROXY_TYPE_PROXY;

        lpProxySettings->lpszProxy       = _ProxyServerList->CopyString();
        lpProxySettings->lpszProxyBypass = _ProxyBypassList->CopyString();

        if ( lpProxySettings->lpszProxy == NULL || 
             lpProxySettings->lpszProxyBypass == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::RefreshProxySettings(
    IN BOOL fForceRefresh
    )
/*++

Routine Description:

    Refreshes the Proxy Information

    This doesn't make sense on PROXY_INFO, nothing done

Arguments:

    fForceRefresh - forces a resync of all settings, turning this on slows things down

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));


    DEBUG_LEAVE(ERROR_SUCCESS);
 
    return ERROR_SUCCESS;
}


DWORD
PROXY_INFO::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Determines what proxy type, proxy name, and port the caller should use
    given an Url, its length, a target host, a target port, and output space
    to store the result.

    The result may be a complete string containing a Netscape style string with
    a delimited set of proxies, and access methods.  An example of this may
    look like:
    "PROXY itgproxy:80; PROXY proxy:80; PROXY 192.168.100.2:1080; SOCKS 192.168.100.2; DIRECT"
    This means we must try itgproxy, if this proxy fails we go on to proxy, and on to 192.168.100.2, etc.
    Note that if itgproxy, proxy, and 192.168.100.2 all fail we can try a SOCKS proxy, and if this fails we
    can try a direct connection.

    If there is an external proxy DLL registered and valid, we defer to it to decide
    what proxy to use, and thus ignore internal proxy information.

    Note this function can also be used to retrive mapping of protocol to proxy.  For example,
    if tUrlProtocol == INTERNET_SCHEME_FTP, the result *lptProxyScheme == INTERNET_SCHEME_SOCKS
    which means we should use a socks proxy/firewall for FTP accesss.

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    nPort               - can be 0, meaning match any port

    pfAutoProxy         - TRUE if an auto-proxy is being used.

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::QueryProxySettings",
                 "%#X",
                 ppQueryForProxyInfo
                 ));

    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;
    INTERNET_SCHEME tProxyScheme = pQueryForProxyInfo->_tUrlProtocol;
    BOOL fIsByPassed = FALSE;
    BOOL fProxyConnect = FALSE;
    
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    if (!IsProxySettingsConfigured())  // virtual func, perhaps replace with faster internal?
    {
        fProxyConnect = FALSE;
        goto quit;
    }

    //
    // Ok, if we're here we are NOT using the Auto-Proxy DLL.
    //  1. Determine if we are Bypassed ( and thus prevented from using a proxy )
    //  2. Map the Protocol to a Proxy type.
    //  3. Grab the hostname of the proxy we wish to use.
    //

    if ( pQueryForProxyInfo->_lpszUrlHostName && pQueryForProxyInfo->_dwUrlHostNameLength > 0 )
    {
        fIsByPassed = IsBypassed(
                        pQueryForProxyInfo->_tUrlProtocol,
                        pQueryForProxyInfo->_lpszUrlHostName,
                        pQueryForProxyInfo->_dwUrlHostNameLength,
                        pQueryForProxyInfo->_nUrlPort
                        );

        if ( fIsByPassed )
        {
            goto quit;
        }
    }

    pQueryForProxyInfo->_tProxyScheme = ProxyScheme(pQueryForProxyInfo->_tUrlProtocol);

    if ( pQueryForProxyInfo->_tProxyScheme == INTERNET_SCHEME_UNKNOWN )
    {
       pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_SOCKS;
       pQueryForProxyInfo->_tUrlProtocol = INTERNET_SCHEME_SOCKS;
    }
    if (pQueryForProxyInfo->_bFreeProxyHostName
        && (pQueryForProxyInfo->_lpszProxyHostName != NULL)) {
        FREE_MEMORY(pQueryForProxyInfo->_lpszProxyHostName);
    }

    fProxyConnect = GetProxyHostName(
                        pQueryForProxyInfo->_tUrlProtocol,
                        &(pQueryForProxyInfo->_tProxyScheme),
                        &(pQueryForProxyInfo->_lpszProxyHostName),
                        &(pQueryForProxyInfo->_bFreeProxyHostName),
                        &(pQueryForProxyInfo->_dwProxyHostNameLength),
                        &(pQueryForProxyInfo->_nProxyHostPort)
                        );

quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) fProxyConnect;

    //
    // If we've disabled direct connections, then fail
    //  when there is no proxy
    //

    if ( !fProxyConnect && IsDisableDirect() ) {         
        error = ERROR_WINHTTP_CANNOT_CONNECT;
    }

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}



DWORD
PROXY_INFO::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    IMPORTANT PLEASE READ: LEGACY FUNCTION, this does not support all the new
      proxy behaviors, left here for Wininet compat with older programs

    Returns the proxy server and bypass lists in an INTERNET_PROXY_INFO. Called
    by InternetQueryOption(WINHTTP_OPTION_PROXY)

    Assumes: Access to this is serialized while we are getting this info

Arguments:

    lpBuffer            - pointer to buffer where information will be returned

    lpdwBufferLength    - IN: size of lpBuffer in BYTEs
                          OUT: number of BYTEs returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the required buffer length
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_INFO::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                *lpdwBufferLength
                ));

    DEBUG_PRINT(PROXY,
                INFO,
                ("Calling Legacy GetProxyStringInfo, NEW CODE SHOULD AVOID THIS CODE PATH\n"
                ));

    DWORD requiredSize = sizeof(WINHTTP_PROXY_INFOA);
    LPSTR lpVariable = (LPSTR)(((WINHTTP_PROXY_INFOA *)lpBuffer) + 1);
    LPSTR lpszProxy;

    Lock(FALSE);

    if (_ProxyServerList != NULL) {
        lpszProxy = lpVariable;
        _ProxyServerList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
    } else {
        lpszProxy = NULL;
    }

    LPSTR lpszProxyBypass;

    if (_ProxyBypassList != NULL) {

        DWORD size = requiredSize;

        lpszProxyBypass = lpVariable;
        _ProxyBypassList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
        if (requiredSize == size) {
            lpszProxyBypass = NULL;
        }
    } else {
        lpszProxyBypass = NULL;
    }

    DWORD error;

    if (*lpdwBufferLength >= requiredSize) {

        LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

        lpInfo->dwAccessType = (lpszProxy == NULL)
                                    ? INTERNET_OPEN_TYPE_DIRECT
                                    : INTERNET_OPEN_TYPE_PROXY;
        lpInfo->lpszProxy = lpszProxy;
        lpInfo->lpszProxyBypass = lpszProxyBypass;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredSize;

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN DWORD dwSecureStatus,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
/*++

Routine Description:

    Determines whether a connection needs to be retried do to a failed proxy.

Arguments:


    lpdwError   - Error code of connection.

    pProxyState - Pointer to proxy_state returned when acquiring the proxy information.


Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_INFO::RedoSendRequest",
                 "%#x [%d, %d], %#x",
                 lpdwError,
                 lpdwError ? *lpdwError : 0,
                 dwSecureStatus,
                 pQueryForProxyInfo
                 ));

    BOOL fReturn = FALSE;
    PROXY_STATE *pProxyState = NULL;
    DWORD dwVersion;
    LPSTR lpszConnection;
    BOOL fCanCache = FALSE;

    if ( pQueryForProxyInfo )
    {
        pProxyState = pQueryForProxyInfo->_pProxyState;

        //
        // On success,
        //

        if ( *lpdwError == ERROR_SUCCESS )
        {
            if ( pQueryForProxyInfo->IsCanCacheResult() && 
                 pProxyState &&                  
                 pOriginServer &&
                 pProxyServer )
            {
                
                pOriginServer->SetCachedProxyServerInfo(
                    pProxyServer,                    
                    pQueryForProxyInfo->GetVersion(),
                    pQueryForProxyInfo->IsUseProxy(),
                    pQueryForProxyInfo->_tUrlProtocol,
                    pQueryForProxyInfo->_nUrlPort,
                    pQueryForProxyInfo->_tProxyScheme,
                    pQueryForProxyInfo->_nProxyHostPort
                    );
            }
        }
        else if ( *lpdwError != ERROR_SUCCESS &&
                  *lpdwError != ERROR_WINHTTP_OPERATION_CANCELLED &&
                  (*lpdwError != ERROR_WINHTTP_SECURE_FAILURE ||
                   dwSecureStatus & ~(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID |
                                      WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)) &&
                  *lpdwError != ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED )
        {
            //
            // For backround detection, we need to retry
            //  waiting for the backround results to complete
            //
            // Otherwise, If we have additional proxies, 
            //  we need to retry them as well.
            //

            if ( pQueryForProxyInfo->IsBackroundDetectionPending() )
            {
                *lpdwError = ERROR_SUCCESS;
                fReturn = TRUE;
            }
            else if ( pProxyState &&
                     !pProxyState->IsEmpty() &&
                      pProxyState->IsAnotherProxyAvail() )               
            {
                INTERNET_PORT LastProxyUsedPort; 
                LPSTR lpszLastProxyUsed = pProxyState->GetLastProxyUsed(&LastProxyUsedPort);

                Lock(FALSE);

                if ( ( lpszLastProxyUsed == NULL ) ||
                     _BadProxyList.AddEntry(lpszLastProxyUsed, LastProxyUsedPort) != ERROR_SUCCESS )
                {
                    fReturn = FALSE;                    
                }
                else
                {
                    *lpdwError = ERROR_SUCCESS;
                    fReturn = TRUE;
                }

                Unlock();
            }
        }
    }

    DEBUG_LEAVE(fReturn);

    return fReturn;
}

VOID PROXY_INFO::SetSessionObject(INTERNET_HANDLE_OBJECT * pSessionObject)
{
    INET_ASSERT(pSessionObject->GetHandleType() == TypeInternetHandle);
    _pSessionObject = pSessionObject;
}


VOID
PROXY_INFO::CleanOutLists(
    VOID
    )

/*++

Routine Description:

    Delete proxy server and bypass lists if not empty

    N.B. Exclusive lock MUST be acquired before calling this method

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "PROXY_INFO::CleanOutLists",
                 NULL
                 ));

    if (_ProxyServerList != NULL) {
        delete _ProxyServerList;
        _ProxyServerList = NULL;
    }
    if (_ProxyBypassList != NULL) {
        delete _ProxyBypassList;
        _ProxyBypassList = NULL;
    }

    DEBUG_LEAVE(0);
}

//
// PROXY_INFO_GLOBAL - Global Object thats inherits and expands the basic functionality 
//   of basic PROXY_INFO behavior.  The new functionality includes wrapping Auto-Proxy
///  and Auto-detection routines
//


VOID
PROXY_INFO_GLOBAL::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Destroy PROXY_INFO_GLOBAL object

Arguments:

    None.

Return Value:

    None.

--*/

{
    PROXY_INFO::TerminateProxySettings();
}

DWORD
PROXY_INFO_GLOBAL::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE if this object is not from the registry, but 
                           a modifed setting for this process (that overrides reg values)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    DWORD error = ERROR_SUCCESS;

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    //
    // Once we're set to Modified, we're modified for the lifetime of the
    //   the process, and thus we no longer accept Registry settings
    //

    if ( IsModifiedInProcess() && 
         !fModifiedInProcess )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    if ( _lpszConnectionName != NULL ) {
        FREE_MEMORY(_lpszConnectionName);
    }

    _lpszConnectionName = lpProxySettings->lpszConnectionName ? 
                            NewString(lpProxySettings->lpszConnectionName) : 
                            NULL;

    _dwProxyFlags = lpProxySettings->dwFlags;

    //
    // Set the Static Proxy Lists
    //
        
    error = PROXY_INFO::SetProxySettings(lpProxySettings, fModifiedInProcess);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::GetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gather the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - 

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    DWORD error = ERROR_SUCCESS;

    lpProxySettings->lpszConnectionName =
                        _lpszConnectionName ? 
                            NewString(_lpszConnectionName) : 
                            NULL;

    lpProxySettings->dwFlags = _dwProxyFlags;


    //
    // Get the Static Proxy Lists
    //
        
    error = PROXY_INFO::GetProxySettings(lpProxySettings, fCheckVersion);

//quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::RefreshProxySettings(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect

Arguments:
    
    fForceRefresh - Forces a hard refresh

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));

    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    //
    // Force reload of registry settings and download of auto-proxy file from server
    //

    if ( IsRefreshDisabled())
    {
        QueueRefresh();
        goto quit;
    }


    //
    // Get the Static Proxy Lists
    //
        
    //error = PROXY_INFO::RefreshProxySettings(fForceRefresh);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}

VOID
PROXY_INFO_GLOBAL::ReleaseQueuedRefresh(
    VOID
    )
/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect,
     When InternetOpen is called, allowing async threads.

Arguments:
    
    None.

Return Value:

    None.

--*/

{
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    SetRefreshDisabled(FALSE);

    if ( _fQueuedRefresh ) 
    {
        error = RefreshProxySettings(
                    FALSE
                    );

    }

    _fQueuedRefresh = FALSE;

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();
}




DWORD
PROXY_INFO_GLOBAL::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Aquries Proxy Information.

    Note: if ppProxyState returns a non-NULL pointer than the Proxy
    strings can be assumed to be allocated pointers to strings.  Freeing
    the ppProxyState object will result in the pointers being freed as well.
    Otherwise the pointers will be to global string data that will not be
    freed unexpectedly.



Arguments:

    tUrlProtocol -  Scheme type, protocol that is being used.

    lpszUrl      -  Url being accessed.

    dwUrlLength  -  size of Url.

    lpszUrlHostName - Host name of site to connect to.

    dwUrlHostNameLength - Host name length.

    nUrlPort      - Port of server to connect to.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::QueryProxySettings",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT(ppQueryForProxyInfo);

    BOOL fReturn = FALSE;
    DWORD error = ERROR_SUCCESS;
    BOOL fNeedsGetNextProxy = FALSE;
    BOOL fLocked = FALSE;
    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;

    //
    // If we're dealing with a list of Proxies, we may have already tried one
    //  proxy and failed.  So go to the next proxy in the list
    //  and see if another one is availble to try.
    //

    if ( pQueryForProxyInfo->IsProxyEnumeration() )
    {
        fNeedsGetNextProxy = TRUE;
        goto quit;
    }

    if ( pQueryForProxyInfo->IsQueryOnCallback() &&
         ! pQueryForProxyInfo->IsAvoidAsyncCall())
    {
        goto quit;
    }

    Lock(FALSE);
    fLocked = TRUE;

    //
    // Use normal Proxy infomation stored in the registry
    //

    error = PROXY_INFO::QueryProxySettings(&pQueryForProxyInfo);

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

quit:

    if ( error == ERROR_SUCCESS &&
          ( fNeedsGetNextProxy ||
            pQueryForProxyInfo->IsProxyEnumeration())  )
    {
        error = pQueryForProxyInfo->GetNextProxy(_BadProxyList);
    }

    if ( fLocked )
    {
        Unlock();
    }

//fastquit:

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO_GLOBAL::HostBypassesProxy(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR           lpszHostName,
    IN DWORD           cchHostName
    )

/*++

Routine Description:

    Determine if request should bypass proxy for host

Arguments:

    tScheme         -
    lpszHostName    -
    cchHostName     -

Return Value:

    BOOL

--*/

{
    BOOL bReturn = FALSE;
    DWORD dwServiceType;
    BOOL bTryByPassList = TRUE;

    // Only do this if it is for a scheme wininet supports.
    if (tScheme == INTERNET_SCHEME_HTTP ||
        tScheme == INTERNET_SCHEME_HTTPS ||
        tScheme == INTERNET_SCHEME_DEFAULT)
    {
        dwServiceType = INTERNET_SERVICE_HTTP;
    }
    else
    {
        return bReturn;
    }

    // LOCK
    Lock(FALSE);

    if (bTryByPassList) {        
        bReturn = IsHostInBypassList(lpszHostName, cchHostName);
    }

    Unlock();
    return bReturn;
}

//
// PROXY_STATE - an abstraction object used to provice simple string enumeration
//   given a list of proxies that need to be tested 
// 



BOOL
PROXY_STATE::GetNextProxy(
    IN  INTERNET_SCHEME   tUrlScheme,
    IN  BAD_PROXY_LIST &  BadProxyList,
    OUT LPINTERNET_SCHEME lptProxyScheme,
    OUT LPSTR * lplpszProxyHostName,
    OUT LPBOOL lpbFreeProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyHostPort
    )

/*++

Routine Description:

    Parses the current Proxy State information to acquire the
        proxy name, port, type to use.


Arguments:

    tUrlScheme   -  Scheme type, protocol that is being used.

    BadProxyList -  Reference to array of bad proxies that we can add/remove/check
                        from.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.

    lpbFreeProxyHostName - TRUE if *lplpszProxyHostName was allocated

    lpdwProxyHostNameLength - length of lplpszProxyHostName.

    lpProxyHostPort    - Host Port of Proxy.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR lpszDelimiter = NULL;
    BOOL  fReturn       = FALSE;
    LPSTR lpszPortDelim = NULL;
    LPSTR lpszPort      = NULL;


    if ( !_fIsMultiProxyList )
    {
        *lptProxyScheme = _tProxyScheme;
        *lplpszProxyHostName = _lpszAutoProxyList;
        *lpbFreeProxyHostName = FALSE;
        *lpdwProxyHostNameLength = _dwcbAutoProxyList;
        *lpProxyHostPort  = _proxyHostPort;
    }

    _fIsAnotherProxyAvail = FALSE;

    while ( *_lpszOffset != '\0' )
    {
        LPSTR lpszNewOffset ;

        //
        // Remove the delimiter so we can see the next token.
        //  ex: PROXY foo:80; DIRECT
        //  we would find DIRECT first with strstr, if we didn't
        //  delimit first.
        //

        lpszDelimiter = strchr(_lpszOffset, ';' );

        if ( lpszDelimiter == NULL )
        {
            lpszDelimiter = strchr(_lpszOffset, ',' );
        }

        if ( lpszDelimiter )
        {
            *lpszDelimiter = '\0';
        }

        lpszNewOffset=
            strstr(_lpszOffset, "DIRECT");

        if ( lpszNewOffset )
        {
            lpszNewOffset += sizeof("DIRECT");
            _lpszOffset    = lpszNewOffset;

            //
            // FALSE means direct.
            //

            fReturn = FALSE;
            goto quit;
        }

        //
        // Its not direct, try PROXY or SOCKS.
        //

        lpszNewOffset =
            strstr(_lpszOffset, "PROXY");


        if ( lpszNewOffset)
        {
            lpszNewOffset += sizeof("PROXY");
            *lpProxyHostPort = INTERNET_DEFAULT_HTTP_PORT;

            if ( tUrlScheme == INTERNET_SCHEME_HTTPS )
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTPS;
            }
            else
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTP;

            }
        }
        else
        {
            lpszNewOffset =
                strstr(_lpszOffset, "SOCKS");

            if ( lpszNewOffset )
            {
                lpszNewOffset   += sizeof("SOCKS");
                *lptProxyScheme  = INTERNET_SCHEME_SOCKS;
                *lpProxyHostPort = INTERNET_DEFAULT_SOCKS_PORT;
            }
        }

        //
        // Now do the generic common things for SOCKS, or PROXY
        // entries, ie: get port, hostname, and hostname size.
        //

        if ( lpszNewOffset )
        {
            _lpszOffset    = lpszNewOffset;

            SKIPWS(_lpszOffset);

            *lplpszProxyHostName = _lpszOffset;
            *lpbFreeProxyHostName = FALSE;

            lpszPortDelim = strchr(_lpszOffset, ':');

            if ( lpszPortDelim )
            {
                *lpszPortDelim = '\0';
                lpszPort  = lpszPortDelim+1;

                *lpProxyHostPort = (INTERNET_PORT)
                    atoi(lpszPort);
            }

            *lpdwProxyHostNameLength = lstrlen(_lpszOffset);

            if (BadProxyList.IsBadProxyName(*lplpszProxyHostName, *lpProxyHostPort))
            {
                if ( lpszDelimiter )
                {
                    _lpszOffset = (lpszDelimiter+1);
                }
                else
                {
                    _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
                }

                continue;
            }

            fReturn = TRUE;
        }

        break;
    }

quit:

    //if ( lpszPortDelim )
    //{
    //    *lpszPortDelim = ':';
    //}

    if ( lpszDelimiter )
    {
        *lpszDelimiter = ';';

        _lpszOffset = (lpszDelimiter+1);
    }
    else
    {
        _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
    }

    if ( fReturn )
    {
        _lpszLastProxyUsed = *lplpszProxyHostName;
        _LastProxyUsedPort = *lpProxyHostPort;

        //
        // If theres another possible proxy in this list,
        //   then we'll need to remember that
        //

        if ( _lpszOffset &&
             *_lpszOffset &&
                (strstr(_lpszOffset, "PROXY") ||
                 strstr(_lpszOffset, "DIRECT") ||  
                 strstr(_lpszOffset, "SOCKS"))
            )
        {
            _fIsAnotherProxyAvail = TRUE;
        }
    }

    return fReturn;
}



#ifndef WININET_SERVER_CORE

PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    )

/*++

Routine Description:

    Reads a string from the registry into a buffer, then shrinks the buffer

Arguments:

    lpszParameterName   - name of string to retrieve

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR buffer = NULL;
    DWORD length = PROXY_REGISTRY_STRING_LENGTH;
    BOOL done = FALSE;

    do {
        buffer = (LPSTR)ResizeBuffer(buffer, length, FALSE);
        if (done || (buffer == NULL)) {
            break;
        }

        DWORD error;

        error = InternetReadRegistryString(lpszParameterName, buffer, &length);
        length = (error == ERROR_SUCCESS) ? ((length == 0) ? 0 : (length + 1)) : 0;
        done = TRUE;
    } while (TRUE);

    return buffer;
}
#endif //!WININET_SERVER_CORE



//
// wrapper function for urlzones.
//

BOOLAPI IsHostInProxyBypassList (INTERNET_SCHEME tScheme, LPCSTR pszHost, DWORD cchHost)
{
    BOOL    fRet = FALSE;

    if (!GlobalDataInitialized) {
        GlobalDataInitialize();
    }

    if(ERROR_SUCCESS == LoadWinsock())
    {
        fRet = g_pGlobalProxyInfo->HostBypassesProxy(tScheme, (LPSTR)pszHost, cchHost);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\hdrbuf.cxx ===
#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

#include <wininetp.h>

#define DATE_AND_TIME_STRING_BUFFER_LENGTH  128

PRIVATE
BOOL
FMatchList(
    LPSTR *lplpList,
    DWORD cListLen,
    HEADER_STRING *lpHeader,
    LPSTR    lpBase
    )
{
    DWORD i;
    for (i=0; i < cListLen; ++i) {
       if (!lpHeader->Strnicmp(lpBase, lplpList[i], strlen(lplpList[i]))) {
          return (TRUE);
       }
    }
    return(FALSE);
}


DWORD
FASTCALL
CalculateHashNoCase(
    IN LPCSTR lpszString,
    IN DWORD dwStringLength
    )

/*++

Routine Description:

    Calculate a case-insensitive hash number given a string. Assumes input is
    7-bit ASCII

Arguments:

    lpszString      - string to hash

    dwStringLength  - length of lpszString, or -1 if we need to calculate

Return Value:

    DWORD - a generated hash value

--*/

{
    DWORD dwHash = HEADER_HASH_SEED;

    while (dwStringLength != 0) {
        CHAR ch = *lpszString;

        if ((ch >= 'A') && (ch <= 'Z')) {
            ch = MAKE_LOWER(ch);
        }
        dwHash += (DWORD)(dwHash << 5) + ch; /*+ *pszName++;*/

        ++lpszString;
        --dwStringLength;
    }
    return dwHash;
}

//
// methods
//



DWORD
HTTP_HEADERS::AllocateHeaders(
    IN DWORD dwNumberOfHeaders
    )

/*++

Routine Description:

    Allocates or grows the array of header pointers (HEADER_STRING objects)

Arguments:

    dwNumberOfHeaders   - number of additional header slots to create

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AllocateHeaders",
                 "%d",
                 dwNumberOfHeaders
                 ));

    PERF_ENTER(AllocateHeaders);

    //
    // we really need to be able to realloc an array of HEADER_STRING objects
    // (see below)
    //

    DWORD error;
    DWORD slots = _TotalSlots;


    if ( (_TotalSlots + dwNumberOfHeaders) >  (INVALID_HEADER_INDEX-1))
    {
        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    _lpHeaders = (HEADER_STRING *)ResizeBuffer((HLOCAL)_lpHeaders,
                                               (_TotalSlots + dwNumberOfHeaders)
                                                    * sizeof(HEADER_STRING),
                                               FALSE // not moveable
                                               );
    if (_lpHeaders != NULL) {
        _NextOpenSlot = _TotalSlots;
        _TotalSlots += dwNumberOfHeaders;
        _FreeSlots += dwNumberOfHeaders;

        //
        // this is slightly ugly, but it seems there's no easy C++ way to
        // do this - we need to be able to realloc() an array of objects
        // created by new(), but so far, it can't be done
        //

        for (; slots < _TotalSlots; ++slots) {
            _lpHeaders[slots].Clear();
        }
        error = ERROR_SUCCESS;
    } else {

        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    INET_ASSERT(_FreeSlots <= _TotalSlots);

    PERF_LEAVE(AllocateHeaders);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::FreeHeaders(
    VOID
    )

/*++

Routine Description:

    Free the headers strings and the headers array

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "FreeHeaders",
                 NULL
                 ));

    if (!LockHeaders())
    {
        goto quit;
    }

    //
    // free up each individual entry (free string buffers)
    //

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        _lpHeaders[i] = (LPSTR)NULL;
    }

    //
    // followed by the array itself
    //

    if (_lpHeaders) {
        _lpHeaders = (HEADER_STRING *)FREE_MEMORY((HLOCAL)_lpHeaders);

        INET_ASSERT(_lpHeaders == NULL);
    }

    _TotalSlots = 0;
    _FreeSlots = 0;
    _HeadersLength = 0;
    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    UnlockHeaders();

quit:
    DEBUG_LEAVE(0);
}


DWORD
HTTP_HEADERS::CopyHeaders(
    IN OUT LPSTR * lpBuffer,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength
    )

/*++

Routine Description:

    Copy the headers to the caller's buffer. Each header is terminated by CR-LF.
    This method is called to convert the request headers list to a buffer that
    we can send to the server

    N.B. This function MUST be called with the headers already locked

Arguments:

    lpBuffer            - pointer to pointer to buffer where headers are
                          written. We update the pointer

    lpszObjectName      - optional object name

    dwObjectNameLength  - optional object name length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory while trying to synchronize src data access

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "CopyHeaders",
                 "%#x, %#x [%q], %d",
                 lpBuffer,
                 lpszObjectName,
                 lpszObjectName,
                 dwObjectNameLength
                 ));

    DWORD dwError = ERROR_SUCCESS;
    if (!LockHeaders())
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    DWORD i = 0;

    if (lpszObjectName != NULL) {
        memcpy(*lpBuffer, _lpszVerb, _dwVerbLength);
        *lpBuffer += _dwVerbLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, lpszObjectName, dwObjectNameLength);
        *lpBuffer += dwObjectNameLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, _lpszVersion, _dwVersionLength);
        *lpBuffer += _dwVersionLength;
        *(*lpBuffer)++ = '\r';
        *(*lpBuffer)++ = '\n';
        i = 1;
    }
    for (; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {
            _lpHeaders[i].CopyTo(*lpBuffer);
            *lpBuffer += _lpHeaders[i].StringLength();
            *(*lpBuffer)++ = '\r';
            *(*lpBuffer)++ = '\n';
        }
    }

    UnlockHeaders();

quit:
    DEBUG_LEAVE(dwError);

    return dwError;
}


HEADER_STRING *
FASTCALL
HTTP_HEADERS::FindFreeSlot(
    DWORD* piSlot
    )

/*++

Routine Description:

    Finds the next free slot in the headers list, or adds some new slots

    N.B. This function MUST be called with the headers already locked

Arguments:

    piSlot: returns index of slot found

Return Value:

    HEADER_STRING *  - pointer to next free slot

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "FindFreeSlot",
                 NULL
                 ));

    PERF_ENTER(FindFreeSlot);

    DWORD i;
    DWORD error;
    HEADER_STRING * header = NULL;

    //
    // if there are no free slots, allocate some more
    //

    if (_FreeSlots == 0) {
        i = _TotalSlots;
        error = AllocateHeaders(HEADERS_INCREMENT);
    } else {
        i = 0;
        error = ERROR_SUCCESS;
        if (!_lpHeaders[_NextOpenSlot].HaveString())
        {
            --_FreeSlots;
            header = &_lpHeaders[_NextOpenSlot];
            *piSlot = _NextOpenSlot;
            _NextOpenSlot = (_NextOpenSlot == (_TotalSlots-1)) ? (_TotalSlots-1) : _NextOpenSlot++;
            goto quit;
        }
    }
    if (error == ERROR_SUCCESS) {
        for (; i < _TotalSlots; ++i) {
            if (!_lpHeaders[i].HaveString()) {
                --_FreeSlots;
                header = &_lpHeaders[i];
                *piSlot = i;
                _NextOpenSlot = (i == (_TotalSlots-1)) ? (_TotalSlots-1) : (i+1);
                break;
            }
        }
        if (header == NULL) {

            //
            // we would have just allocated extra slots if we didn't have
            // any, so we shouldn't be here
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    }

quit:
    _Error = error;

    PERF_LEAVE(FindFreeSlot);

    DEBUG_LEAVE(header);

    return header;
}


VOID
HTTP_HEADERS::ShrinkHeader(
    IN LPBYTE pbBase,
    IN DWORD  iSlot,
    IN DWORD  dwOldQueryIndex,
    IN DWORD  dwNewQueryIndex,
    IN DWORD  cbNewSize
    )

/*++

Routine Description:

    Low level function that does a surgical replace of one header with another.
    This code updates internal structures such as bKnownHeaders and the stored
    hash value for the new Header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    None.

--*/

{
    HEADER_STRING* pHeader = _lpHeaders + iSlot;

    INET_ASSERT(_bKnownHeaders[dwOldQueryIndex] == (BYTE) iSlot ||
                dwNewQueryIndex == dwOldQueryIndex );

    //
    // Swap in the new header.  Update Length, Hash, and its cached position
    //  in the known header array.
    //

    _bKnownHeaders[dwOldQueryIndex] = INVALID_HEADER_INDEX;
    _bKnownHeaders[dwNewQueryIndex] = (BYTE) iSlot;

    pHeader->SetLength (cbNewSize);
    pHeader->SetHash (GlobalKnownHeaders[dwNewQueryIndex].HashVal);
}

DWORD
inline
HTTP_HEADERS::SlowFind(
    IN LPSTR lpBase,
    IN LPCSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwIndex,
    IN DWORD dwHash,
    OUT DWORD *lpdwQueryIndex,
    OUT BYTE  **lplpbPrevIndex
    )

/*++

Routine Description:

    Finds the next occurance of lpszHeaderName in the header array, uses
    a cached table of well known headers to accerlate the search if the
    string is a known header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{

    //
    // Now see if this is a known header passed in as a string,
    //   If it is, we save ourselves the loop, and just map it right in to a known header
    //

    DWORD dwKnownQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    *lpdwQueryIndex = INVALID_HEADER_SLOT;

    if ( dwKnownQueryIndex != 0 )
    {
        dwKnownQueryIndex--;

        if ( ((int)dwHeaderNameLength >= GlobalKnownHeaders[dwKnownQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[dwKnownQueryIndex].Text,
                      GlobalKnownHeaders[dwKnownQueryIndex].Length) == 0)
        {
            *lpdwQueryIndex = dwKnownQueryIndex;

            INET_ASSERT((int)(dwHeaderNameLength) == GlobalKnownHeaders[dwKnownQueryIndex].Length);

            if ( lplpbPrevIndex )
            {
                return FastNukeFind(
                        dwKnownQueryIndex,
                        dwIndex,
                        lplpbPrevIndex
                        );
            }
            else
            {
                return FastFind(
                        dwKnownQueryIndex,
                        dwIndex
                        );
            }
        }
    }

    //
    // Otherwise we painfully enumerate the whole array of headers
    //

    for (DWORD i = 0; i < _TotalSlots; ++i)
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[i];

        if (!pString->HaveString()) {
            continue;
        }

        if (pString->HashStrnicmp(lpBase,
                                  lpszHeaderName,
                                  dwHeaderNameLength,
                                  dwHash) == 0)
        {

            //
            // if we haven't reached the required index yet, continue
            //

            if (dwIndex != 0) {
                --dwIndex;
                continue;
            }

            return i; // found index/slot
        }
    }

    return INVALID_HEADER_SLOT; // not found
}


DWORD
inline
HTTP_HEADERS::FastFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    DWORD dwSlot;

    dwSlot = _bKnownHeaders[dwQueryIndex];

    while ( (dwIndex > 0) && (dwSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[dwSlot];
        dwSlot  = pString->GetNextKnownIndex();

        dwIndex--;
    }

    if ( dwSlot >= INVALID_HEADER_INDEX)
    {
        return INVALID_HEADER_SLOT;
    }

    return dwSlot; // found it.
}


DWORD
inline
HTTP_HEADERS::FastNukeFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex,
    OUT BYTE **lplpbPrevIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.
    Also provides a ptr to ptr to the slot which directs us to the one found.
    This is needed for deletion purposes.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    BYTE *lpbSlot;

    *lplpbPrevIndex = lpbSlot = &_bKnownHeaders[dwQueryIndex];
    dwIndex++;

    while ( (dwIndex > 0) && (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[*lpbSlot];
        *lplpbPrevIndex = lpbSlot;
        lpbSlot  = pString->GetNextKnownIndexPtr();

        dwIndex--;
    }

    if ( **lplpbPrevIndex >= INVALID_HEADER_INDEX ||
         dwIndex > 0 )
    {
        return INVALID_HEADER_SLOT;
    }

    return ((DWORD) **lplpbPrevIndex); // found it.
}

VOID
HTTP_HEADERS::RemoveAllByIndex(
    IN DWORD dwQueryIndex
    )
/*++

Routine Description:

    Removes all Known Headers found in the header array.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

Return Value:

    None.

--*/


{
    BYTE bSlot;
    BYTE bPrevSlot;

    bSlot = bPrevSlot  = _bKnownHeaders[dwQueryIndex];

    while (bSlot < INVALID_HEADER_INDEX)
    {
        HEADER_STRING * pString;

        bPrevSlot   = bSlot;
        pString     = &_lpHeaders[bSlot];
        bSlot       = (BYTE) pString->GetNextKnownIndex();

        RemoveHeader(bPrevSlot, dwQueryIndex, &_bKnownHeaders[dwQueryIndex]);
    }

    _bKnownHeaders[dwQueryIndex] = INVALID_HEADER_INDEX;

    return;
}


BOOL
inline
HTTP_HEADERS::HeaderMatch(
    IN DWORD dwHash,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    OUT DWORD *lpdwQueryIndex
    )

/*++

Routine Description:

    Looks up a Known HTTP header string using its Hash value and
     string contained the name of the header.

Arguments:

    dwHash              - Hash value of header name string

    lpszHeaderName      - name of header we are matching

    dwHeaderNameLength  - length of header name string

    lpdwQueryIndex      - If found, this is the HTTP_QUERY_* based index to the header.

Return Value:

    BOOL
        Success - The string and hash matched againsted a known header

        Failure - There is no known header for that hash & string pair.

--*/

{
    *lpdwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    if ( *lpdwQueryIndex != 0 )
    {
        (*lpdwQueryIndex)--;

        if ( ((int)dwHeaderNameLength == GlobalKnownHeaders[*lpdwQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[*lpdwQueryIndex].Text,
                      GlobalKnownHeaders[*lpdwQueryIndex].Length) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BYTE
inline
HTTP_HEADERS::FastAdd(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwSlot
    )
/*++

Routine Description:

    Rapidly adds a known string to the header array, this function
     is used to matain coherency of the _bKnownHeaders which
     contained indexed offsets into the header array for known headers.

    Note that this function is used instead of latter listed below
     in order to maintain proper order in headers received.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

    dwSlot - Slot in which this header is being added.

Return Value:

    None.

--*/


{
    BYTE *lpbSlot;

    lpbSlot = &_bKnownHeaders[dwQueryIndex];

    while ( (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString  = &_lpHeaders[*lpbSlot];
        lpbSlot  = pString->GetNextKnownIndexPtr();
    }

    INET_ASSERT(*lpbSlot == INVALID_HEADER_INDEX);

    *lpbSlot = (BYTE) dwSlot;
    return INVALID_HEADER_INDEX;
}


//BYTE
//inline
//HTTP_HEADERS::FastAdd(
//    IN DWORD  dwQueryIndex,
//    IN DWORD  dwSlot
//    )
//{
//    BYTE bOldSlot;
//
//    bOldSlot = _bKnownHeaders[dwQueryIndex];
//    _bKnownHeaders[dwQueryIndex] = (BYTE) dwSlot;
//
//    return bOldSlot;
//}




DWORD
HTTP_HEADERS::AddHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    lpszHeaderName      - pointer to name of header to add, e.g. "Accept:"

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(*lpszHeaderName != '\0');
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderValue != NULL);
    INET_ASSERT(*lpszHeaderValue != '\0');
    INET_ASSERT(dwHeaderValueLength != 0);
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    //
    // we may have been handed a header with a trailing colon. We don't care
    // for such nasty imagery
    //

    if (lpszHeaderName[dwHeaderNameLength - 1] == ':') {
        --dwHeaderNameLength;
    }

    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    DWORD i = 0;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = SlowFind(
                    NULL,
                    lpszHeaderName,
                    dwHeaderNameLength,
                    dwIndex,
                    dwHash,
                    &dwQueryIndex,
                    NULL
                    );

        if (dwSlot != ((DWORD) -1))
        {

            HEADER_STRING * pString;

            pString = &_lpHeaders[dwSlot];

            //
            // found what we are looking for. Coalesce it
            //

            pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

            pString->Strncat(
                             (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                 "; " :
                                 ", ",
                              2);

            pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
            _HeadersLength += 2 + dwHeaderValueLength;
            error = ERROR_SUCCESS;

        }
    }
    else
    {

        //
        // Check to verify that the header we're adding is a known header,
        //   If its a known header we use dwQueryIndex to update the known header array
        //   otherwise, IF ITS NOT, we make sure to set dwQueryIndex to INVALID_...
        //

        if (! HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwQueryIndex) )
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }

        /*
        // Perhaps this more efficent ???
        dwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

        if ( dwQueryIndex != 0 )
        {
            dwQueryIndex--;

            if ( ((int)dwHeaderNameLength < GlobalKnownHeaders[dwQueryIndex].Length) ||
                 strnicmp(lpszHeaderName,
                          GlobalKnownHeaders[dwQueryIndex].Text,
                          GlobalKnownHeaders[dwQueryIndex].Length) != 0)
            {
                dwQueryIndex = INVALID_HEADER_SLOT;
            }
        }
        else
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }
        */
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto Cleanup;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto Cleanup;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);

        if ( dwQueryIndex != INVALID_HEADER_SLOT )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));
        }

        error = ERROR_SUCCESS;
    }

Cleanup:
    UnlockHeaders();

quit:
    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::AddHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    INET_ASSERT(dwQueryIndex <= HTTP_QUERY_MAX);
    INET_ASSERT(lpszHeaderValue != NULL);
    INET_ASSERT(*lpszHeaderValue != '\0');
    INET_ASSERT(dwHeaderValueLength != 0);
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD i = 0;
    LPSTR lpszHeaderName;
    DWORD dwHeaderNameLength;
    DWORD dwHash;

    dwHash             = GlobalKnownHeaders[dwQueryIndex].HashVal;
    lpszHeaderName     = GlobalKnownHeaders[dwQueryIndex].Text;
    dwHeaderNameLength = GlobalKnownHeaders[dwQueryIndex].Length;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = FastFind(
                    dwQueryIndex,
                    dwIndex
                    );

        if (dwSlot != INVALID_HEADER_SLOT)
        {

            HEADER_STRING * pString;

            pString = &_lpHeaders[dwSlot];

            //
            // found what we are looking for. Coalesce it
            //

            pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

            pString->Strncat(
                             (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                 "; " :
                                 ", ",
                              2);

            pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
            _HeadersLength += 2 + dwHeaderValueLength;
            error = ERROR_SUCCESS;

        }
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);
        freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));

        error = ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderName      - pointer to the header name

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to the header value

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderName[dwHeaderNameLength - 1] != ':');

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);
    DWORD dwSlot;
    DWORD dwQueryIndex;
    BYTE *pbPrevByte;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = SlowFind(
                NULL,
                lpszHeaderName,
                dwHeaderNameLength,
                dwIndex,
                dwHash,
                &dwQueryIndex,
                &pbPrevByte
                );

    if ( dwSlot != ((DWORD) -1))
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto Cleanup;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            if ( dwQueryIndex != ((DWORD) -1) )
            {
                error = AddHeader(dwQueryIndex,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }
            else
            {
                error = AddHeader(lpszHeaderName,
                                  dwHeaderNameLength,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }


        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        if ( dwQueryIndex != ((DWORD) -1) )
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        }
        else
        {
            error = AddHeader(lpszHeaderName,
                              dwHeaderNameLength,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );

        }
    }

Cleanup:

    UnlockHeaders();

quit:
    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderValue     - pointer to the header value

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    BYTE *pbPrevByte;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = FastNukeFind(
                dwQueryIndex,
                dwIndex,
                &pbPrevByte
                );

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto Cleanup;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        error = AddHeader(dwQueryIndex,
                          lpszHeaderValue,
                          dwHeaderValueLength,
                          0,
                          dwFlags
                          );
    }

Cleanup:

    UnlockHeaders();

quit:
    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN LPCSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Finds a request or response header

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FindHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));


    PERF_ENTER(FindHeader);



    INET_ASSERT(lpdwIndex != NULL);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    HEADER_STRING * pString;
    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = SlowFind(
                lpBase,
                lpszHeaderName,
                dwHeaderNameLength,
                *lpdwIndex,
                dwHash,
                &dwQueryIndex,
                NULL
                );

    if ( dwSlot != ((DWORD) -1) )
    {
        pString = &_lpHeaders[dwSlot];

        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        stringLen = pString->StringLength();

        INET_ASSERT(stringLen > dwHeaderNameLength);

        //
        // get a pointer to the value string
        //

        value = pString->StringAddress(lpBase) + dwHeaderNameLength;
        stringLen -= dwHeaderNameLength;

        //
        // the input string could be a substring of a different header
        //

        //INET_ASSERT(*value != ':');

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        do {
            ++value;
            --stringLen;
        } while ((stringLen > 0) && (*value == ' '));

        //
        // get the data in the format requested by the app
        //

        LPVOID lpData;
        DWORD dwDataSize;
        DWORD dwRequiredSize;
        SYSTEMTIME systemTime;
        DWORD number;

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME) {

            char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

            if (stringLen < sizeof(buf)) {

                //
                // value probably does not point at a zero-terminated string
                // which HttpDateToSystemTime() expects, so we make a copy
                // and terminate it
                //

                memcpy((LPVOID)buf, (LPVOID)value, stringLen);
                buf[stringLen] = '\0';
                if (HttpDateToSystemTime(buf, &systemTime)) {
                    lpData = (LPVOID)&systemTime;
                    dwRequiredSize = dwDataSize = sizeof(systemTime);
                } else {

                    //
                    // couldn't convert date/time. Presume header must be bogus
                    //

                    error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                    DEBUG_PRINT(HTTP,
                                ERROR,
                                ("cannot convert %.40q to SYSTEMTIME\n",
                                value
                                ));

                }
            } else {

                //
                // we would break the date/time buffer!
                //

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        } else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
            if (isdigit(*value)) {
                number = 0;
                for (int i = 0;
                    (stringLen > 0) && isdigit(value[i]);
                    ++i, --stringLen) {

                    number = number * 10 + (DWORD)(value[i] - '0');
                }
                lpData = (LPVOID)&number;
                dwRequiredSize = dwDataSize = sizeof(number);
            } else {

                //
                // not a numeric field. Request must be bogus for this header
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.20q to NUMBER\n",
                            value
                            ));

            }
        } else {
            lpData = (LPVOID)value;
            dwDataSize = stringLen;
            dwRequiredSize = dwDataSize + 1;
        }

        //
        // if error == ERROR_SUCCESS then we can attempt to copy the data
        //

        if (error == ERROR_SUCCESS) {
            if (*lpdwBufferLength < dwRequiredSize) {
                *lpdwBufferLength = dwRequiredSize;
                error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                memcpy(lpBuffer, lpData, dwDataSize);
                *lpdwBufferLength = dwDataSize;

                //
                // if dwRequiredSize > dwDataSize, then this is a variable-
                // length item (i.e. a STRING!) so we add a terminating '\0'
                //

                if (dwRequiredSize > dwDataSize) {

                    INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                    ((LPSTR)lpBuffer)[dwDataSize] = '\0';
                }

                //
                // successfully retrieved the requested header - bump the
                // index
                //

                ++*lpdwIndex;
            }
        }
    }

    UnlockHeaders();

quit:
    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )
/*++

Routine Description:

    Finds a request or response header, based on index to the header name we are searching for.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/
{

    DWORD error;
    LPSTR lpData;
    DWORD dwDataSize = 0;
    DWORD dwRequiredSize;
    SYSTEMTIME systemTime;
    DWORD number;

    error = FastFindHeader(
                lpBase,
                dwQueryIndex,
                (LPVOID *)&lpData,
                &dwDataSize,
                *lpdwIndex
                );

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    //
    // get the data in the format requested by the app
    //

    if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME)
    {
        char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

        if (dwDataSize < sizeof(buf))
        {

            //
            // value probably does not point at a zero-terminated string
            // which HttpDateToSystemTime() expects, so we make a copy
            // and terminate it
            //

            memcpy((LPVOID)buf, (LPVOID)lpData, dwDataSize);
            buf[dwDataSize] = '\0';
            if (HttpDateToSystemTime(buf, &systemTime)) {
                lpData = (LPSTR)&systemTime;
                dwRequiredSize = dwDataSize = sizeof(systemTime);
            } else {

                //
                // couldn't convert date/time. Presume header must be bogus
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.40q to SYSTEMTIME\n",
                            lpData
                            ));

            }
        }
        else
        {

            //
            // we would break the date/time buffer!
            //

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    }
    else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER)
    {
        if (isdigit(*lpData)) {
            number = 0;
            for (int i = 0;
                (dwDataSize > 0) && isdigit(lpData[i]);
                ++i, --dwDataSize) {

                number = number * 10 + (DWORD)(lpData[i] - '0');
            }
            lpData = (LPSTR)&number;
            dwRequiredSize = dwDataSize = sizeof(number);
        } else {

            //
            // not a numeric field. Request must be bogus for this header
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("cannot convert %.20q to NUMBER\n",
                        lpData
                        ));

        }
    }
    else
    {
        dwRequiredSize = dwDataSize + 1;
    }

    //
    // if error == ERROR_SUCCESS then we can attempt to copy the data
    //

    if (error == ERROR_SUCCESS)
    {
        if (*lpdwBufferLength < dwRequiredSize)
        {
            *lpdwBufferLength = dwRequiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            memcpy(lpBuffer, lpData, dwDataSize);
            *lpdwBufferLength = dwDataSize;

            //
            // if dwRequiredSize > dwDataSize, then this is a variable-
            // length item (i.e. a STRING!) so we add a terminating '\0'
            //

            if (dwRequiredSize > dwDataSize)
            {
                INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                ((LPSTR)lpBuffer)[dwDataSize] = '\0';
            }

            //
            // successfully retrieved the requested header - bump the
            // index
            //

            ++*lpdwIndex;
        }
    }
quit:

    return error;
}



DWORD
HTTP_HEADERS::FastFindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    OUT LPVOID *lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Finds a request or response header slightly quicker than its higher level
     cousin, FindHeader.   Unlike FindHeader this function simply returns
     a pointer and length, and does not copy header data.


    lpBase              - base address of strings

    dwQueryIndex        - a index into a array known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lplpBuffer          - pointer to pointer of the actual header to be returned in.

    lpdwBufferLength    - OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

    dwIndex             - a index of which header we're asking for, as there can be multiple headers
                          under the same name.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FastFindHeader",
                 "%q, %#x, %#x [%#x], %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwIndex
                 ));

    PERF_ENTER(FindHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    HEADER_STRING * curHeader;
    DWORD dwSlot;

    dwSlot = FastFind(dwQueryIndex, dwIndex);

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        curHeader = GetSlot(dwSlot);

        //
        // get a pointer to the value string
        //

        value     = curHeader->StringAddress(lpBase) + (GlobalKnownHeaders[dwQueryIndex].Length+1);
        stringLen = curHeader->StringLength() - (GlobalKnownHeaders[dwQueryIndex].Length+1);

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        while ((stringLen > 0) && (*value == ' '))
        {
            ++value;
            --stringLen;
        }

        //
        // get the data in the format requested by the app
        //

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        *lplpBuffer = (LPVOID)value;
        *lpdwBufferLength = stringLen;
    }

    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::QueryRawHeaders(
    IN LPSTR lpBase,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock
--*/

{
    PERF_ENTER(QueryRawHeaders);

    DWORD error = ERROR_SUCCESS;
    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {

            DWORD length;

            length = _lpHeaders[i].StringLength();

            requiredLength += length + (bCrLfTerminated ? 2 : 1);
            if (*lpdwBufferLength > requiredLength) {
                _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                lpszBuffer += length;
                if (bCrLfTerminated) {
                    *lpszBuffer++ = '\r';
                    *lpszBuffer++ = '\n';
                } else {
                    *lpszBuffer++ = '\0';
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    UnlockHeaders();

    ++requiredLength;

    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
    }
    *lpdwBufferLength = requiredLength;

quit:
    PERF_LEAVE(QueryRawHeaders);

    return error;
}


DWORD
HTTP_HEADERS::QueryFilteredRawHeaders(
    IN LPSTR lpBase,
    IN LPSTR *lplpFilterList,
    IN DWORD cListElements,
    IN BOOL  fExclude,
    IN BOOL  fSkipVerb,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error = ERROR_NOT_SUPPORTED;

    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;
    BOOL fCopy;

    DWORD i = fSkipVerb ? 1 : 0;
    for (; i < _TotalSlots; ++i) {
       if (_lpHeaders[i].HaveString()) {
          fCopy = TRUE;
          if (lplpFilterList
             && FMatchList(lplpFilterList, cListElements, _lpHeaders+i, lpBase)) {
             fCopy = fExclude?FALSE:TRUE;
          }
          if (fCopy) {
              DWORD length;

              length = _lpHeaders[i].StringLength();
              requiredLength += length + (bCrLfTerminated ? 2 : 1);
              if (*lpdwBufferLength > requiredLength) {
                    _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                   lpszBuffer += length;
                   if (bCrLfTerminated) {
                       *lpszBuffer++ = '\r';
                       *lpszBuffer++ = '\n';
                    } else {
                       *lpszBuffer++ = '\0';
                   }
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    ++requiredLength;


    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
        error = ERROR_SUCCESS;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
HTTP_HEADERS::AddRequest(
    IN LPSTR lpszVerb,
    IN LPSTR lpszObject,
    IN LPSTR lpszVersion
    )

/*++

Routine Description:

    Builds the request line from its constituent parts. The request line is the
    first (0th) header in the request headers

    Assumes:    1. This is the one-and-only call to this method
                2. lpszObject must already be escaped if necessary

Arguments:

    lpszVerb    - pointer to HTTP verb, e.g. "GET"

    lpszObject  - pointer to HTTP object name, e.g. "/users/albert/~emc2.htm".

    lpszVersion - pointer to HTTP version string, e.g. "HTTP/1.0"

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    PERF_ENTER(AddRequest);

    //
    // there must not be a header when this method is called
    //

    INET_ASSERT(_HeadersLength == 0);

    DWORD error = ERROR_SUCCESS;
    int verbLen = lstrlen(lpszVerb);
    int objectLen = lstrlen(lpszObject);
    int versionLen = lstrlen(lpszVersion);
    int len = verbLen       // "GET"
            + 1             //     ' '
            + objectLen     //        "/users/albert/~emc2.htm"
            + 1             //                                 ' '
            + versionLen    //                                    "HTTP/1.0"
            + 1             //                                              '\0'
            ;

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(!request.HaveString());

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    request.CreateStringBuffer((LPVOID)lpszVerb, verbLen, len);
    if (request.IsError()) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {
        request += ' ';
        request.Strncat((LPVOID)lpszObject, objectLen);
        request += ' ';
        request.Strncat((LPVOID)lpszVersion, versionLen);

        _HeadersLength = len - 1 + (sizeof("\r\n") - 1);

        //
        // we have used the first free slot in the headers array
        //

        --_FreeSlots;

        //
        // update the component variables in case of a ModifyRequest()
        //

        _lpszVerb = request.StringAddress();
        _dwVerbLength = verbLen;
        _lpszObjectName = _lpszVerb + verbLen + 1;
        _dwObjectNameLength = objectLen;
        _lpszVersion = _lpszObjectName + objectLen + 1;
        _dwVersionLength = versionLen;
        SetRequestVersion();
        error = request.IsError() ? ::GetLastError() : ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddRequest);

    return error;
}


DWORD
HTTP_HEADERS::ModifyRequest(
    IN HTTP_METHOD_TYPE tMethod,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength,
    IN LPSTR lpszVersion OPTIONAL,
    IN DWORD dwVersionLength
    )

/*++

Routine Description:

    Updates the request line. Used in redirection

Arguments:

    tMethod             - type of new method

    lpszObjectName      - pointer to new object name

    dwObjectNameLength  - length of new object name

    lpszVersion         - optional pointer to version string

    dwVersionLength     - length of lpszVersion string if present

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ModifyRequest",
                 "%s, %q, %d, %q, %d",
                 MapHttpMethodType(tMethod),
                 lpszObjectName,
                 dwObjectNameLength,
                 lpszVersion,
                 dwVersionLength
                 ));

    PERF_ENTER(ModifyRequest);

    INET_ASSERT(lpszObjectName != NULL);
    INET_ASSERT(dwObjectNameLength != 0);

    //
    // there must already be a header when this method is called
    //

    INET_ASSERT(_HeadersLength != 0);

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    //
    // BUGBUG [arthurbi] using two HEADER_STRINGs here causes an extra
    //  ReAlloc when use the Copy operator between the two.
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;
    HEADER_STRING newRequest;
    LPCSTR lpcszVerb;
    DWORD verbLength;
    DWORD error = ERROR_SUCCESS;
    DWORD length;

    //
    // there must already be a request line
    //

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(request.HaveString());

    //
    // get the verb/method to use.
    //

    if (tMethod == HTTP_METHOD_TYPE_UNKNOWN) {

        //
        // the method is unknown, read the old one out of the string
        //  and save off, basically we're reusing the previous one.
        //

        lpcszVerb = request.StringAddress();

        for (DWORD i = 0; i < request.StringLength(); i++) {
            if (lpcszVerb[i] == ' ') {
                break;
            }
        }

        INET_ASSERT((i > 0) && (i < (DWORD)request.StringLength()));

        verbLength = (DWORD)i;
    } else {

        //
        // its one of the normal kind, just map it.
        //

        verbLength = MapHttpMethodType(tMethod, &lpcszVerb);
    }
    if (lpszVersion == NULL) {
        lpszVersion = _lpszVersion;
        dwVersionLength = _dwVersionLength;
    }

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    //
    // calculate the new length from the component lengths we originally set
    // in AddRequest(), and the new object name
    //

    length = verbLength + 1 + dwObjectNameLength + 1 + dwVersionLength + 1;

    //
    // create a new request line
    //

    newRequest.CreateStringBuffer((LPVOID)lpcszVerb, verbLength, length);
    if (newRequest.IsError()) {
        error = GetLastError();
    } else {
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszObjectName, dwObjectNameLength);
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszVersion, dwVersionLength);

        //
        // remove the current request line length from the header buffer
        // aggregate
        //

        _HeadersLength -= request.StringLength();

        //
        // make the current request line the new one
        //

        request = newRequest.StringAddress();

        //
        // and update the address and length variables (version length is the
        // only thing that stays the same)
        //

        if (!request.IsError()) {
            _lpszVerb = request.StringAddress();
            _dwVerbLength = verbLength;
            _lpszObjectName = _lpszVerb + verbLength + 1;
            _dwObjectNameLength = dwObjectNameLength;
            _lpszVersion = _lpszObjectName + dwObjectNameLength + 1;
            _dwVersionLength = dwVersionLength;
            SetRequestVersion();

        //
        // and the new request line length to the aggregate header length
        //

            _HeadersLength += request.StringLength();
        } else {
            error = GetLastError();
        }
    }

quit:

    PERF_LEAVE(ModifyRequest);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::SetRequestVersion(
    VOID
    )

/*++

Routine Description:

    Set _RequestVersionMajor and _RequestVersionMinor based on the HTTP
    version string

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_HEADERS::SetRequestVersion",
                 NULL
                 ));

    INET_ASSERT(_lpszVersion != NULL);

    _RequestVersionMajor = 0;
    _RequestVersionMinor = 0;
    if (strncmp(_lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR pNum = _lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMajor);
        while (!isdigit(*pNum) && (*pNum != '\0')) {
            ++pNum;
        }
        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMinor);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("request version = %d.%d\n",
                    _RequestVersionMajor,
                    _RequestVersionMinor
                    ));

    } else {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("\"HTTP/\" not found in %q\n",
                    _lpszVersion
                    ));

    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\cookie.cxx ===
//---------------------------------------------------------------------------
//
// COOKIE.CXX
//
//     Cookie Jar
//
//     This file implements cookies as defined by Navigator 4 behavior and the
//     specification at http://www.netscape.com/newsref/std/cookie_spec.html.
//     If Navigator 4 and the specification are not in agreement, we try to
//     match the Navigator 4 behavior.
//
//     The following describes some interesting aspects of cookie behavior.
//
// SYNTAX
//
//    Syntax for cookie is
//
//          [[name]=] value [; options]
//
//    The name is everything before "=" with leading and  trailing whitespace
//    removed.  The value is everything after "=" and before ";" with leading
//    and trailing whitespace removed.  The name and value can contain spaces,
//    quotes or any other character except ";" and "=".  The name and equal
//    sign are optional.
//
//    Example:  =foo  ->  name: <blank> value: foo
//              foo   ->  name: <blank> value: foo
//              foo=  ->  name: foo     value: <blank>
//              ;     ->  name: <blank> value: <blank>
//
// ORDER
//
//    Cookies with a more specific path are sent before cookies with
//    a less specific path mapping.  The domain does not contibute
//    to the ordering of cookies.
//
//    If the path length of two cookies are equal, then the cookies
//    are ordered by time of creation.  Navigator maintains this
//    ordering across domain and path boundaries.  IE maintains this
//    ordering for a specific domain and path. It is difficult to match
//    the Navigator behavior and there are no known bugs because of
//    this difference.
//
// MATCHING
//
//    Path matches are done at the character level.  Any
//    directory structure in the path is ignored.
//
//    Navigator matches domains at the character level and ignores
//    the structure of the domain name.
//
//    Previous versions of IE tossed the leading "." on a domain name.
//    With out this information, character by character compares are
//    can produce incorrect results.  For backwards compatibilty with
//    old cookie we continue to match on a component by component basis.
//
//    Some examples of the difference are:
//
//       Cookie domain   Document domain  Navigator match  IE match
//       .foo.com        foo.com          no               yes
//       bar.x.com       foobar.x.com     yes              no
//
// ACCEPTING COOKIES
//
//    A cookie is rejected if the path specified in the set cookie
//    header is not a prefix of document's path.
//
//    Navigator rejects a cookie if the domain specified in the
//    set cookie header does not contain at least two periods
//    or the domain is not a suffix of the document's domain.
//    The suffix match is done on a character by character basis.
//
//    Navigator ignores all the stuff in the specification about
//    three period matching and the seven special top level domains.
//
//    IE rejects a cookie if the domain specified by the cookie
//    header does not contain at least one embedded period or the
//    domain is not a suffix of the documents domain.
//
//    Cookies are accepted if the path specified in the set cookie
//    header is a prefix of the document's path and the domain
//    specified in the set cookie header.
//
//    The difference in behavior is a result of the matching rules
//    described in the previous section.
//
//---------------------------------------------------------------------------

#include <wininetp.h>
#include "httpp.h"

#include "cookiejar.h"

#define CCH_COOKIE_MAX  (5 * 1024)

static char s_achEmpty[] = "";

// Hard-coded list of special domains. If any of these are present between the 
// second-to-last and last dot we will require 2 embedded dots.
// The domain strings are reversed to make the compares easier

static const char *s_pachSpecialDomains[] = 
    {"MOC", "UDE", "TEN", "GRO", "VOG", "LIM", "TNI" };  


struct CookieInfo {

   char *pchRDomain;
   char *pchPath;
   char *pchName;
   char *pchValue;
   unsigned long dwFlags;
   FILETIME ftExpiration;
};

//---------------------------------------------------------------------------
//
// String utilities
//
//---------------------------------------------------------------------------

static BOOL
IsZero(FILETIME *pft)
{
    return pft->dwLowDateTime == 0 && pft->dwHighDateTime == 0;
}

static char *
StrnDup(const char *pch, int cch)
{
    char *pchAlloc = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cch + 1);
    if (!pchAlloc)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memcpy(pchAlloc, pch, cch);
    pchAlloc[cch] = 0;

    return pchAlloc;
}

static BOOL
IsPathMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0;
}

static BOOL
IsDomainMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0 && (*pchStr == 0 || *pchStr == '.');
}

static BOOL
IsPathLegal(const char *pchHeader, const char *pchDocument)
{
    return TRUE;

    /*

    We attempted to implement the specification here.
    It looks like Navigator does not reject cookies
    based on the path attribute.  We now consider
    all path attributes to be legal.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    if (*pchDocument == 0)
    {
        while (*pchHeader && *pchHeader != '/' && *pchHeader != '\\')
        {
            pchHeader += 1;
        }
    }

    return *pchHeader == 0;
    */
}

extern PTSTR GlobalSpecialDomains;
extern PTSTR *GlobalSDOffsets;

static BOOL
IsVerySpecialDomain(const char *pch, int nTopLevel, int nSecond)
{
    if (!GlobalSpecialDomains)
    {
        HKEY hk;
        if (ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0"),
                                        0,
                                        KEY_READ,
                                        &hk))
        {
            DWORD dwType, dwSize;

            if ((ERROR_SUCCESS==RegQueryValueEx(hk, "SpecialDomains", NULL, &dwType, NULL, &dwSize))
                && (REG_SZ==dwType))
            {
                GlobalSpecialDomains = New TCHAR[dwSize];
                if (GlobalSpecialDomains
                    && (ERROR_SUCCESS==RegQueryValueEx(hk, "SpecialDomains", NULL, &dwType, (LPBYTE)GlobalSpecialDomains, &dwSize)))
                {

                    // We're going to scan a string stored in the registry to gather the domains we should
                    // allow. Format:
                    // [domain] [domain] [domain]
                    // The delimiter is a space character.
                    
                    PTSTR psz = GlobalSpecialDomains;
                    DWORD dwDomains = 0;
                    BOOL fWord = FALSE;
                    while (*psz)
                    {
                        if (*psz==TEXT(' '))
                        {
                            if (fWord)
                            {
                                fWord = FALSE;
                                dwDomains++;
                            }
                        }
                        else
                        {
                            fWord = TRUE;
                        }
                        psz++;
                    }
                    if (fWord)
                    {
                        dwDomains++;
                    }
                    GlobalSDOffsets = (PTSTR*)New PTSTR[dwDomains+1];
                    if (GlobalSDOffsets)
                    {
                        psz = GlobalSpecialDomains;
                        for (DWORD dw = 0; dw < dwDomains; dw++)
                        {
                            INET_ASSERT(*psz);

                            while (*psz==TEXT(' '))
                                psz++;

                            INET_ASSERT(*psz);
                            GlobalSDOffsets[dw] = psz;

                            while (*psz && *psz!=TEXT(' '))
                            {
                                psz++;
                            }
                            *psz = TEXT('\0');
                        }
                        GlobalSDOffsets[dwDomains] = NULL;
                    }
                }
            }
            RegCloseKey(hk);
        }
    }

    // WARNING: The following lines of code make it possible for cookies to be set for *.uk,
    // (for example) if "ku." is in the registry
    BOOL fRet = FALSE;
    if (GlobalSDOffsets)
    {
        for (DWORD i = 0; GlobalSDOffsets[i]; i++)
        {
            if (!StrCmpNI(pch, GlobalSDOffsets[i], nTopLevel)
                || !StrCmpNI(pch, GlobalSDOffsets[i], nTopLevel+nSecond+1))
            {
                fRet = TRUE;
                break;
            }
        }
    }
    return fRet;
}


static BOOL
IsSpecialDomain(const char *pch, int nCount)
{
    // Currently all the special strings are exactly 3 characters long.
    if (pch == NULL || nCount != 3)
        return FALSE;

    for (int i = 0 ; i < ARRAY_ELEMENTS(s_pachSpecialDomains) ; i++ )
    {
        if (StrCmpNIC(pch, s_pachSpecialDomains[i], nCount) == 0)
            return TRUE;
    }

    return FALSE;
}

static BOOL
IsDomainLegal(const char *pchHeader, const char *pchDocument)
{
    const char *pchCurrent = pchHeader;
    int nSegment = 0;
    int dwCharCount = 0;
    int rgcch[2] = { 0, 0 };  // How many characters between dots

    // Must have at least one period in name.
    // and contains nothing but '.' is illegal 

    int dwSegmentLength = 0;
    const char * pchSecondPart = NULL; // for a domain string such as 
    for (; *pchCurrent; pchCurrent++)
    {
        if (*pchCurrent == '.')
        {
            if (nSegment < 2)
            {
                // Remember how many characters we have between the last two dots
                // For example if domain header is .microsoft.com
                // rgcch[0] should be 3 for "com"
                // rgcch[1] should be 9 for "microsoft"
                rgcch[nSegment] = dwSegmentLength;

                if (nSegment == 1)
                {
                    pchSecondPart = pchCurrent - dwSegmentLength;
                }
            }
            dwSegmentLength = 0;
            nSegment += 1;
        }
        else
        {
            dwSegmentLength++;
        }
        dwCharCount++;
    }

    // The code below depends on the leading dot being removed from the domain header.
    // The parse code does that, but an assert here just in case something changes in the 
    // parse code.
    INET_ASSERT(*(pchCurrent - 1) != '.');

    // Remember the count of the characters between the begining of the header and 
    // the first dot. So for domain=abc.com this will set rgch[1] = 3. 
    // Note that this assumes that if domain=.abc.com the leading dot has been stripped
    // out in the parse code. See assert above.
    if (nSegment < 2 )
    {
        rgcch[nSegment] = dwSegmentLength;
        if (nSegment==1)
        {
            pchSecondPart = pchCurrent - dwSegmentLength;
        }
    }

    // If the domain name is of the form abc.xx.yy where the number of characters between the last two dots is less than 
    // 2 we require a minimum of two embedded dots. This is so you are not allowed to set cookies readable by all of .co.nz for 
    // example. However this rule is not sufficient and we special case things like .edu.nz as well. 

    int cEmbeddedDotsNeeded = 1;

    if (rgcch[0] <= 2)
    {
        if ((rgcch[1] <= 2 && !IsVerySpecialDomain(pchHeader, rgcch[0], rgcch[1]))
            || (pchSecondPart && IsSpecialDomain(pchSecondPart, rgcch[1])))
            cEmbeddedDotsNeeded = 2;
    }

    if (nSegment < cEmbeddedDotsNeeded || dwCharCount == nSegment)
        return FALSE;

    // Mismatch between header and document not allowed.
    // Must match full components of domain name.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    return *pchHeader == 0 && (*pchDocument == 0 || *pchDocument == '.' );
}


void
LowerCaseString(char *pch)
{
    for (; *pch; pch++)
    {
        if (*pch >= 'A' && *pch <= 'Z')
            *pch += 'a' - 'A';
    }
}

static void
ReverseString(char *pchFront)
{
    char *pchBack;
    char  ch;
    int   cch;

    cch = strlen(pchFront);

    pchBack = pchFront + cch - 1;

    cch = cch / 2;
    while (--cch >= 0)
    {
        ch = tolower(*pchFront);
        *pchFront = tolower(*pchBack);
        *pchBack = ch;

        pchFront += 1;
        pchBack -= 1;
    }
}

static BOOL
PathAndRDomainFromURL(const char *pchURL, char **ppchRDomain, char **ppchPath, BOOL *pfSecure, BOOL bStrip = TRUE)
{
    char *pchDomainBuf;
    char *pchRDomain = NULL;
    char *pchPathBuf;
    char *pchPath = NULL;
    char *pchExtra;
    DWORD cchDomain;
    DWORD cchPath;
    DWORD cchExtra;
    BOOL  fSuccess = FALSE;
    DWORD dwError;
    INTERNET_SCHEME ustScheme;

    dwError = CrackUrl((char *)pchURL,
             0,
             FALSE,
             &ustScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Lenth
             &pchDomainBuf,
             &cchDomain,
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             &pchPathBuf,
             &cchPath,
             &pchExtra,     //  Extra
             &cchExtra,     //  Extra Length
             NULL);

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        goto Cleanup;
    }

    if ( ustScheme != INTERNET_SCHEME_HTTP &&
         ustScheme != INTERNET_SCHEME_HTTPS &&
         ustScheme != INTERNET_SCHEME_UNKNOWN)
    {
        //
        // known scheme should be supported
        // e.g. 3rd party pluggable protocol should be able to
        // call cookie api to setup cookies...
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    *pfSecure = ustScheme == INTERNET_SCHEME_HTTPS;

    if(bStrip)
    {
        while (cchPath > 0)
        {
            if (pchPathBuf[cchPath - 1] == '/' || pchPathBuf[cchPath - 1] == '\\')
            {
                break;
            }
        cchPath -= 1;
        }
    }

    pchRDomain = StrnDup(pchDomainBuf, cchDomain);
    if (!pchRDomain)
        goto Cleanup;

    LowerCaseString(pchRDomain);
    ReverseString(pchRDomain);

    pchPath = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchPath + 2);
    if (!pchPath)
        goto Cleanup;

    if (*pchPathBuf != '/')
    {
        *pchPath = '/';
        memcpy(pchPath + 1, pchPathBuf, cchPath);
        pchPath[cchPath + 1] = TEXT('\0');
    }
    else
    {
        memcpy(pchPath, pchPathBuf, cchPath);
        pchPath[cchPath] = TEXT('\0');
    }

    fSuccess = TRUE;

Cleanup:
    if (!fSuccess)
    {
        if (pchRDomain)
            FREE_MEMORY(pchRDomain);
        if (pchPath)
            FREE_MEMORY(pchPath);
    }
    else
    {
        *ppchRDomain = pchRDomain;
        *ppchPath = pchPath;
    }

    return fSuccess;
}

//---------------------------------------------------------------------------
//
// CCookieBase implementation
//
//---------------------------------------------------------------------------

void *
CCookieBase::operator new(size_t cb, size_t cbExtra)
{
    void *pv = ALLOCATE_MEMORY(LMEM_FIXED, cb + cbExtra);
    if (!pv)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memset(pv, 0, cb);
    return pv;
}

inline void
CCookieBase::operator delete(void *pv)
{
    FREE_MEMORY(pv);
}

//---------------------------------------------------------------------------
//
// CCookie implementation
//
//---------------------------------------------------------------------------

CCookie *
CCookie::Construct(const char *pchName)
{
    CCookie *pCookie = new(strlen(pchName) + 1) CCookie();
    if (!pCookie)
        return NULL;

    pCookie->_pchName = (char *)(pCookie + 1);
    pCookie->_pchValue = s_achEmpty;
    strcpy(pCookie->_pchName, pchName);

    pCookie->_dwFlags = COOKIE_SESSION;

    return pCookie;
}

CCookie::~CCookie()
{
    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);
}

BOOL
CCookie::SetValue(const char *pchValue)
{
    int   cchValue;

    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);

    if (!pchValue || !*pchValue)
    {
        _pchValue = s_achEmpty;
    }
    else
    {
        cchValue = strlen(pchValue) + 1;
        _pchValue = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchValue);
        if (!_pchValue)
        {
            _pchValue = s_achEmpty;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        memcpy(_pchValue, pchValue, cchValue);
    }
    return TRUE;
}

BOOL
CCookie::CanSend(BOOL fSecure)
{
    return (fSecure || !(_dwFlags & COOKIE_SECURE));
}

BOOL CCookie::PurgeAll(void *)
{
    return TRUE;
}


static BOOL
WriteString(HANDLE hFile, const char *pch)
{
    DWORD cb;
    return pch && *pch ? WriteFile(hFile, pch, strlen(pch), &cb, NULL) : TRUE;
}

static BOOL
WriteStringLF(HANDLE hFile, const char *pch)
{
    DWORD cb;

    if (!WriteString(hFile, pch)) return FALSE;
    return WriteFile(hFile, "\n", 1, &cb, NULL);
}


//---------------------------------------------------------------------------
//
// CCookieLocation implementation
//
//---------------------------------------------------------------------------

CCookieLocation *
CCookieLocation::Construct(const char *pchRDomain, const char *pchPath)
{
    int cchPath = strlen(pchPath);

    CCookieLocation *pLocation = new(strlen(pchRDomain) + cchPath + 2) CCookieLocation();
    if (!pLocation)
        return NULL;

    pLocation->_cchPath = cchPath;
    pLocation->_pchPath = (char *)(pLocation + 1);
    pLocation->_pchRDomain = pLocation->_pchPath + cchPath + 1;

    strcpy(pLocation->_pchRDomain, pchRDomain);
    strcpy(pLocation->_pchPath, pchPath);

    return pLocation;
}

CCookieLocation::~CCookieLocation()
{
    Purge(CCookie::PurgeAll, NULL);
}

CCookie *
CCookieLocation::GetCookie(const char *pchName, BOOL fCreate)
{
    CCookie *pCookie;

    CCookie **ppCookie = &_pCookieKids;

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (strcmp(pchName, pCookie->_pchName) == 0)
            return pCookie;
        ppCookie = &pCookie->_pCookieNext;
    }

    if (!fCreate)
        return NULL;

    pCookie = CCookie::Construct(pchName);
    if (!pCookie)
        return NULL;

    //
    // Insert cookie at end of list to match Navigator's behavior.
    //

    pCookie->_pCookieNext = NULL;
    *ppCookie = pCookie;

    return pCookie;
}

void
CCookieLocation::Purge(BOOL (CCookie::*pfnPurge)(void *), void *pv)
{
    CCookie **ppCookie = &_pCookieKids;
    CCookie *pCookie;

    while ((pCookie = *ppCookie) != NULL)
    {
        if ((pCookie->*pfnPurge)(pv))
        {
            *ppCookie = pCookie->_pCookieNext;
            delete pCookie;
        }
        else
        {
            ppCookie = &pCookie->_pCookieNext;
        }
    }
}

static char *
ScanString(char *pch, char **pchStr)
{
    *pchStr = pch;

    for (; *pch; *pch++)
    {
        if (*pch == '\n')
        {
            *pch = 0;
            pch += 1;
            break;
        }
    }

    return pch;
}

static char *
ScanNumber(char *pch, DWORD *pdw)
{
    DWORD dw = 0;
    char *pchJunk;

    for (; *pch >= '0' && *pch <= '9'; *pch++)
    {
        dw = (dw * 10) + *pch - '0';
    }

    *pdw = dw;

    return ScanString(pch, &pchJunk);
}


BOOL
CCookieLocation::IsMatch(const char *pchRDomain, const char *pchPath)
{
    return IsDomainMatch(_pchRDomain, pchRDomain) &&
        IsPathMatch(_pchPath, pchPath);
}


//---------------------------------------------------------------------------
//
// CCookieJar implementation
//
//---------------------------------------------------------------------------


CCookieJar *
CCookieJar::Construct()
{
    return new(0) CCookieJar();
}

CCookieJar::CCookieJar()
{
    _csCookieJar.Init();
}

CCookieJar::~CCookieJar()
{
    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        CCookieLocation *pLocation = _apLocation[i];
        while (pLocation)
        {
            CCookieLocation *pLocationT = pLocation->_pLocationNext;
            delete pLocation;
            pLocation = pLocationT;
        }
    }
}

CCookieLocation **
CCookieJar::GetBucket(const char *pchRDomain)
{
    int ch;
    int cPeriod = 0;
    unsigned int hash = 0;

    for (; (ch = *pchRDomain) != 0; pchRDomain++)
    {
        if (ch == '.')
        {
            cPeriod += 1;
            if (cPeriod >= 2)
                break;
        }
        hash = (hash * 29) + ch;
    }

    hash = hash % ARRAY_ELEMENTS(_apLocation);

    return &_apLocation[hash];
}

CCookieLocation *
CCookieJar::GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate)
{
    int cchPath = strlen(pchPath);
    CCookieLocation *pLocation = NULL;
    CCookieLocation **ppLocation = GetBucket(pchRDomain);

    // To support sending more specific cookies before less specific,
    // we keep list sorted by path length.

    while ((pLocation = *ppLocation) != NULL)
    {
        if (pLocation->_cchPath < cchPath)
            break;

        if (strcmp(pLocation->_pchPath, pchPath) == 0 &&
            strcmp(pLocation->_pchRDomain, pchRDomain) == 0)
            return pLocation;

        ppLocation = &pLocation->_pLocationNext;
    }

    if (!fCreate)
        goto Cleanup;

    pLocation = CCookieLocation::Construct(pchRDomain, pchPath);
    if (!pLocation)
        goto Cleanup;

    pLocation->_pLocationNext = *ppLocation;
    *ppLocation = pLocation;

Cleanup:
    return pLocation;
}

void 
CCookieJar::expireCookies(CCookieLocation *pLocation, FILETIME *pftNow) {

   FILETIME ftCurrent;

   if (pftNow==NULL)
      GetSystemTimeAsFileTime(&ftCurrent);
   else
      ftCurrent = *pftNow;

   CCookie **previous = & pLocation->_pCookieKids;

   CCookie *pCookie = pLocation->_pCookieKids;

   while (pCookie) 
   {
      /* Session cookies do not expire so we only check persistent cookies */
      if ((pCookie->_dwFlags & COOKIE_SESSION) == 0)
      {

         /* "CompareFileTime" macro returns {+1, 0, -1} similar to "strcmp" */
         int cmpresult = CompareFileTime(ftCurrent, pCookie->_ftExpiry);

         if (cmpresult==1) /* Cookie has expired: remove from linked list & delete */
         { 
            *previous = pCookie->_pCookieNext;
            delete pCookie;
            pCookie = *previous;
            continue;
         }
      }

      /* Otherwise cookie is still valid: advance to next node */
      previous = & (pCookie->_pCookieNext);
      pCookie = pCookie->_pCookieNext;
   }   
}



CCookieLocation*
CCookieJar::GetCookies(const char *pchRDomain, const char *pchPath, CCookieLocation *pLast, FILETIME *ftCurrentTime)  {

   for (CCookieLocation *pLocation = pLast ? pLast->_pLocationNext : *GetBucket(pchRDomain);
        pLocation;
        pLocation = pLocation->_pLocationNext)
   {
      if (pLocation->IsMatch(pchRDomain, pchPath))
      {
         /* Found matching cookies...
            Before returning linked list to the user, check expiration 
            times, deleting cookies which are no longer valid */
         expireCookies(pLocation, ftCurrentTime);
         return pLocation;
      }
   }

   /* Reaching this point means no matching cookies were found */
   return NULL;
}

void
CCookieJar::Purge()
{
    // NOT IMPLEMENTED
}


struct PARSE
{
    char *pchBuffer;
    char *pchToken;
    BOOL fEqualFound;
};

static char *
SkipWS(char *pch)
{
    while (*pch == ' ' || *pch == '\t')
        pch += 1;

    return pch;
}

static BOOL
ParseToken(PARSE *pParse, BOOL fBreakOnSpecialTokens, BOOL fBreakOnEqual)
{
    char ch;
    char *pch;
    char *pchEndToken;

    pParse->fEqualFound = FALSE;

    pch = SkipWS(pParse->pchBuffer);
    if (*pch == 0)
    {
        pParse->pchToken = pch;
        return FALSE;
    }

    pParse->pchToken = pch;
    pchEndToken = pch;

    while ((ch = *pch) != 0)
    {
        pch += 1;
        if (ch == ';')
        {
            break;
        }
        else if (fBreakOnEqual && ch == '=')
        {
            pParse->fEqualFound = TRUE;
            break;
        }
        else if (ch == ' ' || ch == '\t')
        {
            if (fBreakOnSpecialTokens)
            {
                if ((strnicmp(pch, "expires", sizeof("expires") - 1) == 0) ||
                    (strnicmp(pch, "path", sizeof("path") - 1) == 0) ||
                    (strnicmp(pch, "domain", sizeof("domain") - 1) == 0) ||
                    (strnicmp(pch, "secure", sizeof("secure") - 1) == 0))
                {
                    break;
                }
            }
        }
        else
        {
            pchEndToken = pch;
        }
    }

    *pchEndToken = 0;
    pParse->pchBuffer = pch;
    return TRUE;
}


static void
ParseHeader(
    char *pchHeader,
    CookieInfo *pCookie
   )
{
   char **ppchName = & (pCookie->pchName);
   char **ppchValue = & (pCookie->pchValue);
   char **ppchPath = & (pCookie->pchPath);
   char **ppchRDomain = & (pCookie->pchRDomain);

   PARSE parse;

    parse.pchBuffer = pchHeader;

    *ppchName = NULL;
    *ppchValue = NULL;
    *ppchPath = NULL;
    *ppchRDomain = NULL;
    pCookie->dwFlags = COOKIE_SESSION;

    // If only one of name or value is specified, Navigator
    // uses name=<blank> and value as what ever was specified.
    // Example:  =foo  ->  name: <blank> value: foo
    //           foo   ->  name: <blank> value: foo
    //           foo=  ->  name: foo     value: <blank>

    if (ParseToken(&parse, FALSE, TRUE))
    {
        *ppchName = parse.pchToken;
        if (parse.fEqualFound)
        {
            if (ParseToken(&parse, FALSE, FALSE))
            {
                *ppchValue = parse.pchToken;
            }
            else
            {
                *ppchValue = s_achEmpty;
            }
        }
        else
        {
            *ppchValue = *ppchName;
            *ppchName = s_achEmpty;
        }
    }

    while (ParseToken(&parse, FALSE, TRUE))
    {
        if (stricmp(parse.pchToken, "expires") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE))
            {
                // WinHttpX treats persistent cookies as session cookies with expiration
                if (FParseHttpDate(& pCookie->ftExpiration, parse.pchToken)) 
                {
                   // Don't make the cookie persistent if the parsing fails
                   pCookie->dwFlags &= ~COOKIE_SESSION;
                }
            }
        }
        else if (stricmp(parse.pchToken, "domain") == 0)
        {
            if (parse.fEqualFound )
            {
                if( ParseToken(&parse, TRUE, FALSE))
                {
                    // Previous versions of IE tossed the leading
                    // "." on domain names.  We continue this behavior
                    // to maintain compatiblity with old cookie files.
                    // See comments at the top of this file for more
                    // information.

                    if (*parse.pchToken == '.') parse.pchToken += 1;
                    ReverseString(parse.pchToken);
                    *ppchRDomain = parse.pchToken;
                }
                else
                {
                    *ppchRDomain = parse.pchToken;
                }
            }
        }
        else if (stricmp(parse.pchToken, "path") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE))
            {
                *ppchPath = parse.pchToken;
            }
            else
            {
                *ppchPath = s_achEmpty;
            }
        }
        else if (stricmp(parse.pchToken, "secure") == 0)
        {
            pCookie->dwFlags |= COOKIE_SECURE;

            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
        else
        {
            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
    }

    if (!*ppchName)
    {
        *ppchName = *ppchValue = s_achEmpty;
    }
}

// free's an INTERNET_COOKIE structure
static VOID
DestroyInternetCookie(INTERNET_COOKIE *pic)
{
    if ( pic != NULL ) 
    {
        if ( pic->pszDomain ) {
            FREE_MEMORY(pic->pszDomain);
        }
        if ( pic->pszPath ) {
            FREE_MEMORY(pic->pszPath);
        }
        if ( pic->pszName ) {
            FREE_MEMORY(pic->pszName);
        }
        if ( pic->pszData ) {
            FREE_MEMORY(pic->pszData);
        }
        if ( pic->pszUrl ) {
            FREE_MEMORY(pic->pszUrl);
        }
        if( pic->pftExpires ) {
            delete pic->pftExpires; 
            pic->pftExpires = NULL;
        }

        FREE_MEMORY(pic);
    }
}

// allocate's an INTERNET_COOKIE structure
static INTERNET_COOKIE *
MakeInternetCookie(
    const char *pchURL,
    char *pchRDomain,
    char *pchPath,
    char *pchName,
    char *pchValue,
    DWORD dwFlags,
    FILETIME ftExpire
    )
{
    INTERNET_COOKIE *pic = NULL;

    pic = (INTERNET_COOKIE *) ALLOCATE_MEMORY(LMEM_ZEROINIT, sizeof(INTERNET_COOKIE));

    if ( pic == NULL ) {
        return NULL;
    }
    
    pic->cbSize = sizeof(INTERNET_COOKIE);

    pic->pszDomain = pchRDomain ? NewString(pchRDomain) : NULL;
    if (pic->pszDomain) {
        ReverseString(pic->pszDomain);
    }
    pic->pszPath = pchPath ? NewString(pchPath) : NULL;
    pic->pszName = pchName ? NewString(pchName) : NULL;
    pic->pszData = pchValue ? NewString(pchValue) : NULL;
    pic->pszUrl = pchURL ? NewString(pchURL) : NULL;

#if COOKIE_SECURE != INTERNET_COOKIE_IS_SECURE
#error MakeInternetCookie depends on cookie flags to remain the same
#endif 
    pic->dwFlags = dwFlags;

    if( dwFlags & COOKIE_SESSION )
    {
        pic->pftExpires = NULL;
    }
    else
    {
        pic->pftExpires = New FILETIME;
        if( pic->pftExpires )
        {
            memcpy(pic->pftExpires, &ftExpire, sizeof(FILETIME));
        }
    }
    
    return pic;
}


DWORD
CCookieJar::SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader, DWORD dwFlags = 0)
{
    char *pchDocumentRDomain = NULL;
    char *pchDocumentPath = NULL;
    BOOL  fDocumentSecure;
    BOOL  fDelete;
    DWORD dwRet = SET_COOKIE_FAIL;
    CCookieLocation *pLocation;

    CookieInfo cookieStats;

    ParseHeader(pchHeader, &cookieStats);

    char *pchName = cookieStats.pchName;
    char *pchValue = cookieStats.pchValue;
    char *pchHeaderPath = cookieStats.pchPath;
    char *pchHeaderRDomain = cookieStats.pchRDomain;
    DWORD dwFlagsFromParse = cookieStats.dwFlags;
       
    // merge flags given with those found by the parser.
    dwFlags |= dwFlagsFromParse;

    if (!PathAndRDomainFromURL(pchURL, &pchDocumentRDomain, &pchDocumentPath, &fDocumentSecure))
        goto Cleanup;

    //
    // Verify domain and path
    //

    if ((pchHeaderRDomain && !IsDomainLegal(pchHeaderRDomain, pchDocumentRDomain)) ||
        (pchHeaderPath && !IsPathLegal(pchHeaderPath, pchDocumentPath)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    if (!pchHeaderRDomain)
        pchHeaderRDomain = pchDocumentRDomain;

    if (!pchHeaderPath)
        pchHeaderPath = pchDocumentPath;

    // We need to discard any extra info (i.e. query strings and fragments)
    // from the url.
    if (pchHeaderPath)
    {
        PTSTR psz = pchHeaderPath;
        while (*psz)
        {
            if (*psz==TEXT('?') || *psz==TEXT('#'))
            {
                *psz = TEXT('\0');
                break;
            }
            psz++;
        }
    }

    //   WinHttpX treats persistent cookies as session cookies, subject
    //   to the expiration rules
    //   Also it does not implement zone policies set by URLMON
    //
    //   Finally, we can add the cookie!
    //

    {
        if (_csCookieJar.Lock())
        {
            pLocation = GetLocation(pchHeaderRDomain, pchHeaderPath, TRUE);

            if (pLocation)
            {
                CCookie *pCookie;

                pCookie = pLocation->GetCookie(pchName, TRUE);
                if (!pCookie)
                    goto Cleanup;

                //
                // If the cookie's value or flags have changed, update it.
                //
                if (strcmp(pchValue, pCookie->_pchValue) || dwFlags != pCookie->_dwFlags)
                {
                    pCookie->_dwFlags = dwFlags;
                    pCookie->_ftExpiry = cookieStats.ftExpiration;
                    pCookie->SetValue(pchValue);
                }
            }
            _csCookieJar.Unlock();
        }
    }

    dwRet = SET_COOKIE_SUCCESS;

Cleanup:

    if (pchDocumentRDomain)
        FREE_MEMORY(pchDocumentRDomain);
    if (pchDocumentPath)
        FREE_MEMORY(pchDocumentPath);

    return dwRet;
}


//---------------------------------------------------------------------------
//
// External APIs
//
//---------------------------------------------------------------------------


CCookieJar *
CreateCookieJar()
{
    return CCookieJar::Construct();
}

void
CloseCookieJar(CCookieJar * CookieJar)
{
    if (CookieJar)
    {
        delete CookieJar;
    }
}

#ifndef WININET_SERVER_CORE
void
PurgeCookieJar()
{
}
#endif


//
//  rambling comments, delete before checkin...
//
// returns struc, and pending, error
//  on subsequent attempts passes back, with index, or index incremented
// perhaps can store index in fsm, and the rest in UI 
//  need to handle multi dlgs, perhaps via checking added Cookie.
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ExtractSetCookieHeaders(LPDWORD lpdwHeaderIndex)
{
    char *pchHeader = NULL;
    DWORD cbHeader;
    DWORD iQuery = 0;
    int   cCookies = 0;
    DWORD error = ERROR_WINHTTP_HEADER_NOT_FOUND;
    const DWORD cbHeaderInit = CCH_COOKIE_MAX * sizeof(char) - 1;

    pchHeader = New char[CCH_COOKIE_MAX];

    if (pchHeader == NULL || !_ResponseHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(lpdwHeaderIndex);

    cbHeader = cbHeaderInit;

    iQuery = *lpdwHeaderIndex;

    while (QueryResponseHeader(HTTP_QUERY_SET_COOKIE,
            pchHeader,
            &cbHeader,
            0,
            &iQuery) == ERROR_SUCCESS)
    {
        pchHeader[cbHeader] = 0;

        INTERNET_HANDLE_OBJECT *pRoot = GetRootHandle (this);
        CCookieJar* pcj = pRoot->_CookieJar;
        DWORD dwRet = pcj->SetCookie(this, GetURL(), pchHeader);

        if (dwRet == SET_COOKIE_SUCCESS)
        {
            cCookies += 1;
            *lpdwHeaderIndex = iQuery;
            error = ERROR_SUCCESS;
        } 
        else if (dwRet == SET_COOKIE_PENDING) 
        {
            error = ERROR_IO_PENDING;

            INET_ASSERT(iQuery != 0);
            *lpdwHeaderIndex = iQuery - 1; // back up and retry this cookie

            break;
        }

        cbHeader = cbHeaderInit;
    }

    _ResponseHeaders.UnlockHeaders();

Cleanup:
    if (pchHeader)
        delete [] pchHeader;

    return error;
}

int
HTTP_REQUEST_HANDLE_OBJECT::CreateCookieHeaderIfNeeded(VOID)
{
    int     cCookie = 0;
    char *  pchRDomain = NULL;
    char *  pchPath = NULL;
    BOOL    fSecure;
    DWORD   cch;
    int     cchName;
    int     cchValue;
    char *  pchHeader = NULL;
    char *  pchHeaderStart = NULL;

    pchHeaderStart = (char *) ALLOCATE_FIXED_MEMORY(CCH_COOKIE_MAX * sizeof(char));
    if (pchHeaderStart == NULL)
        goto Cleanup;
    
    // remove cookie header if it exists
    // BUGBUG - we are overriding the app. Original cookie code has this.  Don't know why.

    ReplaceRequestHeader(HTTP_QUERY_COOKIE, NULL, 0, 0, 0);

    if (!PathAndRDomainFromURL(GetURL(), &pchRDomain, &pchPath, &fSecure, FALSE))
        goto Cleanup;

    fSecure = GetOpenFlags() & WINHTTP_FLAG_SECURE;

    if (LockHeaders())
    {
        INTERNET_HANDLE_OBJECT *pRoot = GetRootHandle (this);
        CCookieJar* pcj = pRoot->_CookieJar;

        if (pcj->_csCookieJar.Lock())
        {
            FILETIME ftNow;
            GetSystemTimeAsFileTime(&ftNow);

            CCookieLocation *pLocation = pcj->GetCookies(pchRDomain, pchPath, NULL, &ftNow);

            while (pLocation) 
            {
               for (CCookie *pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
               {
                   if (pCookie->CanSend(fSecure))
                   {
                       pchHeader = pchHeaderStart;

                       cch = 0;
                       cch += cchName = strlen(pCookie->_pchName);
                       cch += cchValue = strlen(pCookie->_pchValue);
                       if (cchName) cch += 1; // for equal sign

                       if (cch < CCH_COOKIE_MAX)
                       {
                          if (cchName > 0)
                          {
                             memcpy(pchHeader, pCookie->_pchName, cchName);
                             pchHeader += cchName;
                             *pchHeader++ = '=';
                          }

                          if (cchValue > 0)
                          {
                             memcpy(pchHeader, pCookie->_pchValue, cchValue);
                             pchHeader += cchValue;
                          }

                          cCookie += 1;

                          AddRequestHeader(HTTP_QUERY_COOKIE,
                                           pchHeaderStart,
                                           cch,
                                           0, 
                                           HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON);
                       }
                   }  // if (CanSend)
               } // for (pCookie)

               pLocation = pcj->GetCookies(pchRDomain, pchPath, pLocation, &ftNow);
            } // while (pLocation)
            pcj->_csCookieJar.Unlock();
        } // if pcj->_csCookieJar.Lock()
        UnlockHeaders();
    }

Cleanup:

    if (pchHeaderStart)
        FREE_MEMORY(pchHeaderStart);
    if (pchRDomain)
        FREE_MEMORY(pchRDomain);
    if (pchPath)
        FREE_MEMORY(pchPath);

    return cCookie;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\handles\http.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    http.cxx

Abstract:

    Contains methods for HTTP_REQUEST_HANDLE_OBJECT class

    Contents:
        RMakeHttpReqObjectHandle
        HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::SetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::GetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::ReuseObject
        HTTP_REQUEST_HANDLE_OBJECT::ResetObject
        HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated
        HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeHttpReqObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating an HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                        *** NOT USED FOR HTTP ***
                      OUT: mapped address of HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed
                        *** NOT USED FOR HTTP ***

    dwFlags         - app-supplied flags

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * hHttp;

    hHttp = New HTTP_REQUEST_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwFlags,
                    dwContext
                    );
    if (hHttp != NULL) {
        error = hHttp->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hHttp);

            //
            // ERROR_WINHTTP_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);

                hHttp = NULL;
            }
        } else {
            delete hHttp;
            hHttp = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hHttp;

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT class implementation
//


HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT * Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)

/*++

Routine Description:

    Constructor for direct-to-net HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    Parent      - parent object

    Child       - IN: HTTPREQ structure pointer
                  OUT: pointer to created HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc  - address of function that closes/destroys HTTPREQ structure

    dwFlags     - open flags (e.g. INTERNET_FLAG_RELOAD)

    dwContext   - caller-supplied request context value

Return Value:

    None.

--*/

{
    if (g_pAsyncCount)
    {
        if (Parent && Parent->IsAsyncHandle())
        {
            g_pAsyncCount->AddRef();
        }
    }
    else
    {
        RIP(FALSE);
    }
    
    _pProxyCreds = NULL;
    _pServerCreds = NULL;

    _PreferredScheme = 0;
    _SupportedSchemes = 0;
    _AuthTarget = 0;
    _SecurityLevel = WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM;
    _pszRealm = NULL;

    _Context = dwContext;
    _Socket = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;
    _OpenFlags = dwFlags | INTERNET_FLAG_KEEP_CONNECTION;
    _State = HttpRequestStateCreating;
    _RequestMethod = HTTP_METHOD_TYPE_UNKNOWN;
    _dwOptionalSaved = 0;
    _lpOptionalSaved = NULL;
    _fOptionalSaved = FALSE;
    _bIsWriteRequired = FALSE;
    _ResponseBuffer = NULL;
    _ResponseBufferLength = 0;
    ResetResponseVariables();
    _RequestHeaders.SetIsRequestHeaders(TRUE);
    _ResponseHeaders.SetIsRequestHeaders(FALSE);
    _fTalkingToSecureServerViaProxy = FALSE;
    _bViaProxy = 0;
    _fRequestUsingProxy = FALSE;
    _bWantKeepAlive = FALSE;

    _ServerInfo = NULL;
    _OriginServer = NULL;
    SetServerInfoWithScheme(INTERNET_SCHEME_HTTP, FALSE);

    //
    // set the read/write buffer sizes to the default values (4K)
    //

    _ReadBufferSize = (4 K);
    _WriteBufferSize = (4 K);

    _CacheUrlName = NULL;
    
    SetObjectType(TypeHttpRequestHandle);

    _pAuthCtx         = NULL;
    _pTunnelAuthCtx   = NULL;
    _pCreds             = NULL;

    _NoResetBits.Dword = 0;  // only here are we ever allowed to assign to Dword.

    SetDisableNTLMPreauth(GlobalDisableNTLMPreAuth);
    
    _ProxyHostName = NULL;
    _ProxyHostNameLength = NULL;
    _ProxyPort = INTERNET_INVALID_PORT_NUMBER;

    _SocksProxyHostName = NULL;
    _SocksProxyHostNameLength = NULL;
    _SocksProxyPort = INTERNET_INVALID_PORT_NUMBER;

    _HaveReadFileExData = FALSE;
    memset(&_BuffersOut, 0, sizeof(_BuffersOut));
    _BuffersOut.dwStructSize = sizeof(_BuffersOut);
    _BuffersOut.lpvBuffer = (LPVOID)&_ReadFileExData;

    m_fPPAbortSend = FALSE;

    _dwEnableFlags = 0;

    SetPriority(0);

#ifdef RLF_TEST_CODE

    static long l = 0;
    SetPriority(l++);

#endif

    _RTT = 0;

    if (_Status == ERROR_SUCCESS) {
        _Status = _RequestHeaders.GetError();
        if (_Status == ERROR_SUCCESS) {
            _Status = _ResponseHeaders.GetError();
        }
    }
    
    // Timeout and retry parameters

    INTERNET_HANDLE_OBJECT* pRoot = GetRootHandle(Parent);
    OPTIONAL_SESSION_PARAMS* pParams = pRoot->GetOptionalParams();

    if (pParams)
    {
        _dwResolveTimeout = pParams->dwResolveTimeout;
        _dwConnectTimeout = pParams->dwConnectTimeout;
        _dwConnectRetries = pParams->dwConnectRetries;
        _dwSendTimeout    = pParams->dwSendTimeout;
        _dwReceiveTimeout = pParams->dwReceiveTimeout;
    }
    else
    {
        _dwResolveTimeout = GlobalResolveTimeout;
        _dwConnectTimeout = GlobalConnectTimeout;
        _dwConnectRetries = GlobalConnectRetries;
        _dwSendTimeout    = GlobalSendTimeout;
        _dwReceiveTimeout = GlobalReceiveTimeout;
    }

    if (_OpenFlags & WINHTTP_FLAG_SECURE)
    {
        m_pSecurityInfo = pRoot->GetSslSessionCache()->Find(GetHostName());
        if (NULL == m_pSecurityInfo)
        {
            m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(GetHostName());
        }
    }
    else
    {
        m_pSecurityInfo = NULL;
    }

    if (_Status == ERROR_SUCCESS && IsAsyncHandle())
    {
        if (!_AsyncCritSec.Init())
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        _fAsyncFsmInProgress = FALSE;
    }

}


HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT(
    VOID
    )

/*++

Routine Description:

    Destructor for HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HTTP_REQUEST_HANDLE_OBJECT",
                "%#x",
                this
                ));

    //
    // close the socket (or free it to the pool if keep-alive)
    //

    //
    // Authentication Note:
    // The CloseConnection parameter to force the connection closed
    // is set if we received a challenge but didn't respond, otherwise
    // IIS will get confused when a subsequent request recycles the
    // socket from the keep-alive pool.
    //

    CloseConnection(GetAuthState() == AUTHSTATE_CHALLENGE);

    //
    // If there's an authentication context, unload the provider.
    //

    if (_pAuthCtx) {
        delete _pAuthCtx;
    }
    if (_pTunnelAuthCtx) {
        delete _pTunnelAuthCtx;
    }

    //
    // free the various buffers
    //

    FreeResponseBuffer();
    FreeQueryBuffer();
    SetProxyName(NULL,NULL,0);

    FreeURL();
    
    if (m_pSecurityInfo != NULL) {
        m_pSecurityInfo->Release();
    }

    if (_pProxyCreds)
    {
        delete _pProxyCreds;
    }
    if (_pServerCreds)
    {
        delete _pServerCreds;
    }

    if (_pszRealm)
    {
        FREE_MEMORY(_pszRealm);
    }

    if (_ServerInfo != NULL)
        _ServerInfo->Dereference();
    if (_OriginServer != NULL)
        _OriginServer->Dereference();

    if (g_pAsyncCount)
    {
        g_pAsyncCount->Release();
    }
    else
    {
        RIP(FALSE);
    }

    // There should be no work items left in the blocked queue.
    INET_ASSERT(_FsmWorkItemList.GetCount() == 0);
        
    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetProxyName(
    IN LPSTR lpszProxyHostName,
    IN DWORD dwProxyHostNameLength,
    IN INTERNET_PORT ProxyPort
    )

/*++

Routine Description:

    Set proxy name in object. If already have name, free it. Don't set name if
    current pointer is input

Arguments:

    lpszProxyHostName       - pointer to proxy name to add

    dwProxyHostNameLength   - length of proxy name

    ProxyPort               - port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetProxyName",
                 "{%q, %d, %d}%q, %d, %d",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lpszProxyHostName,
                 dwProxyHostNameLength,
                 ProxyPort
                 ));

    if (lpszProxyHostName != _ProxyHostName) {
        if (_ProxyHostName != NULL) {
            _ProxyHostName = (LPSTR)FREE_MEMORY(_ProxyHostName);

            INET_ASSERT(_ProxyHostName == NULL);

            SetOverrideProxyMode(FALSE);
        }
        if (lpszProxyHostName != NULL) {
            _ProxyHostName = NEW_STRING(lpszProxyHostName);
            if (_ProxyHostName == NULL) {
                dwProxyHostNameLength = 0;
            }
        }
        _ProxyHostNameLength = dwProxyHostNameLength;
        _ProxyPort = ProxyPort;
    } else if (lpszProxyHostName != NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("!!! lpszProxyHostName == _ProxyHostName (%#x)\n",
                    lpszProxyHostName
                    ));

        INET_ASSERT(dwProxyHostNameLength == _ProxyHostNameLength);
        INET_ASSERT(ProxyPort == _ProxyPort);

    }

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::GetProxyName(
    OUT LPSTR* lplpszProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyPort
    )

/*++

Routine Description:

    Return address & length of proxy name plus proxy port

Arguments:

    lplpszProxyHostName     - returned address of name

    lpdwProxyHostNameLength - returned length of name

    lpProxyPort             - returned port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetProxyName",
                 "{%q, %d, %d}%#x, %#x, %#x",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lplpszProxyHostName,
                 lpdwProxyHostNameLength,
                 lpProxyPort
                 ));

    *lplpszProxyHostName = _ProxyHostName;
    *lpdwProxyHostNameLength = _ProxyHostNameLength;
    *lpProxyPort = _ProxyPort;

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReuseObject(
    VOID
    )

/*++

Routine Description:

    Make the object re-usable: clear out any received data and headers and
    reset the state to open

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReuseObject",
                 NULL
                 ));

    _ResponseHeaders.FreeHeaders();
    FreeResponseBuffer();
    ResetResponseVariables();
    _ResponseHeaders.Initialize();
    SetState(HttpRequestStateOpen);
    ResetEndOfFile();
    _ResponseFilterList.ClearList();
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _dwQuerySetCookieHeader = 0;
    if (m_pSecurityInfo) {
        m_pSecurityInfo->Release();
    }
    m_pSecurityInfo = NULL;

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ResetObject(
    IN BOOL bForce,
    IN BOOL bFreeRequestHeaders
    )

/*++

Routine Description:

    This method is called when we we are clearing out a partially completed
    transaction, mainly for when we have determined that an if-modified-since
    request, or a response that has not invalidated the cache entry can be
    retrieved from cache (this is a speed issue)

    Abort the connection and clear out the response headers and response
    buffer; clear the response variables (all done by AbortConnection()).

    If bFreeRequestHeaders, clear out the request headers.

    Reinitialize the response headers. We do not reset the object state, but we
    do reset the end-of-file status

Arguments:

    bForce              - TRUE if connection is forced closed

    bFreeRequestHeaders - TRUE if request headers should be freed

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ResetObject",
                 "%B, %B",
                 bForce,
                 bFreeRequestHeaders
                 ));

    DWORD error;

    error = AbortConnection(bForce);
    if (error == ERROR_SUCCESS) {
        if (bFreeRequestHeaders) {
            _RequestHeaders.FreeHeaders();
        }
        _ResponseHeaders.Initialize();
        ResetEndOfFile();
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    SetAuthenticated    -

Return Value:

    None.

--*/

{
    if (!_Socket)
    {
        INET_ASSERT(FALSE);
    }
    else
    {
        _Socket->SetAuthenticated();
    }
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    IsAuthenticated -

Return Value:

    BOOL

--*/

{
    return (_Socket ? _Socket->IsAuthenticated() : FALSE);
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::SetObjectName(
    LPSTR lpszObjectName,
    LPSTR lpszExtension,
    URLGEN_FUNC * procProtocolUrl
    )
{
    DWORD   dwLen, dwError;
    INTERNET_SCHEME schemeType;

    //
    // if there is already an object name, then free it. We are replacing it
    //

    //
    // BUGBUG - make _CacheUrlString an ICSTRING
    //

    FreeURL();

    //
    // get protocol specific url
    //

    if (procProtocolUrl) {

        //
        // if we are going via proxy AND this is an FTP object AND the user name
        // consists of <username>@<servername> then <servername> is the real
        // server name, and _HostName is the name of the proxy
        //

        //
        // BUGBUG - this is a bit of a hack(!)
        //
        // Note: FTP support has been removed (ssulzer, 3/2000).
        //

        LPSTR target = _HostName.StringAddress();

        schemeType = GetSchemeType();

        // make the scheme type https if necessary

        schemeType = (((schemeType == INTERNET_SCHEME_DEFAULT)||
                      (schemeType == INTERNET_SCHEME_HTTP)) &&
                      (GetOpenFlags() & WINHTTP_FLAG_SECURE))?
                      INTERNET_SCHEME_HTTPS: schemeType;

        LPSTR lpszNewUrl = NULL;

        dwError = (*procProtocolUrl)(schemeType,
                                     target,
                                     NULL,
                                     lpszObjectName,
                                     lpszExtension,
                                     _HostPort,
                                     &lpszNewUrl,
                                     &dwLen
                                     );

        if (dwError == ERROR_SUCCESS) {

            if (!SetURLPtr (&lpszNewUrl)) {
                FREE_MEMORY (lpszNewUrl);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (dwError == ERROR_SUCCESS) {

        DEBUG_PRINT(HANDLE,
                    INFO,
                    ("Url: %s\n",
                    _CacheUrlName
                    ));

    }
    return dwError;
}


//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::GetUserAndPass
    (BOOL fProxy, LPSTR *pszUser, LPSTR *pszPass)
{
    DWORD dwUser, dwPass;
    
    if (fProxy)
    {
        dwUser = WINHTTP_OPTION_PROXY_USERNAME & WINHTTP_OPTION_MASK;
        dwPass = WINHTTP_OPTION_PROXY_PASSWORD & WINHTTP_OPTION_MASK;
    }
    else
    {
        dwUser = WINHTTP_OPTION_USERNAME & WINHTTP_OPTION_MASK;
        dwPass = WINHTTP_OPTION_PASSWORD & WINHTTP_OPTION_MASK;
    }
    
    *pszUser = _xsProp[dwUser].GetPtr();
    *pszPass = _xsProp[dwPass].GetPtr();
    if (*pszUser && *pszPass)
        return TRUE;
    else        
    {
        *pszUser = NULL;
        *pszPass = NULL;
        return FALSE;
    }
}

//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::SetURL (LPSTR lpszUrl)
{
    LPSTR lpszNew;

    // Make an undecorated copy of the URL.

    lpszNew = NewString(lpszUrl);
    if (!lpszNew)
        return FALSE;

    // Clear any previous cache key and record the new one.
    FreeURL();
    INET_ASSERT (lpszNew);
    _CacheUrlName = lpszNew;
    return TRUE;
}

//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::SetURLPtr(LPSTR* ppszUrl)
{
    // Swap in the new URL as the cache key.
    FreeURL();
    _CacheUrlName = *ppszUrl;
    *ppszUrl = NULL;
    return TRUE;
}

//=============================================================================
DWORD HTTP_REQUEST_HANDLE_OBJECT::SetServerInfoWithScheme(
    IN INTERNET_SCHEME tScheme,
    IN BOOL bDoResolution,
    IN OPTIONAL BOOL fNtlm
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name for which this object was created and an optional scheme
    type

Arguments:

    tScheme         - scheme type we want SERVER_INFO for

    bDoResolution   - TRUE if we are to resolve the host name if creating a new
                      SERVER_INFO object

    fNtlm           - TRUE if we are tunnelling for NTLM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%s (%d), %B, %B",
                 InternetMapScheme(tScheme),
                 tScheme,
                 bDoResolution,
                 fNtlm
                 ));


    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

//dprintf("getting server info for %q (current = %q)\n", hostName, GetHostName());

    INTERNET_HANDLE_OBJECT * lpParent = GetRootHandle (this);

    DWORD error = lpParent->GetServerInfo(GetHostName(),
                                INTERNET_SERVICE_HTTP,
                                bDoResolution,
                                &_ServerInfo
                                );
    DEBUG_LEAVE(error);

    return error;
}


//=============================================================================
DWORD HTTP_REQUEST_HANDLE_OBJECT::SetServerInfo(
    IN LPSTR lpszServerName,
    IN DWORD dwServerNameLength
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name in the parameters

Arguments:

    lpszServerName      - name of server

    dwServerNameLength  - length of lpszServerName

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%q, %d",
                 lpszServerName,
                 dwServerNameLength
                 ));

    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

    char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    int copyLength = (int)min(sizeof(hostName) - 1, dwServerNameLength);

    memcpy(hostName, lpszServerName, copyLength);
    hostName[copyLength] = '\0';

    INTERNET_HANDLE_OBJECT * lpParent = GetRootHandle (this);
    DWORD error = lpParent->GetServerInfo(hostName,
                                INTERNET_SERVICE_HTTP,
                                FALSE,
                                &_ServerInfo
                                );

    DEBUG_LEAVE(error);

    return error;
}

//=============================================================================
VOID HTTP_REQUEST_HANDLE_OBJECT::SetOriginServer(
    IN CServerInfo * pServerInfo
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pServerInfo -

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer",
                 "%#x{%q}",
                 pServerInfo,
                 pServerInfo ? pServerInfo->GetHostName() : ""
                 ));

    if (_OriginServer == NULL) {
        _OriginServer = pServerInfo;
        if (pServerInfo != NULL) {
            pServerInfo->Reference();
        }
    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ScheduleWorkItem()
{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ScheduleWorkItem",
                 NULL
                 ));

    CFsm *pFsm = NULL;
    DWORD dwError = ERROR_SUCCESS;
        
    _FsmWorkItemList.DequeueHead(&pFsm);
    if (pFsm)
    {
        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("Queueing work item %#x with %d blocked async work items remaining\n",
                    pFsm,
                    _FsmWorkItemList.GetCount()
                    ));

        pFsm->SetThreadInfo(InternetGetThreadInfo());
        pFsm->SetPushPop(TRUE);
        pFsm->Push();
        dwError = pFsm->QueueWorkItem();
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\add.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    add.cxx

Abstract:

    This file contains the implementation of the HttpAddRequestHeadersA API.

    The following functions are exported by this module:

        HttpAddRequestHeadersA
        WinHttpAddRequestHeaders

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpAddRequestHeadersA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private manifests
//

#define VALID_ADD_FLAGS (HTTP_ADDREQ_FLAG_ADD_IF_NEW \
                        | HTTP_ADDREQ_FLAG_ADD \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA \
                        | HTTP_ADDREQ_FLAG_REPLACE \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON \
                        )

//
// functions
//


INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle

Arguments:

    hRequest        - An open HTTP request handle returned by HttpOpenRequest()

    lpszHeaders     - The headers to append to the request. Each header must be
                      terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is -1L
                      then lpszHeaders is assumed to be zero terminated (ASCIIZ)

    dwModifiers     - flags controlling operation. Can be one or more of:

                        HTTP_ADDREQ_FLAG_ADD_IF_NEW
                            - add the header, but only if it does not already
                              exist. Index must be zero

                        HTTP_ADDREQ_FLAG_ADD
                            - if HTTP_ADDREQ_FLAG_REPLACE is set, but the header
                              is not found and this flag is set then the header
                              is added, so long as there is a valid header-value

                        HTTP_ADDREQ_FLAG_COALESCE
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
                            - concatenate headers of same name. E.g. if we
                              already have "Accept: text/html" then adding
                              "Accept: text/*" will create
                              "Accept: text/html, text/*"

                        HTTP_ADDREQ_FLAG_REPLACE
                            - replaces the named header. Only one header can be
                              supplied. If header-value is empty then the header
                              is removed

Return Value:

    Success - TRUE
                The header was appended successfully

    Failure - FALSE
                The operation failed. Error status is available by calling
                GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpAddRequestHeadersA",
                     "%#x, %.80q, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD error;
    HINTERNET hRequestMapped = NULL;
    DWORD nestingLevel = 0;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    INET_ASSERT(!(
    (lpszHeaders == NULL)
    || (*lpszHeaders == '\0')
    || (dwHeadersLength == 0)
    || (dwModifiers & (HTTP_ADDREQ_FLAGS_MASK & ~VALID_ADD_FLAGS))) );

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // BUGBUG - we should determine whether the app is trying to give us a bogus
    //          header, and whether the header conforms to the format:
    //
    //                          "<header>[:[ <value>]]"
    //

    if (dwHeadersLength == (DWORD)-1) 
    {
        dwHeadersLength = (DWORD)lstrlen(lpszHeaders);
    }
        
    if (error == ERROR_SUCCESS) {
        error = wHttpAddRequestHeaders(hRequestMapped,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwModifiers
                                       );
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE_API(error == ERROR_SUCCESS);

    return error == ERROR_SUCCESS;
}


INTERNETAPI
BOOL
WINAPI
WinHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    lpszHeaders - The headers to append to the request. Each header must be
        terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is
        -1L, then lpszHeaders is assumed to be zero terminated (ASCIIZ).

    dwModifiers     -

Return Value:

    TRUE - The header was appended successfully.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpAddRequestHeaders",
                     "%#x, %.80wq, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!lpszHeaders 
        || *lpszHeaders==L'\0' 
        || !dwHeadersLength
        || ((dwHeadersLength == -1)
            ? IsBadStringPtrW(lpszHeaders, -1)
            : IsBadReadPtr(lpszHeaders, dwHeadersLength))
        || (dwModifiers & (HTTP_ADDREQ_FLAGS_MASK & ~VALID_ADD_FLAGS)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        MEMORYPACKET mpHeaders;
        ALLOC_MB(lpszHeaders, (dwHeadersLength==-1L ? 0 : dwHeadersLength), mpHeaders);
        if (mpHeaders.psStr)
        {
            UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
            fResult = HttpAddRequestHeadersA(hRequest, mpHeaders.psStr, mpHeaders.dwSize, dwModifiers);
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Worker function to append additional header(s) to an HTTP request handle

Arguents:

    hRequest        - handle of HTTP request

    lpszHeaders     - pointer to buffer containing one or more headers

    dwHeadersLength - length of lpszHeaders. Cannot be -1 at this stage

    dwModifiers     - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The header string(s) was bad after all

                  ERROR_WINHTTP_INCORRECT_HANDLE_STATE
                    We can't add headers to this object at this time

                  ERROR_HTTP_HEADER_NOT_FOUND
                    We were asked to replace a header, but couldn't find it

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    We were asked to add a header, only if one of the same name
                    doesn't already exist. It does

--*/

{
    //
    // dwHeadersLength cannot be -1 or 0 at this stage. Nor can lpszHeaders be
    // NULL
    //

    INET_ASSERT(lpszHeaders != NULL);
    INET_ASSERT(dwHeadersLength != (DWORD)-1);
    INET_ASSERT(dwHeadersLength != 0);

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "wHttpAddRequestHeaders",
                 "%#x, %#x [%.80q], %d, %#x",
                 hRequest,
                 lpszHeaders,
                 lpszHeaders,
                 dwHeadersLength,
                 dwModifiers
                 ));

    //
    // get the underlying object and check that we can add headers
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    DWORD error;

    if (!IS_VALID_HTTP_STATE(pRequest, ADD, TRUE)) {
        error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    DWORD offset;
    LPSTR header;

    offset = 0;
    header = (LPSTR)lpszHeaders;

    do {

        //
        // first time: ignore any empty strings; subsequent time: clean off any
        // trailing line termination
        //

        while ((offset < dwHeadersLength)
        && ((lpszHeaders[offset] == '\r') || (lpszHeaders[offset] == '\n'))) {
            ++offset;
        }
        if (offset == dwHeadersLength) {

            //
            // even if app tried adding empty line(s), we return success
            //

            error = ERROR_SUCCESS;
            break;
        }

        DWORD length;
        DWORD nameLength;
        DWORD valueLength;
        LPSTR value;
        BOOL done;

        nameLength = 0;
        valueLength = 0;
        value = NULL;

        //
        // break the header into header-name, header-value pairs. Exclude CR-LF
        // from the header-value (if present)
        //

        for (length = 0, header = (LPSTR)&lpszHeaders[offset];
            offset < dwHeadersLength;
            ++length, ++offset) {

            char ch = header[length];

            if ((ch == '\r') || (ch == '\n')) {

                //
                // end of this particular header
                //

                break;
            } else if (ch == ':') {
                if (nameLength == 0) {

                    //
                    // found end of header name
                    //

                    nameLength = length;
                    value = &header[length];
                }
            }
        }
        if (length == 0) {

            //
            // empty string
            //

            continue;
        } else if (nameLength == 0) {

            //
            // entry consists of just header-name (e.g. "Accept[\r\n]")
            //

            nameLength = length;
        } else {

            //
            // find the start of the header-value
            //

            valueLength = (DWORD) (header + length - value);

            //
            // N.B. We are allowing any mixture of ':' and ' ' between header
            // name and value, but this is probably not a big deal...
            //

            while ((*value == ':') || (*value == ' ') && (valueLength != 0)) {
                ++value;
                --valueLength;
            }
        }
        if (dwModifiers
            & (HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD_IF_NEW)) {

            //
            // replace or remove the header
            //

            error = pRequest->ReplaceRequestHeader(
                                header,
                                nameLength,
                                value,
                                valueLength,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        } else if (valueLength != 0) {

            //
            // add a single, unterminated header string to the request headers.
            // Since these headers came from the app, we don't trust it to get
            // the header termination right (number & type of line terminators)
            // so we add it ourselves
            //

            error = pRequest->AddRequestHeader(
                                header,
                                nameLength,
                                value,
                                valueLength,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        } else {

            //
            // BUGBUG - we are adding headers, but the header-value is not
            //          present. This is a somewhat tricky situation because we
            //          we may have already added some headers, resulting in
            //          the app not really knowing which headers were good and
            //          which failed; additionally, one or more of the headers
            //          may have been added, increasing the apps confusion. The
            //          best way to handle this (if necessary) is to check the
            //          header name/value pairs w.r.t. the dwModifiers flags.
            //          HOWEVER, even then we can get into a state down here
            //          where we add a couple of headers, then fail...
            //

            error = ERROR_INVALID_PARAMETER;
        }
    } while (error == ERROR_SUCCESS);

quit:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\hdrparse.cxx ===
#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP_HEADER_PARSER implementation
//

HTTP_HEADER_PARSER::HTTP_HEADER_PARSER(
    IN LPSTR szHeaders,
    IN DWORD cbHeaders
    ) : HTTP_HEADERS()

/*++

Routine Description:

    Constructor for the HTTP_HEADER_PARSER object.  Calls ParseHeaders to
      build a parsed version of the header string passed in.

Arguments:

    szHeaders      - pointer to the headers to parse

    cbHeaders      - length of the headers

Return Value:

    None.

--*/

{
    DWORD dwBytesScaned = 0;
    BOOL fFoundCompleteLine;
    BOOL fFoundEndOfHeaders;
    DWORD error;

    error = ParseHeaders(
        szHeaders,
        cbHeaders,
        TRUE, // Eof
        &dwBytesScaned,
        &fFoundCompleteLine,
        &fFoundEndOfHeaders
        );

    INET_ASSERT(error == ERROR_SUCCESS);
    INET_ASSERT(fFoundCompleteLine);
    INET_ASSERT(fFoundEndOfHeaders);
}


BOOL
HTTP_HEADER_PARSER::ParseStatusLine(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT DWORD *lpdwStatusCode,
    OUT DWORD *lpdwMajorVersion,
    OUT DWORD *lpdwMinorVersion
    )

/*++

Routine Description:

    Parses the Status line of an HTTP server response.  Takes care of adding the status
     line to HTTP header array.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    BOOL  - TRUE if line was successively parsed and processed, FALSE otherwise

--*/

{

#define BEFORE_VERSION_NUMBERS 0
#define MAJOR_VERSION_NUMBER   1
#define MINOR_VERSION_NUMBER   2
#define STATUS_CODE_NUMBER     3
#define AFTER_STATUS_CODE      4
#define MAX_STATUS_INTS        4

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    DWORD dwStatusLineSize = 0;
    LPSTR lpszStatusLine;
    int ver_state = BEFORE_VERSION_NUMBERS;
    DWORD adwStatusInts[MAX_STATUS_INTS];
    BOOL success = TRUE;

    for ( int i = 0; i < MAX_STATUS_INTS; i++)
        adwStatusInts[i] = 0;

    lpszStatusLine = response;

    //
    // While walking the Status Line looking for terminating \r\n,
    //   we extract the Major.Minor Versions and Status Code in that order.
    //   text and spaces will lie between/before/after the three numbers
    //   but the idea is to remeber which number we're calculating based on a numeric state
    //   If all goes well the loop will churn out an array with the 3 numbers plugged in as DWORDs
    //

    while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
    {
        // below should be wrapped in while (response[i] != ' ') to be more robust???
        switch (ver_state)
        {
            case BEFORE_VERSION_NUMBERS:
                if (*response == '/')
                {
                    INET_ASSERT(ver_state == BEFORE_VERSION_NUMBERS);
                    ver_state++; // = MAJOR_VERSION_NUMBER
                }
                else if (*response == ' ')
                {
                    ver_state = STATUS_CODE_NUMBER;
                }

                break;

            case MAJOR_VERSION_NUMBER:

                if (*response == '.')
                {
                    INET_ASSERT(ver_state == MAJOR_VERSION_NUMBER);
                    ver_state++; // = MINOR_VERSION_NUMBER
                    break;
                }
                // fall through

            case MINOR_VERSION_NUMBER:

                if (*response == ' ')
                {
                    INET_ASSERT(ver_state == MINOR_VERSION_NUMBER);
                    ver_state++; // = STATUS_CODE_NUMBER
                    break;
                }
                // fall through

            case STATUS_CODE_NUMBER:

                if (isdigit(*response)) {
                    int val = *response - '0';
                    adwStatusInts[ver_state] = adwStatusInts[ver_state] * 10 + val;
                }
                else if ( adwStatusInts[STATUS_CODE_NUMBER] > 0 )
                {
                    //
                    // we eat spaces before status code is found,
                    //  once we have the status code we can go on to the next
                    //  state on the next non-digit. This is done
                    //  to cover cases with several spaces between version
                    //  and the status code number.
                    //

                    INET_ASSERT(ver_state == STATUS_CODE_NUMBER);
                    ver_state++; // = AFTER_STATUS_CODE
                    break;
                } else if (!isspace(*response)) {
                    adwStatusInts[ver_state] = (DWORD)-1;
                }

                break;

            case AFTER_STATUS_CODE:
                break;

        }

        ++response;
        ++dwBytesScanned;
    }

    dwStatusLineSize = dwBytesScanned;

    if (response == lpszEnd) {

        //
        // response now points one past the end of the buffer. We may be looking
        // over the edge...
        //
        // if we're at the end of the connection then the server sent us an
        // incorrectly formatted response. Probably an error.
        //
        // Otherwise its a partial response. We need more
        //


        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of short response in status line\n"
                    ));

        success = fEof ? TRUE : FALSE;

        //
        // if we really hit the end of the response then update the amount of
        // headers scanned
        //

        if (!success) {
            dwBytesScanned = 0;
        }

        goto quit;

    }

    while ((response < lpszEnd)
    && ((*response == '\r') || (*response == ' '))) {
        ++response;
        ++dwBytesScanned;
    }

    if (response == lpszEnd) {

        //
        // hit end of buffer without finding LF
        //

        success = FALSE;

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("hit end of buffer without finding LF\n"
                    ));

        goto quit;

    } else if (*response == '\n') {
        ++response;
        ++dwBytesScanned;

        //
        // if we found the empty line then we are done
        //

        success = TRUE;
    }


    INET_ASSERT(success);

    //
    // Now we have our parsed header to add to the array
    //

    HEADER_STRING * freeHeader;
    DWORD iSlot;

    freeHeader = FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        INET_ASSERT(FALSE);
        success = FALSE;
        goto quit;
    } else {
        INET_ASSERT(iSlot == 0); // status line should always be first
        freeHeader->CreateOffsetString((DWORD)(lpszStatusLine - lpHeaderBase), dwStatusLineSize);
        freeHeader->SetHash(0); // status line has no hash value.
    }


quit:

    *lpdwStatusCode    = adwStatusInts[STATUS_CODE_NUMBER];
    *lpdwMajorVersion  = adwStatusInts[MAJOR_VERSION_NUMBER];
    *lpdwMinorVersion  = adwStatusInts[MINOR_VERSION_NUMBER];

    *lpdwBufferLengthScanned += dwBytesScanned;

    return success;
}

DWORD
HTTP_HEADER_PARSER::ParseHeaders(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT LPBOOL pfFoundCompleteLine,
    OUT LPBOOL pfFoundEndOfHeaders
    )

/*++

Routine Description:

    Loads headers into HTTP_HEADERS member for subsequent parsing.

    Parses string based headers and adds their parts to an internally stored
    array of HTTP_HEADERS.

    Input is assumed to be well formed Header Name/Value pairs, each deliminated
    by ':' and '\r\n'.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    None.

--*/


{

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;

    *pfFoundEndOfHeaders  = FALSE;

    //
    // Each iteration of the following loop
    // walks an HTTP header line of the form:
    //  HeaderName: HeaderValue\r\n
    //

    do
    {
        DWORD dwHash = HEADER_HASH_SEED;
        LPSTR lpszHeaderName;
        DWORD dwHeaderNameLength = 0;
        DWORD dwHeaderLineLength = 0;
        DWORD dwPreviousAmountOfBytesScanned = dwBytesScanned;

        //
        // Remove leading whitespace from header
        //

        while ( (response < lpszEnd) && ((*response == ' ') || (*response == '\t')) )
        {
            ++response;
            ++dwBytesScanned;
        }

        //
        // Scan for HeaderName:
        //

        lpszHeaderName = response;
        dwPreviousAmountOfBytesScanned = dwBytesScanned;

        while ((response < lpszEnd) && (*response != ':') && (*response != '\r') && (*response != '\n'))
        {
            //
            // This code incapsulates CalculateHashNoCase as an optimization,
            //   we attempt to calculate the Hash value as we parse the header.
            //

            CHAR ch = *response;

            if ((ch >= 'A') && (ch <= 'Z')) {
                ch = MAKE_LOWER(ch);
            }
            dwHash += (DWORD)(dwHash << 5) + ch;

            ++response;
            ++dwBytesScanned;
        }

        dwHeaderNameLength = (DWORD) (response - lpszHeaderName);

        //
        // catch bogus responses: if we find what looks like one of a (very)
        // small set of HTML tags, then assume the previous header was the
        // last
        //

        if ((dwHeaderNameLength >= sizeof("<HTML>") - 1)
            && (*lpszHeaderName == '<')
            && (!strnicmp(lpszHeaderName, "<HTML>", sizeof("<HTML>") - 1)
                || !strnicmp(lpszHeaderName, "<HEAD>", sizeof("<HEAD>") - 1))) {
            *pfFoundEndOfHeaders  = TRUE;
            break;
        }

        //
        // Keep scanning till end of the line.
        //

        while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
        {
            ++response;
            ++dwBytesScanned;
        }

        dwHeaderLineLength = (DWORD) (response - lpszHeaderName); // note: this headerLINElength

        if (response == lpszEnd) {

            //
            // response now points one past the end of the buffer. We may be looking
            // over the edge...
            //
            // if we're at the end of the connection then the server sent us an
            // incorrectly formatted response. Probably an error.
            //
            // Otherwise its a partial response. We need more
            //


            DEBUG_PRINT(HTTP,
                        INFO,
                        ("found end of short response\n"
                        ));

            success = fEof ? TRUE : FALSE;

            //
            // if we really hit the end of the response then update the amount of
            // headers scanned
            //

            if (!success) {
                dwBytesScanned = dwPreviousAmountOfBytesScanned;
            }

            break;

        }
        else
        {

            //
            // we reached a CR or LF. This is the end of this current header. Find
            // the start of the next one
            //

            //
            // first, strip off any trailing spaces from the current header. We do
            // this by simply reducing the string length. We only look for space
            // and tab characters. Only do this if we have a non-zero length header
            //

            if (dwHeaderLineLength != 0) {
                for (int i = -1; response[i] == ' ' || response[i] == '\t'; --i) {
                    --dwHeaderLineLength;
                }
            }

            INET_ASSERT((int)dwHeaderLineLength >= 0);

            //
            // some servers respond with "\r\r\n". Lame
            // A new twist: "\r \r\n". Lamer
            //

            while ((response < lpszEnd)
            && ((*response == '\r') || (*response == ' '))) {
                ++response;
                ++dwBytesScanned;
            }
            if (response == lpszEnd) {

                //
                // hit end of buffer without finding LF
                //

                success = FALSE;

                DEBUG_PRINT(HTTP,
                            WARNING,
                            ("hit end of buffer without finding LF\n"
                            ));

                //
                // get more data, reparse this line
                //

                dwBytesScanned = dwPreviousAmountOfBytesScanned;
                break;
            } else if (*response == '\n') {
                ++response;
                ++dwBytesScanned;

                //
                // if we found the empty line then we are done
                //

                if (dwHeaderLineLength == 0) {
                    *pfFoundEndOfHeaders  = TRUE;
                    break;
                }

                success = TRUE;
            }
        }

        //
        // Now we have our parsed header to add to the array
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);
            goto quit;

        } else {
            freeHeader->CreateOffsetString((DWORD) (lpszHeaderName - lpHeaderBase), dwHeaderLineLength);
            freeHeader->SetHash(dwHash);
        }


        //CHAR szTemp[256];
        //
        //memcpy(szTemp, lpszHeaderName, dwHeaderLineLength);
        //lpszHeaderName[dwHeaderLineLength] = '\0';

        //DEBUG_PRINT(HTTP,
        //    INFO,
        //    ("ParseHeaders: adding=%q\n", lpszHeaderName
        //    ));


        //
        // Now see if this is a known header we are adding, if so then we note that fact
        //

        DWORD dwKnownQueryIndex;

        if (HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwKnownQueryIndex) )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwKnownQueryIndex, iSlot));
        }
    } while (TRUE);

quit:

    *lpdwBufferLengthScanned += dwBytesScanned;
    *pfFoundCompleteLine = success;

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\httpp.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httpp.h

Abstract:

    Private master include file for the HTTP API project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

//
//  Local include files.
//

#include "proc.h"
#include "headers.h"

extern
BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\httptime.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httptime.h

Abstract:

    This file contains the numerical defines for the date/parsing routines located
    in the httptime.cxx file.

Author:

    Arthur Bierer (arthurbi) 12-Dec-1997

Revision History:

--*/


#ifndef _HTTPTIME_H_
#define _HTTPTIME_H_

#define BASE_DEC 10 // base 10

//
// Date indicies used to figure out what each entry is.
//


#define DATE_INDEX_DAY_OF_WEEK     0

#define DATE_1123_INDEX_DAY        1
#define DATE_1123_INDEX_MONTH      2
#define DATE_1123_INDEX_YEAR       3
#define DATE_1123_INDEX_HRS        4
#define DATE_1123_INDEX_MINS       5
#define DATE_1123_INDEX_SECS       6

#define DATE_ANSI_INDEX_MONTH      1
#define DATE_ANSI_INDEX_DAY        2
#define DATE_ANSI_INDEX_HRS        3
#define DATE_ANSI_INDEX_MINS       4
#define DATE_ANSI_INDEX_SECS       5
#define DATE_ANSI_INDEX_YEAR       6

#define DATE_INDEX_TZ              7

#define DATE_INDEX_LAST            DATE_INDEX_TZ
#define MAX_DATE_ENTRIES           (DATE_INDEX_LAST+1)




//
// DATE_TOKEN's DWORD values used to determine what day/month we're on
//

#define DATE_TOKEN_JANUARY      1
#define DATE_TOKEN_FEBRUARY     2
#define DATE_TOKEN_MARCH        3
#define DATE_TOKEN_APRIL        4
#define DATE_TOKEN_MAY          5
#define DATE_TOKEN_JUNE         6
#define DATE_TOKEN_JULY         7
#define DATE_TOKEN_AUGUST       8
#define DATE_TOKEN_SEPTEMBER    9
#define DATE_TOKEN_OCTOBER      10
#define DATE_TOKEN_NOVEMBER     11
#define DATE_TOKEN_DECEMBER     12       

#define DATE_TOKEN_LAST_MONTH   (DATE_TOKEN_DECEMBER+1)

#define DATE_TOKEN_SUNDAY       0
#define DATE_TOKEN_MONDAY       1
#define DATE_TOKEN_TUESDAY      2                  
#define DATE_TOKEN_WEDNESDAY    3
#define DATE_TOKEN_THURSDAY     4
#define DATE_TOKEN_FRIDAY       5
#define DATE_TOKEN_SATURDAY     6

#define DATE_TOKEN_LAST_DAY     (DATE_TOKEN_SATURDAY+1)
 
#define DATE_TOKEN_GMT          0xFFFFFFFD

#define DATE_TOKEN_LAST         DATE_TOKEN_GMT

#define DATE_TOKEN_ERROR        (DATE_TOKEN_LAST+1)

                            
#endif  // _HTTPTIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\makeconn.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    makeconn.cxx

Abstract:

    This file contains the MakeConnection method

    Contents:
        CFsm_MakeConnection::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_MakeConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_MakeConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    START_SENDREQ_PERF();

    CFsm_MakeConnection * stateMachine = (CFsm_MakeConnection *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->MakeConnection_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm(
    IN CFsm_MakeConnection * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(MakeConnection_Fsm);

    CFsm_MakeConnection & fsm = *Fsm;
    FSM_STATE state = fsm.GetState();
    DWORD error = fsm.GetError();

    INTERNET_HANDLE_OBJECT * pInternet;
    pInternet = GetRootHandle (this);

    if (state == FSM_STATE_INIT) {
        if (GetAuthState() == AUTHSTATE_NEEDTUNNEL) {
            state = FSM_STATE_1;
        } else if (IsTalkingToSecureServerViaProxy()) {
            state = FSM_STATE_3;
        } else {
            state = FSM_STATE_6;
        }
    } else {
        state = fsm.GetFunctionState();
    }
    switch (state) {
    case FSM_STATE_1:

        //
        // If we're attempting to do NTLM authentication using Proxy tunnelling
        // and we don't have a keep-alive socket to use, then create one
        //

        if (!(IsWantKeepAlive() && (_Socket != NULL) && _Socket->IsOpen())) {
            fsm.SetFunctionState(FSM_STATE_2);
            error = OpenProxyTunnel();
            if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
                goto quit;
            }
        } else {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_2:
        if ((error != ERROR_SUCCESS)
        || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
            goto quit;
        }

        //
        // Bind Socket Object with Proper HostName,
        //  so we can check for valid common name
        //  in the handshake.
        //

        if (_Socket->IsSecure()) {
            /* SCLE ref */
            error = ((ICSecureSocket *)_Socket)->SetHostName(GetHostName(), pInternet->GetSslSessionCache());
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        }

        //
        // Undo the proxy-ified info found in this Request Object, make it seem like
        //  we're doing a connect connection, since we're about to do something like it
        //  ( a tunnelled connection through the firewall )
        //

        error = SetServerInfoWithScheme(INTERNET_SCHEME_HTTP, FALSE);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        LPSTR urlPath;
        DWORD urlPathLength;

        //
        // get URL-path again if it was changed during tunnel creation
        //

        error = CrackUrl(GetURL(),
                     lstrlen(GetURL()),
                     FALSE, // don't escape URL-path
                     NULL,  // don't care about scheme type
                     NULL,  // or scheme name
                     NULL,  // or scheme name length
                     NULL,  // or host name
                     NULL,  // or host name length
                     NULL,  // or port
                     NULL,  // or user name
                     NULL,  // or user name length
                     NULL,  // or password
                     NULL,  // or password length
                     &urlPath,
                     &urlPathLength,
                     NULL,  // don't care about extra
                     NULL,  // or extra length
                     NULL
                     );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        if (LockHeaders())
        {
            ModifyRequest(HTTP_METHOD_TYPE_GET,
                          urlPath,
                          urlPathLength,
                          NULL,
                          0
                          );

            UnlockHeaders();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        //SetProxyNTLMTunnelling(FALSE);
        SetRequestUsingProxy(FALSE);             // don't generate proxy stuff.
        break;

    case FSM_STATE_3:

        //
        // Hack for SSL2 Client Hello bug in IIS Servers.
        //  Need to ReOpen connection after failure with
        //  a Client Hello Message.
        //

        if (_Socket != NULL) {
            ((ICSecureSocket *)_Socket)->SetProviderIndex(0);
        }

attempt_ssl_connect:

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_4);
        error = OpenProxyTunnel();
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_4:
        if ((error != ERROR_SUCCESS) || (GetStatusCode() != HTTP_STATUS_OK)) {
            goto quit;
        }

        //
        // Bind Socket Object with Proper HostName,
        //  so we can check for valid common name
        //  in the handshake.
        //

        INET_ASSERT(_Socket->IsSecure());

        /* SCLE ref */
        error = ((ICSecureSocket *)_Socket)->SetHostName(GetHostName(), pInternet->GetSslSessionCache());
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // if the app wants a secure channel (PCT/SSL) then we must negotiate
        // the security here
        //

        //
        // dwProviderIndex will be managed by SecureHandshakeWithServer,
        // And will be set to 0 when we can't try anymore.
        //

        DWORD asyncFlags;

        //
        // find out if we're async. N.B. see Assumes
        //

        asyncFlags = IsAsyncHandle() ? SF_NON_BLOCKING : 0;

        //
        // If we're Posting or sending data, make sure
        //  the SSL connection knows about it, for the
        //  purposes of generating errors.
        //

        if ((GetMethodType() == HTTP_METHOD_TYPE_POST)
        || (GetMethodType() == HTTP_METHOD_TYPE_PUT)) {
            asyncFlags |= SF_SENDING_DATA;
        }

        fsm.SetFunctionState(FSM_STATE_5);
        error = ((ICSecureSocket *)_Socket)->SecureHandshakeWithServer(
                                                (asyncFlags | SF_ENCRYPT),
                                                &fsm.m_bAttemptReconnect);
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_5:
        if (error != ERROR_SUCCESS) {

            if (error == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED)
            {
                if (_Socket->IsSecure())
                {
                    if(m_pSecurityInfo)
                    {
                        /* SCLE ref */
                        m_pSecurityInfo->Release();
                    }
                    /* SCLE ref */
                    m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
                }
            }

            //
            // we disconnected the socket and we won't attempt to reconnect. We
            // need to release the connection to balance the connection limiter
            //

            if (!fsm.m_bAttemptReconnect)
            {
                ReleaseConnection(TRUE,     // bClose
                                  FALSE,    // bIndicate
                                  TRUE      // bDispose
                                  );
            }
            else
            {
                _Socket->Disconnect();
            }
        }

        //
        // SSL2 hack for old IIS servers.
        //  We re-open the socket, and call again.
        //

        if (fsm.m_bAttemptReconnect) {
            goto attempt_ssl_connect;
        }
        break;

    case FSM_STATE_6:
        fsm.SetFunctionState(FSM_STATE_7);
        error = OpenConnection(FALSE, FALSE);
        if (error == ERROR_IO_PENDING) {
            break;
        }

    case FSM_STATE_7:
//dprintf("HTTP connect took %d msec\n", GetTickCount() - _dwQuerySetCookieHeader);
        //hack
        if (error == ERROR_SUCCESS &&
            _Socket &&
            _Socket->IsSecure() &&
            m_pSecurityInfo == NULL
            )
        {
            /* SCLE ref */
            m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
        }
        break;

    default:

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        break;
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
//        PERF_LEAVE(MakeConnection_Fsm);

    }
        PERF_LEAVE(MakeConnection_Fsm);

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\headers.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    headers.cxx

Abstract:

    Contents:

        HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer
        HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader
        HTTP_REQUEST_HANDLE_OBJECT::AddInternalResponseHeader
        HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::QueryResponseVersion
        HTTP_REQUEST_HANDLE_OBJECT::QueryStatusCode
        HTTP_REQUEST_HANDLE_OBJECT::QueryStatusText
        HTTP_REQUEST_HANDLE_OBJECT::QueryRawResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::RemoveAllRequestHeadersByName
        HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders
        MapHttpMethodType
        CreateEscapedUrlPath
        (CalculateHashNoCase)
Author:

    Richard L Firth (rfirth) 20-Dec-1995

Revision History:

    20-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

VOID
HTTP_REQUEST_HANDLE_OBJECT::ReplaceStatusHeader(
    IN LPCSTR lpszStatus
    )
/*
Description:
    Replace the status line in a header (eg. "200 OK") with the specified text.
Arguments:
    lpszStatus	- Status text (eg. "200 OK")
Return Value:
    None
*/
{
    LockHeaders();
    
    //INET_ASSERT (!_CacheWriteInProgress);
    
    LPSTR pszHeader = _ResponseHeaders.GetHeaderPointer(_ResponseBuffer, 0);
    
    INET_ASSERT(pszHeader);
    
    LPSTR pszStatus = StrChr (pszHeader, ' ');
    SKIPWS(pszStatus);
    
    INET_ASSERT (!memcmp(pszStatus, "206", 3));
    
    memcpy(pszStatus, lpszStatus, lstrlen(lpszStatus)+1);
    _ResponseHeaders.ShrinkHeader(_ResponseBuffer, 0,
        HTTP_QUERY_STATUS_TEXT, HTTP_QUERY_STATUS_TEXT,
        (DWORD) (pszStatus - pszHeader) + lstrlen(lpszStatus));
    
    UnlockHeaders();
}


LPSTR
HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer(
    OUT LPDWORD lpdwRequestLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength,
    IN BOOL bExtraCrLf,
    IN DWORD dwMaxPacketLength,
    OUT LPBOOL lpbCombinedData
    )

/*++

Routine Description:

    Creates a request buffer from the HTTP request and headers

Arguments:

    lpdwRequestLength   - pointer to returned buffer length

    lpOptional          - pointer to optional data

    dwOptionalLength    - length of optional data

    bExtraCrLf          - TRUE if we need to add additional CR-LF to buffer

    dwMaxPacketLength   - maximum length of buffer

    lpbCombinedData     - output TRUE if data successfully combined into one

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer",
                 "%#x, %#x, %d, %B, %d, %#x",
                 lpdwRequestLength,
                 lpOptional,
                 dwOptionalLength,
                 bExtraCrLf,
                 dwMaxPacketLength,
                 lpbCombinedData
                 ));

    PERF_ENTER(CreateRequestBuffer);

    LPSTR requestBuffer = NULL;

    *lpbCombinedData = FALSE;

    if (!_RequestHeaders.LockHeaders())
    {
        goto quit;
    }

    DWORD headersLength;
    DWORD requestLength;
    DWORD optionalLength;
    HEADER_STRING * pRequest = _RequestHeaders.GetFirstHeader();
    HEADER_STRING & request = *pRequest;
/*
    WCHAR wszUrl[1024];
    LPWSTR pwszUrl = NULL;
    BYTE utf8Url[2048];
    LPBYTE pbUrl = NULL;
*/
    LPSTR pszObject = _RequestHeaders.ObjectName();
    DWORD dwObjectLength = _RequestHeaders.ObjectNameLength();

    if (pRequest == NULL) {
        goto Cleanup;
    }

    INET_ASSERT(request.HaveString());

    headersLength = _RequestHeaders.HeadersLength();
    requestLength = headersLength + (sizeof("\r\n") - 1);

/*------------------------------------------------------------------
    GlobalEnableUtf8Encoding = FALSE;
    if (GlobalEnableUtf8Encoding
        && StringContainsHighAnsi(pszObject, dwObjectLength)) {

        pwszUrl = wszUrl;

        DWORD arrayElements = ARRAY_ELEMENTS(wszUrl);

        if (dwObjectLength > ARRAY_ELEMENTS(wszUrl)) {
            arrayElements = dwObjectLength;
            pwszUrl = (LPWSTR)ALLOCATE_FIXED_MEMORY(arrayElements * sizeof(*pwszUrl));
            if (pwszUrl == NULL) {
                goto utf8_cleanup;
            }
        }



        PFNINETMULTIBYTETOUNICODE pfnMBToUnicode;
        pfnMBToUnicode = GetInetMultiByteToUnicode( );
        if (pfnMBToUnicode == NULL) {
            goto utf8_cleanup;
        }

        HRESULT hr;
        DWORD dwMode;
        INT nMBChars;
        INT nWChars;

        nMBChars = dwObjectLength;
        nWChars = arrayElements;
        dwMode = 0;

        hr = pfnMBToUnicode(&dwMode,
                                GetCodePage(),
                                pszObject,
                                &nMBChars,
                                pwszUrl,
                                &nWChars
                               );
        if (hr != S_OK || nWChars == 0) {
            goto utf8_cleanup;
        }

        DWORD nBytes;

        nBytes = CountUnicodeToUtf8(pwszUrl, (DWORD)nWChars, TRUE);
        pbUrl = utf8Url;
        if (nBytes > ARRAY_ELEMENTS(utf8Url)) {
            pbUrl = (LPBYTE)ALLOCATE_FIXED_MEMORY(nBytes);
            if (pbUrl == NULL) {
                goto utf8_cleanup;
            }
        }

        DWORD error;

        error = ConvertUnicodeToUtf8(pwszUrl,
                                     (DWORD)nWChars,
                                     pbUrl,
                                     nBytes,
                                     TRUE
                                     );

        INET_ASSERT(error == ERROR_SUCCESS);

        if (error != ERROR_SUCCESS) {
            goto utf8_cleanup;
        }

        requestLength = requestLength - dwObjectLength + nBytes;
        headersLength = headersLength - dwObjectLength + nBytes;
        pszObject = (LPSTR)pbUrl;
        dwObjectLength = nBytes;
        goto after_utf8;

utf8_cleanup:

        if ((pwszUrl != wszUrl) && (pwszUrl != NULL)) {
            FREE_MEMORY(pwszUrl);
        }
        pwszUrl = NULL;
        if ((pbUrl != utf8Url) && (pbUrl != NULL)) {
            FREE_MEMORY(pbUrl);
        }
        pbUrl = NULL;
        pszObject = NULL;
        dwObjectLength = 0;
    }

after_utf8:
------------------------------------------------------------------*/

    optionalLength = (DWORD)(dwOptionalLength + (bExtraCrLf ? (sizeof("\r\n") - 1) : 0));
    if (requestLength + optionalLength <= dwMaxPacketLength) {
        requestLength += optionalLength;
    } else {
        optionalLength = 0;
        bExtraCrLf = FALSE;
    }

    requestBuffer = (LPSTR)ResizeBuffer(NULL, requestLength, FALSE);
    if (requestBuffer != NULL) {
        if (optionalLength != 0) {
            *lpbCombinedData = TRUE;
        }
    } else if (optionalLength != 0) {
        requestLength = headersLength + (sizeof("\r\n") - 1);
        optionalLength = 0;
        bExtraCrLf = FALSE;
        requestBuffer = (LPSTR)ResizeBuffer(NULL, requestLength, FALSE);
    }
    if (requestBuffer != NULL) {

        LPSTR buffer = requestBuffer;

        //
        // copy the headers. Remember: header 0 is the request
        //

        if (ERROR_SUCCESS != _RequestHeaders.CopyHeaders(&buffer, pszObject, dwObjectLength))
        {
            ResizeBuffer(requestBuffer, 0, FALSE);
            requestBuffer = buffer = NULL;
            goto Cleanup;
        }

        //
        // terminate the request
        //

        *buffer++ = '\r';
        *buffer++ = '\n';

        if (optionalLength != 0) {
            if (dwOptionalLength != 0) {
                memcpy(buffer, lpOptional, dwOptionalLength);
                buffer += dwOptionalLength;
            }
            if (bExtraCrLf) {
                *buffer++ = '\r';
                *buffer++ = '\n';
            }
        }

        INET_ASSERT((SIZE_T)(buffer-requestBuffer) == requestLength);

        *lpdwRequestLength = requestLength;

    }

Cleanup:

    _RequestHeaders.UnlockHeaders();

    DEBUG_PRINT(HTTP,
                INFO,
                ("request length = %d, combined = %B\n",
                *lpdwRequestLength,
                *lpbCombinedData
                ));

/*
    if ((pbUrl != NULL) && (pbUrl != utf8Url)) {
        FREE_MEMORY(pbUrl);
    }
    if ((pwszUrl != NULL) && (pwszUrl != wszUrl)) {
        FREE_MEMORY(pwszUrl);
    }
*/

quit:
    PERF_LEAVE(CreateRequestBuffer);

    DEBUG_LEAVE(requestBuffer);

    return requestBuffer;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader(
    IN LPCSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Searches for an arbitrary request header and if found, returns its value

Arguments:

    lpszHeaderName      - pointer to the name of the header to find

    dwHeaderNameLength  - length of the header

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of the returned header value, or required
                               length of lpBuffer

    dwModifiers         - how to return the data: as number, as SYSTEMTIME
                          structure, etc.

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer not large enough for results
                    
                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRequestHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));

    PERF_ENTER(QueryRequestHeader);

    DWORD error;

    error = _RequestHeaders.FindHeader(NULL,
                                       lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwModifiers,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       lpdwIndex
                                       );

    PERF_LEAVE(QueryRequestHeader);

    DEBUG_LEAVE(error);

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader(
    IN DWORD dwQueryIndex,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Searches for an arbitrary request header and if found, returns its value

Arguments:

    lpszHeaderName      - pointer to the name of the header to find

    dwHeaderNameLength  - length of the header

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of the returned header value, or required
                               length of lpBuffer

    dwModifiers         - how to return the data: as number, as SYSTEMTIME
                          structure, etc.

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer not large enough for results
                    
                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRequestHeader",
                 "%u, %#x [%#x], %#x, %#x [%d]",
                 dwQueryIndex,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));

    PERF_ENTER(QueryRequestHeader);

    DWORD error;

    error = _RequestHeaders.FindHeader(NULL,
                                       dwQueryIndex,
                                       dwModifiers,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       lpdwIndex
                                       );

    PERF_LEAVE(QueryRequestHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::AddInternalResponseHeader(
    IN DWORD dwHeaderIndex,
    IN LPSTR lpszHeader,
    IN DWORD dwHeaderLength
    )

/*++

Routine Description:

    Adds a created response header to the response header array. Unlike normal
    response headers, this will be a pointer to an actual string, not an offset
    into the response buffer.

    Even if the address of the response buffer changes, created response headers
    will remain fixed

    N.B. The header MUST NOT have a CR-LF terminator
    N.B.-2 This function must be called under the header lock.

Arguments:

    dwHeaderIndex   - index into header value we are actually creating

    lpszHeader      - pointer to created (internal) header to add

    dwHeaderLength  - length of response header, or -1 if ASCIIZ

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddInternalResponseHeader",
                 "%u [%q], %q, %d",
                 dwHeaderIndex,
                 GlobalKnownHeaders[dwHeaderIndex].Text,
                 lpszHeader,
                 dwHeaderLength
                 ));

    DWORD error;

    if (dwHeaderLength == (DWORD)-1) {
        dwHeaderLength = lstrlen(lpszHeader);
    }

    INET_ASSERT((lpszHeader[dwHeaderLength - 1] != '\r')
                && (lpszHeader[dwHeaderLength - 1] != '\n'));

    //
    // find the next slot for this header
    //

    HEADER_STRING * freeHeader;

    //
    // if we already have all the headers (the 'empty' header is the last one
    // in the array) then change the last header to be the one we are adding
    // and add a new empty header, else just add this one
    //

    DWORD iSlot;
    freeHeader = _ResponseHeaders.FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        error = _ResponseHeaders.GetError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {

        HEADER_STRING * lastHeader;

        lastHeader = _ResponseHeaders.GetEmptyHeader();
        if (lastHeader != NULL) {

            //
            // make copy of last header - its an offset string
            //

            *freeHeader = *lastHeader;

            //
            // use what was last header as free header
            //

            freeHeader = lastHeader;
        }
        freeHeader->MakeCopy(lpszHeader, dwHeaderLength);
        freeHeader->SetNextKnownIndex(_ResponseHeaders.FastAdd(dwHeaderIndex, iSlot));
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders(
    IN OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Given the next chunk of the response, updates the response headers. The
    buffer pointer, buffer length and number of bytes received values are all
    maintained in this object (_ResponseBuffer, _ResponseBufferLength and
    _BytesReceived, resp.)

Arguments:

    lpbEof  - IN: TRUE if we have reached the end of the response
              OUT: TRUE if we have reached the end of the response or the end
                   of the headers

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders",
                 "%#x [%.*q], %d, %d, %#x [%B]",
                 _ResponseBuffer + _ResponseScanned,
                 min(_ResponseBufferLength + 1, 80),
                 _ResponseBuffer + _ResponseScanned,
                 _ResponseBufferLength,
                 _BytesReceived,
                 lpbEof,
                 *lpbEof
                 ));

    PERF_ENTER(UpdateResponseHeaders);

    LPSTR lpszBuffer = (LPSTR)_ResponseBuffer + _ResponseScanned;
    DWORD dwBytesReceived = _BytesReceived - _ResponseScanned;
    DWORD error = ERROR_SUCCESS;
    BOOL  success = TRUE;
    HEADER_STRING * statusLine;

    //
    // lock down the response headers for the duration of this request. The only
    // way another thread is going to wait on this lock is if the reference on
    // the HTTP request object goes to zero, which *shouldn't* happen
    //

    if (!_ResponseHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if input EOF is set then the caller is telling us that the end of the
    // response has been reached at transport level (the server closed the
    // connectiion)
    //

    if (*lpbEof) {
        SetEof(TRUE);
    }

    //
    // if we don't yet know whether we have a HTTP/1.0 (or greater) or HTTP/0.9
    // response yet, then try to find out.
    //
    // Only responses greater than HTTP/0.9 start with the "HTTP/#.#" string
    //

    if (!IsDownLevel() && !IsUpLevel()) {

        if ((dwBytesReceived < sizeof("Secure-HTTP/")) && !*lpbEof) {
            goto done;
        }

#define MAKE_VERSION_ENTRY(string)  string, sizeof(string) - 1

        static struct {
            LPSTR Version;
            DWORD Length;
        } KnownVersionsStrings[] = {
            MAKE_VERSION_ENTRY("HTTP/"),
            MAKE_VERSION_ENTRY("S-HTTP/"),
            MAKE_VERSION_ENTRY("SHTTP/"),
            MAKE_VERSION_ENTRY("Secure-HTTP/"),

            //
            // allow for servers generating slightly off-the-wall responses
            //

            MAKE_VERSION_ENTRY("HTTP ")
        };

#define NUM_HTTP_VERSIONS   ARRAY_ELEMENTS(KnownVersionsStrings)

        //
        // We know this is the start of a HTTP response, but there may be some
        // noise at the start from bad HTML authoring, or bad content-length on
        // the previous response on a keep-alive connection. We will try to sync
        // up to the HTTP header (we will only look for this - I have never seen
        // any of the others, and I doubt its worth the increased complexity and
        // processing time)
        //

        LPSTR lpszBuf;
        DWORD bytesLeft;
        BOOL bFoundStart;

        lpszBuf = lpszBuffer;
        bytesLeft = dwBytesReceived;
        bFoundStart = FALSE;

        do {
            while ((bytesLeft > 0) && (*lpszBuf != 'H') && (*lpszBuf != 'h')) {
                ++lpszBuf;
                --bytesLeft;
                ++_ResponseScanned;
            }
            if (bytesLeft == 0) {
                break;
            }

            //
            // scan for the known version strings
            //

            for (int i = 0; i < NUM_HTTP_VERSIONS; ++i) {

                LPSTR version = KnownVersionsStrings[i].Version;
                DWORD length = KnownVersionsStrings[i].Length;

                if ((bytesLeft >= length)

                //
                // try the most common case as a direct comparison. memcmp()
                // should expand to cmpsd && cmpsb on x86 (most common platform
                // and one on which we are most interested in improving perf)
                //

                && (((i == 0)
                    && (memcmp(lpszBuf, "HTTP/", sizeof("HTTP/") - 1) == 0))
                    //&& (lpszBuf[0] == 'H')
                    //&& (lpszBuf[1] == 'T')
                    //&& (lpszBuf[2] == 'T')
                    //&& (lpszBuf[3] == 'P')
                    //&& (lpszBuf[4] == '/'))

                //
                //  "Clients should be tolerant in parsing the Status-Line"
                //  quote from HTTP/1.1 spec, therefore we perform a
                //  case-insensitive string comparison here
                //

                || (_strnicmp(lpszBuf, version, length) == 0))) {

                    //
                    // it starts with one of the recognized protocol version strings.
                    // We assume its not a down-level server, although it could be,
                    // sending back a plain text document that has e.g. "HTTP/1.0..."
                    // at its start
                    //
                    // According to the HTTP "spec", though, it is mentioned that 0.9
                    // servers typically only return HTML, hence we shouldn't see
                    // even a 0.9 response start with non-HTML data
                    //

                    SetUpLevel(TRUE);

                    //
                    // we have start of this response
                    //

                    lpszBuffer = lpszBuf;
                    bFoundStart = TRUE;
                    break;
                }
            }

            //
            // if we didn't find the start of the HTTP response then search again
            //

            if (!bFoundStart) {
                ++lpszBuf;
                --bytesLeft;
                ++_ResponseScanned;
            }
        } while (!bFoundStart && (bytesLeft > 0));

        //
        // if we didn't find a recognizable HTTP 1.x response then we assume its
        // a down-level response
        //

        if (!IsUpLevel()) {

            //
            // if we didn't find the start of a valid HTTP response and we have
            // not filled the response buffer or hit the end of the connection
            // then quit so we can get the next packet
            //

            if ((_BytesReceived < _ResponseBufferLength) && !IsEof()) {

                DEBUG_PRINT(HTTP,
                            WARNING,
                            ("Didn't find start of response. Try again\n"
                            ));

//dprintf("*** didn't find start of response. Try again\n");
                goto done;
            }

            //
            // this may be a real down-level server, or it may be the response
            // from an FTP or gopher server via a proxy, in which case there
            // will be no headers. We will add some default headers to make
            // life easier for higher level software
            //

            AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                      "HTTP/1.0 200 OK",
                                      sizeof("HTTP/1.0 200 OK") - 1
                                      );
            _StatusCode = HTTP_STATUS_OK;
            //SetDownLevel(TRUE);

            //
            // we're now ready for the app to start reading data out
            //

            SetData(TRUE);

            //
            // down-level server: we're done
            //

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Server is down-level\n"
                        ));

            goto done;
        }
    }

    //
    // this stuff's only for uplevel responses, sorry
    //

    INET_ASSERT(IsUpLevel());

    //
    // Note: at this point we can't store pointers into the response buffer
    // because it might move during a subsequent reallocation. We have to
    // maintain offsets into the buffer and convert to pointers when we come to
    // read the data out of the buffer (when the response is complete, or at
    // least we've finished receiving headers)
    //

    //
    // if we haven't checked the response yet, then the first thing to
    // get is the status line
    //

    statusLine = GetStatusLine();

    if (statusLine == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if (!statusLine->HaveString())
    {
        int majorVersion = 0;
        int minorVersion = 0;
        BOOL fSupportsHttp1_1;

        _StatusCode = 0;

        //
        // find the status line
        //

        success = _ResponseHeaders.ParseStatusLine(
            (LPSTR)_ResponseBuffer,
            _BytesReceived,
            IsEof(),
            &_ResponseScanned,
            &_StatusCode,
            (LPDWORD)&majorVersion,
            (LPDWORD)&minorVersion
            );

        if ( !success )
        {
            error = ERROR_SUCCESS;
            goto Cleanup;
        }


        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Version = %d.%d\n",
                    majorVersion,
                    minorVersion
                    ));

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("_StatusCode = %d\n",
                    _StatusCode
                    ));

        fSupportsHttp1_1 = FALSE;

        if ( majorVersion > 1 )
        {
            //
            // for higher version servers, the 1.1 spec dictates
            //  that we return the highest version the client
            //  supports, and in our case that is 1.1.
            //

            fSupportsHttp1_1 = TRUE;
        }
        else if ( majorVersion == 1 )
        {
            if ( minorVersion >= 1 )
            {
                fSupportsHttp1_1 = TRUE;
            }
        } else if ((majorVersion < 0) || (minorVersion < 0)) {
            error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
            goto Cleanup;
        }

        SetResponseHttp1_1(fSupportsHttp1_1);

        //
        // record the server HTTP version in the server info object
        //

        CServerInfo * pServerInfo = GetServerInfo();

        if (pServerInfo != NULL) {
            if (fSupportsHttp1_1) {
                pServerInfo->SetHttp1_1();

                //
                // Set the max connections per HTTP 1.1 server.
                //
                pServerInfo->SetNewLimit(GetMaxConnectionsPerServer(WINHTTP_OPTION_MAX_CONNS_PER_SERVER));
            } else {
                pServerInfo->SetHttp1_0();

                //
                // Set the max connections per HTTP 1.0 server.
                //
                pServerInfo->SetNewLimit(GetMaxConnectionsPerServer(WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER));
            }
        }

        if (_StatusCode == 0) {

            //
            // BUGBUG [arthurbi] malformed header, should we really just accept it?
            //      what if we get indeterminate garbage?
            //


            INET_ASSERT(FALSE);

            AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                          "HTTP/1.0 200 OK",
                          sizeof("HTTP/1.0 200 OK") - 1
                          );
            _StatusCode = HTTP_STATUS_OK;
            error = ERROR_SUCCESS;

            goto Cleanup;
        }
    }

    //
    // continue scanning headers here until we have tested all the current
    // buffer, or we have found the start of the data
    //

    BOOL fFoundEndOfHeaders;

    error = _ResponseHeaders.ParseHeaders(
                (LPSTR)_ResponseBuffer,
                _BytesReceived,
                IsEof(),
                &_ResponseScanned,
                &success,
                &fFoundEndOfHeaders
                );

    if ( error != ERROR_SUCCESS )
    {
        goto Cleanup;
    }


    if ( fFoundEndOfHeaders )
    {
        //
        // we found the end of the headers
        //

        SetEof(TRUE);

        //
        // and the start of the data
        //

        SetData(TRUE);
        _DataOffset = _ResponseScanned;

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of headers. _DataOffset = %d\n",
                    _DataOffset
                    ));

    }

done:

    //
    // if we have reached the end of the headers then we communicate this fact
    // to the caller
    //

    if (IsData() || IsEof()) {
        error = CheckWellKnownHeaders();
        if (ERROR_SUCCESS != error)
        {
            goto Cleanup;
        }
        *lpbEof = TRUE;

        /*

        Set connection persistency based on these rules:

        persistent = (1.0Request && Con: K-A && 1.0Response && Con: K-A)
                     || (1.1Request && Con: K-A && 1.0Response && Con: K-A)
                     || (1.0Request && Con: K-A && 1.1Response && Con: K-A)
                     || (1.1Request && !Con: Close && 1.1Response && !Con: Close)

        therefore,

        persistent = 1.1Request && 1.1Response
                        ? (!Con: Close in request || response)
                        : Con: K-A in request && response

        */

        if (IsRequestHttp1_1() && IsResponseHttp1_1()) {

            BOOL bHaveConnCloseRequest;

            bHaveConnCloseRequest = FindConnCloseRequestHeader(
                                        IsRequestUsingProxy()
                                            ? HTTP_QUERY_PROXY_CONNECTION
                                            : HTTP_QUERY_CONNECTION
                                            );
            if (!(IsConnCloseResponse() || bHaveConnCloseRequest)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("HTTP/1.1 persistent connection\n"
                            ));

                SetKeepAlive(TRUE);
                SetPersistentConnection(IsRequestUsingProxy()
                                        && !IsTalkingToSecureServerViaProxy()
                                        );
            } else {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("HTTP/1.1 non-persistent connection: close on: request: %B; response: %B\n",
                            bHaveConnCloseRequest,
                            IsConnCloseResponse()
                            ));

                SetKeepAlive(FALSE);
                SetNoLongerKeepAlive();
                ClearPersistentConnection();
            }
        }
    }

Cleanup:

    //
    // we are finished updating the response headers (no other thread should be
    // waiting for this if the reference count and object state is correct)
    //

    _ResponseHeaders.UnlockHeaders();

quit:
    PERF_LEAVE(UpdateResponseHeaders);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders(
    IN OUT LPSTR* ppszBuffer,
    IN DWORD      dwBufferLength
    )

/*++

Routine Description:

    Create the response headers given a buffer containing concatenated headers.
    Called when we are creating this object from the cache

Arguments:

    lpszBuffer      - pointer to buffer containing headers

    dwBufferLength  - length of lpszBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create headers

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders",
                 "%.32q, %d",
                 ppszBuffer,
                 dwBufferLength
                 ));

    //
    // there SHOULD NOT already be a response buffer if we're adding an
    // external buffer
    //

    INET_ASSERT(_ResponseBuffer == NULL);

    DWORD error;
    BOOL eof = FALSE;

    _ResponseBuffer = (LPBYTE) *ppszBuffer;
    _ResponseBufferLength = dwBufferLength;
    _BytesReceived = dwBufferLength;
    error = UpdateResponseHeaders(&eof);
    if (error != ERROR_SUCCESS) {

        //
        // if we failed, we will clean up our variables including clearing
        // out the response buffer address and length, but leave freeing
        // the buffer to the caller
        //

        _ResponseBuffer = NULL;
        _ResponseBufferLength = 0;
        ResetResponseVariables();

    } else {

        //
        // Success - the object owns the buffer so the caller should not free.
        //

        *ppszBuffer = NULL;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryResponseVersion(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the HTTP version string from the status line

Arguments:

    lpBuffer            - pointer to buffer to copy version string into

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: size of version string excluding terminating '\0'
                               if successful, else required buffer length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryResponseVersion);

    DWORD error;

    HEADER_STRING * statusLine = GetStatusLine();

    if ((statusLine == NULL) || statusLine->IsError()) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    LPSTR string;
    DWORD length;

    //
    // get a pointer into the response buffer where the status line starts
    // and its length
    //

    string = statusLine->StringAddress((LPSTR)_ResponseBuffer);
    length = (DWORD)statusLine->StringLength();

    //
    // the version string is the first token on the line, delimited by spaces
    //

    DWORD index;

    for (index = 0; index < length; ++index) {

        //
        // we'll also check for CR and LF, although just space should be
        // sufficient
        //

        if ((string[index] == ' ')
        || (string[index] == '\r')
        || (string[index] == '\n')) {
            break;
        }
    }
    if (*lpdwBufferLength > index) {
        memcpy(lpBuffer, (LPVOID)string, index);
        ((LPSTR)lpBuffer)[index] = '\0';
        *lpdwBufferLength = index;
        error = ERROR_SUCCESS;
    } else {
        *lpdwBufferLength = index + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:

    PERF_LEAVE(QueryResponseVersion);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryStatusCode(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Returns the status code as a string or a number

Arguments:

    lpBuffer            - pointer to buffer where results written

    lpdwBufferLength    - IN: length of buffer
                          OUT: size of returned information, or required size'
                               of buffer

    dwModifiers         - flags which modify returned value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryStatusCode);

    DWORD error;
    DWORD requiredSize;

    if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
        requiredSize = sizeof(_StatusCode);
        if (*lpdwBufferLength >= requiredSize) {
            *(LPDWORD)lpBuffer = _StatusCode;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        //
        // the number should always be only 3 characters long, but we'll be
        // flexible (just in case)
        //

        char numBuf[sizeof("4294967296")];

        requiredSize = wsprintf(numBuf, "%u", _StatusCode) + 1;

#ifdef DEBUG
        // Debug check to make sure everything is good because the above
        // used to be ultoa.
        char debugBuf[sizeof("4294967296")];
        ultoa(_StatusCode, debugBuf, 10);
        if (strcmp(debugBuf,numBuf))
        {
            INET_ASSERT(FALSE);
        }

        INET_ASSERT(requiredSize == lstrlen(numBuf) + 1);
#endif

        if (*lpdwBufferLength >= requiredSize) {
            memcpy(lpBuffer, (LPVOID)numBuf, requiredSize);
            *lpdwBufferLength = requiredSize - 1;
            error = ERROR_SUCCESS;
        } else {
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    PERF_LEAVE(QueryStatusCode);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryStatusText(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the status text - if any - returned by the server in the status line

Arguments:

    lpBuffer            - pointer to buffer where status text is written

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: length of the status text string minus 1 for the
                               '\0', or the required buffer length if we return
                               ERROR_INSUFFICIENT_BUFFER

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryStatusText);

    DWORD error;

    HEADER_STRING * statusLine = GetStatusLine();

    if ((statusLine == NULL) || statusLine->IsError()) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    LPSTR str;
    DWORD len;

    //
    // find the third token on the status line. The status line has the form
    //
    //  "HTTP/1.0 302 Try again\r\n"
    //
    //   ^        ^   ^
    //   |        |   |
    //   |        |   +- status text
    //   |        +- status code
    //   +- version
    //

    str = statusLine->StringAddress((LPSTR)_ResponseBuffer);
    len = statusLine->StringLength();

    DWORD i;

    i = 0;

    int j;

    for (j = 0; j < 2; ++j) {
        while ((i < len) && (str[i] != ' ')) {
            ++i;
        }
        while ((i < len) && (str[i] == ' ')) {
            ++i;
        }
    }
    len -= i;
    if (*lpdwBufferLength > len) {
        memcpy(lpBuffer, (LPVOID)&str[i], len);
        ((LPSTR)lpBuffer)[len] = '\0';
        *lpdwBufferLength = len;
        error = ERROR_SUCCESS;
    } else {
        *lpdwBufferLength = len + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:

    PERF_LEAVE(QueryStatusText);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRawResponseHeaders(
    IN BOOL bCrLfTerminated,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the raw response headers

Arguments:

    bCrLfTerminated     - TRUE if we want RAW_HEADERS_CRLF else RAW_HEADERS

    lpBuffer            - pointer to buffer where headers returned

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: returned length of lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRawHeaders",
                 "%B, %#x, %#x [%d]",
                 bCrLfTerminated,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength
                 ));

    PERF_ENTER(QueryRawHeaders);

    DWORD error = _ResponseHeaders.QueryRawHeaders(
                    (LPSTR)_ResponseBuffer,
                    bCrLfTerminated,
                    lpBuffer,
                    lpdwBufferLength
                    );

    IF_DEBUG_CODE() {
        if (error == ERROR_INSUFFICIENT_BUFFER) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("*lpdwBufferLength = %d\n",
                        *lpdwBufferLength
                        ));

        }
    }

    PERF_LEAVE(QueryRawHeaders);

    DEBUG_LEAVE(error);

    return error;

}


VOID
HTTP_REQUEST_HANDLE_OBJECT::RemoveAllRequestHeadersByName(
    IN DWORD dwQueryIndex
    )

/*++

Routine Description:

    Removes all headers of a particular type from the request object

Arguments:

    lpszHeaderName  - name of header to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "RemoveAllRequestHeadersByName",
                 "%q, %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex
                 ));

    PERF_ENTER(RemoveAllRequestHeadersByName);

    _RequestHeaders.RemoveAllByIndex(dwQueryIndex);

    PERF_LEAVE(RemoveAllRequestHeadersByName);

    DEBUG_LEAVE(0);
}

//
// private methods
//


PRIVATE
DWORD
HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders(
    VOID
    )

/*++

Routine Description:

    Tests for a couple of well-known headers that are important to us as well as
    the app:

        "Connection: Keep-Alive"
        "Proxy-Connection: Keep-Alive"
        "Connection: Close"
        "Proxy-Connection: Close"
        "Transfer-Encoding: chunked"
        "Content-Length: ####"
        "Content-Range: bytes ####-####/####"

    The header DOES NOT contain CR-LF. That is, dwHeaderLength will not include
    any counts for line termination

    We need to know if the server honoured a request for a keep-alive connection
    so that we don't try to receive until we hit the end of the connection. The
    server will keep it open.

    We need to know the content length if we are talking over a persistent (keep
    alive) connection.

    If either header is found, we set the corresponding flag in the HTTP_HEADERS
    object, and in the case of "Content-Length:" we parse out the length.

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders",
                 NULL
                 ));

    DWORD dwError = ERROR_SUCCESS;

    //
    // check for "Content-Length:"
    //

    if ( IsResponseHeaderPresent(HTTP_QUERY_CONTENT_LENGTH) )
    {
        HEADER_STRING * curHeader;
        DWORD dwHeaderLength;
        LPSTR lpszHeader;

        DWORD iSlotContentLength = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONTENT_LENGTH];
        curHeader = _ResponseHeaders.GetSlot(iSlotContentLength);

        lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
        dwHeaderLength = curHeader->StringLength();

        dwHeaderLength -= GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Length+1;
        lpszHeader     += GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Length+1;

        while (dwHeaderLength && (*lpszHeader == ' ')) {
            --dwHeaderLength;
            ++lpszHeader;
        }
        while (dwHeaderLength && isdigit(*lpszHeader)) {
            _ContentLength = _ContentLength * 10 + (*lpszHeader - '0');
            --dwHeaderLength;
            ++lpszHeader;
        }

        //
        // once we have _ContentLength, we don't modify it (unless
        // we fix it up when using a 206 partial response to resume
        // a partial download.)  The header value should be returned
        // by HttpQueryInfo().  Instead, we keep account of the
        // amount of keep-alive data left to copy in _BytesRemaining
        //

        _BytesRemaining = _ContentLength;

        //
        // although we said we may be one past the end of the header, in
        // reality, if we received a buffer with "Content-Length:" then we
        // expect it to be terminated by CR-LF (or CR-CR-LF or just LF,
        // depending on the wackiness quotient of the server)
        //

        // MSXML3 bug 56001: commenting-out this assert; it's informational
        //                   only and ignorable.
        // INET_ASSERT((*lpszHeader == '\r') || (*lpszHeader == '\n'));

        SetHaveContentLength(TRUE);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("_ContentLength = %d\n",
                    _ContentLength
                    ));

        _BytesInSocket = (_ContentLength != 0)
                ? (_ContentLength - (_BytesReceived - _DataOffset))
                : 0;

        //
        // we could have multiple responses in the same buffer. If
        // the amount received is greater than the content length
        // then we have all the data; there are no bytes left in
        // the socket for the current response
        //

        if ((int)_BytesInSocket < 0) {
            _BytesInSocket = 0;
        }

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("bytes left in socket = %d\n",
                    _BytesInSocket
                    ));

    }


    if ( IsResponseHeaderPresent(HTTP_QUERY_CONNECTION) ||
         IsResponseHeaderPresent(HTTP_QUERY_PROXY_CONNECTION) )
    {
        //
        // check for "Connection: Keep-Alive" or "Proxy-Connection: Keep-Alive".
        // This test protects us against the unlikely
        // event of a server returning to us a keep-alive response header (because
        // that would cause problems for the proxy)
        //

        if (IsWantKeepAlive() && (!IsKeepAlive() || IsResponseHttp1_1()))
        {
            HEADER_STRING * curHeader;
            DWORD dwHeaderLength, headerNameLength;
            LPSTR lpszHeader;


            DWORD iSlot;

            char ch;

            if (IsRequestUsingProxy() &&
                IsResponseHeaderPresent(HTTP_QUERY_PROXY_CONNECTION))
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_PROXY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Length+1;
            }
            else if (IsResponseHeaderPresent(HTTP_QUERY_CONNECTION))
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_CONNECTION].Length+1;
            }
            else
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_PROXY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Length+1;
                INET_ASSERT(FALSE);
            }

            curHeader      = _ResponseHeaders.GetSlot(iSlot);
            lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
            dwHeaderLength = curHeader->StringLength();

            dwHeaderLength -= headerNameLength;
            lpszHeader     += headerNameLength;

            while (dwHeaderLength && (*lpszHeader == ' ')) {
                ++lpszHeader;
                --dwHeaderLength;
            }

            //
            // both headers use "Keep-Alive" as header-value ONLY for HTTP 1.0 servers
            //

            if (((int)dwHeaderLength >= KEEP_ALIVE_LEN)
            && !strnicmp(lpszHeader, KEEP_ALIVE_SZ, KEEP_ALIVE_LEN)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Connection: Keep-Alive\n"
                            ));

                //
                // BUGBUG - we are setting k-a when coming from cache!
                //

                SetKeepAlive(TRUE);
                SetPersistentConnection(headerNameLength == HTTP_PROXY_CONNECTION_LEN);
            }

            //
            // also check for "Close" as header-value ONLY for HTTP 1.1 servers
            //

            else if ((*lpszHeader == 'C' || *lpszHeader == 'c')
                     && ((int)dwHeaderLength >= CLOSE_LEN)
                     && IsResponseHttp1_1()
                     && !strnicmp(lpszHeader, CLOSE_SZ, CLOSE_LEN)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Connection: Close (HTTP/1.1)\n"
                            ));

                SetConnCloseResponse(TRUE);
            }
        }
    }

    //
    // check for "Transfer-Encoding:"
    //

    if (IsResponseHeaderPresent(HTTP_QUERY_TRANSFER_ENCODING) &&
        IsResponseHttp1_1())
    {

        //
        // If Http 1.1, check for Chunked Transfer
        //

        HEADER_STRING * curHeader;
        DWORD dwHeaderLength;
        LPSTR lpszHeader;
        DWORD iSlot;

        iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING];
        curHeader = _ResponseHeaders.GetSlot(iSlot);

        lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
        dwHeaderLength = curHeader->StringLength();

        dwHeaderLength -= GlobalKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING].Length+1;
        lpszHeader     += GlobalKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING].Length+1;

        while (dwHeaderLength && (*lpszHeader == ' ')) {
            ++lpszHeader;
            --dwHeaderLength;
        }

        //
        // look for "chunked" entry that confirms that we're doing chunked transfer encoding
        //

        if (((int)dwHeaderLength >= CHUNKED_LEN)
        && !strnicmp(lpszHeader, CHUNKED_SZ, CHUNKED_LEN))
        {
            INTERNET_HANDLE_OBJECT* pRoot = GetRootHandle(this);
            DWORD_PTR dwChunkFilterCtx = 0;

            // Now that we know this is a chunked response, allocate
            // a decoder context for parsing the data later.  If anything
            // fails here, the request needs to fail.            
            if (S_OK != pRoot->_ChunkFilter.RegisterContext(&dwChunkFilterCtx))
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            else if (!_ResponseFilterList.Insert(&pRoot->_ChunkFilter, dwChunkFilterCtx))
            {
                pRoot->_ChunkFilter.UnregisterContext(dwChunkFilterCtx);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            SetHaveChunkEncoding(TRUE);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("server is sending Chunked Transfer Encoding\n"
                        ));

            //
            // if both "transfer-encoding: chunked" and "content-length:"
            // were received then the chunking takes precedence
            //

            INET_ASSERT(!(IsChunkEncoding() && IsContentLength()));

            if (IsContentLength()) {
                SetHaveContentLength(FALSE);
            }

        }
    }

    SetBadNSServer(FALSE);

    if (IsResponseHttp1_1())
    {

        //
        // For IIS 4.0 Servers, and all other normal servers, if we make
        //  a HEAD request, we should ignore the Content-Length.
        //
        // IIS 3.0 servers send an illegal body, and this is a bug in the server.
        //  since they're not HTTP 1.1 we should be ok here.
        //

        if ( (GetMethodType() == HTTP_METHOD_TYPE_HEAD) &&
             (_ContentLength > 0) &&
             IsWantKeepAlive()
             )
        {

            //
            // set length to 0
            //

            _ContentLength = 0;

        }

        if ( IsRequestHttp1_1() )
        {


            //
            // check for NS servers that don't return correct HTTP/1.1 responses
            //

            LPSTR buffer;
            DWORD buflen;
            DWORD status = FastQueryResponseHeader(HTTP_QUERY_SERVER,
                                                   (LPVOID*)&buffer,
                                                   &buflen,
                                                   0
                                                   );

    #define NSEP    "Netscape-Enterprise/3"
    #define NSEPLEN (sizeof(NSEP) - 1)
    #define NSFT    "Netscape-FastTrack/3"
    #define NSFTLEN (sizeof(NSFT) - 1)
    #define NSCS    "Netscape-Commerce/3"
    #define NSCSLEN (sizeof(NSCS) - 1)

            if (status == ERROR_SUCCESS) {

                BOOL fIsBadServer = ((buflen > NSEPLEN) && !strnicmp(buffer, NSEP, NSEPLEN))
                                 || ((buflen > NSFTLEN) && !strnicmp(buffer, NSFT, NSFTLEN))
                                 || ((buflen > NSCSLEN) && !strnicmp(buffer, NSCS, NSCSLEN));

                if ( fIsBadServer )
                {
                    CServerInfo * pServerInfo = GetServerInfo();

                    SetBadNSServer(fIsBadServer);

                    if (pServerInfo != NULL)
                    {
                        //
                        // Note this Bad Server info in the server info obj,
                        //   as we they fail to do keep-alive with SSL properly
                        //

                        pServerInfo->SetBadNSServer();
                    }


                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("IsBadNSServer() == %B\n",
                                IsBadNSServer()
                                ));
                }
            }
        }

        //
        // BUGBUG - content-type: multipart/byteranges means we
        //          also have data
        //

        DWORD statusCode = GetStatusCode();

        if (!IsBadNSServer()
            && !IsContentLength()
            && !IsChunkEncoding()
            && (((statusCode >= HTTP_STATUS_CONTINUE)               // 100
                && (statusCode < HTTP_STATUS_OK))                   // 200
                || (statusCode == HTTP_STATUS_NO_CONTENT)           // 204
                || (statusCode == HTTP_STATUS_MOVED)                // 301
                || (statusCode == HTTP_STATUS_REDIRECT)             // 302
                || (statusCode == HTTP_STATUS_REDIRECT_METHOD)      // 303
                || (statusCode == HTTP_STATUS_NOT_MODIFIED)         // 304
                || (statusCode == HTTP_STATUS_REDIRECT_KEEP_VERB))  // 307
            || (GetMethodType() == HTTP_METHOD_TYPE_HEAD)) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("header-only HTTP/1.1 response\n"
                        ));

            SetData(FALSE);
        }
    }

quit:
    DEBUG_LEAVE(dwError);
    return dwError;
}


//
// this array has the same order as the HTTP_METHOD_TYPE enum
//

#define MAKE_REQUEST_METHOD_TYPE(Type) \
    sizeof(# Type) - 1, # Type, HTTP_METHOD_TYPE_ ## Type

//
// darrenmi - need a new macro because *_M-POST isn't a valid enum member.
// we need a seperate enum type and string value.
//
// map HTTP_METHOD_TYPE_MPOST <=> "M-POST"
//

#define MAKE_REQUEST_METHOD_TYPE2(EnumType,Type) \
    sizeof(# Type) - 1, # Type, HTTP_METHOD_TYPE_ ## EnumType

static const struct _REQUEST_METHOD {
    int Length;
    LPSTR Name;
    HTTP_METHOD_TYPE MethodType;
} MethodNames[] = {
    MAKE_REQUEST_METHOD_TYPE(GET),
    MAKE_REQUEST_METHOD_TYPE(HEAD),
    MAKE_REQUEST_METHOD_TYPE(POST),
    MAKE_REQUEST_METHOD_TYPE(PUT),
    MAKE_REQUEST_METHOD_TYPE(PROPFIND),
    MAKE_REQUEST_METHOD_TYPE(PROPPATCH),
    MAKE_REQUEST_METHOD_TYPE(LOCK),
    MAKE_REQUEST_METHOD_TYPE(UNLOCK),
    MAKE_REQUEST_METHOD_TYPE(COPY),
    MAKE_REQUEST_METHOD_TYPE(MOVE),
    MAKE_REQUEST_METHOD_TYPE(MKCOL),
    MAKE_REQUEST_METHOD_TYPE(CONNECT),
    MAKE_REQUEST_METHOD_TYPE(DELETE),
    MAKE_REQUEST_METHOD_TYPE(LINK),
    MAKE_REQUEST_METHOD_TYPE(UNLINK),
    MAKE_REQUEST_METHOD_TYPE(BMOVE),
    MAKE_REQUEST_METHOD_TYPE(BCOPY),
    MAKE_REQUEST_METHOD_TYPE(BPROPFIND),
    MAKE_REQUEST_METHOD_TYPE(BPROPPATCH),
    MAKE_REQUEST_METHOD_TYPE(BDELETE),
    MAKE_REQUEST_METHOD_TYPE(SUBSCRIBE),
    MAKE_REQUEST_METHOD_TYPE(UNSUBSCRIBE),
    MAKE_REQUEST_METHOD_TYPE(NOTIFY),
    MAKE_REQUEST_METHOD_TYPE(POLL), 
    MAKE_REQUEST_METHOD_TYPE(CHECKIN),
    MAKE_REQUEST_METHOD_TYPE(CHECKOUT),
    MAKE_REQUEST_METHOD_TYPE(INVOKE),
    MAKE_REQUEST_METHOD_TYPE(SEARCH),
    MAKE_REQUEST_METHOD_TYPE(PIN),
    MAKE_REQUEST_METHOD_TYPE2(MPOST,M-POST)
};


HTTP_METHOD_TYPE
MapHttpRequestMethod(
    IN LPCSTR lpszVerb
    )

/*++

Routine Description:

    Maps request method string to type. Method names *are* case-sensitive

Arguments:

    lpszVerb    - method (verb) string

Return Value:

    HTTP_METHOD_TYPE

--*/

{
    int verbLen = strlen(lpszVerb);

    for (int i = 0; i < ARRAY_ELEMENTS(MethodNames); ++i) {
        if ((MethodNames[i].Length == verbLen)
        && (memcmp(lpszVerb, MethodNames[i].Name, verbLen) == 0)) {
            return MethodNames[i].MethodType;
        }
    }

    //
    // we now hande HTTP_METHOD_TYPE_UNKNOWN
    //

    return HTTP_METHOD_TYPE_UNKNOWN;
}


DWORD
MapHttpMethodType(
    IN HTTP_METHOD_TYPE tMethod,
    OUT LPCSTR * lplpcszName
    )

/*++

Routine Description:

    Map a method type to the corresponding name and length

Arguments:

    tMethod     - to map

    lplpcszName - pointer to pointer to returned name

Return Value:

    DWORD
        Success - length of method name

        Failure - (DWORD)-1

--*/

{
    DWORD length;

    if ((tMethod >= HTTP_METHOD_TYPE_FIRST) && (tMethod <= HTTP_METHOD_TYPE_LAST)) {
        *lplpcszName = MethodNames[tMethod].Name;
        length = MethodNames[tMethod].Length;
    } else {
        length = (DWORD)-1;
    }
    return length;
}

#if INET_DEBUG

LPSTR
MapHttpMethodType(
    IN HTTP_METHOD_TYPE tMethod
    )
{
    return (tMethod == HTTP_METHOD_TYPE_UNKNOWN)
        ? "Unknown"
        : MethodNames[tMethod].Name;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\headers.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    headers.h

Abstract:

    This file contains the well-known HTTP/MIME request/response headers.
    For each header, two manifests are defined. HTTP_*_SZ contains the header
    name, immediatly followed by a colon. HTTP_*_LEN is the strlen of the
    corresponding HTTP_*_SZ, which does not include the terminating '\0'.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/


#define CSTRLEN(str)  (sizeof(str)-1)

#ifndef _HEADERS_H_
#define _HEADERS_H_

struct KnownHeaderType {
    LPSTR Text;
    INT Length;
    DWORD Flags;
    DWORD HashVal;
};

#define MAX_HEADER_HASH_SIZE 153
#define HEADER_HASH_SEED 1291949


extern const BYTE GlobalHeaderHashs[];
extern const struct KnownHeaderType GlobalKnownHeaders[];

DWORD
FASTCALL
CalculateHashNoCase(
    IN LPCSTR lpszString,
    IN DWORD dwStringLength
    );


//
// Various other header defines for different HTTP headers.
//

#define HTTP_ACCEPT_RANGES_SZ           "Accept-Ranges:"
#define HTTP_ACCEPT_RANGES_LEN          CSTRLEN(HTTP_ACCEPT_RANGES_SZ)

#define HTTP_DATE_SZ                    "Date:"
#define HTTP_DATE_LEN                   (sizeof(HTTP_DATE_SZ) - 1)

#define HTTP_EXPIRES_SZ                 "Expires:"
#define HTTP_EXPIRES_LEN                (sizeof(HTTP_EXPIRES_SZ) - 1)


#define HTTP_CONTENT_DISPOSITION_SZ     "Content-Disposition:"
#define HTTP_CONTENT_DISPOSITION_LEN     (sizeof(HTTP_CONTENT_DISPOSITION_SZ) - 1)

#define HTTP_LAST_MODIFIED_SZ           "Last-Modified:"
#define HTTP_LAST_MODIFIED_LEN          (sizeof(HTTP_LAST_MODIFIED_SZ) - 1)

// nuke?
#define HTTP_UNLESS_MODIFIED_SINCE_SZ   "Unless-Modified-Since:"
#define HTTP_UNLESS_MODIFIED_SINCE_LEN  CSTRLEN(HTTP_UNLESS_MODIFIED_SINCE_SZ)

#define HTTP_SERVER_SZ                  "Server:"
#define HTTP_SERVER_LEN                 (sizeof(HTTP_SERVER_SZ) - 1)

#define HTTP_CONNECTION_SZ              "Connection:"
#define HTTP_CONNECTION_LEN             (sizeof(HTTP_CONNECTION_SZ) - 1)

#define HTTP_PROXY_CONNECTION_SZ        "Proxy-Connection:"
#define HTTP_PROXY_CONNECTION_LEN       (sizeof(HTTP_PROXY_CONNECTION_SZ) - 1)

#define HTTP_SET_COOKIE_SZ              "Set-Cookie:"
#define HTTP_SET_COOKIE_LEN             (sizeof(HTTP_SET_COOKIE_SZ)-1)

//
//  Miscellaneous header goodies.
//

#define CHUNKED_SZ                      "chunked"
#define CHUNKED_LEN                     (sizeof(CHUNKED_SZ) - 1)

#define KEEP_ALIVE_SZ                   "Keep-Alive"
#define KEEP_ALIVE_LEN                  (sizeof(KEEP_ALIVE_SZ) - 1)

#define CLOSE_SZ                        "Close"
#define CLOSE_LEN                       (sizeof(CLOSE_SZ) - 1)

#define BYTES_SZ                        "bytes"
#define BYTES_LEN                       CSTRLEN(BYTES_SZ)

#define HTTP_VIA_SZ                     "Via:"
#define HTTP_VIA_LEN                    (sizeof(HTTP_VIA_SZ) - 1)

#define HTTP_DATE_SIZE  40

// Cache control defines:

#define HTTP_CACHE_CONTROL_SZ           "Cache-Control:"
#define HTTP_CACHE_CONTROL_LEN          CSTRLEN(HTTP_CACHE_CONTROL_SZ)

#define HTTP_AGE_SZ                     "Age:"
#define HTTP_AGE_LEN                    (sizeof(HTTP_AGE_SZ)-1)

#define HTTP_VARY_SZ                    "Vary:"
#define HTTP_VARY_LEN                   (sizeof(HTTP_VARY_SZ)-1)

#define NO_CACHE_SZ                     "no-cache"
#define NO_CACHE_LEN                    (sizeof(NO_CACHE_SZ) -1)

#define NO_STORE_SZ                     "no-store"
#define NO_STORE_LEN                    (sizeof(NO_STORE_SZ) -1)

#define MUST_REVALIDATE_SZ              "must-revalidate"
#define MUST_REVALIDATE_LEN             (sizeof(MUST_REVALIDATE_SZ) -1)

#define MAX_AGE_SZ                      "max-age"
#define MAX_AGE_LEN                     (sizeof(MAX_AGE_SZ) -1)

#define PRIVATE_SZ                      "private"
#define PRIVATE_LEN                     (sizeof(PRIVATE_SZ) - 1)

#define POSTCHECK_SZ                    "post-check"
#define POSTCHECK_LEN                   (sizeof(POSTCHECK_SZ) -1)

#define PRECHECK_SZ                     "pre-check"
#define PRECHECK_LEN                    (sizeof(PRECHECK_SZ) -1)

#define FILENAME_SZ                     "filename"
#define FILENAME_LEN                    (sizeof(FILENAME_SZ) - 1)

#define USER_AGENT_SZ                   "user-agent"
#define USER_AGENT_LEN                  (sizeof(USER_AGENT_SZ) - 1)

#endif  // _HEADERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\hhead.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hhead.cxx

Abstract:

    This file contains autogenerated table values of a perfect hash function
    DO NOT, DO NOT EDIT THIS FILE, TO ADD HEADERS SEE hashgen.cpp
    Contents:
      GlobalKnownHeaders
      GlobalHeaderHashs

Author:

   Arthur Bierer (arthurbi) 19-Dec-1997 (AND) my code generator[hashgen.exe]

Revision History:

--*/


#include <wininetp.h>
#include "httpp.h"

#ifdef HEADER_HASH_SEED
#if (HEADER_HASH_SEED != 1291949)
#error HEADER_HASH_SEED has not been updated in the header file, please copy this number to the header
#endif
#else
#define HEADER_HASH_SEED 1291949
#endif

#ifdef MAX_HEADER_HASH_SIZE
#if (MAX_HEADER_HASH_SIZE != 153)
#error MAX_HEADER_HASH_SIZE has not been updated in the header file, please copy this number to the header
#endif
#else
#define MAX_HEADER_HASH_SIZE 153
#endif

#ifdef HTTP_QUERY_MAX
#if (HTTP_QUERY_MAX != 77)
#error HTTP_QUERY_MAX is not the same as the value used in wininet.h, this indicates mismatched headers, see hashgen.cpp
#endif
#endif

//
// GlobalHeaderHashs - array of precalculated hashes on case-sensetive set of known headers.
// This array must be used with the same hash function used to generate it.
// Note, all entries in this array are biased (++'ed) by 1 from HTTP_QUERY_ manifests in wininet.h.
//   0-ed entries indicate error values
//

const BYTE GlobalHeaderHashs[MAX_HEADER_HASH_SIZE] = {
      0,   0,   0,  71,   0,   0, 
     53,   0,   0,   0,   0,   0, 
     40,  60,  72,   0,   0,   0, 
     64,  61,   0,  28,   4,   0, 
     76,  57,   0,  30,   0,   8, 
      0,  15,   0,   0,   0,   0, 
     24,   0,  66,  29,   0,   0, 
      0,   0,   0,   0,  13,  14, 
     16,  33,   0,   0,   0,  68, 
     41,   0,   7,   0,   0,   0, 
      0,   0,  32,  17,  51,  48, 
     67,  11,   0,   0,   5,   0, 
     65,   2,   0,   0,  35,   6, 
      0,   0,  31,  50,   0,   0, 
      0,  49,  78,  26,   0,   0, 
     42,   0,   0,  43,   0,  27, 
     69,   9,   1,   0,   0,  18, 
     10,   0,   0,   3,  47,  55, 
      0,  44,   0,  56,   0,  70, 
     54,  52,   0,   0,   0,   0, 
      0,   0,  36,  62,   0,   0, 
     45,   0,   0,  12,   0,  73, 
     77,   0,  63,   0,  59,   0, 
      0,   0,   0,  58,  38,   0, 
      0,   0,  39,  25,   0,  37, 
      0,  34,   0, 
   };

//
// GlobalKnownHeaders - array of HTTP request and response headers that we understand.
// This array must be in the same order as the HTTP_QUERY_ manifests in WININET.H
//

#define HEADER_ENTRY(String, Flags, HashVal) String, sizeof(String) - 1, Flags, HashVal

const struct KnownHeaderType GlobalKnownHeaders[HTTP_QUERY_MAX+1] = {
    HEADER_ENTRY("Mime-Version",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x179ED708),
    HEADER_ENTRY("Content-Type",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8A50E357),
    HEADER_ENTRY("Content-Transfer-Encoding",  HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x562B730E),
    HEADER_ENTRY("Content-Id",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xE7ADCA82),
    HEADER_ENTRY("Content-Description",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x9D4EB3D9),
    HEADER_ENTRY("Content-Length",             (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_NUMBER), 0x4E02E517),
    HEADER_ENTRY("Content-Language",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xA6681019),
    HEADER_ENTRY("Allow",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x297A46CC),
    HEADER_ENTRY("Public",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C5DD44C),
    HEADER_ENTRY("Date",                       (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xBB71C70B),
    HEADER_ENTRY("Expires",                    (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xC153144D),
    HEADER_ENTRY("Last-Modified",              (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x23617A4F),
    HEADER_ENTRY("Message-id",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC9AE6FAC),
    HEADER_ENTRY("Uri",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF60D45D),
    HEADER_ENTRY("Derived-From",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x6AAF4091),
    HEADER_ENTRY("Cost",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB717626),
    HEADER_ENTRY("Link",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB764B5B),
    HEADER_ENTRY("Pragma",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C26E9A5),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_NUMBER, 0x0),
    HEADER_ENTRY("",                           0, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Connection",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x190A507D),
    HEADER_ENTRY("Accept",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x581B295D),
    HEADER_ENTRY("Accept-Charset",             HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC87564B4),
    HEADER_ENTRY("Accept-Encoding",            HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x81EEF031),
    HEADER_ENTRY("Accept-Language",            HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2827D6EE),
    HEADER_ENTRY("Authorization",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xEC768B9E),
    HEADER_ENTRY("Content-Encoding",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2F295C),
    HEADER_ENTRY("Forwarded",                  HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x420550EB),
    HEADER_ENTRY("From",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB732781),
    HEADER_ENTRY("If-Modified-Since",          (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x88B69529),
    HEADER_ENTRY("Location",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8DD3A2C6),
    HEADER_ENTRY("Orig-Uri",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x47CCA2FB),
    HEADER_ENTRY("Referer",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7CFEFF98),
    HEADER_ENTRY("Retry-After",                (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xD2881822),
    HEADER_ENTRY("Server",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8244B644),
    HEADER_ENTRY("Title",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2AD094CF),
    HEADER_ENTRY("User-Agent",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x968679A8),
    HEADER_ENTRY("WWW-Authenticate",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x21BED5E),
    HEADER_ENTRY("Proxy-Authenticate",         HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBE0F117B),
    HEADER_ENTRY("Accept-Ranges",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC3BF828A),
    HEADER_ENTRY("Set-Cookie",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC704A760),
    HEADER_ENTRY("Cookie",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x5DA54DC7),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Refresh",                    0, 0x7D05EAFC),
    HEADER_ENTRY("Content-Disposition",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xDCB6FC4A),
    HEADER_ENTRY("Age",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF607DDA),
    HEADER_ENTRY("Cache-Control",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBBD3B86F),
    HEADER_ENTRY("Content-Base",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8A469ED0),
    HEADER_ENTRY("Content-Location",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC201A76E),
    HEADER_ENTRY("Content-Md5",                HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xDD672BFB),
    HEADER_ENTRY("Content-Range",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xD43BEC42),
    HEADER_ENTRY("Etag",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB72A1CE),
    HEADER_ENTRY("Host",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB74340B),
    HEADER_ENTRY("If-Match",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x971A5776),
    HEADER_ENTRY("If-None-Match",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF6E9D3),
    HEADER_ENTRY("If-Range",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x9774B8F6),
    HEADER_ENTRY("If-Unmodified-Since",        (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xC946042C),
    HEADER_ENTRY("Max-Forwards",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x3C693EC8),
    HEADER_ENTRY("Proxy-Authorization",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x96A221ED),
    HEADER_ENTRY("Range",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2AA7E69A),
    HEADER_ENTRY("Transfer-Encoding",          HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBD09B166),
    HEADER_ENTRY("Upgrade",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7DAF65B5),
    HEADER_ENTRY("Vary",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB7BA5AF),
    HEADER_ENTRY("Via",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF60D76D),
    HEADER_ENTRY("Warning",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xF56B7D23),
    HEADER_ENTRY("Expect",                     (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x62F2EDB6),
    HEADER_ENTRY("Proxy-Connection",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xD79F12C),
    HEADER_ENTRY("Unless-Modified-Since",      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8E53B934),
    HEADER_ENTRY("Ms-Echo-Request",            0, 0xBB7AF4AF),
    HEADER_ENTRY("Ms-Echo-Reply",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xA5326612),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Proxy-Support",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C4F7F99),
    HEADER_ENTRY("Authentication-Info",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xB03F47E6),
    HEADER_ENTRY("PassportURLs",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF7C676F),
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\httptime.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    httptime.cxx

Abstract:

    This file contains routines to get various timestamps from an http response
    header.

    We handle only the three standards-mandated date forms, since these are used by
    the vast majority of sites out there on the WWW. Handling additional date forms
    adds to the overhead of these functions, so unless a new form makes headway, we
    will keep these functions simple.

    Contents:
        FGetHttpExpiryTime
        FGetHttpLastModifiedTime
        FParseHttpDate
        FHttpDateTimeToFiletime
        FFileTimetoHttpDateTime
        HttpDateToSystemTime
        HttpTimeFromSystemTime
        (FInternalParseHttpDate)
        (MapDayMonthToDword)

Author:

    Shishir Pardikar (shishirp) 06-Jan-1996

Revision History:

    06-Jan-1996 rfirth
        Created this header

    12-Dec-1997 arthurbi
        Rewrote the date parser to reduce allocs, and other bad stuff.

--*/

#include <wininetp.h>
#include "httpp.h"
#include "httptime.h"

//
// external prototypes
//

/********************* Local data *******************************************/
/******************** HTTP date format strings ******************************/

// Month
static const char cszJan[]="Jan";
static const char cszFeb[]="Feb";
static const char cszMar[]="Mar";
static const char cszApr[]="Apr";
static const char cszMay[]="May";
static const char cszJun[]="Jun";
static const char cszJul[]="Jul";
static const char cszAug[]="Aug";
static const char cszSep[]="Sep";
static const char cszOct[]="Oct";
static const char cszNov[]="Nov";
static const char cszDec[]="Dec";

// DayOfWeek in rfc1123 or asctime format
static const char cszSun[]="Sun";
static const char cszMon[]="Mon";
static const char cszTue[]="Tue";
static const char cszWed[]="Wed";
static const char cszThu[]="Thu";
static const char cszFri[]="Fri";
static const char cszSat[]="Sat";

// List of weekdays for rfc1123 or asctime style date
static const char *rgszWkDay[7] =
   {
        cszSun,cszMon,cszTue,cszWed,cszThu,cszFri,cszSat
   };

// list of month strings for all date formats
static const char *rgszMon[12] =
   {
        cszJan,cszFeb,cszMar,cszApr,cszMay,cszJun,
        cszJul,cszAug,cszSep,cszOct,cszNov,cszDec
   };

/******************** HTTP date format strings ******************************/

/* Http date format: Sat, 29 Oct 1994 19:43:00 GMT */
const char cszHttpDateFmt[]="%s, %02i %s %02i %02i:%02i:%02i GMT";

/****************************************************************************/


/******************************** Local Functions ***************************/

BOOL
FHttpDateTimeToFiletime(
    LPCSTR pcszStr,      // input datetime string
    LPCSTR *rgszWkDay,   // day of week strings
    LPCSTR *rgszMon,     // month strings
    LPCSTR pcszSep,      // seperators
    UINT dateId,         // date format
    FILETIME *lpft       // output filetime in GMT
    );


BOOL 
FInternalParseHttpDate(
    OUT FILETIME *lpft,
    OUT SYSTEMTIME *lpSysTime,
    IN  LPCSTR lpInputBuffer
    );


/****************************************************************************/






//+---------------------------------------------------------------------------
//
//  Function: FGetHttpExpiryTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------

BOOL FGetHttpExpiryTime(HINTERNET hRequest, FILETIME *lpFt)
   {
        BOOL fRet=FALSE;
   char buff[256];
   DWORD dwBuffLen;

   dwBuffLen = sizeof(buff);
   if (HttpQueryInfo(hRequest, HTTP_QUERY_EXPIRES, NULL, buff, &dwBuffLen, NULL))
      {
      fRet = FParseHttpDate(lpFt, buff);
      }

        return fRet;
   }

//+---------------------------------------------------------------------------
//
//  Function: FGetHttpLastModifiedTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------

BOOL FGetHttpLastModifiedTime(HINTERNET hRequest, FILETIME *lpFt)
   {
        BOOL fRet=FALSE;
   char buff[256];
   DWORD dwBuffLen;

   dwBuffLen = sizeof(buff);
   if (HttpQueryInfo(hRequest, HTTP_QUERY_LAST_MODIFIED, NULL, buff, &dwBuffLen, NULL))
      {
      fRet = FParseHttpDate(lpFt, buff);
      }

        return fRet;
   }

DWORD
inline
MapDayMonthToDword(
    LPCSTR lpszDay
    )
/*++

Routine Description:

    Looks at the first three bytes of string to determine if we're looking
        at a Day of the Week, or Month, or "GMT" string.  Is inlined so that
        the compiler can optimize this code into the caller FInternalParseHttpDate.

Arguments:

    lpszDay - a string ptr to the first byte of the string in question.

Return Value:

    DWORD
    Success - The Correct date token, 0-6 for day of the week, 1-14 for month, etc

    Failure - DATE_TOKEN_ERROR

--*/

{
    switch ( MAKE_UPPER(*lpszDay) ) // make uppercase
    {
        case 'A':
            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'P':
                    return DATE_TOKEN_APRIL;
                case 'U':
                    return DATE_TOKEN_AUGUST;

            }
            return DATE_TOKEN_ERROR;

        case 'D':
            return DATE_TOKEN_DECEMBER;

        case 'F':
            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'R':
                    return DATE_TOKEN_FRIDAY;
                case 'E':
                    return DATE_TOKEN_FEBRUARY;
            }

            return DATE_TOKEN_ERROR;

        case 'G':
            return DATE_TOKEN_GMT;

        case 'M':

            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'O':
                    return DATE_TOKEN_MONDAY;
                case 'A':
                    switch (MAKE_UPPER(*(lpszDay+2)) )
                    {
                        case 'R':
                            return DATE_TOKEN_MARCH;
                        case 'Y':
                            return DATE_TOKEN_MAY;
                    }

                    // fall through to error
            }

            return DATE_TOKEN_ERROR;            

        case 'N':
            return DATE_TOKEN_NOVEMBER;

        case 'J':

            switch (MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'A':
                    return DATE_TOKEN_JANUARY;

                case 'U':
                    switch (MAKE_UPPER(*(lpszDay+2)) )
                    {
                        case 'N':
                            return DATE_TOKEN_JUNE;
                        case 'L':
                            return DATE_TOKEN_JULY;
                    }

                    // fall through to error
            }

            return DATE_TOKEN_ERROR;

        case 'O':
            return DATE_TOKEN_OCTOBER;

        case 'S':
            
            switch (MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'A':
                    return DATE_TOKEN_SATURDAY;
                case 'U':
                    return DATE_TOKEN_SUNDAY;
                case 'E':
                    return DATE_TOKEN_SEPTEMBER;
            }

            return DATE_TOKEN_ERROR;


        case 'T':
            switch (MAKE_UPPER(*(lpszDay+1)) )
            {    
                case 'U':
                    return DATE_TOKEN_TUESDAY;
                case 'H':
                    return DATE_TOKEN_THURSDAY;
            }

            return DATE_TOKEN_ERROR;

        case 'U':
            return DATE_TOKEN_GMT;
            
        case 'W':
            return DATE_TOKEN_WEDNESDAY;

    }

    return DATE_TOKEN_ERROR;
}

BOOL 
FInternalParseHttpDate(
    OUT FILETIME *lpft,
    OUT SYSTEMTIME *lpSysTime,
    IN  LPCSTR lpInputBuffer
    )
/*++

Routine Description:

    Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
     a FILETIME/SYSTEMTIME time format.  

    Important this a time-critical function and should only be changed 
     with the intention of optimizing or a critical need work item.

Arguments:

    lpft - Ptr to FILETIME structure.  Used to store converted result.
            Must be NULL if not intended to be used !!!

    lpSysTime - Ptr to SYSTEMTIME struture. Used to return Systime if needed.

    lpcszDateStr - Const Date string to parse.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    int i = 0, iLastLettered = -1;
    BOOL fIsANSIDateFormat = FALSE;
    DWORD rgdwDateParseResults[MAX_DATE_ENTRIES];
    SYSTEMTIME  sSysTime;
    FILETIME    ftTime;
    BOOL fRet = TRUE;

    DEBUG_ENTER((DBG_HTTP,
                Bool,
                "FInternalParseHttpDate",
                "%x %.10q",
                lpft,
                lpInputBuffer
                ));

    //
    // Date Parsing v2 (1 more to go), and here is how it works... 
    //  We take a date string and churn through it once, converting
    //  integers to integers, Month,Day, and GMT strings into integers,
    //  and all is then placed IN order in a temp array. 
    //
    // At the completetion of the parse stage, we simple look at 
    //  the data, and then map the results into the correct 
    //  places in the SYSTIME structure.  Simple, No allocations, and
    //  No dirting the data.   
    //
    // The end of the function does something munging and pretting
    //  up of the results to handle the year 2000, and TZ offsets
    //  Note: do we need to fully handle TZs anymore?
    //

    memset(rgdwDateParseResults, 0, sizeof(rgdwDateParseResults));

    while ( *lpInputBuffer && i < MAX_DATE_ENTRIES)
    {
        if ( *lpInputBuffer >= '0' && *lpInputBuffer <= '9' )
        {
            //
            // we have a numerical entry, scan through it and convent to DWORD
            //

            rgdwDateParseResults[i] = 0;

            do {
                rgdwDateParseResults[i] *= BASE_DEC;
                rgdwDateParseResults[i] += (DWORD) (*lpInputBuffer - '0');
                lpInputBuffer++;
            } while ( *lpInputBuffer && *lpInputBuffer >= '0' && *lpInputBuffer <= '9' );

            i++; // next token
        }
        else if ( (*lpInputBuffer >= 'A' && *lpInputBuffer <= 'Z') ||
             (*lpInputBuffer >= 'a' && *lpInputBuffer <= 'z') )
        {
            //
            // we have a string, should be a day, month, or GMT
            //   lets skim to the end of the string
            //
            
            rgdwDateParseResults[i] = 
                MapDayMonthToDword(lpInputBuffer);

            iLastLettered = i;

            // We want to ignore the possibility of a time zone such as PST or EST in a non-standard
            // date format such as "Thu Dec 17 16:01:28 PST 1998" (Notice that the year is _after_ the time zone
            if ((rgdwDateParseResults[i] == DATE_TOKEN_ERROR) 
                && 
                !(fIsANSIDateFormat && (i==DATE_ANSI_INDEX_YEAR)))
            {
                fRet = FALSE;
#ifdef DEBUG
                dprintf("FInternalParseHttpDate: Invalid Date Format, could not parse %s\n", lpInputBuffer);
#endif
                
                goto quit;
            }

            //
            // At this point if we have a vaild string
            //  at this index, we know for sure that we're
            //  looking at a ANSI type DATE format.
            //

            if ( i == DATE_ANSI_INDEX_MONTH )
            {
                fIsANSIDateFormat = TRUE;
            }

            //
            // Read past the end of the current set of alpha characters,
            //  as MapDayMonthToDword only peeks at a few characters
            //

            do {
                lpInputBuffer++;
            } while ( *lpInputBuffer && 
                        ( (*lpInputBuffer >= 'A' && *lpInputBuffer <= 'Z') ||
                          (*lpInputBuffer >= 'a' && *lpInputBuffer <= 'z') ) );

            i++; // next token
        }
        else
        {
            //
            // For the generic case its either a space, comma, semi-colon, etc.
            //  the point is we really don't care, nor do we need to waste time
            //  worring about it (the orginal code did).   The point is we 
            //  care about the actual date information, So we just advance to the 
            //  next lexume.
            //

            lpInputBuffer++;        
        }
    }

    //
    // We're finished parsing the string, now take the parsed tokens
    //  and turn them to the actual structured information we care about.
    //  So we build lpSysTime from the Array, using a local if none is passed in.
    //

    if ( lpSysTime == NULL )
    {
        lpSysTime = &sSysTime;
    }

    lpSysTime->wDayOfWeek    = (WORD)rgdwDateParseResults[DATE_INDEX_DAY_OF_WEEK];
    lpSysTime->wMilliseconds =  0;

    if ( fIsANSIDateFormat )
    {
        lpSysTime->wDay    = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_DAY];
        lpSysTime->wMonth  = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_MONTH];
        lpSysTime->wHour   = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_HRS];
        lpSysTime->wMinute = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_MINS];
        lpSysTime->wSecond = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_SECS];
        if (iLastLettered != DATE_ANSI_INDEX_YEAR)
        {
            lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_YEAR];
        }
        else
        {
            // Warning! This is a hack to get around the toString/toGMTstring fiasco (where the timezone is
            // appended at the end. (See above)
            lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_INDEX_TZ];
         }
    }
    else
    {
        lpSysTime->wDay    = (WORD)rgdwDateParseResults[DATE_1123_INDEX_DAY];
        lpSysTime->wMonth  = (WORD)rgdwDateParseResults[DATE_1123_INDEX_MONTH];
        lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_1123_INDEX_YEAR];
        lpSysTime->wHour   = (WORD)rgdwDateParseResults[DATE_1123_INDEX_HRS];
        lpSysTime->wMinute = (WORD)rgdwDateParseResults[DATE_1123_INDEX_MINS];
        lpSysTime->wSecond = (WORD)rgdwDateParseResults[DATE_1123_INDEX_SECS];
    }

    //
    // Normalize the year, 90 == 1990, handle the year 2000, 02 == 2002
    //  This is Year 2000 handling folks!!!  We get this wrong and 
    //  we all look bad. 
    //

    if (lpSysTime->wYear < 100) {
        lpSysTime->wYear += ((lpSysTime->wYear < 80) ? 2000 : 1900);
    }

    //
    // if we got misformed time, then plug in the current time
    // !lpszHrs || !lpszMins || !lpszSec
    //

    if ( i < 4) 
    {
        SYSTEMTIME  sCurSysTime;

        // this is a bad date; logging.
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));

        GetSystemTime(&sCurSysTime);

        if ( i < 2 )
        {
            //
            // If we really messed up the parsing, then
            //  just use the current time. 
            //

            *lpSysTime = sCurSysTime;
        }
        else
        {
            lpSysTime->wHour = sCurSysTime.wHour;
            lpSysTime->wMinute = sCurSysTime.wMinute;
            lpSysTime->wSecond = sCurSysTime.wSecond;
        }
    }


    if ((lpSysTime->wDay > 31)
    || (lpSysTime->wHour > 23)
    || (lpSysTime->wMinute > 59)
    || (lpSysTime->wSecond > 59)) 
    {
        fRet = FALSE;
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
        goto quit;
    }

    // Hack: we want the system time to be accurate. This is _suhlow_
    // The time passed in is in the local time zone; we have to convert this into GMT.
    
    if (iLastLettered==DATE_ANSI_INDEX_YEAR)
    {
        i--;
        
        FILETIME ft1, ft2;

        fRet = 
            SystemTimeToFileTime(lpSysTime, &ft1);

        if (fRet)
        {
            fRet = LocalFileTimeToFileTime(&ft1, &ft2);
            if (fRet)
            {
                fRet = FileTimeToSystemTime(&ft2, lpSysTime);
            }

        }
        
        if (!fRet)
        {
            DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
            goto quit;
        }
    }


    //
    // If FILETIME Ptr passed in/or we have an Offset to another Time Zone
    //   then convert to FILETIME for necessity/convenience
    //

    if ( lpft ||
         (i > DATE_INDEX_TZ &&
          rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT))
    {

        if ( lpft == NULL )
        {
            lpft = &ftTime;
        }

        fRet = 
            SystemTimeToFileTime(lpSysTime, lpft);

        if ( ! fRet )
        {
           DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
           goto quit;
        }

        if (i > DATE_INDEX_TZ &&
            rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT) 
        {
            // time zones are a very expensive operation, I want to know if this is a common case.
            DEBUG_PRINT(HTTP,
                        INFO,
                        ("*** Received a time zone: %d\n", (int) rgdwDateParseResults[DATE_INDEX_TZ]
                        ));

            //
            // if we received +/-nnnn as offset (hhmm), modify the output FILETIME
            //

            LONGLONG delta;
            BOOL negative;
            int offset;

            offset = (int) rgdwDateParseResults[DATE_INDEX_TZ];

            //
            // BUGBUG - some sites return +0000 instead of GMT. Presumably, this is
            //          an offset from GMT (== 0). What are the units? What are the
            //          boundaries (-12 hours to +12 hours? In seconds? (43200
            //          seconds in 12 hours, so can't be this)
            //

            //
            // BUGBUG - must handle negatives...and (-1 == GMT)
            //

            if (offset < 0) {
                negative = TRUE;
                offset = -offset;
            } else {
                negative = FALSE;
            }

            //
            // hours and minutes as 100nSec intervals
            //

            delta = (((offset / 100) * 60)
                    + (offset % 100)) * 60 * 10000000;
            if (negative) {
                delta = -delta;
            }
            AddLongLongToFT(lpft,delta);

            //
            // Chk to see if we Need to turn the offseted 
            //   FILETIME back into SYSTEMTIME.
            //

            if ( lpSysTime == &sSysTime )
            {
                fRet = FileTimeToSystemTime(lpft, lpSysTime);
            }
        }
    }

quit:

    DEBUG_LEAVE(fRet);

    return fRet;
}

PUBLIC 
BOOL 
FParseHttpDate(
    OUT FILETIME *lpft,
    IN  LPCSTR lpInputBuffer
    )

/*++

Routine Description:

    Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
     a FILETIME time format.  

Arguments:

    lpft - Ptr to FILETIME structure.  Used to store converted result.

    lpcszDateStr - Const Date string to parse.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    return FInternalParseHttpDate(
                lpft,                
                NULL, // SYSTEMTIME
                lpInputBuffer
                );
}



//+---------------------------------------------------------------------------
//
//  Function: FFileTimetoHttpDateTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------
BOOL FFileTimetoHttpDateTime(
    FILETIME *lpft,       // output filetime in GMT
    LPSTR   lpszBuff,
    LPDWORD lpdwSize
    )
{
    SYSTEMTIME  sSysTime;

    INET_ASSERT (*lpdwSize >= HTTP_DATE_SIZE);

    if (FileTimeToSystemTime(lpft, &sSysTime)) {
        *lpdwSize = wsprintf(lpszBuff, cszHttpDateFmt
                , rgszWkDay[sSysTime.wDayOfWeek]
                , sSysTime.wDay
                , rgszMon[sSysTime.wMonth-1]
                , sSysTime.wYear
                , sSysTime.wHour
                , sSysTime.wMinute
                , sSysTime.wSecond);
        return (TRUE);
    }
    return (FALSE);
}


BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    Takes a HTTP time/date string of the format "Sat, 6 Jan 1996 21:22:04 GMT"
    and converts it to a SYSTEMTIME structure

Arguments:

    lpszHttpDate    - pointer to time string to convert

    lpSystemTime    - pointer to converted time

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string

--*/

{
    return FInternalParseHttpDate(
                NULL, // FILETIME               
                lpSystemTime, 
                (LPCSTR)lpszHttpDate
                );
}


INTERNETAPI
BOOL
WINAPI
InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    OUT LPSTR lpszTime          // output string buffer
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    lpszTime: buffer to return the string in

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeA",
                     "%#x, %#x",
                     pst,
                     lpszTime
                     ));

    DWORD dwErr;
    BOOL fResult = TRUE;
    FILETIME ft;

    INET_ASSERT(!( IsBadReadPtr (pst, sizeof(*pst))
                || IsBadWritePtr (lpszTime, WINHTTP_TIME_FORMAT_BUFSIZE)
                || !SystemTimeToFileTime(pst, &ft)
                ));

    if (!SystemTimeToFileTime(pst, &ft))
    {
        fResult = FALSE;
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        SYSTEMTIME st;

        if (!FileTimeToSystemTime(&ft, &st))
        {
            // If a round trip isn't allowed (e.g. boundary case involving year
            // near 65535), then fail the call.
            fResult = FALSE;
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            // ST2FT ignores the week of the day; so if we round trip back,
            // it should place the correct week of the day.
            pst = &st;
        }

        if (fResult)
        {
            wsprintf (lpszTime, cszHttpDateFmt,
                rgszWkDay[pst->wDayOfWeek],
                pst->wDay,
                rgszMon[pst->wMonth-1],
                pst->wYear,
                pst->wHour,
                pst->wMinute,
                pst->wSecond);
        }
    }

    if (!fResult)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI
BOOL
WINAPI
InternetTimeToSystemTimeA(
    IN  LPCSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved
)
/*++

Routine Description:

    API. Takes a HTTP time/date string of the formats that we deal with
    and converts it to a SYSTEMTIME structure

Arguments:

    lpcszTimeString     - pointer to a null terminated date/time string to convert

    lpSysTime           - pointer to converted time

    dwreserved          - Reserved

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeToSystemTimeA",
                     "%q, %#x, %#x",
                     lpcszTimeString,
                     lpSysTime,
                     dwReserved
                     ));
    BOOL fRet;;
    
    INET_ASSERT(! (IsBadWritePtr (lpSysTime, sizeof(*lpSysTime)) 
                || IsBadStringPtr(lpcszTimeString, 0xffff)) );

    fRet = FInternalParseHttpDate(NULL, lpSysTime, (LPCSTR)lpcszTimeString);
    if (!fRet)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(INET, ERROR_INVALID_PARAMETER);
    }
    DEBUG_LEAVE_API(fRet);
    return (fRet);
}

INTERNETAPI
BOOL
WINAPI
WinHttpTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    OUT LPWSTR lpszTime         // output string buffer
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    lpszTime: buffer to return the string in

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpTimeFromSystemTimeW",
                     "%#x, %#x",
                     pst,
                     lpszTime
                     ));

    DWORD dwErr = ERROR_SUCCESS;;
    BOOL fResult = FALSE;
    MEMORYPACKET mpTime;
    DWORD ccSize;
    
    if (!lpszTime
        || IsBadWritePtr(lpszTime, WINHTTP_TIME_FORMAT_BUFSIZE)
        || !pst
        || IsBadReadPtr(pst, sizeof(*pst)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpTime.psStr = (LPSTR)ALLOC_BYTES(WINHTTP_TIME_FORMAT_BUFSIZE);
    if (!mpTime.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpTime.dwAlloc = WINHTTP_TIME_FORMAT_BUFSIZE;
    
    fResult = InternetTimeFromSystemTimeA(pst, mpTime.psStr);

    if (fResult)
    {
        if (0 == MultiByteToWideChar(CP_ACP, 0, mpTime.psStr, -1, lpszTime, WINHTTP_TIME_FORMAT_BUFSIZE/sizeof(WCHAR)))
        {
            INET_ASSERT(FALSE);
            fResult = FALSE;
            dwErr = ERROR_INSUFFICIENT_BUFFER;;
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI
BOOL
WINAPI
WinHttpTimeToSystemTime(
    IN  LPCWSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime
)
/*++

Routine Description:

    API. Takes a HTTP time/date string of the formats that we deal with
    and converts it to a SYSTEMTIME structure

Arguments:

    lpcszTimeString     - pointer to a null terminated date/time string to convert

    lpSysTime           - pointer to converted time

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpTimeFromSystemTime",
                     "%wq, %#x",
                     lpcszTimeString,
                     lpSysTime
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpTime;

    if (!lpcszTimeString
        || IsBadStringPtrW(lpcszTimeString,-1)
        || !lpSysTime
        || IsBadWritePtr(lpSysTime,sizeof(SYSTEMTIME)) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpcszTimeString, 0, mpTime);
    if (!mpTime.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpcszTimeString, mpTime);
    fResult = InternetTimeToSystemTimeA(mpTime.psStr, lpSysTime, NULL);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\proc.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    proc.h

Abstract:

    This file contains global procedure declarations for the HTTP API
    project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/


#ifndef _PROC_H_
#define _PROC_H_

#if defined(__cplusplus)
extern "C" {
#endif

#define SECURITY_WIN32
#include <sspi.h>
#include <issperr.h>

DWORD
pHttpGetUrlLen(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pHttpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszCWD,
    IN LPSTR lpszObjectName,
    IN LPSTR lpszExtension,
    IN DWORD dwPort,
    OUT LPSTR * lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pHttpBuildUrl(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwBuffSize
    );

BOOL FParseHttpDate(
    FILETIME *lpFt,
    LPCSTR lpcszDateStr
    );

BOOL FFileTimetoHttpDateTime(
    FILETIME *lpft,       // output filetime in GMT
    LPSTR   lpszBuff,
    LPDWORD lpdwSize
    );

#if defined(__cplusplus)
}
#endif

#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\open.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    open.cxx

Abstract:

    This file contains the implementation of the HttpOpenRequestA API.

    The following functions are exported by this module:

        HttpOpenRequestA
        WinHttpOpenRequest
        ParseHttpUrl
        ParseHttpUrl_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpOpenRequestA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// functions
//


INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb OPTIONAL,
    IN LPCSTR lpszObjectName OPTIONAL,
    IN LPCSTR lpszVersion OPTIONAL,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates a new HTTP request handle and stores the specified parameters
    in that context.

Arguments:

    hConnect            - An open Internet handle returned by InternetConnect()

    lpszVerb            - The verb to use in the request. May be NULL in which
                          case "GET" will be used

    lpszObjectName      - The target object for the specified verb. This is
                          typically a file name, an executable module, or a
                          search specifier. May be NULL in which case the empty
                          string will be used

    lpszVersion         - The version string for the request. May be NULL in
                          which case "HTTP/1.0" will be used

    lpszReferrer        - Specifies the address (URI) of the document from
                          which the URI in the request (lpszObjectName) was
                          obtained. May be NULL in which case no referer is
                          specified

    lplpszAcceptTypes   - Points to a NULL-terminated array of LPCTSTR pointers
                          to content-types accepted by the client. This value
                          may be NULL in which case the default content-type
                          (text/html) is used

    dwFlags             - open options

    dwContext           - app-supplied context value for call-backs

    BUGBUG: WHAT IS THE DEFAULT CONTENT-TRANSFER-ENCODING?

Return Value:

    HINTERNET

        Success - non-NULL (open) handle to an HTTP request

        Failure - NULL. Error status is available by calling GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "HttpOpenRequestA",
                     "%#x, %.80q, %.80q, %.80q, %.80q, %#x, %#08x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags,
                     dwContext
                     ));

    DWORD error;
    HINTERNET hConnectMapped = NULL;
    BOOL fRequestUsingProxy;
    HINTERNET hRequest = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();

    //
    // map the handle
    //

    error = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // find path from internet handle and validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters. Allow lpszVerb to default to "GET" if a NULL pointer
    // is supplied
    //

    if (!ARGUMENT_PRESENT(lpszVerb) || (*lpszVerb == '\0')) {
        lpszVerb = DEFAULT_HTTP_REQUEST_VERB;
    }

    //
    // if a NULL pointer or empty string is supplied for the object name, then
    // convert to the default object name (root object)
    //

    if (!ARGUMENT_PRESENT(lpszObjectName) || (*lpszObjectName == '\0')) {
        lpszObjectName = "/";
    }

    // check the rest of the parameters
    if (dwFlags & ~WINHTTP_OPEN_REQUEST_FLAGS_MASK)
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    // default to the current supported version
    char versionBuffer[sizeof("HTTP/4294967295.4294967295")];
    DWORD verMajor;
    DWORD verMinor;

    if (!ARGUMENT_PRESENT(lpszVersion) || (*lpszVersion == '\0')) {
        wsprintf(versionBuffer,
                 "HTTP/%d.%d",
                 HttpVersionInfo.dwMajorVersion,
                 HttpVersionInfo.dwMinorVersion
                 );
        lpszVersion = versionBuffer;
        verMajor = HttpVersionInfo.dwMajorVersion;
        verMinor = HttpVersionInfo.dwMinorVersion;
    } else if (strnicmp(lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR p = (LPSTR)lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&p, 0, (LPINT)&verMajor);
        while (!isdigit(*p) && (*p != '\0')) {
            ++p;
        }
        ExtractInt(&p, 0, (LPINT)&verMinor);
    } else {
        verMajor = 1;
        verMinor = 0;
    }

    //
    // if we have HTTP 1.1 enabled in the registry and the version is < 1.1
    // then convert
    //

    if (GlobalEnableHttp1_1
    && (((verMajor == 1) && (verMinor == 0)) || (verMajor < 1))) {
        lpszVersion = "HTTP/1.1";
    }

    //
    // allow empty strings to be equivalent to NULL pointer
    //

    if (ARGUMENT_PRESENT(lpszReferrer) && (*lpszReferrer == '\0')) {
        lpszReferrer = NULL;
    }

    // get the target port
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped;
    INTERNET_PORT hostPort;
    hostPort = pConnect->GetHostPort();

    //
    // set the per-thread info: parent handle object
    //

    _InternetSetObjectHandle(lpThreadInfo, hConnect, hConnectMapped);

    //
    // make local HTTP request handle object before we can add headers to it
    //

    error = RMakeHttpReqObjectHandle(hConnectMapped,
                                     &hRequest,
                                     NULL,  // (CLOSE_HANDLE_FUNC)wHttpCloseRequest
                                     dwFlags,
                                     dwContext
                                     );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    //
    // add the request line
    //

    INET_ASSERT((lpszVerb != NULL) && (*lpszVerb != '\0'));
    INET_ASSERT((lpszObjectName != NULL) && (*lpszObjectName != '\0'));
    INET_ASSERT((lpszVersion != NULL) && (*lpszVersion != '\0'));

    if (!pRequest->LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // encode the URL-path
    //

    error = pRequest->AddRequest((LPSTR)lpszVerb,
                                 (LPSTR)lpszObjectName,
                                 (LPSTR)lpszVersion
                                 );
    if (error != ERROR_SUCCESS) {
        pRequest->UnlockHeaders();
        goto quit;
    }

    //
    // set the method type from the verb
    //

    pRequest->SetMethodType(lpszVerb);

    //
    // add the headers
    //

    if (lpszReferrer != NULL) {
        error = pRequest->AddRequestHeader(HTTP_QUERY_REFERER,
                                           (LPSTR)lpszReferrer,
                                           lstrlen(lpszReferrer),
                                           0,
                                           CLEAN_HEADER
                                           );
        if (error != ERROR_SUCCESS) {
            pRequest->UnlockHeaders();
            goto quit;
        }
    }

    if (lplpszAcceptTypes != NULL) {
        while (*lplpszAcceptTypes) {
            error = pRequest->AddRequestHeader(HTTP_QUERY_ACCEPT,
                                               (LPSTR)*lplpszAcceptTypes,
                                               lstrlen(*(LPSTR*)lplpszAcceptTypes),
                                               0,
                                               CLEAN_HEADER | COALESCE_HEADER_WITH_COMMA
                                               );
            if (error != ERROR_SUCCESS) {
                pRequest->UnlockHeaders();
                goto quit;
            }
            ++lplpszAcceptTypes;
        }
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    pRequest->UnlockHeaders();

    //
    // change the object state to opened
    //

    pRequest->SetState(HttpRequestStateOpen);
    ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->SetRequestUsingProxy(
                                                    FALSE
                                                    );

    if (hostPort == INTERNET_INVALID_PORT_NUMBER)
    {
        if (dwFlags & WINHTTP_FLAG_SECURE)
        {
            pRequest->SetHostPort(INTERNET_DEFAULT_HTTPS_PORT);
        }
        else
        {
            pRequest->SetHostPort(INTERNET_DEFAULT_HTTP_PORT);
        }
    }
    else
    {
        pRequest->SetHostPort(hostPort);
    }

    //
    // if the object name is not set then all cache methods fail
    //

    URLGEN_FUNC fn;
    fn = (URLGEN_FUNC)pHttpGetUrlString;

    //
    // BUGBUG - change prototype to take LPCSTR
    //

    error = pRequest->SetObjectName((LPSTR)lpszObjectName,
                                    NULL,
                                    &fn
                                    );

quit:

    _InternetDecNestingCount(1);

done:

    if (error != ERROR_SUCCESS) {
        if (hRequest != NULL) {
            WinHttpCloseHandle(((HANDLE_OBJECT *)hRequest)->GetPseudoHandle());
        }

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
        hRequest = NULL;
    } else {

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hRequest = ((HANDLE_OBJECT *)hRequest)->GetPseudoHandle();
    }

    if (hConnectMapped != NULL) {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    DEBUG_LEAVE_API(hRequest);

    return hRequest;
}


INTERNETAPI
HINTERNET
WINAPI
WinHttpOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Creates a new HTTP request handle and stores the specified parameters
    in that context.

Arguments:

    hHttpSession        - An open Internet handle returned by InternetConnect()

    lpszVerb            - The verb to use in the request

    lpszObjectName      - The target object for the specified verb. This is
                          typically a file name, an executable module, or a
                          search specifier

    lpszVersion         - The version string for the request

    lpszReferrer        - Specifies the address (URI) of the document from
                          which the URI in the request (lpszObjectName) was
                          obtained. May be NULL in which case no referer is
                          specified

    lplpszAcceptTypes   - Points to a NULL-terminated array of LPCTSTR pointers
                          to content-types accepted by the client. This value
                          may be NULL in which case the default content-type
                          (text/html) is used

    dwFlags             - open options

    BUGBUG: WHAT IS THE DEFAULT CONTENT-TRANSFER-ENCODING?

Return Value:

    !NULL - An open handle to an HTTP request.

    NULL - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpOpenRequest",
                     "%#x, %.80wq, %.80wq, %.80wq, %.80wq, %#x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags
                     ));

    HINTERNET hConnectMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpVerb, mpObjectName, mpVersion, mpReferrer;
    MEMORYPACKETTABLE mptAcceptTypes;
    BOOL isLocal;
    BOOL isAsync;

    if (dwFlags &~ (WINHTTP_OPEN_REQUEST_FLAGS_MASK))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    // map the handle
    dwErr = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);
    if (dwErr != ERROR_SUCCESS) 
    {
        goto cleanup;
    }

    // find path from internet handle and validate handle
    dwErr = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpConnectHandle
                           );
    if (dwErr != ERROR_SUCCESS) 
    {
        goto cleanup;
    }

    if (lpszVerb)
    {
        if (IsBadStringPtrW(lpszVerb, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszVerb,0,mpVerb);
        if (!mpVerb.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszVerb,mpVerb);
    }
    if (lpszObjectName)
    {
        if (IsBadStringPtrW(lpszObjectName, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT*)hConnectMapped;
        DWORD dwCodePage = pConnect->GetCodePage();
        dwErr = ConvertUnicodeToMultiByte(lpszObjectName, dwCodePage, &mpObjectName, 
                (dwFlags&(WINHTTP_FLAG_ESCAPE_PERCENT|WINHTTP_FLAG_NULL_CODEPAGE))|WINHTTP_FLAG_DEFAULT_ESCAPE ); 
        if (dwErr != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    if (lpszVersion)
    {
        if (IsBadStringPtrW(lpszVersion, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszVersion,0,mpVersion);
        if (!mpVersion.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszVersion,mpVersion);
    }
    if (lpszReferrer)
    {
        if (IsBadStringPtrW(lpszReferrer, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszReferrer,0,mpReferrer);
        if (!mpReferrer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszReferrer,mpReferrer);
    }

    // Create a table of ansi strings
    if (lplpszAcceptTypes)
    {
        WORD csTmp=0;
        do
        {
            if (IsBadReadPtr(lplpszAcceptTypes+csTmp*sizeof(LPCWSTR), sizeof(LPCWSTR)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            if (lplpszAcceptTypes[csTmp])
            {
                if (IsBadStringPtrW(lplpszAcceptTypes[csTmp++], -1))
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                }
            }
            else
                break;
        }
        while (TRUE);

        mptAcceptTypes.SetUpFor(csTmp);
        for (WORD ce=0; ce < csTmp; ce++)
        {
            mptAcceptTypes.pdwAlloc[ce] = (lstrlenW(lplpszAcceptTypes[ce]) + 1)*sizeof(WCHAR);
            mptAcceptTypes.ppsStr[ce] = (LPSTR)ALLOC_BYTES(mptAcceptTypes.pdwAlloc[ce]*sizeof(CHAR));
            if (!mptAcceptTypes.ppsStr[ce])
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            mptAcceptTypes.pdwSize[ce] = WideCharToMultiByte(CP_ACP,
                                                                0,
                                                                lplpszAcceptTypes[ce],
                                                                mptAcceptTypes.pdwAlloc[ce]/sizeof(WCHAR),
                                                                mptAcceptTypes.ppsStr[ce],
                                                                mptAcceptTypes.pdwAlloc[ce],NULL,NULL);
        }
    }

    hInternet = HttpOpenRequestA(hConnect, mpVerb.psStr, mpObjectName.psStr, mpVersion.psStr,
                               mpReferrer.psStr, (LPCSTR*)mptAcceptTypes.ppsStr,
                               dwFlags, NULL);

cleanup:
    if (hConnectMapped != NULL)
    {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\query.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    query.cxx

Abstract:

    This file contains the implementation of the HttpQueryInfoA API.

    Contents:
        HttpQueryInfoA
        WinHttpQueryHeaders
        HTTP_REQUEST_HANDLE_OBJECT::QueryInfo

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpQueryInfoA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private prototypes
//

//
// private data
//

#define NUM_HEADERS ARRAY_ELEMENTS(GlobalKnownHeaders)

//
// functions
//


INTERNETAPI
BOOL
WINAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN     LPCSTR  lpszName OPTIONAL,   
    IN OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )

/*++

Routine Description:

    Queries a request or response header from the HTTP request handle

Arguments:

    hRequest            - an open HTTP request handle returned by
                          HttpOpenRequest()

    dwInfoLevel         - one of the HTTP_QUERY_* values indicating the
                          attribute to query. In addition, the following flags
                          can be set:

                            HTTP_QUERY_FLAG_REQUEST_HEADERS
                                - Causes the request headers to be queried. The
                                  default is to check the response headers

                            HTTP_QUERY_FLAG_SYSTEMTIME
                                - Causes headers that contain date & time
                                  information to be returned as SYSTEMTIME
                                  structures

                            HTTP_QUERY_FLAG_NUMBER
                                - Causes header value to be returned as a number.
                                  Useful for when the app knows it is expecting
                                  a numeric value, e.g. status code

    lpBuffer            - pointer to the buffer to receive the information.
                          If dwInfoLevel is HTTP_QUERY_CUSTOM then buffer
                          contains the header to query.

                          If NULL then we just return the required buffer length
                          to hold the header specified by dwInfoLevel

    lpdwBufferLength    - IN: contains the length (in BYTEs) of lpBuffer
                          OUT: size of data written to lpBuffer, or required
                               buffer length if ERROR_INSUFFICIENT_BUFFER
                               returned

    lpdwIndex           - IN: 0-based header index
                          OUT: next index to query, if success returned

Return Value:

    TRUE    - The query succeeded. lpBuffer contains the query information, and
              *lpdwBufferLength contains the size (in BYTEs) of the information

    FALSE   - The operation failed. Error status is available by calling
              GetLastError().

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpQueryInfoA",
                     "%#x, %s (%#x), %#x [%q], %#x [%d], %#x [%d]",
                     hRequest,
                     InternetMapHttpOption(dwInfoLevel & HTTP_QUERY_HEADER_MASK),
                     dwInfoLevel,
                     lpBuffer,
                     ((dwInfoLevel & HTTP_QUERY_HEADER_MASK) == HTTP_QUERY_CUSTOM)
                        ? lpBuffer
                        : "",
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     lpdwIndex,
                     lpdwIndex ? *lpdwIndex : 0
                     ));

    DWORD defaultIndex = 0;
    DWORD error;
    HINTERNET hRequestMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    //
    // find path from Internet handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    DWORD queryModifiers;
    DWORD infoLevel;

    queryModifiers = dwInfoLevel & HTTP_QUERY_MODIFIER_FLAGS_MASK;
    infoLevel = dwInfoLevel & HTTP_QUERY_HEADER_MASK;

    if (((infoLevel > HTTP_QUERY_MAX) && (infoLevel != HTTP_QUERY_CUSTOM))
    || (lpdwBufferLength == NULL)

    //
    // nip in the bud apps that want SYSTEMTIME AND NUMBER for same header(!)
    //

#define EXCLUSIVE_MODIFIERS (HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_FLAG_SYSTEMTIME)

    || ((dwInfoLevel & EXCLUSIVE_MODIFIERS) == EXCLUSIVE_MODIFIERS)) {

        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the app passed in a NULL lpdwIndex then it is asking for index 0
    //

    if (!ARGUMENT_PRESENT(lpdwIndex)) {
        lpdwIndex = &defaultIndex;
    }

    //
    // if the app is asking for one of the special query items - status code,
    // status text, HTTP version, or one of the raw header variants, then make
    // sure the index is 0. These pseudo-header types cannot be enumerated
    //

    if ((*lpdwIndex != 0)
    && ((infoLevel == HTTP_QUERY_VERSION)
        || (infoLevel == HTTP_QUERY_STATUS_CODE)
        || (infoLevel == HTTP_QUERY_STATUS_TEXT)
        || (infoLevel == HTTP_QUERY_RAW_HEADERS)
        || (infoLevel == HTTP_QUERY_RAW_HEADERS_CRLF))) {

        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    //
    // ensure that we can use any flags passed in
    //

    if (infoLevel == HTTP_QUERY_CUSTOM) {

        //
        // the app has given us a string to locate. We only accept strings in
        // the following format:
        //
        //  <header-to-find>[:][CR][LF]<EOS>
        //
        // The header cannot contain any spaces
        //

        INET_ASSERT(error == ERROR_SUCCESS);

        int queryLength = 0;
        int headerLength = 0;

        for (; lpszName[queryLength] != '\0'; ++queryLength) {
            if ((lpszName[queryLength] == ':')
            || (lpszName[queryLength] == '\r')
            || (lpszName[queryLength] == '\n')) {
                break;
            }
            if (iscntrl(lpszName[queryLength])
            || isspace(lpszName[queryLength])) {
                error = ERROR_INVALID_PARAMETER;
                break;
            }
        }        
    } else if ((queryModifiers & ~GlobalKnownHeaders[infoLevel].Flags) != 0) {
        error = ERROR_HTTP_INVALID_QUERY_REQUEST;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if NULL buffer pointer then app wants length of option: set buffer length
    // to zero
    //

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;
    if (dwInfoLevel & HTTP_QUERY_FLAG_REQUEST_HEADERS) {
        if (!IS_VALID_HTTP_STATE(pRequest, QUERY_REQUEST, TRUE)) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        }
    } else {
        if (!IS_VALID_HTTP_STATE(pRequest, QUERY_RESPONSE, TRUE)) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        }
    }
    if (error == ERROR_SUCCESS) {
        error = pRequest->QueryInfo(dwInfoLevel,
                                    lpszName,
                                    lpBuffer,
                                    lpdwBufferLength,
                                    lpdwIndex
                                    );
    }

quit:

    _InternetDecNestingCount(1);

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
        success = FALSE;
    } else {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwBufferLength = %d\n",
                        *lpdwBufferLength
                        ));

        DEBUG_DUMP_API(DUMP_API_DATA,
                       "Query data:\n",
                       lpBuffer,
                       *lpdwBufferLength
                       );

        success = TRUE;
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpQueryHeaders(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN     LPCWSTR lpszName OPTIONAL, 
       OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )

/*++

Routine Description:

    Queries information from the HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    dwInfoLevel - One of the HTTP_QUERY_* values indicating the attribute
        to query.

    lpBuffer - Pointer to the buffer to receive the information.

    dwBufferLength - On entry, contains the length (in BYTEs) of the data
        buffer. On exit, contains the size (in BYTEs) of the data written
        to lpBuffer.

Return Value:

    TRUE - The query succeeded. lpBuffer contains the query information,
        and lpBufferLength contains the size (in BYTEs) of the information.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryHeaders",
                     "%#x, %s (%#x), %wq, %#x, %#x [%d], %#x [%d]",
                     hRequest,
                     InternetMapHttpOption(dwInfoLevel & HTTP_QUERY_HEADER_MASK),
                     dwInfoLevel,
                     lpszName? lpszName : L"<null>",
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     lpdwIndex,
                     lpdwIndex ? *lpdwIndex : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult=FALSE;
    INET_ASSERT(hRequest);
    MEMORYPACKET mpBuffer, mpName;

    if (!lpdwBufferLength
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (lpBuffer && ProbeWriteBuffer(lpBuffer, *lpdwBufferLength))
        || (lpdwIndex && IsBadWritePtr(lpdwIndex, sizeof(*lpdwIndex))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if ((dwInfoLevel & HTTP_QUERY_HEADER_MASK) == HTTP_QUERY_CUSTOM)
    {
        if (!lpszName 
            || IsBadStringPtrW(lpszName, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszName,0,mpName);
        if (!mpName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszName,mpName);
    }

    if (lpBuffer)
    {
        mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
        mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    fResult = HttpQueryInfoA(hRequest,dwInfoLevel, mpName.psStr,
        mpBuffer.psStr, &mpBuffer.dwSize, lpdwIndex);

    if (!((dwInfoLevel & HTTP_QUERY_FLAG_NUMBER) ||
        (dwInfoLevel & HTTP_QUERY_FLAG_SYSTEMTIME)))
    {
        // This is the default, we've been handed back a string.
        if (fResult)
        {
            *lpdwBufferLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                        NULL, 0);
            *lpdwBufferLength *= sizeof(WCHAR);
            if (*lpdwBufferLength<=mpBuffer.dwAlloc)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, mpBuffer.dwAlloc/sizeof(WCHAR));
                *lpdwBufferLength -= sizeof(WCHAR);
            }
            else
            {
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }
    }
    else
    {
        if (fResult)
        {
            memcpy(lpBuffer, (LPVOID)mpBuffer.psStr, mpBuffer.dwSize);
        }
        *lpdwBufferLength = mpBuffer.dwSize;
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

//
// object methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryInfo(
    IN DWORD dwInfoLevel,
    IN LPCSTR headerName,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Header query method for HTTP_REQUEST_HANDLE_OBJECT class

Arguments:

    dwInfoLevel         - level of info (header) to get

    headerName          - name of header with HTTP_QUERY_CUSTOM

    lpBuffer            - pointer to user's buffer

    lpdwBufferLength    - IN: length of user's buffer
                          OUT: length of returned information or required buffer
                               length if insufficient

    lpdwIndex           - IN: 0-based index of named header to return
                          OUT: index of next header if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

                  ERROR_HTTP_INVALID_QUERY_REQUEST
                    The caller asked for e.g. the Accept: header to be returned
                    as a SYSTEMTIME structure, or for e.g. a request header that
                    only exists for response headers (status code, for example)

                  ERROR_INSUFFICIENT_BUFFER
                    User's buffer not large enough to hold requested data

--*/

{
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT(lpdwIndex != NULL);

    DWORD error;
    DWORD headerNameLength;
    DWORD modifiers;

    modifiers = dwInfoLevel & HTTP_QUERY_MODIFIER_FLAGS_MASK;
    dwInfoLevel &= HTTP_QUERY_HEADER_MASK;

    if (dwInfoLevel == HTTP_QUERY_CUSTOM) {
        for (headerNameLength = 0; ; ++headerNameLength) {
            if ((headerName[headerNameLength] == '\0')
            || (headerName[headerNameLength] == ':')
            || (headerName[headerNameLength] == '\r')
            || (headerName[headerNameLength] == '\n')) {
                break;
            }
        }
    } else if (dwInfoLevel == HTTP_QUERY_REQUEST_METHOD) {

        LPSTR lpszVerb;
        DWORD dwVerbLength;

        lpszVerb = _RequestHeaders.GetVerb(&dwVerbLength);
        if ((lpszVerb != NULL) && (dwVerbLength != 0)) {

            //
            // the verb is (usually) space terminated
            //

            while ((dwVerbLength > 0) && (lpszVerb[dwVerbLength - 1] == ' ')) {
                --dwVerbLength;
            }

            //
            // *lpdwBufferLength will be 0 if lpBuffer is NULL
            //

            if (*lpdwBufferLength > dwVerbLength) {
                memcpy(lpBuffer, lpszVerb, dwVerbLength);
                ((LPBYTE)lpBuffer)[dwVerbLength] = '\0';
                error = ERROR_SUCCESS;
            } else {
                ++dwVerbLength;
                error = ERROR_INSUFFICIENT_BUFFER;
            }
            *lpdwBufferLength = dwVerbLength;
        } else {
            error = ERROR_HTTP_HEADER_NOT_FOUND;
        }
        goto quit;
    } else {
        headerName = GlobalKnownHeaders[dwInfoLevel].Text;
        headerNameLength = GlobalKnownHeaders[dwInfoLevel].Length;
    }

    if (modifiers & HTTP_QUERY_FLAG_REQUEST_HEADERS) {

        //
        // we can always query request headers, even if the server is down
        // level
        //

        switch (dwInfoLevel) {
        case HTTP_QUERY_VERSION:
        case HTTP_QUERY_STATUS_CODE:
        case HTTP_QUERY_STATUS_TEXT:

            //
            // can't query these sub-header values from the request headers
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;
            break;

        case HTTP_QUERY_RAW_HEADERS:
        case HTTP_QUERY_RAW_HEADERS_CRLF:
            error = _RequestHeaders.QueryRawHeaders(
                        NULL,
                        dwInfoLevel == HTTP_QUERY_RAW_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_ECHO_HEADERS:
        case HTTP_QUERY_ECHO_HEADERS_CRLF:
            error = QueryRequestHeadersWithEcho(
                        dwInfoLevel == HTTP_QUERY_ECHO_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_CUSTOM:

            if (_RequestHeaders.LockHeaders())
            {
                error = QueryRequestHeader(headerName,
                                           headerNameLength,
                                           lpBuffer,
                                           lpdwBufferLength,
                                           modifiers,
                                           lpdwIndex
                                           );

                _RequestHeaders.UnlockHeaders();
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            break;

        default:

            if (_RequestHeaders.LockHeaders())
            {
                error = QueryRequestHeader( dwInfoLevel,
                                            lpBuffer,
                                            lpdwBufferLength,
                                            modifiers,
                                            lpdwIndex
                                            );

                _RequestHeaders.UnlockHeaders();
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            break;

        }
    } else if (!IsDownLevel()) {
        switch (dwInfoLevel) {
        case HTTP_QUERY_VERSION:
            error = QueryResponseVersion(lpBuffer, lpdwBufferLength);
            break;

        case HTTP_QUERY_STATUS_CODE:
            error = QueryStatusCode(lpBuffer, lpdwBufferLength, modifiers);
            break;

        case HTTP_QUERY_STATUS_TEXT:
            error = QueryStatusText(lpBuffer, lpdwBufferLength);
            break;

        case HTTP_QUERY_RAW_HEADERS:
        case HTTP_QUERY_RAW_HEADERS_CRLF:
            error = _ResponseHeaders.QueryRawHeaders(
                        (LPSTR)_ResponseBuffer,
                        dwInfoLevel == HTTP_QUERY_RAW_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_ECHO_HEADERS:
        case HTTP_QUERY_ECHO_HEADERS_CRLF:
            error = ERROR_HTTP_INVALID_QUERY_REQUEST;
            break;

        case HTTP_QUERY_CUSTOM:

            if (_RequestHeaders.LockHeaders())
            {
                error = QueryResponseHeader(
                                            headerName,
                                            headerNameLength,
                                            lpBuffer,
                                            lpdwBufferLength,
                                            modifiers,
                                            lpdwIndex
                                            );

                _RequestHeaders.UnlockHeaders();
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            break;

        default:

            if (_ResponseHeaders.LockHeaders())
            {
                error = QueryResponseHeader(
                                            dwInfoLevel,
                                            lpBuffer,
                                            lpdwBufferLength,
                                            modifiers,
                                            lpdwIndex
                                            );

                _ResponseHeaders.UnlockHeaders();
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            break;
        }
    } else {

        //
        // there are no response headers from down-level servers
        //

        error = ERROR_HTTP_HEADER_NOT_FOUND;
    }

quit:

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeadersWithEcho(
    IN BOOL bCrlfTerminated,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
/*++

Routine Description:

    Header query for request headers with echo headers added if any..

Arguments:

    bCrlfTerminated     - should the headers be seperated by CRLF's
    lpBuffer            - pointer to user's buffer

    lpdwBufferLength    - IN: length of user's buffer
                          OUT: length of returned information or required buffer
                               length if insufficient

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

                  ERROR_INSUFFICIENT_BUFFER
                    User's buffer not large enough to hold requested data

--*/
{
    INET_ASSERT(lpdwBufferLength != NULL);

    DWORD error;
    LPSTR lpszEchoHeaderIn = NULL ;
    LPSTR lpszEchoHeaderOut = NULL;
    DWORD cbHeaderIn = 0;
    DWORD cbHeaderOut = 0;
    BOOL bEchoPresent = FALSE;

    // List of headers to filter out of the Request headers

    LPSTR rglpFilter [ ] =
    {
        GlobalKnownHeaders[HTTP_QUERY_AUTHORIZATION].Text,
        GlobalKnownHeaders[HTTP_QUERY_CONNECTION].Text,
        GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Text,
        GlobalKnownHeaders[HTTP_QUERY_COOKIE].Text,
        GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Text,
        GlobalKnownHeaders[HTTP_QUERY_HOST].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_MODIFIED_SINCE].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_MATCH].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_NONE_MATCH].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_RANGE].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_UNMODIFIED_SINCE].Text,
        GlobalKnownHeaders[HTTP_QUERY_PROXY_AUTHORIZATION].Text,
        GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Text,
        GlobalKnownHeaders[HTTP_QUERY_RANGE].Text,
        GlobalKnownHeaders[HTTP_QUERY_UNLESS_MODIFIED_SINCE].Text,
    };

    if (!_ResponseHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = FastQueryResponseHeader(HTTP_QUERY_ECHO_REQUEST,
                                    (LPVOID *)&lpszEchoHeaderIn,
                                    &cbHeaderIn,
                                    0);

    if (error == ERROR_SUCCESS)
    {
        DWORD cbEchoRequest = GlobalKnownHeaders[HTTP_QUERY_ECHO_REQUEST].Length;
        DWORD cbEchoReply   = GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Length;

        bEchoPresent = TRUE;

        // Add echo-reply: to the begining of the header.
        cbHeaderOut = cbEchoReply  + 1                      // For echo-reply:
                        + cbHeaderIn                        // Send back the stuff from the header.
                        + (bCrlfTerminated ? 2 : 1)         // 2 for CRLF
                        + 1;                                // 1 for NULL terminator

        lpszEchoHeaderOut = (LPSTR) _alloca(cbHeaderOut); // Add 1 for null terminator.

        if ( lpszEchoHeaderOut == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        LPSTR lpsz = lpszEchoHeaderOut;

        memcpy(lpszEchoHeaderOut, GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Text, cbEchoReply);
        lpsz += cbEchoReply;

        lpsz[0] = ':';
        lpsz++;


        memcpy(lpsz, lpszEchoHeaderIn, cbHeaderIn );
        lpsz += cbHeaderIn;


        if ( bCrlfTerminated)
        {
            lpsz[0] = '\r';
            lpsz[1] = '\n';
            lpsz += 2;
        }
        else
        {
            lpsz[0] = '\0';
            lpsz++;
        }

        *lpsz = '\0';
    }

    DWORD dwBufferLength;
    dwBufferLength = *lpdwBufferLength;


    error = _RequestHeaders.QueryFilteredRawHeaders(
                NULL,
                rglpFilter,
                sizeof(rglpFilter)/sizeof(rglpFilter[0]),
                TRUE,
                TRUE,
                bCrlfTerminated,
                lpBuffer,
                lpdwBufferLength
                );

    if ( !bEchoPresent )
    {
        // Nothing more to do in this case.
    }
    else if ( error == ERROR_SUCCESS )
    {
        DWORD dwBufferReqd = *lpdwBufferLength + cbHeaderOut;
        // Check if we have space to add extra headers.
        if (dwBufferReqd <= dwBufferLength)
        {
            memcpy((LPSTR)lpBuffer + *lpdwBufferLength, lpszEchoHeaderOut, cbHeaderOut);
            *lpdwBufferLength += cbHeaderOut - 1; // -1 to exclude terminating '\0'
        }
        else
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            // There is a NULL termination count included both in cbHeaderOut and *lpdwBufferLength
            // hence the -1.
            *lpdwBufferLength += cbHeaderOut - 1 ;
        }
    }
    else if ( error == ERROR_INSUFFICIENT_BUFFER )
    {
        *lpdwBufferLength += cbHeaderOut - 1 ;
    }
    else
    {
        // For other errors just return the original error from QueryRawHeaders.
    }

done:
    _ResponseHeaders.UnlockHeaders();

quit:
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\read.cxx ===
/*++

Copyright (c) 1994-1997 Microsoft Corporation

Module Name:

    read.cxx

Abstract:

    This file contains the implementation of the HttpReadData API.

    Contents:
        HttpReadData
        CFsm_HttpReadData::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::ReadData
        CFsm_ReadData::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable
        CFsm_HttpQueryAvailable::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::QueryAvailable_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::DrainResponse
        CFsm_DrainResponse::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpReadData remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private prototypes
//

PRIVATE
VOID
FilterHeaders(
    IN LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwLen
    );

//
// functions
//


DWORD
HttpReadData(
    IN HINTERNET hRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    Reads a block of data from an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetReadFile() which
        globally validates parameters for all Internet data read
        functions

         2. We will never get a request for 0 bytes at this level. This
        request will have been handled in InternetReadFile()

Arguments:

    hRequest                - mapped HTTP request handle

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToRead   - number of bytes to read into lpBuffer

    lpdwNumberOfBytesRead   - number of bytes read into lpBuffer

    dwSocketFlags           - controlling socket operation

Return Value:

    TRUE - The data was read successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HttpReadData",
                 "%#x, %#x, %d, %#x, %#x",
                 hRequest,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead,
                 dwSocketFlags
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT* pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT*) hRequest;

    error = DoFsm(New CFsm_HttpReadData(lpBuffer,
                                        dwNumberOfBytesToRead,
                                        lpdwNumberOfBytesRead,
                                        dwSocketFlags,
                                        pRequest
                                       ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpReadData::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpReadData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpReadData * stateMachine = (CFsm_HttpReadData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->HttpReadData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm(
    IN CFsm_HttpReadData * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpReadData & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        if (!CheckReceiveResponseState() || !IsValidHttpState(READ)) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
            goto quit;
        }
        error = ReadData(fsm.m_lpBuffer,
                         fsm.m_dwNumberOfBytesToRead,
                         fsm.m_lpdwNumberOfBytesRead,
                         FALSE, // BUGBUG RFirthRemove on chkin
                         fsm.m_dwSocketFlags
                         );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    PERF_LOG(PE_TRACE, 0x1002);

    DEBUG_LEAVE(error);

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadData(
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN BOOL fNoAsync, // BUGBUG RFirthRemove on DrainSocket checkin
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT ReadData method

    Reads data into users buffer. Reads from header buffer if data exists
    there, or reads from the socket

Arguments:

    lpBuffer                - pointer to users buffer

    dwNumberOfBytesToRead   - size of buffer/number of bytes to read

    lpdwNumberOfBytesRead   - pointer to returned number of bytes read

    fNoAsync                - TRUE if we want to override defaults and have
                              no Async Read.

    dwSocketFlags           - controlling socket operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadData",
                 "%#x, %d, %#x, %B, %#x",
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead,
                 fNoAsync,
                 dwSocketFlags
                 ));

    DWORD error = DoFsm(New CFsm_ReadData(lpBuffer,
                                          dwNumberOfBytesToRead,
                                          lpdwNumberOfBytesRead,
                                          fNoAsync,
                                          dwSocketFlags,
                                          this
                                          ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ReadData::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_ReadData * stateMachine = (CFsm_ReadData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->ReadData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm(
    IN CFsm_ReadData * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_LOG(PE_TRACE, 0x6001);

    CFsm_ReadData & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    if (fsm.GetState() == FSM_STATE_CONTINUE) {

        PERF_LOG(PE_TRACE, 0x6101);

        error = fsm.GetError();
        goto receive_continue;
    }

    fsm.m_dwBytesRead = 0;
    fsm.m_dwBufferLeft = fsm.m_dwNumberOfBytesToRead;
    fsm.m_nBytesCopied = 0;

    //
    // if there's no data then we're done
    //

    if (!IsData()) {

        DEBUG_PRINT(HTTP,
                    ERROR,
                    ("!IsData()\n"
                    ));

        SetState(HttpRequestStateReopen);

        INET_ASSERT(error == ERROR_SUCCESS);

        goto quit;
    }

    //
    // If using keep-alive, reduce output buffer so we don't over-read.
    //

    if (IsKeepAlive() && IsContentLength()) {
        if (_BytesRemaining == 0) {

            INET_ASSERT(error == ERROR_SUCCESS);

            PERF_LOG(PE_TRACE, 0x6102);

            goto done;
        }

        PERF_LOG(PE_TRACE, 0x6103);

        fsm.m_dwBufferLeft = min(fsm.m_dwBufferLeft, _BytesRemaining);
    }

    //
    // if there's data left in the response buffer then copy it
    //

    fsm.m_bEof = FALSE;

    if (IsBufferedData()) {

        DWORD amountToCopy = min(fsm.m_dwNumberOfBytesToRead, BufferDataAvailToRead());

        if (amountToCopy != 0) {

            PERF_LOG(PE_TRACE, 0x6104);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Copying %d (%#x) bytes from header buffer @ %#x - %d left\n",
                        amountToCopy,
                        amountToCopy,
                        BufferedDataStart(),
                        BufferDataAvailToRead() - amountToCopy
                        ));

            memcpy(fsm.m_lpBuffer, BufferedDataStart(), amountToCopy);
            ReduceDataAvailToRead(amountToCopy);
            fsm.m_dwBytesRead += amountToCopy;
            fsm.m_dwBufferLeft -= amountToCopy;
            fsm.m_nBytesCopied += amountToCopy;

            //
            // we don't update lpBuffer here. Receive() takes the address of
            // the start of the buffer
            //

        }

        //
        // if we exhausted all the buffer space, then we're done
        //

        if (fsm.m_dwBufferLeft == 0) {

            PERF_LOG(PE_TRACE, 0x6105);

            goto done;
        }
    }

    //
    // find out if we're async. Even though the handle was created for async I/O
    // the request may be satisfied immediately
    //

    DWORD asyncFlags;

    if ( fsm.m_fNoAsync )   // BUGBUG RFirthRemove on Checkin of DrainSocket
        asyncFlags = 0;
    else
        asyncFlags = (IsAsyncHandle()
                        && (fsm.m_dwBufferLeft > AvailableDataLength()))
                   ? SF_NON_BLOCKING
                   : 0
                   ;

    //
    // if we have data already received in the query buffer, then return that
    //

    if (HaveQueryData()) {

        PERF_LOG(PE_TRACE, 0x6106);

        DWORD nCopied;

        nCopied = CopyQueriedData((LPVOID)((LPBYTE)fsm.m_lpBuffer + fsm.m_dwBytesRead),
                                  fsm.m_dwBufferLeft
                                  );

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Copied %d (%#x) bytes from query buffer @ %#x - %d left\n",
                    nCopied,
                    nCopied,
                    (LPBYTE)_QueryBuffer - _QueryOffset,
                    _QueryBytesAvailable
                    ));

        fsm.m_dwBytesRead += nCopied;
        fsm.m_dwBufferLeft -= nCopied;
        fsm.m_nBytesCopied += nCopied;
        if (fsm.m_dwBufferLeft == 0) {
            goto done;
        }
    }

    if (HaveReadFileExData()) {
        PERF_LOG(PE_TRACE, 0x6107);
        *(LPBYTE)fsm.m_lpBuffer = GetReadFileExData();
        --fsm.m_dwNumberOfBytesToRead;
        --fsm.m_dwBufferLeft;
        ++fsm.m_dwBytesRead;

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Copied 1 byte (%#x) from ReadFileEx buffer %#x\n",
                    (BYTE)_ReadFileExData & 0xff,
                    &_ReadFileExData
                    ));

        if (fsm.m_dwBufferLeft == 0) {
            goto done;
        }
    }

    //
    // If the Chunk parser claims we're done, then we're done,
    //  stop ready and tell the reader
    //

    if ( IsChunkEncoding() && IsDecodingFinished() )
    {
        PERF_LOG(PE_TRACE, 0x6108);
        fsm.m_bEof = TRUE;
        goto done;
    }

    //
    // we're about to check the socket. Make sure its valid to do so
    //

    //INET_ASSERT(_Socket != NULL);

    if ((_Socket == NULL) || !_Socket->IsOpen()) {

        //
        // socket was closed - no more data
        //

        //
        // there is no more data to be received on this object
        //

        SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
        fsm.m_bEof = TRUE;
        PERF_LOG(PE_TRACE, 0x6109);
        goto quit;
    }

read_again:

    fsm.m_nBytes = fsm.m_dwBytesRead;

    //
    // if we had a content-length and we don't think there is any data left to
    // read then we're done
    //

    if (IsContentLength() && (_BytesInSocket == 0)) {
        fsm.m_bEof = TRUE;
        PERF_LOG(PE_TRACE, 0x6110);
        goto done;
    }

    //
    // receive data into user's buffer. Because we don't own the buffer, we
    // cannot resize it
    //

    LPVOID lpBuffer;
    DWORD dwBytesToRead;
    DWORD dwBufferLeft;
    DWORD dwBytesRead;

    lpBuffer = fsm.m_lpBuffer;
    dwBytesToRead = fsm.m_dwNumberOfBytesToRead;
    dwBufferLeft = fsm.m_dwBufferLeft;
    dwBytesRead = fsm.m_dwBytesRead;

    //INET_ASSERT(!(fsm.m_dwSocketFlags & SF_NO_WAIT)
    //            ? (fsm.m_dwBufferLeft <= _BytesRemaining)
    //            : TRUE);

    PERF_LOG(PE_TRACE, 0x6111);

    if (IsBadNSServer() && !IsConnCloseResponse()) {
        SetBadNSReceiveTimeout();
    }

    error = _Socket->Receive(&fsm.m_lpBuffer,
                             &fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBufferLeft,
                             &fsm.m_dwBytesRead,
                             0,
                             SF_INDICATE
                             | ((fsm.m_dwSocketFlags & SF_NO_WAIT)
                                ? SF_NO_WAIT
                                : (IsChunkEncoding() ? 0 : SF_RECEIVE_ALL)),
                             &fsm.m_bEof
                             );

    //
    // only if we performed an asynchronous no-wait receive and there was no
    // data available in the socket will we get WSAEWOULDBLOCK. Make another
    // receive request, this time without no-wait. It will complete
    // asynchronously and the app must make another no-wait request
    //

    if (error == WSAEWOULDBLOCK) {

        PERF_LOG(PE_TRACE, 0x6112);

        INET_ASSERT(fsm.m_dwSocketFlags & SF_NO_WAIT);
        INET_ASSERT(!fsm.m_bEof);

        //
        // BUGBUG - IsAsyncHandle() || IsAsyncRequest()
        //

        if ((fsm.m_dwBytesRead == 0) && IsAsyncHandle()) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Initiating wait-for-data (1-byte read)\n"
                        ));

            fsm.m_lpBuffer = (LPVOID)&_ReadFileExData;
            fsm.m_dwNumberOfBytesToRead = 1;
            fsm.m_dwBufferLeft = 1;
            fsm.m_dwSocketFlags &= ~SF_NO_WAIT;

            INET_ASSERT(!_HaveReadFileExData);

            SetReadFileExData();

            _ReadFileExData = 0;

            //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

            PERF_LOG(PE_TRACE, 0x6113);

            if (IsBadNSServer() && !IsConnCloseResponse()) {
                SetBadNSReceiveTimeout();
            }

            error = _Socket->Receive(&fsm.m_lpBuffer,
                                     &fsm.m_dwNumberOfBytesToRead,
                                     &fsm.m_dwBufferLeft,
                                     &fsm.m_dwBytesRead,
                                     0,
                                     fsm.m_dwSocketFlags,
                                     &fsm.m_bEof
                                     );
            if (error == ERROR_SUCCESS) {

                PERF_LOG(PE_TRACE, 0x6114);

                BOOL fReadNothing = (fsm.m_dwBytesRead == 0 ? TRUE : FALSE);

                //
                // we have successfully read a single byte from the socket.
                //

                //INET_ASSERT(FALSE);

                fsm.m_lpBuffer = lpBuffer;
                fsm.m_dwNumberOfBytesToRead = dwBytesToRead;
                fsm.m_dwBufferLeft = dwBufferLeft;
                fsm.m_dwBytesRead = dwBytesRead;
                if (fReadNothing) {
                    // Don't copy if nothing was actually read.
                    ResetReadFileExData();
                }
                else {
                    *(LPBYTE)fsm.m_lpBuffer = GetReadFileExData();
                    --fsm.m_dwBufferLeft;
                    ++fsm.m_dwBytesRead;
                }

                //
                // BUGBUG - if socket unblocked already, should go round & read
                //          again, not just return 1 byte
                //

            }

            PERF_LOG(PE_TRACE, 0x6115);

        } else {

            PERF_LOG(PE_TRACE, 0x6116);

            DEBUG_PRINT(HTTP,
                        WARNING,
                        ("Not initiating wait-for-data: bytesRead = %d, asyncHandle = %B\n",
                        fsm.m_dwBytesRead,
                        IsAsyncHandle()
                        ));

            //
            // read data from buffers but nothing available from socket
            //

            error = ERROR_SUCCESS;
        }
    }

    if (error == ERROR_IO_PENDING) {
        PERF_LOG(PE_TRACE, 0x6117);
        goto quit_pending;
    }

receive_continue:

    PERF_LOG(PE_TRACE, 0x6118);

    //
    // if we timed-out while talking to 'bad' NS server (returns HTTP/1.1 but
    // content-length or chunked encoding info) then close the connection and
    // reset any RFX status. We return SUCCESS in this case
    //

    if ((error == ERROR_WINHTTP_TIMEOUT) && IsBadNSServer()) {

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Bad NS server: Closing connection %#x/%d on timeout\n",
                    _Socket ? _Socket->GetSocket() : -1,
                    _Socket ? _Socket->GetSourcePort() : -1
                    ));

        CloseConnection(TRUE);
        ResetReadFileExData();
        SetData(FALSE);
        fsm.m_bEof = TRUE;
        error = ERROR_SUCCESS;
        goto quit;
    }
    if (error == ERROR_SUCCESS) {
        if (IsContentLength()) {

            INET_ASSERT(fsm.m_dwBytesRead >= fsm.m_nBytes);

            _BytesInSocket -= fsm.m_dwBytesRead - fsm.m_nBytes;

            INET_ASSERT((int)_BytesInSocket >= 0);

            if ((int)_BytesInSocket < 0) {
                _BytesInSocket = 0;
            }
        }

        if ( IsChunkEncoding() && !(HaveReadFileExData()))
        {

            PERF_LOG(PE_TRACE, 0x6119);

            DWORD dwChunkBytesRead = 0;
            DWORD dwChunkBytesWritten = 0;

            error = _ResponseFilterList.Decode(
                (LPBYTE)fsm.m_lpBuffer + fsm.m_nBytesCopied,
                fsm.m_dwBytesRead - fsm.m_nBytesCopied,
                NULL,
                NULL,
                &dwChunkBytesRead,
                &dwChunkBytesWritten);

            // When no error, the number of bytes read should match the input byte count
            INET_ASSERT(error == ERROR_SUCCESS &&  // for now, let's see all errors
                        fsm.m_dwBytesRead - fsm.m_nBytesCopied == dwChunkBytesRead);

            fsm.m_dwBufferLeft += (fsm.m_dwBytesRead - fsm.m_nBytesCopied);
            fsm.m_dwBytesRead  -= (fsm.m_dwBytesRead - fsm.m_nBytesCopied);

            fsm.m_dwBufferLeft -= dwChunkBytesWritten;
            fsm.m_dwBytesRead  += dwChunkBytesWritten;
            fsm.m_nBytesCopied += dwChunkBytesWritten;

            if ( error != ERROR_SUCCESS )
            {
                goto quit;
            }

            // Chunked transfers tell us when to expect EOF
            if ( IsDecodingFinished() )
            {
                fsm.m_bEof = TRUE;
            }
            else if (fsm.m_dwBytesRead < fsm.m_dwNumberOfBytesToRead &&
                     !fsm.m_bEof)
            {
                // read some more
                goto read_again;
            }
        }
    } else {

        PERF_LOG(PE_TRACE, 0x6121);

        DEBUG_PRINT(HTTP,
                    ERROR,
                    ("error %d on socket %#x\n",
                    error,
                    _Socket->GetSocket()
                    ));

        //
        // socket error
        //

        SetState(HttpRequestStateError);

        //
        // cause connection to be closed/released
        //

        fsm.m_bEof = TRUE;
    }

done:

    //
    // only update bytes remaining, EOF and the current stream position values
    // if we're returning data. If we just completed reading ReadFileEx data
    // then don't update. The 1 byte of ReadFileEx data will be read on the next
    // read proper
    //

    if (HaveReadFileExData()) {
        goto quit;
    }

    //
    // whether the data came from the response buffer or the socket, if we have
    // a content-length, update the amount of data left to retrieve
    //

    if (IsChunkEncoding()
        && IsDecodingFinished()
        && (_QueryBytesAvailable == 0)
        && (BufferDataAvailToRead() == 0)) {
        fsm.m_bEof = TRUE;
    } else if (IsKeepAlive() && IsContentLength()) {
        _BytesRemaining -= fsm.m_dwBytesRead;

        INET_ASSERT((int)_BytesRemaining >= 0);
        //
        // if we have read all the entity-body then we can release the keep-alive
        // connection, or close the socket
        //

        if (_BytesRemaining<=0 && ((int)_BytesRemaining>=-2)) {
            // We might overshoot by 1 or 2 because of server misinformation.
            fsm.m_bEof = TRUE;
        }
    }

    DEBUG_PRINT(HTTP,
                INFO,
                ("read %d bytes\n",
                fsm.m_dwBytesRead
                ));

    //
    // if we reached the end of the connection - either the end of the server
    // connection for real, or we received all indicated data on a keep-alive
    // connection - then close the connection
    //

    if (fsm.m_bEof) {

        PERF_LOG(PE_TRACE, 0x6122);

        //
        // if we don't need to keep hold of the connection, release it. In the
        // case of multi-part authentication (NTLM) over keep-alive connection
        // we need to keep the connection. With Kerberos, we don't need to keep
        // the connection.
        //

        if (GetAuthState() != AUTHSTATE_CHALLENGE) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("end of data - freeing connection %#x (Auth State = %s)\n",
                        _Socket ? _Socket->GetSocket() : 0,
                        (GetAuthState() == AUTHSTATE_NONE)
                            ? "NONE"
                            : ((GetAuthState() == AUTHSTATE_NEGOTIATE)
                                ? "NEGOTIATE"
                                : ((GetAuthState() == AUTHSTATE_CHALLENGE)
                                    ? "CHALLENGE"
                                    : "?"))
                        ));

            CloseConnection(FALSE);

        } else {

            // AUTHSTATE_CHALLENGE - check if request is through proxy or is kerberos.

            // When IsRequestUsingProxy returns TRUE, there are three types of connections possible:
            // 1) http request forwarded by the proxy to the server
            // 2) connect request to proxy to establish https tunnel
            // 3) using https tunnel through proxy to the server

            // I believe the various methods return:
            // http conn. tunnel
            // IsRequestUsingProxy                          1 1 1
            // IsViaProxy                       1 1 0
            // IsTunnel 0   1 0
            // IsTalkingToSecureServerViaProxy 0 0 1

            INET_ASSERT(_pAuthCtx->GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE);

            if (GetAuthCtx()->GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS)
            {
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("freeing connection - kerberos and auth state challenge\n"
                            ));
                CloseConnection(FALSE);
            }                
            else if (IsRequestUsingProxy()
                && !(IsTunnel() || IsTalkingToSecureServerViaProxy())
                && (_pAuthCtx->GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED)
                && !_pAuthCtx->_fIsProxy)
            {
                // Ordinarily, if the auth state is AUTHSTATE_CHALLENGE we wish to keep
                // the current connection open (keep alive) so that the response will go
                // out on the same socket. NTLM, which requires keep-alive, does not
                // work when going through a proxy. In the case that the proxy does not return keep-alive with the
                // challenge (Catapult appears to be the only proxy that does) we want to
                // close the socket to ensure that it is not subsequently used for the response.

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("freeing connection - auth state challenge\n"
                            ));
                CloseConnection(FALSE);
            }
            else
            {
                //  Keep alive required - don't close socket.
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("not freeing connection - auth state challenge\n"
                            ));
            }

        }

        //
        // there is no more data to be received on this object
        //

        SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
    }

quit:

    //
    // update the amount of data returned then we're outta here
    //

    *fsm.m_lpdwNumberOfBytesRead = fsm.m_dwBytesRead;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

quit_pending:

    PERF_LOG(PE_TRACE, 0x6002);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines how much data is available to be read by the caller

    BUGBUG - need cache case

Arguments:

    lpdwNumberOfBytesAvailable  - returned number of bytes available

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_WINHTTP_INCORRECT_HANDLE_STATE

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable",
                 "%#x",
                 lpdwNumberOfBytesAvailable
                 ));

    DWORD error = DoFsm(New CFsm_HttpQueryAvailable(lpdwNumberOfBytesAvailable,
                                                    this
                                                    ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpQueryAvailable::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpQueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpQueryAvailable * stateMachine = (CFsm_HttpQueryAvailable *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->QueryAvailable_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryAvailable_Fsm(
    IN CFsm_HttpQueryAvailable * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpQueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD bytesAvailable = 0;

    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        goto fsm_continue;
    }

    INET_ASSERT(fsm.GetState() == FSM_STATE_INIT);

    //
    // the handle must be readable
    //

    if (!CheckReceiveResponseState() || !IsValidHttpState(READ)) {
        error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    fsm.m_bEof = FALSE;

    //
    // error must be ERROR_SUCCESS - we just read it out of FSM & didn't jump
    // anywhere
    //

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // first check if there is data to receive at all
    //

    if (IsData()) {

        //
        // if there's buffered data still available from receiving the headers,
        // then return that length, else query the information from the socket
        //

        if (IsBufferedData()) {
            bytesAvailable = BufferDataAvailToRead();

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("%d bytes available in buffer\n",
                        bytesAvailable
                        ));

        } else if (_Socket != NULL) {

            //
            // the rest of the data must be read from the socket
            //

            BOOL checkSocket;

            if (IsKeepAlive() && IsContentLength()) {
                checkSocket = ((int)_BytesInSocket > 0) ? TRUE : FALSE;
            } else if (IsChunkEncoding()) {
                checkSocket = !IsDecodingFinished();
            } else {
                checkSocket = TRUE;
            }
            if (checkSocket) {
                if (_QueryBuffer != NULL) {
                    bytesAvailable = _QueryBytesAvailable;
                    checkSocket = (bytesAvailable == 0) ? TRUE : FALSE;
                } else {
                    error = _Socket->AllocateQueryBuffer(&_QueryBuffer,
                                                         &_QueryBufferLength
                                                         );
                    if (error != ERROR_SUCCESS) {
                        checkSocket = FALSE;
                    }
                }
            } else if (IsKeepAlive() && IsContentLength() && (_BytesRemaining == 0)) {
                fsm.m_bEof = TRUE;
            } else if (IsChunkEncoding() && IsDecodingFinished()) {
                fsm.m_bEof = TRUE;
            }
            if (checkSocket) {

                INET_ASSERT(_Socket->IsValid());
                INET_ASSERT(_QueryBytesAvailable == 0);

                //
                // reset the query buffer offset
                //

                _QueryOffset = 0;

                //
                // don't create another FSM just for the DataAvailable2 wrapper.
                // If it ever becomes more than a call to Receive() then create
                // an FSM
                //

                fsm.m_lpBuffer = _QueryBuffer;
                fsm.m_dwBufferLength = (IsKeepAlive() && IsContentLength())
                                     ? min(_BytesRemaining, _QueryBufferLength)
                                     : _QueryBufferLength;
                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;

                //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

                if (IsBadNSServer() && !IsConnCloseResponse()) {
                    SetBadNSReceiveTimeout();
                }

                error = _Socket->Receive(&fsm.m_lpBuffer,
                                         &fsm.m_dwBufferLength,
                                         &fsm.m_dwBufferLeft, // don't care about this
                                         &_QueryBytesAvailable,
                                         0,
                                         0,
                                         &fsm.m_bEof
                                         );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

fsm_continue:

                if ((error == ERROR_WINHTTP_TIMEOUT) && IsBadNSServer()) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("Bad NS server: Closing connection %#x/%d on timeout\n",
                                _Socket ? _Socket->GetSocket() : -1,
                                _Socket ? _Socket->GetSourcePort() : -1
                                ));

                    CloseConnection(TRUE);
                    _QueryBytesAvailable = 0;
                    error = ERROR_SUCCESS;
                }
                if (error == ERROR_SUCCESS) {


                    if ( IsChunkEncoding() && (_QueryBytesAvailable != 0))
                    {
                        DWORD dwChunkBytesRead = 0;
                        DWORD dwChunkBytesWritten = 0;

                        error = _ResponseFilterList.Decode((LPBYTE)_QueryBuffer,
                                                           _QueryBytesAvailable,
                                                           NULL,
                                                           NULL,
                                                           &dwChunkBytesRead,
                                                           &dwChunkBytesWritten);

                        _QueryBytesAvailable = dwChunkBytesWritten;

                        INET_ASSERT(error == ERROR_SUCCESS); // I want to see this.

                        if ( error != ERROR_SUCCESS )
                        {
                            goto quit;
                        }
                    }

                    bytesAvailable = _QueryBytesAvailable;

                    //
                    // note the amount of data that is available immediately.
                    // This allows e.g. async InternetReadFile() to complete
                    // synchronously if the next request is for <= bytesAvailable
                    //

                    //SetAvailableDataLength(bytesAvailable);

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("%d bytes available in socket %#x\n",
                                bytesAvailable,
                                (_Socket ? _Socket->GetSocket() : 0)
                                ));

                    if ((bytesAvailable == 0)
                    && (IsChunkEncoding() ? IsDecodingFinished() : TRUE)) {
                        fsm.m_bEof = TRUE;
                    }
                    if (IsKeepAlive() && IsContentLength()) {
                        _BytesInSocket -= bytesAvailable;

                        INET_ASSERT((int)_BytesInSocket >= 0);

                        if ((int)_BytesInSocket < 0) {
                            _BytesInSocket = 0;
                        }
                    }
                }
            }
        } else {

            //
            // all data read from socket & socket released
            //

            INET_ASSERT(error == ERROR_SUCCESS);
            INET_ASSERT(bytesAvailable == 0);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("no socket\n"
                        ));

            fsm.m_bEof = TRUE;
        }
    } else {

        INET_ASSERT(error == ERROR_SUCCESS);

        //
        // we may have already removed all the data from the socket
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("all data has been read\n"
                    ));

        fsm.m_bEof = TRUE;
    }

quit:

    *fsm.m_lpdwNumberOfBytesAvailable = bytesAvailable;

    //
    // if we have reached the end of the data then we can release the connection
    //

    /*
    if (fsm.m_bEof || (bytesAvailable >= _BytesRemaining)) {
        if (_Socket != NULL) {
            CloseConnection(FALSE);
        }
    }
    */
    if (fsm.m_bEof) {
        if (_Socket != NULL) {
            CloseConnection(FALSE);
        }
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::DrainResponse(
    OUT LPBOOL lpbDrained
    )

/*++

Routine Description:

    Receives any remaining response data into the buffer we allocated for the
    headers. Used in redirection: if the server returns some HTML page (e.g.)
    with the redirection response, we give the app a chance to read it. This
    way, we allow the app to retrieve the data immediately during the status
    callback in which we indicate that the request has been redirected

Arguments:

    lpbDrained  - TRUE if we really drained the socket else FALSE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to ERROR_WINHTTP_XXX

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::DrainResponse",
                 "%#x",
                 lpbDrained
                 ));

    DWORD error = DoFsm(New CFsm_DrainResponse(lpbDrained, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_DrainResponse::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_DrainResponse::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_DrainResponse * stateMachine = (CFsm_DrainResponse *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->DrainResponse_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm(
    IN CFsm_DrainResponse * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_DrainResponse & fsm = *Fsm;
    DWORD error = fsm.GetError();
    BOOL drainIt = FALSE;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        drainIt = TRUE;
        goto fsm_continue;
    }

    PERF_LOG(PE_TRACE, 0x8001);

    drainIt = TRUE;

    //
    // if the socket is already closed, we can't drain it
    //

    if ((_Socket == NULL) || !_Socket->IsValid()) {
        drainIt = FALSE;
    } else if (IsWantKeepAlive()) {

        //
        // IIS 1.0 has a bug where it can return a failure indication to a
        // request that was made using a keep-alive connection. The response
        // doesn't contain a keep-alive header but the server has left open the
        // connection AND it has returned us fewer bytes than was claimed in
        // the content-length header. If we try to drain the response buffer at
        // this point, we will wait a long time waiting for the server to send
        // us the non-existent additional bytes. Therefore, if we are talking
        // to an IIS 1.0 server, we don't drain the response buffer
        //

        LPSTR lpszServerBuf;
        DWORD serverBufferLength;

        if (_ResponseHeaders.LockHeaders())
        {
            error = FastQueryResponseHeader(HTTP_QUERY_SERVER,
                                            (LPVOID *)&lpszServerBuf,
                                            &serverBufferLength,
                                            0
                                            );
            if (error == ERROR_SUCCESS) {

#define IIS         "Microsoft-IIS/"
#define IIS_LEN     (sizeof(IIS) - 1)

#define PWS         "Microsoft-PWS/"
#define PWS_LEN     (sizeof(PWS) - 1)

#define PWS95       "Microsoft-PWS-95/"
#define PWS95_LEN   (sizeof(PWS95) - 1)

#define IIS10       "Microsoft-Internet-Information-Server/"
#define IIS10_LEN   (sizeof(IIS10) - 1)

                if ((serverBufferLength > IIS_LEN)
                    && !strnicmp(lpszServerBuf, IIS, IIS_LEN)) {

                    int major_num = 0;

                    for (DWORD i = IIS_LEN; i < serverBufferLength; ++i) {

                        char ch = lpszServerBuf[i];

                        if (isdigit(ch)) {
                            major_num = major_num * 10 + (int)(ch - '0');
                        } else {
                            break;
                        }
                    }
                    if (major_num < 4) {
                        drainIt = FALSE;
                    }
                } else if (IsBadNSServer()) {
                    drainIt = FALSE;
                } else if (((serverBufferLength > IIS10_LEN)
                            && !strncmp(lpszServerBuf, IIS10, IIS10_LEN))
                           || ((serverBufferLength > PWS_LEN)
                               && !strncmp(lpszServerBuf, PWS, PWS_LEN))
                           || ((serverBufferLength > PWS95_LEN)
                               && !strncmp(lpszServerBuf, PWS95, PWS95_LEN))) {
                    drainIt = FALSE;
                }
            }
            _ResponseHeaders.UnlockHeaders();
        }
    }

    error = ERROR_SUCCESS;

    if (drainIt) {

        fsm.m_dwAsyncFlags = IsAsyncHandle() ? SF_WAIT : 0;
        fsm.m_dwAmountToRead = IsContentLength() ? _BytesInSocket : (DWORD)-1;
        //DWORD bufferLeft = _ResponseBufferLength - _BytesReceived;
        fsm.m_dwBufferLeft = min(fsm.m_dwAmountToRead, _ResponseBufferLength - _BytesReceived);

        if (IsChunkEncoding() && IsDecodingFinished()) {
            fsm.m_dwAmountToRead = 0;
            fsm.m_bEof = TRUE;

            INET_ASSERT(fsm.m_dwBytesReceived == 0);

        }

        //
        // either receive the amount specified in the "Content-Length" header, or
        // receive until we hit the end of the connection. We may have already
        // received the entire response
        //

        while ((fsm.m_dwAmountToRead != 0) && !fsm.m_bEof && (error == ERROR_SUCCESS)) {

            fsm.m_dwPreviousBytesReceived = _BytesReceived;

            //
            // receive the rest of the data. We are assuming here that it is a
            // couple of K at the most. Notice that we don't care to make status
            // callbacks to the app while we are doing this
            //

            //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

            error = _Socket->Receive((LPVOID *)&_ResponseBuffer,
                                     &_ResponseBufferLength,
                                     &fsm.m_dwBufferLeft,
                                     &_BytesReceived,
                                     0,   // dwExtraSpace
                                     SF_EXPAND
                                     | SF_COMPRESS
                                     | fsm.m_dwAsyncFlags,
                                     &fsm.m_bEof
                                     );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

fsm_continue:

            if (error == ERROR_SUCCESS) {

                DWORD nRead = _BytesReceived - fsm.m_dwPreviousBytesReceived;

                if (IsContentLength()) {
                    fsm.m_dwAmountToRead -= nRead;

                    INET_ASSERT((int)fsm.m_dwAmountToRead >= 0);

                    _BytesInSocket -= nRead;

                    INET_ASSERT((int)_BytesInSocket >= 0);

                    if (IsKeepAlive()) {
                        _BytesRemaining -= nRead;

                        INET_ASSERT((int)_BytesRemaining >= 0);

                        //
                        // if we have read all the entity-body then we can
                        // release the keep-alive connection, or close the
                        // socket
                        //

                        //
                        // BUGBUG - put back post-ie30a
                        //

                        //if (_BytesRemaining == 0) {
                        //    fsm.m_bEof = TRUE;
                        //}
                    }
                }

                if ( IsChunkEncoding() )
                {
                    DWORD dwChunkBytesRead = 0;
                    DWORD dwChunkBytesWritten = 0;

                    INET_ASSERT(!IsContentLength());

                    error = _ResponseFilterList.Decode(
                        _ResponseBuffer + fsm.m_dwPreviousBytesReceived,
                        nRead,
                        NULL,
                        NULL,
                        &dwChunkBytesRead,
                        &dwChunkBytesWritten
                        );

                    nRead = dwChunkBytesWritten;
                    _BytesReceived = nRead + fsm.m_dwPreviousBytesReceived;

                    INET_ASSERT(error == ERROR_SUCCESS); // I want to see this happen.
                    if ( error != ERROR_SUCCESS )
                    {
                        break;
                    }

                    if ( IsDecodingFinished() )
                    {
                        fsm.m_bEof = TRUE;
                        break;
                    }
                }

                fsm.m_dwBytesReceived += nRead;
                fsm.m_dwPreviousBytesReceived = _BytesReceived;
            }
        }
    }

    if (error == ERROR_SUCCESS) {

        //
        // update the amount of data immediately available to the caller
        //

        IncreaseAvailableDataLength(fsm.m_dwBytesReceived);

        //
        // and set the end-of-file indication in the top level handle object
        //

        SetEndOfFile();

        //
        // there is no more data to be received on this HTTP object
        //

        //SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
    }

    //
    // return indication that we drained the socket
    //

    DEBUG_PRINT(HTTP,
                INFO,
                ("returning *lpbDrained = %B\n",
                drainIt
                ));

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        *fsm.m_lpbDrained = drainIt;
    }

    PERF_LOG(PE_TRACE, 0x8002);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetBadNSReceiveTimeout(
    VOID
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetBadNSReceiveTimeout",
                 NULL
                 ));

    if ((_Socket != NULL)
        && !IsContentLength()
        && !IsChunkEncoding()) {

        CServerInfo * pServerInfo = GetServerInfo();

        if (pServerInfo) {

            DWORD timeout = max(5000, 5 * pServerInfo->GetRTT());

            _Socket->SetTimeout(RECEIVE_TIMEOUT, timeout);
            SetTimeout(WINHTTP_OPTION_RECEIVE_TIMEOUT, timeout);
        }
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\request.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    request.cxx

Abstract:

    Contains HTTP utility functions

    Contents:
        pHttpGetUrlLen
        pHttpGetUrlString
        pHttpBuildUrl

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

#include <wininetp.h>
#include "httpp.h"

//
// functions
//


DWORD
pHttpGetUrlLen(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine finds the length of an HTTP URL from targethostname
    port and the object and returns the length

Arguments:

    SchemeType      - type of scheme for URL

    lpszTargetName  - host name

    lpszObjectName  - URL-path

    dwPort          - port (if not default)

    lpdwUrlLen      - returned URL length

Return Value:

    DWORD

--*/

{
    LPSTR schemeName;
    DWORD schemeLength;

    schemeName = MapUrlScheme(SchemeType, &schemeLength);
    if (schemeName == NULL) {
        return ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
    }

    int portLen;

    *lpdwUrlLen = 0;

    if (dwPort) {

        CHAR TcpipPortString[32];

        //itoa(dwPort, TcpipPortString, 10);
        wsprintf(TcpipPortString, "%d", dwPort);
        
        portLen = lstrlen(TcpipPortString);
    } else {
        portLen = 0;
    }

    *lpdwUrlLen = schemeLength
                + sizeof("://")
                + portLen
                + lstrlen(lpszTargetName)
                + lstrlen(lpszObjectName)
                ;

    return ERROR_SUCCESS;
}

DWORD
pHttpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszCWD,
    IN LPSTR lpszObjectName,
    IN LPSTR lpszExtension,
    IN DWORD dwPort,
    OUT LPSTR * lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine returns a LocaAlloc'ed buffer containing an HTTP URL constructed
    from the TargetHost, the ObjectName and the port. The caller is responsible
    for freeing the memory.

Arguments:

    SchemeType      -
    lpszTargetName  -
    lpszCWD         -
    lpszObjectName  -
    lpszExtension   -
    dwPort          -
    lplpUrlName     -
    lpdwUrlLen      -

Return Value:

    DWORD

--*/

{
    DWORD dwError, dwSav, i;
    URL_COMPONENTS sUrlComp;
    char *pBuff = (char *) ALLOCATE_FIXED_MEMORY(INTERNET_MAX_URL_LENGTH);

    if (pBuff == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(lpszCWD == NULL);

    *lplpUrlName = NULL;

    memset(&sUrlComp, 0, sizeof(URL_COMPONENTS));

    sUrlComp.dwStructSize = sizeof(URL_COMPONENTS);
    sUrlComp.nScheme = SchemeType;
    sUrlComp.lpszHostName = lpszTargetName;
    sUrlComp.lpszUrlPath = lpszObjectName;
    sUrlComp.nPort = (INTERNET_PORT)dwPort;

    dwSav = INTERNET_MAX_URL_LENGTH;

    for (i=0; i<2; i++)
    {
        if(!WinHttpCreateUrlA(&sUrlComp, 0, pBuff, &dwSav))
        {
            dwError = GetLastError();

            if ((dwError == ERROR_INSUFFICIENT_BUFFER)
                && (i==0))
            {
                LPSTR pTemp = (LPSTR)REALLOCATE_MEMORY(pBuff, dwSav, LMEM_MOVEABLE);
                if (pTemp)
                {
                    pBuff = pTemp;
                    continue;
                }
                else
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            goto Cleanup;
        }
        else
        {
            dwError = ERROR_SUCCESS;
            break;
        }
    }
    // BUGBUG, this is because WinHttpCreateUrl is not returning
    // the correct size

    dwSav = strlen(pBuff)+5;

    for(i=0;i<2;++i) {

        *lplpUrlName = (LPSTR)ALLOCATE_MEMORY(LPTR, dwSav);

        if (*lplpUrlName) {

            if(!InternetCanonicalizeUrl(pBuff, *lplpUrlName, &dwSav, ICU_ENCODE_SPACES_ONLY)){

                FREE_MEMORY(*lplpUrlName);

                // general paranoia
                *lplpUrlName = NULL;

                dwError = GetLastError();

                if ((i == 1) || (dwError != ERROR_INSUFFICIENT_BUFFER)) {
                    goto Cleanup;
                }
            }
            else {

                dwError = ERROR_SUCCESS;
                *lpdwUrlLen = dwSav;
                break;

            }
        }
        else {
            SetLastError(dwError = ERROR_NOT_ENOUGH_MEMORY);
            goto Cleanup;
        }
    }



Cleanup:
    if (pBuff)
        FREE_MEMORY(pBuff);
    if (dwError != ERROR_SUCCESS) {

        INET_ASSERT(!*lplpUrlName);

        *lpdwUrlLen = 0;
    }

    return (dwError);
}

DWORD
pHttpBuildUrl(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwBuffSize
    )

/*++

Routine Description:

    This routine builds an HTTP URL in the buffer passed. If the size is not
    enough it returns ERROR_INSUFFICIENT_BUFFER.

Arguments:

    SchemeType      - type of scheme - http, gopher, etc.

    lpszTargetName  - host name

    lpszObjectName  - URL-path

    dwPort          - port number (if not default)

    lpszUrl         - place to write URL

    lpdwBuffSize    - IN: size of lpszUrl buffer
                      OUT: size of URL written to lpszUrl

Return Value:

    DWORD

--*/

{
    DWORD dwBuffLen;
    DWORD error;

    error = pHttpGetUrlLen(SchemeType,
                           lpszTargetName,
                           lpszObjectName,
                           dwPort,
                           &dwBuffLen
                           );
    if (error != ERROR_SUCCESS) {
        return error;
    }
    if (dwBuffLen > *lpdwBuffSize) {
        return (ERROR_INSUFFICIENT_BUFFER);
    }

    LPSTR schemeName;
    DWORD schemeLength;

    schemeName = MapUrlScheme(SchemeType, &schemeLength);
    if (schemeName == NULL) {

        //
        // should never happen
        //

        INET_ASSERT(FALSE);

        return ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
    }

    LPSTR p = lpszUrl;
    int len;
    int urlLength;

    memcpy((LPVOID)p, (LPVOID)schemeName, schemeLength);
    p += schemeLength;
    urlLength = schemeLength;

    memcpy((LPVOID)p, (LPVOID)"://", sizeof("://") - 1);
    p += sizeof("://") - 1;
    urlLength += sizeof("://") - 1;

    len = lstrlen(lpszTargetName);
    memcpy((LPVOID)p, (LPVOID)lpszTargetName, len);
    p += len;
    urlLength += len;

    if (dwPort && (dwPort != INTERNET_DEFAULT_HTTP_PORT)) {

        CHAR TcpipPortString[32];

        //itoa(dwPort, TcpipPortString, 10);
        wsprintf(TcpipPortString, "%d", dwPort);

        INET_ASSERT(TcpipPortString[0] != '\0');

        *p++ = ':';
        len = lstrlen(TcpipPortString);
        memcpy((LPVOID)p, (LPVOID)TcpipPortString, len);
        p += len;
        urlLength += len + 1;
    }

    len = lstrlen(lpszObjectName);
    memcpy((LPVOID)p, (LPVOID)lpszObjectName, len);
    urlLength += len;

    *lpdwBuffSize = urlLength;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\response.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    response.cxx

Abstract:

    This file contains the HTTP Request Handle Object ReceiveResponse method

    Contents:
        CFsm_ReceiveResponse::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private manifests
//

#define DEFAULT_RESPONSE_BUFFER_LENGTH  (1 K)

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_ReceiveResponse::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReceiveResponse::RunSM",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReceiveResponse * stateMachine = (CFsm_ReceiveResponse *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->ReceiveResponse_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm(
    IN CFsm_ReceiveResponse * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
#if INET_DEBUG
//#define RLF_TEST_CODE
#ifdef RLF_TEST_CODE

//
// single 100 response
//

#define TEST_HEADER_0   "HTTP/1.1 100 Continue\r\n" \
                        "\r\n"

//
// single 100 header
//

#define TEST_HEADER_1   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n"

//
// continue header with moderate amount of data
//

#define TEST_HEADER_2   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Content-Length: 128\r\n" \
                        "Content-Type: octet/shmoctet\r\n" \
                        "\r\n" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef"

//
// continue header seen from apache server
//

#define TEST_HEADER_3   "HTTP/1.1 100 Continue\r\n" \
                        "\r\n" \
                        "\n\n\n\n\n"

//
// multiple continue headers, no data
//

#define TEST_HEADER_4   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n"

//
// single 100 response, preceeded by preamble and containing a chunked response
//

#define TEST_HEADER_5   "!!!! this is a pre-amble, should be ignored even though it includes HTTP !!!!" \
                        "     " \
                        "HTTP/1.1 100 Go ahead punk, make my day\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Transfer-Encoding: chunked\r\n" \
                        "\r\n" \
                        "0010 this is the first chunk (16 bytes)\r\n" \
                        "0123456789abcdef" \
                        "\r\n" \
                        "  10; this is the second chunk (16 bytes)\r\n" \
                        "0123456789abcdef" \
                        "\r\n" \
                        "00F3\r\n" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "012" \
                        "\r\n" \
                        "0000; the final chunk\r\n" \
                        "\r\n" \
                        "Entity-Header: this is the chunk footer\r\n" \
                        "\r\n"

//
// enpty chunk encoded response with empty footer
//

#define TEST_HEADER_6   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Transfer-Encoding: chunked\r\n" \
                        "\r\n" \
                        "0\r\n" \
                        "\r\n" \
                        "\r\n"

    const struct {LPSTR ptr; DWORD len;} test_cases[] = {
        TEST_HEADER_0, sizeof(TEST_HEADER_0) - 1,
        TEST_HEADER_1, sizeof(TEST_HEADER_1) - 1,
        TEST_HEADER_2, sizeof(TEST_HEADER_2) - 1,
        TEST_HEADER_3, sizeof(TEST_HEADER_3) - 1,
        TEST_HEADER_4, sizeof(TEST_HEADER_4) - 1,
        TEST_HEADER_5, sizeof(TEST_HEADER_5) - 1,
        TEST_HEADER_6, sizeof(TEST_HEADER_6) - 1
    };
    DWORD test_index = 99;

#endif // def RLF_TEST_CODE
#endif // INET_DEBUG

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(ReceiveResponse_Fsm);

    CFsm_ReceiveResponse & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();

    if (error != ERROR_SUCCESS) {

        if (error == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED) {

            if ((_Socket != NULL) && _Socket->IsSecure())
            {
                if(m_pSecurityInfo)
                {
                    /* SCLE ref */
                    m_pSecurityInfo->Release();
                }
                /* SCLE ref */
                m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
            }

            SetState(HttpRequestStateOpen);
            CloseConnection(TRUE);
            fsm.SetDone();
            goto quit2;
        }

        goto quit;
    }
    if (state != FSM_STATE_INIT) {
        state = fsm.GetFunctionState();
    }
    do {
        switch (state) {
        case FSM_STATE_INIT:
            if (_ResponseBuffer == NULL) {
                _ResponseBufferLength = DEFAULT_RESPONSE_BUFFER_LENGTH;
                _ResponseBuffer = (LPBYTE)ALLOCATE_MEMORY(LMEM_FIXED,
                                                          _ResponseBufferLength);
                if (_ResponseBuffer == NULL) {
                    _ResponseBufferLength = 0;
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
            }

            INET_ASSERT(_BytesReceived == 0);

            fsm.m_dwResponseLeft = _ResponseBufferLength;
            state = FSM_STATE_2;

            //
            // fall through
            //

#ifdef RLF_TEST_CODE

            InternetGetDebugVariable("WininetTestIndex", &test_index);
            if (test_index < ARRAY_ELEMENTS(test_cases)) {
                _BytesReceived = test_cases[test_index].len;
                memcpy(_ResponseBuffer, test_cases[test_index].ptr, _BytesReceived);
                fsm.m_dwResponseLeft = _ResponseBufferLength - _BytesReceived;
            }

#endif // def RLF_TEST_CODE

        case FSM_STATE_2:

            //
            // we will allow Receive() to expand the buffer (and therefore initially
            // allocate it), and to compress the buffer if we receive the end of the
            // connection. It is up to UpdateResponseHeaders() to figure out when
            // enough data has been read to indicate end of the headers
            //

            fsm.SetFunctionState(FSM_STATE_3);

            INET_ASSERT(_Socket != NULL);

            if (_Socket != NULL) {
                error = _Socket->Receive((LPVOID *)&_ResponseBuffer,
                                         &_ResponseBufferLength,
                                         &fsm.m_dwResponseLeft,
                                         &_BytesReceived,
                                         0,
                                         SF_EXPAND
                                         | SF_COMPRESS
                                         | SF_INDICATE,
                                         &fsm.m_bEofResponseHeaders
                                         );
                if (error == ERROR_IO_PENDING) {
                    goto quit;
                }
            } else {
                error = ERROR_WINHTTP_OPERATION_CANCELLED;
            }

            //
            // fall through
            //

        case FSM_STATE_3:

            //
            // if we are using a keep-alive connection that was previously timed-out
            // by the server, we may not find out about it until now
            //
            // Note: it seems we can get a zero length response at this point also,
            // which I take to mean that the server-side socket has been closed
            //

            INET_ASSERT(_BytesReceived <= _ResponseBufferLength);

            if ((error != ERROR_SUCCESS)
            || ((_BytesReceived == 0) && IsKeepAlive())) {

                //
                // We need to reset the state if we got a
                // certificate request.
                //

                if (error == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED) {

                    if ((_Socket != NULL) && _Socket->IsSecure())
                    {
                        if(m_pSecurityInfo)
                        {
                            /* SCLE ref */
                            m_pSecurityInfo->Release();
                        }
                        /* SCLE ref */
                        m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
                    }

                    SetState(HttpRequestStateOpen);
                }
                CloseConnection(TRUE);
                goto quit;
            }

            //
            // if we received no data then the server has closed the connection
            // already
            //

            if (_BytesReceived != 0) {

                BOOL bHaveFinalResponse;

                do {
                    bHaveFinalResponse = TRUE;
                    error = UpdateResponseHeaders(&fsm.m_bEofResponseHeaders);
//if (!(rand() % 7)) {
//    error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
//}
                    if (error != ERROR_SUCCESS) {
//dprintf("UpdateResponseHeaders() returns %d\n", error);
                        break;
                    }

                    DWORD statusCode;

                    statusCode = GetStatusCode();

                    //
                    // receive next packet if we didn't get a status code yet
                    //

                    if (statusCode == 0) {
                        break;
                    }

                    //
                    // discard any 1xx responses and get the headers again
                    //

                    if (fsm.m_bEofResponseHeaders
                    && (statusCode >= HTTP_STATUS_CONTINUE)
                    && (statusCode < HTTP_STATUS_OK)) {
                        bHaveFinalResponse = FALSE;
                        fsm.SetFunctionState(FSM_STATE_4);

                        //
                        // get any data that came with the header
                        //

                        fsm.m_bDrained = FALSE;
                        if (IsContentLength() && (_BytesInSocket != 0)) {
                            error = DrainResponse(&fsm.m_bDrained);
                            if (error != ERROR_SUCCESS) {
                                goto quit;
                            }
                        }

                        //
                        // fall through
                        //

        case FSM_STATE_4:

                        //
                        // now that we have drained the socket, we can indicate
                        // the response to the app. This gives apps chance to
                        // perform progress reporting for each 100 response
                        // received, e.g.
                        //
                        DWORD dwStatusCode = statusCode;
                        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE,
                                               &dwStatusCode,
                                               sizeof(dwStatusCode)
                                               );

                        //
                        // if there is no more data left in the buffer then we
                        // can receive the next response at the start of the
                        // buffer, else continue from where the previous one
                        // ended
                        //

                        if (fsm.m_bDrained || !IsBufferedData()) {
                            fsm.m_dwResponseLeft = _ResponseBufferLength;
                            _BytesReceived = 0;
                            _DataOffset = 0;
                            _ResponseScanned = 0;
                        } else {
                            _ResponseScanned = _DataOffset;
                            if (IsContentLength()) {
                                _ResponseScanned += _ContentLength;
                            }
                        }
                        _ResponseHeaders.FreeHeaders();
                        _ResponseHeaders.Initialize();
                        ZapFlags();
                        _ContentLength = 0;
                        _BytesRemaining = 0;
                        _BytesInSocket = 0;
                        fsm.m_bEofResponseHeaders = FALSE;
                        if (_DataOffset == 0) {

                            //
                            // need to read next response - nothing left in
                            // buffer
                            //

                            break;
                        }
                    }

                    // If we have a server authentication context
                    // and the response is anything but 401, mark
                    // the socket as authenticated.
                    AUTHCTX *pAuthCtx;
                    pAuthCtx = GetAuthCtx();
                    if (pAuthCtx && !pAuthCtx->_fIsProxy
                        && (statusCode != HTTP_STATUS_DENIED))
                    {

#define MICROSOFT_IIS_SERVER_SZ "Microsoft-IIS/"
#define MICROSOFT_PWS_SERVER_SZ "Microsoft-PWS/"

#define MICROSOFT_IIS_SERVER_LEN (sizeof(MICROSOFT_IIS_SERVER_SZ) - 1)
#define MICROSOFT_PWS_SERVER_LEN (sizeof(MICROSOFT_PWS_SERVER_SZ) - 1)

                        LPSTR pszBuf;
                        DWORD cbBuf;
                        cbBuf = MAX_PATH;
                        if (FastQueryResponseHeader(HTTP_QUERY_SERVER, 
                            (LPVOID*) &pszBuf, &cbBuf, 0) == ERROR_SUCCESS)
                        {
                            if (cbBuf >= MICROSOFT_IIS_SERVER_LEN 
                                && (!strncmp(pszBuf, MICROSOFT_IIS_SERVER_SZ, MICROSOFT_IIS_SERVER_LEN)
                                    || !strncmp(pszBuf, MICROSOFT_PWS_SERVER_SZ, MICROSOFT_PWS_SERVER_LEN)))

                            {                            
                                // Found an IIS header. Mark socket as authenticated if 
                                // IIS 1, 2 or 3. Lengths of both strings are same.
                                CHAR *pVer = pszBuf + MICROSOFT_IIS_SERVER_LEN;
                                if (*pVer == '1'
                                    || *pVer == '2'
                                    || *pVer == '3'
                                    )
                                {
                                    // IIS 1, 2 or 3  - mark dirty.
                                    _Socket->SetAuthenticated();
                                }
                            }                                
                        }
                        else
                        {
                            // Unknown server; may be IIS 1,2 or 3.
                            _Socket->SetAuthenticated();
                        }
                    }

                } while (!bHaveFinalResponse);
            } else {
                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
            }

            //
            // set state to perform next receive
            //

            state = FSM_STATE_2;
        }
    } while ((error == ERROR_SUCCESS) && !fsm.m_bEofResponseHeaders);

    //
    // we should update the RTT as soon as we get received data from
    // the socket, but then we'd have to store the RTT in the socket
    // object or access this one, etc. Just keep it here for now -
    // its a reasonable approximation in the normal IE case: not too
    // much time spent in callbacks etc.
    //

    UpdateRTT();
//dprintf("RTT for %s = %d\n", GetURL(), GetRTT());
//dprintf("OS = %s, PS = %s\n", ((GetOriginServer() != NULL) ? GetOriginServer()->GetHostName() : "none"),
//    ((GetServerInfo() != NULL) ? GetServerInfo()->GetHostName() : "none"));

    //
    // we have received the headers and possibly some (or all) of the data. The
    // app can now query the headers and receive the data
    //

    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //
    if ( IsChunkEncoding() )
    {
        DWORD dwChunkBytesRead = 0;
        DWORD dwChunkBytesWritten = 0;

        error = _ResponseFilterList.Decode(
            (LPBYTE) BufferedDataStart(),
            BufferedDataLength(),
            NULL,
            NULL,
            &dwChunkBytesRead,
            &dwChunkBytesWritten
            );

        _ResponseBufferDataReadyToRead = dwChunkBytesWritten;

        INET_ASSERT(error == ERROR_SUCCESS);
        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }

    SetAvailableDataLength(BufferDataAvailToRead());

    //
    // IIS caches authentication credentials on keep-alive sockets.
    //

    if (_Socket) {

        if (IsAuthorized()) {
            _Socket->SetAuthorized();
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // if we got the socket from the keep-alive pool, but found no keep-
        // alive header then we no longer have a keep-alive connection
        //

        if (_bKeepAliveConnection && !IsKeepAlive()) {
//dprintf("*** %s - NO LONGER K-A socket %#x\n", GetURL(), _Socket->GetSocket());
            SetNoLongerKeepAlive();
        }

        //
        // don't maintain the connection if there's no more data to read. UNLESS
        // we are in the middle of establishing an authenticated connection
        // (implies using keep-alive connection, e.g. NTLM)
        // IsData() returns FALSE if there's no data at all, otherwise we
        // check to see if we have read all the data already (i.e. with the
        // response headers)
        //

        if ((error != ERROR_SUCCESS)
            || (

                //
                // data-less response (ignoring keep-alive & content-length)
                //

                (!IsData()

                 //
                 // all data body in header buffer
                 //

                 || (IsKeepAlive()
                     && IsContentLength()
                     && (BufferedDataLength() == GetContentLength())
                     )
                 )

                //
                // but only if not in the middle of auth negotiation and if the
                // connection hasn't been dropped by the server
                //

                && ((GetAuthState() != AUTHSTATE_NEGOTIATE)
                    || IsNoLongerKeepAlive())
                )
            ) {

//dprintf("socket %#x [%#x/%d] error=%d, IsData()=%B, K-A=%B, C-L=%d, BDL=%d, AS=%d\n",
//        _Socket,
//        _Socket ? _Socket->GetSocket() : 0,
//        _Socket ? _Socket->GetSourcePort() : 0,
//        error,
//        IsData(),
//        IsKeepAlive(),
//        GetContentLength(),
//        BufferedDataLength(),
//        GetAuthState()
//        );

            //
            // BUGBUG - if this is a new keep-alive connection?
            //

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("closing: error = %d, IsData() = %B, K-A = %B, IsC-L = %B, BDL = %d, C-L = %d\n",
                        error,
                        IsData(),
                        IsKeepAlive(),
                        IsContentLength(),
                        BufferedDataLength(),
                        GetContentLength()
                        ));

            if(GetStatusCode() != HTTP_STATUS_REDIRECT || (HTTP_METHOD_TYPE_HEAD == GetMethodType()))
                CloseConnection((error != ERROR_SUCCESS) ? TRUE : FALSE);
            else
                DEBUG_PRINT(HTTP, INFO, ("Not closing socket, Status code = %d \n", GetStatusCode()));

            //
            // set the relevant state
            //

            if (error != ERROR_SUCCESS &&
                (error != ERROR_WINHTTP_SECURE_FAILURE ||
                 GetStatusFlags() & ~(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA |
                                     WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID |
                                     WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID |
                                     WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR |
                                     WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED |
                                     WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)) &&
                error != ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED )
            {
                SetState(HttpRequestStateError);
            }
        }

        PERF_LEAVE(ReceiveResponse_Fsm);
    }

quit2:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\redirect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    redirect.cxx

Abstract:

    Contains HTTP_REQUEST_HANDLE_OBJECT method for handle redirection

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::Redirect

Author:

    Richard L Firth (rfirth) 18-Feb-1996

Environment:

    Win32 user-level

Revision History:

    18-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// manifests
//

#define DEFAULT_COOKIE_BUFFER_LENGTH    (1 K)

//
// functions
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::Redirect(
    IN HTTP_METHOD_TYPE tMethod,
    IN BOOL fRedirectToProxy
    )

/*++

Routine Description:

    Called after a successful SendData() in which we discover that the requested
    object has been moved.

    We need to change the HTTP_REQUEST_HANDLE_OBJECT so that we can resubmit the
    request and retrieve the redirected object.

    To do this we have to:

        get the new URI
        crack the new URI
        if callbacks are enabled or the server is the same and we are using keep-alive
            drain the current response into the response buffer
        if we are not using keep-alive
            kill the connection
        if callbacks are enabled
            indicate redirection to the app
        create a new request header
        if the server or port has changed
            update the local server & port information

Arguments:

    tMethod - new request method type (e.g. if POST => GET), or POST => POST ( for HTTP 1.1)

    fRedirectToProxy  - TRUE if we're actually redirected to use a proxy instead of another site


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "Redirect",
                "%s, %x",
                MapHttpMethodType(tMethod),
                fRedirectToProxy
                ));

    DWORD error = DoFsm(New CFsm_Redirect(tMethod, FALSE, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_Redirect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_Redirect::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    START_SENDREQ_PERF();

    CFsm_Redirect * stateMachine = (CFsm_Redirect *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->Redirect_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::Redirect_Fsm(
    IN CFsm_Redirect * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::Redirect_Fsm",
                 "%#x",
                 Fsm
                 ));

    DWORD index;
    LPSTR uriBuffer = NULL;
    DWORD uriLength = INTERNET_MAX_PATH_LENGTH;
    CFsm_Redirect & fsm = *Fsm;
    DWORD error = fsm.GetError();
    char *buffer = NULL;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (!_ResponseHeaders.LockHeaders()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (fsm.GetState() == FSM_STATE_INIT) {

        if (!IsKeepAlive() || IsContentLength() || IsChunkEncoding()) {
            error = DrainResponse(&fsm.m_bDrained);
            if (error != ERROR_SUCCESS) {
                goto Cleanup;
            }
        }
    }

    //
    // get the "Location:" header
    //
    // BUGBUG - we also need to get & parse the "URI:" header(s)
    //

    do {

        //
        // we allow ourselves to fail due to insufficient buffer (at least once)
        //

        uriBuffer = (LPSTR)ResizeBuffer(uriBuffer, uriLength, FALSE);
        if (uriBuffer != NULL) {

            DWORD previousLength = uriLength;

            index = 0;

            error = QueryResponseHeader(HTTP_QUERY_LOCATION,
                                        uriBuffer,
                                        &uriLength,
                                        0,      // no modifiers
                                        &index  // should only be one
                                        );
            if (error == ERROR_SUCCESS) {

                if (uriLength == 0) {
                    // Don't let an empty value succeed
                    error = ERROR_WINHTTP_REDIRECT_FAILED;
                }
                else {
                    //
                    // we probably allocated too much buffer - shrink it
                    //

                    uriBuffer = (LPSTR)ResizeBuffer(uriBuffer, uriLength + 1, FALSE);

                    //
                    // check for NULL below
                    //
                }

            } else if ((error == ERROR_INSUFFICIENT_BUFFER)
            && (previousLength >= uriLength)) {

                //
                // this should never happen, but we will avoid a loop if it does
                //

                INET_ASSERT(FALSE);

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
            else if (error == ERROR_WINHTTP_HEADER_NOT_FOUND) {
                // Be clear that this is failing due to having
                // no defined location to redirect to since there's no header
                error = ERROR_WINHTTP_REDIRECT_FAILED;
            }
        }
        if (uriBuffer == NULL) {

            //
            // failed to (re)alloc or shrink
            //

            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } while (error == ERROR_INSUFFICIENT_BUFFER);
    if (error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    ////
    //// strip all cookie request headers
    ////
    //
    //RemoveAllRequestHeadersByName("Cookie");
    //
    ////
    //// and add any we received
    ////
    //
    //DWORD headerLength;
    //DWORD bufferLength;
    //LPVOID lpHeader;
    //
    //bufferLength = DEFAULT_COOKIE_BUFFER_LENGTH;
    //lpHeader = (LPVOID)ResizeBuffer(NULL, bufferLength, FALSE);
    //if (lpHeader == NULL) {
    //    error = ERROR_NOT_ENOUGH_MEMORY;
    //    goto Cleanup;
    //}
    //
    //index = 0;
    //
    //do {
    //    headerLength = bufferLength;
    //    error = QueryResponseHeader("Set-Cookie",
    //                                sizeof("Set-Cookie") - 1,
    //                                lpHeader,
    //                                &headerLength,
    //                                0,
    //                                &index
    //                                );
    //    if (error == ERROR_INSUFFICIENT_BUFFER) {
    //        error = ERROR_SUCCESS;
    //        bufferLength = headerLength;
    //        lpHeader = (LPVOID)ResizeBuffer((HLOCAL)lpHeader,
    //                                        bufferLength,
    //                                        FALSE
    //                                        );
    //        if (lpHeader == NULL) {
    //            error = ERROR_NOT_ENOUGH_MEMORY;
    //            goto Cleanup;
    //        }
    //    } else if (error == ERROR_SUCCESS) {
    //        error = AddRequestHeader("Cookie",
    //                                 sizeof("Cookie") - 1,
    //                                 (LPSTR)lpHeader,
    //                                 headerLength,
    //                                 0,
    //                                 0
    //                                 );
    //    }
    //} while (error == ERROR_SUCCESS);
    //
    //INET_ASSERT(error == ERROR_HTTP_HEADER_NOT_FOUND);

    //
    // we may have been given a partial URL. Combine it with the current base
    // URL. If both are base URLs then we just get back the new one
    //

    DWORD newUrlLength = INTERNET_MAX_URL_LENGTH;

    buffer = (char *) ALLOCATE_FIXED_MEMORY(newUrlLength + 1);
    if (buffer == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(GetURL() != NULL);

    for (int i=0; i<2; i++)
    {
        if (!InternetCombineUrl(GetURL(),
                                uriBuffer,
                                buffer,
                                &newUrlLength,
                                ICU_ENCODE_SPACES_ONLY)) 
        {
            error = GetLastError();
            if (error == ERROR_INSUFFICIENT_BUFFER)
            {
                if (i==0) 
                {
                    LPSTR pTemp = (LPSTR)REALLOCATE_MEMORY(buffer, newUrlLength + 1, LMEM_MOVEABLE);
                    if (pTemp)
                    {
                        buffer = pTemp;
                        continue;
                    }
                    else
                    {
                        error = ERROR_HTTP_REDIRECT_FAILED;
                    }
                }
                else
                {
                    error = ERROR_HTTP_REDIRECT_FAILED;
                }
            }
            
            goto Cleanup;
        }
        else
        {
            error = ERROR_SUCCESS;
            break;
        }
    }
    //
    // we are done with uriBuffer
    //

    uriBuffer = (LPSTR)FREE_MEMORY((HLOCAL)uriBuffer);

    INET_ASSERT(uriBuffer == NULL);

    //
    // if we ended up with exactly the same URL then we're done. Note that the
    // URLs may be the same, even if they're lexicographically different - host
    // name vs. IP address e.g., encoded vs. unencoded, case sensitive? In the
    // encoded case, the URLs should be in canonical form. We may have an issue
    // with host vs IP address which will lead to an additional transaction
    //

    {
        AUTHCTX* pAuthCtx = GetAuthCtx();
        DWORD eAuthScheme = 0;
        if (pAuthCtx != NULL)
        {
            eAuthScheme = pAuthCtx->GetSchemeType();
        }

        if ((eAuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT) &&
            !strcmp(GetURL(), buffer))   
            // Passport1.4 auth need redirect to same site works
        {
            DEBUG_PRINT(HTTP,
                        INFO,
                        ("URLs match: %q, %q\n",
                        GetURL(),
                        buffer
                        ));

            error = ERROR_HTTP_NOT_REDIRECTED;
            goto Cleanup;
        }
    }

    //
    // crack the new URL
    //

    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT port;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extra;
    DWORD extraLength;

    error = CrackUrl(buffer,
                     newUrlLength,
                     FALSE, // don't escape URL-path
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &port,
                     NULL,  // don't care about user name
                     NULL,
                     NULL,  // or password
                     NULL,
                     &urlPath,
                     &urlPathLength,
                     &extra,
                     &extraLength,
                     NULL
                     );
    if ((error != ERROR_SUCCESS) || (hostNameLength == 0)) {

        //
        // if this is an URL for which we don't understand the protocol then
        // defer redirection to the caller
        //

        if (error == ERROR_WINHTTP_UNRECOGNIZED_SCHEME) {
            error = ERROR_HTTP_REDIRECT_FAILED;
        } else if (hostNameLength == 0) {
            error = ERROR_HTTP_NOT_REDIRECTED;
        }
        goto Cleanup;
    }

    //
    // if the scheme is not HTTP or HTTPS then we can't automatically handle it.
    // We have to return it to the caller. For example, we cannot transmogrify
    // a HTTP handle to an FTP directory handle, and there's no way we can
    // handle a file:// URL (we don't understand file://)
    //

    if ((schemeType != INTERNET_SCHEME_HTTP)
    && (schemeType != INTERNET_SCHEME_HTTPS)) {
        error = ERROR_HTTP_REDIRECT_FAILED;
        goto Cleanup;
    }

    //
    // BUGBUG - we may get back an IP address (IPX?) in which case we need to
    //          resolve it again
    //

    //
    // map port
    //

    if (port == INTERNET_INVALID_PORT_NUMBER) {
        port = (schemeType == INTERNET_SCHEME_HTTPS)
            ? INTERNET_DEFAULT_HTTPS_PORT
            : INTERNET_DEFAULT_HTTP_PORT;
    }

    //
    // if the server & port remain the same and we are using keep-alive OR
    // we think the app may want to read any data associated with the redirect
    // header (i.e. callbacks are enabled) then drain the response
    //

    INTERNET_PORT currentHostPort;
    LPSTR currentHostName;
    DWORD currentHostNameLength;
    INTERNET_SCHEME currentSchemeType;

    currentHostPort = GetHostPort();
    currentHostName = GetHostName(&currentHostNameLength);
    currentSchemeType = ((WINHTTP_FLAG_SECURE & GetOpenFlags()) ?
                            INTERNET_SCHEME_HTTPS :
                            INTERNET_SCHEME_HTTP);

    //
    // close the connection
    //

    //
    // BUGBUG - if we are redirecting to the same site and we have a keep-alive
    //          connection, then we don't have to do this. Worst case is that
    //          we go to get the keep-alive connection and some other bounder
    //          has taken it
    //

    //
    // if we didn't actually drain the socket because of the server type or
    // because there was no or incorrect data indication then force the
    // connection closed (if keep-alive)
    //

    CloseConnection(fsm.m_bDrained ? FALSE : TRUE);

    //
    // inform the app of the redirection. At this point, we have received all
    // the headers and data associated with the original request. We have not
    // modified the object with information for the new request. This is so
    // the application can query information about the original request - e.g.
    // the original URL - before we make the new request for the redirected item
    //

    // Make sure buffer is copied over before reporting to app, since we continue
    // to use this buffer.
    InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, buffer, TRUE/*bCopyBuffer*/);

    //
    // BUGBUG - app may have closed the request handle
    //

    //
    // if there is an intra-page link on the redirected URL then get rid of it:
    // we don't send it to the server, and we have already indicated it to the
    // app
    //

    if (extraLength != 0) {

        INET_ASSERT(extra != NULL);
        INET_ASSERT(!IsBadWritePtr(extra, 1));

        if (*extra == '#') {
            *extra = '\0';
            newUrlLength -= extraLength;
        } else {
            urlPathLength += extraLength;
        }
    }

    //
    // create the new request line. If we're going via proxy, add the entire URI
    // else just the URL-path
    //

    //
    // BUGBUG - do we need to perform any URL-path escaping here?
    //

    //
    // BUGBUG - always modifying POST to GET
    //

    //
    // BUGBUG - [arthurbi]
    //   this breaks For HTTPS sent over  HTTP to
    //   a proxy which turns it into HTTPS.
    //

    //INET_ASSERT(fsm.m_tMethod == HTTP_METHOD_TYPE_GET);

    INTERNET_HANDLE_OBJECT * pInternet;
    pInternet = GetRootHandle (this);

    //
    // Set Url in the request object. Authentication, and Cookies
    //  depend on checking the new URL not the previous one.
    //

    BYTE bTemp;

    bTemp = buffer[newUrlLength];
    buffer[newUrlLength] = 0;

    BOOL fSuccess;

    fSuccess = SetURL(buffer);
    buffer[newUrlLength] = bTemp;

    if (!fSuccess) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // update the method, server and port, if they changed
    //

    SetMethodType(fsm.m_tMethod);

    if (port != currentHostPort) {
        SetHostPort(port);
    }
    if ((hostNameLength != currentHostNameLength)
    || (strnicmp(hostName, currentHostName, hostNameLength) != 0)) {

        char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];
        LPSTR hostValueStr;
        DWORD hostValueSize; 

        CHAR chBkChar = hostName[hostNameLength]; // save off char

        hostName[hostNameLength] = '\0';
        SetHostName(hostName);

        hostValueSize = hostNameLength;
        hostValueStr = hostName;            

        if ((port != INTERNET_DEFAULT_HTTP_PORT)
        &&  (port != INTERNET_DEFAULT_HTTPS_PORT)) {
            if (hostValueSize > INTERNET_MAX_HOST_NAME_LENGTH)
            {
                hostName[hostNameLength] = chBkChar; // put back char
                error = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            hostValueSize = wsprintf(hostValue, "%s:%d", hostName, (port & 0xffff));
            hostValueStr = hostValue;
        }

        hostName[hostNameLength] = chBkChar; // put back char

        //
        // replace the "Host:" header
        //

        ReplaceRequestHeader(HTTP_QUERY_HOST,
                             hostValueStr,
                             hostValueSize,
                             0, // dwIndex
                             ADD_HEADER
                             );

        //
        // and get the corresponding server info, resolving the name if
        // required
        //

        SetServerInfo(FALSE);
    }

    //
    // if the new method is GET then remove any content-length headers (there
    // *should* only be 1!) - we won't be sending any data on the redirected
    // request. Remove any content-type (again should only be 1) also
    //

    if (fsm.m_tMethod == HTTP_METHOD_TYPE_GET) {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONTENT_LENGTH);
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONTENT_TYPE);
    }

    //
    // Catch Redirections from HTTPS to HTTP (and) HTTP to HTTPS
    //

    if ( currentSchemeType != schemeType )
    {
        DWORD OpenFlags;

        OpenFlags = GetOpenFlags();

        //
        // Switched From HTTPS to HTTP
        //

        if ( currentSchemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(schemeType != INTERNET_SCHEME_HTTPS );

            OpenFlags &= ~(WINHTTP_FLAG_SECURE);
        }

        //
        // Switched From HTTP to HTTPS
        //

        else if ( schemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(currentSchemeType == INTERNET_SCHEME_HTTP );

            OpenFlags |= (WINHTTP_FLAG_SECURE);
        }


        SetOpenFlags(OpenFlags);
        SetSchemeType(schemeType);

    }

Cleanup:

    if (buffer)
        FREE_MEMORY(buffer);
    if (uriBuffer != NULL) {
        uriBuffer = (LPSTR)FREE_MEMORY((HLOCAL)uriBuffer);

        INET_ASSERT(uriBuffer == NULL);
    }

    _ResponseHeaders.UnlockHeaders();

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\socket.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    socket.cxx

Abstract:

    This file contains general socket utilities.

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::OpenConnection
        CFsm_OpenConnection::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::CloseConnection
        HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection
        HTTP_REQUEST_HANDLE_OBJECT::AbortConnection
        HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel
        CFsm_OpenProxyTunnel::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    18-Dec-1995 rfirth
        Reworked for C++

    27-Mar-1996 arthurbi
        Added OpenProxyTunnel Method

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// functions
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenConnection(
    IN BOOL bNewConnection,
    IN BOOL fNoCreate  /* = FALSE */
    )

/*++

Routine Description:

    Get a connection to the web server. Either use a pre-existing keep-alive
    connection from the global pool or create a new connection

Arguments:

    bNewConnection  - TRUE if we are NOT to get a connection from the keep-alive
                      pool

    fNoCreate       - TRUE if we should NOT create a new socket if a k-a isn't found.
                      This is currently for the SSL tunneling case where we want to break
                      and send a CONNECT if a k-a doesn't match our criteria.
                      
Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Opened connection

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::OpenConnection",
                "%B",
                bNewConnection
                ));

    DWORD error = DoFsm(New CFsm_OpenConnection(bNewConnection, this, fNoCreate));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_OpenConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next OpenConnection state

Arguments:

    Fsm - containing open connection state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_OpenConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_OpenConnection * stateMachine = (CFsm_OpenConnection *)Fsm;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->OpenConnection_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm(
    IN CFsm_OpenConnection * Fsm
    )

/*++

Routine Description:

    Open connection FSM

Arguments:

    Fsm - containing state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_OpenConnection & fsm = *Fsm;
    DWORD error = fsm.GetError();
    CServerInfo * pServerInfo = GetServerInfo();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // BUGBUG - redundancy. Either put these in the FSM or figure out why we need
    //          to do proxy name processing here
    //

    //
    // if this object was created from an InternetOpen() handle which specified
    // INTERNET_OPEN_TYPE_PROXY then we connect to the proxy, otherwise we
    // connect to the server specified in InternetConnect()
    //

    LPSTR hostName;
    LPSTR hostNameServer;
    DWORD hostLength;
    INTERNET_PORT hostPort;

    hostName = hostNameServer = GetHostName(&hostLength);
    hostPort = GetHostPort();

    LPSTR proxyHostName;
    DWORD proxyHostNameLength;
    INTERNET_PORT proxyHostPort;

    GetProxyName(&proxyHostName,
                 &proxyHostNameLength,
                 &proxyHostPort
                 );

    if ((proxyHostName != NULL) && (proxyHostNameLength > 0)) {
        SetViaProxy(TRUE);
        hostName = proxyHostName;
        hostLength = proxyHostNameLength;
        hostPort = proxyHostPort;
    }

    INET_ASSERT(hostName != NULL);
    INET_ASSERT(hostPort != INTERNET_INVALID_PORT_NUMBER);

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_1:
            goto get_continue;            
        case FSM_STATE_2:
            goto connect_continue;       
        default:

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
            goto quit;
        }
    }

    //
    // we may already have a keep-alive connection - don't ask for a new one.
    // This happens in the challenge phase of a multi-part (e.g. NTLM) auth
    // negotiation over keep-alive
    //

    if (IsWantKeepAlive() && !fsm.m_bNewConnection && (_Socket != NULL)
    && _Socket->IsOpen()) {

        //INET_ASSERT(_bKeepAliveConnection);

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x, ALREADY open on Socket=%#x\n", this, _Socket );
        //}


        error = ERROR_SUCCESS;
        goto quit;
    }

    INET_ASSERT(pServerInfo != NULL);

    if (pServerInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this request wants a keep-alive connection AND we are allowed to use
    // one (i.e. not forced to generate a new connection) AND we can find one
    // then we're done, otherwise we have to generate a new connection
    //

    DWORD dwSocketFlags;

    dwSocketFlags = IsAsyncHandle() ? SF_NON_BLOCKING : 0;
    if ((IsWantKeepAlive() || (GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION))
    && !fsm.m_bNewConnection) {
        dwSocketFlags |= SF_KEEP_ALIVE;
    }
    if (GetOpenFlags() & WINHTTP_FLAG_SECURE) {
        dwSocketFlags |= SF_SECURE;
    }
    if ( IsTunnel() )
    {
        dwSocketFlags |= SF_TUNNEL;
        //    dprintf("Opening Tunnel for nested req=%#x, Socket Flags=%#x, K-A=%B, Secure=%B, N-B=%B\n",
        //             this, dwSocketFlags, (dwSocketFlags & SF_KEEP_ALIVE), (dwSocketFlags & SF_SECURE),
        //            (dwSocketFlags & SF_NON_BLOCKING));
    }


    INET_ASSERT(_Socket == NULL);

    _Socket = NULL;
    fsm.SetFunctionState(FSM_STATE_1);
    // If m_fNoCreate flag is set, then we're attempting to find
    // a matching SSL tunnel that's already been established.
    error = DoFsm(new CFsm_GetConnection(
                            dwSocketFlags,
                            fsm.m_fNoCreate ? GetHostPort() : hostPort,
                            GetTimeoutValue(WINHTTP_OPTION_CONNECT_TIMEOUT),
                            10000,  // dwLimitTimeout
                            &_Socket,
                            pServerInfo,
                            fsm.m_fNoCreate ? hostNameServer : NULL
                            ));

get_continue:

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (_Socket != NULL) {

        //
        // _bKeepAliveConnection now means "this is a pre-existing k-a socket".
        // Only meaningful when re-establishing connect when dropped by server
        //

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x\n opened on K-A Socket=%#x\n", this, _Socket );
        //}


//dprintf("%s existing K-A connection %#x\n", GetURL(), _Socket->GetSocket());
        _bKeepAliveConnection = TRUE;

        //
        // Get any security Info
        //

        if (_Socket->IsSecure()) {
            if (m_pSecurityInfo != NULL) {
                /* SCLE ref */
                m_pSecurityInfo->Release();
            }
            /* SCLE ref */
            m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
            ((ICSecureSocket*)_Socket)->SetSecureFlags(SECURITY_FLAG_SECURE);
        }

        //
        // successfully got keep-alive connection from the pool
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("%skeep-alive connection: socket %#x, port %d\n",
                    _Socket->IsSecure() ? "SSL " : "",
                    _Socket->GetSocket(),
                    _Socket->GetSourcePort()
                    ));

        goto quit;
    }
    else if (fsm.m_fNoCreate)
    {
        goto quit;
    }

    //
    // the socket didn't come from the pool
    //

    _bKeepAliveConnection = FALSE;

    //
    // we may already have a socket if we're reusing the object
    //

    if (GetOpenFlags() & WINHTTP_FLAG_SECURE)
    {
        _Socket = New ICSecureSocket();

        // Search on the appropriate cache, session vs. global
        INTERNET_HANDLE_OBJECT * pInternet;
        pInternet = GetRootHandle (this);

        if (m_pSecurityInfo == NULL)
        {
            /* SCLE ref */
            m_pSecurityInfo = (pInternet->GetSslSessionCache())->Find(GetHostName());
            if (NULL == m_pSecurityInfo)
            {
                /* SCLE ref */
                m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(GetHostName());
            }
        }

        if (_Socket != NULL)
        {
            _Socket->SetEncryption();
            /* SCLE ref */
            ((ICSecureSocket *)_Socket)->SetSecurityEntry(m_pSecurityInfo);
            /* SCLE ref */
            ((ICSecureSocket *)_Socket)->SetHostName(GetHostName(), pInternet->GetSslSessionCache());
            ((ICSecureSocket *)_Socket)->SetSecureFlags(GetOpenFlags() & SECURITY_INTERNET_MASK);
            if (GetEnableFlags() & WINHTTP_ENABLE_SSL_REVOCATION)
                ((ICSecureSocket *)_Socket)->SetSecureFlags(SECURITY_FLAG_CHECK_REVOCATION);
        }
    }
    else
    {
        if (dwSocketFlags & SF_TUNNEL)
        {
            _Socket = New ICSecureSocket;
            ((ICSecureSocket *)_Socket)->ResetFlags(FALSE);
        }
        else
        {
            _Socket = New ICSocket;
        }
    }
    if (_Socket != NULL)
    {
        fsm.m_bCreatedSocket = TRUE;
    }
    else
    {

        //
        // balance number of available connections
        //

        ReleaseConnection(FALSE, FALSE, FALSE);
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Turn on Socks, if needed.
    //

    GetSocksProxyName(&proxyHostName,
                      &proxyHostNameLength,
                      &proxyHostPort
                      );

    if ((proxyHostName != NULL) && (proxyHostNameLength > 0)) {
        _Socket->EnableSocks(proxyHostName, proxyHostPort);
    }

    //
    // NOTE: if secure connection is required, TargetServer must
    //       be a fully qualified domain name.
    //       The hostname is used in comparison with CN found in
    //       the certificate.  The hostname MUST NOT BE the
    //       result of a DNS lookup. DNS lookups are open to
    //       spoofing, and that may prevent a security from
    //       being detected.
    //
    //
    // If we're Posting or sending data, make sure
    //  the SSL connection code knows about it.  Therefore we set
    //  the flag "SF_SENDING_DATA" for the purposes of
    //  generating errors if found while making the connection.
    //

    _Socket->SetPort(hostPort);
    fsm.SetFunctionState(FSM_STATE_2);
    error = _Socket->Connect(GetTimeoutValue(WINHTTP_OPTION_CONNECT_TIMEOUT),
                             GetTimeoutValue(WINHTTP_OPTION_CONNECT_RETRIES),
                             SF_INDICATE
                             | (IsAsyncHandle() ? SF_NON_BLOCKING : 0)
                             | (((GetMethodType() == HTTP_METHOD_TYPE_POST)
                             || (GetMethodType() == HTTP_METHOD_TYPE_PUT))
                                ? SF_SENDING_DATA
                                : 0)
                             );

connect_continue:

    if (error == ERROR_SUCCESS) {
//dprintf("%s NEW connection %#x\n", GetURL(), _Socket->GetSocket());

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("new connection: socket %#x\n",
                    _Socket->GetSocket()
                    ));

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x opened for Socket=%#x\n", this, _Socket );
        //}


        /*
            24918: Invalid ASSERT because the m_Socket member in _Socket can be invalidated
            due to closing handle : code downstream of this assert takes that into consideration.
            for eg. SetLinger puts the call in a try..except.
         */
         
        //INET_ASSERT(_Socket->IsOpen());

        //pServerInfo->AddActiveConnection();
        
        // enable send and receive timeout - ignore any errors

        _Socket->SetTimeout(SEND_TIMEOUT,
                            GetTimeoutValue(WINHTTP_OPTION_SEND_TIMEOUT)
                            );
                            
        _Socket->SetTimeout(RECEIVE_TIMEOUT,
                            GetTimeoutValue(WINHTTP_OPTION_RECEIVE_TIMEOUT)
                            );
                            
        //
        // set zero linger: force connection closed at transport level when
        // we close the socket. Ignore the error
        //

        _Socket->SetLinger(TRUE, 0);
    }

quit:

    if (error != ERROR_IO_PENDING) {

        //
        // if we created the socket but failed to connect then delete the socket
        // object
        //

        if ((error != ERROR_SUCCESS) && fsm.m_bCreatedSocket) {

            //
            // we created a socket so we must increase the available connection
            // count on failure
            //

            INET_ASSERT(_Socket != NULL);

            ReleaseConnection(TRUE,     // close socket (if open)
                              FALSE,    // don't indicate
                              TRUE      // dispose of socket object
                              );
        }
//dprintf("%s get/connect pending socket %#x\n", GetURL(), _Socket ? _Socket->GetSocket() : 0);
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloseConnection(
    IN BOOL bForceClosed
    )

/*++

Routine Description:

    Performs the opposite of OpenConnection(), i.e. closes the socket or marks
    it not in use if keep-alive

Arguments:

    bForceClosed    - TRUE if we are to forcibly release a keep-alive connection
                      (i.e. the server timed out before we did)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::CloseConnection",
                "%B",
                bForceClosed
                ));

//dprintf("*** closing %s%s socket %#x\n",
//        (_bKeepAliveConnection || IsKeepAlive()) ? "K-A " : "",
//        GetURL(),
//        _Socket ? _Socket->GetSocket() : 0
//        );

    DWORD error = ERROR_SUCCESS;
    BOOL bClose = TRUE;
    BOOL bDelete = TRUE;

    if (_Socket == NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("socket already deleted\n"
                    ));

        goto quit;
    }
    if (_bKeepAliveConnection || IsKeepAlive()) {

        //
        // keep-alive connection: just return the connection to the pool
        //

        if ((IsContentLength() && (GetBytesInSocket() != 0))
        || (IsChunkEncoding() && !IsDecodingFinished())
        || IsNoLongerKeepAlive() || _Socket->IsClosed()
        || ((_State & 0x0F) < (HttpRequestStateObjectData & 0x0F))) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("forcing %#x [%#x] closed: bytes left = %d/%d; no longer k-a = %B; closed = %B\n",
                        _Socket,
                        _Socket->GetSocket(),
                        GetBytesInSocket(),
                        GetContentLength(),
                        IsNoLongerKeepAlive(),
                        _Socket->IsClosed()
                        ));

//dprintf("forcing k-a %#x closed - bytes=%d/%d, no longer=%B, chunked=%B, chunk-finished=%B\n",
//        _Socket->GetSocket(),
//        GetBytesInSocket(),
//        GetContentLength(),
//        IsNoLongerKeepAlive(),
//        IsChunkEncoding(),
//        IsDecodingFinished()
//        );
            bForceClosed = TRUE;
        }
        if (!bForceClosed) {
            bClose = FALSE;
            bDelete = FALSE;
        } else {
//dprintf("%#x forced close\n", _Socket->GetSocket());
        }
    }

    ReleaseConnection(bClose, TRUE, bDelete);
    _Socket = NULL;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;

quit:

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection(
    IN BOOL bClose,
    IN BOOL bIndicate,
    IN BOOL bDispose
    )

/*++

Routine Description:

    Releases the connection back to the server limited pool and optionally
    closes the socket handle and destroys the socket object

Arguments:

    bClose      - if TRUE, increments the available connection count in the
                  server info object and closes the handle, else we are
                  returning a keep-alive connection; after this call we no
                  longer have a socket object owned by this request handle
                  object

    bIndicate   - TRUE if we indicate to the user when we close the socket
                  handle

    bDispose    - TRUE if we are disposing of the socket object (mutually
                  exclusive with !bClose), in which case we will no longer have
                  a socket object after this call returns

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection",
                 "%B, %B, %B",
                 bClose,
                 bIndicate,
                 bDispose
                 ));

    INET_ASSERT(_Socket != NULL);
    //INET_ASSERT(_Socket->IsOpen());

    CServerInfo * pServerInfo = GetServerInfo();

    // Always disconnect sockets which have been marked as authenticated.
    // This is to avoid posting data to IIS4 while preauthenticating
    // and inducing the server to close the connection.
    if (_Socket)
        bClose = (bClose || _Socket->IsAuthenticated());
        
    ICSocket * pSocket = bClose ? NULL : _Socket;

    INET_ASSERT(pServerInfo != NULL);

    if (pServerInfo != NULL) {
        if (bClose && (_Socket != NULL)) {

            //
            // BUGBUG - this should be set based on bGraceful parameter
            //

            _Socket->SetLinger(FALSE, 0);

            //INET_ASSERT(!_bKeepAliveConnection || _bNoLongerKeepAlive);
            _Socket->Shutdown(SD_BOTH);
            _Socket->Disconnect(bIndicate ? SF_INDICATE : 0);
            if (bDispose) {
                _Socket->Dereference();
                _Socket = NULL;
            }
        } else {
            _Socket = NULL;
        }
        //if (IsResponseHttp1_1() && IsKeepAlive()) {
        //    pServerInfo->ReleasePipelinedConnection(pSocket);
        //} else {
            pServerInfo->ReleaseConnection(pSocket);
        //}
    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::AbortConnection(
    IN BOOL bForce
    )

/*++

Routine Description:

    Aborts the current connection. Closes the socket and frees up all receive
    buffers. If the connection is keep-alive, we have the option to forcefully
    terminate the connection, or just return the socket to the keep-alive pool

Arguments:

    bForce  - if TRUE and keep-alive, forcefully close the keep-alive socket

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::AbortConnection",
                "%B",
                bForce
                ));

    DWORD error;

    error = CloseConnection(bForce);
    if (error == ERROR_SUCCESS) {

        //
        // destroy all response variables. This is similar to ReuseObject()
        // except we don't change the object state, or reset the end-of-file
        // state
        //

        _ResponseHeaders.FreeHeaders();
        FreeResponseBuffer();
        ResetResponseVariables();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel(
    VOID
    )

/*++

Routine Description:

    Creates a connection with the requested server via a Proxy
    tunnelling method.

    Works by creating a nested child HTTP and Connect request object.
    These objects send a "CONNECT" verb to the proxy server asking for
    a connection to made with the destination server. Upon completion the
    child objects are discarded.  If a class 200 response is not received from
    proxy server, the proxy response is copied into this object
    and returned to the user.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel",
                 NULL
                 ));

    DWORD error = DoFsm(New CFsm_OpenProxyTunnel(this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_OpenProxyTunnel::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next OpenProxyTunnel state

Arguments:

    Fsm - contains state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_OpenProxyTunnel::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_OpenProxyTunnel * stateMachine = (CFsm_OpenProxyTunnel *)Fsm;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->OpenProxyTunnel_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm(
    IN CFsm_OpenProxyTunnel * Fsm
    )

/*++

Routine Description:

    State machine for OpenProxyTunnel

Arguments:

    Fsm - contains state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_OpenProxyTunnel & fsm = *Fsm;
    DWORD error = fsm.GetError();
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();

    // Need to bury error on blocked async item that failed to find
    // established SSL tunnel
    if (error != ERROR_SUCCESS && fsm.GetFunctionState() != FSM_STATE_2) {
        goto quit;
    }
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    //  Need to use handle magic for async requests
    //  so we'll have the reference before jumping.
    //

    INTERNET_HANDLE_OBJECT * pInternet;
    pInternet = GetRootHandle (this);

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_1:
            goto send_continue;

        case FSM_STATE_2:
            goto keep_alive_tunnel;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);
            goto quit;
        }
    }

    // Do not continue if handle is in NTLM challenge state - we
    // already have a valid socket set up for tunnelling.
    if ((_Socket != NULL) && (GetAuthState() == AUTHSTATE_CHALLENGE))
    {
        error = ERROR_SUCCESS;
        goto quit;
    }


    // First, try and fetch an already established tunnel
    // from the keep-alive pool.  If so, we can avoid the nested
    // CONNECT request.
    //
    if (_Socket == NULL)
    {
        error = OpenConnection(FALSE, TRUE);

        if (error == ERROR_IO_PENDING)
        {
            fsm.SetFunctionState(FSM_STATE_2);
            goto quit;
        }
keep_alive_tunnel:
        if (error == ERROR_SUCCESS && _Socket != NULL)
        {
            // No need to create nested request.  We found an active SSL tunnel
            // for this server in the keep-alive pool.
            goto quit;
        }
        else
        {
            // Start over as normal tunnel since bypass to find
            // keep-alive failed.
            error = ERROR_SUCCESS;
        }
    }

    //
    //  With the Internet Handle Object,
    //  construct a new Connect Object, and new HttpRequest Object.
    //

    //
    // increment the nested request level around InternetConnect(). This is
    // required to stop InternetConnect() believing this is the async part of
    // a two-part (FTP) request (original async hackery)
    //

    _InternetIncNestingCount();
    fsm.m_hConnect = InternetConnect(pInternet->GetPseudoHandle(),
                                     GetHostName(),
                                     GetHostPort(),
                                     0, // no flags
                                     NULL
                                     );
    _InternetDecNestingCount(1);
    if (!fsm.m_hConnect) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_IO_PENDING);

        goto quit;
    }

    //
    // Now do an Open Request. This will pick up the secure proxy flag.
    //

    fsm.m_hRequest = HttpOpenRequest(fsm.m_hConnect,
                                     "CONNECT",
                                     "/",    // we don't need this for a CONNECT
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL
                                     );
    if (!fsm.m_hRequest) {
        error = GetLastError();
        goto quit;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(fsm.m_hRequest,
                               (LPVOID *)&fsm.m_hRequestMapped,
                               FALSE);
    if ((error != ERROR_SUCCESS) || (fsm.m_hRequestMapped == NULL)) {
        goto quit;
    }

    fsm.m_pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.m_hRequestMapped;

    //
    // we need to set the special secure proxy flag in the request object
    //

    fsm.m_pRequest->SetTunnel();


    LPSTR proxyHostName;
    DWORD proxyHostNameLength;
    INTERNET_PORT proxyHostPort;

    GetProxyName(&proxyHostName,
                 &proxyHostNameLength,
                 &proxyHostPort
                 );
    fsm.m_pRequest->SetProxyName(proxyHostName,
                                 proxyHostNameLength,
                                 proxyHostPort
                                 );

    //
    // Transfer any proxy user/pass from the handle.
    //
    LPSTR lpszUser, lpszPass;

    // Get username + password off of outer handle.
    if (GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
    {
        // This will automatically re-validate the username/password
        // on the tunneling handle.
        fsm.m_pRequest->SetProp (WINHTTP_OPTION_PROXY_USERNAME
            & WINHTTP_OPTION_MASK, lpszUser);
        fsm.m_pRequest->SetProp (WINHTTP_OPTION_PROXY_PASSWORD
            & WINHTTP_OPTION_MASK, lpszPass);
    }

    if (_pProxyCreds)
    {
        fsm.m_pRequest->_pProxyCreds = new WINHTTP_REQUEST_CREDENTIALS(_pProxyCreds->_AuthScheme,
                                                                       _pProxyCreds->_pszRealm,
                                                                       _pProxyCreds->_pszUserName,
                                                                       _pProxyCreds->_pszPassword);
        if (fsm.m_pRequest->_pProxyCreds == NULL)
        {
            // If we couldn't clone it, transfer it. This is not efficient, but it will work.
            fsm.m_pRequest->_pProxyCreds = _pProxyCreds;
            _pProxyCreds = NULL; // ownership transferred
        }
    }

    //
    // Transfer any authentication context to the tunnelling handle.
    //

    //fsm.m_pRequest->SetAuthCtx (_pTunnelAuthCtx);


    //dprintf("New tunnel request %#x making nested request= %#x\n", this, fsm.m_pRequest);

    //
    // Do the Nested SendRequest to the Proxy Server.
    //  ie send the CONNECT method.
    //

    fsm.SetFunctionState(FSM_STATE_1);
    if (!HttpSendRequest(fsm.m_hRequest, NULL, 0, NULL, 0)) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            goto done;
        }
        goto quit;
    }

send_continue:

    //
    // Check Status Code Returned from proxy Server Here.
    // If its not 200 we let the user view it as a Proxy Error
    //  and DON'T continue our connection to the SSL/PCT Server.
    //

    //dprintf("Received Nested Response, Socket=%#x, org request=%#x, nested request=%#x\n", fsm.m_pRequest->_Socket, this, fsm.m_pRequest);

    _StatusCode = fsm.m_pRequest->GetStatusCode();

    switch (_StatusCode) {

        case HTTP_STATUS_OK:
            break;

        case HTTP_STATUS_PROXY_AUTH_REQ:
            if ((error = CloneResponseBuffer(fsm.m_pRequest)) != ERROR_SUCCESS)
                goto quit;
            break;

        default:
            if ((error = CloneResponseBuffer(fsm.m_pRequest)) != ERROR_SUCCESS)
                goto quit;
            goto quit;
    }


    //
    // Transfer any authentication context back to the outer handle.
    //

    if ( _pTunnelAuthCtx ) {
        delete _pTunnelAuthCtx;
    }

    _pTunnelAuthCtx = fsm.m_pRequest->GetAuthCtx();
    // Don't leave the potential for a deleted request reference
    // to be left in the trasferred context.
    if (_pTunnelAuthCtx)
    {
        _pTunnelAuthCtx->_pRequest = NULL;
    }

    fsm.m_pRequest->SetAuthCtx (NULL);

    _PreferredScheme = fsm.m_pRequest->_PreferredScheme;
    _SupportedSchemes = fsm.m_pRequest->_SupportedSchemes;
    _AuthTarget = fsm.m_pRequest->_AuthTarget;

    //
    // pull the socket handle from the socket object used to communicate with
    // the proxy
    //

    INET_ASSERT(fsm.m_pRequest->_Socket != NULL);

    /*
    if server returned anything other than 200 then we failed; revert to non-
    secure socket
    */

    if (_Socket == NULL)
    {
        // transfer socket reference from nested request
        _Socket = fsm.m_pRequest->_Socket;
        fsm.m_pRequest->_Socket = NULL;

        // Socket should now be marked as secure
        ((ICSecureSocket *)_Socket)->ResetFlags(TRUE);
    }
    if(m_pSecurityInfo == NULL)
    {
        /* SCLE ref */
        m_pSecurityInfo = pInternet->GetSslSessionCache()->Find(GetHostName());
        if (NULL == m_pSecurityInfo)
        {
            /* SCLE ref */
            m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(GetHostName());
        }
    }
    if (_Socket != NULL)
    {

        INET_ASSERT(_Socket->IsSecure());

        /* SCLE ref */
        ((ICSecureSocket *)_Socket)->SetSecurityEntry(m_pSecurityInfo);
        /* SCLE ref */
        ((ICSecureSocket *)_Socket)->SetHostName(GetHostName(), pInternet->GetSslSessionCache());
        ((ICSecureSocket *)_Socket)->SetSecureFlags(GetOpenFlags() & SECURITY_INTERNET_MASK);
        if (GetEnableFlags() & WINHTTP_ENABLE_SSL_REVOCATION)
            ((ICSecureSocket *)_Socket)->SetSecureFlags(SECURITY_FLAG_CHECK_REVOCATION);

        // Update values for the established tunnel
        _Socket->SetPort(fsm.m_pRequest->GetHostPort());
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

quit:

    if (fsm.m_hRequestMapped != NULL) {
        DereferenceObject((LPVOID)fsm.m_hRequestMapped);
    }

    if (fsm.m_hRequest != NULL) {

        BOOL bOk;
        bOk = WinHttpCloseHandle(fsm.m_hRequest);
        INET_ASSERT(bOk);
    }

    if (fsm.m_hConnect != NULL) {

        BOOL bOk;
        bOk = WinHttpCloseHandle(fsm.m_hConnect);
        INET_ASSERT(bOk);
    }

    //
    // We Reset the ThreadInfo back to the the previous
    //  object handle, and context values.
    //

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, GetPseudoHandle(), (HINTERNET)this);
        _InternetClearLastError(lpThreadInfo);
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer(
    IN HTTP_REQUEST_HANDLE_OBJECT *pChildRequestObj
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT CloneResponseBuffer method.

    Copies a Child Request Object's Response Buffer into "this"
    request object.  Also forces header parsing to be rerun on
    the header.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer",
                 "%#x",
                 pChildRequestObj
                 ));

    DWORD error;
    LPBYTE lpBuffer;

    error = ERROR_SUCCESS;

    lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(pChildRequestObj->_BytesReceived);

    if ( lpBuffer == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull out headers, and data from Child Request into our request.
    //


    CopyMemory(
           lpBuffer,
           pChildRequestObj->_ResponseBuffer,
           pChildRequestObj->_BytesReceived
           );

    //
    // Recreate and reparse our header structure into our Object,
    //  this is kindof inefficent, but it only happens on errors
    //

    error = CreateResponseHeaders(
                                (LPSTR*) &lpBuffer,
                                pChildRequestObj->_BytesReceived
                                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //

    SetAvailableDataLength(BufferedDataLength());

quit:

    if (lpBuffer) {
        FREE_MEMORY (lpBuffer);
    }
    
    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\send.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    send.cxx

Abstract:

    This file contains the HTTP Request Handle Object SendRequest method

    Contents:
        CFsm_SendRequest::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_SendRequest::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_SendRequest::RunSM",
                 "%#x",
                 Fsm
                 ));

    START_SENDREQ_PERF();

    CFsm_SendRequest * stateMachine = (CFsm_SendRequest *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->SendRequest_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    STOP_SENDREQ_PERF();

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm(
    IN CFsm_SendRequest * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(SendRequest_Fsm);

    CFsm_SendRequest & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    LPSTR requestBuffer = fsm.m_pRequestBuffer;
    DWORD requestLength = fsm.m_dwRequestLength;
    LPVOID lpOptional = fsm.m_lpOptional;
    DWORD dwOptionalLength = fsm.m_dwOptionalLength;
    BOOL bExtraCrLf = fsm.m_bExtraCrLf;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (state != FSM_STATE_INIT) {
        state = fsm.GetFunctionState();
    }
    switch (state) {

    case FSM_STATE_INIT:

    fsm.SetFunctionState(FSM_STATE_1);
    error = DoFsm(New CFsm_MakeConnection(this));


    case FSM_STATE_1:

        if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
            goto quit;
        }

        // Monolithic upload: If we have optional data to send,
        // save off in handle and flag that the data has been saved.
        // This is useful in the case of redirects and auth, because of RR FSM changes:
        if (fsm.m_lpOptional && fsm.m_dwOptionalLength)
        {
            _lpOptionalSaved = fsm.m_lpOptional;
            _dwOptionalSaved = fsm.m_dwOptionalLength;
            _fOptionalSaved = TRUE;
        }            
        else
        // Check if optional data has been saved in handle during a previous
        // SendRequest or negotiate stage. If so, restore it and content length:
        // Do it only if you don't have something already:
        if (_fOptionalSaved)
        {
            // Restore the fsm optional values and content length.
            
            lpOptional = fsm.m_lpOptional = _lpOptionalSaved;
            dwOptionalLength = fsm.m_dwOptionalLength = _dwOptionalSaved;

            if(!IsWriteRequired())
            // Reset Content-Length, but only if Writes are not required. If Writes are required, someplace
            // else would have done it. In the case of redirects and auth, we should not hit this for Writes,
            // because we fail the request:
            {
                DWORD cbNumber;
                CHAR szNumber[sizeof("4294967295")];
                cbNumber = wsprintf(szNumber, "%d", fsm.m_dwOptionalLength);

                ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                    (LPSTR)szNumber,
                                    cbNumber,
                                    0,   // dwIndex
                                    ADD_HEADER
                                    ); 
            }
        }

        // # 62953
        // If initiating NTLM authentication, don't submit request data since
        // we're expecting to get a challenge and resubmit the request anyway.
        if (GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            if (!((PLUG_CTX*)(GetAuthCtx()))->_fNTLMProxyAuth)
            {
                // We are in the negotiate phase during a POST
                // and do not have an authenticated socket. 
                // In both monolithic upload InternetWriteFile
                // cases, we wish to omit any post data, and reflect
                // this in the content length.
                if (!((GetMethodType() == HTTP_METHOD_TYPE_GET) && !IsMethodBody()))
                {
                    ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                         "0",
                                         1,
                                         0,   // dwIndex
                                         ADD_HEADER
                                         );
                }

                fsm.m_lpOptional = lpOptional = NULL;
                fsm.m_dwOptionalLength = dwOptionalLength = 0;
            }        
        }

        bExtraCrLf = (!(GetOpenFlags() & WINHTTP_FLAG_SECURE)
                      && (dwOptionalLength != 0)
                      && ((GetServerInfo() != NULL)
                        ? GetServerInfo()->IsHttp1_0()
                        : TRUE));

        //
        // collect request headers into blob
        //

        BOOL bCombinedData;

        requestBuffer = CreateRequestBuffer(&requestLength,
                                            lpOptional,
                                            dwOptionalLength,
                                            bExtraCrLf,
                                            GlobalTransportPacketLength,
                                            &bCombinedData
                                            );
        if (requestBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        DEBUG_PRINT(HTTP, INFO, ("SendRequest_FSM: lpOptional=0x%x dwOptionalLength=%d\n", 
                                fsm.m_lpOptional, fsm.m_dwOptionalLength));

        if (bCombinedData) {

            //
            // everything copied to one buffer. No need to send separate
            // optional data and CR-LF termination
            //

            fsm.m_lpOptional = lpOptional = NULL;
            fsm.m_dwOptionalLength = dwOptionalLength = 0;
            bExtraCrLf = FALSE;
        }
        fsm.m_pRequestBuffer = requestBuffer;
        fsm.m_dwRequestLength = requestLength;
        fsm.m_bExtraCrLf = bExtraCrLf;
        DEBUG_PRINT(HTTP, INFO, ("fsm.m_pRequestBuffer=0x%x\r\n", fsm.m_pRequestBuffer));
        StartRTT();

        //
        // send the request. If we are using a keep-alive connection, this may
        // fail because the server timed it out since we last used it. We must
        // be prepared to re-establish
        //

        fsm.SetFunctionState(FSM_STATE_3);
        error = _Socket->Send(requestBuffer, requestLength, SF_INDICATE);

        //
        // fall through
        //

    case FSM_STATE_3:
        if (error != ERROR_SUCCESS) {
            if (error != ERROR_IO_PENDING) {
                CloseConnection(TRUE);
            }
            goto quit;
        }

        //
        // send any optional data (that we didn't send in the request buffer).
        // If this fails then we don't retry. We assume that if the first send
        // succeedeed, but the second failed, then this is a non-recoverable
        // error
        //

        //fsm.m_bExtraCrLf = bExtraCrLf = TRUE;
        if (dwOptionalLength != 0) {

            LPSTR buffer = (LPSTR)lpOptional;
            DWORD length = dwOptionalLength;

            if (bExtraCrLf) {
                length += sizeof(gszCRLF) - 1;
                if (requestLength >= length) {
                    buffer = requestBuffer;
                } else if (length <= GlobalTransportPacketLength) {
                    requestBuffer = (LPSTR)ResizeBuffer(requestBuffer,
                                                        length,
                                                        FALSE
                                                        );
                    buffer = requestBuffer;
                    fsm.m_pRequestBuffer = requestBuffer;
                } else {
                    length -= sizeof(gszCRLF) - 1;
                }
                if (buffer == requestBuffer) {
                    memcpy(buffer, lpOptional, dwOptionalLength);
                    buffer[dwOptionalLength] = '\r';
                    buffer[dwOptionalLength + 1] = '\n';
                    fsm.m_bExtraCrLf = bExtraCrLf = FALSE;
                }
            }
            fsm.SetFunctionState(FSM_STATE_4);
            error = _Socket->Send(buffer, length, SF_INDICATE);
        }

        //
        // fall through
        //

    case FSM_STATE_4:

        //
        // Here we also add an extra CR-LF if the app is sending data (even if
        // the amount of data supplied is zero) unless we are using a keep-alive
        // connection, in which case we're not dealing with old servers which
        // require CR-LF at the end of post data.
        //
        // But only do this for non-HTTP 1.1 servers and proxies ( ie when
        //  the user puts us in HTTP 1.0 mode)
        //

        if ((error == ERROR_SUCCESS) && bExtraCrLf) {
            fsm.SetFunctionState(FSM_STATE_5);
            error = _Socket->Send(gszCRLF, 2, SF_INDICATE);
        }

        //
        // fall through
        //

    case FSM_STATE_5:

        //
        // we are now in receiving state
        //

        if (error == ERROR_SUCCESS) {
            SetState(HttpRequestStateResponse);
        }
        break;
    }

quit:

    if (error != ERROR_IO_PENDING) {
//dprintf("HTTP connect-send took %d msec\n", GetTickCount() - _dwQuerySetCookieHeader);
        fsm.SetDone();

        PERF_LEAVE(SendRequest_Fsm);
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\httpcache\cachehndl.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cachehndl.cxx

Abstract:

    Cache handle manager for creating, deleting, reference counting,
    and mapping HINTERNET objects to HTTPCACHE_REQUEST objects

Author:

Revision History:

--*/

/*

  Class CACHE_HANDLE_MANAGER public interface:

    BOOL AddCacheRequestObject(HINTERNET hRequest);
    BOOL GetCacheRequestObject(HINTERNET hRequest, HTTPCACHE_REQUEST* CacheRequest); 
    BOOL RemoveCacheRequestObject(HINTERNET hRequest);
    
    CACHE_HANDLE_MANAGER();
    ~CACHE_HANDLE_MANAGER();
    
*/
#include <wininetp.h>
#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"
#include "cachelogic.hxx"
#include "cachehndl.hxx"

/*
We'll also let the handle manager takes care of the work of loading and unloading
the URLCACHE library
*/

CACHE_HANDLE_MANAGER::CACHE_HANDLE_MANAGER() 
{
    HeadCacheRequestList = NULL;
    dwRefCount = 0;
    HndlMgrCritSec.Init();
	DLLUrlCacheEntry(DLL_PROCESS_ATTACH);
}

CACHE_HANDLE_MANAGER::~CACHE_HANDLE_MANAGER() 
{
    HndlMgrCritSec.FreeLock();
	DLLUrlCacheEntry(DLL_PROCESS_DETACH);    
}

// Precondition:  hRequest really is a HTTP_REQUEST_HANDLE_OBJECT.
BOOL CACHE_HANDLE_MANAGER::AddCacheRequestObject(HINTERNET hRequest)
{    
    DWORD dwHandleType;
    DWORD dwSize = sizeof(DWORD);
    DWORD fResult = FALSE;
    
    HndlMgrCritSec.Lock();

    if (hRequest == NULL)
        goto quit;
    
    // If you try to give me a Connect or Session handle and try to trick me into
    // thinking that it's a Request handle, then I'll fail you!
    WinHttpQueryOption(hRequest, WINHTTP_OPTION_HANDLE_TYPE, &dwHandleType, &dwSize);
    if (dwHandleType != WINHTTP_HANDLE_TYPE_REQUEST)
        goto quit;

    // We don't add another hInternet->HTTPCACHE_REQUEST mapping if one already exists
    if (GetCacheRequestObject(hRequest) != NULL)
        goto quit;

    // Traverse to the end of the list
    CACHE_REQUEST_LIST * CurCacheRequestList = HeadCacheRequestList;
    if (HeadCacheRequestList != NULL)
    {
        for (;;)
        {
            if (CurCacheRequestList->next == NULL)
                break;
            CurCacheRequestList = CurCacheRequestList->next;
        }

        if ((CurCacheRequestList->next = new CACHE_REQUEST_LIST(hRequest)) != NULL)
        {
            dwRefCount++;
            fResult = TRUE;
            goto quit;
        }
    }
    else
    {
        if ((HeadCacheRequestList = new CACHE_REQUEST_LIST(hRequest)) != NULL) 
        {
            dwRefCount++;
            fResult = TRUE;
            goto quit;
        }
    }

quit:
    HndlMgrCritSec.Unlock();
    return fResult;
    
}
    
HTTPCACHE_REQUEST * CACHE_HANDLE_MANAGER::GetCacheRequestObject(HINTERNET hRequest)
{
    CACHE_REQUEST_LIST * CurCacheRequestList = HeadCacheRequestList;

    while (CurCacheRequestList != NULL)
    {
        if (CurCacheRequestList->CacheRequestObj->GetRequestHandle() == hRequest)
        {
            return CurCacheRequestList->CacheRequestObj;
        }
        CurCacheRequestList = CurCacheRequestList->next;
    }

    return NULL;
}

BOOL CACHE_HANDLE_MANAGER::RemoveCacheRequestObject(HINTERNET hRequest)
{
    if (HeadCacheRequestList == NULL)
        return FALSE;

    CACHE_REQUEST_LIST * CurCacheRequestList = HeadCacheRequestList;

    if (HeadCacheRequestList->CacheRequestObj->GetRequestHandle() == hRequest)
    {
        HndlMgrCritSec.Lock();

        HeadCacheRequestList = HeadCacheRequestList->next;
        delete CurCacheRequestList;
        CurCacheRequestList = NULL;
        
        dwRefCount--;
        
        HndlMgrCritSec.Unlock();

        return TRUE;
    }
    

    while (CurCacheRequestList->next != NULL)
    {
        if (CurCacheRequestList->next->CacheRequestObj->GetRequestHandle() == hRequest)
        {
            HndlMgrCritSec.Lock();
            
            CACHE_REQUEST_LIST * DeleteCacheRequestList = CurCacheRequestList->next;
            
            if (CurCacheRequestList->next->next == NULL)
                CurCacheRequestList->next = NULL;
            else
                CurCacheRequestList->next = CurCacheRequestList->next->next;

            delete DeleteCacheRequestList;
            DeleteCacheRequestList = NULL;
            
            dwRefCount--;
            
            HndlMgrCritSec.Unlock();

            return TRUE;
        }
        CurCacheRequestList = CurCacheRequestList->next;
    }
        
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\sendreq.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    send.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest
        HTTP_REQUEST_HANDLE_OBJECT::CheckClientRequestHeaders
        CFsm_HttpSendRequest::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start
        HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish
        HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo
        HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest(
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID *lplpOptional,
    IN LPDWORD lpdwOptionalLength,
    IN DWORD dwOptionalLengthTotal
    )

/*++

Routine Description:

    Performs Initiatization of the HTTP Request by setting up the necessary
     headers and preparing the POST data.

Arguments:

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total Length for File Upload.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - One of the Win32 Error values.

  Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest",
                 "%#x, %d, %d, %#x",
                 lplpOptional ? *lplpOptional : NULL,
                 lpdwOptionalLength ? *lpdwOptionalLength : NULL,
                 dwOptionalLengthTotal
                 ));

    DWORD error = ERROR_SUCCESS;
    LPVOID lpOptional       = *lplpOptional;
    DWORD dwOptionalLength  = *lpdwOptionalLength;

    //
    // validate parameters
    //

    if ((lpOptional == NULL) || (dwOptionalLength == 0)) {
        lpOptional = NULL;
        dwOptionalLength = 0;
    }

    //
    // the headers lengths can be -1 meaning that we should calculate the
    // string lengths. We must do this before calling MakeAsyncRequest()
    // which is expecting the parameters to be correct
    //

    if (dwHeadersLength == -1) 
    {
        dwHeadersLength = lstrlen((LPCSTR)lpszHeaders);
    } 

    //
    // if the caller specified some additional headers, then add them before
    // we make the request asynchronously
    //

    if (ARGUMENT_PRESENT(lpszHeaders) && (*lpszHeaders != '\0')) {

        //
        // we use the API here because the headers came from the app, and
        // we don't trust it
        //

        if (!HttpAddRequestHeaders(GetPseudoHandle(),
                                   lpszHeaders,
                                   dwHeadersLength,

                                   //
                                   // if the object is being re-used then
                                   // replace the headers to avoid
                                   // duplicating original headers
                                   //

                                   IS_VALID_HTTP_STATE(this, REUSE, TRUE)
                                    ? ( HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD ): 0
                                    //? HTTP_ADDREQ_FLAG_REPLACE : 0
                                   )) {
            error = GetLastError();
            goto quit;
        }
    }

    //
    // If we fall through then we are connected and a) either the thing
    // is not in the cache or we did a conditional get or c) there was
    // some cache error
    //

    error = ERROR_SUCCESS;

    //
    // if the app supplied a user-agent string to InternetOpen() AND hasn't
    // added a "User-Agent:" header, then add it
    //

    LPSTR userAgent;
    DWORD userAgentLength;

    userAgent = GetUserAgent(&userAgentLength);
    if (userAgent != NULL) {
        ReplaceRequestHeader(HTTP_QUERY_USER_AGENT,
                             userAgent,
                             userAgentLength,
                             0, // dwIndex,
                             ADD_HEADER_IF_NEW
                             );
    }

    //
    // do the same thing with the "Host:" header. The header-value is the host
    // name supplied to InternetConnect() (or the name of the redirected host)
    //

    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT hostPort;

    hostName = GetHostName(&hostNameLength);
    hostPort = GetHostPort();

    INET_ASSERT((hostName != NULL) && (hostNameLength > 0));

    char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];

    if ((hostPort != INTERNET_DEFAULT_HTTP_PORT)
    && (hostPort != INTERNET_DEFAULT_HTTPS_PORT)) {
        if (lstrlen(hostName) > INTERNET_MAX_HOST_NAME_LENGTH)
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        hostNameLength = wsprintf(hostValue, "%s:%d", hostName, (hostPort & 0xffff));
        hostName = hostValue;
    }
    ReplaceRequestHeader(HTTP_QUERY_HOST,
                         hostName,
                         hostNameLength,
                         0, // dwIndex,
                         ADD_HEADER_IF_NEW
                         );

    //
    // if the app requested keep-alive then add the header; if we're going via
    // proxy then use the proxy-connection header
    //

    //if (pRequest->GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION) {
    //    pRequest->SetWantKeepAlive(TRUE);
    //}

    //
    // add the content-length header IF we are sending data OR this is a POST,
    // AND ONLY if the app has not already added the header
    //

    if (dwOptionalLength || dwOptionalLengthTotal)
        SetMethodBody();
        
    if (((dwOptionalLength != 0) || (dwOptionalLengthTotal != 0))

    //
    // BUGBUG - just comparing against a method type is insufficient. We need
    //          a test of whether the method implies sending data (PUT, etc).
    //          We make the same test in other places
    //

    || (GetMethodType() != HTTP_METHOD_TYPE_GET)) {

        DWORD dwContentLength;

        char number[sizeof("4294967295")];

        //
        // For File Upload we need to add the Content-Length
        //   header off of the Total Length, Not the current
        //   data size.  Since we get more data via InternetWriteFile
        //

        if ( dwOptionalLengthTotal != 0 )
        {
            dwContentLength = dwOptionalLengthTotal;
        }
        else
        {
            dwContentLength = dwOptionalLength;
        }

        // _itoa(dwOptionalLength, number, 10);
        wsprintf(number, "%d", dwContentLength);

        DWORD numberLength = lstrlen(number);

        /*----------------------------------------------------------------------

        #62953 NOTE --  Authstate can never be in the AUTHSTATE_NEGOTIATE
        state here. It is not necessary to zero out the content length
        header here when omitting post data on NTLM negotiate since this
        will be done later in the request. The commented-out code is not
        necessary.

        if ((GetMethodType() == HTTP_METHOD_TYPE_POST)
            && (GetAuthState() == AUTHSTATE_NEGOTIATE))
        {

            ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                "0",
                                1,
                                0,   // dwIndex
                                ADD_HEADER
                                );
        }

        ---------------------------------------------------------------------*/

        // Normally we don't over-write the content-length
        // header if one already exists.
        DWORD dwAddHeader;
        dwAddHeader = ADD_HEADER_IF_NEW;

        // But if we're posting data and have an auth ctx
        // over-write the content-length header which will
        // have been reset to 0 to omit post data on the
        // negotiate phase.
        AUTHCTX *pAuthCtx;
        pAuthCtx = GetAuthCtx();
        if (pAuthCtx)
        {
            dwAddHeader = ADD_HEADER;
        }


        ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                            (LPSTR)number,
                            numberLength,
                            0,   // dwIndex
                             dwAddHeader
                            );

    }

quit:

    *lplpOptional       = lpOptional;
    *lpdwOptionalLength = dwOptionalLength;

    DEBUG_LEAVE(error);

    return error;
}



DWORD
CFsm_HttpSendRequest::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpSendRequest::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    START_SENDREQ_PERF();

    CFsm_HttpSendRequest * stateMachine = (CFsm_HttpSendRequest *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:

        //CHECK_FSM_OWNED(Fsm);

        error = pRequest->HttpSendRequest_Start(stateMachine);
        break;

    case FSM_STATE_FINISH:

        //CHECK_FSM_OWNED(Fsm);

        error = pRequest->HttpSendRequest_Finish(stateMachine);
        break;

    case FSM_STATE_ERROR:

        //CHECK_FSM_OWNED(Fsm);

        error = Fsm->GetError();

        //
        // If we block to call GetProxyInfo async, then
        //  we may get unblocked during a cancel.  We need to
        //   handle it by freeing the object in our destructor.
        //

        INET_ASSERT( (!stateMachine->m_fOwnsProxyInfoQueryObj) ?
                        ( error == ERROR_WINHTTP_OPERATION_CANCELLED ||
                          error == ERROR_WINHTTP_TIMEOUT )  :
                        TRUE );

        Fsm->SetDone();
        break;

    default:

        //CHECK_FSM_OWNED(Fsm);

        stateMachine->m_fOwnsProxyInfoQueryObj = TRUE;
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    STOP_SENDREQ_PERF();

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start(
    IN CFsm_HttpSendRequest * Fsm
    )

/*++

Routine Description:

    Calls SendData() method in a loop, handling redirects (& authentications?)
    until we have successfully started to retrieve what was originally requested

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Operation completed successfully

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_WINHTTP_INCORRECT_HANDLE_STATE
                    The HTTP request handle is in the wrong state for this
                    request

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(HttpSendRequest_Start);

    //CHECK_FSM_OWNED(Fsm);

    CFsm_HttpSendRequest & fsm = *Fsm;

    //
    // we must loop here while the server redirects us or while we authenticate
    // the user
    //

    FSM_STATE state = fsm.GetState();
    DWORD error = fsm.GetError();

    //
    // We set m_fOwnsProxyInfoObj TRUE, because by virtue of being here
    //   we have know that we now own the pointer in our fsm, pointed to by
    //   fsm.m_pProxyInfoQuery.
    //
    // This boolean is used to know when we are allowed to FREE and ACCESS
    //   this pointer.  If FALSE, we CANNOT touch this pointer because
    //   the auto-proxy thread may be accessing it.   The auto-proxy thread
    //   will unblock us, this releasing its "un-offical" lock on this pointer.
    //

    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    if (state == FSM_STATE_INIT)
    {        
        if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST )
        {
            state = FSM_STATE_4;
            fsm.SetFunctionState(FSM_STATE_4);
        }
    }
    else
    {
        state = fsm.GetFunctionState();
    }

retry_send_request:

    do {
        switch (state) {
        case FSM_STATE_INIT:
        case FSM_STATE_1:

            //CHECK_FSM_OWNED(Fsm);

            fsm.m_iRetries = 2;
            fsm.m_bAuthNotFinished = FALSE;
            fsm.m_dwCookieIndex = 0;

            //
            // Terrible bug that afflicts NS servers while doing SSL,
            //  they lie (those buggers), and claim they do keep-alive,
            //  but when we attempt to reuse their Keep-Alive sockets,
            //  they all fail, so we therefore must increase the retry count
            //  so we can empty all the bad keep-alive sockets out of the pool
            //
              
            if ( (GetOpenFlags() & WINHTTP_FLAG_SECURE) )
            {
                CServerInfo * pServerInfo = GetServerInfo();
    
                if ( pServerInfo && pServerInfo->IsBadNSServer() )
                {
                    fsm.m_iRetries = 5;
                }
            }

            //
            // if we're not in the right state to send, drain the socket
            //

            if (!IsValidHttpState(SEND)) {

#define DRAIN_SOCKET_BUFFER_LENGTH  (1 K)

                if (fsm.m_pBuffer == NULL) {
                    fsm.m_pBuffer = (LPVOID)ALLOCATE_MEMORY(
                                        LMEM_FIXED,
                                        DRAIN_SOCKET_BUFFER_LENGTH);
                    if (fsm.m_pBuffer == NULL) {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }
                }
                do {
                    if (!fsm.m_bSink) {
                        fsm.m_bSink = TRUE;
                        fsm.SetFunctionState(FSM_STATE_2);
                        error = ReadData(fsm.m_pBuffer,
                                         DRAIN_SOCKET_BUFFER_LENGTH,
                                         &fsm.m_dwBytesDrained,
                                         TRUE,
                                         0);
                        if (error == ERROR_IO_PENDING) {
                            goto quit;
                        }
                    }

                    //
                    // fall through to state 2
                    //

        case FSM_STATE_2:

                    fsm.m_bSink = FALSE;
                } while ((error == ERROR_SUCCESS) && (fsm.m_dwBytesDrained != 0));
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }
                if (fsm.m_pBuffer != NULL) {
                    fsm.m_pBuffer = (LPVOID)FREE_MEMORY(fsm.m_pBuffer);

                    INET_ASSERT(fsm.m_pBuffer == NULL);

                }

                ReuseObject();

                INET_ASSERT(!IsData());
                INET_ASSERT(IS_VALID_HTTP_STATE(this, SEND, TRUE));

                //
                // BUGBUG - if we're not in the right state?
                //

            }

            //
            // generate the correct request headers based
            //  on what types, or whether we're using
            //  proxies
            //


            fsm.SetFunctionState(FSM_STATE_3);
            error = UpdateProxyInfo(Fsm, FALSE);

            if (error == ERROR_IO_PENDING) {
                goto done;
            }

            //
            // set function state to not-FSM_STATE_3 to differentiate interrupted
            // path in FSM_STATE_3
            //

            fsm.SetFunctionState(FSM_STATE_BAD);

            //
            // fall through
            //

        case FSM_STATE_3:

            if ((error == ERROR_SUCCESS)
            && (fsm.GetFunctionState() == FSM_STATE_3)) {
                error = UpdateProxyInfo(Fsm, TRUE);
            }

            if (error != ERROR_SUCCESS) {
                fsm.m_bCancelRedoOfProxy = TRUE;
                goto quit;
            }

            //
            // get any cookies required for this site, but only if app didn't
            // tell us it will handle cookies
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_COOKIES) )
            {
                if (CreateCookieHeaderIfNeeded())
                {
                   // SetPerUserItem(TRUE);
                }
            }

            //
            // if this URL requires authentication then add its header here, but
            // only if the app didn't tell us not to
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_AUTH)) 
            {
                SetPPAbort(FALSE); // let's assume Passport is not going to abort the send.
                
                error = AuthOnRequest(this);
                if (error != ERROR_SUCCESS) 
                {
                    goto quit;
                }

                if (PPAbort())
                {
                    // Passport needed to abort the send cuz the DA wanted to redirect
                    // the App to an different site *AND* the app wanted to handle the 
                    // redirect itself.
                    error = ERROR_WINHTTP_LOGIN_FAILURE;
                    goto quit;
                }
            }
try_again:
            fsm.SetFunctionState(FSM_STATE_4);
            DEBUG_PRINT(HTTP, INFO, ("State_3_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));
            error = DoFsm(New CFsm_SendRequest(fsm.m_lpOptional,
                                               fsm.m_dwOptionalLength,
                                               this
                                               ));
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

            //
            // fall through
            //

        case FSM_STATE_4:
            DEBUG_PRINT(HTTP, INFO, ("State_4_start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            //
            // This adds CR-LF for the File Upload case
            //

            //if (_RequestMethod == HTTP_METHOD_TYPE_POST && _AddCRLFToPOST && fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST)
            //{
            //    error = _Socket->Send(gszCRLF, 2, 0);
            //    if (error != ERROR_SUCCESS) {
            //        goto quit;
            //    }
            //}
            fsm.m_bWasKeepAlive = (_bKeepAliveConnection || IsKeepAlive());
            if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {

                //
                // must be doing proxy tunnelling request if status code set
                //

                INET_ASSERT(((GetStatusCode() != HTTP_STATUS_OK)
                            && (GetStatusCode() != 0))
                            ? IsTalkingToSecureServerViaProxy()
                            : TRUE
                            );

                //
                // server may have reset keep-alive connection
                //

                if ((error == ERROR_WINHTTP_CONNECTION_ERROR)
                && fsm.m_bWasKeepAlive
                && (--fsm.m_iRetries != 0)) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("keep-alive connection failed after send. Retrying\n"
                                ));

//dprintf("*** retrying k-a connection after send\n");
                    CloseConnection(TRUE);
                    goto try_again;
                }
                goto quit;
            }
            if (fsm.m_arRequest == AR_HTTP_BEGIN_SEND_REQUEST) {
                goto quit;
            }
            fsm.SetFunctionState(FSM_STATE_5);
            error = DoFsm(New CFsm_ReceiveResponse(this));
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

            //
            // fall through
            //

        case FSM_STATE_5:

            DEBUG_PRINT(HTTP, INFO, ("State_5_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            if (error != ERROR_SUCCESS) {
//dprintf("*** post-receive: error=%d, retries=%d\n", error, fsm.m_iRetries);

                //
                // server may have reset keep-alive connection
                //

                if (((error == ERROR_WINHTTP_CONNECTION_ERROR)
                || (error == ERROR_HTTP_INVALID_SERVER_RESPONSE))
                && fsm.m_bWasKeepAlive
                && (--fsm.m_iRetries != 0)) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("keep-alive connection failed after receive. Retrying\n"
                                ));

//dprintf("*** retrying k-a connection after receive\n");
                    CloseConnection(TRUE);
                    _ResponseHeaders.FreeHeaders();
                    ResetResponseVariables();
                    _ResponseHeaders.Initialize();
                    goto try_again;
                }

                goto quit;
            }

            fsm.SetFunctionState(FSM_STATE_6);


        case FSM_STATE_6:
            DEBUG_PRINT(HTTP, INFO, ("State_6_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //
            // put any received cookie headers in the cookie jar, but only if the
            // app didn't tell us not to
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_COOKIES)
            && IsResponseHeaderPresent(HTTP_QUERY_SET_COOKIE) )
            {
                DWORD dwError;
                dwError = ExtractSetCookieHeaders(&fsm.m_dwCookieIndex);

                if ( dwError == ERROR_IO_PENDING )
                {
                    error = ERROR_IO_PENDING;
                    goto quit;
                }
            }

            //
            // we need to handle various intermediary return codes:
            //
            //  30x - redirection
            //  40x - authentication
            //
            // BUT ONLY if the app didn't tell us it wanted to handle these itself
            //

            DWORD statusCode;
            BOOL bNoAuth;

            statusCode = GetStatusCode();
            bNoAuth = (GetOpenFlags() & INTERNET_FLAG_NO_AUTH) ? TRUE : FALSE;

            //
            // if the status is 200 (most frequently return header == success)
            // and we are not authenticating all responses then we're done
            //

            if ((statusCode == HTTP_STATUS_OK) && bNoAuth) {
                goto quit;
            }

            //
            // handle authentication before checking the cache
            //

            if (!bNoAuth) {

                //
                // call packages for basic, ntlm
                //

                error = AuthOnResponse(this);
                // passport1.4 auth could change the status code from 302 to 401 here
                statusCode = GetStatusCode();

                if (error == ERROR_WINHTTP_FORCE_RETRY) {

                    // Force a retry error only if Writes are required, otherwise we have all the data for a redirect:
                    if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST && IsWriteRequired())
                    {
                        goto quit;
                    }

                    //
                    // the object has been updated with new info - try again
                    //

                    fsm.m_bFinished = FALSE;
                    fsm.m_bAuthNotFinished = TRUE;
                    error = ERROR_SUCCESS;

                    //
                    // Reset auto-proxy info so we can retry the connection
                    //

                    if ( fsm.m_fOwnsProxyInfoQueryObj && fsm.m_pProxyInfoQuery && fsm.m_pProxyInfoQuery->IsAlloced())
                    {
                        delete fsm.m_pProxyInfoQuery;
                        fsm.m_pProxyInfoQuery = NULL;
                    }


                } else if (error == ERROR_WINHTTP_INCORRECT_PASSWORD) {

                    //
                    // just return success to the app which will have to check the
                    // headers and make the request again, with the right password
                    //

                    error = ERROR_SUCCESS;
                    goto quit;
                } 
            }

            //
            // if we can read from the cache then let us try
            //

            if ((statusCode == HTTP_STATUS_OK)
                || (statusCode == HTTP_STATUS_NOT_MODIFIED)
                || (statusCode == HTTP_STATUS_PRECOND_FAILED)
                || (statusCode == HTTP_STATUS_PARTIAL_CONTENT)
                || (statusCode == 0)) {

            }

            BOOL fMustRedirect;
            
            fMustRedirect = FALSE;

            if (_pAuthCtx)
            {
                if (_pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT)
                {
                    PASSPORT_CTX* pPPCtx = (PASSPORT_CTX*)_pAuthCtx;
                    if (pPPCtx->m_lpszRetUrl)
                    {
                        fMustRedirect = TRUE;
                    }
                }
            }

            //
            // handle redirection
            //

            fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_UNKNOWN;

            fsm.m_bRedirected = FALSE;

            if (((statusCode == HTTP_STATUS_AMBIGUOUS)              // 300
                 || (statusCode == HTTP_STATUS_MOVED)               // 301
                 || (statusCode == HTTP_STATUS_REDIRECT)            // 302
                 || (statusCode == HTTP_STATUS_REDIRECT_METHOD)     // 303
                 || (statusCode == HTTP_STATUS_REDIRECT_KEEP_VERB)) // 307
                && (fMustRedirect || !(GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT))) {

                //
                // Clean out expired PROXY_STATE
                //

                error = ERROR_SUCCESS;
                if ( fsm.m_fOwnsProxyInfoQueryObj && fsm.m_pProxyInfoQuery && fsm.m_pProxyInfoQuery->IsAlloced())
                {
                    delete fsm.m_pProxyInfoQuery;
                    fsm.m_pProxyInfoQuery = NULL;
                }
                //fsm.m_pProxyState = NULL;
                SetProxyName(NULL, 0, 0);

                //
                // if we've already had the max allowable redirects then quit
                //

                if (fsm.m_dwRedirectCount == 0) {
                    error = ERROR_HTTP_REDIRECT_FAILED;
                    fsm.m_bRedirectCountedOut = TRUE;
                    goto quit;
                }

                //
                // we got 300 (ambiguous), 301 (permanent move), 302 (temporary
                // move), or 303 (redirection using new method)
                //

                switch (statusCode) {
                case HTTP_STATUS_AMBIGUOUS:

                    //
                    // 300 - multiple choice
                    //

                    //
                    // If there is a Location header, we do an "automatic" redirect
                    //

                    if (_ResponseHeaders.LockHeaders())
                    {
                        if (! IsResponseHeaderPresent(HTTP_QUERY_LOCATION)) {
                            _ResponseHeaders.UnlockHeaders();
                            fsm.m_bFinished = TRUE;
                            break;
                        }
                        _ResponseHeaders.UnlockHeaders();
                    }
                    else
                    {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }

                    //
                    // fall through
                    //

                case HTTP_STATUS_MOVED:

                    // Table View:
                    //Method            301             302             303             307
                    //  *               *               *           GET         *
                    //POST                  GET         GET             GET             POST
                    //
                    //Put another way:
                    //301 & 302  - All methods are redirected to the same method but POST. POST is
                    //  redirected to a GET.
                    //303 - All methods are redirected to GET
                    //307 - All methods are redirected to the same method.

                    //
                    // 301 - permanently moved
                    //

                    //
                    // fall through
                    //

                case HTTP_STATUS_REDIRECT:

                    //
                    // 302 - temporarily moved (POST => GET, everything stays the same)
                    //
                    fsm.m_tMethodRedirect = GetMethodType();
                    if (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_POST)
                    //
                    // A POST change method to a GET
                    //
                    {
                        fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                        // force no optional data on second and subsequent sends
                        fsm.m_dwOptionalLength = 0;
                        _fOptionalSaved = FALSE;
                    }

                    INET_ASSERT(((fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_GET)
                                 || (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_HEAD))
                                 ? (fsm.m_dwOptionalLength == 0) : TRUE);

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;

                    break;
                case HTTP_STATUS_REDIRECT_METHOD:

                    //
                    // 303 - see other (POST => GET)
                    //

                    fsm.m_tMethodRedirect = (GetMethodType() == HTTP_METHOD_TYPE_HEAD) ?
                                                    HTTP_METHOD_TYPE_HEAD :
                                                    HTTP_METHOD_TYPE_GET;

                    //
                    // force no optional data on second and subsequent sends
                    //

                    fsm.m_dwOptionalLength = 0;
                    _fOptionalSaved = FALSE;

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;

                case HTTP_STATUS_REDIRECT_KEEP_VERB:

                    //
                    // 307 - see other (POST => POST)
                    //

                    //if (IsHttp1_1()) {
                    fsm.m_tMethodRedirect = GetMethodType();

                    INET_ASSERT(((fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_GET)
                                 || (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_HEAD))
                                 ? (fsm.m_dwOptionalLength == 0) : TRUE);

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;

                default:
                    fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                    //
                    // BUGBUG - force no optional data on second and subsequent
                    //          sends
                    //

                    fsm.m_dwOptionalLength = 0;
                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;
                }

                //
                // Only allow redirect to continue if we are successful.
                //

                if (fsm.m_bRedirected
                && ((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_UNKNOWN)
                    || (fsm.m_tMethodRedirect == GetMethodType()))) {
                    fsm.SetFunctionState(FSM_STATE_7);
                    error = Redirect(fsm.m_tMethodRedirect, FALSE);
                    if (error != ERROR_SUCCESS) {
                        goto quit;
                    }
                }
            } else {

                //
                // not a status that we handle. We're done
                //   BUT WAIT, we're only finshed if also
                //   finished retrying HTTP authentication.
                //
                // if the app told us not to handle authentication auth_not_finished
                // will be FALSE
                //

                if (!fsm.m_bAuthNotFinished) {
                    fsm.m_bFinished = TRUE;
                }
            }

            //
            // fall through
            //

        case FSM_STATE_7:
            DEBUG_PRINT(HTTP, INFO, ("State_7_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            if (fsm.m_bRedirected) {
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                INET_ASSERT(error == ERROR_SUCCESS);

                //
                // cleanup response headers from redirection
                //

                ReuseObject();

                //
                // Allow Redirects to exit out and force the HttpEndRequestA
                //  caller to notice.
                //

                if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST &&
                     fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET &&
                     fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD &&
                    // Force a retry error only if Writes are required, otherwise we have all the data for a redirect:
                     IsWriteRequired()
                     )
                {
                    error = ERROR_WINHTTP_FORCE_RETRY;
                }
            }
        }
        state = FSM_STATE_INIT;
    } while (!fsm.m_bFinished && (error == ERROR_SUCCESS));

quit:
        DEBUG_PRINT(HTTP, INFO, ("Quit1: error = 0x%x\r\n", error));

    if (error == ERROR_IO_PENDING) {
        goto done;
    }

    {
        AUTHCTX* pAuthCtx = GetAuthCtx();
        DWORD eAuthScheme = 0;
        if (pAuthCtx != NULL)
        {
            eAuthScheme = pAuthCtx->GetSchemeType();
        }

        if (!fsm.m_bCancelRedoOfProxy && 
            //(GetStatusCode() != HTTP_STATUS_DENIED) &&
            ((eAuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT) || (GetStatusCode() != HTTP_STATUS_DENIED)) && // this is safer
            fsm.m_pInternet->RedoSendRequest(&error, fsm.m_pRequest->GetSecureFlags(), fsm.m_pProxyInfoQuery, GetOriginServer(), GetServerInfo())) 
        {
            fsm.m_bFinished = FALSE;
            fsm.m_bRedirectCountedOut = FALSE;
            fsm.m_dwRedirectCount = GlobalMaxHttpRedirects;
            fsm.SetState(FSM_STATE_INIT);
            state = FSM_STATE_INIT;
            DEBUG_PRINT(HTTP, INFO, ("Quit2: error = 0x%x\r\n", error));
            goto retry_send_request;
        } 
        else 
        {
            //SetProxyName(NULL, 0, 0);
            DEBUG_PRINT(HTTP, INFO, ("Quit3: error = 0x%x\r\n", error));
        }
    }

    //
    // if ERROR_HTTP_REDIRECT_FAILED then we tried to redirect, but found that
    // we couldn't do it (e.g. http:// to ftp:// or file://, etc.) We need to
    // defer this to the caller to clean up & make the new request. They will
    // have all the header info (plus we probably already indicated the new
    // URL during the redirect callback).  Rather than returning ERROR_SUCCESS,
    // we will now fail with this error.
    //
    // Cases where we are redirected to the same site will return ERROR_SUCCESS.
    //

    if ((error == ERROR_HTTP_NOT_REDIRECTED)
    && !fsm.m_bRedirectCountedOut) {
        error = ERROR_SUCCESS;
    }

    fsm.SetNextState(FSM_STATE_FINISH);

done:

    PERF_LEAVE(HttpSendRequest_Start);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish(
    IN CFsm_HttpSendRequest * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(HttpSendRequest_Finish);

    CFsm_HttpSendRequest & fsm = *Fsm;
    DWORD error = fsm.GetError();

    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    INET_ASSERT(fsm.m_hRequestMapped != NULL);

    //if (!IsAsyncHandle() && (fsm.m_hRequestMapped != NULL)) {
    //    DereferenceObject((LPVOID)fsm.m_hRequestMapped);
    //}

    //
    // we will return FALSE even if this is an async operation and the error is
    // ERROR_IO_PENDING
    //

    fsm.SetDone(error);
    //fsm.SetApiResult(error == ERROR_SUCCESS);

    PERF_LEAVE(HttpSendRequest_Finish);

    DEBUG_LEAVE(error);

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::BuildProxyMessage(
    IN CFsm_HttpSendRequest * Fsm,
    AUTO_PROXY_ASYNC_MSG * pProxyMsg,
    IN OUT URL_COMPONENTS * pUrlComponents
    )

/*++

Routine Description:

    Calls CrackUrl to parses request URL, and 
      transfers the information to the AUTO_PROXY_ASYNC_MSG

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;

    LPSTR currentUrl;
    DWORD currentUrlLength;

    //
    // Gather the URL off the handle
    //

    currentUrl = GetURL();

    if (currentUrl) {
        currentUrlLength = lstrlen(currentUrl);

        //
        // BUGBUG [arthurbi] the following can be a slow call,
        //   but its too risky to change the complete behavior where
        //   we cache it
        //

        //
        // crack the current URL
        //

        memset(pUrlComponents, 0, sizeof(URL_COMPONENTS));
        pUrlComponents->dwStructSize = sizeof(URL_COMPONENTS);

        error = CrackUrl(currentUrl,
                         currentUrlLength,
                         FALSE, // don't escape URL-path
                         &(pUrlComponents->nScheme),
                         NULL,  // don't care about Scheme Name
                         NULL,
                         &(pUrlComponents->lpszHostName),
                         &(pUrlComponents->dwHostNameLength),
                         &(pUrlComponents->nPort),
                         NULL,  // don't care about user name
                         NULL,
                         NULL,  // or password
                         NULL,
                         &(pUrlComponents->lpszUrlPath),
                         &(pUrlComponents->dwUrlPathLength),
                         NULL,  // no extra
                         NULL,
                         NULL
                         );

        pProxyMsg->SetProxyMsg(
            pUrlComponents->nScheme,
            currentUrl,
            currentUrlLength,
            pUrlComponents->lpszHostName,
            pUrlComponents->dwHostNameLength,
            pUrlComponents->nPort
            );
    } else {
        INET_ASSERT(FALSE);
        error = ERROR_WINHTTP_INVALID_URL;
    }
    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryProxySettings(
    IN CFsm_HttpSendRequest * Fsm,
    INTERNET_HANDLE_OBJECT * pInternet,
    IN OUT URL_COMPONENTS * pUrlComponents
    )

/*++

Routine Description:

    Wrapper over GetProxyInfo call to determine proxy
        settings on our given object

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;
    CFsm_HttpSendRequest & fsm = *Fsm;

    INET_ASSERT(fsm.m_pProxyInfoQuery);
    INET_ASSERT(pInternet);

    SetProxyName(NULL, 0, 0);

    fsm.m_fOwnsProxyInfoQueryObj = FALSE;

    if (IsProxy() || (GetProxyInfo() == PROXY_INFO_DIRECT))
    {
        error = GetProxyInfo(&fsm.m_pProxyInfoQuery);
    }
    else
    {
        error = pInternet->GetProxyInfo(&fsm.m_pProxyInfoQuery);
    }

    //
    //  If GetProxyInfo returns pending, then we no longer have
    //   access to the pointer that we've passed.
    //

    if ( error == ERROR_IO_PENDING )
    {
        //
        // Bail out, DO NOT TOUCH any OBJECTS or FSMs 
        //

        goto quit;
    }

    // then regardless we own it unless GetProxyInfo went pending with the FSM
    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    INET_ASSERT( error == ERROR_SUCCESS );

    if ( ! ((fsm.m_pProxyInfoQuery)->IsUseProxy()) )
    {
        SetIsTalkingToSecureServerViaProxy(FALSE);        
    }

quit:

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::CheckForCachedProxySettings(
    IN AUTO_PROXY_ASYNC_MSG *pProxyMsg,
    OUT CServerInfo **ppProxyServerInfo
    )

/*++

Routine Description:

    Attempts to determine and then resolve if there are cached
     proxy settings saved away in the CServerInfo object,
     which is found in our HTTP_REQUEST_ object.  This can
     be very useful since calling off to an auto-proxy thread
     can be quite expensive in terms of performance.

Arguments:

    pProxyMsg - the object containing our current proxy message
      information, that we use to scripple our proxy state for
      a given request

    ppProxyServerInfo - on return, may contain the resultant
      cached ServerInfo object.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    CServerInfo * pOriginServer = GetOriginServer();
    CServerInfo * pProxyServer;

    INET_ASSERT(pProxyMsg);

    *ppProxyServerInfo = NULL;

    if (pOriginServer)
    {
        BOOL fCachedEntry;

        pProxyServer = 
            pOriginServer->GetCachedProxyServerInfo(            
                pProxyMsg->_tUrlProtocol,
                pProxyMsg->_nUrlPort,
                &fCachedEntry
                );

        if (fCachedEntry)
        {
            if ( pProxyServer )
            {
                if (pProxyServer->CopyCachedProxyInfoToProxyMsg(pProxyMsg))
                {
                    SetOriginServer();
                    *ppProxyServerInfo = pProxyServer;
                    error = ERROR_SUCCESS;
                    goto quit;
                }
            
                // nuke extra ref, sideeffect of GetCachedProxy... call            
                ::ReleaseServerInfo(pProxyServer);
            }  
            else
            {
                // DIRECT, no-proxy cached.
                pProxyMsg->SetUseProxy(FALSE);
                pProxyMsg->_lpszProxyHostName = NULL;
                error = ERROR_SUCCESS;
                goto quit;
            }
        }
    }

    pProxyMsg->SetVersion();

quit:
    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::ProcessProxySettings(
    IN CFsm_HttpSendRequest * Fsm,
    IN OUT URL_COMPONENTS * pUrlComponents,
    OUT LPSTR * lplpszRequestObject,
    OUT DWORD * lpdwRequestObjectSize
    )
/*++

Routine Description:

    Armed with the results of the proxy query, this method takes care of 
    assembling the various variables and states to deal with various 
    types of proxies.

    More specifally, this handles HTTP Cern Proxies, SOCKS proxies, 
    SSL-CONNECT/HTTP proxies, and special cases such as FTP URLs
    with passwords through an HTTP Cern Proxy.

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;
    CFsm_HttpSendRequest & fsm = *Fsm;

    LPSTR lpszUrlObject = NULL;
    LPSTR lpszObject = pUrlComponents->lpszUrlPath;
    DWORD dwcbObject = pUrlComponents->dwUrlPathLength;

    if ((fsm.m_pProxyInfoQuery)->GetProxyScheme() == INTERNET_SCHEME_SOCKS)
    {
        SetSocksProxyName((fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                          (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                          (fsm.m_pProxyInfoQuery)->_nProxyHostPort
                          );

        (fsm.m_pProxyInfoQuery)->_lpszProxyHostName = NULL;
        (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength = 0;
    }
    else if (pUrlComponents->nScheme == INTERNET_SCHEME_HTTPS)
    {
        SetIsTalkingToSecureServerViaProxy(TRUE);
    }
    else
    {
        SetIsTalkingToSecureServerViaProxy(FALSE); // default value.

        //
        // if this request is going via proxy then we send the entire URL as the
        // request
        //

        DWORD urlLength;

        //
        // in secure proxy tunnelling case we are going to send the request
        // "CONNECT <host>:<port>"
        //

        if (IsTunnel()) {
            urlLength = pUrlComponents->dwHostNameLength + sizeof(":65535");
        } else {
            urlLength = INTERNET_MAX_URL_LENGTH;
        }

        lpszUrlObject = (LPSTR)ResizeBuffer(NULL, urlLength, FALSE);
        if (lpszUrlObject == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        if (IsTunnel())
        {
            // When tunneling, the scheme is http for the CONNECT and the port
            // info may be stripped to 0 if the default http port was specified
            // in the original SSL tunneling URL.
            if (pUrlComponents->nPort == INTERNET_INVALID_PORT_NUMBER)
            {
                INET_ASSERT (pUrlComponents->nScheme == INTERNET_SCHEME_HTTP);
                pUrlComponents->nPort = INTERNET_DEFAULT_HTTP_PORT;
            }
            memcpy (lpszUrlObject, pUrlComponents->lpszHostName, pUrlComponents->dwHostNameLength);
            wsprintf (lpszUrlObject + pUrlComponents->dwHostNameLength, ":%d", pUrlComponents->nPort);
        }
        else
        {
            //
            // there may be a user name & password (only if FTP)
            //

            LPSTR userName;
            DWORD userNameLength;
            LPSTR password;
            DWORD passwordLength;

            userName = NULL;
            userNameLength = 0;
            password = NULL;
            passwordLength = 0;

            if (pUrlComponents->nPort == INTERNET_INVALID_PORT_NUMBER)
            {
                switch (pUrlComponents->nScheme)
                {
                    case INTERNET_SCHEME_HTTP:
                        pUrlComponents->nPort = INTERNET_DEFAULT_HTTP_PORT;
                        break;

                    case INTERNET_SCHEME_HTTPS:
                        pUrlComponents->nPort = INTERNET_DEFAULT_HTTPS_PORT;
                        break;

                    default:
                        INET_ASSERT(FALSE);
                        break;
                }
            }

            pUrlComponents->lpszUserName = userName;
            pUrlComponents->dwUserNameLength = userNameLength;
            pUrlComponents->lpszPassword = password;
            pUrlComponents->dwPasswordLength = passwordLength;

            for (int i=0; i<2; i++)
            {
                if (!WinHttpCreateUrlA(pUrlComponents, 0, lpszUrlObject, &urlLength))
                {
                    error = GetLastError();

                    if ((error == ERROR_INSUFFICIENT_BUFFER)
                        && (i==0))
                    {
                        LPSTR pTemp = (LPSTR)ResizeBuffer(lpszUrlObject,
                                                        urlLength,
                                                        FALSE);

                        if (pTemp)
                        {
                            lpszUrlObject = pTemp;
                            continue;
                        }
                        else
                        {
                            error = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    goto quit;
                }
                else
                {
                    error = ERROR_SUCCESS;
                    break;
                }
            }
            //
            // shrink the buffer to fit
            //

            lpszUrlObject = (LPSTR)ResizeBuffer(lpszUrlObject,
                                                (urlLength + 1) * sizeof(TCHAR),
                                                FALSE
                                                );

            INET_ASSERT(lpszUrlObject != NULL);

            if (lpszUrlObject == NULL)
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
        }

        SetRequestUsingProxy(TRUE);

        lpszObject = lpszUrlObject;
        dwcbObject = lstrlen(lpszUrlObject);
    }

quit:

    *lplpszRequestObject   = lpszObject;
    *lpdwRequestObjectSize = dwcbObject;

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateRequestInfo(
    IN CFsm_HttpSendRequest * Fsm,
    IN LPSTR lpszObject,
    IN DWORD dwcbObject,
    IN OUT URL_COMPONENTS * pUrlComponents,
    IN OUT CServerInfo **ppProxyServerInfo
    )

/*++

Routine Description:

    Based on object and URL information, for a given HTTP request, 
    this function assembles the "special cases" and modifes the 
    request headers in prepartion of making the actual request.

    The "special cases" includes the handling of HTTP versioning, 
    HTTP 1.0/1.1 keep-alives, and Pragma headers.

    This function also deals with the update the ServerInfo object
    that contains the host resolution information.


Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;

    LPSTR lpszVersion = NULL;
    DWORD dwVersionLen = 0;

    CFsm_HttpSendRequest & fsm = *Fsm;

    if ( lpszObject == NULL) 
    {
        lpszObject = pUrlComponents->lpszUrlPath;
        dwcbObject = pUrlComponents->dwUrlPathLength;
    }
        
    INET_ASSERT(dwcbObject > 0 );

    if (!_RequestHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if we are going via proxy and HTTP 1.1 through proxy is disabled
    // then modify the request version to HTTP/1.0
    //

    if ((fsm.m_pProxyInfoQuery)->IsUseProxy() &&        
        ((fsm.m_pProxyInfoQuery)->_lpszProxyHostName != NULL) &&
        !GlobalEnableProxyHttp1_1 || GetMethodType() == HTTP_METHOD_TYPE_CONNECT) {
        lpszVersion = "HTTP/1.0";
        dwVersionLen = sizeof("HTTP/1.0") - 1;
    }

    ModifyRequest(GetMethodType(),
                  lpszObject,
                  dwcbObject,
                  lpszVersion,
                  dwVersionLen
                  );

    if ((fsm.m_pProxyInfoQuery)->IsUseProxy() )        
    {
        SetProxyName( (fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                      (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                      (fsm.m_pProxyInfoQuery)->_nProxyHostPort
                      );

        if ((fsm.m_pProxyInfoQuery)->_lpszProxyHostName != NULL) {

            if (_ServerInfo != NULL)
            {
                _ServerInfo->SetProxyByPassed(FALSE);
            }

            //
            // changing server info from origin server to proxy server. Keep
            // pointer to origin server so that we can update connect and
            // round-trip times
            //

            SetOriginServer();

            if (*ppProxyServerInfo) {
                // cached server info
                SetServerInfo(*ppProxyServerInfo);
                *ppProxyServerInfo = NULL;
            }
            else
            {            
                error = SetServerInfo((fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                                      (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength
                                      );
                if (error != ERROR_SUCCESS) {
                    goto Cleanup;
                }
            }
        }
    }
    else
    {
        if (_ServerInfo != NULL)
        {
            _ServerInfo->SetProxyByPassed(TRUE);

            if ( pUrlComponents->lpszHostName )
            {
                error = SetServerInfo(pUrlComponents->lpszHostName,
                                      pUrlComponents->dwHostNameLength
                                      );

                if (error != ERROR_SUCCESS) {
                    goto Cleanup;
                }
            }

        }
    }

    //
    // determine whether we use persistent connections and ensure the correct
    // type and number of keep-alive headers are present
    //

    //
    // BUGBUG - we need to check for "Connection: keep-alive". There may be
    //          other types of "Connection" header, and the keep-alive header
    //          may contain additional information
    //

    DWORD bufferLength;
    DWORD index;
    DWORD dwHeaderNameIndex;

    if (IsRequestUsingProxy()) {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONNECTION);
        dwHeaderNameIndex = HTTP_QUERY_PROXY_CONNECTION;
    } else {
        RemoveAllRequestHeadersByName(HTTP_QUERY_PROXY_CONNECTION);
        dwHeaderNameIndex = HTTP_QUERY_CONNECTION;
    }

    if (IsRequestHeaderPresent(dwHeaderNameIndex)) {
        SetWantKeepAlive(TRUE);
        SetOpenFlags(
            GetOpenFlags() | INTERNET_FLAG_KEEP_CONNECTION);
    }

    error = ERROR_SUCCESS;

    //
    // if the global keep-alive switch
    // is off then we don't want any keep-alive headers
    //

    if (GlobalDisableKeepAlive)
    {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONNECTION);
        RemoveAllRequestHeadersByName(HTTP_QUERY_PROXY_CONNECTION);

        if (IsRequestHttp1_1())
        {
            //
            // Add "Connection: Close" header because we're not doing
            //  keep-alive on this Request, needed for HTTP 1.1
            //

            (void)ReplaceRequestHeader(HTTP_QUERY_CONNECTION,
                                       CLOSE_SZ,
                                       CLOSE_LEN,
                                       0,
                                       REPLACE_HEADER
                                       );
        }

        SetOpenFlags(
            GetOpenFlags() & ~INTERNET_FLAG_KEEP_CONNECTION);
    }

    //
    // if the app requested keep-alive then add the header; if we're going via
    // proxy then use the proxy-connection header
    //

    if (GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION)
    {
        SetWantKeepAlive(TRUE);
        (void)ReplaceRequestHeader(dwHeaderNameIndex,
                                   KEEP_ALIVE_SZ,
                                   KEEP_ALIVE_LEN,
                                   0,
                                   ADD_HEADER_IF_NEW
                                   );
    }

    //
    // if app added "connection: close" then we don't want keep-alive
    //

    if (IsRequestHttp1_1()) {

        BOOL bClose = FindConnCloseRequestHeader(dwHeaderNameIndex);
        BOOL bWantKeepAlive;
        DWORD dwOpenFlags = GetOpenFlags();

        if (bClose || (IsTunnel() && GetAuthState() != AUTHSTATE_CHALLENGE)) {
            RemoveAllRequestHeadersByName(dwHeaderNameIndex);

            //
            // For a Tunnel to a proxy we want to make sure that
            //  keep-alive is off since is does not make sense
            //  to do keep-alive with in a HTTP CONNECT request
            //
            // Note: we do not add the Connection: close header
            //  because of its amphorus definition in this case.
            //

            if (!IsTunnel()) {
                (void)ReplaceRequestHeader(dwHeaderNameIndex,
                                           CLOSE_SZ,
                                           CLOSE_LEN,
                                           0,
                                           REPLACE_HEADER
                                           );
            }
            bWantKeepAlive= FALSE;
            dwOpenFlags &= ~INTERNET_FLAG_KEEP_CONNECTION;
        } else {
            bWantKeepAlive = TRUE;
            dwOpenFlags |= INTERNET_FLAG_KEEP_CONNECTION;
        }
        SetWantKeepAlive(bWantKeepAlive);
        SetOpenFlags(dwOpenFlags);
    }

    if (GetOpenFlags() & WINHTTP_FLAG_BYPASS_PROXY_CACHE)
    {
        // add "Pragma: No-Cache" header
        
        ReplaceRequestHeader(HTTP_QUERY_CACHE_CONTROL,
                           NO_CACHE_SZ,
                           NO_CACHE_LEN,
                           0,   // dwIndex
                           ADD_HEADER_IF_NEW
                           );

        // add "Cache-Control: No-Cache" header for HTTP 1.1

        if (IsRequestHttp1_1())
        {
            ReplaceRequestHeader(HTTP_QUERY_PRAGMA,
                               NO_CACHE_SZ,
                               NO_CACHE_LEN,
                               0,   // dwIndex
                               ADD_HEADER_IF_NEW
                               );
        }                           
    }


Cleanup:

    _RequestHeaders.UnlockHeaders();

quit:

    return error;

}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo(
    IN CFsm_HttpSendRequest * Fsm,
    IN BOOL fCallback
    )

/*++

Routine Description:

    Queries Proxy Information, and based on the proxy info it assembles the appropriate
     HTTP request.

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo",
                 "%#x, %B",
                 Fsm,
                 fCallback
                 ));

    PERF_ENTER(UpdateProxyInfo);

    DWORD error = ERROR_SUCCESS;

    CFsm_HttpSendRequest & fsm = *Fsm;

    CServerInfo *pProxyServer = NULL;

    INTERNET_HANDLE_OBJECT * pInternet;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

    AUTO_PROXY_ASYNC_MSG proxyInfoQuery;
    URL_COMPONENTS urlComponents;

    LPSTR lpszObject = NULL;
    DWORD dwcbObject = 0;


    // once we're woken up, we own the obj stored in our FSM.
    INET_ASSERT(fsm.m_fOwnsProxyInfoQueryObj); 

    //
    // Get the Obj Pointers we care about
    //

    pInternet = GetRootHandle (this);

    //
    // Clear our handle state in regards to proxy settings
    //

    SetSocksProxyName(NULL, NULL, NULL);
    SetRequestUsingProxy(FALSE);

    //
    // Parse URL, I have to do this every time,
    //  and even worse we need to do this before our caching code
    //  gets hit, but we can't move it because the quit code
    //  depends on the parsed URL.  In the future we should cache this!!
    //

    error = BuildProxyMessage(
                Fsm,
                &proxyInfoQuery,
                &urlComponents
                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // No proxy installed on this object, bail out
    //

    if ( ((GetProxyInfo() == PROXY_INFO_DIRECT) || (!IsProxy() && ! pInternet->IsProxy())) 
        && ! IsOverrideProxyMode() )
    {
        INET_ASSERT(fsm.m_pProxyInfoQuery == NULL);
        fsm.m_pProxyInfoQuery = &proxyInfoQuery; // !!! put our local in the FSM
        goto quit;
    }

    //
    // If we're in the callback, just retrieve the results,
    //  from the orginal blocking call to proxy code
    //

    if ( fsm.m_pProxyInfoQuery )
    {            
        fCallback = TRUE;

        if ( ! (fsm.m_pProxyInfoQuery)->IsBackroundDetectionPending()) {
            (fsm.m_pProxyInfoQuery)->SetQueryOnCallback(TRUE);
        }

        error = QueryProxySettings(Fsm, pInternet, &urlComponents);
        if ( error != ERROR_SUCCESS || !(fsm.m_pProxyInfoQuery)->IsUseProxy())              
        {
            goto quit;
        }
    }
    else
    {
        fsm.m_pProxyInfoQuery = &proxyInfoQuery; // !!! put our local in the FSM
        
        proxyInfoQuery.SetBlockUntilCompletetion(TRUE);
        proxyInfoQuery.SetShowIndication(TRUE);        

        if (!IsTunnel() && !IsOverrideProxyMode())
        {
            error = QueryProxySettings(Fsm, pInternet, &urlComponents);
            if ( error != ERROR_SUCCESS || !(fsm.m_pProxyInfoQuery)->IsUseProxy()) {
                goto quit;
            }
        }
        else // fall-back
        {
            //
            // Get the current proxy information,
            //   if we're in an nested SSL tunnell
            //

            GetProxyName(&(fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                         &(fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                         &(fsm.m_pProxyInfoQuery)->_nProxyHostPort
                         );

            (fsm.m_pProxyInfoQuery)->_tProxyScheme = INTERNET_SCHEME_DEFAULT;
            (fsm.m_pProxyInfoQuery)->SetUseProxy(TRUE);
        }
    }

    //
    // Need to figure out whether we're actually talking
    //  to a Server via proxy.  In this case we need to
    //  special case some logic in the Send so we create
    //  a sub-request to the proxy-server, and then do this
    //  request to the main SSL server.
    //

    if ( (fsm.m_pProxyInfoQuery)->IsUseProxy() ) 
    {
        error = ProcessProxySettings(
                    Fsm,
                    &urlComponents,
                    &lpszObject,
                    &dwcbObject
                    );    
    }
    else
    {
        // Ensure this is false in case of very slim chance of
        // redirect from internet https to intranet http
        SetIsTalkingToSecureServerViaProxy(FALSE);
    }

quit:

    //
    // If we didn't fail with pending,
    //  go ahead and process the request headers
    //
   
    if ( error != ERROR_IO_PENDING)
    {
        if ( error == ERROR_SUCCESS ) {
            error = UpdateRequestInfo(Fsm, lpszObject, dwcbObject, &urlComponents, &pProxyServer);
        }

        //
        // Now, Unlink the proxyinfomsg struc from the fsm,
        //   if its our stack based variable that we used as a temp
        //

        if ( fsm.m_fOwnsProxyInfoQueryObj &&
             fsm.m_pProxyInfoQuery &&
             ! (fsm.m_pProxyInfoQuery)->IsAlloced() )
        {
            fsm.m_pProxyInfoQuery = NULL;
        }

    }

    //
    // Don't leak objects, Give a hoot, don't pollute !!
    //

    if ( pProxyServer != NULL )
    {
        ::ReleaseServerInfo(pProxyServer);
    }

    if ( lpszObject != NULL &&
         lpszObject != urlComponents.lpszUrlPath)
    {
        FREE_MEMORY(lpszObject);
    }

    PERF_LEAVE(UpdateProxyInfo);

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader(
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Determine if Connection: Close added to request headers

Arguments:

    dwIndex - id of Connection header to search for (Connection or
              Proxy-Connection)

Return Value:

    BOOL
        TRUE    - header found

        FALSE   - header not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader",
                 "%d [%s]",
                 dwIndex,
                 InternetMapHttpOption(dwIndex)
                 ));

    BOOL bFound = FALSE;

    if (CheckedConnCloseRequest()) {
        bFound = IsConnCloseRequest(dwIndex == HTTP_QUERY_PROXY_CONNECTION);
    } else {

        LPSTR ptr;
        DWORD len;
        DWORD index = 0;

        while (FastQueryRequestHeader(dwIndex,
                                      (LPVOID *)&ptr,
                                      &len,
                                      index) == ERROR_SUCCESS) {
            if ((len == CLOSE_LEN) && (strnicmp(ptr, CLOSE_SZ, len) == 0)) {
                bFound = TRUE;
                break;
            }
            index++;
        }
        SetCheckedConnCloseRequest(dwIndex == HTTP_QUERY_PROXY_CONNECTION, bFound);
    }

    DEBUG_LEAVE(bFound);

    return bFound;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
HTTP_REQUEST_HANDLE_OBJECT::SetTimeout(
    IN DWORD dwTimeoutOption,
    IN DWORD dwTimeoutValue
    )
{
    BOOL bRetval = TRUE;
    
    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        _dwResolveTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        _dwConnectTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_CONNECT_RETRIES:
        _dwConnectRetries = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_SEND_TIMEOUT:
        _dwSendTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        _dwReceiveTimeout = dwTimeoutValue;
        break;
        
    default:
        INET_ASSERT(FALSE);
        
        bRetval = FALSE;
        break;
    }

    return bRetval;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
DWORD
HTTP_REQUEST_HANDLE_OBJECT::GetTimeout(
    IN DWORD dwTimeoutOption
    )
{
    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        return _dwResolveTimeout;

    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        return _dwConnectTimeout;

    case WINHTTP_OPTION_CONNECT_RETRIES:
        return _dwConnectRetries;

    case WINHTTP_OPTION_SEND_TIMEOUT:
        return _dwSendTimeout;

    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        return _dwReceiveTimeout;
    }

    INET_ASSERT(FALSE);
    
    // we should not be here, but in case we are, return 0
    return 0;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
HTTP_REQUEST_HANDLE_OBJECT::SetTimeouts(
    IN DWORD        dwResolveTimeout,
    IN DWORD        dwConnectTimeout,
    IN DWORD        dwSendTimeout,
    IN DWORD        dwReceiveTimeout
    )
{
    _dwResolveTimeout = dwResolveTimeout;
    _dwConnectTimeout = dwConnectTimeout;
    _dwSendTimeout = dwSendTimeout;
    _dwReceiveTimeout = dwReceiveTimeout;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\httpcache\cachelogic.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cachelogic.cxx

Abstract:

    This file contains the implementation of the HTTPCACHE request object public interface and a few 
    miscellaneous global variables and classes

Author:

Revision History:

--*/

#include <wininetp.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"
#include "..\urlcache\hndlmgr.hxx"

#include "cachelogic.hxx"
#include "internalapi.hxx"

/////////////////////////////////////////////////////////////////////////
//
// Global variables specific to HttpCache 
//
//
/////////////////////////////////////////////////////////////////////////

#define CACHE_ENTRY_INFOEX_SIZE 1024 * 5    // we need this much to prevent buffer overrun

/////////////////////////////////////////////////////////////////////////
//
// HTTPCACHE_REQUEST Constructors and destructors
//
//
/////////////////////////////////////////////////////////////////////////

HTTPCACHE_REQUEST::HTTPCACHE_REQUEST(HINTERNET hRequest)
{
    _hRequest = hRequest;

    InternalQueryOptionA(_hRequest, WINHTTP_OPTION_CACHE_FLAGS, &_dwCacheFlags);
    InternalQueryOptionA(_hRequest, WINHTTP_OPTION_REQUEST_FLAGS, &_dwRequestFlags);
    
	_lpszFileName = NULL;
	_lpszFileExtension = NULL;
	_lpszCacheWriteLocalFilename = NULL;

    _fIsPartialCache = FALSE;
    _fCacheWriteInProgress = FALSE;
    _fDeleteWriteFile = FALSE;
    _fCacheReadInProgress = FALSE;
    _fLazyUpdate = FALSE;

    _fHasExpiry = FALSE;
    _fHasLastModTime = FALSE;
    _fHasPostCheck = FALSE;
    _fMustRevalidate = FALSE;


	_pCacheEntryInfo = (CACHE_ENTRY_INFOEX *) ALLOCATE_FIXED_MEMORY(CACHE_ENTRY_INFOEX_SIZE); 
    // Set the URL for this object
    // if you drill down to the defn of GetURL(), you'll see that it's returning
    // _CacheUrlName from the class.  This variable has NOTHING to do with the
    // caching layer.  They just have a misleading variable name there!
    DWORD dwSize = INTERNET_MAX_URL_LENGTH;
    InternetQueryOptionA(_hRequest, WINHTTP_OPTION_URL, _szUrl, &dwSize);

	// This is where _nextState is set
    _nextState = CHECK_IF_IN_CACHE;

    if (_dwCacheFlags & CACHE_FLAG_DISABLE_CACHE_READ)
        _nextState = PREPARE_DOWNLOAD_FROM_INET;
    
}


HTTPCACHE_REQUEST::~HTTPCACHE_REQUEST()
{
    // If there's a file that we're using to write to the cache,
    // but fails to commit to the cache index, then we entirely
    // get rid of the file here
    if (_fDeleteWriteFile == TRUE)
    {
        CloseHandle(_hCacheWriteFile);
        DeleteFile(_lpszCacheWriteLocalFilename);
    }
    
    if (_lpszFileName)
        FREE_MEMORY(_lpszFileName);

    if (_lpszFileExtension)
        FREE_MEMORY(_lpszFileExtension);
  
    if (_lpszCacheWriteLocalFilename)
        FREE_MEMORY(_lpszCacheWriteLocalFilename);

    if (_pCacheEntryInfo)
        FREE_MEMORY(_pCacheEntryInfo);
}


/////////////////////////////////////////////////////////////////////////
//
// HTTPCACHE_REQUEST Public interface:
//      SendRequest
//      ReceiveResponse
//      QueryDataAvailable
//      ReadData
//
// Essentially these public interfaces keep track of a state variable (_nextState)
// and manipulate the states based on the results returned from the private
// functions.
//
// It is structured so that ONLY the public interface should manipulate the state
// variables
//
// The lpszHeader and lpOptional parameters are being ignored
// by the cache, unless the cache fails (cache lookup fails or IMS request
// returns 200 OK), in which case we call the net SendRequest with
// the passed-in parameters

PUBLIC BOOL HTTPCACHE_REQUEST::SendRequest(
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength
    )

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::SendRequest",
                 NULL
                 ));

    BOOL fResult = FALSE;
	BOOL fFinish = FALSE;

    do
    {
        switch(_nextState)
        {
            case CHECK_IF_IN_CACHE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("CHECK_IF_IN_CACHE state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));
                
                fResult = OpenCacheReadStream();
                
                if (fResult)
                {
                    _fCacheReadInProgress = TRUE;
                    DEBUG_PRINT(CACHE, INFO, ("%s coming from the cache\n", GetUrl()));
                    if (IsPartialCacheEntry())
                        _nextState = ADD_PARTIAL_CONTENT_UMS_AND_RANGE_HEADER;
                    else
                        _nextState = ADD_NORMAL_CONTENT_IMS_HEADER;
                }
                else
                {
                    _fCacheReadInProgress = FALSE;
                    _nextState = PREPARE_DOWNLOAD_FROM_INET;
                }
                
                break;

            case ADD_PARTIAL_CONTENT_UMS_AND_RANGE_HEADER:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("ADD_PARTIAL_CONTENT_UMS_AND_RANGE_HEADER state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                // we don't need to check for expiry if it's a partial content
                LockPartialCacheEntry();
                AddRangeRequestHeaders();
                _nextState = SEND_REQUEST;

                break;
                    
            case ADD_NORMAL_CONTENT_IMS_HEADER:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("ADD_NORMAL_CONTENT_IMS_HEADER state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                if (_dwCacheFlags & CACHE_FLAG_ALWAYS_RESYNCHRONIZE || 
                   IsExpired() == TRUE)
                {   
                    AddIfModifiedSinceHeaders();
                    _nextState = SEND_REQUEST;
                }
                else
                {
                    _nextState = PREPARE_READ_FROM_CACHE;
                }
                
                break;

            case SEND_REQUEST:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("SEND_REQUEST state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                DWORD dwStatusCode;
                DWORD dwAction;
                 
                fResult = TransmitRequest(&dwStatusCode);
                if (fResult)
                {
                    CheckResponseAfterIMS(dwStatusCode);

                    // If I get a 304 back, then it means it's not modified, and I can grab it
                    // from the cache
                    if (dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
                        _nextState = PREPARE_READ_FROM_CACHE;
                        
                    // If I get back a 200 then I can start reading data from the net;
                    // but I don't have to do a SendRequets again caz it's already done in
                    // the Transmit request call
                    else if (dwStatusCode == HTTP_STATUS_OK)
                        _nextState = PREPARE_READ_FROM_INET_AFTER_200_RESPONSE;

                    // If we get a 206, then do the partial read
                    else if (dwStatusCode == HTTP_STATUS_PARTIAL_CONTENT &&
                           _pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY) 
                        _nextState = PARTIAL_READ;

                    // Otherwise, I'll have to clear all the headers, reset the request object
                    // and redo the full SendRequest again (CACHE_SEND_ERROR state)
                }
                else
                {
                    _nextState = CACHE_SEND_ERROR;
                }

                break;

            case PARTIAL_READ:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PARTIAL_READ state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                fResult = FakePartialCacheResponseHeaders();
                                
                _nextState = PREPARE_READ_FROM_CACHE;
                fFinish = TRUE;
                break;
                
            case PREPARE_READ_FROM_CACHE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PREPARE_READ_FROM_CACHE state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                // If the request can be satisifed by the cache, we complete the SendRequest
                // transaction by recovering the response headers from the cache so that the
                // user is not aware that the content is coming from the cache
                FakeCacheResponseHeaders();
                fResult = TRUE;
                fFinish = TRUE;
                break;

            case PREPARE_READ_FROM_INET_AFTER_200_RESPONSE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PREPARE_READ_FROM_INET_AFTER_200_RESPONSE state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                if (IsPartialCacheEntry())
                    DeletePartialCacheFile();

                CloseCacheReadStream();

                _nextState = PREPARE_DOWNLOAD_FROM_INET;
                fFinish = TRUE;
                break;
                
            // somehow adding the request header fails, so we fall back to downloading from inet
            case CACHE_SEND_ERROR:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("CACHE_SEND_ERROR state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                if (IsPartialCacheEntry())
                    DeletePartialCacheFile();

                CloseCacheReadStream();

                // Reset the request handle object (clear any previous request headers, etc...)
                // so it can be used to send new requests again
                InternalReuseHTTP_Request_Handle_Object(_hRequest);

                _nextState = PREPARE_DOWNLOAD_FROM_INET;
                break;
                
            case PREPARE_DOWNLOAD_FROM_INET:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PREPARE_DOWNLOAD_FROM_INET state in HTTPCACHE_REQUEST::SendRequest\n"
                             ));

                fResult = WinHttpSendRequest(
                            _hRequest, 
                            lpszHeaders,
                            dwHeadersLength,
                            lpOptional,
                            dwOptionalLength,
                            0, 
                            0);
                
                fFinish = TRUE;
                break;

            default:
                fResult = FALSE;
                fFinish = TRUE;
                break;
        }
    } while (!fFinish);

    DEBUG_LEAVE(fResult);
    return fResult;
}

PUBLIC BOOL HTTPCACHE_REQUEST::ReceiveResponse(LPVOID lpBuffersOut)
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::ReceiveResponse",
                 NULL
                 ));
    BOOL fResult = FALSE;

    switch (_nextState)
    {
        case PREPARE_READ_FROM_CACHE:
            _nextState = BEGIN_CACHE_READ;    
            fResult = TRUE;
            break;

        case PREPARE_DOWNLOAD_FROM_INET:
            _nextState = BEGIN_DOWNLOAD_FROM_INET;
            fResult = WinHttpReceiveResponse(_hRequest, lpBuffersOut);
            break;
        default:
            fResult = FALSE;
            break;
    }

    DEBUG_LEAVE(fResult);
    return fResult;    
}

PUBLIC BOOL HTTPCACHE_REQUEST::QueryDataAvailable(LPDWORD lpdwNumberOfBytesAvailable) 
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::QueryDataAvailable",
                 NULL
                 ));

    BOOL fResult = FALSE;
    switch (_nextState)
    {
        case END_CACHE_READ:
        case END_READ_DATA:
            *lpdwNumberOfBytesAvailable = 0;
            fResult = TRUE;
            break;

        case BEGIN_CACHE_READ:
            // We assume that the cached file size is less than 4 GB (= 2^32).  If the cached file is 
            // really that big we might as well not cache it
            *lpdwNumberOfBytesAvailable = _pCacheEntryInfo->dwSizeLow;
            fResult = TRUE;
            break;

        case DOWNLOAD_FROM_INET_WITH_CACHE_WRITE:  
        case DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE:
        case BEGIN_DOWNLOAD_FROM_INET:
            fResult = WinHttpQueryDataAvailable(_hRequest, lpdwNumberOfBytesAvailable);
            break;
 
        default:
            break;
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}

PUBLIC BOOL HTTPCACHE_REQUEST::ReadData(LPVOID lpBuffer, 
                                            DWORD dwNumberOfBytesToRead,
                                            LPDWORD lpdwNumberOfBytesRead)
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::ReadData",
                 NULL
                 ));

    BOOL fFinish = FALSE;        
    BOOL fResult = FALSE;
    do
    {
        switch (_nextState)
        {
            case BEGIN_CACHE_READ:
                DEBUG_PRINT(CACHE, 
                             INFO,
                             ("BEGIN_CACHE_READ state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                fResult = ReadDataFromCache(lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
                if (fResult == FALSE)
                    _nextState = BEGIN_DOWNLOAD_FROM_INET;
                else if (*lpdwNumberOfBytesRead == 0)
                {
                    _nextState = END_CACHE_READ;
                }
                else
                {
                    _nextState = BEGIN_CACHE_READ;      // just to be more clear
                    fFinish = TRUE;
                }                
                break;
                
            case BEGIN_DOWNLOAD_FROM_INET:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("BEGIN_DOWNLOAD_FROM_INET state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                if (_dwCacheFlags & CACHE_FLAG_DISABLE_CACHE_WRITE)
                    _nextState = DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE;
                else
                    _nextState = PREP_FOR_CACHE_WRITE;

                if (GetScheme() == INTERNET_SCHEME_HTTPS && 
                   _dwCacheFlags & CACHE_FLAG_DISABLE_SSL_CACHING)
                {
                    _nextState = DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE;  // SetPerUserItem(TRUE) ??;
                }

                break;

            case DOWNLOAD_FROM_INET_WITH_CACHE_WRITE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("DOWNLOAD_FROM_INET_WITH_CACHE_WRITE state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                fResult = WinHttpReadData(_hRequest, 
                                         lpBuffer, 
                                         dwNumberOfBytesToRead, 
                                         lpdwNumberOfBytesRead);
                if (fResult)
                    _nextState = WRITE_TO_CACHE_ENTRY;
                else
                {
                    _nextState = COMMIT_PARTIAL_CACHE_ENTRY;
                    fFinish = TRUE;
                }
                break;

            case DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                fResult = WinHttpReadData(_hRequest, 
                                         lpBuffer, 
                                         dwNumberOfBytesToRead, 
                                         lpdwNumberOfBytesRead);
                fFinish = TRUE;
                break;
                
            case PREP_FOR_CACHE_WRITE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("PREP_FOR_CACHE_WRITE state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                INET_ASSERT((_dwCacheFlags & CACHE_FLAG_DISABLE_CACHE_WRITE) == FALSE);
                BOOL fNoCache;
                
                if (FCanWriteHTTP1_1ResponseToCache(&fNoCache))
                {
                
                    // fNoCache indicates that a cache-control: no-store
                    // or cache-control: no-cache is present, so we need
                    // to make sure that the cache does not keep any
                    // previous copies of the file as well
                    if (fNoCache)        
                        DeleteUrlCacheEntryA(GetUrl());

                    SetFilenameAndExtForCacheWrite();
                    _RealCacheFileSize = 0;
                    
                    if (CreateCacheWriteFile())
                    {
                        _fCacheWriteInProgress = TRUE;
                        _nextState = DOWNLOAD_FROM_INET_WITH_CACHE_WRITE;
                    }
                    else
                    {    
                        _nextState = DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE;
                    }
                }    
                else
                {
                    _nextState = DOWNLOAD_FROM_INET_WITHOUT_CACHE_WRITE;
                }
                break;

            case WRITE_TO_CACHE_ENTRY:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("WRITE_TO_CACHE_ENTRY state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                if (*lpdwNumberOfBytesRead == 0)
                    _nextState = END_CACHE_WRITE;
                else
                {
                    if ((fResult = WriteToCacheFile((LPBYTE) lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead)) == TRUE)
                    {
                        _nextState = DOWNLOAD_FROM_INET_WITH_CACHE_WRITE;
                        fFinish = TRUE;
                    }
                    else
                    {
                        _nextState = COMMIT_PARTIAL_CACHE_ENTRY;
                    }
                }
                break;

            case COMMIT_PARTIAL_CACHE_ENTRY:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("COMMIT_PARTIAL_CACHE_ENTRY state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                if (!CommitCacheFileEntry(FALSE))
                    // The partial entry cannot be committed to the cache, so let's
                    // delete it in the destructor so it'll not become a stale entry
                    _fDeleteWriteFile = TRUE;
                else
                    _fDeleteWriteFile = FALSE;

                _fCacheWriteInProgress = FALSE; 
                _nextState = END_READ_DATA;
                fResult = TRUE;
                fFinish = TRUE;
                break;
                
            case END_CACHE_WRITE:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("END_CACHE_WRITE state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                if (!CommitCacheFileEntry(TRUE))
                    // The file cannot be committed to the cache, so let's
                    // delete it in the destructor so it'll not become a stale entry
                    _fDeleteWriteFile = TRUE;
                else
                    _fDeleteWriteFile = FALSE;

                _fCacheWriteInProgress = FALSE; 
                _nextState = END_READ_DATA;
                fResult = TRUE;
                fFinish = TRUE;
                break;

            case END_CACHE_READ:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("END_CACHE_READ state in HTTPCACHE_REQUEST::ReadData\n"
                             ));

                // Close the cache read file handle
                CloseCacheReadStream();
                _fCacheReadInProgress = FALSE;
                if (_fIsPartialCache == TRUE)
                {
                    _nextState = BEGIN_DOWNLOAD_FROM_INET;
                    _fIsPartialCache = FALSE;
                }
                else
                    _nextState = END_READ_DATA;

                fResult = TRUE;
                fFinish = TRUE;
                break;


            case END_READ_DATA:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("END_READ_DATA state\n in HTTPCACHE_REQUEST::ReadData"
                             ));

                lpBuffer = (LPVOID)'\0';
                *lpdwNumberOfBytesRead = 0;
                fResult = TRUE;
                fFinish = TRUE;
                break;

            // If we ever got here, we REALLY SHOULD PANIC!!  Fix this later
            default:
                DEBUG_PRINT(CACHE, 
                             INFO, 
                             ("HTTPCACHE_REQUEST::ReadData FSM is in bogus state\n"
                             ));

                fResult = WinHttpReadData(_hRequest, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
                fFinish = TRUE;
                break;
                
        }
    } while (!fFinish);

    // Before you exit this loop, make sure you set fResult to the intended value
    DEBUG_LEAVE(fResult);
    return fResult;
}

PUBLIC BOOL HTTPCACHE_REQUEST::CloseRequestHandle()
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::CloseHandle",
                 NULL
                 ));

    BOOL fResult = FALSE;
    switch (_nextState)
    {            
        case DOWNLOAD_FROM_INET_WITH_CACHE_WRITE:
            // The idea here is that if the user calls WinHttpCloseHandle
            // before the full content has been downloaded, then we
            // should try to commit it as a partial entry for later retrieval
            
            if (!CommitCacheFileEntry(FALSE))
                // The file cannot be committed to the cache, so let's
                // delete it in the destructor so it'll not become a stale entry
                _fDeleteWriteFile = TRUE;
            else
                _fDeleteWriteFile = FALSE;

            _fCacheWriteInProgress = FALSE; 
            
            // intentional fall through;
            
        case END_READ_DATA:
        default:
            fResult = WinHttpCloseHandle(_hRequest);
            break;

    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


////////////////////////////////////////////////////////////////////////
//
// Miscelleneous utility functions
//
//
//


/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokExA (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

#define EXE_EXTENSION   TEXT(".exe")
#define DLL_EXTENSION   TEXT(".dll")
#define CGI_EXTENSION   TEXT(".cgi")

LPSTR GetFileExtensionFromUrl(
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwLength)
/*++

Routine Description:
    This routine returns a possible file extension from a URL
    It does this by walking back from the end till the first  dot.

Arguments:

    lpszUrl         Url to derive the extension from

    lpdwLength      max length of the extension expected

Returns:

    NULL if no dot within the passed in length or a forward slash or a
    backward slash encountered before the dot. Otherwise returns a pointer
    pointing past the dot in the url string

Comments:

--*/
{
    const char  vszInvalidFilenameChars[] = "<>\\\"/:|?*";

    INET_ASSERT(lpszUrl && lpdwLength);

    if (!lpszUrl)
    {
        *lpdwLength = 0;
        return NULL;
    }

    LPSTR pszPeriod = NULL;
    BOOL fContinue = TRUE;

    // Scanning from left to right, note where we last saw a period.
    // If we see a character that cannot be in an extension, and we've seen a period, forget
    // about the period.
    // Repeat this until we've reached the end of the url, a question mark (query) or hash (fragment)

    // 1.6.98: _However_, if the file extension we've discovered is either .dll or .exe, 
    //         we'll continue to scan beyond the query mark for a file extension.

    // 1.20.98: And if we find no extension before the question mark, we'll look after it, then.
    
    while (fContinue)
    {
        switch (*lpszUrl)
        {
        case TEXT('.'):
            pszPeriod = lpszUrl;
            break;

        case TEXT('?'):
            if (pszPeriod)
            {
                if ((!StrCmpNI(pszPeriod, EXE_EXTENSION, ARRAY_ELEMENTS(EXE_EXTENSION)-1))
                    || (!StrCmpNI(pszPeriod, DLL_EXTENSION, ARRAY_ELEMENTS(DLL_EXTENSION)-1))
                    || (!StrCmpNI(pszPeriod, CGI_EXTENSION, ARRAY_ELEMENTS(CGI_EXTENSION)-1)))
                {
                    pszPeriod = NULL;
                    break;
                }
            }
            else
            {
                break;
            }
            
        case TEXT('#'):
        case TEXT('\0'):
            fContinue = FALSE;
            break;

        default:
            if (pszPeriod && strchr(vszInvalidFilenameChars, *lpszUrl))
            {
                pszPeriod = NULL;
            }        
        }
        lpszUrl++;
    }
    // This will be off by one
    lpszUrl--;
    if (pszPeriod)
    {
        if (*lpdwLength < (DWORD)(lpszUrl-pszPeriod))
        {
            pszPeriod = NULL;
        }
        else
        {
            pszPeriod++;
            *lpdwLength = (DWORD)(lpszUrl-pszPeriod);
        }
    }
    return pszPeriod;
}

// This function and the #define should be moved to registry.cxx

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

PRIVATE BOOL GetFileExtensionFromMimeType(
    LPCSTR  lpszMimeType,
    DWORD   dwMimeLen,
    LPSTR   lpszFileExtension,
    LPDWORD lpdwExtLen
    )
{
    HKEY    hKey = NULL;
    LPSTR   lpszMimeKey = (LPSTR)_alloca(sizeof(MIME_TO_FILE_EXTENSION_KEY)+dwMimeLen);

    memcpy(lpszMimeKey, MIME_TO_FILE_EXTENSION_KEY,
            sizeof(MIME_TO_FILE_EXTENSION_KEY)-1);
    memcpy(lpszMimeKey + sizeof(MIME_TO_FILE_EXTENSION_KEY) - 1, lpszMimeType,
            dwMimeLen);
    lpszMimeKey[sizeof(MIME_TO_FILE_EXTENSION_KEY) + dwMimeLen - 1] = '\0';

    if (REGOPENKEYEX(HKEY_CLASSES_ROOT,
                               lpszMimeKey,
                               0,
                               KEY_QUERY_VALUE,
                               &hKey)==ERROR_SUCCESS)
    {
        DWORD dwType, dwError = RegQueryValueEx(hKey,
                                EXTENSION_VALUE,
                                NULL,
                                &dwType,
                                (LPBYTE)lpszFileExtension,
                                lpdwExtLen);
        REGCLOSEKEY(hKey);
        return (dwError==ERROR_SUCCESS);
    }
    return FALSE;
}

PRIVATE BOOL FExcludedMimeType(
    IN LPSTR lpszMimeType,
    IN DWORD dwMimeTypeSize
    )
{
    LPCSTR rgszExcludedMimeTypes[] = {
        "multipart/mixed",
        "multipart/x-mixed-replace",
        "multipart/x-byteranges"
    };

    const DWORD rgdwExcludedMimeTypeSizes[] = {
        sizeof("multipart/mixed") - 1,
        sizeof("multipart/x-mixed-replace") - 1,
        sizeof("multipart/x-byteranges") - 1
    };


    DWORD i;
    LPCSTR * lprgszMimeExcludeTable = rgszExcludedMimeTypes;
    DWORD dwMimeExcludeCount = (sizeof(rgszExcludedMimeTypes)/sizeof(LPSTR));
    const DWORD *lprgdwMimeExcludeTableOfSizes = rgdwExcludedMimeTypeSizes;

    for (i = 0; i < dwMimeExcludeCount; ++i) {
        if ((dwMimeTypeSize == lprgdwMimeExcludeTableOfSizes[i]) &&
            !strnicmp(lpszMimeType,
                      lprgszMimeExcludeTable[i],
                      lprgdwMimeExcludeTableOfSizes[i])) {

            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\httpcache\cacheread.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cacheread.cxx

Abstract:

    This file contains the implementation of the HTTPCACHE request object which involve reading from the cache

Author:

Revision History:

--*/

#include <wininetp.h>
#include <string.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"

#include "cachelogic.hxx"
#include "internalapi.hxx"
#include "..\http\proc.h"

extern const struct KnownHeaderType GlobalKnownHeaders[];

DWORD
UrlCacheRetrieve
(
    IN  LPSTR                pszUrl,
    IN  BOOL                 fRedir,
    OUT HANDLE*              phStream,
    OUT CACHE_ENTRY_INFOEX** ppCEI
);

#define ONE_HOUR_DELTA  (60 * 60 * (LONGLONG)10000000)


////////////////////////////////////////////////////////////////////////////////
//
// Cache read related private functions:
//
//      EndCacheRead
//      ReadDataFromCache
//      SendIMSRequest
//      CheckIfInCache
//      CheckIsExpired
//      AddIfModifiedSinceAndETag
//      CheckResponseAfterIMS
//
//

PRIVATE PRIVATE VOID HTTPCACHE_REQUEST::ResetCacheReadVariables()
/*++

Routine Description:

    Should be call to reset all variables related to cache read for new requests

Return Value: 

    NONE
    
--*/
{
    _hCacheReadStream = NULL;
    _dwCurrentStreamPosition = 0;
}

PRIVATE BOOL HTTPCACHE_REQUEST::CloseCacheReadStream(VOID)
/*++

Routine Description:

    Close the cache read stream to fully complete the cache read operation.    

Pre-condition:

    OpenCacheReadStream() returns TRUE
    
Side Effects:  

    _hCacheReadStream = NULL;
    _dwCurrentStreamPosition = 0;

Return Value: 

    BOOL indicating whether the call is successful or not
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::CloseCacheReadStream",
                 NULL
                 ));

    BOOL fResult = FALSE;

    if (_fIsPartialCache == TRUE)
        return TRUE;
    
    INET_ASSERT(_hCacheReadStream != NULL);

    if (UnlockUrlCacheEntryStream(_hCacheReadStream, 0))
    {
        // reinitializes the variables so the new requests won't screw up
        fResult = TRUE;
        ResetCacheReadVariables();
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


PRIVATE BOOL HTTPCACHE_REQUEST::ReadDataFromCache(
                                    LPVOID lpBuffer,
                                    DWORD dwNumberOfBytesToRead,
                                    LPDWORD lpdwNumberOfBytesRead
                                    )
/*++

Routine Description:

    Try to read dwNumberOfBytesToRead bytes of data from the current file pointer for the
    cache entry, and return the data to lpBuffer.  Also return the actual number of bytes
    read to lpdwNumberOfBytesRead

    Similar to HTTP_REQUEST_HANDLE_OBJECT::AttemptReadFromFile in Wininet
    
Parameters:

Precondition:

    OpenCacheReadStream() returns TRUE before is function is being called
    
Side Effects:  

    NONE

Return Value: 

    BOOL indicating whether the call is successful or not
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::ReadDataFromCache",
                 NULL
                 ));

    BOOL fSuccess;
    DWORD dwBytesToCopy = 0;

    if (!dwNumberOfBytesToRead)
    {
        *lpdwNumberOfBytesRead = 0;
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    if (_fCacheReadInProgress && !_fIsPartialCache)
    {
        // INET_ASSERT(_VirtualCacheFileSize == _RealCacheFileSize);

        // Entire read should be satisfied from cache.
        *lpdwNumberOfBytesRead = dwNumberOfBytesToRead;

        if (ReadUrlCacheEntryStream(_hCacheReadStream, 
                                    _dwCurrentStreamPosition, 
                                    lpBuffer, 
                                    lpdwNumberOfBytesRead, 
                                    0))
        {
            _dwCurrentStreamPosition += *lpdwNumberOfBytesRead;
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
        else
        {
            *lpdwNumberOfBytesRead = 0;
            DEBUG_PRINT(CACHE, ERROR, ("Error in ReadUrlCacheEntryStream: _hCacheReadStream=%d, _dwCurrentStreamPosition=%d\n",
                            _hCacheReadStream, _dwCurrentStreamPosition));
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
    }

    else if (_fCacheWriteInProgress || _fCacheReadInProgress && _fIsPartialCache)
    {
        // See if the read is completely within the file.
        if (_dwCurrentStreamPosition + *lpdwNumberOfBytesRead > _VirtualCacheFileSize) // && !IsEndOfFile()   ??
        {

            DEBUG_PRINT(CACHE, ERROR, ("Error: Current streampos=%d cbToRead=%d, _VirtualCacheFileSize=%d\n",
                            _dwCurrentStreamPosition, *lpdwNumberOfBytesRead, _VirtualCacheFileSize));

            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        INET_ASSERT((_lpszCacheWriteLocalFilename != NULL) || _fIsPartialCache);

        if (_fIsPartialCache)
        {
            _lpszCacheWriteLocalFilename = NewString(_pCacheEntryInfo->lpszLocalFileName);

            INET_ASSERT(_lpszCacheWriteLocalFilename);
        }
        
        HANDLE hfRead;
        hfRead = CreateFile(_lpszCacheWriteLocalFilename, 
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE, 
                          NULL, 
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, 
                          NULL);

        if (hfRead == INVALID_HANDLE_VALUE) 
        {
            DEBUG_PRINT(CACHE, ERROR, ("CreateFile failed:  Local filename = %s", _lpszCacheWriteLocalFilename));
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        // Read the data from the file.
        SetFilePointer (hfRead, _dwCurrentStreamPosition, NULL, FILE_BEGIN);
        fSuccess = ReadFile (hfRead, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead, NULL);
        if (fSuccess)
            _dwCurrentStreamPosition += *lpdwNumberOfBytesRead;

        CloseHandle(hfRead);
        
        return fSuccess;
        
    }
    else
    {
        DEBUG_PRINT(CACHE, ERROR, ("Error: unexpected program path.  (possibly uninitalized variables?)\n"));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
}

PRIVATE VOID HTTPCACHE_REQUEST::CheckResponseAfterIMS(DWORD dwStatusCode)
/*++

Routine Description:

    We get back the response after sending a IMS request.  This routine finds out
    if the content is modified (in which case we have to go to the net again), not
    modfied (in which case we can grab it from the cache), or whether it's a 
    partial cache entry (it which case we follow the partial cache logic in partial.cxx)

    Similar to HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePostNetIO in wininet
    
Parameters:

    dwStatusCode - the HTTP response status code sent back from the server after the IMS request
    
Precondition:

    TransmitRequest() (conditional send request) has been called
    
Side Effects:  

    NONE
    
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 None,
                 "HTTPCACHE_REQUEST::CheckResponseAfterIMS",
                 "%d",
                 dwStatusCode
                 ));

    // Assume that a conditional send request has already been called and response returned back.    
    INET_ASSERT((dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
                || (dwStatusCode == HTTP_STATUS_PRECOND_FAILED)
                || (dwStatusCode == HTTP_STATUS_OK)
                || (dwStatusCode == HTTP_STATUS_PARTIAL_CONTENT)
                || (dwStatusCode == 0));

    // Extract the time stamps from the HTTP headers
    CalculateTimeStampsForCache();

    // TODO:  fVariation??

    // We get a 304 (if-modified-since was not modified), then use the entry from the cache
    // Optimization:  When the return status is OK and the server sent us a last modified time
    // that is exactly the same as what's in the cache entry, then we follow the same behavior 
    // as a 304
    if ((dwStatusCode == HTTP_STATUS_NOT_MODIFIED) ||        
       ((_fHasLastModTime) && (FT2LL(_ftLastModTime) == FT2LL(_pCacheEntryInfo->LastModifiedTime))))
    {
        DWORD dwAction = CACHE_ENTRY_SYNCTIME_FC;

        if (_fHasExpiry)
        {
            (_pCacheEntryInfo->ExpireTime).dwLowDateTime = _ftExpiryTime.dwLowDateTime;
            (_pCacheEntryInfo->ExpireTime).dwHighDateTime = _ftExpiryTime.dwHighDateTime;
            dwAction |= CACHE_ENTRY_EXPTIME_FC;
        }

        // update the cache entry type if needed
        DWORD dwType;
        dwType = _pCacheEntryInfo->CacheEntryType;
        if (dwType)
            _pCacheEntryInfo->CacheEntryType |= dwType;
        dwAction |= CACHE_ENTRY_TYPE_FC;

        // Update the last sync time to the current time
        // so we can do once_per_session logic
        if (!SetUrlCacheEntryInfoA(_pCacheEntryInfo->lpszSourceUrlName, _pCacheEntryInfo, dwAction))
        {
            // NB if this call fails, the worst that could happen is
            // that next time around we will do an if-modified-since
            // again
            INET_ASSERT(FALSE);
        }

    }
    
    DEBUG_LEAVE(0);
}

PRIVATE BOOL HTTPCACHE_REQUEST::TransmitRequest(IN OUT DWORD * pdwStatusCode)
/*++

Routine Description:

    A call to WinHttpSendRequest.  Use this call to send a I-M-S or a 
    U-M-S request

Parameter

    pdwStatusCode - returns the status code of the Send request
    
Return Value: 

    BOOL - whether the call is successful
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::TransmitRequest",
                 NULL
                 ));

    DWORD dwSize = sizeof(DWORD);
    BOOL fResult;
    
    // Someone will get here only if they're calling WinHttpSendRequest()
    // and is using the cache, so...
    INET_ASSERT(_hRequest);

    // resend the HTTP request
    WinHttpSendRequest(_hRequest, NULL, 0, NULL, 0, 0, 0);
    WinHttpReceiveResponse(_hRequest, NULL);

    // Examine what HTTP status code I get back after the send request
    fResult = WinHttpQueryHeaders(_hRequest, 
                            WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                            NULL, 
                            pdwStatusCode, 
                            &dwSize, 
                            NULL);

    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE BOOL HTTPCACHE_REQUEST::FakeCacheResponseHeaders()
/*++

Routine Description:

    If a resource is coming from the cache, sets the HTTP Response Headers
    so that users apps calling WinHttpQueryHeaders get the right behaviours.

    Basically this function is the HTTP_REQUEST_HEADER::FHttpBeginCacheRetreival,
    AddTimestampsForCacheToResponseHeaders(), and AddTimeHeader() from
    from wininet all packed together
    
Precondition:

    The GET request content can be fulfilled by the cache
    
Return Value: 

    BOOL
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::FakeCacheResponseHeaders",
                 NULL
                 ));

    LPSTR lpHeaders = NULL;
    DWORD dwError = ERROR_INVALID_PARAMETER;
    TCHAR szBuf[128];
    BOOL fResult = FALSE;
    
    // DO we need to warp this call by a _ResponseHeader.LockHeader() and
    // UnlockHeader() pair??
    
    // allocate buffer for headers
    lpHeaders = (LPSTR)ALLOCATE_FIXED_MEMORY(_pCacheEntryInfo->dwHeaderInfoSize+512);
    if (!lpHeaders)
        goto quit;

    memcpy(lpHeaders, _pCacheEntryInfo->lpHeaderInfo, _pCacheEntryInfo->dwHeaderInfoSize);

    InternalReuseHTTP_Request_Handle_Object(_hRequest);

    dwError = InternalCreateResponseHeaders(_hRequest, &lpHeaders, _pCacheEntryInfo->dwHeaderInfoSize);

    if (dwError == ERROR_SUCCESS)
    {
        if (AddTimeResponseHeader(_pCacheEntryInfo->LastModifiedTime, WINHTTP_QUERY_LAST_MODIFIED))
        {
            if (AddTimeResponseHeader(_pCacheEntryInfo->ExpireTime, WINHTTP_QUERY_EXPIRES))
            {    
                fResult = TRUE;
            }
         }
     }

quit:
    if (lpHeaders)
        FREE_MEMORY(lpHeaders);

    DEBUG_LEAVE(fResult);
    return (fResult);
    
}

PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::AddTimeResponseHeader(
    IN FILETIME fTime,
    IN DWORD dwQueryIndex
    )
/*++

Routine Description:

    Add a response header that has a time-related value.
    
    Used mainly as a helper function for FakeCacheResponseHeaders to add 
    time-related response headers

Parameters:

    fTime - Time in FILTIME format
    dwQueryIndex - the type of response header to add
    
Return Value: 

    BOOL
    
--*/    
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::AddTimeResponseHeader",
                 "%#x:%#x, %d",
                 fTime.dwLowDateTime,
                 fTime.dwHighDateTime,
                 dwQueryIndex
                 ));

    BOOL fResult = FALSE;
    SYSTEMTIME systemTime;
    DWORD dwLen;
    TCHAR szBuf[64];
    
    if (FT2LL(fTime) != LONGLONG_ZERO) 
    {
        if (FileTimeToSystemTime((CONST FILETIME *)&fTime, &systemTime)) 
        {
            if (InternetTimeFromSystemTimeA((CONST SYSTEMTIME *)&systemTime,
                                              szBuf)) 
            {
                fResult = (ERROR_SUCCESS == InternalReplaceResponseHeader(
                                                    _hRequest,
                                                    dwQueryIndex,
                                                    szBuf,
                                                    strlen(szBuf),
                                                    0,
                                                    WINHTTP_ADDREQ_FLAG_ADD_IF_NEW
                                                    ));
                                                    
                                               
            } 
        }
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


PRIVATE BOOL HTTPCACHE_REQUEST::OpenCacheReadStream()
/*++

Routine Description:

    Determines if the URL entry of this object is already in the cache, and
    if so, open up the cache read file stream so that cache retrieval
    can be done.
    
Return Value: 

    BOOL
    
--*/
    
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::OpenCacheReadStream",
                 NULL
                 ));

    BOOL fResult = FALSE;
    LPSTR lpszUrl;
    HANDLE hReadStream;
    
    lpszUrl = GetUrl();
    
    // look up URL from the cache and if found, get the handle to the cache objects
    // We DO NOT take redirection into account.  Redirection is handled at a higher layer 
    if (UrlCacheRetrieve(lpszUrl, FALSE, &hReadStream, &_pCacheEntryInfo) == ERROR_SUCCESS)
    {
        DEBUG_PRINT (CACHE, INFO, ("%s found in the cache!!  Local filename: %s\n", lpszUrl, _pCacheEntryInfo->lpszLocalFileName));

        // Note that if this is a partial entry, then _hCacheReadStream will be set
        // to NULL.  But at this point we don't check whether this is a partial
        // entry or not
        ResetCacheReadVariables();
        _hCacheReadStream = hReadStream;
        
        fResult = TRUE;
    }
    else
        _hCacheReadStream = NULL;
    
    DEBUG_LEAVE(fResult);
    return fResult;
}

// --- from wininet\http\cache.cxx
/*============================================================================
IsExpired (...)

4/17/00 (RajeevD) Corrected back arrow behavior and wrote detailed comment.
 
We have a cache entry for the URL.  This routine determines whether we should
synchronize, i.e. do an if-modified-since request.  This answer depends on 3
factors: navigation mode, expiry on cache entry if any, and syncmode setting.

1. There are two navigation modes:
a. hyperlinking - clicking on a link, typing a URL, starting browser etc.
b. back/forward - using the back or forward buttons in the browser.

In b/f case we generally want to display what was previously shown.  Ideally
wininet would cache multiple versions of a given URL and trident would specify
which one to use when hitting back arrow.  For now, the best we can do is use
the latest (only) cache entry or resync with the server.

EXCEPTION: if the cache entry sets http/1.1 cache-control: must-revalidate,
we treat as if we were always hyperlinking to the cache entry.  This is 
normally used during offline mode to suppress using a cache entry after
expiry.  This overloaded usage gives sites a workaround if they dislike our
new back button behavior.

2. Expiry may fall into one of 3 buckets:
a. no expiry information
b. expiry in past of current time (hyperlink) or last-access time (back/fwd)
c. expiry in future of current time (hyperlink) or-last access time (back/fwd)

3. Syncmode may have 3 settings
a. always - err on side of freshest data at expense of net perf.
b. never - err on side of best net perf at expense of stale data.
c. once-per-session - middle-of-the-road setting
d. automatic - slight variation of once-per-session where we decay frequency
of i-m-s for images that appear to be static.  This is the default.

Based on these factors, there are 5 possible result values in matrices below:
1   synchronize
0   don't synchronize
?   synchronize if last-sync time was before start of the current session, 
?-  Like per-session except if URL is marked static and has a delay interval.
0+  Don't sync if URL is marked static, else fall back to per-session


HYPERLINKING

When hyperlinking, expiry takes precedence, then we look at syncmode.

                No Expiry       Expiry in Future    Expiry in Past
Syncmode                        of Current Time     of Current Time
                               
   Always           1                   0                   1  


   Never            0                   0                   1


   Per-Session      ?                   0                   1


   Automatic        ?-                  0                   1

   
BACK/FORWARD

When going back or forward, we generally don't sync.  The exception is if
we should have sync'ed the URL on the previous navigate but didn't.  We
deduce this by looking at the last-sync time of the entry.


                No Expiry       Expiry in Future    Expiry in Past
Syncmode                        of Last-Access Time of Last-Access Time
    
   Always           ?                   0                   ?


   Never            0                   0                   ?


   Per-Session      ?                   0                   ?


   Automatic        0+                  0                   ?


When considering what might have happened when hyperlinking to this URL,
the decision tree has 5 outcomes:
1. We might have had no cache entry and downloaded to cache for the first time
2. Else we might have had a cache entry and used it w/o i-m-s
3. Else we did i-m-s but the download was aborted
4. Or the i-m-s returned not modified
5. Or the i-m-s returned new content
Only in case 3 do we want to resync the cache entry.

============================================================================*/

PRIVATE BOOL HTTPCACHE_REQUEST::IsExpired ()
/*++

Routine Description:

    Determines whether the current cache entry is expired.  If it's 
    expired then we need to synchronize (i.e. do a i-m-s request)

Parameters:

    NONE
    
Side Effects:  

    _fLazyUpdate

Return Value: 

    BOOL
    
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::IsExpired",
                 NULL
                 ));

    BOOL fExpired;
    FILETIME ftCurrentTime;
    GetCurrentGmtTime (&ftCurrentTime);

    if ((_dwCacheFlags & CACHE_FLAG_FWD_BACK)
        && !(_pCacheEntryInfo->CacheEntryType & MUST_REVALIDATE_CACHE_ENTRY))
    {
        // BACK/FORWARD CASE

        if (FT2LL (_pCacheEntryInfo->ExpireTime) != LONGLONG_ZERO)
        {
            // We have an expires time.
            if (FT2LL (_pCacheEntryInfo->ExpireTime) > FT2LL(_pCacheEntryInfo->LastAccessTime))
            {
                // Expiry was in future of last access time, so don't resync.
                fExpired = FALSE;
            }                
            else
            {
                // Entry was originally expired.  Make sure it was sync'ed once.
                fExpired = (FT2LL(_pCacheEntryInfo->LastSyncTime) < dwdwSessionStartTime);
            }
        }
        else switch (_dwCacheFlags)
        {
            default:
            case CACHE_FLAG_SYNC_MODE_AUTOMATIC:
                if (_pCacheEntryInfo->CacheEntryType & STATIC_CACHE_ENTRY)
                {
                    fExpired = FALSE;
                    break;
                }
            // else intentional fall-through...
        
            case CACHE_FLAG_SYNC_MODE_ALWAYS:
            case CACHE_FLAG_SYNC_MODE_ONCE_PER_SESSION:
                fExpired = (FT2LL(_pCacheEntryInfo->LastSyncTime) < dwdwSessionStartTime);
                break;

            case CACHE_FLAG_SYNC_MODE_NEVER:
                fExpired = FALSE;
                break;
                
        } // end switch
    }
    else
    {
        // HYPERLINKING CASE

        // Always strictly honor expire time from the server.
        _fLazyUpdate = FALSE;
        
        if(   (_pCacheEntryInfo->CacheEntryType & POST_CHECK_CACHE_ENTRY ) &&
             !(_dwCacheFlags & INTERNET_FLAG_BGUPDATE) )
        {
            //
            // this is the (instlled) post check cache entry, so we will do
            // post check on this ietm
            //
            fExpired = FALSE;
            _fLazyUpdate = TRUE;
            
        }
        else if (FT2LL(_pCacheEntryInfo->ExpireTime) != LONGLONG_ZERO)
        {
            // do we have postCheck time?
            //
            //           ftPostCheck                   ftExpire
            //               |                            |
            // --------------|----------------------------|-----------> time
            //               |                            | 
            //    not expired |   not expired (bg update)  |   expired
            //
            //               
            LONGLONG qwPostCheck = FT2LL(_pCacheEntryInfo->ftPostCheck);
            if( qwPostCheck != LONGLONG_ZERO )
            {
                LONGLONG qwCurrent = FT2LL(ftCurrentTime);

                if( qwCurrent < qwPostCheck )
                {
                    fExpired = FALSE;
                }
                else
                if( qwCurrent < FT2LL(_pCacheEntryInfo->ExpireTime) ) 
                {
                    fExpired = FALSE;

                    // set background update flag  
                    // (only if we are not doing lazy updating ourselfs)
                    if ( !(_dwCacheFlags & INTERNET_FLAG_BGUPDATE) )
                    {
                        _fLazyUpdate = TRUE;
                    }
                }
                else
                {
                    fExpired = TRUE;
                }
            }
            else 
                fExpired = FT2LL(_pCacheEntryInfo->ExpireTime) <= FT2LL(ftCurrentTime);
        }
        else switch (_dwCacheFlags)
        {

            case CACHE_FLAG_SYNC_MODE_NEVER:
                // Never check, unless the page has expired
                fExpired = FALSE;
                break;

            case CACHE_FLAG_SYNC_MODE_ALWAYS:
                fExpired = TRUE;
                break;

            default:
            case CACHE_FLAG_SYNC_MODE_AUTOMATIC:

                if (_pCacheEntryInfo->CacheEntryType & STATIC_CACHE_ENTRY)
                {
                    // We believe this entry never actually changes.
                    // Check the entry if interval since last checked
                    // is less than 25% of the time we had it cached.
                    LONGLONG qwTimeSinceLastCheck = FT2LL (ftCurrentTime)
                        - FT2LL(_pCacheEntryInfo->LastSyncTime);
                    LONGLONG qwTimeSinceDownload = FT2LL (ftCurrentTime)
                        - FT2LL (_pCacheEntryInfo->ftDownload);
                    fExpired = qwTimeSinceLastCheck > qwTimeSinceDownload/4;
                    break;
                }
                // else intentional fall through to once-per-session rules.

            case CACHE_FLAG_SYNC_MODE_ONCE_PER_SESSION:

                fExpired = TRUE;

                // Huh. We don't have an expires, so we'll improvise
                // but wait! if we are hyperlinking then there is added
                // complication. This semantic has been figured out
                // on Netscape after studying various sites
                // if the server didn't send us expiry time or lastmodifiedtime
                // then this entry expires when hyperlinking
                // this happens on queries

                if (_dwCacheFlags & INTERNET_FLAG_HYPERLINK
                    && !FT2LL(_pCacheEntryInfo->LastModifiedTime))
                {
                    // shouldn't need the hyperlink test anymore
                    DEBUG_PRINT(CACHE, INFO, ("Hyperlink semantics\n"));
                    INET_ASSERT(fExpired==TRUE);
                    break;
                }

                // We'll assume the data could change within a day of the last time
                // we sync'ed.
                // We want to refresh UNLESS we've seen the page this session
                // AND the session's upper bound hasn't been exceeded.
                if      ((dwdwSessionStartTime < FT2LL(_pCacheEntryInfo->LastSyncTime))
                    &&
                        (FT2LL(ftCurrentTime) < FT2LL(_pCacheEntryInfo->LastSyncTime) + 
                            dwdwHttpDefaultExpiryDelta))
                {                    
                    fExpired = FALSE;
                }            
                break;

        } // end switch
        
    } // end else for hyperlinking case

    DEBUG_LEAVE(fExpired);
    return fExpired;
}

PRIVATE BOOL HTTPCACHE_REQUEST::AddIfModifiedSinceHeaders()
/*++

Routine Description:

    Add the necessary IMS request headers to validate whether a cache
    entry can still be used to satisfy the GET request.

    Code from HTTP_REQUEST_HANDLE_OBJECT::FAddIfModifiedSinceHeader
    and HTTP_REQUEST_HANDLE_OBJECT::AddHeaderIfEtagFound from wininet

Return Value: 

    BOOL
    
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::AddIfModifiedSinceHeaders",
                 NULL
                 ));

    BOOL fResult = FALSE;

    // add if-modified-since only if there is last modified time
    // sent back by the site. This way you never get into trouble
    // where the site doesn't send you an last modified time and you
    // send if-modified-since based on a clock which might be ahead
    // of the site. So the site might say nothing is modified even though
    // something might be. www.microsoft.com is one such example
    if (FT2LL(_pCacheEntryInfo->LastModifiedTime) != LONGLONG_ZERO)
    {

        TCHAR szBuf[64];
        TCHAR szHeader[HTTP_IF_MODIFIED_SINCE_LEN + 76];
        DWORD dwLen;
        DWORD dwError;
        BOOL success = FALSE;

        INET_ASSERT (FT2LL(_pCacheEntryInfo->LastModifiedTime));

        dwLen = sizeof(szBuf);

        if (FFileTimetoHttpDateTime(&(_pCacheEntryInfo->LastModifiedTime), szBuf, &dwLen))
        {
            if (_pCacheEntryInfo->CacheEntryType & HTTP_1_1_CACHE_ENTRY)
            {
                INET_ASSERT (dwLen);
                dwLen = wsprintf(szHeader, "%s %s", HTTP_IF_MODIFIED_SINCE_SZ, szBuf); 
            }
            else
            {
                dwLen = wsprintf(szHeader, "%s %s; length=%d", HTTP_IF_MODIFIED_SINCE_SZ, 
                               szBuf, _pCacheEntryInfo->dwSizeLow);
            }
            
            fResult = HttpAddRequestHeadersA(_hRequest, 
                                             szHeader, 
                                             dwLen,
                                             WINHTTP_ADDREQ_FLAG_ADD);

        }
    }
    
    // Only HTTP 1.1 support the ETag header
    if (!(_pCacheEntryInfo->CacheEntryType & HTTP_1_1_CACHE_ENTRY))
    {
        fResult = TRUE;
    }
    else
    {
        // Look for the ETag header
        TCHAR szOutBuf[256];
        TCHAR szHeader[256 + HTTP_IF_NONE_MATCH_LEN];
        DWORD dwOutBufLen = 256;
        DWORD dwHeaderLen;
        
        // If the ETag header is present, then add the "if-range: <etag>" header
        if (HttpQueryInfoA(_hRequest, WINHTTP_QUERY_ETAG, NULL, szOutBuf, &dwOutBufLen, NULL))
        {
            dwHeaderLen = wsprintf(szHeader, "%s %s", HTTP_IF_NONE_MATCH_SZ, szOutBuf);

            fResult = HttpAddRequestHeadersA(_hRequest, 
                                              szHeader, 
                                              dwHeaderLen, 
                                              WINHTTP_ADDREQ_FLAG_ADD_IF_NEW);
        }
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


PRIVATE PRIVATE VOID HTTPCACHE_REQUEST::CalculateTimeStampsForCache()
/*++

Routine Description:

    extracts timestamps from the http response. If the timestamps don't exist,
    does the default thing. has additional goodies like checking for expiry etc.

Side Effects:  

    The calculated time stamps values are saved as private members 
    _ftLastModTime, _ftExpiryTime, _ftPostCheckTime, _fHasExpiry,
    _fHasLastModTime, _fHasPostCheck, and _fMustRevalidate.

Return Value: 

    NONE

--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 None,
                 "HTTPCACHE_REQUEST::CalculateTimeStampsForCache",
                 NULL
                 ));

    TCHAR buf[512];
    LPSTR lpszBuf;
    BOOL fRet = FALSE;

    DWORD dwLen, index = 0;
    BOOL fPostCheck = FALSE;
    BOOL fPreCheck = FALSE;
    FILETIME ftPreCheckTime;
    FILETIME ftPostCheckTime;

    // reset the private variables
    _fHasLastModTime = FALSE;
    _fHasExpiry = FALSE;
    _fHasPostCheck = FALSE;
    _fMustRevalidate = FALSE;

    // Do we need to enter a critical section?
    // _ResponseHeaders.LockHeaders();

    // Determine if a Cache-Control: max-age header exists. If so, calculate expires
    // time from current time + max-age minus any delta indicated by Age:

    //
    // we really want all the post-fetch stuff works with 1.0 proxy
    // so we loose our grip a little bit here: enable all Cache-Control
    // max-age work with 1.0 response.
    //
    //if (IsResponseHttp1_1())

    CHAR  *ptr, *pToken;
    INT nDeltaSecsPostCheck = 0;
    INT nDeltaSecsPreCheck = 0;

    BOOL fResult;
    DWORD dwError;
    
    while (1)
    {
        // Scan headers for Cache-Control: max-age header.
        dwLen = sizeof(buf);
        fResult = HttpQueryInfoA(_hRequest, 
                                WINHTTP_QUERY_CACHE_CONTROL,
                                NULL,
                                buf,
                                &dwLen,
                                &index);

        if (fResult == TRUE) 
            dwError = ERROR_SUCCESS;
        else
            dwError = GetLastError();

        switch (dwError)
        {
          case ERROR_SUCCESS:      
            buf[dwLen] = '\0';
            pToken = ptr = buf;

            // Parse a token from the string; test for sub headers.
            while (pToken = StrTokExA(&ptr, ","))  // <<-- Really test this out, used StrTokEx before
            {
                SKIPWS(pToken);

                if (strnicmp(POSTCHECK_SZ, pToken, POSTCHECK_LEN) == 0)
                {
                    pToken += POSTCHECK_LEN;

                    SKIPWS(pToken);

                    if (*pToken != '=')
                        break;

                    pToken++;

                    SKIPWS(pToken);

                    nDeltaSecsPostCheck = atoi(pToken);

                    // Calculate post fetch time 
                    GetCurrentGmtTime(&ftPostCheckTime);
                    AddLongLongToFT(&ftPostCheckTime, (nDeltaSecsPostCheck * (LONGLONG) 10000000));
                
                    fPostCheck = TRUE;
                }
                else if (strnicmp(PRECHECK_SZ, pToken, PRECHECK_LEN) == 0)
                {
                    // found
                    pToken += PRECHECK_LEN;

                    SKIPWS(pToken);

                    if (*pToken != '=')
                        break;

                    pToken++;

                    SKIPWS(pToken);

                    nDeltaSecsPreCheck = atoi(pToken);

                    // Calculate pre fetch time (overwrites ftExpire ) 
                    GetCurrentGmtTime(&ftPreCheckTime);
                    AddLongLongToFT(&ftPreCheckTime, (nDeltaSecsPreCheck * (LONGLONG) 10000000));

                    fPreCheck = TRUE;
                }
                else if (strnicmp(MAX_AGE_SZ, pToken, MAX_AGE_LEN) == 0)
                {
                    // Found max-age. Convert to integer form.
                    // Parse out time in seconds, text and convert.
                    pToken += MAX_AGE_LEN;

                    SKIPWS(pToken);

                    if (*pToken != '=')
                        break;

                    pToken++;

                    SKIPWS(pToken);

                    INT nDeltaSecs = atoi(pToken);
                    INT nAge;

                    // See if an Age: header exists.

					// Using a local index variable:
                    DWORD indexAge = 0;
                    dwLen = sizeof(INT)+1;

                    if (HttpQueryInfoA(_hRequest,
                                      HTTP_QUERY_AGE | HTTP_QUERY_FLAG_NUMBER,
                                      NULL,
                                      &nAge,
                                      &dwLen,
                                      &indexAge))

                    {
                        // Found Age header. Convert and subtact from max-age.
                        // If less or = 0, attempt to get expires header.
                        nAge = ((nAge < 0) ? 0 : nAge);

                        nDeltaSecs -= nAge;
                        if (nDeltaSecs <= 0)
                            // The server (or some caching intermediary) possibly sent an incorrectly
					        // calculated header. Use "Expires", if no "max-age" directives at higher indexes.
                            // Note: This behaviour could cause a situation where the "pre-check"
                            // and "post-check" are picked up from the current index, and "max-age" is
                            // picked up from a higher index. "pre-check" and "post-check" are IE 5.x 
                            // extensions, and generally not bunched together with "max-age", so this
                            // should work fine. More info on "pre-check" and "post-check":
                            // <http://msdn.microsoft.com/workshop/author/perf/perftips.asp#Use_Cache-Control_Extensions>
                            continue;
                    }

                    // Calculate expires time from max age.
                    GetCurrentGmtTime(&_ftExpiryTime);
                    AddLongLongToFT(&_ftExpiryTime, (nDeltaSecs * (LONGLONG) 10000000));
                    fRet = TRUE;
                }
                else if (strnicmp(MUST_REVALIDATE_SZ, pToken, MUST_REVALIDATE_LEN) == 0)
                {
                    pToken += MUST_REVALIDATE_LEN;
                    SKIPWS(pToken);
                    if (*pToken == 0 || *pToken == ',')
                        _fMustRevalidate = TRUE;
                        
                }
            }

            // If an expires time has been found, break switch.
            if (fRet)
                break;
					
            // Need to bump up index to prevent possibility of never-ending outer while(1) loop.
            // Otherwise, on exit from inner while, we could be stuck here reading the 
            // Cache-Control at the same index.
            // HttpQueryInfoA(WINHTTP_QUERY_CACHE_CONTROL, ...) will return either the next index,
            // or an error, and we'll be good to go:
			index++;
            continue;

          case ERROR_INSUFFICIENT_BUFFER:
            index++;
            continue;

          default:
            break; // no more Cache-Control headers.
        }

        //
        // pre-post fetch headers must come in pair, also
        // pre fetch header overwrites the expire 
        // and make sure postcheck < precheck
        //
        if( fPreCheck && fPostCheck && 
            ( nDeltaSecsPostCheck < nDeltaSecsPreCheck ) ) 
        {
            fRet = TRUE;
            _ftPostCheckTime = ftPostCheckTime;
            _ftExpiryTime = ftPreCheckTime;
            _fHasPostCheck = TRUE;

            if( nDeltaSecsPostCheck == 0 && 
                !(_dwCacheFlags & CACHE_FLAG_BGUPDATE) )
            {
                //
                // "post-check = 0"
                // this page has already passed the lazy update time
                // this means server wants us to do background update 
                // after the first download  
                //
                // (bg fsm will be created at the end of the cache write)
                //
                _fLazyUpdate = TRUE;
            }
        }
        else
        {
            fPreCheck = FALSE;
            fPostCheck = FALSE;
        }

        break; // no more Cache-Control headers.
    }

    // If no expires time is calculated from max-age, check for expires header.
    if (!fRet)
    {
        dwLen = sizeof(buf) - 1;
        index = 0;
        if (HttpQueryInfoA(_hRequest, HTTP_QUERY_EXPIRES, NULL, buf, &dwLen, &index))
        {
            fRet = FParseHttpDate(&_ftExpiryTime, buf);

            //
            // as per HTTP spec, if the expiry time is incorrect, then the page is
            // considered to have expired
            //

            if (!fRet)
            {
                GetCurrentGmtTime(&_ftExpiryTime);
                AddLongLongToFT(&_ftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
                fRet = TRUE;
            }
        }
    }

    // We found or calculated a valid expiry time, let us check it against the
    // server date if possible
    FILETIME ft;
    dwLen = sizeof(buf) - 1;
    index = 0;

    if (HttpQueryInfoA(_hRequest, HTTP_QUERY_DATE, NULL, buf, &dwLen, &index) == ERROR_SUCCESS
        && FParseHttpDate(&ft, buf))
    {

        // we found a valid Data: header

        // if the expires: date is less than or equal to the Date: header
        // then we put an expired timestamp on this item.
        // Otherwise we let it be the same as was returned by the server.
        // This may cause problems due to mismatched clocks between
        // the client and the server, but this is the best that can be done.

        // Calulating an expires offset from server date causes pages
        // coming from proxy cache to expire later, because proxies
        // do not change the date: field even if the reponse has been
        // sitting the proxy cache for days.

        // This behaviour is as-per the HTTP spec.


        if (FT2LL(_ftExpiryTime) <= FT2LL(ft))
        {
            GetCurrentGmtTime(&_ftExpiryTime);
            AddLongLongToFT(&_ftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
        }
    }

    _fHasExpiry = fRet;

    if (!fRet)
    {
        _ftExpiryTime.dwLowDateTime = 0;
        _ftExpiryTime.dwHighDateTime = 0;
    }

    fRet = FALSE;
    dwLen = sizeof(buf) - 1;
    index = 0;

    if (HttpQueryInfoA(_hRequest, HTTP_QUERY_LAST_MODIFIED, NULL, buf, &dwLen, &index))
    {
        DEBUG_PRINT(CACHE,
                    INFO,
                    ("Last Modified date is: %q\n",
                    buf
                    ));

        fRet = FParseHttpDate(&_ftLastModTime, buf);

        if (!fRet)
        {
            DEBUG_PRINT(CACHE,
                        ERROR,
                        ("FParseHttpDate() returns FALSE\n"
                        ));
        }
    }

    _fHasLastModTime = fRet;

    if (!fRet)
    {
        _ftLastModTime.dwLowDateTime = 0;
        _ftLastModTime.dwHighDateTime = 0;
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\httpcache\httpcache.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    httpcache.cxx

Abstract:

    Contains API implementation of the WinHTTP-UrlCache interaction layer 

Environment:

    Win32 user-level

Revision History:


--*/

/*++

- TODO: All functions assume that parameter validation has been performed already in the layer above it.  Make
sure all parameters that gets passed in (in test programs etc...) are validated and correct.

- As it currently stands, the HTTP-Cache API functions are exposed outside via DLL exports.  This is NOT what's supposed
to happen.  This layer is supposed to be an internal layer.  Eliminate the DLL exports as soon as the API hooks are
completed and extensive testing has been done to make sure that the component is really working as expected.

- FindUrlCacheEntry trys to find the address specified by "http://"+_szServername+_szLastVerb

-- */

#include <wininetp.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"

#include "cachelogic.hxx"
#include "cachehndl.hxx"

////////////////////////////////////////////////////////////////////////////////////////////
// Global Variables
//

CACHE_HANDLE_MANAGER * CacheHndlMgr;


////////////////////////////////////////////////////////////////////////////////////////////
//
// API implementation
//

HINTERNET
WINAPI
WinHttpCacheOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )
{
    DEBUG_ENTER((DBG_CACHE,
                     Handle,
                     "WinHttpCacheOpen",
                     "%wq, %s (%d), %wq, %wq, %#x",
                     pszAgentW,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     pszProxyW,
                     pszProxyBypassW,
                     dwFlags
                     ));

    DWORD dwErr;
    HINTERNET hInternet = NULL;
    
    if ((dwFlags & WINHTTP_FLAG_ASYNC) && 
       (dwFlags & WINHTTP_CACHE_FLAGS_MASK))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    hInternet = WinHttpOpen(
        pszAgentW, 
        dwAccessType, 
        pszProxyW, 
        pszProxyBypassW, 
        dwFlags);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;

}

HINTERNET
WINAPI
WinHttpCacheOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    )
{
    DEBUG_ENTER_API((DBG_CACHE,
                     Handle,
                     "WinHttpCacheOpenRequest",
                     "%#x, %.80wq, %.80wq, %.80wq, %.80wq, %#x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags
                     ));

    HINTERNET hRequest; 

    hRequest = WinHttpOpenRequest(
                    hConnect, 
                    lpszVerb, 
                    lpszObjectName, 
                    lpszVersion, 
                    lpszReferrer, 
                    lplpszAcceptTypes, 
                    dwFlags);

    if (hRequest != NULL) 
    {
        // The caching layer only works with GET requests
        if(wcscmp(L"GET", lpszVerb) == 0)
        {  
            if (CacheHndlMgr == NULL)
            {
                CacheHndlMgr = new CACHE_HANDLE_MANAGER;
                if (CacheHndlMgr == NULL)
                {
                    DEBUG_PRINT(CACHE, ERROR, ("Not enough memory to initialize CACHE_HANDLE_MANAGER"));
                    goto quit;
                }
           }

            CacheHndlMgr->AddCacheRequestObject(hRequest);
        }
    }
    
quit:
    
    DEBUG_LEAVE(hRequest);
    return hRequest;
}


BOOL
WINAPI
WinHttpCacheSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    )

{
    DEBUG_ENTER((DBG_CACHE,
                Bool,
                "WinHttpCacheSendRequest",
                "%#x, %.80wq, %d, %#x, %d, %d, %x",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwTotalLength,
                dwContext
                ));

    BOOL fResult = FALSE;
    
    if (CacheHndlMgr != NULL)
    {
        HTTPCACHE_REQUEST * HTTPCacheRequest;
        if ((HTTPCacheRequest =
            CacheHndlMgr->GetCacheRequestObject(hRequest)) != NULL)
        {
            fResult = HTTPCacheRequest->SendRequest(
                        lpszHeaders,
                        dwHeadersLength,
                        lpOptional,
                        dwOptionalLength
                        );
            goto quit;
        }
    } 

    fResult = WinHttpSendRequest(hRequest,
                               lpszHeaders,
                               dwHeadersLength,
                               lpOptional,
                               dwOptionalLength,
                               dwTotalLength,
                               dwContext);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
    
}

BOOL
WINAPI
WinHttpCacheReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut
    )
{
    DEBUG_ENTER((DBG_CACHE,
                     Bool,
                     "WinHttpCacheReceiveResponse",
                     "%#x, %#x",
                     hRequest,
                     lpBuffersOut
                     ));

    BOOL fResult;
    
    if (CacheHndlMgr != NULL)
    {
        HTTPCACHE_REQUEST * HTTPCacheRequest;
        if ((HTTPCacheRequest = 
            CacheHndlMgr->GetCacheRequestObject(hRequest)) != NULL)
        {
            fResult = HTTPCacheRequest->ReceiveResponse(lpBuffersOut);
            goto quit;
        }
    }

    fResult = WinHttpReceiveResponse(hRequest,
                                   lpBuffersOut);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}

BOOL
WINAPI
WinHttpCacheQueryDataAvailable(
    IN HINTERNET hRequest,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )
{
    DEBUG_ENTER((DBG_CACHE,
                     Bool,
                     "WinHttpCacheQueryDataAvailable",
                     "%#x, %#x, %#x",
                     hRequest,
                     lpdwNumberOfBytesAvailable
                     ));

    BOOL fResult;
    
    if (CacheHndlMgr != NULL)
    {
        HTTPCACHE_REQUEST * HTTPCacheRequest;
        if ((HTTPCacheRequest =
           CacheHndlMgr->GetCacheRequestObject(hRequest)) != NULL)
        {
            fResult = HTTPCacheRequest->QueryDataAvailable(lpdwNumberOfBytesAvailable);
            goto quit;
        }
    }

    fResult = WinHttpQueryDataAvailable(hRequest,
                                     lpdwNumberOfBytesAvailable);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}

BOOL
WINAPI
WinHttpCacheReadData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    DEBUG_ENTER((DBG_CACHE,
                     Bool,
                     "WinHttpCacheReadData",
                     "%#x, %#x, %d, %#x",
                     hRequest,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     ));

    BOOL fResult;
    
    if (CacheHndlMgr != NULL)
    {
        HTTPCACHE_REQUEST * HTTPCacheRequest;
        if ((HTTPCacheRequest =
           CacheHndlMgr->GetCacheRequestObject(hRequest)) != NULL)
        {
            fResult = HTTPCacheRequest->ReadData(lpBuffer, 
                                              dwNumberOfBytesToRead,
                                              lpdwNumberOfBytesRead);
            goto quit;
        }
    }

    fResult = WinHttpReadData(hRequest,
                           lpBuffer,
                           dwNumberOfBytesToRead,
                           lpdwNumberOfBytesRead);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
    
}

BOOL
WINAPI
WinHttpCacheCloseHandle(
    IN HINTERNET hInternet
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "WinHTTPCacheCloseRequestHandle",
                 "%#x",
                 hInternet
                 ));

    DWORD dwHandleType;
    DWORD dwSize = sizeof(DWORD);
    DWORD fResult = FALSE;
    
    if (hInternet == NULL)
        goto quit;
    
    WinHttpQueryOption(hInternet, WINHTTP_OPTION_HANDLE_TYPE, &dwHandleType, &dwSize);
    if (dwHandleType == WINHTTP_HANDLE_TYPE_REQUEST)
    {
        if (CacheHndlMgr != NULL)
        {
            HTTPCACHE_REQUEST * HTTPCacheRequest;
            if ((HTTPCacheRequest =
            CacheHndlMgr->GetCacheRequestObject(hInternet)) != NULL)
            {
                fResult = HTTPCacheRequest->CloseRequestHandle();
                
                CacheHndlMgr->RemoveCacheRequestObject(hInternet);

                if (CacheHndlMgr->RefCount() == 0)
                {
                    delete CacheHndlMgr;
                    CacheHndlMgr = NULL;
                }

                goto quit;
            }
        }
    }

    fResult = WinHttpCloseHandle(hInternet);

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\http\write.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    write.cxx

Abstract:

    This file contains the implementation of the HttpWriteData API.

    Contents:
        HttpWriteData
        HTTP_REQUEST_HANDLE_OBJECT::WriteData

Author:

    Arthur Bierer (arthurbi) 07-Apr-1997

Revision History:



--*/

#include <wininetp.h>
#include "httpp.h"



//
// functions
//



DWORD
HttpWriteData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    Writes a block of data for an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetWriteFile() which
        globally validates parameters for all Internet data write
        functions

         2. That we the caller has called HttpBeginSendRequest but not HttpEndSendRequest

Arguments:

    hRequest                - an open HTTP request handle returned by
                  HttpOpenRequest()

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written

    dwSocketFlags           - controlling socket operation


Return Value:

    TRUE - The data was written successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/


{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HttpWriteData",
                 "%#x, %#x, %d, %#x, %#x",
                 hRequest,
                 lpBuffer,
                 dwNumberOfBytesToWrite,
                 lpdwNumberOfBytesWritten,
                 dwSocketFlags
                 ));

    DWORD error = DoFsm(New CFsm_HttpWriteData(lpBuffer,
                                              dwNumberOfBytesToWrite,
                                              lpdwNumberOfBytesWritten,
                                              dwSocketFlags,
                                              (HTTP_REQUEST_HANDLE_OBJECT *)hRequest
                                              ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpWriteData::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpWriteData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpWriteData * stateMachine = (CFsm_HttpWriteData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:

        pRequest->SetAddCRLF(TRUE);

        //
        // Fall through
        //

    case FSM_STATE_CONTINUE:
        error = pRequest->HttpWriteData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpWriteData_Fsm(
    IN CFsm_HttpWriteData * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpWriteData_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpWriteData & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {
        if (!IsValidHttpState(WRITE)) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
            goto quit;
        }

        error = _Socket->Send(
                           fsm.m_lpBuffer,
                           fsm.m_dwNumberOfBytesToWrite,
                           SF_INDICATE
                           );

    }

    if (error == ERROR_SUCCESS)
    {
        *fsm.m_lpdwNumberOfBytesWritten = fsm.m_dwNumberOfBytesToWrite;
    }


quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\httpcache\internalapi.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    internalapi.cxx
    
Abstract:

    Contains internal (unexposed) codes for getting/setting various properties of 
    the HTTP_REQUEST_HANDLE_OBJECT object.

    Used mainly by the WinHTTP caching layer to obtain and set extended information
    not possible through the WinHTTP C++ API.

    The cache should not be made aware about the internal class structure of 
    WinHTTP (to make a cleaner separation between the core WinHTTP layer and
    the caching layer), therefore the cache must call these internal functions to
    access internal WinHTTP functionalities.
    
Environment:

    Win32 user-mode DLL

Revision History:

--*/
#include <wininetp.h>
#include "internalapi.hxx"

BOOL InternalQueryOptionA(
    IN HINTERNET hInternet, 
    IN DWORD dwOption, 
    IN OUT LPDWORD lpdwResult
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Bool, 
                  "InternalQueryOptionA",
                  "%#x, %d, %d",
                  hInternet,
                  dwOption,
                  *lpdwResult));

    BOOL fSuccess;
    DWORD dwError;
    HINTERNET_HANDLE_TYPE handleType;
    HINTERNET hObjectMapped = NULL;
    HTTP_REQUEST_HANDLE_OBJECT* pReq;
    
    // map the handle
    dwError = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
    if (dwError == ERROR_SUCCESS) {
        hInternet = hObjectMapped;
        dwError = RGetHandleType(hInternet, &handleType);
    }

    if (dwError != ERROR_SUCCESS) {
        goto quit;
    }

    dwError = ERROR_INVALID_OPERATION;

    if (handleType == TypeHttpRequestHandle)
        pReq = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
    else
        goto quit;
    
    if (pReq == NULL)
        goto quit;
    
    switch (dwOption)
    {
      case WINHTTP_OPTION_REQUEST_FLAGS:
        *lpdwResult = pReq->GetOpenFlags();
        break;
        
      case WINHTTP_OPTION_CACHE_FLAGS:
        *lpdwResult = pReq->GetInternetOpenFlags();
        break;
        
      default:
        break;
    }

    dwError = ERROR_SUCCESS;
   
quit:
    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwError = ERROR_SUCCESS)
        fSuccess = TRUE;
    else
        fSuccess = FALSE;

    DEBUG_LEAVE(fSuccess);
    return fSuccess;
}

DWORD InternalReplaceResponseHeader(
    IN HINTERNET hRequest,
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Dword, 
                  "InternalReplaceResponseHeaders",
                  "%#x, %d",
                  hRequest,
                  dwQueryIndex));

    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    DWORD fResult;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;
    fResult = pRequest->ReplaceResponseHeader(
                                dwQueryIndex,
                                lpszHeaderValue,
                                dwHeaderValueLength,
                                dwIndex,
                                dwFlags);
    
    DEBUG_LEAVE(fResult);
    return fResult;
}

DWORD InternalAddResponseHeader(
    IN HINTERNET hRequest,
    IN DWORD dwHeaderIndex,
    IN LPSTR lpszHeader,
    IN DWORD dwHeaderLength
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Dword, 
                  "InternalAddResponseHeaders",
                  "%#x",
                  hRequest));
    
    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    DWORD fResult;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    fResult = pRequest->AddInternalResponseHeader(
            dwHeaderIndex,
            lpszHeader,
            dwHeaderLength
            );
    
    DEBUG_LEAVE(fResult);
    return fResult;
}

DWORD InternalCreateResponseHeaders(
    IN HINTERNET hRequest,
    IN OUT LPSTR* ppszBuffer,
    IN DWORD dwBufferLength
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Dword, 
                  "InternalCreateResponseHeaders",
                  "%#x",
                  hRequest));
    
    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    DWORD fResult;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;
    fResult = pRequest->CreateResponseHeaders(
                            ppszBuffer,
                            dwBufferLength);
    
    DEBUG_LEAVE(fResult);
    return fResult;
}

    
BOOL InternalIsResponseHeaderPresent(
    IN HINTERNET hRequest, 
    IN DWORD dwQueryIndex
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Bool, 
                  "InternalIsResponseHeadersPresent",
                  "%#x, %d",
                  hRequest,
                  dwQueryIndex));

    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    BOOL fResult;

    HTTP_REQUEST_HANDLE_OBJECT * pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;
    fResult = pRequest->IsResponseHeaderPresent(dwQueryIndex);

    DEBUG_LEAVE(fResult);
    return fResult;
}


BOOL InternalIsResponseHttp1_1(
    IN HINTERNET hRequest
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  Bool, 
                  "InternalIsResponseHttp1_1",
                  "%#x",
                  hRequest));

    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    BOOL fResult;

    fResult = ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->IsResponseHttp1_1();
    DEBUG_LEAVE(fResult);
    return fResult;
}

VOID InternalReuseHTTP_Request_Handle_Object(
    IN HINTERNET hRequest
    )
{
    DEBUG_ENTER((DBG_CACHE, 
                  None, 
                  "InternalReuseHTTP_Request_Handle_Object",
                  "%#x",
                  hRequest));

    // should include type checking.  Right now this API is relying on the user
    // passing a Request handle

    ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->ReuseObject();

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\httpcache\cachewrite.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cachewrite.cxx

Abstract:

    This file contains the implementation of the HTTPCACHE request object which involve writing to the cache

Author:

Revision History:

--*/

#include <wininetp.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"

#include "..\http\headers.h"
#include "cachelogic.hxx"
#include "internalapi.hxx"
#include "..\http\proc.h"

struct AddUrlArg
{
    LPCSTR   pszUrl;
    LPCSTR   pszRedirect;
    LPCTSTR  pszFilePath;
    DWORD    dwFileSize;
    LONGLONG qwExpires;
    LONGLONG qwLastMod;
    LONGLONG qwPostCheck;
    FILETIME ftCreate;
    DWORD    dwEntryType;
    LPCSTR   pbHeaders;
    DWORD    cbHeaders;
    LPCSTR   pszFileExt;
    BOOL     fImage;
    DWORD    dwIdentity;
};
DWORD UrlCacheCommitFile (IN AddUrlArg* pArgs);
DWORD 
UrlCacheCreateFile
(
    IN LPCSTR szUrl, 
    IN OUT LPTSTR szFile, 
    IN LPTSTR szExt,
    IN HANDLE* phfHandle,
    IN BOOL fCreatePerUser = FALSE,
    IN DWORD dwExpectedLength = 0
);

PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::IsStaticImage()
/*++

Routine Description:

   To improve performance, Internet Explorer classify whether a cached 
   contents is a static image or not.  Images usually do not change as
   often as text contents, so they do not have to be revalidated
   from the server as often, thus improving performance.  

   Let the cache know if the item is likely to be a static image if it
   satisfies all four of the following requirements
     1. No expire time.
     2. Has last-modified time.
     3. The content-type is image/*
     4. No '?' in the URL.

Pre-condition: 

    CalculateTimeStampsForCache() has been called

Side Effects: 

    NONE

Return Value:

    BOOL to indicate whether the image is a static image or not
--*/
{
    TCHAR szHeader[256];
    DWORD dwSize = 256;
    return (!FT2LL(_ftExpiryTime)
            && FT2LL(_ftLastModTime)
            && (HttpQueryInfoA(_hRequest, HTTP_QUERY_CONTENT_TYPE,
                NULL, (LPVOID *) &szHeader, &dwSize, 0) == TRUE)
            && (StrCmpNI (szHeader, "image/", sizeof("image/")-1) == 0)
            && (!StrChr (GetUrl(), '?'))
           );
}

PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::ExtractHeadersForCacheCommit(
    OUT LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwHeaderLen
    )
    
/*++

Routine Description:

    Most HTTP response headers are to be kept inside the cache in index.dat, so 
    that those pieces of information can be retrieved and examined
    in subsequent requests.  

    This function will extract all the HTTP response headers that will normally be
    committed to the cache entry

    Similar to FilterHeaders in Wininet
    
Parameters:

    LPSTR lpszHeaderInfo - Caller should allocate sufficient memory to hold the
                          extracted headers
        
Side Effects: 

    NONE

Return Value:

    BOOL to indicate whether the call is successful or not
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::ExtractHeadersForCacheCommit",
                 NULL
                 ));

    BOOL fResult = FALSE;
    
    if (lpszHeaderInfo == NULL)
    {
        DEBUG_PRINT(CACHE, ERROR, ("First parameter is NULL.  Cannot continue\n"));
        goto quit;
    }
    
    DWORD i, len, lenT, reduced = 0, dwHeaderTableCount;
    LPSTR lpT, lpMark, lpNext, *lprgszHeaderExcludeTable;

    LPSTR rgszExcludeHeaders[] = {
        HTTP_SET_COOKIE_SZ,
        HTTP_LAST_MODIFIED_SZ,
        HTTP_SERVER_SZ,
        HTTP_DATE_SZ,
        HTTP_EXPIRES_SZ,
        HTTP_CONNECTION_SZ,
        HTTP_PROXY_CONNECTION_SZ,
        HTTP_VIA_SZ,
        HTTP_VARY_SZ,
        HTTP_AGE_SZ,
        HTTP_CACHE_CONTROL_SZ,
        HTTP_ACCEPT_RANGES_SZ,
        HTTP_CONTENT_DISPOSITION_SZ
    };
    
    lprgszHeaderExcludeTable = rgszExcludeHeaders;
    dwHeaderTableCount = sizeof(rgszExcludeHeaders) / sizeof(LPSTR);

    DWORD dwRawHeaderLen = 1024;
    TCHAR szRawHeaderInfo[1024];

    // We need to get the raw headers (with line breaks), and then
    // parse out the junk in the rest of this routine
    if (!HttpQueryInfoA(_hRequest, 
                       HTTP_QUERY_RAW_HEADERS_CRLF,
                       NULL,
                       (LPVOID *) &szRawHeaderInfo,
                       &dwRawHeaderLen,
                       NULL))
    {
        DEBUG_PRINT(CACHE, ERROR, ("HttpQueryInfoA failed\n"));
        goto quit;
    }

    // skip over the status line
    // NB this assumes that the raw buffer is nullterminated (CR/LF)
    lpT = strchr(szRawHeaderInfo, '\r');
    if (!lpT) {
        goto quit;
    }

    INET_ASSERT(*(lpT + 1) == '\n');

    lpT += 2;

    do 
    {
        // find the header portion
        lpMark = strchr(lpT, ':');
        if (!lpMark) 
        {
            break;
        }

        // get the end of the header line
        lpNext = strchr(lpMark, '\r');

        if (!lpNext)
        {
            INET_ASSERT(FALSE);
            // A properly formed header _should_ terminate with \r\n, but sometimes
            // that just doesn't happen
            lpNext = lpMark;
            while (*lpNext)
            {
                lpNext++;
            }
        }
        else
        {
            INET_ASSERT(*(lpNext + 1) == '\n');
            lpNext += 2;
        }

        len = (DWORD) PtrDifference(lpMark, lpT) + 1; 
        lenT = dwRawHeaderLen;  // doing all this to see it properly in debugger

        BOOL bFound = FALSE;

        for (i = 0; i < dwHeaderTableCount; ++i) 
        {
            if (!strnicmp(lpT, lprgszHeaderExcludeTable[i], len)) 
            {
                bFound = TRUE;
                break;
            }
        }

        // If bFound is true, then it means that it's not one of the special headers,
        // so nuke the header
        if (bFound) 
        {
            len = lenT - (DWORD)PtrDifference(lpNext, szRawHeaderInfo) + 1; // for NULL character

            // ACHTUNG memove because of overlapped copies
            memmove(lpT, lpNext, len);

            // keep count of how much we reduced the header by
            reduced += (DWORD) PtrDifference(lpNext, lpT);

            // lpT is already properly positioned because of the move
        } 
        else 
        {
            lpT = lpNext;
        }
    } while (TRUE);
    
    dwRawHeaderLen -= reduced;
    fResult = TRUE;
    
    // return results
    strncpy(lpszHeaderInfo, szRawHeaderInfo, dwRawHeaderLen);
    *lpdwHeaderLen = dwRawHeaderLen;
    DEBUG_PRINT(CACHE, 
                 INFO, 
                 ("Extracted header is %s.  Length = %d\n", 
                 lpszHeaderInfo,
                 *lpdwHeaderLen));

quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE BOOL HTTPCACHE_REQUEST::CommitCacheFileEntry(
    IN BOOL fNormal
    )
/*++

Routine Description:

    Commit the downloaded resource to the cache index.  No redirection
    is taken into account here (unlike the way wininet works)
    
    Similar to INTERNET_CONNECT_HANDLE_OBJECT::LocalEndCacheWrite and 
    EndCacheWrite from wininet
    
Pre-conditions:

    CalculateTimeStampsForCache() has been called

Parameters:

    fNormal - TRUE if normal end cache write operation of the complete resource
             FALSE if interruptions occur during ReadData such that the entire
             resource hasn't been fully downloaded yet, and the resource will
             be marked as a partial cache entry.
             
Side effects:

    NONE
    
Return Value:

    BOOL to indicate whether the call is successful or not
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::CommitCacheFileEntry",
                 "%B",
                 fNormal
                 ));
    
    TCHAR szFileExtension[] = "";  // eventally need to change
    TCHAR szFileName[MAX_PATH];
    DWORD dwCacheEntryType;
    BOOL fImage;
    TCHAR szHeaderInfo[2048];
    DWORD dwHeaderLen;
    BOOL fResult;
    DWORD dwError;
    FILETIME ftCreate;
    BOOL fHttp1_1;

    // We need a few more pieces of information before we
    // can call UrlCommitFile: 
    // 1) cache entry type 
    // 2) whether the item is a static image or not
    // 3) header info
    // 4) The time at which the cache file is created
    // Let's grab them now!

    dwCacheEntryType = 0;

    if (!fNormal)
    {
        if (!IsPartialResponseCacheable())
        {
            DEBUG_PRINT(CACHE, INFO, ("Partial response not cacheable, downloaded will be aborted\n"));
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
        else
        {
            DEBUG_PRINT(CACHE, INFO, ("Partial response will be cached\n"));
            dwCacheEntryType |= SPARSE_CACHE_ENTRY;
            fNormal = TRUE;
        }
            
    }

    if (fNormal)
    {
        // 1) Grab cache entry type information
        if (_dwCacheFlags & CACHE_FLAG_MAKE_PERSISTENT)
            dwCacheEntryType |= STICKY_CACHE_ENTRY;

        if (InternalIsResponseHttp1_1(_hRequest) == TRUE)
        {
            dwCacheEntryType |= HTTP_1_1_CACHE_ENTRY;
            if (_fMustRevalidate == TRUE)
                dwCacheEntryType |= MUST_REVALIDATE_CACHE_ENTRY;
        }

        // 2) Is it an image?
        fImage = IsStaticImage();

        // 3) Grab the header info
        if (!ExtractHeadersForCacheCommit(szHeaderInfo, &dwHeaderLen))
        {
            DEBUG_PRINT(CACHE, INFO, ("ExtractHeadersForCacheCommit failed\n"));
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
    }

    // 4) Get filetime for the cache file, and close the file handle
    // that we first opened to write the content into
    INET_ASSERT(_hCacheWriteFile != INVALID_HANDLE_VALUE);
    GetFileTime( _hCacheWriteFile, &ftCreate, NULL, NULL );

    CalculateTimeStampsForCache();
    
    CloseHandle(_hCacheWriteFile);
    _hCacheWriteFile = INVALID_HANDLE_VALUE;
    
    DEBUG_PRINT(CACHE,
                INFO,
                ("Cache write EntryType = %x\r\n",
                dwCacheEntryType
                ));

    // Now do the real thing
    AddUrlArg Args;
    memset(&Args, 0, sizeof(Args));
    Args.pszUrl = GetUrl();
    Args.pszFilePath = _lpszCacheWriteLocalFilename;
    Args.dwFileSize = _RealCacheFileSize;
    Args.qwExpires = *((LONGLONG *) &_ftExpiryTime);
    Args.qwLastMod = *((LONGLONG *) &_ftLastModTime);
    Args.qwPostCheck = *((LONGLONG *) &_ftPostCheckTime);
    Args.ftCreate = ftCreate;
    Args.dwEntryType = dwCacheEntryType;
    Args.pbHeaders = szHeaderInfo;
    Args.cbHeaders = dwHeaderLen;
    Args.pszFileExt = _lpszFileExtension;
    Args.pszRedirect = NULL;      // BUGBUG should we pass in GetUrl() instead?
    Args.fImage = fImage;
    Args.dwIdentity = 0;
            
    dwError = UrlCacheCommitFile(&Args);

    if (dwError != ERROR_SUCCESS)
    {
        DEBUG_PRINT(CACHE, ERROR,
                      ("CommitUrlCacheEntry(%q) failed\n",
                      _lpszCacheWriteLocalFilename
                     ));
        
        if (dwError == ERROR_SHARING_VIOLATION) 
        {
            // we got new URL data, but the old one is in use.
            // expire it, so any new user's will go to the net
            // ExpireUrl();
        }

        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    DEBUG_LEAVE(TRUE);
    return TRUE;
}


PRIVATE PRIVATE VOID HTTPCACHE_REQUEST::SetFilenameAndExtForCacheWrite()
/*
Routine Description:

    This function attempts to find out the filename and extension for the resource to be
    cached by querying the appropriate HTTP headers.  
    It is possible that EITHER filename or extension will by NULL, but they will NEVER
    be both NULL.  

    Adopt from HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheWrite from Wininet

    TODO: content-length ??

Side effects:

    LPSTR _lpszFileName 
    LPSTR _lpszFileExtension

    These variables will be set.  These variables are needed
    1) when first creating a file for cache write
    2) when the file is committed to the cache
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 None,
                 "HTTPCACHE_REQUEST::SetFilenameAndExtForCacheWrite",
                 NULL
                 ));

    BOOL fResult = FALSE;
    TCHAR cExt[DEFAULT_MAX_EXTENSION_LENGTH + 1];
    TCHAR szFileName[MAX_PATH];
    const TCHAR szDefaultExtension[] = "txt";
    
    DWORD dwLen, cbFileName, dwIndex;
    BOOL fIsUncertainMime = FALSE;

    TCHAR szBuf[256];
    LPSTR ptr, pToken;

    // If the content-disposition header is available, then parse out any filename and use it
    // From RFC2616: The Content-Disposition response-header field has been proposed as a means for 
    // the origin server to suggest a default filename if the user requests that the content is saved to a file.
    if (HttpQueryInfoA(_hRequest, WINHTTP_QUERY_CONTENT_DISPOSITION, NULL, 
                            szBuf, &(dwLen = sizeof(szBuf)), &dwIndex))
    {
        // Could have multiple tokens in the Content-Disposition header. Scan for the "filename" token.
        ptr = pToken = szBuf;
        while (ptr = StrTokExA(&pToken, ";"))
        {
            // Skip any leading ws in token.
            SKIPWS(ptr);

            // Compare against "filename".
            if (!strnicmp(ptr, FILENAME_SZ, FILENAME_LEN))
            {
                // Found it.
                ptr += FILENAME_LEN;

                // Skip ws before '='.
                SKIPWS(ptr);

                // Must have '='
                if (*ptr == '=')
                {
                    // Skip any ws after '=' and point
                    // to beginning of the file name
                    ptr++;
                    SKIPWS(ptr);

                    // Skip past any quotes
                    if (*ptr == '\"')
                        ptr++;

                    SKIPWS(ptr);

                    cbFileName = strlen(ptr);

                    if (cbFileName)
                    {
                        // Ignore any trailing quote.
                        if (ptr[cbFileName-1] == '\"')
                            cbFileName--;
                            
                        memcpy(szFileName, ptr, cbFileName);
                        szFileName[cbFileName] = '\0';
                        _lpszFileName = NewString(szFileName, MAX_PATH);
                    }
                }
                break;
            }
        }
    }

    // Either no Content-disposition header or filename not parsed, so try to figure out
    // the file extension using the Content-Type header
    if (!_lpszFileName)
    {
        DWORD dwMimeLen = sizeof(szBuf);
        if ((HttpQueryInfoA(_hRequest, WINHTTP_QUERY_CONTENT_ENCODING, NULL,
            szBuf, &dwMimeLen, 0)) && StrCmpNI(szBuf,"binary",6) )
        {
            // if there is content encoding, we should not use
            // content-type for file extension

            //Modifying this for bug 98611.
            //For 'binary' encoding use the Content-Type to find extension
            _lpszFileExtension = NULL;
        }

        else if (HttpQueryInfoA(_hRequest, HTTP_QUERY_CONTENT_TYPE, NULL,
                szBuf, &(dwMimeLen = sizeof(szBuf)), 0))
        {
            dwLen = sizeof(cExt);
            fIsUncertainMime = strnicmp(szBuf, "text/plain", dwMimeLen)==0;

            if (!fIsUncertainMime &&
                GetFileExtensionFromMimeType(szBuf, dwMimeLen, cExt, &dwLen))
            {
                // get past the '.' because the cache expects it that way
                _lpszFileExtension = NewString(&cExt[1], DEFAULT_MAX_EXTENSION_LENGTH);
            }
        }

        //
        // if we couldn't get the MIME type or failed to map it then try to get
        // the file extension from the object name requested
        //

        if (_lpszFileExtension == NULL)
        {
            dwLen = DEFAULT_MAX_EXTENSION_LENGTH + 1;
            LPSTR lpszExt;
            lpszExt = GetFileExtensionFromUrl(GetUrl(), &dwLen);
            if (_lpszFileExtension != NULL)
            {
                _lpszFileExtension = NewString(lpszExt, dwLen);
                _lpszFileExtension[dwLen] = '\0';
            }
        }

        if ((_lpszFileExtension == NULL) && fIsUncertainMime)
        {
            INET_ASSERT(sizeof(szDefaultExtension) < DEFAULT_MAX_EXTENSION_LENGTH);

            _lpszFileExtension = NewString(szDefaultExtension, sizeof(szDefaultExtension));
        }
    }

    DEBUG_PRINT(CACHE, INFO, ("Filename = %s, File extension = %s\n", _lpszFileName, _lpszFileExtension));
    DEBUG_LEAVE(NULL);    
}


PRIVATE BOOL
HTTPCACHE_REQUEST::CreateCacheWriteFile()
/*++

Routine Description:

    Create a file for subsequent cache writes to write the data to

    Similar to INTERNET_CONNECT_HANDLE_OBJECT::BeginCacheWrite
    in wininet

Pre-condition: 

    SetFilenameAndExtForCacheWrite() has been called

Side Effects: 

    _lpszCacheWriteLocalFilename will contain the full path of the file at 
    which the cache contents will be written to

    _hCacheWriteFile will contain the handle to the cache write file

Return Value:

    BOOL indicating whether the call succeeds or not
    
--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::CreateCacheWriteFile",
                 NULL
                 ));

    TCHAR szFileName[MAX_PATH];
    BOOL fResult = FALSE;
    
    // NOTE:  We are not making use of _lpszFileName from the
    // previous call to SetFilenameAndExtForCacheWrite()...
    // Possibly a bug??
    if (!CreateUrlCacheEntryA(GetUrl(), 0, _lpszFileExtension, 
                             szFileName, 0))
    {
        DEBUG_PRINT(CACHE, 
                      ERROR, 
                      ("Error:  CreateUrlCacheEntry failed for %s\n",
                      GetUrl()));
        goto quit;
    }
    else
    {
        DEBUG_PRINT(CACHE, INFO, ("Cache filename = %q\n", szFileName));
    }

    // monkey around with the local filename (szFileName)
    _hCacheWriteFile = CreateFile(szFileName, 
                              GENERIC_WRITE, 
                              0, 
                              NULL, 
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, 
                              NULL);
    if (_hCacheWriteFile == INVALID_HANDLE_VALUE) 
    {
        DEBUG_PRINT (CACHE, INFO, ("CreateFile API failed %x\n", GetLastError()));
        if( _hCacheWriteFile != INVALID_HANDLE_VALUE ) 
        {
            CloseHandle(_hCacheWriteFile);
            _hCacheWriteFile = INVALID_HANDLE_VALUE;
        }

        DeleteFile(szFileName);
        goto quit;
    }

    INET_ASSERT(_lpszCacheWriteLocalFilename == NULL);
    _lpszCacheWriteLocalFilename = NewString(szFileName);

    if (!_lpszCacheWriteLocalFilename) 
    {
        if (_lpszCacheWriteLocalFilename != NULL) 
        {
            (void)FREE_MEMORY((HLOCAL)_lpszCacheWriteLocalFilename);
            _lpszCacheWriteLocalFilename = NULL;

            DeleteFile(szFileName);
        }
    }

    INET_ASSERT(_hCacheWriteFile != INVALID_HANDLE_VALUE);
    fResult = TRUE;
    
quit:
    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE BOOL
HTTPCACHE_REQUEST::WriteToCacheFile(
    LPBYTE lpBuffer, 
    DWORD dwBufferLen, 
    LPDWORD lpdwBytesWritten
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::WriteToCacheFile",
                 "%d",
                 dwBufferLen
                 ));

    BOOL fResult;
    fResult =  WriteFile(_hCacheWriteFile,
                     lpBuffer,
                     dwBufferLen,
                     lpdwBytesWritten,
                     NULL );
    
    _RealCacheFileSize += *lpdwBytesWritten;
    
    DEBUG_PRINT(CACHE, 
                 INFO, 
                 ("%d bytes written to the cache file %s", 
                 *lpdwBytesWritten, 
                 _lpszCacheWriteLocalFilename));

    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE BOOL
HTTPCACHE_REQUEST::FCanWriteHTTP1_1ResponseToCache(
    BOOL * fNoCache
    )
/*
Routine Description:

    Examine the cache-control headers and MIME exclusion list 
    to see if the given resource can be written to cache storage

    Similar to HTTP_REQUEST_HANDLE_OBJECT::FCanWiteToCache in Wininet

Precondition: 

    The resource comes from a HTTP 1.1 server

Side Effects:

    NONE
    
Parameters:

    fNoCache - indicate whether the cache entry must not be remained from the cache 
               because the response contains certain explicitly/implicitly HTTP headers 
--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "HTTPCACHE_REQUEST::FCanWriteHTTP1_1ResponseToCache",
                 NULL
                 ));
        
    BOOL ok = FALSE;
    BOOL fVary = FALSE;
    
    *fNoCache = FALSE;     // Set fNoCache if there is pragma: no-cache

    DWORD index;
    TCHAR szBuf[1024];
    DWORD dwBufLen = sizeof(szBuf);

    //
    // Also set fNoCache if there is Cache-Control: no-cache or no-store header,
    // if there is a Cache-Control: private header and we're *not* on NT with user profiles,
    // or any Vary: headers. These are only checked for HTTP 1.1 servers.
    //
    CHAR *ptr, *pToken;
    index = 0;

    // Scan for Cache-Control header.
    dwBufLen = sizeof(szBuf);
    while (HttpQueryInfoA(_hRequest,
                          WINHTTP_QUERY_CACHE_CONTROL,
                          NULL,
                          szBuf,
                          &dwBufLen,
                          &index))
    {
        // Check for no-cache or no-store or private.
        CHAR chTemp = szBuf[dwBufLen];

        szBuf[dwBufLen] = '\0';
        pToken = ptr = szBuf;
        // Parse a token from the string; test for sub headers.
        while (*pToken != '\0')
        {
            SKIPWS(pToken);

            // no-cache, no-store.
            if (strnicmp(NO_CACHE_SZ, pToken, NO_CACHE_LEN) == 0)
            {
                *fNoCache = TRUE;
                break;
            }

            if( strnicmp(NO_STORE_SZ, pToken, NO_STORE_LEN) == 0) 
            {
                *fNoCache = TRUE;
            }

            // The PRIVATE_SZ tag should be handled one level higher
            // private.
            // if (strnicmp(PRIVATE_SZ, pToken, PRIVATE_LEN) == 0)
            // {
            //     SetPerUserItem(TRUE);
            // }

            while (*pToken != '\0')
            {
                if ( *pToken == ',')
                {
                    pToken++;
                    break;
                }

                pToken++;
            }

        } // while (*pToken != '\0')

        // We've finished parsing it, now return our terminator back to its proper place
        szBuf[dwBufLen] = chTemp;

        // If fNoCache, we're done. Break out of switch.
        if (*fNoCache)
            break;

        index++;

    } // while FastQueryResponseHeader == ERROR_SUCCESS

    // Finally, check if any Vary: headers exist, EXCEPT "Vary: User-Agent"
    dwBufLen = sizeof(szBuf);
    if (HttpQueryInfoA(_hRequest,
                      HTTP_QUERY_VARY,
                      NULL,
                      szBuf,
                      &dwBufLen,
                      NULL) == TRUE       
       && !(dwBufLen == USER_AGENT_LEN && !strnicmp (szBuf, USER_AGENT_SZ, dwBufLen)) )
    {
        fVary = TRUE;
        goto quit;
    }

    DWORD StatusCode;
    DWORD dwSize = sizeof(DWORD);
    // accept HTTP/1.0 or downlevel server responses
    if (HttpQueryInfoA(_hRequest,
                      WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                      NULL,
                      &StatusCode,
                      &dwSize,
                      NULL)) 
    {
        if (StatusCode == HTTP_STATUS_OK || StatusCode == 0)
        {
            dwBufLen = sizeof(szBuf);
            if (HttpQueryInfoA(_hRequest,
                              WINHTTP_QUERY_CONTENT_TYPE,
                              NULL,
                              szBuf,
                              &dwBufLen,
                              NULL)) 
            {
                if (::FExcludedMimeType(szBuf, dwBufLen))
                {
                    ok = FALSE;
                    DEBUG_PRINT(CACHE, 
                                 INFO, 
                                 ("%s Mime Excluded from caching\n",
                                 szBuf
                                 ));
                    goto quit;
                }
            }

            // BUGBUGBUG:  What are we going to do with the Vary header???????
            ok = TRUE;
            goto quit;
        }
    }
    
quit:
    DEBUG_LEAVE(ok);
    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\idl\httprequestid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 2000                    **
//*********************************************************************


//;begin_internal
#ifndef __HTTPREQUESTID_H__
#define __HTTPREQUESTID_H__
//;end_internal

#define DISPID_HTTPREQUEST_BASE                     0x00000001


#define DISPID_HTTPREQUEST_OPEN                     (DISPID_HTTPREQUEST_BASE)
#define DISPID_HTTPREQUEST_SETREQUESTHEADER         (DISPID_HTTPREQUEST_BASE + 1)
#define DISPID_HTTPREQUEST_GETRESPONSEHEADER        (DISPID_HTTPREQUEST_BASE + 2)
#define DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS    (DISPID_HTTPREQUEST_BASE + 3)
#define DISPID_HTTPREQUEST_SEND                     (DISPID_HTTPREQUEST_BASE + 4)
#define DISPID_HTTPREQUEST_OPTION                   (DISPID_HTTPREQUEST_BASE + 5)
#define DISPID_HTTPREQUEST_STATUS                   (DISPID_HTTPREQUEST_BASE + 6)
#define DISPID_HTTPREQUEST_STATUSTEXT               (DISPID_HTTPREQUEST_BASE + 7)
#define DISPID_HTTPREQUEST_RESPONSETEXT             (DISPID_HTTPREQUEST_BASE + 8)
#define DISPID_HTTPREQUEST_RESPONSEBODY             (DISPID_HTTPREQUEST_BASE + 9)
#define DISPID_HTTPREQUEST_RESPONSESTREAM           (DISPID_HTTPREQUEST_BASE + 10)
#define DISPID_HTTPREQUEST_ABORT                    (DISPID_HTTPREQUEST_BASE + 11)
#define DISPID_HTTPREQUEST_SETPROXY                 (DISPID_HTTPREQUEST_BASE + 12)
#define DISPID_HTTPREQUEST_SETCREDENTIALS           (DISPID_HTTPREQUEST_BASE + 13)
#define DISPID_HTTPREQUEST_WAITFORRESPONSE          (DISPID_HTTPREQUEST_BASE + 14)
#define DISPID_HTTPREQUEST_SETTIMEOUTS              (DISPID_HTTPREQUEST_BASE + 15)

//;begin_internal
#endif // __HTTPREQUESTID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\httpcache\test\testhttpcache.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
// 
// Test driver for the WinHTTP-UrlCache interaction layer
//

#include <windows.h>
#include <winhttp.h>
#include <internal.h>
#include <conio.h>
#include <stdio.h>
#include <tchar.h>
#include <fstream.h>
#include <stdlib.h>

//////////////////////////////////////////////////////////////////////////////////////////////////

// Globals
wchar_t g_wszHost[50];
wchar_t g_wszPath[50];
DWORD g_dwTotalRequests;
DWORD g_dwNumConnections;

// Hard-coded #define
//#define HOSTNAME L"t-eddieng"
//#define HOSTNAME "www.w3.org"
//#define HOSTNAME "msw"
LPCWSTR szObjectName[] = { L"/?action=a", 
                             L"default.asp", 
                             L"/", 
                             L"/default.asp", 
                             L"/?action=a", 
                             L"/?action=b", 
                             L"/default.asp?action=a", 
                             L"/?action=a" 
                           };

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//
#if 0
void TestCase1() {
    HINTERNET hSession;
    HINTERNET hConnect;
    HINTERNET hRequest;
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Cache Extension", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    hConnect = WinHttpConnect(hSession, HOSTNAME, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL) {
        printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
        goto done;
    }

for (int i=0; i<1; i++) 
{
    // Create a HTTP request handle
    hRequest = WinHttpCacheOpenRequest( hConnect, L"GET", szObjectName[i], NULL, NULL, NULL, 0);
    if (hRequest == NULL) {
        printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
        goto done;
    }

    // Send a Request
    if(!WinHttpCacheSendRequest( hRequest, NULL, 0, NULL, 0, 0, 0))
    {
        printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
        goto done;
    }

    
    // End the request
    if(!WinHttpCacheReceiveResponse( hRequest, NULL))
        printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());
        // intentional fall through...

    // Keep checking for data until there is nothing left.
    do 
    {
        // Check for available data.
        dwSize = 0;
        if (!WinHttpCacheQueryDataAvailable( hRequest, &dwSize))
            printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            ZeroMemory(pszOutBuffer, dwSize+1);

            // Read the Data.
            if (!WinHttpCacheReadData( hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
                printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
            else
                printf("%s", pszOutBuffer);
        
            // Free the memory allocated to the buffer.
            delete [] (LPVOID)pszOutBuffer;
    } while (dwSize>0);

    // There may be problems querying or looking up headers if the resource is from the cache.
    // Test that out here
    WCHAR wszOptionData[2048];
    DWORD dwSize = 2048;
    if (WinHttpQueryOption( hRequest, WINHTTP_OPTION_URL, (LPVOID)wszOptionData, &dwSize))
    {
        printf("WinHttpQueryOption returns dwSize = %d, URL = %S\n", dwSize, wszOptionData);
    }
    else
    {
        printf("Error %u in WinHttpQueryOption.\n", GetLastError());
    }        

}

done:
    if (hRequest != NULL) WinHttpCacheCloseHandle(hRequest);
    if (hConnect != NULL) WinHttpCacheCloseHandle(hConnect);
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);

}




//////////////////////////////////////////////////////////////////////////////////////////////////
//
// TestCase2 - weird case (call QueryDataAvailable before ReceiveResponse)
//
// Get from network all the time
//
void TestCase2() {
    HINTERNET hSession;
    HINTERNET hConnect;
    HINTERNET hRequest;
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Cache Extension", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    hConnect = WinHttpConnect(hSession, HOSTNAME, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL) {
        printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
        goto done;
    }

for (int i=0; i<4; i++) 
{
    // Create a HTTP request handle
    hRequest = WinHttpCacheOpenRequest( hConnect, L"GET", szObjectName[0], NULL, NULL, NULL, 0);
    if (hRequest == NULL) {
        printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
        goto done;
    }

    // Send a Request
    if(!WinHttpCacheSendRequest( hRequest, NULL, 0, NULL, 0, 0, 0))
    {
        printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
        goto done;
    }


    // End the request
    if(!WinHttpCacheReceiveResponse( hRequest, NULL))
        printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());
        // intentional fall through...

    // There may be problems querying or looking up headers if the resource is from the cache.
    // Test that out here
    // TEST CASE:  Calling WinHttpQueryOption and WinHttpQueryHeaders before WinHttpReceiveResponse
    WCHAR wszOptionData[2048];
    DWORD dwSize = 2048;

/*
    if (WinHttpQueryOption(hRequest, WINHTTP_OPTION_URL, (LPVOID)wszOptionData, &dwSize))
    {
        printf("WinHttpQueryOption returns dwSize = %d, URL = %S\n", dwSize, wszOptionData);
    }
    else
    {
        printf("Error %u in WinHttpQueryOption.\n", GetLastError());
    }        


    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_LAST_MODIFIED, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns last_modified = %S\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());
    
    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CONTENT_LENGTH, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns content length = %S\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns all headers = \n%S\n\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());
*/
    // Keep checking for data until there is nothing left.
    do 
    {
        // Check for available data.
        dwSize = 0;
        if (!WinHttpCacheQueryDataAvailable( hRequest, &dwSize))
        {
            printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());
            goto done;
        }
            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            ZeroMemory(pszOutBuffer, dwSize+1);

            // Read the Data.
            if (!WinHttpCacheReadData( hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
            {    
                printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
                goto done;
            }
            else
                printf("%s", pszOutBuffer);
        
            // Free the memory allocated to the buffer.
            delete [] (LPVOID)pszOutBuffer;
    } while (dwSize>0);

}

done:
    if (hRequest != NULL) WinHttpCacheCloseHandle(hRequest);
    if (hConnect != NULL) WinHttpCacheCloseHandle(hConnect);
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void TestCase3() {
    HINTERNET hSession;
    HINTERNET hConnect;
    HINTERNET hRequest;
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Cache Extension", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    hConnect = WinHttpConnect(hSession, HOSTNAME, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL) {
        printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
        goto done;
    }

for (int i=0; i<1; i++) 
{
    // Create a HTTP request handle
    hRequest = WinHttpCacheOpenRequest( hConnect, L"GET", szObjectName[i], NULL, NULL, NULL, 0);
    if (hRequest == NULL) {
        printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
        goto done;
    }

    // Send a Request
    if(!WinHttpCacheSendRequest( hRequest, NULL, 0, NULL, 0, 0, 0))
    {
        printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
        goto done;
    }


    // End the request
    if(!WinHttpCacheReceiveResponse( hRequest, NULL))
        printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());
        // intentional fall through...

    // There may be problems querying or looking up headers if the resource is from the cache.
    // Test that out here
    // TEST CASE:  Calling WinHttpQueryOption and WinHttpQueryHeaders before WinHttpReceiveResponse
    WCHAR wszOptionData[2048];
    DWORD dwSize = 2048;

    if (WinHttpQueryOption(hRequest, WINHTTP_OPTION_URL, (LPVOID)wszOptionData, &dwSize))
    {
        printf("WinHttpQueryOption returns URL - dwSize = %d, URL = %S\n", dwSize, wszOptionData);
    }
    else
    {
        printf("Error %u in WinHttpQueryOption.\n", GetLastError());
    }        

    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_EXPIRES, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns expires = %S\n", wszOptionData);
    else
        printf ("Error %u in expires.\n", GetLastError());

    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_LAST_MODIFIED, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns last_modified = %S\n", wszOptionData);
    else
        printf ("Error %u in last-modified.\n", GetLastError());


    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_IF_MATCH, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns if-match = %S\n", wszOptionData);
    else
        printf ("Error %u in If-match.\n", GetLastError());
    
    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CONTENT_LENGTH, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns content length = %S\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

    dwSize = 2048;
    if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
        printf ("WinHttpQueryHeaders returns all headers = \n%S\n\n", wszOptionData);
    else
        printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

    // Keep checking for data until there is nothing left.
    do 
    {
        // Check for available data.
        dwSize = 0;
        if (!WinHttpCacheQueryDataAvailable( hRequest, &dwSize))
        {
            printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());
            goto done;
        }

        // Allocate space for the buffer.
        pszOutBuffer = new char[dwSize+1];
        ZeroMemory(pszOutBuffer, dwSize+1);

        // Read the Data.
        if (!WinHttpCacheReadData( hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
        {    
            printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
            goto done;
        }
        else
            printf("%s", pszOutBuffer);
        
        // Free the memory allocated to the buffer.
        delete [] (LPVOID)pszOutBuffer;
    } while (dwSize>0);

}

done:
    if (hRequest != NULL) WinHttpCacheCloseHandle(hRequest);
    if (hConnect != NULL) WinHttpCacheCloseHandle(hConnect);
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Test multiple open connect handles and open request handles synchronously
//
void TestCase4(DWORD dwNumOfConnect, DWORD dwNumOfRequest) {
    HINTERNET hSession;
    HINTERNET * hConnect;
    HINTERNET * hRequest;

    hConnect = new HINTERNET[dwNumOfConnect];
    hRequest = new HINTERNET[dwNumOfRequest];
    
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Cache", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    for (DWORD i=0; i<dwNumOfConnect; i++)
    {
        hConnect[i] = WinHttpConnect(hSession, HOSTNAME, INTERNET_DEFAULT_HTTP_PORT, 0);
        if (hConnect[i] == NULL) 
        {
            printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
            goto done;
        }
    }

    // Create a HTTP request handle
    for (DWORD i=0; i<dwNumOfRequest; i++)
    {
        hRequest[i] = WinHttpCacheOpenRequest( hConnect[0], L"GET", szObjectName[0], NULL, NULL, NULL, 0);
        if (hRequest[i] == NULL) 
		{
            printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
            goto done;
        }

        // Send a Request
        if(!WinHttpCacheSendRequest( hRequest[i], NULL, 0, NULL, 0, 0, 0))
        {
            printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
            goto done;
        }

        // End the request
        if(!WinHttpCacheReceiveResponse( hRequest[i], NULL))
            printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());

    }

done:
    for (DWORD i=0; i<dwNumOfRequest; i++)
        if (hRequest[i] != NULL) WinHttpCacheCloseHandle(hRequest[i]);

    delete [] hRequest;

    for (DWORD i=0; i<dwNumOfConnect; i++)
        if (hConnect[i] != NULL) WinHttpCacheCloseHandle(hConnect[i]);

    delete [] hConnect;

    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);

}
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void TestFullRead() {
    HINTERNET hSession;
    HINTERNET * hConnect;
    HINTERNET * hRequest;

    hConnect = new HINTERNET[g_dwNumConnections];
    hRequest = new HINTERNET[g_dwTotalRequests];
    
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Agent", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    for (DWORD i=0; i<g_dwNumConnections; i++)
    {
        hConnect[i] = WinHttpConnect(hSession, g_wszHost, INTERNET_DEFAULT_HTTP_PORT, 0);
        if (hConnect[i] == NULL) 
        {
            printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
            goto done;
        }
    }

    // Create a HTTP request handle
    for (DWORD i=0; i<g_dwTotalRequests; i++)
    {
        printf ("Interation %d in request loop.\n\n", i);
        
        hRequest[i] = WinHttpCacheOpenRequest( hConnect[0], L"GET", g_wszPath, NULL, NULL, NULL, 0);
        if (hRequest[i] == NULL) 
		{
            printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
            goto done;
        }

        // Send a Request
        if(!WinHttpCacheSendRequest( hRequest[i], NULL, 0, NULL, 0, 0, 0))
        {
            printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
            goto done;
        }

        // End the request
        if(!WinHttpCacheReceiveResponse( hRequest[i], NULL))
            printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());

        WCHAR wszOptionData[2048];
        dwSize = 2048;
        if (WinHttpQueryHeaders(hRequest[i], WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
            printf ("WinHttpQueryHeaders returns all headers = \n%S\n\n", wszOptionData);
        else
            printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

        // Keep checking for data until there is nothing left.
        do 
        {
            // Check for available data.
            dwSize = 0;
            if (!WinHttpCacheQueryDataAvailable( hRequest[i], &dwSize))
            {
                printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());
                goto done;
            }

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            ZeroMemory(pszOutBuffer, dwSize+1);

            // Read the Data.
            if (!WinHttpCacheReadData( hRequest[i], (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
            {    
                printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
                goto done;
            }
            else
                printf("%s", pszOutBuffer);
            
            // Free the memory allocated to the buffer.
            delete [] (LPVOID)pszOutBuffer;
        } while (dwSize>0);

    }

done:
    for (DWORD i=0; i<g_dwTotalRequests; i++)
        if (hRequest[i] != NULL) WinHttpCacheCloseHandle(hRequest[i]);

    delete [] hRequest;
    
    for (DWORD i=0; i<g_dwNumConnections; i++)
        if (hConnect[i] != NULL) WinHttpCacheCloseHandle(hConnect[i]);

    delete [] hConnect;
    
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);

}




//////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void TestPartialRead() {
    HINTERNET hSession;
    HINTERNET * hConnect;
    HINTERNET * hRequest;

    hConnect = new HINTERNET[g_dwNumConnections];
    hRequest = new HINTERNET[g_dwTotalRequests];
    
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    
    // Initiate a HTTP session
    hSession = WinHttpCacheOpen(L"WinHTTP Agent", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, CACHE_FLAG_DEFAULT_SETTING);
    if (hSession == NULL) {
        printf("Error %u in WinHttpCacheOpen.\n", GetLastError());
        goto done;
    }

    // Connect to a server
    for (DWORD i=0; i<g_dwNumConnections; i++)
    {
        hConnect[i] = WinHttpConnect(hSession, g_wszHost, INTERNET_DEFAULT_HTTP_PORT, 0);
        if (hConnect[i] == NULL) 
        {
            printf("Error %u in WinHttpCacheConnect.\n", GetLastError());
            goto done;
        }
    }

    // Create a HTTP request handle
    for (DWORD i=0; i<g_dwTotalRequests; i++)
    {
        printf ("Interation %d in request loop.\n\n", i);
        
        hRequest[i] = WinHttpCacheOpenRequest( hConnect[0], L"GET", g_wszPath, NULL, NULL, NULL, 0);
        if (hRequest[i] == NULL) 
		{
            printf("Error %u in WinHttpCacheOpenRequest.\n", GetLastError());
            goto done;
        }

        // Send a Request
        if(!WinHttpCacheSendRequest( hRequest[i], NULL, 0, NULL, 0, 0, 0))
        {
            printf("Error %u in WinHttpCacheSendRequest.\n", GetLastError());
            goto done;
        }

        // End the request
        if(!WinHttpCacheReceiveResponse( hRequest[i], NULL))
            printf("Error %u in WinHttpCacheReceiveResponse.\n", GetLastError());

        WCHAR wszOptionData[2048];
        dwSize = 2048;
        if (WinHttpQueryHeaders(hRequest[i], WINHTTP_QUERY_RAW_HEADERS_CRLF, 
                            NULL, (LPVOID)wszOptionData, &dwSize, NULL))
            printf ("WinHttpQueryHeaders returns all headers = \n%S\n\n", wszOptionData);
        else
            printf ("Error %u in WinHttpQueryHeaders.\n", GetLastError());

        // DON'T Keep checking for data until there is nothing left.

            // Check for available data.
            dwSize = 0;
            if (!WinHttpCacheQueryDataAvailable( hRequest[i], &dwSize))
            {
                printf("Error %u in WinHttpCacheQueryDataAvailable.\n", GetLastError());
                goto done;
            }

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            ZeroMemory(pszOutBuffer, dwSize+1);

            // Read the Data.
            if (!WinHttpCacheReadData( hRequest[i], (LPVOID)pszOutBuffer, dwSize, &dwDownloaded))
            {    
                printf("Error %u in WinHttpCacheReadData.\n", GetLastError());
                goto done;
            }
            else
                printf("%s", pszOutBuffer);
            
            // Free the memory allocated to the buffer.
            delete [] (LPVOID)pszOutBuffer;

    }

done:
    for (DWORD i=0; i<g_dwTotalRequests; i++)
        if (hRequest[i] != NULL) WinHttpCacheCloseHandle(hRequest[i]);

    delete [] hRequest;
    
    for (DWORD i=0; i<g_dwNumConnections; i++)
        if (hConnect[i] != NULL) WinHttpCacheCloseHandle(hConnect[i]);

    delete [] hConnect;
    
    if (hSession != NULL) WinHttpCacheCloseHandle(hSession);

}



void __cdecl main(
    int argc,
    CHAR * argv[]
    )
{
    BOOL fPartial = FALSE;
    int iArgStart = 2;
    
    if (argc == 1 || (argc >= 2 && strcmp(argv[1], "/?") == 0))
        goto syntax;

    if (strcmp(argv[1], "/P") == 0 || strcmp(argv[1], "/p") == 0)
        fPartial = TRUE;
    else if (strcmp(argv[1], "/F") == 0 || strcmp(argv[1], "/f") == 0)
        fPartial = FALSE;
    else
    {
        fPartial = FALSE;
        iArgStart = 1;
    }

    if (argc != iArgStart + 4)
    {
        printf ("Error: Invalid number of parameters\n");
        printf ("For help type %s /?\n", argv[0]);
        return;
    }
    
    g_dwTotalRequests = atoi(argv[iArgStart + 2]);
    g_dwNumConnections = atoi(argv[iArgStart + 3]);
    if (g_dwTotalRequests <= 0 || g_dwNumConnections <= 0)
    {
        printf ("Error: Number of requests and number of connections must be greater than 0\n");
        printf ("For help type %s /?\n", argv[0]);
        return;
    }
        
    MultiByteToWideChar(CP_ACP, 0, argv[iArgStart + 0], -1, g_wszHost, 50);
    MultiByteToWideChar(CP_ACP, 0, argv[iArgStart + 1], -1, g_wszPath, 50);

    if (fPartial == TRUE)
        TestPartialRead();
    else
        TestFullRead();

    return;
    
syntax:
    printf ("Test driver for the WinHTTP caching layer.\n\n");
    printf ("%s [/F | /P] ServerName ObjectName NumRequests NumConn\n\n", argv[0]);
    printf ("   /F                  Full GET request (default setting)\n");
    printf ("   /P                  Partial GET request (i.e. interrupt before the entire file is downloaded)\n");
    printf ("   ServerName\n");
    printf ("   ObjectName\n");
    printf ("   NumReqPerConn\n");
    printf ("   NumConn             URL you want to connect to, and how many loops do you want.\n");           
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\ihttprequest\httprequest.cxx ===
/*
 *  HttpRequest.cpp
 *
 *  WinHttp.WinHttpRequest COM component
 *
 *  Copyright (C) 2000 Microsoft Corporation. All rights reserved. *
 *
 *  Much of this code was stolen from our Xml-Http friends over in
 *  inetcore\xml\http\xmlhttp.cxx. Thanks very much!
 *
 */
#include <wininetp.h>
#include "httprequest.hxx"
#include <olectl.h>


/////////////////////////////////////////////////////////////////////////////
// private function prototypes
static void    WideCharToUtf8(WCHAR * buffer, UINT cch, BYTE * bytebuffer, UINT * cb);
static HRESULT BSTRToUTF8(char ** psz, DWORD * pcbUTF8, BSTR bstr);
static HRESULT AsciiToBSTR(BSTR * pbstr, char * sz, int cch);
static HRESULT BSTRToAscii(char ** psz, BSTR bstr);
static BSTR    GetBSTRFromVariant(VARIANT varVariant);
static BOOL    GetBoolFromVariant(VARIANT varVariant, BOOL fDefault);
static DWORD   GetDwordFromVariant(VARIANT varVariant, DWORD dwDefault);
static long    GetLongFromVariant(VARIANT varVariant, long lDefault);
static HRESULT CreateVector(VARIANT * pVar, const BYTE * pData, DWORD cElems);
static HRESULT ReadFromStream(char ** ppData, ULONG * pcbData, IStream * pStm);
static void    MessageLoop();
static DWORD   UpdateTimeout(DWORD dwTimeout, DWORD dwStartTime);
static HRESULT FillExcepInfo(HRESULT hr, EXCEPINFO * pExcepInfo);
static BOOL    IsValidVariant(VARIANT v);

static BOOL         s_fWndClassRegistered;
static const char * s_szWinHttpEventMarshallerWndClass = "_WinHttpEventMarshaller";


#define SafeRelease(p) \
{ \
    if (p) \
        (p)->Release();\
    (p) = NULL;\
}

#ifndef HWND_MESSAGE
#define HWND_MESSAGE    ((HWND)-3)
#endif


inline BOOL IsValidBstr(BSTR bstr)
{
    // A BSTR can be NULL, or if non-NULL, it should at least
    // point to a 2-byte terminating NULL character.
    return (bstr == NULL) || (!IsBadReadPtr(bstr, 2));
}



#ifndef WINHTTP_STATIC_LIBRARY
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void ** ppv)
{
    if (rclsid != CLSID_WinHttpRequest)
        return CLASS_E_CLASSNOTAVAILABLE;

    if (riid != IID_IClassFactory || ppv == NULL)
        return E_INVALIDARG;

    CClassFactory * pCF = New CClassFactory();

    if (pCF)
    {
        *ppv = static_cast<IClassFactory *>(pCF);
        pCF->AddRef();
        return NOERROR;
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }
}
CClassFactory::CClassFactory()
{
    _cRefs = 0;
}


STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (ppvObject == NULL)
        return E_INVALIDARG;

    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        *ppvObject = static_cast<IClassFactory *>(this);
        AddRef();
        return NOERROR;
    }
    else
        return E_NOINTERFACE;
}


ULONG STDMETHODCALLTYPE CClassFactory::AddRef()
{
    return ++_cRefs;
}

ULONG STDMETHODCALLTYPE CClassFactory::Release()
{
    if (--_cRefs == 0)
    {
        delete this;
        return 0;
    }

    return _cRefs;
}


STDMETHODIMP
CClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject)
{
    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    if (ppvObject == NULL)
        return E_INVALIDARG;

    return CreateHttpRequest(riid, ppvObject);
}


STDMETHODIMP
CClassFactory::LockServer(BOOL fLock)
{
    return NOERROR;
}

#else

STDAPI WinHttpCreateHttpRequestComponent(REFIID riid, void ** ppvObject)
{
    return CreateHttpRequest(riid, ppvObject);
}

#endif //WINHTTP_STATIC_LIBRARY



STDMETHODIMP
CreateHttpRequest(REFIID riid, void ** ppvObject)
{
    CHttpRequest *  pHttpRequest = New CHttpRequest();
    HRESULT         hr;

    if (pHttpRequest)
    {
        hr = pHttpRequest->QueryInterface(riid, ppvObject);

        if (FAILED(hr))
        {
            delete pHttpRequest;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}




/*
 *  CHttpRequest::CHttpRequest constructor
 *
 */

CHttpRequest::CHttpRequest()
{
    Initialize();
}



/*
 *  CHttpRequest::~CHttpRequest destructor
 *
 */

CHttpRequest::~CHttpRequest()
{
    ReleaseResources();
}


HRESULT STDMETHODCALLTYPE
CHttpRequest::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = NOERROR;

    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (riid == IID_IWinHttpRequest || riid == IID_IDispatch || riid == IID_IUnknown)
    {
        *ppv = static_cast<IWinHttpRequest *>(this);
        AddRef();
    }
    else if (riid == IID_IConnectionPointContainer)
    {
        *ppv = static_cast<IConnectionPointContainer *>(this);
        AddRef();
    }
    else if (riid == IID_IProvideClassInfo)
    {
        *ppv = static_cast<IProvideClassInfo *>(static_cast<IProvideClassInfo2 *>(this));
        AddRef();
    }
    else if (riid == IID_IProvideClassInfo2)
    {
        *ppv = static_cast<IProvideClassInfo2 *>(this);
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}



ULONG STDMETHODCALLTYPE
CHttpRequest::AddRef()
{
    if (GetCurrentThreadId() == _dwMainThreadId)
        ++_cRefsOnMainThread;

    return InterlockedIncrement(&_cRefs);
}


ULONG STDMETHODCALLTYPE
CHttpRequest::Release()
{
    if (GetCurrentThreadId() == _dwMainThreadId)
    {
        if ((--_cRefsOnMainThread == 0) && _fAsync)
        {
            // Clean up the Event Marshaller. This must be done
            // on the main thread.
            _CP.ShutdownEventSinksMarshaller();

            // If the worker thread is still running, abort it
            // and wait for it to run down.
            Abort();
        }
    }

    DWORD cRefs  = InterlockedDecrement(&_cRefs);

    if (cRefs == 0)
    {
        delete this;
        return 0;
    }
    else
        return cRefs;
}


HRESULT
CHttpRequest::GetHttpRequestTypeInfo(REFGUID guid, ITypeInfo ** ppTypeInfo)
{
    HRESULT hr = NOERROR;

    ITypeLib *  pTypeLib;
    char        szPath[MAX_PATH];
    OLECHAR     wszPath[MAX_PATH];

    GetModuleFileName(GlobalDllHandle, szPath, MAX_PATH);

    MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);

    hr = LoadTypeLib(wszPath, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = pTypeLib->GetTypeInfoOfGuid(guid, ppTypeInfo);

        pTypeLib->Release();
    }

    return hr;
}

STDMETHODIMP
CHttpRequest::GetTypeInfoCount(UINT * pctinfo)
{
    if (!pctinfo)
        return E_INVALIDARG;

    *pctinfo = 1;

    return NOERROR;
}


STDMETHODIMP
CHttpRequest::GetTypeInfo(UINT iTInfo, LCID, ITypeInfo ** ppTInfo)
{
    if (!ppTInfo)
        return E_INVALIDARG;

    *ppTInfo = NULL;

    if (iTInfo != 0)
        return DISP_E_BADINDEX;

    if (!_pTypeInfo)
    {
        HRESULT hr = GetHttpRequestTypeInfo(IID_IWinHttpRequest, &_pTypeInfo);

        if (FAILED(hr))
            return hr;
    }

    *ppTInfo = _pTypeInfo;
    _pTypeInfo->AddRef();

    return NOERROR;
}


struct IDMAPPING
{
    const OLECHAR * wszMemberName;
    DISPID          dispId;
};

static const IDMAPPING IdMapping[] =
{
    { L"Open",                  DISPID_HTTPREQUEST_OPEN },
    { L"SetRequestHeader",      DISPID_HTTPREQUEST_SETREQUESTHEADER },
    { L"Send",                  DISPID_HTTPREQUEST_SEND },
    { L"Status",                DISPID_HTTPREQUEST_STATUS },
    { L"WaitForResponse",       DISPID_HTTPREQUEST_WAITFORRESPONSE },
    { L"GetResponseHeader",     DISPID_HTTPREQUEST_GETRESPONSEHEADER },
    { L"ResponseBody",          DISPID_HTTPREQUEST_RESPONSEBODY },
    { L"ResponseText",          DISPID_HTTPREQUEST_RESPONSETEXT },
    { L"ResponseStream",        DISPID_HTTPREQUEST_RESPONSESTREAM },
    { L"StatusText",            DISPID_HTTPREQUEST_STATUSTEXT },
    { L"SetCredentials",        DISPID_HTTPREQUEST_SETCREDENTIALS },
    { L"SetProxy",              DISPID_HTTPREQUEST_SETPROXY },
    { L"GetAllResponseHeaders", DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS },
    { L"Abort",                 DISPID_HTTPREQUEST_ABORT },
    { L"SetTimeouts",           DISPID_HTTPREQUEST_SETTIMEOUTS },
    { L"Option",                DISPID_HTTPREQUEST_OPTION }
};


STDMETHODIMP
CHttpRequest::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames,
    UINT        cNames,
    LCID        ,
    DISPID *    rgDispId)
{
    if (riid != IID_NULL)
        return E_INVALIDARG;

    HRESULT     hr = NOERROR;

    if (cNames > 0)
    {
        hr = DISP_E_UNKNOWNNAME;

        for (int i = 0; i < (sizeof(IdMapping)/sizeof(IdMapping[0])); i++)
        {
            if (StrCmpIW(rgszNames[0], IdMapping[i].wszMemberName) == 0)
            {
                hr = NOERROR;
                rgDispId[0] = IdMapping[i].dispId;
                break;
            }
        }
    }

    return hr;
}


// _DispGetOptionalParam
//
// Helper routine to fetch optional parameters. If DispGetParam returns
// DISP_E_PARAMNOTFOUND, the error is converted to NOERROR.
//
static inline HRESULT _DispGetOptionalParam
(
    DISPPARAMS *    pDispParams,
    DISPID          dispid,
    VARTYPE         vt,
    VARIANT *       pvarResult,
    unsigned int *  puArgErr
)
{
    HRESULT hr = DispGetParam(pDispParams, dispid, vt, pvarResult, puArgErr);

    return (hr == DISP_E_PARAMNOTFOUND) ? NOERROR : hr;
}



STDMETHODIMP
CHttpRequest::Invoke(DISPID dispIdMember, REFIID riid,
    LCID,
    WORD            wFlags,
    DISPPARAMS *    pDispParams,
    VARIANT *       pVarResult,
    EXCEPINFO *     pExcepInfo,
    UINT *          puArgErr)
{
    HRESULT         hr = NOERROR;
    unsigned int    uArgErr;


    if (wFlags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT))
        return E_INVALIDARG;

    if (riid != IID_NULL)
        return DISP_E_UNKNOWNINTERFACE;

    if (IsBadReadPtr(pDispParams, sizeof(DISPPARAMS)))
        return E_INVALIDARG;

    if (!puArgErr)
    {
        puArgErr = &uArgErr;
    }
    else if (IsBadWritePtr(puArgErr, sizeof(UINT)))
    {
        return E_INVALIDARG;
    }

    if (pVarResult)
    {
        if (IsBadWritePtr(pVarResult, sizeof(VARIANT)))
            return E_INVALIDARG;

        VariantInit(pVarResult);
    }

    switch (dispIdMember)
    {
    case DISPID_HTTPREQUEST_ABORT:
        {
            hr = Abort();

            break;
        }

    case DISPID_HTTPREQUEST_SETPROXY:
        {
            VARIANT     varProxySetting;
            VARIANT     varProxyServer;
            VARIANT     varBypassList;

            VariantInit(&varProxySetting);
            VariantInit(&varProxyServer);
            VariantInit(&varBypassList);

            hr = DispGetParam(pDispParams, 0, VT_UI4, &varProxySetting, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = _DispGetOptionalParam(pDispParams, 1, VT_BSTR, &varProxyServer, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = _DispGetOptionalParam(pDispParams, 2, VT_BSTR, &varBypassList, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = SetProxy(V_UI4(&varProxySetting), varProxyServer, varBypassList);
            }

            VariantClear(&varProxySetting);
            VariantClear(&varProxyServer);
            VariantClear(&varBypassList);

            break;
        }

    case DISPID_HTTPREQUEST_SETCREDENTIALS:
        {
            VARIANT     varUserName;
            VARIANT     varPassword;
            VARIANT     varAuthTarget;

            VariantInit(&varUserName);
            VariantInit(&varPassword);
            VariantInit(&varAuthTarget);

            hr = DispGetParam(pDispParams, 0, VT_BSTR, &varUserName, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 1, VT_BSTR, &varPassword, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 2, VT_UI4, &varAuthTarget, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = SetCredentials(V_BSTR(&varUserName), V_BSTR(&varPassword),
                            V_UI4(&varAuthTarget));
            }

            VariantClear(&varUserName);
            VariantClear(&varPassword);
            VariantClear(&varAuthTarget);
            
            break;
        }

    case DISPID_HTTPREQUEST_OPEN:
        {
            VARIANT     varMethod;
            VARIANT     varUrl;
            VARIANT     varAsync;

            VariantInit(&varMethod);
            VariantInit(&varUrl);
            VariantInit(&varAsync);

            hr = DispGetParam(pDispParams, 0, VT_BSTR, &varMethod, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 1, VT_BSTR, &varUrl, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = _DispGetOptionalParam(pDispParams, 2, VT_BOOL, &varAsync, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = Open(V_BSTR(&varMethod), V_BSTR(&varUrl), varAsync);
            }

            VariantClear(&varMethod);
            VariantClear(&varUrl);
            VariantClear(&varAsync);

            break;
        }

    case DISPID_HTTPREQUEST_SETREQUESTHEADER:
        {
            VARIANT     varHeader;
            VARIANT     varValue;

            VariantInit(&varHeader);
            VariantInit(&varValue);

            hr = DispGetParam(pDispParams, 0, VT_BSTR, &varHeader, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 1, VT_BSTR, &varValue, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = SetRequestHeader(V_BSTR(&varHeader), V_BSTR(&varValue));
            }

            VariantClear(&varHeader);
            VariantClear(&varValue);

            break;
        }

    case DISPID_HTTPREQUEST_GETRESPONSEHEADER:
        {
            VARIANT     varHeader;

            VariantInit(&varHeader);

            hr = DispGetParam(pDispParams, 0, VT_BSTR, &varHeader, puArgErr);

            if (SUCCEEDED(hr))
            {
                BSTR    bstrValue = NULL;

                hr = GetResponseHeader(V_BSTR(&varHeader), &bstrValue);

                if (SUCCEEDED(hr) && pVarResult)
                {
                    V_VT(pVarResult)   = VT_BSTR;
                    V_BSTR(pVarResult) = bstrValue;
                }
                else
                    SysFreeString(bstrValue);
            }

            VariantClear(&varHeader);

            break;
        }

    case DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS:
        {
            BSTR    bstrResponseHeaders = NULL;

            hr = GetAllResponseHeaders(&bstrResponseHeaders);

            if (SUCCEEDED(hr) && pVarResult)
            {
                V_VT(pVarResult)   = VT_BSTR;
                V_BSTR(pVarResult) = bstrResponseHeaders;
            }
            else
                SysFreeString(bstrResponseHeaders);

            break;
        }

    case DISPID_HTTPREQUEST_SEND:
        {
            if (pDispParams->cArgs <= 1)
            {
                VARIANT     varEmptyBody;

                VariantInit(&varEmptyBody);

                hr = Send((pDispParams->cArgs == 0) ? varEmptyBody : pDispParams->rgvarg[0]);
            }
            else
            {
                hr = DISP_E_BADPARAMCOUNT;
            }
            break;
        }

    case DISPID_HTTPREQUEST_STATUS:
        {
            long    Status;

            hr = get_Status(&Status);

            if (SUCCEEDED(hr) && pVarResult)
            {
                V_VT(pVarResult) = VT_I4;
                V_I4(pVarResult) = Status;
            }
            break;
        }

    case DISPID_HTTPREQUEST_STATUSTEXT:
        {
            BSTR    bstrStatus = NULL;

            hr = get_StatusText(&bstrStatus);

            if (SUCCEEDED(hr) && pVarResult)
            {
                V_VT(pVarResult)   = VT_BSTR;
                V_BSTR(pVarResult) = bstrStatus;
            }
            else
                SysFreeString(bstrStatus);

            break;
        }

    case DISPID_HTTPREQUEST_RESPONSETEXT:
        {
            BSTR    bstrResponse = NULL;

            hr = get_ResponseText(&bstrResponse);

            if (SUCCEEDED(hr) && pVarResult)
            {
                V_VT(pVarResult)   = VT_BSTR;
                V_BSTR(pVarResult) = bstrResponse;
            }
            else
                SysFreeString(bstrResponse);

            break;
        }

    case DISPID_HTTPREQUEST_RESPONSEBODY:
        {
            if (pVarResult)
            {
                hr = get_ResponseBody(pVarResult);
            }
            break;
        }

    case DISPID_HTTPREQUEST_RESPONSESTREAM:
        {
            if (pVarResult)
            {
                hr = get_ResponseStream(pVarResult);
            }
            break;
        }

    case DISPID_HTTPREQUEST_OPTION:
        {
            VARIANT                 varOption;
            WinHttpRequestOption    Option;

            VariantInit(&varOption);

            hr = DispGetParam(pDispParams, 0, VT_I4, &varOption, puArgErr);

            if (FAILED(hr))
                break;

            Option = static_cast<WinHttpRequestOption>(V_I4(&varOption));

            if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
            {
                if (pVarResult)
                {
                    hr = get_Option(Option, pVarResult);
                }
            }
            else if (wFlags & DISPATCH_PROPERTYPUT)
            {
                hr = put_Option(Option, pDispParams->rgvarg[0]);
            }

            VariantClear(&varOption);
            break;
        }

    case DISPID_HTTPREQUEST_WAITFORRESPONSE:
        {
            VARIANT      varTimeout;
            VARIANT_BOOL boolSucceeded;

            VariantInit(&varTimeout);

            hr = _DispGetOptionalParam(pDispParams, 0, VT_I4, &varTimeout, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = WaitForResponse(varTimeout, &boolSucceeded);
            }

            if (pVarResult)
            {
                V_VT(pVarResult)   = VT_BOOL;
                V_BOOL(pVarResult) = boolSucceeded;
            }

            VariantClear(&varTimeout);
            break;
        }

    case DISPID_HTTPREQUEST_SETTIMEOUTS:
        {
            VARIANT     varResolveTimeout;
            VARIANT     varConnectTimeout;
            VARIANT     varSendTimeout;
            VARIANT     varReceiveTimeout;

            VariantInit(&varResolveTimeout);
            VariantInit(&varConnectTimeout);
            VariantInit(&varSendTimeout);
            VariantInit(&varReceiveTimeout);

            hr = DispGetParam(pDispParams, 0, VT_I4, &varResolveTimeout, puArgErr);

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 1, VT_I4, &varConnectTimeout, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 2, VT_I4, &varSendTimeout, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = DispGetParam(pDispParams, 3, VT_I4, &varReceiveTimeout, puArgErr);
            }

            if (SUCCEEDED(hr))
            {
                hr = SetTimeouts(V_I4(&varResolveTimeout), V_I4(&varConnectTimeout),
                            V_I4(&varSendTimeout),
                            V_I4(&varReceiveTimeout));
            }

            VariantClear(&varResolveTimeout);
            VariantClear(&varConnectTimeout);
            VariantClear(&varSendTimeout);
            VariantClear(&varReceiveTimeout);
            break;
        }

    default:
        hr = DISP_E_MEMBERNOTFOUND;
        break;
    }

    if (FAILED(hr) && (pExcepInfo != NULL))
    {
        hr = FillExcepInfo(hr, pExcepInfo);
    }

    return hr;
}

static
HRESULT
FillExcepInfo(HRESULT hr, EXCEPINFO * pExcepInfo)
{
    // Don't create excepinfo for these errors to mimic oleaut behavior.
    if( hr == DISP_E_BADPARAMCOUNT ||
        hr == DISP_E_NONAMEDARGS ||
        hr == DISP_E_MEMBERNOTFOUND ||
        hr == E_INVALIDARG)
    {
        return hr;
    }

    // clear out exception info
    IErrorInfo * pei = NULL;

    pExcepInfo->wCode = 0;
    pExcepInfo->scode = hr;

    // if error info exists, use it
    GetErrorInfo(0, &pei);
   
    if (pei)
    {
        // give back to OLE
        SetErrorInfo(0, pei);

        pei->GetHelpContext(&pExcepInfo->dwHelpContext);
        pei->GetSource(&pExcepInfo->bstrSource);
        pei->GetDescription(&pExcepInfo->bstrDescription);
        pei->GetHelpFile(&pExcepInfo->bstrHelpFile);

        // give complete ownership to OLEAUT
        pei->Release();

        hr = DISP_E_EXCEPTION;
    }

    return hr;

}

STDMETHODIMP
CHttpRequest::GetClassInfo(ITypeInfo ** ppTI)
{
    if (!ppTI)
        return E_POINTER;

    *ppTI = NULL;
    
    return GetHttpRequestTypeInfo(CLSID_WinHttpRequest, ppTI);
}


STDMETHODIMP
CHttpRequest::GetGUID(DWORD dwGuidKind, GUID * pGUID)
{
    if (!pGUID)
        return E_POINTER;

    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
    {
        *pGUID = IID_IWinHttpRequestEvents;
    }
    else
        return E_INVALIDARG;
    
    return NOERROR;
}


STDMETHODIMP
CHttpRequest::EnumConnectionPoints(IEnumConnectionPoints **)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CHttpRequest::FindConnectionPoint(REFIID riid, IConnectionPoint ** ppCP)
{
    if (!ppCP)
        return E_POINTER;

    if (riid == IID_IWinHttpRequestEvents)
    {
        return _CP.QueryInterface(IID_IConnectionPoint, (void **)ppCP);
    }
    else
        return CONNECT_E_NOCONNECTION;
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (!ppvObject)
        return E_INVALIDARG;

    if (riid == IID_IUnknown || riid == IID_IConnectionPoint)
    {
        *ppvObject = static_cast<IUnknown *>(static_cast<IConnectionPoint *>(this));
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE
CHttpRequest::CHttpRequestEventsCP::AddRef()
{
    return Px()->AddRef();
}


ULONG STDMETHODCALLTYPE
CHttpRequest::CHttpRequestEventsCP::Release()
{
    return Px()->Release();
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::GetConnectionInterface(IID * pIID)
{
    if (!pIID)
        return E_POINTER;

    *pIID = IID_IWinHttpRequestEvents;
    return NOERROR;
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::GetConnectionPointContainer
(
    IConnectionPointContainer ** ppCPC
)
{
    if (!ppCPC)
        return E_POINTER;

    return Px()->QueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::Advise(IUnknown * pUnk, DWORD * pdwCookie)
{
    if (!pUnk || !pdwCookie)
    {
        return E_POINTER;
    }

    IWinHttpRequestEvents * pIWinHttpRequestEvents;
    HRESULT                 hr;

    hr = pUnk->QueryInterface(IID_IWinHttpRequestEvents, (void **)&pIWinHttpRequestEvents);

    if (SUCCEEDED(hr))
    {
        *pdwCookie = _SinkArray.Add(static_cast<IUnknown *>(pIWinHttpRequestEvents));
        
        if (*pdwCookie)
        {
            _cConnections++;
            hr = NOERROR;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
        hr = CONNECT_E_CANNOTCONNECT;

    return hr;
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::Unadvise(DWORD dwCookie)
{
    IUnknown * pSink = _SinkArray.GetUnknown(dwCookie);

    if (pSink)
    {
        _SinkArray.Remove(dwCookie);
        pSink->Release();
        --_cConnections;
    }

    return NOERROR;
}


STDMETHODIMP
CHttpRequest::CHttpRequestEventsCP::EnumConnections(IEnumConnections **)
{
    return E_NOTIMPL;
}


void
CHttpRequest::CHttpRequestEventsCP::FireOnResponseStart(long Status, BSTR ContentType)
{
    if (_cConnections > 0 && !Px()->_bAborted)
    {
        GetSink()->OnResponseStart(Status, ContentType);
    }
}


void
CHttpRequest::CHttpRequestEventsCP::FireOnResponseDataAvailable
(
    const BYTE *    rgbData,
    DWORD           cbData
)
{
    if (_cConnections > 0 && !Px()->_bAborted)
    {
        VARIANT varData;
        HRESULT hr;
        
        VariantInit(&varData);

        hr = CreateVector(&varData, rgbData, cbData);

        if (SUCCEEDED(hr))
        {
            GetSink()->OnResponseDataAvailable(&V_ARRAY(&varData));
        }

        VariantClear(&varData);
    }
}


void
CHttpRequest::CHttpRequestEventsCP::FireOnResponseFinished()
{
    if (_cConnections > 0 && !Px()->_bAborted)
    {
        GetSink()->OnResponseFinished();
    }
}


HRESULT
CHttpRequest::CHttpRequestEventsCP::CreateEventSinksMarshaller()
{
    HRESULT     hr = NOERROR;

    if (_cConnections > 0)
    {
        SafeRelease(_pSinkMarshaller);
        hr = CWinHttpRequestEventsMarshaller::Create(&_SinkArray, &_pSinkMarshaller);
    }

    return hr;
}


void
CHttpRequest::CHttpRequestEventsCP::ShutdownEventSinksMarshaller()
{
    if (_pSinkMarshaller)
        _pSinkMarshaller->Shutdown();
}


void
CHttpRequest::CHttpRequestEventsCP::ReleaseEventSinksMarshaller()
{
    SafeRelease(_pSinkMarshaller);
}


void
CHttpRequest::CHttpRequestEventsCP::FreezeEvents()
{
    if (_pSinkMarshaller)
        _pSinkMarshaller->FreezeEvents();
}


void
CHttpRequest::CHttpRequestEventsCP::UnfreezeEvents()
{
    if (_pSinkMarshaller)
        _pSinkMarshaller->UnfreezeEvents();
}


CHttpRequest::CHttpRequestEventsCP::~CHttpRequestEventsCP()
{
    // If any connections are still alive, unadvise them.
    if (_cConnections > 0)
    {
        _SinkArray.ReleaseAll();
        _cConnections = 0;
    }
}


/*
 *  CHttpRequest::Initialize
 *
 *  Purpose:
 *      Zero all data members
 *
 */
void
CHttpRequest::Initialize()
{
    _cRefs = 0;

    _pTypeInfo = NULL;
    _bstrUserAgent = NULL;

    _dwProxySetting  = INTERNET_OPEN_TYPE_PRECONFIG;
    _bstrProxyServer = NULL;
    _bstrBypassList  = NULL;

    _eState = CHttpRequest::CREATED;

    _fAsync            = FALSE;
    _hWorkerThread     = NULL;
    _cRefsOnMainThread = 0;
    _dwMainThreadId    = GetCurrentThreadId();
    _hrAsyncResult     = NOERROR;

    _bAborted          = false;
    _bSetTimeouts      = false;
    _bDisableRedirects = false;

    _hInet = NULL;
    _hConnection = NULL;
    _hHTTP = NULL;

    _ResolveTimeout = 0;
    _ConnectTimeout = 0;
    _SendTimeout    = 0;
    _ReceiveTimeout = 0;

    _cbRequestBody    = 0;
    _szRequestBuffer  = NULL;

    _dwCodePage          = CP_UTF8;
    _dwEscapePercentFlag = 0; 

    _szResponseBuffer = NULL;
    _cbResponseBuffer = 0;
    _cbResponseBody   = 0;

    _hAbortedConnectObject = NULL;
    _hAbortedRequestObject = NULL;

    _bstrCertSubject = NULL;
    _dwSslIgnoreFlags = 0;
}



/*
 *  CHttpRequest::ReleaseResources
 *
 *  Purpose:
 *      Release all handles, events, and buffers
 *
 */
void
CHttpRequest::ReleaseResources()
{
    SafeRelease(_pTypeInfo);

    if (_hWorkerThread)
    {
        CloseHandle(_hWorkerThread);
        _hWorkerThread = NULL;
    }

    _CP.ReleaseEventSinksMarshaller();

    //
    // Derefence aborted handle objects (if any).
    //

    if (_hAbortedRequestObject != NULL)
    {
        DereferenceObject(_hAbortedRequestObject);
        _hAbortedRequestObject = NULL;
    }

    if (_hAbortedConnectObject != NULL)
    {
        DereferenceObject(_hAbortedConnectObject);
        _hAbortedConnectObject = NULL;
    }

    if (_hHTTP)
    {
        HINTERNET temp = _hHTTP;
        _hHTTP = NULL;
        WinHttpCloseHandle(temp);
    }

    if (_hConnection)
    {
        HINTERNET temp = _hConnection;
        _hConnection = NULL;
        WinHttpCloseHandle(temp);
    }

    if (_hInet)
    {
        HINTERNET temp = _hInet;
        _hInet = NULL;
        WinHttpCloseHandle(temp);
    }

    if (_szRequestBuffer)
    {
        delete [] _szRequestBuffer;
        _szRequestBuffer = NULL;
    }

    if (_szResponseBuffer)
    {
        delete [] _szResponseBuffer;
        _szResponseBuffer = NULL;
    }

    if (_bstrUserAgent)
    {
        SysFreeString(_bstrUserAgent);
        _bstrUserAgent = NULL;
    }

    if (_bstrProxyServer)
    {
        SysFreeString(_bstrProxyServer);
        _bstrProxyServer = NULL;
    }

    if (_bstrBypassList)
    {
        SysFreeString(_bstrBypassList);
        _bstrBypassList = NULL;
    }

    if (_bstrCertSubject)
    {
        SysFreeString(_bstrCertSubject);
        _bstrCertSubject = NULL;
    }
}


/*
 *  CHttpRequest::Reset
 *
 *  Purpose:
 *      Release all resources and initialize data members
 *
 */

void
CHttpRequest::Reset()
{
    ReleaseResources();
    Initialize();
}



/*
 *  CHttpRequest::Recycle
 *
 *  Purpose:
 *      Recycle object
 *
 */

void
CHttpRequest::Recycle()
{
    //
    // Wait for the worker thread to shut down. This shouldn't take long
    // since the Abort will close the Request and Connection handles.
    //
    if (_hWorkerThread)
    {
        DWORD   dwWaitResult;

        for (;;)
        {
            dwWaitResult = MsgWaitForMultipleObjects(1, &_hWorkerThread,
                                FALSE,
                                INFINITE,
                                QS_ALLINPUT);

            if (dwWaitResult == (WAIT_OBJECT_0 + 1))
            {
                // Message waiting in the message queue.
                // Run message pump to clear queue.
                MessageLoop();
            }
            else
            {
                break;
            }
        }

        CloseHandle(_hWorkerThread);
        _hWorkerThread = NULL;
    }

    _hConnection = NULL;
    _hHTTP = NULL;

    //
    // Derefence aborted handle objects (if any).
    //

    if (_hAbortedRequestObject != NULL)
    {
        DereferenceObject(_hAbortedRequestObject);
        _hAbortedRequestObject = NULL;
    }

    if (_hAbortedConnectObject != NULL)
    {
        DereferenceObject(_hAbortedConnectObject);
        _hAbortedConnectObject = NULL;
    }

    _fAsync           = FALSE;
    _hrAsyncResult    = NOERROR;

    _bAborted         = false;

    // don't reset timeouts, keep any that were set.

    _cbRequestBody    = 0;
    _cbResponseBuffer = 0;
    _cbResponseBody   = 0;

    if (_szRequestBuffer)
    {
        delete [] _szRequestBuffer;
        _szRequestBuffer = NULL;
    }

    if (_szResponseBuffer)
    {
        delete [] _szResponseBuffer;
        _szResponseBuffer = NULL;
    }

    _CP.ShutdownEventSinksMarshaller();

    _CP.ReleaseEventSinksMarshaller();

    // Allow events to fire; Abort() would have frozen them from firing.
    _CP.UnfreezeEvents();

    SetState(CHttpRequest::CREATED);
}



/*
 *  CHttpRequest::ReadResponse
 *
 *  Purpose:
 *      Read the response bits
 *
 *  Parameters:
 *      None
 *
 *  Errors:
 *      E_FAIL
 *      E_OUTOFMEMORY
 */
HRESULT
CHttpRequest::ReadResponse()
{
    HRESULT     hr = NOERROR;
    BOOL        fRetCode;
    long        lStatus;
    BSTR        bstrContentType = NULL;
    DWORD       dwContentLength = 0;

    // Determine the content length

    DWORD cb = sizeof(dwContentLength);

    fRetCode = HttpQueryInfoA(
                    _hHTTP,
                    HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,
                    WINHTTP_HEADER_NAME_BY_INDEX,
                    &dwContentLength,
                    &cb,
                    0);

    hr = get_Status(&lStatus);

    if (FAILED(hr))
        goto Error;

    hr = _GetResponseHeader(L"Content-Type", &bstrContentType);

    if (FAILED(hr))
    {
        bstrContentType = SysAllocString(L"");
        if (bstrContentType == NULL)
            goto ErrorOutOfMemory;

        hr = NOERROR;
    }

    _CP.FireOnResponseStart(lStatus, bstrContentType);

    if (dwContentLength != 0)
    {
        _szResponseBuffer = New char[dwContentLength];

        if (_szResponseBuffer)
        {
            _cbResponseBuffer = dwContentLength;
        }
        else
            goto ErrorOutOfMemory;
    }
    else
    {
        _szResponseBuffer = NULL;
        _cbResponseBuffer = 0;
    }


    //
    // Read data until there is no more - we need to buffer the data
    //
    while (!_bAborted)
    {
    	DWORD   cbAvail = 0;
        DWORD   cbRead  = 0;

        fRetCode = WinHttpQueryDataAvailable(_hHTTP, &cbAvail);

        if (!fRetCode)
        {
            goto ErrorFail;
        }

        // Check for buffer overflow - dynamically resize if neccessary
        if (_cbResponseBody + cbAvail > _cbResponseBuffer)
        {
            ULONG cbNewSize = _cbResponseBody + cbAvail;
            
            char * szNewBuf = New char[cbNewSize];

            if (!szNewBuf)
                goto ErrorOutOfMemory;

            if (_szResponseBuffer)
            {
                ::memcpy(szNewBuf, _szResponseBuffer, _cbResponseBody);
                delete [] _szResponseBuffer;
            }

            _cbResponseBuffer = cbNewSize;

            _szResponseBuffer = szNewBuf;
        }

        fRetCode = WinHttpReadData(
                    _hHTTP,
                    &_szResponseBuffer[_cbResponseBody],
                    cbAvail,
                    &cbRead);

        if (!fRetCode)
        {
            goto ErrorFail;
        }
        
        // No more data
        if (cbRead == 0)
            break;

        _CP.FireOnResponseDataAvailable((const BYTE *)&_szResponseBuffer[_cbResponseBody],
                cbRead);

        _cbResponseBody += cbRead;
    }

    SetState(CHttpRequest::RESPONSE);

    hr = NOERROR;

Cleanup:
    if (bstrContentType)
        SysFreeString(bstrContentType);

    _CP.FireOnResponseFinished();

    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;

Error:
    goto Cleanup;
}



STDMETHODIMP
CHttpRequest::SetProxy(HTTPREQUEST_PROXY_SETTING ProxySetting,
    VARIANT     varProxyServer,
    VARIANT     varBypassList)
{
    HRESULT             hr = NOERROR;

    if (!IsValidVariant(varProxyServer) || !IsValidVariant(varBypassList))
        return E_INVALIDARG;

    if (_bstrProxyServer)
    {
        SysFreeString(_bstrProxyServer);
        _bstrProxyServer = NULL;
    }

    if (_bstrBypassList)
    {
        SysFreeString(_bstrBypassList);
        _bstrBypassList = NULL;
    }

    switch (ProxySetting)
    {
        case HTTPREQUEST_PROXYSETTING_PRECONFIG:
            _dwProxySetting = INTERNET_OPEN_TYPE_PRECONFIG;
            break;

        case HTTPREQUEST_PROXYSETTING_DIRECT:
            _dwProxySetting   = INTERNET_OPEN_TYPE_DIRECT;
            break;

        case HTTPREQUEST_PROXYSETTING_PROXY:
            _dwProxySetting   = INTERNET_OPEN_TYPE_PROXY;
            _bstrProxyServer  = GetBSTRFromVariant(varProxyServer);
            _bstrBypassList   = GetBSTRFromVariant(varBypassList);
            break;

        default:
            hr = E_INVALIDARG;
            break;
    }

    if (SUCCEEDED(hr))
    {
        if (_hInet)
        {
            WINHTTP_PROXY_INFOW ProxyInfo;

            memset(&ProxyInfo, 0, sizeof(ProxyInfo));

            ProxyInfo.dwAccessType    = _dwProxySetting;
            ProxyInfo.lpszProxy       = _bstrProxyServer;
            ProxyInfo.lpszProxyBypass = _bstrBypassList;
            
            if (!WinHttpSetOption(_hInet, WINHTTP_OPTION_PROXY,
                        &ProxyInfo,
                        sizeof(ProxyInfo)))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    SetErrorInfo(hr);

    return hr;
}


STDMETHODIMP
CHttpRequest::SetCredentials(
    BSTR bstrUserName,
    BSTR bstrPassword,
    HTTPREQUEST_SETCREDENTIALS_FLAGS Flags)
{
    HRESULT     hr;

    // Must call Open method before SetCredentials.
    if (! _hHTTP)
    {
        goto ErrorCannotCallBeforeOpen;
    }

    if (!IsValidBstr(bstrUserName) || !IsValidBstr(bstrPassword))
        return E_INVALIDARG;

    if (Flags == HTTPREQUEST_SETCREDENTIALS_FOR_SERVER)
    {
        // Set Username and Password.
        WinHttpSetOption(
            _hHTTP, 
            WINHTTP_OPTION_USERNAME, 
            bstrUserName, 
            SysStringLen(bstrUserName));

        WinHttpSetOption(
            _hHTTP, 
            WINHTTP_OPTION_PASSWORD, 
            bstrPassword,
            SysStringLen(bstrPassword));
    }
    else if (Flags == HTTPREQUEST_SETCREDENTIALS_FOR_PROXY)
    {
        // Set Username and Password.
        WinHttpSetOption(
            _hHTTP, 
            WINHTTP_OPTION_PROXY_USERNAME, 
            bstrUserName, 
            SysStringLen(bstrUserName));

        WinHttpSetOption(
            _hHTTP, 
            WINHTTP_OPTION_PROXY_PASSWORD, 
            bstrPassword,
            SysStringLen(bstrPassword));
    }
    else
        return E_INVALIDARG;

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeOpen:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
    goto Cleanup;
}


/*
 *  CHttpRequest::Open
 *
 *  Purpose:
 *      Open a logical HTTP connection
 *
 *  Parameters:
 *      bstrMethod      IN      HTTP method (GET, PUT, ...)
 *      bstrUrl         IN      Target URL
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      E_ACCESSDENIED
 *      Errors from InternetOpenA and WinHttpCrackUrlA and InternetConnectA
 *          and HttpOpenRequestA
 */

STDMETHODIMP
CHttpRequest::Open(
    BSTR            bstrMethod,
    BSTR            bstrUrl,
    VARIANT         varAsync)
{
    HRESULT         hr = NOERROR;
    BSTR            bstrHostName = NULL;
    BSTR            bstrUrlPath = NULL;
    DWORD           dwHttpOpenFlags = 0;
    URL_COMPONENTSW url;

    // Check for reinitialization
    if (_eState != CHttpRequest::CREATED)
    {
        //
        // Abort any request in progress.
        // This will also recycle the object.
        //
        Abort();
    }

    // Validate parameters
    if (!bstrMethod || !bstrUrl ||
            !IsValidBstr(bstrMethod) ||
            !IsValidBstr(bstrUrl) ||
            !lstrlenW(bstrMethod) ||    // cannot have empty method
            !lstrlenW(bstrUrl)    ||    // cannot have empty url
            !IsValidVariant(varAsync))
        return E_INVALIDARG;

    _fAsync = GetBoolFromVariant(varAsync, FALSE);

    //
    // Open an Internet Session if one does not already exist.
    //
    if (!_hInet)
    {
        _hInet = WinHttpOpen(
                    GetUserAgentString(),
                    _dwProxySetting,
                    _bstrProxyServer,
                    _bstrBypassList,
                    0);

        if (!_hInet)
            goto ErrorFail;

        // In winhttp5, this should be adjusted through an exposed option
        // or flag, rather than going through the back door.
        HINTERNET hSessionMapped = NULL;
        if (ERROR_SUCCESS == MapHandleToAddress(_hInet,
                                                (LPVOID *)&hSessionMapped,
                                                FALSE) &&
            hSessionMapped)
        {
            ((INTERNET_HANDLE_OBJECT *)hSessionMapped)->SetUseSslSessionCache(TRUE);
            DereferenceObject(hSessionMapped);
        }
    }

    //
    // If any timeouts were set previously, apply them.
    //
    if (_bSetTimeouts)
    {
        if (!WinHttpSetTimeouts(_hInet, (int)_ResolveTimeout,
                        (int)_ConnectTimeout,
                        (int)_SendTimeout,
                        (int)_ReceiveTimeout))
            goto ErrorFail;
    }


    //
    // Set the code page on the Session handle; the Connect
    // handle will also inherit this value.
    //
    if (!WinHttpSetOption(_hInet, WINHTTP_OPTION_CODEPAGE,
                &_dwCodePage,
                sizeof(_dwCodePage)))
        goto ErrorFail;


    // Break the URL into the required components
    ZeroMemory(&url, sizeof(URL_COMPONENTSW));

    url.dwStructSize = sizeof(URL_COMPONENTSW);
    url.dwHostNameLength  = 1;
    url.dwUrlPathLength   = 1;
    url.dwExtraInfoLength = 1;

    if (!WinHttpCrackUrl(bstrUrl, 0, 0, &url))
        goto ErrorFail;


    // Check for non-http schemes
    if (url.nScheme != INTERNET_SCHEME_HTTP && url.nScheme != INTERNET_SCHEME_HTTPS)
        goto ErrorUnsupportedScheme;

    // IE6/Reno Bug #6236: if the client does not specify a resource path,
    // then add the "/".
    if (url.dwUrlPathLength == 0)
    {
        INET_ASSERT(url.dwExtraInfoLength == 1);

        url.lpszUrlPath = L"/";
        url.dwUrlPathLength = 1;
    }

    bstrHostName = SysAllocStringLen(url.lpszHostName, url.dwHostNameLength);
    bstrUrlPath  = SysAllocStringLen(url.lpszUrlPath, lstrlenW(url.lpszUrlPath));

    if (!bstrHostName || !bstrUrlPath)
        goto ErrorOutOfMemory;


    INET_ASSERT(_hConnection == NULL);
    INET_ASSERT(_hHTTP == NULL);

    _hConnection = WinHttpConnect(
                    _hInet,
                    bstrHostName,
                    url.nPort,
                    0);

    if (!_hConnection)
        goto ErrorFail;

    if (url.nScheme == INTERNET_SCHEME_HTTPS)
    {
        dwHttpOpenFlags |= WINHTTP_FLAG_SECURE;
    }

    //
    // Apply EscapePercentInURL option.
    //
    dwHttpOpenFlags |= _dwEscapePercentFlag;

    _hHTTP = WinHttpOpenRequest(
                _hConnection,
                bstrMethod,
                bstrUrlPath,
                NULL,
                NULL,
                NULL,
                dwHttpOpenFlags);

    if (!_hHTTP)
        goto ErrorFail;

    // Set the SSL ignore flags through an undocumented front door
    if (_dwSslIgnoreFlags)
    {
        WinHttpSetOption(_hHTTP,
                         WINHTTP_OPTION_SECURITY_FLAGS,
                         (LPVOID)&_dwSslIgnoreFlags,
                         sizeof(_dwSslIgnoreFlags));
    }

    SetState(CHttpRequest::OPENED);

    hr = NOERROR;

Cleanup:
    if (bstrHostName)
        SysFreeString(bstrHostName);;
    if (bstrUrlPath)
        SysFreeString(bstrUrlPath);

    SetErrorInfo(hr);

    return hr;

ErrorUnsupportedScheme:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    goto Cleanup;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::SetRequestHeader
 *
 *  Purpose:
 *      Set a request header
 *
 *  Parameters:
 *      bstrHeader      IN      HTTP request header
 *      bstrValue       IN      Header value
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_UNEXPECTED
 */

STDMETHODIMP
CHttpRequest::SetRequestHeader(BSTR bstrHeader, BSTR bstrValue)
{
    WCHAR *     wszHeaderValue = NULL;  
    DWORD       cchHeaderValue;
    DWORD       dwModifiers = HTTP_ADDREQ_FLAG_ADD;
    HRESULT     hr = NOERROR;

    // Validate header parameter (null or zero-length value is allowed)
    if (!bstrHeader || !IsValidBstr(bstrHeader) ||
            lstrlenW(bstrHeader)==0 ||
            !IsValidBstr(bstrValue))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::OPENED)
        goto ErrorCannotCallBeforeOpen;
    else if (_eState >= CHttpRequest::SENDING)
        goto ErrorCannotCallAfterSend;

    // Ignore attempts to set the Content-Length header; the
    // content length is computed and sent automatically.
    if (StrCmpIW(bstrHeader, L"Content-Length") == 0)
        goto Cleanup;

    cchHeaderValue = SysStringLen(bstrHeader) + SysStringLen(bstrValue)
                        + 2 /* wcslen(L": ") */
                        + 2 /* wcslen(L"\r\n") */;

    wszHeaderValue = New WCHAR [cchHeaderValue + 1];

    if (!wszHeaderValue)
        goto ErrorOutOfMemory;

    wcscpy(wszHeaderValue, bstrHeader);
    wcscat(wszHeaderValue, L": ");
    if (bstrValue)
        wcscat(wszHeaderValue, bstrValue);
    wcscat(wszHeaderValue, L"\r\n");

    // For blank header values, erase the header by setting the
    // REPLACE flag.
    if (SysStringLen(bstrValue) == 0)
    {
        dwModifiers |= HTTP_ADDREQ_FLAG_REPLACE;
    }
    
    if (! WinHttpAddRequestHeaders(_hHTTP, wszHeaderValue,
            -1L,
            dwModifiers))
        goto ErrorFail;

    hr = NOERROR;

Cleanup:
    if (wszHeaderValue)
        delete [] wszHeaderValue;

    SetErrorInfo(hr);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorCannotCallBeforeOpen:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
    goto Error;

ErrorCannotCallAfterSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND);
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::SetRequiredRequestHeaders
 *
 *  Purpose:
 *      Set implicit request headers
 *
 *  Parameters:
 *      None
 *
 *  Errors:
 *      E_FAIL
 *      E_UNEXPECTED
 *      E_OUTOFMEMORY
 *      Errors from WinHttpAddRequestHeaders and WinHttpSendRequest
 */

HRESULT
CHttpRequest::SetRequiredRequestHeaders()
{
    HRESULT hr = NOERROR;
    char    szContentLengthHeader[sizeof("Content-Length") +
                                  sizeof(": ") +
                                  15 +   // content-length value
                                  sizeof("\r\n") + 1];

    lstrcpy(szContentLengthHeader, "Content-Length: ");
    _ltoa(_cbRequestBody,
        szContentLengthHeader + 16, /* "Content-Length: " */
        10);
    lstrcat(szContentLengthHeader, "\r\n");

    if (! HttpAddRequestHeadersA(_hHTTP, szContentLengthHeader,
            -1L,
            HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE))
    {
        hr = E_FAIL;
    }

    // Add an Accept: */* header if no other Accept header
    // has been set. Ignore any return code, since it is
    // not fatal if this fails.
    HttpAddRequestHeadersA(_hHTTP, "Accept: */*",
            -1L,
            HTTP_ADDREQ_FLAG_ADD_IF_NEW);

    return hr;
}


DWORD WINAPI WinHttpRequestSendAsync(LPVOID lpParameter)
{
#ifdef WINHTTP_FOR_MSXML
    //
    // MSXML needs to initialize its thread local storage data.
    // It does not do this during DLL_THREAD_ATTACH, so our
    // worker thread must explicitly call into MSXML to initialize
    // its TLS for this thread.
    //
    InitializeMsxmlTLS();
#endif

    HRESULT hr;
    DWORD   dwExitCode;

    CHttpRequest * pWinHttpRequest = reinterpret_cast<CHttpRequest *>(lpParameter);

    INET_ASSERT(pWinHttpRequest != NULL);

    dwExitCode = pWinHttpRequest->SendAsync();

    pWinHttpRequest->Release();

    // If this worker thread was impersonating, revert to the default
    // process identity.
    RevertToSelf();

    return dwExitCode;
}


/*
 *  CHttpRequest::CreateAsyncWorkerThread
 *
 */

HRESULT
CHttpRequest::CreateAsyncWorkerThread()
{
    DWORD   dwWorkerThreadId;
    HANDLE  hThreadToken = NULL;
    HRESULT hr;

    hr = _CP.CreateEventSinksMarshaller();

    if (FAILED(hr))
        return hr;

    hr = NOERROR;

    //
    // If the current thread is impersonating, then grab its access token
    // and revert the current thread (so it is nolonger impersonating).
    // After creating the worker thread, we will make the main thread
    // impersonate again. Apparently you should not call CreateThread
    // while impersonating.
    //
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ),
            FALSE,
            &hThreadToken))
    {
        INET_ASSERT(hThreadToken != 0);

        RevertToSelf();
    }

    // Create the worker thread suspended.
    _hWorkerThread = CreateThread(NULL, 0, WinHttpRequestSendAsync,
                            (void *)static_cast<CHttpRequest *>(this),
                            CREATE_SUSPENDED,
                            &dwWorkerThreadId);

    // If CreateThread fails, grab the error code now.
    if (!_hWorkerThread)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If the main thread was impersonating, then:
    //  (1) have the worker thread impersonate the same user, and
    //  (2) have the main thread resume impersonating the 
    //      client too (since we called RevertToSelf above).
    //
    if (hThreadToken)
    {
        if (_hWorkerThread)
        {
            SetThreadToken(&_hWorkerThread, hThreadToken);
        }

        SetThreadToken(NULL, hThreadToken);
        
        CloseHandle(hThreadToken);
    }

    // If the worker thread was created, start it running.
    if (_hWorkerThread)
    {
        // The worker thread owns a ref count on the component.
        // Don't call AddRef() as it will attribute the ref count
        // to the main thread.
        _cRefs++;

        ResumeThread(_hWorkerThread);
    }
    else
    {
        _CP.ShutdownEventSinksMarshaller();
        _CP.ReleaseEventSinksMarshaller();
    }

    return hr;
}


/*
 *  CHttpRequest::Send
 *
 *  Purpose:
 *      Send the HTTP request
 *
 *  Parameters:
 *      varBody     IN      Request body
 *
 *  Errors:
 *      E_FAIL
 *      E_UNEXPECTED
 *      E_OUTOFMEMORY
 *      Errors from WinHttpAddRequestHeaders and WinHttpSendRequest
 */

STDMETHODIMP
CHttpRequest::Send(VARIANT varBody)
{
    HRESULT     hr = NOERROR;
    BOOL        fRetCode = FALSE;
    BOOL        fRetryWithClientAuth = TRUE;

    // Validate parameter
    if (!IsValidVariant(varBody))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::OPENED)
        goto ErrorCannotCallBeforeOpen;

    // Get the request body
    hr = SetRequestBody(varBody);

    if (FAILED(hr))
        goto Error;

    hr = SetRequiredRequestHeaders();

    if (FAILED(hr))
        goto Error;

    if (_bDisableRedirects)
    {
        DWORD   dwDisable = WINHTTP_DISABLE_REDIRECTS;

        WinHttpSetOption(_hHTTP,
                        WINHTTP_OPTION_DISABLE_FEATURE,
                        (void *) &dwDisable,
                        sizeof(DWORD));
    }

    
try_again:
    SetState(CHttpRequest::SENDING);
    
    if (_fAsync)
    {
        hr = CreateAsyncWorkerThread();

        if (FAILED(hr))
            goto Error;
    }
    else
    {
        // Send the HTTP request
        fRetCode = WinHttpSendRequest(
                        _hHTTP,
                        NULL, 0,            // No header info here
                        _szRequestBuffer,
                        _cbRequestBody,
                        _cbRequestBody,
                        0);

        if (!fRetCode)
        {
            goto ErrorFail;
        }

        fRetCode = WinHttpReceiveResponse(_hHTTP, NULL);

        if (!fRetCode)
        {
            goto ErrorFail;
        }

        SetState(CHttpRequest::SENT);

        // Read the response data
        hr = ReadResponse();

        if (FAILED(hr))
            goto Error;
    }

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeOpen:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if (!_fAsync &&
        hr == HRESULT_FROM_WIN32(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED) &&
        fRetryWithClientAuth)
    {
        fRetryWithClientAuth = FALSE;
        // Try to enumerate the first cert in the reverted user context,
        // select the cert (per object sesssion, not global), and send
        // the request again.
        if (SelectCertificate())
            goto try_again;
    }
    goto Cleanup;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::SendAsync
 *
 *  Purpose:
 *      Send the HTTP request
 *
 *  Parameters:
 *      varBody     IN      Request body
 *
 *  Errors:
 *      E_FAIL
 *      E_UNEXPECTED
 *      E_OUTOFMEMORY
 *      Errors from WinHttpAddRequestHeaders and WinHttpSendRequest
 */

DWORD
CHttpRequest::SendAsync()
{
    DWORD   dwLastError = 0;
    DWORD   fRetCode;
    HRESULT hr;
    BOOL    fRetryWithClientAuth = TRUE;

try_again:
    if (_bAborted || !_hHTTP)
        goto ErrorUnexpected;

    // Send the HTTP request
    fRetCode = WinHttpSendRequest(
                    _hHTTP,
                    NULL, 0,            // No header info here
                    _szRequestBuffer,
                    _cbRequestBody,
                    _cbRequestBody,
                    0);

    if (!fRetCode)
        goto ErrorFail;

    fRetCode = WinHttpReceiveResponse(_hHTTP, NULL);

    if (!fRetCode)
        goto ErrorFail;

    if (!_bAborted)
    {
        SetState(CHttpRequest::SENT);

        hr = ReadResponse();

        if (FAILED(hr))
        {
            if (hr == E_OUTOFMEMORY)
                goto ErrorOutOfMemory;
            goto ErrorFail;
        }
    }

    hr = NOERROR;

Cleanup:
    _hrAsyncResult = hr;
    return dwLastError;

ErrorUnexpected:
    dwLastError = ERROR_WINHTTP_INTERNAL_ERROR;
    hr = HRESULT_FROM_WIN32(dwLastError);
    goto Cleanup;

ErrorFail:
    dwLastError = GetLastError();
    if (dwLastError == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED &&
        fRetryWithClientAuth)
    {
        fRetryWithClientAuth = FALSE;
        // Try to enumerate the first cert in the reverted user context,
        // select the cert (per object sesssion, not global), and send
        // the request again.
        if (SelectCertificate())
        {
            SetState(CHttpRequest::SENDING);
            goto try_again;
        }
    }
    hr = HRESULT_FROM_WIN32(dwLastError);
    goto Cleanup;

ErrorOutOfMemory:
    dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::WaitForResponse(VARIANT varTimeout, VARIANT_BOOL * pboolSucceeded)
{
    HRESULT     hr = NOERROR;
    bool        bSucceeded= true;
    DWORD       dwTimeout;

    // Validate parameters; null pboolSucceeded pointer is Ok.
    if (!IsValidVariant(varTimeout) ||
            (pboolSucceeded &&
             IsBadWritePtr(pboolSucceeded, sizeof(VARIANT_BOOL))))
        return E_INVALIDARG;

    // Get the timeout value. Disallow numbers
    // less than -1 (which means INFINITE).
    
    if (GetLongFromVariant(varTimeout, INFINITE) < -1L)
        return E_INVALIDARG;

    dwTimeout = GetDwordFromVariant(varTimeout, INFINITE);


    // Validate state. 
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    //
    // WaitForResponse is a no-op if we're not in async mode.
    //
    if (_fAsync && _hWorkerThread)
    {
        //
        // Has the worker thread has already finished?
        //
        if (WaitForSingleObject(_hWorkerThread, 0) == WAIT_TIMEOUT)
        {
            //
            // Convert Timeout from seconds to milliseconds. Any timeout
            // value over 4 million seconds (~46 days) is "rounded up"
            // to INFINITE. :)
            //
            if (dwTimeout > 4000000)   // avoid overflow
            {
                dwTimeout = INFINITE;
            }
            else
            {
                // convert to milliseconds
                dwTimeout *= 1000;
            }


            DWORD   dwStartTime;
            DWORD   dwWaitResult;
            bool    bWaitAgain;
            
            do
            {
                dwStartTime = GetTickCount();

                dwWaitResult = MsgWaitForMultipleObjects(1, &_hWorkerThread,
                                    FALSE,
                                    dwTimeout,
                                    QS_ALLINPUT);
                
                bWaitAgain = false;

                switch (dwWaitResult)
                {
                case WAIT_OBJECT_0:
                    // Thread exited.
                    MessageLoop();
                    hr = _hrAsyncResult;
                    bSucceeded = SUCCEEDED(hr);
                    break;
                case WAIT_OBJECT_0 + 1:
                    // Message waiting in the message queue.
                    // Run message pump to clear queue.
                    MessageLoop();
                    bWaitAgain = true;
                    break;
                case WAIT_TIMEOUT:
                    // Timeout.
                    bSucceeded = false;
                    break;
                case (-1):
                default:
                    // Error.
                    goto ErrorFail;
                    break;
                }

                // If we're going to continue waiting for the worker
                // thread, decrease timeout appropriately.
                if (bWaitAgain)
                {
                    dwTimeout = UpdateTimeout(dwTimeout, dwStartTime);
                }
            } while (bWaitAgain);
        }
        else
        {
            // If the worker thread is already done, then pump messages
            // to clear any events that it may have posted.
            MessageLoop();
            hr = _hrAsyncResult;
            bSucceeded = SUCCEEDED(hr);
        }
    }

Cleanup:
    if (pboolSucceeded)
    {
        *pboolSucceeded = (bSucceeded ? VARIANT_TRUE : VARIANT_FALSE);
    }

    SetErrorInfo(hr);
    return hr;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

Error:
    bSucceeded = false;
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::Abort()
{
    //
    // Abort if not already aborted and not in the CREATED state,
    // (meaning at least the Open method has been called).
    //
    if ((_eState > CHttpRequest::CREATED) && !_bAborted)
    {
        DWORD   error;

        _bAborted = true;

        // Tell our connection point manager to abort any
        // events "in flight"--i.e., abort any events that
        // may have already been posted by the worker thread.
        _CP.FreezeEvents();

        if (_hHTTP)
        {
            //
            // Add a ref count on the HTTP Request handle.
            //
            INET_ASSERT(_hAbortedRequestObject == NULL);
            error = MapHandleToAddress(_hHTTP, (LPVOID *)&_hAbortedRequestObject, FALSE);
            INET_ASSERT(error == 0);

            WinHttpCloseHandle(_hHTTP);
        }

        if (_hConnection)
        {
            //
            // Add a ref count on the Connection handle.
            //
            INET_ASSERT(_hAbortedConnectObject == NULL);
            error = MapHandleToAddress(_hConnection, (LPVOID *)&_hAbortedConnectObject, FALSE);
            INET_ASSERT(error == 0);

            WinHttpCloseHandle(_hConnection);
        }

        // Recycle the object.
        Recycle();
    }

    return NOERROR;
}


STDMETHODIMP
CHttpRequest::SetTimeouts(long ResolveTimeout, long ConnectTimeout, long SendTimeout, long ReceiveTimeout)
{
    if ((ResolveTimeout < -1L) || (ConnectTimeout < -1L) ||
        (SendTimeout < -1L)    || (ReceiveTimeout < -1L))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = NOERROR;

    _ResolveTimeout = (DWORD) ResolveTimeout;
    _ConnectTimeout = (DWORD) ConnectTimeout;
    _SendTimeout    = (DWORD) SendTimeout;
    _ReceiveTimeout = (DWORD) ReceiveTimeout;
    
    _bSetTimeouts   = true;

    if (_hHTTP)
    {
        DWORD fRetCode;

        fRetCode = WinHttpSetTimeouts(_hHTTP, (int)_ResolveTimeout,
                        (int)_ConnectTimeout,
                        (int)_SendTimeout,
                        (int)_ReceiveTimeout);

        if (!fRetCode)
            hr = E_INVALIDARG;
    }

    return hr;
}


/*
 *  CHttpRequest::SetRequestBody
 *
 *  Purpose:
 *      Set the request body
 *
 *  Parameters:
 *      varBody     IN      Request body
 *
 *  Errors:
 *      E_FAIL
 *      E_OUTOFMEMORY
 *      E_UNEXPECTED
 */

HRESULT
CHttpRequest::SetRequestBody(VARIANT varBody)
{
    HRESULT             hr = NOERROR;
    VARIANT             varTemp;
    BSTR                bstrBody = NULL;
    SAFEARRAY *         psa = NULL;
    VARIANT *           pvarBody = NULL;
    IStream *           pStm = NULL;

    // varBody is validated by CHttpRequest::Send().

    VariantInit(&varTemp);

    // Free a previously set body and its response
    if (_szRequestBuffer)
    {
        delete [] _szRequestBuffer;
        _szRequestBuffer = NULL;
        _cbRequestBody = 0;
    }

    if (_szResponseBuffer)
    {
        delete [] _szResponseBuffer;
        _szResponseBuffer = NULL;
        _cbResponseBuffer = 0;
        _cbResponseBody = 0;
    }

    if (V_ISBYREF(&varBody))
    {
        pvarBody = varBody.pvarVal;
    }
    else
    {
        pvarBody = &varBody;
    }

    // Check for an empty body
    if (V_VT(pvarBody) == VT_EMPTY ||
        V_VT(pvarBody) == VT_NULL  ||
        V_VT(pvarBody) == VT_ERROR)
        goto Cleanup;

    //
    // Extract the body: BSTR or array of UI1
    //

    // We need to explicitly look for the byte array since it will be converted
    // to a BSTR by VariantChangeType.
    if (V_ISARRAY(pvarBody) && (V_VT(pvarBody) & VT_UI1))
    {
        BYTE *  pb = NULL;
        long    lUBound = 0;
        long    lLBound = 0;

        psa = V_ARRAY(pvarBody);

        // We only handle 1 dimensional arrays
        if (SafeArrayGetDim(psa) != 1)
            goto ErrorFail;

        // Get access to the blob
        hr = SafeArrayAccessData(psa, (void **)&pb);

        if (FAILED(hr))
            goto Error;

        // Compute the data size from the upper and lower array bounds
        hr = SafeArrayGetLBound(psa, 1, &lLBound);

        if (FAILED(hr))
            goto Error;

        hr = SafeArrayGetUBound(psa, 1, &lUBound);

        if (FAILED(hr))
            goto Error;

        _cbRequestBody = lUBound - lLBound + 1;

        if (_cbRequestBody > 0)
        {
            // Copy the data into the request buffer
            _szRequestBuffer = New char [_cbRequestBody];

            if (!_szRequestBuffer)
            {
                _cbRequestBody = 0;
                goto ErrorOutOfMemory;
            }
            
            ::memcpy(_szRequestBuffer, pb, _cbRequestBody);
        }
        
        SafeArrayUnaccessData(psa);
        psa = NULL;
    }
    else
    {
        // Try a BSTR
        bstrBody = GetBSTRFromVariant(*pvarBody);

        if (bstrBody)
        {
            hr = BSTRToUTF8(&_szRequestBuffer, &_cbRequestBody, bstrBody);

            if (FAILED(hr))
                goto Error;
        }
        else
        {
            // Try a Stream
            if (V_VT(pvarBody) == VT_UNKNOWN || V_VT(pvarBody) == VT_DISPATCH)
            {
                IStream *   pStm;

                hr = pvarBody->punkVal->QueryInterface(
                            IID_IStream,
                            (void **)&pStm);

                if (FAILED(hr))
                    goto Error;

                hr = ReadFromStream(
                            &_szRequestBuffer,
                            &_cbRequestBody,
                            pStm);

                pStm->Release();

                if (FAILED(hr))
                    goto Error;
            }
        }
    }

    hr = NOERROR;

Cleanup:
    VariantClear(&varTemp);
    if (psa)
        SafeArrayUnaccessData(psa);
    if (bstrBody)
        SysFreeString(bstrBody);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::GetResponseHeader
 *
 *  Purpose:
 *      Get a response header
 *
 *  Parameters:
 *      bstrHeader      IN      HTTP request header
 *      pbstrValue      OUT     Header value
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      E_UNEXPECTED
 *      Errors from WinHttpQueryHeaders
 */

STDMETHODIMP
CHttpRequest::GetResponseHeader(BSTR bstrHeader, BSTR * pbstrValue)
{
    return _GetResponseHeader(bstrHeader, pbstrValue);
}

HRESULT
CHttpRequest::_GetResponseHeader(OLECHAR * wszHeader, BSTR * pbstrValue)
{
    HRESULT     hr = NOERROR;
    WCHAR *     wszHeaderValue = NULL;
    DWORD       cb;
    BOOL        fRetCode;

    // Validate parameters
    if (IsBadReadPtr(wszHeader, 2) ||
            IsBadWritePtr(pbstrValue, sizeof(BSTR)) ||
            !lstrlenW(wszHeader))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    *pbstrValue = NULL;

    cb = 64; // arbitrary size in which many header values will fit

    wszHeaderValue = New WCHAR[cb];

    if (!wszHeaderValue)
        goto ErrorOutOfMemory;

RetryQuery:
    // Determine length of requested header
    fRetCode = WinHttpQueryHeaders(
                    _hHTTP,
                    HTTP_QUERY_CUSTOM,
                    wszHeader,
                    wszHeaderValue,
                    &cb,
                    0);

    // Check for ERROR_INSUFFICIENT_BUFFER - reallocate the buffer and retry
    if (!fRetCode)
    {
        switch (GetLastError())
        {
            case ERROR_INSUFFICIENT_BUFFER:
            {
                delete [] wszHeaderValue;
                wszHeaderValue = New WCHAR[cb]; // should this be cb/2?
                if (!wszHeaderValue)
                    goto ErrorOutOfMemory;
                goto RetryQuery;
            }

            case ERROR_HTTP_HEADER_NOT_FOUND:
                goto ErrorFail;
        
            default:
                goto ErrorFail;
        }
    }

    *pbstrValue = SysAllocString(wszHeaderValue);

    if (!*pbstrValue)
        goto ErrorOutOfMemory;

    hr = NOERROR;

Cleanup:
    if (wszHeaderValue)
        delete [] wszHeaderValue;

    SetErrorInfo(hr);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

Error:
    goto Cleanup;
}


/*
 *  CHttpRequest::GetAllResponseHeaders
 *
 *  Purpose:
 *      Return the response headers
 *
 *  Parameters:
 *      pbstrHeaders    IN/OUT      CRLF delimited headers
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      E_UNEXPECTED
 */

STDMETHODIMP
CHttpRequest::GetAllResponseHeaders(BSTR * pbstrHeaders)
{
    HRESULT     hr = NOERROR;
    BOOL        fRetCode;
    WCHAR *     wszAllHeaders = NULL;
    WCHAR *     wszFirstHeader = NULL;
    DWORD       cb = 0;

    // Validate parameter
    if (IsBadWritePtr(pbstrHeaders, sizeof(BSTR)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    *pbstrHeaders = NULL;

RetryQuery:
    // Determine the length of all headers and then get all the headers
    fRetCode = WinHttpQueryHeaders(
                    _hHTTP,
                    HTTP_QUERY_RAW_HEADERS_CRLF,
                    WINHTTP_HEADER_NAME_BY_INDEX,
                    wszAllHeaders,
                    &cb,
                    0);

    if (!fRetCode)
    {
        // Allocate a buffer large enough to hold all headers
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            wszAllHeaders = New WCHAR[cb];

            if (!wszAllHeaders)
                goto ErrorOutOfMemory;

            goto RetryQuery;
        }
        else
        {
            goto ErrorFail;
        }
    }

    // Bypass status line - jump past first CRLF (0x13, 0x10)
    wszFirstHeader = wcschr(wszAllHeaders, '\n');

    if (*wszFirstHeader == '\n')
    {
        *pbstrHeaders = SysAllocString(wszFirstHeader + 1);

        if (!*pbstrHeaders)
            goto ErrorOutOfMemory;
    }

    hr = NOERROR;
    
Cleanup:
    if (wszAllHeaders)
        delete [] wszAllHeaders;

    SetErrorInfo(hr);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

Error:
    if (pbstrHeaders)
    {
        SysFreeString(*pbstrHeaders);
        *pbstrHeaders = NULL;
    }
    goto Cleanup;
}


/*
 *  CHttpRequest::get_status
 *
 *  Purpose:
 *      Get the request status code
 *
 *  Parameters:
 *      plStatus        OUT     HTTP request status code
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_UNEXPECTED
 */

STDMETHODIMP
CHttpRequest::get_Status(long * plStatus)
{
    HRESULT hr = NOERROR;
    DWORD   cb = sizeof(DWORD);
    BOOL    fRetCode;
    DWORD   dwStatus;

    // Validate parameter
    if (IsBadWritePtr(plStatus, sizeof(long)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    fRetCode = HttpQueryInfoA(
                    _hHTTP,
                    HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                    WINHTTP_HEADER_NAME_BY_INDEX,
                    &dwStatus,
                    &cb,
                    0);

    if (!fRetCode)
        goto ErrorFail;

    *plStatus = dwStatus;

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}


/*
 *  CHttpRequest::get_StatusText
 *
 *  Purpose:
 *      Get the request status text
 *
 *  Parameters:
 *      pbstrStatus     OUT     HTTP request status text
 *
 *  Errors:
 *      E_FAIL
 *      E_INVALIDARG
 *      E_UNEXPECTED
 */

STDMETHODIMP
CHttpRequest::get_StatusText(BSTR * pbstrStatus)
{
    HRESULT     hr = NOERROR;
    WCHAR       wszStatusText[32];
    WCHAR *     pwszStatusText = wszStatusText;
    BOOL        fFreeStatusString = FALSE;
    DWORD       cb;
    BOOL        fRetCode;

    // Validate parameter
    if (IsBadWritePtr(pbstrStatus, sizeof(BSTR)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;

    *pbstrStatus = NULL;

    cb = sizeof(wszStatusText) / sizeof(WCHAR);

RetryQuery:
    fRetCode = WinHttpQueryHeaders(
                    _hHTTP,
                    HTTP_QUERY_STATUS_TEXT,
                    WINHTTP_HEADER_NAME_BY_INDEX,
                    pwszStatusText,
                    &cb,
                    0);

    if (!fRetCode)
    {
        // Check for ERROR_INSUFFICIENT_BUFFER error
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            // Reallocate the status text buffer
            if (fFreeStatusString)
                delete pwszStatusText;

            pwszStatusText = New WCHAR[cb];

            if (!pwszStatusText)
                goto ErrorOutOfMemory;

            fFreeStatusString = TRUE;

            goto RetryQuery;
        }
        else
        {
            goto ErrorFail;
        }
    }

    // Convert the status text to a BSTR
    *pbstrStatus = SysAllocString(pwszStatusText);

    if (!*pbstrStatus)
        goto ErrorOutOfMemory;

    hr = NOERROR;

Cleanup:
    if (fFreeStatusString)
        delete [] pwszStatusText;
    SetErrorInfo(hr);
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;

Error:
    goto Cleanup;
}



/*
 *  CHttpRequest::get_ResponseBody
 *
 *  Purpose:
 *      Retrieve the response body as a SAFEARRAY of UI1
 *
 *  Parameters:
 *      pvarBody    OUT     Response blob
 *
 *  Errors:
 *      E_INVALIDARG
 *      E_UNEXPECTED
 *      E_PENDING
 */

STDMETHODIMP
CHttpRequest::get_ResponseBody(VARIANT * pvarBody)
{
    HRESULT hr = NOERROR;

    // Validate parameter
    if (IsBadWritePtr(pvarBody, sizeof(VARIANT)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;
    else if (_eState < CHttpRequest::RESPONSE)
        goto ErrorPending;

    VariantInit(pvarBody);

    if (_szResponseBuffer)
    {
        hr = CreateVector(
                pvarBody, 
                (const BYTE *)_szResponseBuffer,
                _cbResponseBody);

        if (FAILED(hr))
            goto Error;
    }
    else
    {
        V_VT(pvarBody) = VT_EMPTY;
    }

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorPending:
    hr = E_PENDING;
    goto Error;

Error:
    if (pvarBody)
        VariantClear(pvarBody);
    goto Cleanup;
}



/*
 *  CHttpRequest::get_ResponseText
 *
 *  Purpose:
 *      Retrieve the response body as a BSTR
 *
 *  Parameters:
 *      pbstrBody   OUT     response as a BSTR
 *
 *  Errors:
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      E_UNEXPECTED
 *      E_PENDING
 */

STDMETHODIMP
CHttpRequest::get_ResponseText(BSTR * pbstrBody)
{
    HRESULT hr;

    // Validate parameter
    if (IsBadWritePtr(pbstrBody, sizeof(BSTR)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;
    else if (_eState < CHttpRequest::RESPONSE)
        goto ErrorPending;

    hr = AsciiToBSTR(pbstrBody, _szResponseBuffer, (int)_cbResponseBody);
    
    if (FAILED(hr))
        goto Error;

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorPending:
    hr = E_PENDING;
    goto Error;

Error:
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::get_ResponseStream(VARIANT * pvarBody)
{
    HRESULT     hr = NOERROR;
    IStream *   pStm = NULL;

    // Validate parameter
    if (IsBadWritePtr(pvarBody, sizeof(VARIANT)))
        return E_INVALIDARG;

    // Validate state
    if (_eState < CHttpRequest::SENDING)
        goto ErrorCannotCallBeforeSend;
    else if (_eState < CHttpRequest::RESPONSE)
        goto ErrorPending;

    VariantInit(pvarBody);

    hr = CreateStreamOnResponse(&pStm);
    
    if (FAILED(hr))
        goto Error;

    V_VT(pvarBody) = VT_UNKNOWN;
    pvarBody->punkVal = pStm;

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeSend:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND);
    goto Error;

ErrorPending:
    hr = E_PENDING;
    goto Error;

Error:
    if (pvarBody)
        VariantClear(pvarBody);
    goto Cleanup;
}

void
CHttpRequest::SetState(State state)
{
    if (_fAsync)
    {
        InterlockedExchange((long *)&_eState, state);
    }
    else
    {
        _eState = state;
    }
}


/*
 *  CHttpRequest::CreateStreamOnResponse
 *
 *  Purpose:
 *      Create a Stream containing the Response data
 *
 *  Parameters:
 *      ppStm   IN/OUT      Stream
 *
 *  Errors:
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 */

HRESULT
CHttpRequest::CreateStreamOnResponse(IStream ** ppStm)
{
    HRESULT         hr = NOERROR;
    ULONG           cbWritten;
    LARGE_INTEGER   liReset = { 0 };

    if (!ppStm)
        return E_INVALIDARG;

    *ppStm = NULL;

    hr = CreateStreamOnHGlobal(NULL, TRUE, ppStm);

    if (FAILED(hr))
        goto ErrorOutOfMemory;

    hr = (*ppStm)->Write(_szResponseBuffer, _cbResponseBody, &cbWritten);

    if (FAILED(hr))
        goto Error;

    hr = (*ppStm)->Seek(liReset, STREAM_SEEK_SET, NULL);

    if (FAILED(hr))
        goto Error;

    hr = NOERROR;

Cleanup:
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

Error:
    if (ppStm)
        SafeRelease(*ppStm);
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::get_Option(WinHttpRequestOption Option, VARIANT * Value)
{
    HRESULT     hr;

    if (IsBadWritePtr(Value, sizeof(VARIANT)))
        return E_INVALIDARG;

    switch (Option)
    {
    case WinHttpRequestOption_UserAgentString:
        {
            V_BSTR(Value) = SysAllocString(GetUserAgentString());

            if (V_BSTR(Value) == NULL)
                goto ErrorOutOfMemory;

            V_VT(Value) = VT_BSTR;

            break;
        }

    case WinHttpRequestOption_URL:
        {
            WCHAR * pwszUrl = NULL;
            DWORD   dwBufferSize = 0;

            if (_eState < CHttpRequest::OPENED)
                goto ErrorCannotCallBeforeOpen;

            if (!WinHttpQueryOption(_hHTTP, WINHTTP_OPTION_URL, NULL, &dwBufferSize) &&
                (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
            {
                pwszUrl = New WCHAR[dwBufferSize + 1];

                if (!pwszUrl)
                    goto ErrorOutOfMemory;

                if (WinHttpQueryOption(_hHTTP, WINHTTP_OPTION_URL, pwszUrl, &dwBufferSize))
                {
                    V_BSTR(Value) = SysAllocString(pwszUrl);
                    V_VT(Value)   = VT_BSTR;

                    hr = NOERROR;
                }
                else
                {
                    hr = E_FAIL;
                }

                delete [] pwszUrl;

                if (FAILED(hr))
                {
                    goto ErrorFail;
                }
                else if (V_BSTR(Value) == NULL)
                {
                    goto ErrorOutOfMemory;
                }
            }
            break;
        }

    case WinHttpRequestOption_URLCodePage:
        V_I4(Value) = (long) _dwCodePage;
        V_VT(Value) = VT_I4;
        break;
    
    case WinHttpRequestOption_EscapePercentInURL:
        V_BOOL(Value) = (_dwEscapePercentFlag==WINHTTP_FLAG_ESCAPE_PERCENT) ? VARIANT_TRUE : VARIANT_FALSE;
        V_VT(Value)   = VT_BOOL;
        break;

    case WinHttpRequestOption_EnableRedirects:
        V_BOOL(Value) = _bDisableRedirects ? VARIANT_FALSE : VARIANT_TRUE;
        V_VT(Value)   = VT_BOOL;
        break;

    default:
        VariantInit(Value);
        return E_INVALIDARG;
    }    

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorCannotCallBeforeOpen:
    hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN);
    goto Error;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}


STDMETHODIMP
CHttpRequest::put_Option(WinHttpRequestOption Option, VARIANT Value)
{
    HRESULT     hr;

    if (!IsValidVariant(Value))
        return E_INVALIDARG;

    switch (Option)
    {
    case WinHttpRequestOption_UserAgentString:
        {
            BSTR bstrUserAgent = GetBSTRFromVariant(Value);

            if (!bstrUserAgent || (*bstrUserAgent == L'\0'))
                return E_INVALIDARG;

            if (_hInet)
            {
                if (!WinHttpSetOption(_hInet, WINHTTP_OPTION_USER_AGENT,
                        bstrUserAgent,
                        SysStringLen(bstrUserAgent)))
                {
                    goto ErrorFail;
                }
            }

            if (_hHTTP)
            {
                if (!WinHttpSetOption(_hHTTP, WINHTTP_OPTION_USER_AGENT,
                        bstrUserAgent,
                        SysStringLen(bstrUserAgent)))
                {
                    goto ErrorFail;
                }
            }

            if (_bstrUserAgent)
                SysFreeString(_bstrUserAgent);
            _bstrUserAgent = bstrUserAgent;
            break;
        }

    case WinHttpRequestOption_URL:
        // The URL cannot be set using the Option property.
        return E_INVALIDARG;

    case WinHttpRequestOption_URLCodePage:
        {
            _dwCodePage = GetDwordFromVariant(Value, CP_UTF8);

            if (_hInet)
            {
                if (!WinHttpSetOption(_hInet, WINHTTP_OPTION_CODEPAGE,
                            &_dwCodePage,
                            sizeof(_dwCodePage)))
                    goto ErrorFail;
            }

            if (_hConnection)
            {
                if (!WinHttpSetOption(_hConnection, WINHTTP_OPTION_CODEPAGE,
                            &_dwCodePage,
                            sizeof(_dwCodePage)))
                    goto ErrorFail;
            }

            break;
        }
    
    case WinHttpRequestOption_EscapePercentInURL:
        {
            BOOL fEscapePercent = GetBoolFromVariant(Value, FALSE);

            _dwEscapePercentFlag = (fEscapePercent ? WINHTTP_FLAG_ESCAPE_PERCENT : 0);
            break;
        }

    case WinHttpRequestOption_SslErrorIgnoreFlags:
        {
            DWORD dwSslIgnoreFlags = GetDwordFromVariant(Value, _dwSslIgnoreFlags);
            if (dwSslIgnoreFlags & ~SECURITY_INTERNET_MASK)
            {
                return E_INVALIDARG;
            }

            // Break automatically, so we don't need the overhead of a callback.
            dwSslIgnoreFlags |= SECURITY_FLAG_BREAK_ON_STATUS_SECURE_FAILURE;

            if (_hHTTP)
            {
                // Set the SSL ignore flags through an undocumented front door
                if (!WinHttpSetOption(_hHTTP,
                                     WINHTTP_OPTION_SECURITY_FLAGS,
                                     (LPVOID)&dwSslIgnoreFlags,
                                     sizeof(dwSslIgnoreFlags)))
                    goto ErrorFail;
            }
            _dwSslIgnoreFlags = dwSslIgnoreFlags;
            break;
        }

    case WinHttpRequestOption_SelectCertificate:
        {
            BSTR bstrCertSubject = GetBSTRFromVariant(Value);

            if (!bstrCertSubject)
            {
                // Allow all empty calls to be interpreted as "first enum"
                bstrCertSubject = SysAllocString(L"");
                if (!bstrCertSubject)
                    return E_OUTOFMEMORY;
            }
            if (_bstrCertSubject)
                SysFreeString(_bstrCertSubject);
            _bstrCertSubject = bstrCertSubject;
            break;
        }

    case WinHttpRequestOption_EnableRedirects:
        {
            BOOL fEnableRedirects = GetBoolFromVariant(Value, TRUE);

            _bDisableRedirects = fEnableRedirects ? false : true;
            break;
        }

    default:
        return E_INVALIDARG;
    }    

    hr = NOERROR;

Cleanup:
    SetErrorInfo(hr);
    return hr;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Error;

Error:
    goto Cleanup;
}


void
CHttpRequest::SetErrorInfo(HRESULT hr)
{
    if (SUCCEEDED(hr))
        return;
    
    ICreateErrorInfo *  pCErrInfo     = NULL;
    IErrorInfo *        pErrInfo      = NULL;
    DWORD               error         = hr;
    DWORD               dwFmtMsgFlag  = FORMAT_MESSAGE_FROM_SYSTEM;
    HMODULE             hModule       = NULL;
    DWORD               rc;
    LPWSTR              pwszMessage   = NULL;
    const DWORD         dwSize        = 512;

    pwszMessage = New WCHAR[dwSize];
    if (pwszMessage == NULL)
        return;
    
    if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
    {
        DWORD errcode = HRESULT_CODE(hr);

        if ((errcode > WINHTTP_ERROR_BASE) && (errcode <= WINHTTP_ERROR_LAST))
        {
            dwFmtMsgFlag = FORMAT_MESSAGE_FROM_HMODULE;

            hModule = GetModuleHandle("WINHTTP5.DLL");

            error = errcode;
        }
    }

    rc = ::FormatMessageW(dwFmtMsgFlag, hModule, 
                error, 
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                pwszMessage,
                dwSize,
                NULL);

    if (rc != 0)
    {
        if (SUCCEEDED(::CreateErrorInfo(&pCErrInfo)))
        {
            if (SUCCEEDED(pCErrInfo->QueryInterface(IID_IErrorInfo, (void **) &pErrInfo)))
            {
                pCErrInfo->SetSource(L"WinHttp.WinHttpRequest");
        
                pCErrInfo->SetGUID(IID_IWinHttpRequest);

                pCErrInfo->SetDescription(pwszMessage);
        
                ::SetErrorInfo(0, pErrInfo);

                pErrInfo->Release();
            }

            pCErrInfo->Release();
        }
    }

    delete [] pwszMessage;
}



BOOL
CHttpRequest::SelectCertificate()
{
    HCERTSTORE hMyStore = NULL;
    BOOL fRet = FALSE;
    HANDLE  hThreadToken = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    
    // If impersonating, revert while trying to obtain the cert
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ),
            FALSE,
            &hThreadToken))
    {
        INET_ASSERT(hThreadToken != 0);

        RevertToSelf();
    }

    // For now, just pick the first enum available
    // based on a simple CERT_ FIND_SUBJECT_STR criteria
    // If the user selected an empty string, then simply
    // pick the first enum.
    hMyStore = CertOpenSystemStore(NULL, "MY");
    if (!hMyStore)
    {
        goto Cleanup;
    }

    if (_bstrCertSubject && _bstrCertSubject[0])
    {
        pCertContext = CertFindCertificateInStore(hMyStore,
                                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_SUBJECT_STR,
                                                  (LPVOID) _bstrCertSubject,
                                                  NULL);
    }
    else
    {
        pCertContext = CertFindCertificateInStore(hMyStore,
                                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_ANY,
                                                  NULL,
                                                  NULL);
    }

    // Winhttp5 will add a couple of new options.
    // One will be an option to request that client auth
    // certs are not cached, so they can be session based.
    // Another will be for flushing the SSL cache on demand.
    //
    // For now, set this via a private method off of the
    // request object.
    if (pCertContext)
    {
        fRet = WinHttpSetOption(_hHTTP,
                                WINHTTP_OPTION_CLIENT_CERT_CONTEXT,
                                (LPVOID) pCertContext,
                                sizeof(CERT_CONTEXT));
    }

Cleanup:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    if (hMyStore)
        CertCloseStore(hMyStore, 0);
    
    // Restore the impersonating state for the current thread.
    if (hThreadToken)
    {
        SetThreadToken(NULL, hThreadToken);
        CloseHandle(hThreadToken);
    }
    return fRet;
}


/*
 *  BSTRToUTF8
 *
 *  Purpose:
 *      Convert a BSTR to UTF-8
 *
 */

static
HRESULT 
BSTRToUTF8(char ** psz, DWORD * pcbUTF8, BSTR bstr)
{
    UINT    cch = lstrlenW(bstr);
    
    *pcbUTF8 = 0;
    *psz     = NULL;
    
    if (cch == 0)
        return NOERROR;

    // Allocate the maximum buffer the UTF-8 string could be
    *psz = New char [(cch * 3) + 1];
    
    if (!*psz)
        return E_OUTOFMEMORY;

    *pcbUTF8 = cch * 3;

    WideCharToUtf8(bstr, cch, (BYTE *)*psz, (UINT *)pcbUTF8);

    (*psz)[*pcbUTF8] = 0;

    return NOERROR;
}



/**
 * Scans buffer and translates Unicode characters into UTF8 characters
 */
static
void
WideCharToUtf8(
    WCHAR * buffer, 
    UINT    cch,
    BYTE *  bytebuffer,
    UINT *  cb)
{
    UINT count = 0, m1 = *cb, m2 = m1 - 1, m3 = m2 - 1, m4 = m3 - 1;
    DWORD dw1;
    bool surrogate = false;

    for (UINT i = cch; i > 0; i--)
    {
        DWORD dw = *buffer;

        if (surrogate) //  is it the second char of a surrogate pair?
        {
            if (dw >= 0xdc00 && dw <= 0xdfff)
            {
                // four bytes 0x11110xxx 0x10xxxxxx 0x10xxxxxx 0x10xxxxxx
                if (count < m4)
                    count += 4;
                else
                    break;
                ULONG ucs4 = (dw1 - 0xd800) * 0x400 + (dw - 0xdc00) + 0x10000;
                *bytebuffer++ = (byte)(( ucs4 >> 18) | 0xF0);
                *bytebuffer++ = (byte)((( ucs4 >> 12) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)((( ucs4 >> 6) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)(( ucs4 & 0x3F) | 0x80);
                surrogate = false;
                buffer++;
                continue;
            }
            else // Then dw1 must be a three byte character
            {
                if (count < m3)
                    count += 3;
                else
                    break;
                *bytebuffer++ = (byte)(( dw1 >> 12) | 0xE0);
                *bytebuffer++ = (byte)((( dw1 >> 6) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)(( dw1 & 0x3F) | 0x80);
            }
            surrogate = false;
        }

        if (dw  < 0x80) // one byte, 0xxxxxxx
        {
            if (count < m1)
                count++;
            else
                break;
            *bytebuffer++ = (byte)dw;
        }
        else if ( dw < 0x800) // two WORDS, 110xxxxx 10xxxxxx
        {
            if (count < m2)
                count += 2;
            else
                break;
            *bytebuffer++ = (byte)((dw >> 6) | 0xC0);
            *bytebuffer++ = (byte)((dw & 0x3F) | 0x80);
        }
        else if (dw >= 0xd800 && dw <= 0xdbff) // Assume that it is the first char of surrogate pair
        {
            if (i == 1) // last wchar in buffer
                break;
            dw1 = dw;
            surrogate = true;
        }
        else // three bytes, 1110xxxx 10xxxxxx 10xxxxxx
        {
            if (count < m3)
                count += 3;
            else
                break;
            *bytebuffer++ = (byte)(( dw >> 12) | 0xE0);
            *bytebuffer++ = (byte)((( dw >> 6) & 0x3F) | 0x80);
            *bytebuffer++ = (byte)(( dw & 0x3F) | 0x80);
        }
        buffer++;
    }

    *cb = count;
}


/*
 *  AsciiToBSTR
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR
 *
 */

static
HRESULT 
AsciiToBSTR(BSTR * pbstr, char * sz, int cch)
{
    int cwch;

    // Determine how big the ascii string will be
    cwch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cch,
                                NULL, 0);

    *pbstr = SysAllocStringLen(NULL, cwch);

    if (!*pbstr)
        return E_OUTOFMEMORY;

    cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cch,
                                *pbstr, cwch);

    return NOERROR;
}


/*
 *  BSTRToAscii
 *
 *  Purpose:
 *      Convert a BSTR to an ascii string
 *
 */

static
HRESULT 
BSTRToAscii(char ** psz, BSTR bstr)
{
    int cch;

    *psz = NULL;

    if (!bstr)
        return S_OK;


    // Determine how big the ascii string will be
    cch = WideCharToMultiByte(CP_ACP, 0, bstr, SysStringLen(bstr),
                                NULL, 0, NULL, NULL);

    *psz = New char[cch + 1];

    if (!*psz)
        return E_OUTOFMEMORY;

    // Determine how big the ascii string will be
    cch = WideCharToMultiByte(CP_ACP, 0, bstr, SysStringLen(bstr),
                                *psz, cch, NULL, NULL);

    (*psz)[cch] = 0;
    
    return S_OK;
}



/*
 *  GetBSTRFromVariant
 *
 *  Purpose:
 *      Convert a VARIANT to a BSTR
 *
 */

static BSTR GetBSTRFromVariant(VARIANT varVariant)
{
    VARIANT varTemp;
    HRESULT hr;
    BSTR    bstrResult = NULL;

    if (V_VT(&varVariant) != VT_EMPTY && V_VT(&varVariant) != VT_NULL &&
                V_VT(&varVariant) != VT_ERROR)
    {
        VariantInit(&varTemp);

        hr = VariantChangeType(
                &varTemp,
                &varVariant,
                0,
                VT_BSTR);

        if (FAILED(hr))
            goto Error;
        
        bstrResult = V_BSTR(&varTemp); // take over ownership of BSTR
    }

    hr = NOERROR;

Cleanup:
    // DON'T clear the variant because we stole the BSTR
    //VariantClear(&varTemp);
    return bstrResult;

Error:
    goto Cleanup;
}


/*
 *  GetBoolFromVariant
 *
 *  Purpose:
 *      Convert a VARIANT to a Boolean
 *
 */

static BOOL GetBoolFromVariant(VARIANT varVariant, BOOL fDefault)
{
    HRESULT hr;
    BOOL    fResult = fDefault;

    if (V_VT(&varVariant) != VT_EMPTY && V_VT(&varVariant) != VT_NULL &&
        V_VT(&varVariant) != VT_ERROR)
    {
        VARIANT varTemp;
        VariantInit(&varTemp);
        hr = VariantChangeType(
                &varTemp,
                &varVariant,
                0,
                VT_BOOL);
    
        if (FAILED(hr))
            goto Cleanup;
        
        fResult = V_BOOL(&varTemp) == VARIANT_TRUE ? TRUE : FALSE;
    }

    hr = NOERROR;

Cleanup:
    return fResult;
}


/*
 *  GetDwordFromVariant
 *
 *  Purpose:
 *      Convert a VARIANT to a DWORD
 *
 */

static DWORD GetDwordFromVariant(VARIANT varVariant, DWORD dwDefault)
{
    HRESULT hr;
    DWORD   dwResult = dwDefault;

    if (V_VT(&varVariant) != VT_EMPTY && V_VT(&varVariant) != VT_NULL &&
        V_VT(&varVariant) != VT_ERROR)
    {
        VARIANT varTemp;
        VariantInit(&varTemp);
        hr = VariantChangeType(
                &varTemp,
                &varVariant,
                0,
                VT_UI4);
    
        if (FAILED(hr))
            goto Cleanup;
        
        dwResult = V_UI4(&varTemp);
    }

    hr = NOERROR;

Cleanup:
    return dwResult;
}

/*
 *  GetDwordFromVariant
 *
 *  Purpose:
 *      Convert a VARIANT to a DWORD
 *
 */

static long GetLongFromVariant(VARIANT varVariant, long lDefault)
{
    HRESULT hr;
    long    lResult = lDefault;

    if (V_VT(&varVariant) != VT_EMPTY && V_VT(&varVariant) != VT_NULL &&
        V_VT(&varVariant) != VT_ERROR)
    {
        VARIANT varTemp;
        VariantInit(&varTemp);
        hr = VariantChangeType(
                &varTemp,
                &varVariant,
                0,
                VT_I4);
    
        if (FAILED(hr))
            goto Cleanup;
        
        lResult = V_I4(&varTemp);
    }

    hr = NOERROR;

Cleanup:
    return lResult;
}

/**
 * Helper to create a char safearray from a string
 */
static
HRESULT
CreateVector(VARIANT * pVar, const BYTE * pData, DWORD cElems)
{
    HRESULT hr;
    BYTE * pB;

    SAFEARRAY * psa = SafeArrayCreateVector(VT_UI1, 0, cElems);
    if (!psa)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = SafeArrayAccessData(psa, (void **)&pB);
    if (hr)
        goto Error;

    memcpy(pB, pData, cElems);

    SafeArrayUnaccessData(psa);
    INET_ASSERT((pVar->vt == VT_EMPTY) || (pVar->vt == VT_NULL));
    V_ARRAY(pVar) = psa;
    pVar->vt = VT_ARRAY | VT_UI1;

    hr = NOERROR;

Cleanup:
    return hr;

Error:
    if (psa)
        SafeArrayDestroy(psa);
    goto Cleanup;
}


/*
 *  ReadFromStream
 *
 *  Purpose:
 *      Extract the contents of a stream into a buffer.
 *
 *  Parameters:
 *      ppBuf   IN/OUT      Buffer
 *      pStm    IN          Stream
 *
 *  Errors:
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 */

static
HRESULT
ReadFromStream(char ** ppData, ULONG * pcbData, IStream * pStm)
{
    HRESULT     hr = NOERROR;
    char *      pBuffer = NULL;	    // Buffer
    ULONG       cbBuffer = 0;       // Bytes in buffer
    ULONG       cbData = 0;         // Bytes of data in buffer
    ULONG       cbRead = 0;         // Bytes read from stream
    ULONG       cbNewSize = 0;
    char *      pNewBuf = NULL;

    if (!ppData || !pStm)
        return E_INVALIDARG;

    *ppData = NULL;
    *pcbData = 0;
    
    while (TRUE)
    {
        if (cbData + 512 > cbBuffer)
        {
            cbNewSize = (cbData ? cbData*2 : 4096);
            pNewBuf = New char[cbNewSize+1];

            if (!pNewBuf)
                goto ErrorOutOfMemory;

            if (cbData)
                ::memcpy(pNewBuf, pBuffer, cbData);

            cbBuffer = cbNewSize;
            delete[] pBuffer;
            pBuffer = pNewBuf;
            pBuffer[cbData] = 0;
        }

        hr = pStm->Read(
                    &pBuffer[cbData],
                    cbBuffer - cbData,
                    &cbRead);

        if (FAILED(hr))
            goto Error;
            
        cbData += cbRead;
        pBuffer[cbData] = 0;

        // No more data
        if (cbRead == 0)
            break;
    }

    *ppData = pBuffer;
    *pcbData = cbData;

    hr = NOERROR;

Cleanup:
    return hr;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

Error:
    if (pBuffer)
        delete [] pBuffer;
    goto Cleanup;
}


static
void
MessageLoop()
{
    MSG     msg;

    // There is a window message available. Dispatch it.
    while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}


static
DWORD
UpdateTimeout(DWORD dwTimeout, DWORD dwStartTime)
{
    if (dwTimeout != INFINITE)
    {
        DWORD   dwTimeNow = GetTickCount();
        DWORD   dwElapsedTime;

        if (dwTimeNow >= dwStartTime)
        {
            dwElapsedTime = dwTimeNow - dwStartTime;
        }
        else
        {
            dwElapsedTime = dwTimeNow + (0xFFFFFFFF - dwStartTime);
        }

        if (dwElapsedTime < dwTimeout)
        {
            dwTimeout -= dwElapsedTime;
        }
        else
        {
            dwTimeout = 0;
        }
    }

    return dwTimeout;
}


DWORD CSinkArray::Add(IUnknown * pUnk)
{
    ULONG iIndex;

    IUnknown** pp = NULL;

    if (_nSize == 0) // no connections
    {
	_pUnk = pUnk;
	_nSize = 1;
	return 1;
    }
    else if (_nSize == 1)
    {
	// create array
	pp = (IUnknown **)ALLOCATE_FIXED_MEMORY(sizeof(IUnknown*)* _DEFAULT_VECTORLENGTH);
	if (pp == NULL)
		return 0;
	memset(pp, 0, sizeof(IUnknown *) * _DEFAULT_VECTORLENGTH);
	*pp = _pUnk;
	_ppUnk = pp;
	_nSize = _DEFAULT_VECTORLENGTH;
    }

    for (pp = begin(); pp < end(); pp++)
    {
	if (*pp == NULL)
	{
	    *pp = pUnk;
	    iIndex = ULONG(pp-begin());
	    return iIndex+1;
	}
    }

    int nAlloc = _nSize*2;
    pp = (IUnknown **)REALLOCATE_MEMORY(_ppUnk, sizeof(IUnknown*)*nAlloc, LMEM_ZEROINIT);
    if (pp == NULL)
	return 0;

    _ppUnk = pp;
    memset(&_ppUnk[_nSize], 0, sizeof(IUnknown *)*_nSize);
    _ppUnk[_nSize] = pUnk;
    iIndex = _nSize;
    _nSize = nAlloc;
    return iIndex+1;
}

BOOL CSinkArray::Remove(DWORD dwCookie)
{
    ULONG iIndex;

    if (dwCookie == NULL)
        return FALSE;
    if (_nSize == 0)
        return FALSE;
    iIndex = dwCookie-1;
    if (iIndex >= (ULONG)_nSize)
        return FALSE;
    if (_nSize == 1)
    {
        _nSize = 0;
        return TRUE;
    }
    begin()[iIndex] = NULL;
    return TRUE;
}

void CSinkArray::ReleaseAll()
{
    for (IUnknown ** pp = begin(); pp < end(); pp++)
    {
	if (*pp != NULL)
	{
            SafeRelease(*pp);
	}
    }
}


HRESULT STDMETHODCALLTYPE
CSinkArray::QueryInterface(REFIID, void **)
{
    return E_NOTIMPL;
}


ULONG STDMETHODCALLTYPE
CSinkArray::AddRef()
{
    return 2;
}


ULONG STDMETHODCALLTYPE
CSinkArray::Release()
{
    return 1;
}

void STDMETHODCALLTYPE
CSinkArray::OnResponseStart(long Status, BSTR bstrContentType)
{
    for (IUnknown ** pp = begin(); pp < end(); pp++)
    {
	if (*pp != NULL)
	{
            IWinHttpRequestEvents * pSink;

            pSink = static_cast<IWinHttpRequestEvents *>(*pp);

            if (((*(DWORD_PTR **)pSink)[3]) != NULL)
            {
                pSink->OnResponseStart(Status, bstrContentType);
            }
	}
    }
}


void STDMETHODCALLTYPE
CSinkArray::OnResponseDataAvailable(SAFEARRAY ** ppsaData)
{
    for (IUnknown ** pp = begin(); pp < end(); pp++)
    {
	if (*pp != NULL)
	{
            IWinHttpRequestEvents * pSink;

            pSink = static_cast<IWinHttpRequestEvents *>(*pp);

            if (((*(DWORD_PTR **)pSink)[4]) != NULL)
            {
                pSink->OnResponseDataAvailable(ppsaData);
            }
	}
    }
}


void STDMETHODCALLTYPE
CSinkArray::OnResponseFinished(void)
{
    for (IUnknown ** pp = begin(); pp < end(); pp++)
    {
	if (*pp != NULL)
	{
            IWinHttpRequestEvents * pSink;

            pSink = static_cast<IWinHttpRequestEvents *>(*pp);

            if (((*(DWORD_PTR **)pSink)[5]) != NULL)
            {
                pSink->OnResponseFinished();
            }
	}
    }
}


CWinHttpRequestEventsMarshaller::CWinHttpRequestEventsMarshaller
(
    CSinkArray *    pSinkArray,
    HWND            hWnd
)
{
    INET_ASSERT((pSinkArray != NULL) && (hWnd != NULL));

    _pSinkArray  = pSinkArray;
    _hWnd        = hWnd;
    _cRefs       = 0;
    _bFireEvents = true;

    _cs.Init();
}


CWinHttpRequestEventsMarshaller::~CWinHttpRequestEventsMarshaller()
{
    INET_ASSERT(_pSinkArray == NULL);
    INET_ASSERT(_hWnd == NULL);
    INET_ASSERT(_cRefs == 0);
}


HRESULT
CWinHttpRequestEventsMarshaller::Create
(
    CSinkArray *                        pSinkArray,
    CWinHttpRequestEventsMarshaller **  ppSinkMarshaller
)
{
    CWinHttpRequestEventsMarshaller *   pSinkMarshaller = NULL;
    HWND                                hWnd = NULL;
    HRESULT                             hr = NOERROR;


    if (!RegisterWinHttpEventMarshallerWndClass())
        goto ErrorFail;

    hWnd = CreateWindowEx(0, s_szWinHttpEventMarshallerWndClass, NULL,
                0, 0, 0, 0, 0, 
                (IsPlatformWinNT() && GlobalPlatformVersion5) ? HWND_MESSAGE : NULL, 
                NULL, GlobalDllHandle, NULL);

    if (!hWnd)
        goto ErrorFail;

    pSinkMarshaller = New CWinHttpRequestEventsMarshaller(pSinkArray, hWnd);

    if (!pSinkMarshaller)
        goto ErrorOutOfMemory;

    SetLastError(0);
    
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pSinkMarshaller);

    if (GetLastError() != 0)
        goto ErrorFail;

    pSinkMarshaller->AddRef();

    *ppSinkMarshaller = pSinkMarshaller;

Exit:
    if (FAILED(hr))
    {
        if (pSinkMarshaller)
        {
            delete pSinkMarshaller;
        }
        else if (hWnd)
        {
            DestroyWindow(hWnd);
        }
    }

    return hr;

ErrorFail:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Exit;

ErrorOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Exit;
}


void
CWinHttpRequestEventsMarshaller::Shutdown()
{
    if (_cs.Lock())
    {
        FreezeEvents();

        if (_hWnd)
        {
            MessageLoop();

            DestroyWindow(_hWnd);
            _hWnd = NULL;
        }

        _pSinkArray = NULL;

        _cs.Unlock();
    }
}


LRESULT CALLBACK
CWinHttpRequestEventsMarshaller::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg >= WHREM_MSG_ON_RESPONSE_START && msg <= WHREM_MSG_ON_RESPONSE_FINISHED)
    {
        CWinHttpRequestEventsMarshaller *   pMarshaller;
        CSinkArray *                        pSinkArray;
        bool                                bOkToFireEvents = false;

        pMarshaller = (CWinHttpRequestEventsMarshaller *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

        if (pMarshaller)
        {
            pSinkArray = pMarshaller->GetSinkArray();
            bOkToFireEvents = pMarshaller->OkToFireEvents();
        }

        switch (msg)
        {
        case WHREM_MSG_ON_RESPONSE_START:
            {
                BSTR bstrContentType = (BSTR) lParam;

                if (bOkToFireEvents)
                {
                    pSinkArray->OnResponseStart((long) wParam, bstrContentType);
                }

                if (bstrContentType)
                {
                    SysFreeString(bstrContentType);
                }
            }
            break;

        case WHREM_MSG_ON_RESPONSE_DATA_AVAILABLE:
            {
                SAFEARRAY * psaData = (SAFEARRAY *) wParam;

                if (bOkToFireEvents)
                {
                    pSinkArray->OnResponseDataAvailable(&psaData);
                }

                if (psaData)
                {
                    SafeArrayDestroy(psaData);
                }
            }
            break;

        case WHREM_MSG_ON_RESPONSE_FINISHED:
            if (bOkToFireEvents)
            {
                pSinkArray->OnResponseFinished();
            }
            break;
        }

        return 0;
    }
    else
    {
        return DefWindowProc(hWnd, msg, wParam, lParam);
    }
}


HRESULT STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = NOERROR;

    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (riid == IID_IWinHttpRequestEvents || riid == IID_IUnknown)
    {
        *ppv = static_cast<IWinHttpRequestEvents *>(this);
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}



ULONG STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::AddRef()
{
    return InterlockedIncrement(&_cRefs);
}


ULONG STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::Release()
{
    DWORD cRefs = InterlockedDecrement(&_cRefs);

    if (cRefs == 0)
    {
        delete this;
        return 0;
    }
    else
        return cRefs;
}


void STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::OnResponseStart(long Status, BSTR bstrContentType)
{
    if (_cs.Lock())
    {
        if (OkToFireEvents())
        {
            BSTR    bstrContentTypeCopy;

            bstrContentTypeCopy = SysAllocString(bstrContentType);

            PostMessage(_hWnd, WHREM_MSG_ON_RESPONSE_START,
                (WPARAM) Status,
                (LPARAM) bstrContentTypeCopy);

            // Note: ownership of bstrContentType is transferred to the 
            // message window, so the string is not freed here.
        }
        _cs.Unlock();
    }
}


void STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::OnResponseDataAvailable(SAFEARRAY ** ppsaData)
{

    if (_cs.Lock())
    {
        if (OkToFireEvents())
        {
            SAFEARRAY * psaDataCopy = NULL;

            if (SUCCEEDED(SafeArrayCopy(*ppsaData, &psaDataCopy)))
            {
                PostMessage(_hWnd, WHREM_MSG_ON_RESPONSE_DATA_AVAILABLE,
                    (WPARAM) psaDataCopy, 0);
            }

            // Note: ownership of psaDataCopy is transferred to the 
            // message window, so the array is not freed here.
        }
        _cs.Unlock();
    }
}


void STDMETHODCALLTYPE
CWinHttpRequestEventsMarshaller::OnResponseFinished(void)
{
    if (_cs.Lock())
    {
        if (OkToFireEvents())
        {
            PostMessage(_hWnd, WHREM_MSG_ON_RESPONSE_FINISHED, 0, 0);
        }

        _cs.Unlock();
    }
}



BOOL RegisterWinHttpEventMarshallerWndClass()
{
    if (s_fWndClassRegistered)
        return TRUE;

    // only one thread should be here
    if (!GeneralInitCritSec.Lock())
        return FALSE;

    if (s_fWndClassRegistered == FALSE)
    {
        WNDCLASS    wndclass;

        wndclass.style          = 0;
        wndclass.lpfnWndProc    = &CWinHttpRequestEventsMarshaller::WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = GlobalDllHandle;
        wndclass.hIcon          = NULL;
        wndclass.hCursor        = NULL;;
        wndclass.hbrBackground  = (HBRUSH)NULL;
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = s_szWinHttpEventMarshallerWndClass;

        // Register the window class
        if (RegisterClass(&wndclass))
        {
            s_fWndClassRegistered = TRUE;
        }
    }

    GeneralInitCritSec.Unlock();

    return s_fWndClassRegistered;
}


void CleanupWinHttpRequestGlobals()
{
    if (s_fWndClassRegistered)
    {
        // Register the window class
        if (UnregisterClass(s_szWinHttpEventMarshallerWndClass, GlobalDllHandle))
        {
            s_fWndClassRegistered = FALSE;
        }
    }
}


static
BOOL
IsValidVariant(VARIANT v)
{
    BOOL    fOk = TRUE;

    if (V_ISBYREF(&v))
    {
        if (IsBadReadPtr(v.pvarVal, sizeof(VARIANT)))
        {
            fOk = FALSE;
            goto Exit;
        }
        else
            v = *(v.pvarVal);
    }

    switch (v.vt)
    {
    case VT_BSTR:
        fOk = IsValidBstr(v.bstrVal);
        break;

    case (VT_BYREF | VT_BSTR):
        fOk = !IsBadReadPtr(v.pbstrVal, sizeof(BSTR));
        break;

    case (VT_BYREF | VT_VARIANT):
        fOk = !IsBadReadPtr(v.pvarVal, sizeof(VARIANT)) &&
               IsValidVariant(*(v.pvarVal));
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        fOk = !IsBadReadPtr(v.punkVal, sizeof(void *));
        break;
    }

Exit:
    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\constant.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    constant.h

Abstract:

    Contains all internal constant values used in INTERNET.DLL

Author:

    Richard L Firth (rfirth) 16-Nov-1994

Revision History:

    16-Nov-1994 rfirth
        Created

--*/

//
// manifests
//

#define K       * 1024
#define M       * 1048576
#define _1K     (1 K)
#define _2K     (2 K)
#define _4K     (4 K)
#define _8K     (8 K)
#define _16K    (16 K)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\httpcache\partial.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    partial.cxx

Abstract:

    Routines for manipulating partial cache entries

Author:

Revision History:

--*/

#include <wininetp.h>
#include <string.h>

#define __CACHE_INCLUDE__
#include "..\urlcache\cache.hxx"

#include "cachelogic.hxx"
#include "..\http\proc.h"
#include "internalapi.hxx"

PRIVATE VOID HTTPCACHE_REQUEST::DeletePartialCacheFile(VOID)
{
    if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
    {
        // We can't use the partial cache entry because it is
        // stale, so delete the data file we got from cache.
        if (_hSparseFileReadHandle != INVALID_HANDLE_VALUE)
            CloseHandle(_hSparseFileReadHandle);
        _hSparseFileReadHandle = INVALID_HANDLE_VALUE;

        DeleteFile(_pCacheEntryInfo->lpszLocalFileName);
    }
}
PRIVATE BOOL HTTPCACHE_REQUEST::IsPartialCacheEntry(VOID)
// Given an entry in the cache, is the cache entry a partial cache entry
// Side effect: _fIsPartialCache;
// Precondition:  CheckIfInCache() returns TRUE
{
    INET_ASSERT(_pCacheEntryInfo != NULL);
    
    if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
        _fIsPartialCache = TRUE;
    else
        _fIsPartialCache = FALSE;
    
    return _fIsPartialCache;
}

PRIVATE VOID HTTPCACHE_REQUEST::LockPartialCacheEntry(VOID)
// Side effect: The file pointer of the cache entry got moved to the last byte
// _fIsPartialCache may change status if the file seems corrupted
{
    INET_ASSERT(_fIsPartialCache == TRUE);
    
    // open the file so it can't be deleted
    _hSparseFileReadHandle = CreateFile(_pCacheEntryInfo->lpszLocalFileName,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

     // Check the file size
    if (_hSparseFileReadHandle == INVALID_HANDLE_VALUE || 
       (SetFilePointer (_hSparseFileReadHandle, 0, NULL, FILE_END) 
        != _pCacheEntryInfo->dwSizeLow))
    {
        CloseHandle(_hSparseFileReadHandle);
        _fIsPartialCache = FALSE;
    }
}

// What are we doing here?
// Three things
// 1.  We have a partial cache entry for this URL.  No need to check
//     for expiry or correct user.  Add a Range: header to get the
//     rest of the data.
// 
// 2.  If there was Last-Modified-Time, add Unless-Modified-Since header,
//     which assures coherency in the event the URL data changed since
//     the partial download.
//
// 3.  If the entry has a 1.1 ETag, add the If-Range header.
//
PRIVATE BOOL HTTPCACHE_REQUEST::AddRangeRequestHeaders()
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "HTTPCACHE_REQUEST::AddRangeRequestHeaders",
                 NULL));

    INET_ASSERT(_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY);

    TCHAR szBuf[64+HTTP_RANGE_LEN];
    TCHAR szBuf2[64+HTTP_UMS_LEN];
  
    DWORD cbBuf = wsprintf (szBuf, "%s: bytes=%d-", HTTP_RANGE_SZ, _pCacheEntryInfo->dwSizeLow);
    DWORD cbBuf2;
    BOOL fResult = FALSE;
    
    if (!HttpAddRequestHeadersA(_hRequest,
                                szBuf,
                                cbBuf,
                                ADD_HEADER))
        goto quit;

    if (FT2LL(_pCacheEntryInfo->LastModifiedTime) != LONGLONG_ZERO)
    {
        cbBuf = sizeof(szBuf);
        FFileTimetoHttpDateTime(&(_pCacheEntryInfo->LastModifiedTime),
                                szBuf, &cbBuf);
        cbBuf2 = wsprintf(szBuf2, "%s: %s", HTTP_UMS_SZ, szBuf);
        if (!HttpAddRequestHeadersA(_hRequest,
                                    szBuf2, 
                                    cbBuf2, 
                                    ADD_HEADER))
        goto quit;
    }

    // Only HTTP 1.1 support the ETag header
    if (!(_pCacheEntryInfo->CacheEntryType & HTTP_1_1_CACHE_ENTRY))
    {
        fResult = TRUE;
    }
    else
    {
        // Look for the ETag header
        TCHAR szOutBuf[256];
        TCHAR szHeader[256 + HTTP_IF_RANGE_LEN];
        DWORD dwOutBufLen = 256;
        DWORD dwHeaderLen;
        
        // If the ETag header is present, then add the "if-range: <etag>" header
        if (HttpQueryInfoA(_hRequest, WINHTTP_QUERY_ETAG, NULL, szOutBuf, &dwOutBufLen, NULL))
        {
            dwHeaderLen = wsprintf(szHeader, "%s %s", HTTP_IF_NONE_MATCH_SZ, szOutBuf);

            fResult = HttpAddRequestHeadersA(_hRequest, 
                                              szHeader, 
                                              dwHeaderLen, 
                                              WINHTTP_ADDREQ_FLAG_ADD_IF_NEW);
        }
    }

quit:
    if ((fResult == TRUE) || 
        (fResult == FALSE && GetLastError() == ERROR_WINHTTP_HEADER_ALREADY_EXISTS)) 
        fResult = TRUE;

    DEBUG_LEAVE(fResult);
    return fResult;
}

PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::IsPartialResponseCacheable(VOID)
/*++

Routine Description:

    The transfer of the content of the HTTP response has been 
    interrupted.  This call finds out if the currently (incomplete)
    content can be commited to the cache.  

    The main criteria for this decision is whether the HTTP server
    from which the request was originated can handle range
    request.  If the server returns a "Accept-ranges" header, then
    the content is cacheable.

Arguments:

    None.

Return Value:

    BOOL

--*/
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "HTTPCACHE_REQUEST::IsPartialResponseCacheable",
                 NULL));

    TCHAR szHeader[256];
    DWORD dwSize = 256;

    DWORD dwIndex;
    BOOL fRet = FALSE;
    DWORD dwErr;

// Until chunked transfer has been implemented, we don't care
// about this bit of code
/*
    if (_RealCacheFileSize >= _ContentLength)
    {
        // We don't handle chunked transfer upon resuming a partial
        // download, so we require a Content-Length header.  Also,
        // if download file is actually complete, yet not committed
        // to cache (possibly because the client didn't read to eof)
        // then we don't want to save a partial download.  Otherwise
        // we might later start a range request for the file starting
        // one byte beyond eof.  MS Proxy 1.0 will return an invalid
        // 206 response containing the last byte of the file.  Other
        // servers or proxies that follow the latest http spec might
        // return a 416 response which is equally useless to us.
        
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }
*/
    // For HTTP/1.0, must have last-modified time, otherwise we
    // don't have a way to tell if the partial downloads are coherent.
    if (!InternalIsResponseHttp1_1(_hRequest) && (FT2LL(_ftLastModTime) == 0))
    {
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }

    // First check if there's a Content-Range header from the response
    // headers.  
    if (!HttpQueryInfoA(_hRequest, WINHTTP_QUERY_CONTENT_RANGE, NULL, szHeader, &dwSize, NULL))    
    {
        // We didn't get a Content-Range header which implies the server
        // supports byte range for this URL, so we must look for the
        // explicit invitation of "Accept-Ranges: bytes" response header.
        dwSize = 256;
        dwIndex = 0;
        if (!HttpQueryInfoA(_hRequest, WINHTTP_QUERY_ACCEPT_RANGES, NULL, szHeader, &dwSize, &dwIndex)
           || !(dwSize == sizeof(BYTES_SZ) - 1 && !strnicmp(szHeader, BYTES_SZ, dwSize)))
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    dwSize = 256;
    if (!InternalIsResponseHttp1_1(_hRequest))
    {
        // For HTTP/1.0, only cache responses from Server: Microsoft-???/*
        // Microsoft-PWS-95/*.* will respond with a single range but
        // with incorrect Content-Length and Content-Range headers.
        // Other 1.0 servers may return single range in multipart response.

        const static char szPrefix[] = "Microsoft-";
        const static DWORD ibSlashOffset = sizeof(szPrefix)-1 + 3;

        if (!HttpQueryInfoA(_hRequest, HTTP_QUERY_SERVER, NULL, szHeader, &dwSize, 0)
            || dwSize <= ibSlashOffset
            || szHeader[ibSlashOffset] != '/'
            || memcmp(szHeader, szPrefix, sizeof(szPrefix) - 1)
           )
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }
    else // if (IsResponseHttp1_1())
    {
        // For http 1.1, must have strong etag.  A weak etag starts with
        // a character other than a quote mark and cannot be used as a 
        // coherency validator.  IIS returns a weak etag when content is
        // modified within a single file system time quantum.        
        if (!HttpQueryInfoA(_hRequest, HTTP_QUERY_ETAG, NULL, szHeader, &dwSize, 0)
            || szHeader[0] != '\"')
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    fRet = TRUE;

quit:

    DEBUG_LEAVE(fRet);
    return fRet;
 }


PRIVATE PRIVATE BOOL HTTPCACHE_REQUEST::FakePartialCacheResponseHeaders(VOID)
/*++

Routine Description:

    Resume partial download.
    First thing we do here is we verify the Content-Range header is
    a valid one, and then parse it to get the numerical range values

    After that's verified, the second thing we do is we fake the 
    response headers.  The intent is to fix up the response headers 
    to appear same as a 200 response so that the partial caching 
    becomes completely invisible to the user app
    
Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "HTTPCACHE_REQUEST::FakePartialCacheResponseHeaders",
                 NULL));

    TCHAR szBuffer[256];
    DWORD dwBufferLength = sizeof(szBuffer);
    DWORD dwIndex = 0;
    TCHAR szTempBuf[256];
    DWORD dwErr = ERROR_SUCCESS;
    
    INET_ASSERT (!_fCacheWriteInProgress);

    
    
    // Retrieve the start and end of Content-Range header
    if (!HttpQueryInfoA(_hRequest,
                       HTTP_QUERY_CONTENT_RANGE,
                       NULL,
                       szBuffer, 
                       &dwBufferLength,
                       &dwIndex))
    {
        goto quit;
    }

    INET_ASSERT (szBuffer);

    PSTR pszLimit;
    LPSTR pszHeader;
    DWORD cbHeader;

    pszHeader = szBuffer;
    pszLimit = szBuffer + dwBufferLength;
    INET_ASSERT (pszLimit);
    *pszLimit = 0;

    // Extract the document length as a string and number.
    // The http 1.1 spec is very explicit that we MUST parse
    // the header and return an error if invalid.  We expect
    // it to be of the form Content-Range: bytes xxx-yyy/zzz.
    PSTR pszStart, pszEnd, pszLength;
    DWORD dwStart, dwEnd, dwLength;

    // Ensure that value is prefixed with "bytes"
    PSTR pszBytes = pszHeader;
    if (strnicmp (pszBytes, BYTES_SZ, sizeof(BYTES_SZ) - 1))
        goto quit;

    // Parse and validate start of range.
    pszStart = pszBytes + sizeof(BYTES_SZ) - 1;
    SKIPWS (pszStart);
    dwStart = StrToInt (pszStart);
    if (dwStart != _pCacheEntryInfo->dwSizeLow)
        goto quit;

    // Parse and validate end of range.
    pszEnd = StrChr (pszStart, '-');
    if (!pszEnd++)
        goto quit;
    dwEnd = StrToInt (pszEnd);
    if (dwStart > dwEnd)
        goto quit;

    // Parse and validate length.
    pszLength = StrChr (pszEnd, '/');
    if (!pszLength)
        goto quit;
    pszLength++;
    dwLength = StrToInt (pszLength);
    if (dwEnd + 1 != dwLength)
        goto quit;


    //  Which headers are we exactly changing here?
    //  1.  Change the content-length header to reflect the length of
    //      the total amount of data, not just the partial content.
    //  2.  Add an implicit "Accept-Ranges: bytes" header
    //  3.  Change the status code from 206 to 200
    //  4.  Remove the "Content-Range" header

    // Step 1:  Modify the content-length header
    wsprintf (szTempBuf, "%d", dwLength);
    dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_CONTENT_LENGTH, 
                                szTempBuf, 
                                strlen(szTempBuf), 
                                0, 
                                WINHTTP_ADDREQ_FLAG_REPLACE);
    
    /// _pRequest->SetContentLength(dwLength);   // why do we need to do this????
    INET_ASSERT(dwErr == ERROR_SUCCESS);
    
    // Step 2: Some servers omit "Accept-Ranges: bytes" since it is implicit
    // in a 206 response.  This is important to Adobe Amber ActiveX
    // control and other clients that may issue their own range
    // requests. Add the header if not present.
    if (!InternalIsResponseHeaderPresent(_hRequest, HTTP_QUERY_ACCEPT_RANGES))
    {
        const static char szAccept[] = "bytes";
        dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_ACCEPT_RANGES, 
                                (LPSTR) szAccept, 
                                sizeof(szAccept)-1, 
                                0, 
                                ADD_HEADER);
        INET_ASSERT (dwErr == ERROR_SUCCESS);
    }    

    // Step 3: Fake the status code
    
    /*  this code is replaced by the call to ReplaceStatusHeader()
    dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_STATUS_TEXT,
                                NULL,
                                0,
                                0,
                                WINHTTP_ADDREQ_FLAG_REPLACE);

    dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_STATUS_CODE,
                                NULL,
                                0,
                                0,
                                WINHTTP_ADDREQ_FLAG_REPLACE);
    
    INET_ASSERT(dwErr == ERROR_SUCCESS);
    */

   BOOL bOK;
    ((HTTP_REQUEST_HANDLE_OBJECT *)_hRequest)->ReplaceStatusHeader("200 OK");
    ((HTTP_REQUEST_HANDLE_OBJECT *)_hRequest)->SetStatusCode(200);
    ((HTTP_REQUEST_HANDLE_OBJECT *)_hRequest)->UpdateResponseHeaders(&bOK);  //BUGBUG do we need this?

    // Step 4: Remove the Content-Range header.  We'll just hope that this
    // operation really works.  (no Error code is returned by the caller)
    dwErr = InternalReplaceResponseHeader(
                                _hRequest,
                                HTTP_QUERY_CONTENT_RANGE,
                                NULL,
                                0,
                                0,
                                WINHTTP_ADDREQ_FLAG_REPLACE);    

    // Adjust the file size
    _VirtualCacheFileSize = dwStart;
    _RealCacheFileSize    = dwStart;
    DEBUG_LEAVE (dwErr);
    return TRUE;
    
quit:
    DEBUG_LEAVE (dwErr);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\cookie.h ===
// cookie.h - header for external cookie funcs code.

class CCookieJar;

CCookieJar * CreateCookieJar();
void CloseCookieJar(CCookieJar * CookieJar);

#ifndef WININET_SERVER_CORE
void PurgeCookieJar();
#endif

#define COOKIE_SECURE   INTERNET_COOKIE_IS_SECURE
#define COOKIE_SESSION  INTERNET_COOKIE_IS_SESSION // never saved to disk
#define COOKIE_NOUI     4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\ansi.h ===
#if defined(_WIN64)
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#if defined(__cplusplus)
extern "C" {
#endif

typedef struct {
    DWORD   dwOption;            // option to be queried or set
    union {
        DWORD    dwValue;        // dword value for the option
        LPSTR    pszValue;       // pointer to string value for the option
        FILETIME ftValue;        // file-time value for the option
    } Value;
} INTERNET_PER_CONN_OPTIONA, * LPINTERNET_PER_CONN_OPTIONA;
typedef INTERNET_PER_CONN_OPTIONA INTERNET_PER_CONN_OPTION;
typedef LPINTERNET_PER_CONN_OPTIONA LPINTERNET_PER_CONN_OPTION;

typedef struct {
    DWORD   dwSize;             // size of the INTERNET_PER_CONN_OPTION_LIST struct
    LPSTR   pszConnection;      // connection name to set/query options
    DWORD   dwOptionCount;      // number of options to set/query
    DWORD   dwOptionError;      // on error, which option failed
    LPINTERNET_PER_CONN_OPTIONA  pOptions;
                                // array of options to set/query
} INTERNET_PER_CONN_OPTION_LISTA, * LPINTERNET_PER_CONN_OPTION_LISTA;
typedef INTERNET_PER_CONN_OPTION_LISTA INTERNET_PER_CONN_OPTION_LIST;
typedef LPINTERNET_PER_CONN_OPTION_LISTA LPINTERNET_PER_CONN_OPTION_LIST;

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPSTR   lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPSTR   lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPSTR   lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPSTR   lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPSTR   lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPSTR   lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSA, * LPURL_COMPONENTSA;
typedef URL_COMPONENTSA URL_COMPONENTS;
typedef LPURL_COMPONENTSA LPURL_COMPONENTS;

typedef struct _INTERNET_BUFFERSA {
    DWORD dwStructSize;                 // used for API versioning. Set to sizeof(INTERNET_BUFFERS)
    struct _INTERNET_BUFFERSA * Next;   // chain of buffers
    LPCSTR   lpcszHeader;               // pointer to headers (may be NULL)
    DWORD dwHeadersLength;              // length of headers if not NULL
    DWORD dwHeadersTotal;               // size of headers if not enough buffer
    LPVOID lpvBuffer;                   // pointer to data buffer (may be NULL)
    DWORD dwBufferLength;               // length of data buffer if not NULL
    DWORD dwBufferTotal;                // total size of chunk, or content-length if not chunked
    DWORD dwOffsetLow;                  // used for read-ranges (only used in HttpSendRequest2)
    DWORD dwOffsetHigh;
} INTERNET_BUFFERSA, * LPINTERNET_BUFFERSA;
typedef INTERNET_BUFFERSA INTERNET_BUFFERS;
typedef LPINTERNET_BUFFERSA LPINTERNET_BUFFERS;

BOOLAPI
InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    OUT LPSTR lpszTime          // output string buffer
    );
#define InternetTimeFromSystemTime  InternetTimeFromSystemTimeA

BOOLAPI
InternetTimeToSystemTimeA(
    IN  LPCSTR lpszTime,         // NULL terminated string
    OUT SYSTEMTIME *pst,         // output in GMT time
    IN  DWORD dwReserved
    );
#define InternetTimeToSystemTime  InternetTimeToSystemTimeA

typedef struct
{
    DWORD dwAccessType;      // see WINHTTP_ACCESS_* types below
    LPSTR lpszProxy;         // proxy server list
    LPSTR lpszProxyBypass;   // proxy bypass list
} WINHTTP_PROXY_INFOA;

typedef WINHTTP_PROXY_INFOA* LPINTERNET_PROXY_INFO;


BOOLAPI
WinHttpCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSA lpUrlComponents
    );

BOOLAPI
WinHttpCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    );

INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );
#define InternetOpen  InternetOpenA

INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define InternetConnect  InternetConnectA

INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define InternetOpenUrl  InternetOpenUrlA

INTERNETAPI
BOOL
WINAPI
InternetReadFileExA(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSA lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define InternetReadFileEx  InternetReadFileExA

INTERNETAPI
BOOL
WINAPI
InternetWriteFileExA(
    IN HINTERNET hFile,
    IN LPINTERNET_BUFFERSA lpBuffersIn,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define InternetWriteFileEx  InternetWriteFileExA

BOOLAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#define InternetQueryOption  InternetQueryOptionA

BOOLAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );
#define InternetSetOption  InternetSetOptionA

BOOLAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwError,
    OUT LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoA

INTERNETAPI
WINHTTP_STATUS_CALLBACK
WINAPI
InternetSetStatusCallbackA(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback
    );
#define InternetSetStatusCallback  InternetSetStatusCallbackA

BOOLAPI
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );
#define HttpAddRequestHeaders  HttpAddRequestHeadersA

#define HTTP_VERSIONA           "HTTP/1.0"
#define HTTP_VERSION            HTTP_VERSIONA

INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define HttpOpenRequest  HttpOpenRequestA

BOOLAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
#define HttpSendRequest  HttpSendRequestA

BOOLAPI WinHttpSetCredentialsA (
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
   
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCSTR     pszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCSTR     pszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID     pAuthParams
   
    );
#define HttpSetCredentials  HttpSetCredentialsA

INTERNETAPI
BOOL
WINAPI
HttpSendRequestExA(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#define HttpSendRequestEx  HttpSendRequestExA

BOOLAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPCSTR      lpszName OPTIONAL,
    IN OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );
#define HttpQueryInfo  HttpQueryInfoA

#if defined(__cplusplus)
} // end extern "C" {
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\crtsubst.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    crtsubst.h

Abstract:

    Maps some CRT functions to Win32 calls

Author:

    Rajeev Dujari (rajeevd) 04-Apr-1996

Revision History:

    04-Apr-1996 rajeevd
        Created
--*/
#include "iert.h"
#ifndef unix
/*
   On NT, kernel32 forwards RtlMoveMemory to ntdll.
   On 95, kernel32 has RtlMoveMemory but ntdll doesn't.
   Override the NT headers forwarding at compile time.
*/
#ifdef RtlMoveMemory
#undef RtlMoveMemory
extern "C" void RtlMoveMemory (void *, const void *, unsigned long);
#endif

/* WARNING: Be careful mapping CRT strncpy to Win32 lstrcpyn.

   strncpy  (dst, "bar", 2);  // dst will get 'b', 'a'
   lstrcpyn (dst, "bar" 2);   // dst will get 'b',  0

   strncpy  (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0, 0, 0
   lstrcpyn (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0
*/

#undef free
#undef malloc
#undef memmove
#undef strdup
#undef stricmp
#undef _stricmp
#undef strlwr
#undef _strlwr
#undef strupr
#undef tolower
#undef toupper
#undef wcslen
#undef _strstr
#undef strstr
#undef _strchr
#undef strchr
#undef strrchr
#undef __atoi
#undef _atoi
#undef atoi
#undef _strncat
#undef strncat
#undef _strncpy
#undef strncpy
#undef _strnicmp
#undef strnicmp
#undef _strncmp
#undef strncmp
#undef StrChr


#define free(ptr)         FREE_MEMORY((HLOCAL) ptr)
#define malloc(size)      ((PVOID)ALLOCATE_MEMORY(LMEM_FIXED, size))
#define memmove(m1,m2,n)  RtlMoveMemory (m1,m2,n)
#define strdup(s)         NewString(s)
#define stricmp(s1,s2)    lstrcmpi(s1,s2)
#define _stricmp(s1,s2)   lstrcmpi(s1,s2)
#define strlwr(s)         CharLower(s)
#define _strlwr(s)        CharLower(s)
#define strupr(s)         CharUpper(s)
#define tolower(c)        ((BYTE) CharLower((LPSTR) ((DWORD_PTR)((BYTE)(c) & 0xff))))
#define toupper(c)        ((BYTE) CharUpper((LPSTR) ((DWORD_PTR)((BYTE)(c) & 0xff))))
#define wcslen(s)         lstrlenW(s)
#define _strstr           StrStr
#define strstr            StrStr
#define StrChr            PrivateStrChr
#define _strchr           StrChr
#define strchr            StrChr
#define strrchr(s, c)     StrRChr(s, NULL, c)
#define __atoi            StrToInt
#define _atoi             StrToInt
#define atoi              StrToInt
#define strncat           StrNCat
#define _strncat          StrNCat
#define strncpy           StrNCpy
#define _strncpy          StrNCpy
#define strnicmp          StrCmpNIC
#define _strnicmp         StrCmpNIC
#define strncmp           StrCmpNC
#define _strncmp          StrCmpNC

#undef itoa
#undef ultoa

//#define itoa(val,s,n)     _itoa(val,s,n)
//#define ultoa(val,s,n)    _ultoa(val,s,n)

 
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\debugmem.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.h

Abstract:

    Header for debugmem.cxx

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Revision History:

    02-Feb-1995
        Created

--*/

#ifdef WINHTTP_FOR_MSXML
#error include msxmlmem.h, not debugmem.h, for MSXML
#endif

#if defined(__cplusplus)
extern "C" {
#endif


//
// manifests
//

//
// USE_PRIVATE_HEAP_IN_RETAIL - by default we use the process heap in the retail
// build. Alternative is to use a private (wininet) heap (which we do in the
// debug version if required)
//

#if !defined(USE_PRIVATE_HEAP_IN_RETAIL)
#define USE_PRIVATE_HEAP_IN_RETAIL  0
#endif

//
// prototypes
//

VOID
InternetDebugMemInitialize(
    VOID
    );

VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    );

HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    );

HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    );

HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    );

SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    );

BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    );

BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    );

//
// macros
//

#if defined(USE_DEBUG_MEMORY)

#define ALLOCATOR(Flags, Size) \
    InternetDebugAllocMem(Flags, Size, __FILE__, __LINE__)

#define DEALLOCATOR(hLocal) \
    InternetDebugFreeMem(hLocal, __FILE__, __LINE__)

#define REALLOCATOR(hLocal, Size, Flags) \
    InternetDebugReAllocMem(hLocal, Size, Flags, __FILE__, __LINE__)

#define MEMORYSIZER(hLocal) \
    InternetDebugSizeMem(hLocal, __FILE__, __LINE__)

#define INITIALIZE_MEMORY_MANAGER() \
    InternetDebugMemInitialize()

#define TERMINATE_MEMORY_MANAGER(bReport) \
    InternetDebugMemTerminate(bReport)

#define CHECK_MEMORY_FREED(bReport) \
    InternetDebugCheckMemFreed(bReport)

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    InternetDebugMemReport(bTermSym, bCloseFile)

#else   // retail version


#if defined(USE_ROCKALL)

extern void INITIALIZE_MEMORY_MANAGER();
extern void TERMINATE_MEMORY_MANAGER(BOOL bReport);
extern void* ALLOCATOR(int Flags, int Size);
extern void* DEALLOCATOR(void *hLocal); 
extern void* REALLOCATOR(void *hLocal, int Size, int Flags);
extern int MEMORYSIZER(void *hLocal);

#else

#define ALLOCATOR(Flags, Size) \
    LocalAlloc(Flags, Size)

#define DEALLOCATOR(hLocal) \
    LocalFree(hLocal)

#define REALLOCATOR(hLocal, Size, Flags) \
    LocalReAlloc(hLocal, Size, Flags)

#define MEMORYSIZER(hLocal) \
    LocalSize(hLocal)

#define INITIALIZE_MEMORY_MANAGER() \
    /* NOTHING */

#define TERMINATE_MEMORY_MANAGER(bReport) \
    /* NOTHING */

#endif


#define CHECK_MEMORY_FREED(bReport) \
    /* NOTHING */

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    /* NOTHING */

#endif // defined(USE_DEBUG_MEMORY)

#if defined(USE_ROCKALL)

#define ALLOCATE_ZERO_MEMORY(Size) \
    ALLOCATE_MEMORY(LPTR, (Size))

#define ALLOCATE_FIXED_MEMORY(Size) \
    ALLOCATE_MEMORY(LMEM_FIXED, (Size))

#define ALLOCATE_MEMORY(Flags, Size) \
    ALLOCATOR((UINT)(Flags), (UINT)(Size))

#define FREE_ZERO_MEMORY(hLocal) \
    FREE_MEMORY((void*)(hLocal))

#define FREE_FIXED_MEMORY(hLocal) \
    FREE_MEMORY((void*)(hLocal))

#define FREE_MEMORY(hLocal) \
    DEALLOCATOR((void*)(hLocal))

#define REALLOCATE_MEMORY(hLocal, Size, Flags) \
    REALLOCATOR((void*)(hLocal), (UINT)(Size), (UINT)(Flags))

#define MEMORY_SIZE(hLocal) \
    MEMORYSIZER((void*)(hLocal))

#else

#define ALLOCATE_ZERO_MEMORY(Size) \
    ALLOCATE_MEMORY(LPTR, (Size))

#define ALLOCATE_FIXED_MEMORY(Size) \
    ALLOCATE_MEMORY(LMEM_FIXED, (Size))

#define ALLOCATE_MEMORY(Flags, Size) \
    ALLOCATOR((UINT)(Flags), (UINT)(Size))

#define FREE_ZERO_MEMORY(hLocal) \
    FREE_MEMORY((HLOCAL)(hLocal))

#define FREE_FIXED_MEMORY(hLocal) \
    FREE_MEMORY((HLOCAL)(hLocal))

#define FREE_MEMORY(hLocal) \
    DEALLOCATOR((HLOCAL)(hLocal))

#define REALLOCATE_MEMORY(hLocal, Size, Flags) \
    REALLOCATOR((HLOCAL)(hLocal), (UINT)(Size), (UINT)(Flags))

#define MEMORY_SIZE(hLocal) \
    MEMORYSIZER((HLOCAL)(hLocal))

#endif // USE_ROCKALL

#define New     new
#if defined(__cplusplus)
}
#endif

//
// Wininet no longer uses moveable memory
//

#define LOCK_MEMORY(p)          (LPSTR)(p)
#define UNLOCK_MEMORY(p)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\defaults.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    defaults.h

Abstract:

    Contains all default manifests for WININET

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

--*/

//
// default timeout values and retry counts
//

#define DEFAULT_RESOLVE_TIMEOUT             INFINITE
#define DEFAULT_CONNECT_TIMEOUT             ((LONG)1*60*1000)   // 1 minute
#define DEFAULT_CONNECT_RETRIES             5
#ifndef unix
#define DEFAULT_SEND_TIMEOUT                ((LONG)30*1000)     // 30 seconds
#define DEFAULT_RECEIVE_TIMEOUT             ((LONG)30*1000)     // 30 seconds
#else
#define DEFAULT_SEND_TIMEOUT                ((LONG)(1 * 60 * 1000)) // 1 minutes
#define DEFAULT_RECEIVE_TIMEOUT             ((LONG)(1 * 60 * 1000)) // 1 minutes
#endif /* unix */
#define DEFAULT_KEEP_ALIVE_TIMEOUT          (1 * 60 * 1000)         // 1 minute
#define DEFAULT_FROM_CACHE_TIMEOUT          (5 * 1000)              // 5 seconds
#define DEFAULT_DNS_CACHE_ENTRIES           32
#define DEFAULT_DNS_CACHE_TIMEOUT           (30 * 60)               // 30 minutes
#define DEFAULT_MAX_HTTP_REDIRECTS          100
#define DEFAULT_MAX_CONNECTIONS_PER_SERVER  2                       // default HTTP 1.1
#define DEFAULT_MAX_CONS_PER_1_0_SERVER     4                       // default HTTP 1.0
#define DEFAULT_CONNECTION_LIMIT_TIMEOUT    (1 * 60 * 1000)         // 1 minute
#define DEFAULT_CONNECTION_INACTIVE_TIMEOUT (10 * 1000)             // 10 seconds
#define DEFAULT_SERVER_INFO_TIMEOUT         (2 * 60 * 1000)         // 2 minutes
#define DEFAULT_NETWORK_OFFLINE_TIMEOUT     (5 * 1000)              // 5 seconds
#define DEFAULT_DIAL_UP_OFFLINE_TIMEOUT     (20 * 1000)             // 20 seconds
#define DEFAULT_IDLE_TIMEOUT                1000                    // 1 second
#define DEFAULT_NETWORK_PING_RETRIES        1
#define DEFAULT_DIAL_UP_PING_RETRIES        4

//
// thread pool default constants
//

#define DEFAULT_MINIMUM_THREADS     0
#define DEFAULT_MAXIMUM_THREADS     4   // arbitrary
#define DEFAULT_INITIAL_THREADS     1
#define DEFAULT_THREAD_IDLE_TIMEOUT (2 * 60 * 1000) // 2 minutes
#define DEFAULT_WORK_QUEUE_LIMIT    8
#define DEFAULT_WORK_ITEM_PRIORITY  0

//
// async scheduler thread default constants
//

#define DEFAULT_WORKER_THREAD_TIMEOUT       (2 * 60 * 1000)        // 2 minutes
#define DEFAULT_MAXIMUM_QUEUE_DEPTH         2
#define DEFAULT_FIBER_STACK_SIZE            (16 K)
#define DEFAULT_CREATE_FIBER_ATTEMPTS       4

//
// default sizes
//

#define DEFAULT_RECEIVE_BUFFER_INCREMENT        (1 K)
#define DEFAULT_TRANSPORT_PACKET_LENGTH         (1 K)
#define DEFAULT_HTML_QUERY_BUFFER_LENGTH        (4 K)
#define DEFAULT_SOCKET_SEND_BUFFER_LENGTH       ((DWORD)-1)
#define DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH    ((DWORD)-1)
#define DEFAULT_SOCKET_QUERY_BUFFER_LENGTH      (8 K)

//
// default strings
//

#define DEFAULT_HTTP_REQUEST_VERB       "GET"
#define DEFAULT_EMAIL_NAME              "user@domain"
#define DEFAULT_URL_SCHEME_NAME         "http"

// default SSL protocols
#define DEFAULT_SECURE_PROTOCOLS        (SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\dummy.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dummy.cxx

Abstract:

    Dummy file for build so we can generate the precompiled header for the
    internet project

    Contents:

Author:

     Richard L Firth (rfirth) 03-Feb-1995

Revision History:

    03-Feb-1995
        Created

--*/

#include "wininetp.h"

void __cdecl main(int, char**);

void __cdecl main(int argc, char** argv) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\inetchar.h ===
#ifndef INETCHAR_H

#define INETCHAR_H

/* Copyright (c) 1998  Microsoft Corporation

Module Name:

    inetchar.h

Abstract:

    macros for converting between Unicode and MultiByte characters.

    Contents:
        REASSIGN_ALLOC
        REASSIGN_SIZE
        ALLOC_MB
        UNICODE_TO_ANSI
        
Author:

    Ahsan S. Kabir  

Revision History:

    18Nov97 akabir
        Created

*/

//

// ---- Macros to simplify recovering values from memory packets -------------

#define REASSIGN_ALLOC(mp,ps,dw) \
    ps = mp.psStr; \
    dw = mp.dwAlloc;
    
#define REASSIGN_SIZE(mp,ps,dw) \
    ps = mp.psStr; \
    dw = mp.dwSize;


// -- (MAYBE_)ALLOC_MB ------------
// Macros to allocate enough memory for an ansi-equivalent string

#define ALLOC_MB(URLW,DWW,MPMP) { \
    MPMP.dwAlloc = ((DWW ? DWW : lstrlenW(URLW))+ 1)*sizeof(WCHAR); \
    MPMP.psStr = (LPSTR)ALLOC_BYTES(MPMP.dwAlloc*sizeof(CHAR)); }


// -- UNICODE_TO_ANSI -----
// Base case macro to convert from unicode to ansi
// We're subtracting 1 because we're converting the nullchar in dwAlloc.

#define UNICODE_TO_ANSI(pszW, mpA) \
    mpA.dwSize = \
        WideCharToMultiByte(CP_ACP,0,pszW,(mpA.dwAlloc/sizeof(*pszW))-1,mpA.psStr,mpA.dwAlloc,NULL,NULL); \
        mpA.psStr[mpA.dwSize]= '\0';

#define UNICODE_TO_ANSI_CHECKED(pszW, mpA, pfNotSafe) \
    mpA.dwSize = \
        WideCharToMultiByte(CP_ACP,0,pszW,(mpA.dwAlloc/sizeof(*pszW))-1,mpA.psStr,mpA.dwAlloc,NULL,pfNotSafe); \
        mpA.psStr[mpA.dwSize]= '\0';

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\handle.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Header file for common\handle.cxx

Author:

    Richard L Firth (rfirth) 01-Nov-1994

Revision History:

    01-Nov-1994 rfirth
        Created

--*/

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
HandleInitialize(
    VOID
    );

VOID
HandleTerminate(
    VOID
    );

DWORD
AllocateHandle(
    IN LPVOID Address,
    OUT LPHINTERNET lpHandle
    );

DWORD
FreeHandle(
    IN HINTERNET Handle
    );

DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    );

DWORD
DereferenceObject(
    IN LPVOID lpObject
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\inetsspi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsspi.h

Abstract:

    Contains all constant values and prototype decls used in inetsspi.cxx

Author:

    Sophia Chung (SophiaC)  02-Jan-1996

Revision History:

--*/

#ifndef _INETSSPI_H_
#define _INETSSPI_H_

#ifdef __cplusplus
extern "C" {
#endif


//
//  Encryption Capabilities
//

#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active
#define ENC_CAPS_SCHANNEL_CREDS    0x00000004       // Uses SCHANNEL Creds Struct

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//  PCT & SSL are both supported
//

#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | ENC_CAPS_PCT)
#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

#define INVALID_CRED_VALUE         {0xFFFFFFFF, 0xFFFFFFFF}

#define IS_CRED_INVALID(s) (((s)->dwUpper == 0xFFFFFFFF) && ((s)->dwLower == 0xFFFFFFFF))

typedef struct _SEC_PROVIDER
{
    CHAR            *pszName;          // security pkg name
    CredHandle      hCreds;           // credential handle
    DWORD           dwFlags;          // encryption capabilities
    BOOL            fEnabled;         // enable flag indicator
    DWORD           dwProtocolFlags;  // protocol flags that this provider supports.
    PCCERT_CONTEXT  pCertCtxt;        // cert context to use when getting default credentials.
} SEC_PROVIDER, *PSEC_PROVIDER;

//
//  Array of encryption providers
//

extern SEC_PROVIDER SecProviders[];

//
//  Global EncProvider flag
//

extern DWORD dwEncFlags;


//
//  Prototypes
//

BOOL
SecurityPkgInitialize(
    BOOL fForce = FALSE
    );

DWORD
EncryptData(
    IN CtxtHandle* hContext,
    IN LPVOID   lpBuffer,
    IN DWORD    dwInBufferLen,
    OUT LPVOID *lplpBuffer,
    OUT DWORD  *lpdwOutBufferLen,
    OUT DWORD  *lpdwInBufferBytesEncrypted
    );

DWORD
DecryptData(
    IN CtxtHandle* hContext,
    IN OUT DBLBUFFER* pdblbufBuffer,
    OUT DWORD     *lpdwBytesNeeded,
    OUT LPBYTE        lpOutBuffer,
    IN OUT DWORD  *lpdwOutBufferLeft,
    IN OUT DWORD  *lpdwOutBufferReceived,
    IN OUT DWORD  *lpdwOutBufferBytesRead
    );

VOID
TerminateSecConnection(
    IN CtxtHandle* hContext
    );


DWORD 
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo,
                  IN LPDWORD lpdwStatusFlag);


#ifdef __cplusplus
}
#endif

#endif //_INETSSPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\inetdbg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetdbg.h

Abstract:

    Manifests, macros, types and prototypes for Windows Internet client DLL
    debugging functions

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// misc. debug manifests
//

#define DEBUG_WAIT_TIME     (2 * 60 * 1000)

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

#if DBG

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG

//
// types
//

//
// DEBUG_FUNCTION_RETURN_TYPE - Type of result (scalar) that a function returns
//

#ifdef ENABLE_DEBUG

typedef enum {
    None,
    Bool,
    Int,
    Dword,
    String,
    Handle,
    Pointer
} DEBUG_FUNCTION_RETURN_TYPE;

//
// INTERNET_DEBUG_RECORD - for each thread, we maintain a LIFO stack of these,
// describing the functions we have visited
//

typedef struct _INTERNET_DEBUG_RECORD {

    //
    // Stack - a LIFO stack of debug records is maintained in the debug version
    // of the INTERNET_THREAD_INFO
    //

    struct _INTERNET_DEBUG_RECORD* Stack;

    //
    // Category - the function's category flag(s)
    //

    DWORD Category;

    //
    // ReturnType - type of value returned by function
    //

    DEBUG_FUNCTION_RETURN_TYPE ReturnType;

    //
    // Function - name of the function
    //

    LPCSTR Function;

    //
    // LastTime - if we are dumping times as deltas, keeps the last tick count
    //

    DWORD LastTime;

} INTERNET_DEBUG_RECORD, *LPINTERNET_DEBUG_RECORD;

//
// INTERNET_FUNCTION_TRIGGER - if we are required to trigger on a function, this
// structure maintains the debugging flags
//

typedef struct _INTERNET_FUNCTION_TRIGGER {

    //
    // Next - we maintain a singly-linked list of INTERNET_FUNCTION_TRIGGERs
    //

    struct _INTERNET_FUNCTION_TRIGGER* Next;

    //
    // Hash - hash value for the function name, to cut-down strcmp's to 1
    //

    DWORD Hash;

    //
    // Function - name of the function - must match exactly
    //

    LPCSTR Function;

    //
    // Category - category debug flags to use when this function triggers
    //

    DWORD MajorCategory;

} INTERNET_FUNCTION_TRIGGER, *LPINTERNET_FUNCTION_TRIGGER;

//
// data
//

extern DWORD InternetDebugErrorLevel;
extern DWORD InternetDebugControlFlags;
extern DWORD InternetDebugCategoryFlags;
extern DWORD InternetDebugBreakFlags;

//
// prototypes
//

//
// inetdbg.cxx
//

VOID
InternetDebugInitialize(
    VOID
    );

VOID
InternetDebugTerminate(
    VOID
    );

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    );

BOOL
InternetOpenDebugFile(
    VOID
    );

BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    );

VOID
InternetCloseDebugFile(
    VOID
    );

VOID
InternetFlushDebugFile(
    VOID
    );

VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList,
    IN ...
    );

VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetDebugError(
    IN DWORD Error
    );

VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    );

VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    IN va_list valist
    );

VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    );

VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    );

VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    );

DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    );

VOID
InternetAssert(
    IN LPSTR Condition,
    IN LPSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    );

LPSTR
InternetMapError(
    IN DWORD Error
    );

LPSTR
InternetMapStatus(
    IN DWORD Status
    );

LPSTR
InternetMapOption(
    IN DWORD Option
    );

LPSTR
InternetMapSSPIError(
    IN DWORD Status
    );

LPSTR
InternetMapHttpOption(
    IN DWORD Option
    );

LPSTR
InternetMapHttpState(
    IN WORD State
    );

LPSTR
InternetMapHttpStateFlag(
    IN WORD Flag
    );

LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    );

LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    );

LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    );

LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    );

LPSTR
InternetMapService(
    IN DWORD Service
    );         

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN_VALUE eToken
    );

LPSTR
InternetMapChunkState(
    IN CHUNK_DECODE_STATE eState
    );

DWORD
InternetHandleCount(
    VOID
    );

int dprintf(char *, ...);

LPSTR
SourceFilename(
    LPSTR Filespec
    );

VOID
InitSymLib(
    VOID
    );

VOID
TermSymLib(
    VOID
    );

LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    );

VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

//
// exceptn.cxx
//

VOID
SetExceptionHandler(
    VOID
    );

#else

#define dprintf (VOID)

#endif // #ifdef ENABLE_DEBUG

//
// macros
//

#ifdef ENABLE_DEBUG

//
// INET_DEBUG_START - initialize debugging support
//

#define INET_DEBUG_START() \
    InternetDebugInitialize()

//
// INET_DEBUG_FINISH - terminate debugging support
//

#define INET_DEBUG_FINISH() \
    InternetDebugTerminate()

// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//      welcome.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
BOOL CDECL CcshellRipMsgA(BOOL bRip, LPCSTR pszMsg, ...);
BOOL CDECL CcshellRipMsgW(BOOL bRip, LPCSTR pszMsg, ...);

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg
    
#ifdef UNICODE
#define CcshellRip      CcshellRipW
#define CcshellRipMsg   CcshellRipMsgW
#else
#define CcshellRip      CcshellRipA
#define CcshellRipMsg   CcshellRipMsgA
#endif

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define SH_DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define SH_DEBUG_BREAK        do { _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } while (0)
#endif
 
#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            SH_DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG          CcshellRipMsg

//
// INET_ASSERT - The standard assert, redefined here because Win95 doesn't have
// RtlAssert
//

#if defined(DISABLE_ASSERTS)

#define INET_ASSERT(test) \
    /* NOTHING */

#else

#define INET_ASSERT(test) \
    do if (!(test)) { \
        InternetAssert(#test, __FILE__, __LINE__); \
    } while (0)

#endif // defined(RETAIL_LOGGING)

#else // end #ifdef ENABLE_DEBUG

#define INET_DEBUG_START() \
    /* NOTHING */

#define INET_DEBUG_FINISH() \
    /* NOTHING */

#define INET_ASSERT(test) \
    do { } while(0) /* NOTHING */
    
#define RIP(f)
#define RIPMSG          1 ? (void)0 : (void)

#endif // end #ifndef ENABLE_DEBUG

//
// INET_DEBUG_ASSERT - assert only if INET_DEBUG is set
//

#if INET_DEBUG
#define INET_DEBUG_ASSERT(cond) INET_ASSERT(cond)
#else
#define INET_DEBUG_ASSERT(cond) /* NOTHING */
#endif

#if INET_DEBUG

//
// IF_DEBUG_CODE - always on if INET_DEBUG is set
//

#define IF_DEBUG_CODE() \
    if (1)

//
// IF_DEBUG - only execute following code if the specific flag is set
//

#define IF_DEBUG(x) \
    if (InternetDebugCategoryFlags & DBG_ ## x)

//
// IF_DEBUG_CONTROL - only execute if control flag is set
//

#define IF_DEBUG_CONTROL(x) \
    if (InternetDebugControlFlags & DBG_ ## x)

//
// DEBUG_ENTER - creates an INTERNET_DEBUG_RECORD for this function
//

#if defined(RETAIL_LOGGING)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    InternetDebugEnter ParameterList

#else

#define DEBUG_ENTER_API DEBUG_ENTER
#define DEBUG_ENTER(ParameterList) \
    InternetDebugEnter ParameterList

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_LEAVE - destroys this function's INTERNET_DEBUG_RECORD
//

#if defined(RETAIL_LOGGING)

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#else

#define DEBUG_LEAVE_API DEBUG_LEAVE
#define DEBUG_LEAVE(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_ERROR - displays an error and its symbolic name
//

#define DEBUG_ERROR(Category, Error) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugError(Error); \
    }

//
// DEBUG_PRINT - print debug info if we are at the correct level or we are
// requested to always dump information at, or above, InternetDebugErrorLevel
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#else

#define DEBUG_PRINT_API DEBUG_PRINT
#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_PUT - prints formatted string to debug output stream
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PUT(Args) \
    /* NOTHING */

#else

#define DEBUG_PUT(Args) \
    InternetDebugPrintf Args

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_DUMP - dump data
//

#if defined(RETAIL_LOGGING)

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#else

#define DEBUG_DUMP_API DEBUG_DUMP
#define DEBUG_DUMP(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_BREAK - break into debugger if break flag is set for this module
//

#define DEBUG_BREAK(Module) \
    if (InternetDebugBreakFlags & DBG_ ## Module) { \
        InternetDebugPrintf("Breakpoint. File %s Line %d\n", \
                            __FILE__, \
                            __LINE__ \
                            ); \
        DebugBreak(); \
    }

//
// WAIT_FOR_SINGLE_OBJECT - perform WaitForSingleObject and check we didn't
// get a timeout
//

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), DEBUG_WAIT_TIME); \
    if (Error == WAIT_TIMEOUT) { \
        InternetDebugPrintf("single object timeout\n"); \
        DebugBreak(); \
    }

//
// DEBUG_WAIT_TIMER - create DWORD variable for holding time
//

#define DEBUG_WAIT_TIMER(TimerVar) \
    DWORD TimerVar

//
// DEBUG_START_WAIT_TIMER - get current tick count
//

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    TimerVar = GetTickCountWrap()

//
// DEBUG_CHECK_WAIT_TIMER - get the current number of ticks, subtract from the
// previous value recorded by DEBUG_START_WAIT_TIMER and break to debugger if
// outside the predefined range
//

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    TimerVar = (GetTickCountWrap() - TimerVar); \
    if (TimerVar > MilliSeconds) { \
        InternetDebugPrintf("Wait time (%d mSecs) exceeds acceptable value (%d mSecs)\n", \
                            TimerVar, \
                            MilliSeconds \
                            ); \
        DebugBreak(); \
    }

#define DEBUG_DATA(Type, Name, InitialValue) \
    Type Name = InitialValue

#define DEBUG_DATA_EXTERN(Type, Name) \
    extern Type Name

#define DEBUG_LABEL(label) \
    label:

#define DEBUG_GOTO(label) \
    goto label

#define DEBUG_ONLY(x) \
    x

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)
#define GET_CALL_STACK(p)           x86SleazeCallStack((LPVOID *)&p, ARRAY_ELEMENTS(p), 0)

#else

#define GET_CALLERS_ADDRESS(p, pp)
#define GET_CALL_STACK(p)

#endif // defined(i386)

#else // end #if INET_DEBUG

#define IF_DEBUG_CODE() \
    if (0)

#define IF_DEBUG(x) \
    if (0)

#define IF_DEBUG_CONTROL(x) \
    if (0)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    /* NOTHING */

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    /* NOTHING */

#define DEBUG_ERROR(Category, Error) \
    /* NOTHING */

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PUT(Args) \
    /* NOTHING */

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_BREAK(module) \
    /* NOTHING */

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), INFINITE)

#define DEBUG_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    /* NOTHING */

#define DEBUG_DATA(Type, Name, InitialValue) \
    /* NOTHING */

#define DEBUG_DATA_EXTERN(Type, Name) \
    /* NOTHING */

#define DEBUG_LABEL(label) \
    /* NOTHING */

#define DEBUG_GOTO(label) \
    /* NOTHING */

#define DEBUG_ONLY(x) \
    /* NOTHING */

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    External definitions for data in dll\globals.c

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

--*/

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#if defined(__cplusplus)
extern "C" {
#endif

//
// macros
//

#define UPDATE_GLOBAL_PROXY_VERSION() \
    InterlockedIncrement((LPLONG)&GlobalProxyVersionCount)


#define COOKIES_WARN     0 // warn with a dlg if using cookies
#define COOKIES_ALLOW    1 // allow cookies without any warning
#define COOKIES_DENY     2 // disable cookies completely


//
// external variables
//

extern HINSTANCE GlobalDllHandle;
#define GlobalResHandle     GlobalDllHandle  // change for plugable ui
extern DWORD GlobalPlatformType;
extern DWORD GlobalPlatformVersion5;
extern DWORD GlobalPlatformMillennium;

extern BOOL GlobalDataInitialized;

extern DWORD InternetMajorVersion;
extern DWORD InternetMinorVersion;
extern DWORD InternetBuildNumber;

extern const DWORD GlobalResolveTimeout;
extern const DWORD GlobalConnectTimeout;
extern const DWORD GlobalConnectRetries;
extern const DWORD GlobalSendTimeout;
extern const DWORD GlobalReceiveTimeout;
extern const DWORD GlobalFtpAcceptTimeout;
extern const DWORD GlobalTransportPacketLength;
extern const DWORD GlobalKeepAliveSocketTimeout;
extern const DWORD GlobalSocketSendBufferLength;
extern const DWORD GlobalSocketReceiveBufferLength;
extern const DWORD GlobalMaxHttpRedirects;
extern const DWORD GlobalMaxConnectionsPerServer;
extern const DWORD GlobalMaxConnectionsPer1_0Server;
extern const DWORD GlobalConnectionInactiveTimeout;
extern const DWORD GlobalServerInfoTimeout;

extern BOOL InDllCleanup;
extern BOOL GlobalDynaUnload;
extern BOOL GlobalDisableKeepAlive;
extern const DWORD GlobalSecureProtocols;
extern BOOL GlobalEnableHttp1_1;
extern BOOL GlobalEnableProxyHttp1_1;
extern BOOL GlobalDisableReadRange;
extern BOOL GlobalIsProcessExplorer;
extern const BOOL GlobalEnableFortezza;
extern HANDLE g_hCompletionPort;
extern LPOVERLAPPED g_lpCustomOverlapped;
#define COMPLETION_BYTES_CUSTOM ((DWORD)-1)
#define COMPLETION_BYTES_EXITIOCP ((DWORD)-2)
#define WINHTTP_GLOBAL_IOCP_THREADS_BACKUP 2
extern DWORD g_cNumIOCPThreads;

#if INET_DEBUG
extern LONG g_cWSACompletions;
extern LONG g_cCustomCompletions;
#endif

extern LONG g_cSessionCount;
class CAsyncCount
{
private:

    DWORD dwRef;

public:

    CAsyncCount()
    {
        dwRef = 0;
    }
    
    DWORD AddRef();
    VOID Release();
    //make sure you grab the GeneralInitCritSec before making this call.
    DWORD GetRef()
    {
        return dwRef;
    }
};
extern CAsyncCount* g_pAsyncCount;

extern const BOOL fDontUseDNSLoadBalancing;

extern BOOL GlobalWarnOnPost;
extern BOOL GlobalWarnAlways;

extern LONG GlobalInternetOpenHandleCount;
extern DWORD GlobalProxyVersionCount;
extern BOOL GlobalAutoProxyInInit;
extern BOOL GlobalAutoProxyCacheEnable;
extern BOOL GlobalDisplayScriptDownloadFailureUI;

extern SERIALIZED_LIST GlobalObjectList;

extern LONGLONG dwdwHttpDefaultExpiryDelta;
extern LONGLONG dwdwSessionStartTime;
extern LONGLONG dwdwSessionStartTimeDefaultDelta;

extern SECURITY_CACHE_LIST GlobalCertCache;

extern BOOL GlobalDisableNTLMPreAuth;

extern CCritSec AuthenticationCritSec;
extern CCritSec GeneralInitCritSec;
extern CCritSec LockRequestFileCritSec;
extern CCritSec AutoProxyDllCritSec;
extern CCritSec MlangCritSec;

extern GLOBAL PP_CONTEXT GlobalPassportContext;

extern const char vszSyncMode[];




extern INTERNET_VERSION_INFO InternetVersionInfo;
extern HTTP_VERSION_INFO HttpVersionInfo;
extern BOOL fCdromDialogActive;

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

extern char gszAt[];
extern char gszBang[];
extern char gszCRLF[3];

//
// novell client32 (hack) "support"
//

extern BOOL GlobalRunningNovellClient32;
extern const BOOL GlobalNonBlockingClient32;


// shfolder.dll hmod handle
extern HMODULE g_HMODSHFolder;
// shell32.dll hmod handle
extern HMODULE g_HMODShell32;

extern DWORD GlobalIdentity;
extern GUID GlobalIdentityGuid;
#ifdef WININET6
extern HKEY GlobalCacheHKey;
#endif


//
// prototypes
//

BOOL
GlobalDllInitialize(
    VOID
    );

VOID
GlobalDllTerminate(
    VOID
    );

DWORD
GlobalDataInitialize(
    VOID
    );

VOID
GlobalDataTerminate(
    VOID
    );

BOOL
IsHttp1_1(
    VOID
    );

VOID
ChangeGlobalSettings(
    VOID
    );


typedef HRESULT
(STDAPICALLTYPE * PFNINETMULTIBYTETOUNICODE)
(
    LPDWORD  lpdword,
    DWORD    dwSrcEncoding,
    LPCSTR   lpSrcStr,
    LPINT    lpnSrcSize,
    LPWSTR   lpDstStr,
    LPINT    lpDstStrSize
);

// Loads Mlang and returns a pointer to the MultiByte to Unicode converter.
// Could return NULL if mlang.dll couldn't be loaded for some reason. 
PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( );

#if defined(__cplusplus)
}
#endif

#endif //_GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\inetp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetp.h

Abstract:

    Contains the Internet Gateway Service private functions proto type
    definitions.

Author:

    Madan Appiah  (madana)  11-Nov-1994

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef _INETP_
#define _INETP_

#if defined(__cplusplus)
extern "C" {
#endif

//
// types
//

typedef enum {
    TypeGenericHandle = 'HneG',
    TypeInternetHandle = 'tenI',
    TypeFtpConnectHandle = 'noCF',
    TypeFtpFindHandle = 'dnFF',
    TypeFtpFindHandleHtml = 'HnFF',
    TypeFtpFileHandle = 'liFF',
    TypeFtpFileHandleHtml = 'HlFF',
    TypeGopherConnectHandle = 'noCG',
    TypeGopherFindHandle = 'dnFG',
    TypeGopherFindHandleHtml = 'HnFG',
    TypeGopherFileHandle = 'liFG',
    TypeGopherFileHandleHtml = 'HlFG',
    TypeHttpConnectHandle = 'noCH',
    TypeHttpRequestHandle = 'qeRH',
    TypeFileRequestHandle = 'flRH',
    TypeWildHandle = 'dliW'
} HINTERNET_HANDLE_TYPE, *LPHINTERNET_HANDLE_TYPE;

//
// typedef virtual close function.
//

typedef BOOL ( *CLOSE_HANDLE_FUNC ) ( HINTERNET );
typedef BOOL ( *CONNECT_CLOSE_HANDLE_FUNC ) ( HINTERNET, DWORD );

//
// prototypes
//

BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    );

DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    );

//
// remote/RPC/object functions
//

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle,
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    );

DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    );

DWORD
RSetUrl(
    HINTERNET Handle,
    LPSTR lpszUrl
    );

DWORD
RGetUrl(
    HINTERNET Handle,
    LPSTR* lpszUrl
    );

DWORD
RSetDirEntry(
    HINTERNET Handle,
    LPSTR lpszDirEntry
    );

DWORD
RGetDirEntry(
    HINTERNET Handle,
    LPSTR* lpszDirEntry
    );

DWORD
RSetParentHandle(
    HINTERNET hChild,
    HINTERNET hParent,
    BOOL DeleteWithChild
    );

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    );

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    );

DWORD
RGetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    LPDWORD lpdwTimeoutValue
    );

DWORD
RSetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    DWORD dwTimeoutValue
    );

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback
    );

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType,
    IN DWORD dwFlags
    );

DWORD
RMakeInternetConnectObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    LPSTR lpszServerName,
    INTERNET_PORT nServerPort,
    DWORD dwFlags,
    DWORD_PTR dwContext
    );

DWORD
RMakeHttpReqObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags,
    DWORD_PTR dwContext
    );


//
// non-exported Internet subordinate functions
//
DWORD
HttpWriteData(
    IN HINTERNET hRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwSocketFlags
    );

DWORD
HttpReadData(
    IN HINTERNET hHttpRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwSocketFlags
    );

PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

DWORD
pHttpGetUrlInfo(
    IN HANDLE RequestHandle,
    IN LPBYTE Headers,
    IN DWORD HeadersLength,
    IN LPBYTE UrlBuf,
    IN OUT DWORD *UrlBufLen,
    IN BOOL ReloadFlagCheck
    );

BOOLAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
BOOLAPI
InternetCanonicalizeUrlW(
    IN LPCWSTR lpszUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlW
#else
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlA
#endif // !UNICODE

BOOLAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
BOOLAPI
InternetCombineUrlW(
    IN LPCWSTR lpszBaseUrl,
    IN LPCWSTR lpszRelativeUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCombineUrl  InternetCombineUrlW
#else
#define InternetCombineUrl  InternetCombineUrlA
#endif // !UNICODE

#if defined(__cplusplus)
}
#endif

#endif // _INETP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\makefile.inc ===
winhttp.h: winhttp.w
	hsplit -o winhttp.h internal.h winhttp.w
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\macros.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Contains all internal macros used in INTERNET.DLL

    Contents:
        ROUND_UP_?K
        ROUND_UP_DWORD
        NEW
        DEL
        NEW_STRING
        DEL_STRING
        NEW_MEMORY
        ZAP
        PRIVATE
        PUBLIC
        GLOBAL
        LOCAL
        DEBUG_FUNCTION
        SKIPWS

Author:

    Richard L Firth (rfirth) 16-Nov-1994

Revision History:

    16-Nov-1994 rfirth
        Created

--*/

//
// macros
//

//
// ROUND_UP_ - return (n) rounded up to the next (k) bytes
//

#define ROUND_UP_NK(n, k)   (((n) + ((_ ## k ## K) - 1)) & -(_ ## k ## K))
#define ROUND_UP_2K(n)      ROUND_UP_NK(n, 2)
#define ROUND_UP_4K(n)      ROUND_UP_NK(n, 4)
#define ROUND_UP_8K(n)      ROUND_UP_NK(n, 8)
#define ROUND_UP_16K(n)     ROUND_UP_NK(n, 16)

//
// ROUND_UP_DWORD - return (n) rounded up to the next 4 bytes
//

#define ROUND_UP_DWORD(value) \
    (((value) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))

//
// ARRAY_ELEMENTS - returns number of elements in array
//

#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof(array[0]))

//
// NEW - allocates a new 'object' of type (obj). Memory is allocated with
// LocalAlloc and initialized to zeroes
//

#define NEW(object) \
    (object FAR *)ALLOCATE_ZERO_MEMORY(sizeof(object))

//
// DEL - (should be DELETE, but that symbol is taken) - does opposite of NEW()
//

#define DEL(object) \
    FREE_MEMORY(object)

//
// NEW_STRING - performs NEW for a string
//

#define NEW_STRING(string) \
    NewString(string, 0)

//
// DEL_STRING - performs DEL for a string
//

#define DEL_STRING(string) \
    FREE_MEMORY(string)

//
// NEW_MEMORY - performs NEW for arbitrary sized memory
//

#define NEW_MEMORY(n, type) \
    (type FAR *)ALLOCATE_FIXED_MEMORY(n * sizeof(type))

//
// ZAP - zeroes an object (must be a variable, not a pointer)
//

#define ZAP(thing) \
    ZeroMemory((PVOID)&thing, sizeof(thing))

//
// STRTOUL - character-width independent (compile-time controlled) strtoul
//

#define STRTOUL             strtoul

//
// PRIVATE - make static items visible in debug version *FOR GLOBALS ONLY*. Use
// LOCAL in functions
//

#if INET_DEBUG

#define PRIVATE

#else

//#define PRIVATE static
#define PRIVATE

#endif // INET_DEBUG

//
// PUBLIC - just used as an aide-a-programmer pour le nonce
//

#define PUBLIC

//
// GLOBAL - same as PUBLIC, aide-a-programmer (for now) that tells you this
// thang has global scope
//

#define GLOBAL

//
// LOCAL - always expands to static, so you know that this thing only has
// local scope (within the current block)
//

#define LOCAL   static

//
// DEBUG_FUNCTION - this is a debug-only routine (if it get compiled in retail
// version a compile-time error is generated)
//

#if INET_DEBUG

#define DEBUG_FUNCTION

#else

#define DEBUG_FUNCTION

#endif // INET_DEBUG

//
// SKIPWS - skips blank widespace on the front of a string
//

#define SKIPWS(s) while (*(s)==' ' || *(s)=='\t') (s)++;


//
// MAKE_LOWER - takes an assumed upper character and bit manipulates into a lower.
//              (make sure the character is Upper case alpha char to begin, otherwise it corrupts)
//

#define MAKE_LOWER(c) (c | 0x20)

//
// MAKE_UPPER - takes an assumed lower character and bit manipulates into a upper.
//              (make sure the character is Lower case alpha char to begin, otherwise it corrupts)
//

#define MAKE_UPPER(c) (c & 0xdf)

//
// FASTCALL - used to bypass problems that may arise with UNIX compilers
//

#ifdef FASTCALL
#undef FASTCALL
#endif

#ifdef unix
#define FASTCALL
#else
#define FASTCALL __fastcall
#endif


//
// macro to cast FILETIME to LONGLONG
//
#define FT2LL(x) ( ((LONGLONG)((x).dwLowDateTime)) | (((LONGLONG)((x).dwHighDateTime))<<32) )


//
// Inline function to handle adding LONGLONG to FILETIME.
//
static __inline
void AddLongLongToFT( IN OUT LPFILETIME lpft,
                      IN     LONGLONG   llVal )
{
        LONGLONG llTmp;

        llTmp = FT2LL(*lpft);
        llTmp += llVal;

        lpft->dwLowDateTime =  ((LPDWORD)&llTmp)[0];
        lpft->dwHighDateTime = ((LPDWORD)&llTmp)[1];
}





//
// Macro to compute the number of bytes between two pointers
// The type of this expression is size_t, a signed integral
// type matching the size of a pointer
//
#define PtrDifference(x,y)  ((LPBYTE)(x) - (LPBYTE)(y))

//
// Macro to typecast 64-bit quantity to 32-bits
// Asserts in debug mode if the typecast loses information
//
#ifdef  DBG
#define GuardedCast(x)      ((x)<=0xFFFFFFFFL ? (DWORD)(x) : (InternetAssert(FALSE, __FILE__, __LINE__), 0))
#else
#define GuardedCast(x)      (DWORD)(x)
#endif

// Macro for the most common case
#define PtrDiff32(x,y)      (GuardedCast(PtrDifference(x,y)))

#define NOVTABLE            __declspec(novtable)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\inethttp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    inethttp.h

Abstract:

    This header maps some wininet API to winhttp

--*/

// API mappings

#define InternetTimeFromSystemTime  WinHttpTimeFromSystemTime

#define InternetTimeToSystemTime    WinHttpTimeToSystemTime

#define InternetCrackUrl            WinHttpCrackUrl

#define InternetCreateUrl           WinHttpCreateUrl

#define InternetOpen                WinHttpOpen

#define InternetSetStatusCallback(h, pcb)\
    WinHttpSetStatusCallback(h, pcb, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, 0)

#define InternetSetOption           WinHttpSetOption

#define InternetQueryOption         WinHttpQueryOption

#define InternetConnect(h,s,port,user,pass,svc,flag,ctx) \
    WinHttpConnect(h,s,port,flag,ctx)

#define HttpOpenRequest             WinHttpOpenRequest

#define HttpAddRequestHeaders       WinHttpAddRequestHeaders

#define HttpSendRequest(h,ph,cbh,pr,cbr)\
    WinHttpSendRequest(h,ph,cbh,pr,cbr,cbr,0)


#define HttpSendRequestEx(h,pbi,pbo,dw,c)\
    WinHttpSendRequest(h,   \
        (pbi)->lpcszHeader,     \
        (pbi)->dwHeadersLength, \
        (pbi)->lpvBuffer,       \
        (pbi)->dwBufferLength,  \
        (pbi)->dwBufferTotal,   \
        0)

#define InternetWriteFile(h,p,cb,pcb)\
    WinHttpWriteData(h,p,cb,pcb,0)

#define HttpEndRequest              WinHttpReceiveResponse

#define HttpQueryInfo(h,dw,pb,pcb,ndx)\
	WinHttpQueryHeaders(h,dw,((LPCWSTR) pb),pb,pcb,ndx)

#define InternetQueryDataAvailable  WinHttpQueryDataAvailable

#define InternetReadFile(h,p,cb,pcb)\
    WinHttpReadData(h,p,cb,pcb,0)

#define InternetCloseHandle         WinHttpCloseHandle

#define InternetOpenUrl             WinHttpOpenUrl


// InternetSetOption values

#define INTERNET_FIRST_OPTION                        WINHTTP_FIRST_OPTION
#define INTERNET_OPTION_CALLBACK                     WINHTTP_OPTION_CALLBACK
#define INTERNET_OPTION_RESOLVE_TIMEOUT              WINHTTP_OPTION_RESOLVE_TIMEOUT
#define INTERNET_OPTION_CONNECT_TIMEOUT              WINHTTP_OPTION_CONNECT_TIMEOUT
#define INTERNET_OPTION_CONNECT_RETRIES              WINHTTP_OPTION_CONNECT_RETRIES
#define INTERNET_OPTION_SEND_TIMEOUT                 WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_RECEIVE_TIMEOUT              WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_HANDLE_TYPE                  WINHTTP_OPTION_HANDLE_TYPE
#define INTERNET_OPTION_READ_BUFFER_SIZE             WINHTTP_OPTION_READ_BUFFER_SIZE
#define INTERNET_OPTION_WRITE_BUFFER_SIZE            WINHTTP_OPTION_WRITE_BUFFER_SIZE
#define INTERNET_OPTION_PARENT_HANDLE                WINHTTP_OPTION_PARENT_HANDLE
#define INTERNET_OPTION_REQUEST_FLAGS                WINHTTP_OPTION_REQUEST_FLAGS
#define INTERNET_OPTION_EXTENDED_ERROR               WINHTTP_OPTION_EXTENDED_ERROR
#define INTERNET_OPTION_SECURITY_FLAGS               WINHTTP_OPTION_SECURITY_FLAGS
#define INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT  WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT
#define INTERNET_OPTION_URL                          WINHTTP_OPTION_URL
#define INTERNET_OPTION_SECURITY_KEY_BITNESS         WINHTTP_OPTION_SECURITY_KEY_BITNESS
#define INTERNET_OPTION_PROXY                        WINHTTP_OPTION_PROXY
#define INTERNET_OPTION_VERSION                      WINHTTP_OPTION_VERSION
#define INTERNET_OPTION_USER_AGENT                   WINHTTP_OPTION_USER_AGENT
#define INTERNET_OPTION_CONTEXT_VALUE                WINHTTP_OPTION_CONTEXT_VALUE
#define INTERNET_OPTION_CLIENT_CERT_CONTEXT          WINHTTP_OPTION_CLIENT_CERT_CONTEXT
#define INTERNET_OPTION_POLICY                       WINHTTP_OPTION_POLICY
#define INTERNET_OPTION_REQUEST_PRIORITY             WINHTTP_OPTION_REQUEST_PRIORITY
#define INTERNET_OPTION_HTTP_VERSION                 WINHTTP_OPTION_HTTP_VERSION
#define INTERNET_OPTION_ERROR_MASK                   WINHTTP_OPTION_ERROR_MASK
#define INTERNET_OPTION_CONTROL_SEND_TIMEOUT         WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT      WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_DATA_SEND_TIMEOUT            WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_DATA_RECEIVE_TIMEOUT         WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_CODEPAGE                     WINHTTP_OPTION_CODEPAGE
#define INTERNET_OPTION_MAX_CONNS_PER_SERVER         WINHTTP_OPTION_MAX_CONNS_PER_SERVER
#define INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER     WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER
#define INTERNET_OPTION_PER_CONNECTION_OPTION        WINHTTP_OPTION_PER_CONNECTION_OPTION
#define INTERNET_OPTION_DIGEST_AUTH_UNLOAD           WINHTTP_OPTION_DIGEST_AUTH_UNLOAD
#define INTERNET_LAST_OPTION                         WINHTTP_LAST_OPTION

// status callback

#define INTERNET_ASYNC_RESULT                        WINHTTP_ASYNC_RESULT
#define LPINTERNET_ASYNC_RESULT                      LPWINHTTP_ASYNC_RESULT

#define INTERNET_STATUS_RESOLVING_NAME               WINHTTP_STATUS_RESOLVING_NAME
#define INTERNET_STATUS_NAME_RESOLVED                WINHTTP_STATUS_NAME_RESOLVED
#define INTERNET_STATUS_CONNECTING_TO_SERVER         WINHTTP_STATUS_CONNECTING_TO_SERVER
#define INTERNET_STATUS_CONNECTED_TO_SERVER          WINHTTP_STATUS_CONNECTED_TO_SERVER
#define INTERNET_STATUS_SENDING_REQUEST              WINHTTP_STATUS_SENDING_REQUEST
#define INTERNET_STATUS_REQUEST_SENT                 WINHTTP_STATUS_REQUEST_SENT
#define INTERNET_STATUS_RECEIVING_RESPONSE           WINHTTP_STATUS_RECEIVING_RESPONSE
#define INTERNET_STATUS_RESPONSE_RECEIVED            WINHTTP_STATUS_RESPONSE_RECEIVED
#define INTERNET_STATUS_CLOSING_CONNECTION           WINHTTP_STATUS_CLOSING_CONNECTION
#define INTERNET_STATUS_CONNECTION_CLOSED            WINHTTP_STATUS_CONNECTION_CLOSED
#define INTERNET_STATUS_HANDLE_CREATED               WINHTTP_STATUS_HANDLE_CREATED
#define INTERNET_STATUS_HANDLE_CLOSING               WINHTTP_STATUS_HANDLE_CLOSING
#define INTERNET_STATUS_DETECTING_PROXY              WINHTTP_STATUS_DETECTING_PROXY
#define INTERNET_STATUS_REQUEST_COMPLETE             WINHTTP_STATUS_REQUEST_COMPLETE
#define INTERNET_STATUS_REDIRECT                     WINHTTP_STATUS_REDIRECT
#define INTERNET_STATUS_INTERMEDIATE_RESPONSE        WINHTTP_STATUS_INTERMEDIATE_RESPONSE

#define INTERNET_STATUS_CALLBACK                     WINHTTP_STATUS_CALLBACK
#define LPINTERNET_STATUS_CALLBACK                   LPWINHTTP_STATUS_CALLBACK
#define INTERNET_INVALID_STATUS_CALLBACK             WINHTTP_INVALID_STATUS_CALLBACK
#define INTERNET_NO_CALLBACK                         0

// flags

#define INTERNET_FLAG_RELOAD                         WINHTTP_FLAG_REFRESH
#define INTERNET_FLAG_RESYNCHRONIZE                  WINHTTP_FLAG_REFRESH
#define INTERNET_FLAG_PRAGMA_NO_CACHE                WINHTTP_FLAG_BYPASS_CACHE
#define INTERNET_FLAG_NO_CACHE_WRITE                 0
#define INTERNET_FLAG_DONT_CACHE                     0
#define INTERNET_FLAG_MAKE_PERSISTENT                0
#define INTERNET_FLAG_READ_PREFETCH                  0
#define INTERNET_FLAG_CACHE_IF_NET_FAIL              0
#define INTERNET_FLAG_CACHE_ASYNC                    0
#define INTERNET_FLAG_BGUPDATE                       0
#define INTERNET_FLAG_HYPERLINK                      0
#define INTERNET_FLAG_FWD_BACK                       0
#define INTERNET_FLAG_NO_UI                          0
#define INTERNET_FLAG_KEEP_CONNECTION                0


// handle types

#define INTERNET_HANDLE_TYPE_INTERNET           WINHTTP_HANDLE_TYPE_SESSION
#define INTERNET_HANDLE_TYPE_CONNECT_HTTP       WINHTTP_HANDLE_TYPE_CONNECT
#define INTERNET_HANDLE_TYPE_HTTP_REQUEST       WINHTTP_HANDLE_TYPE_REQUEST


#define HTTP_ADDREQ_INDEX_MASK        WINHTTP_ADDREQ_INDEX_MASK
#define HTTP_ADDREQ_FLAGS_MASK        WINHTTP_ADDREQ_FLAGS_MASK
#define HTTP_ADDREQ_FLAG_ADD_IF_NEW   WINHTTP_ADDREQ_FLAG_ADD_IF_NEW
#define HTTP_ADDREQ_FLAG_ADD          WINHTTP_ADDREQ_FLAG_ADD
#define HTTP_ADDREQ_FLAG_REPLACE      WINHTTP_ADDREQ_FLAG_REPLACE
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
#define HTTP_ADDREQ_FLAG_COALESCE                  WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA


#define HTTP_QUERY_MIME_VERSION                 WINHTTP_QUERY_MIME_VERSION                
#define HTTP_QUERY_CONTENT_TYPE                 WINHTTP_QUERY_CONTENT_TYPE                
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING   
#define HTTP_QUERY_CONTENT_ID                   WINHTTP_QUERY_CONTENT_ID                  
#define HTTP_QUERY_CONTENT_DESCRIPTION          WINHTTP_QUERY_CONTENT_DESCRIPTION         
#define HTTP_QUERY_CONTENT_LENGTH               WINHTTP_QUERY_CONTENT_LENGTH              
#define HTTP_QUERY_CONTENT_LANGUAGE             WINHTTP_QUERY_CONTENT_LANGUAGE            
#define HTTP_QUERY_ALLOW                        WINHTTP_QUERY_ALLOW                       
#define HTTP_QUERY_PUBLIC                       WINHTTP_QUERY_PUBLIC                      
#define HTTP_QUERY_DATE                         WINHTTP_QUERY_DATE                        
#define HTTP_QUERY_EXPIRES                      WINHTTP_QUERY_EXPIRES                     
#define HTTP_QUERY_LAST_MODIFIED                WINHTTP_QUERY_LAST_MODIFIED               
#define HTTP_QUERY_MESSAGE_ID                   WINHTTP_QUERY_MESSAGE_ID                  
#define HTTP_QUERY_URI                          WINHTTP_QUERY_URI                         
#define HTTP_QUERY_DERIVED_FROM                 WINHTTP_QUERY_DERIVED_FROM                
#define HTTP_QUERY_COST                         WINHTTP_QUERY_COST                        
#define HTTP_QUERY_LINK                         WINHTTP_QUERY_LINK                        
#define HTTP_QUERY_PRAGMA                       WINHTTP_QUERY_PRAGMA                      
#define HTTP_QUERY_VERSION                      WINHTTP_QUERY_VERSION                     
#define HTTP_QUERY_STATUS_CODE                  WINHTTP_QUERY_STATUS_CODE                 
#define HTTP_QUERY_STATUS_TEXT                  WINHTTP_QUERY_STATUS_TEXT                 
#define HTTP_QUERY_RAW_HEADERS                  WINHTTP_QUERY_RAW_HEADERS                 
#define HTTP_QUERY_RAW_HEADERS_CRLF             WINHTTP_QUERY_RAW_HEADERS_CRLF            
#define HTTP_QUERY_CONNECTION                   WINHTTP_QUERY_CONNECTION                  
#define HTTP_QUERY_ACCEPT                       WINHTTP_QUERY_ACCEPT                      
#define HTTP_QUERY_ACCEPT_CHARSET               WINHTTP_QUERY_ACCEPT_CHARSET              
#define HTTP_QUERY_ACCEPT_ENCODING              WINHTTP_QUERY_ACCEPT_ENCODING             
#define HTTP_QUERY_ACCEPT_LANGUAGE              WINHTTP_QUERY_ACCEPT_LANGUAGE             
#define HTTP_QUERY_AUTHORIZATION                WINHTTP_QUERY_AUTHORIZATION               
#define HTTP_QUERY_CONTENT_ENCODING             WINHTTP_QUERY_CONTENT_ENCODING            
#define HTTP_QUERY_FORWARDED                    WINHTTP_QUERY_FORWARDED                   
#define HTTP_QUERY_FROM                         WINHTTP_QUERY_FROM                        
#define HTTP_QUERY_IF_MODIFIED_SINCE            WINHTTP_QUERY_IF_MODIFIED_SINCE           
#define HTTP_QUERY_LOCATION                     WINHTTP_QUERY_LOCATION                    
#define HTTP_QUERY_ORIG_URI                     WINHTTP_QUERY_ORIG_URI                    
#define HTTP_QUERY_REFERER                      WINHTTP_QUERY_REFERER                     
#define HTTP_QUERY_RETRY_AFTER                  WINHTTP_QUERY_RETRY_AFTER                 
#define HTTP_QUERY_SERVER                       WINHTTP_QUERY_SERVER                      
#define HTTP_QUERY_TITLE                        WINHTTP_QUERY_TITLE                       
#define HTTP_QUERY_USER_AGENT                   WINHTTP_QUERY_USER_AGENT                  
#define HTTP_QUERY_WWW_AUTHENTICATE             WINHTTP_QUERY_WWW_AUTHENTICATE            
#define HTTP_QUERY_PROXY_AUTHENTICATE           WINHTTP_QUERY_PROXY_AUTHENTICATE          
#define HTTP_QUERY_ACCEPT_RANGES                WINHTTP_QUERY_ACCEPT_RANGES               
#define HTTP_QUERY_SET_COOKIE                   WINHTTP_QUERY_SET_COOKIE                  
#define HTTP_QUERY_COOKIE                       WINHTTP_QUERY_COOKIE                      
#define HTTP_QUERY_REQUEST_METHOD               WINHTTP_QUERY_REQUEST_METHOD              
#define HTTP_QUERY_REFRESH                      WINHTTP_QUERY_REFRESH                     
#define HTTP_QUERY_CONTENT_DISPOSITION          WINHTTP_QUERY_CONTENT_DISPOSITION         
#define HTTP_QUERY_AGE                          WINHTTP_QUERY_AGE                         
#define HTTP_QUERY_CACHE_CONTROL                WINHTTP_QUERY_CACHE_CONTROL               
#define HTTP_QUERY_CONTENT_BASE                 WINHTTP_QUERY_CONTENT_BASE                
#define HTTP_QUERY_CONTENT_LOCATION             WINHTTP_QUERY_CONTENT_LOCATION            
#define HTTP_QUERY_CONTENT_MD5                  WINHTTP_QUERY_CONTENT_MD5                 
#define HTTP_QUERY_CONTENT_RANGE                WINHTTP_QUERY_CONTENT_RANGE               
#define HTTP_QUERY_ETAG                         WINHTTP_QUERY_ETAG                        
#define HTTP_QUERY_HOST                         WINHTTP_QUERY_HOST                        
#define HTTP_QUERY_IF_MATCH                     WINHTTP_QUERY_IF_MATCH                    
#define HTTP_QUERY_IF_NONE_MATCH                WINHTTP_QUERY_IF_NONE_MATCH               
#define HTTP_QUERY_IF_RANGE                     WINHTTP_QUERY_IF_RANGE                    
#define HTTP_QUERY_IF_UNMODIFIED_SINCE          WINHTTP_QUERY_IF_UNMODIFIED_SINCE         
#define HTTP_QUERY_MAX_FORWARDS                 WINHTTP_QUERY_MAX_FORWARDS                
#define HTTP_QUERY_PROXY_AUTHORIZATION          WINHTTP_QUERY_PROXY_AUTHORIZATION         
#define HTTP_QUERY_RANGE                        WINHTTP_QUERY_RANGE                       
#define HTTP_QUERY_TRANSFER_ENCODING            WINHTTP_QUERY_TRANSFER_ENCODING           
#define HTTP_QUERY_UPGRADE                      WINHTTP_QUERY_UPGRADE                     
#define HTTP_QUERY_VARY                         WINHTTP_QUERY_VARY                        
#define HTTP_QUERY_VIA                          WINHTTP_QUERY_VIA                         
#define HTTP_QUERY_WARNING                      WINHTTP_QUERY_WARNING                     
#define HTTP_QUERY_EXPECT                       WINHTTP_QUERY_EXPECT                      
#define HTTP_QUERY_PROXY_CONNECTION             WINHTTP_QUERY_PROXY_CONNECTION            
#define HTTP_QUERY_UNLESS_MODIFIED_SINCE        WINHTTP_QUERY_UNLESS_MODIFIED_SINCE       
#define HTTP_QUERY_ECHO_REQUEST                 WINHTTP_QUERY_ECHO_REQUEST                
#define HTTP_QUERY_ECHO_REPLY                   WINHTTP_QUERY_ECHO_REPLY                  
#define HTTP_QUERY_ECHO_HEADERS                 WINHTTP_QUERY_ECHO_HEADERS                
#define HTTP_QUERY_ECHO_HEADERS_CRLF            WINHTTP_QUERY_ECHO_HEADERS_CRLF           
#define HTTP_QUERY_PROXY_SUPPORT                WINHTTP_QUERY_PROXY_SUPPORT               
#define HTTP_QUERY_AUTHENTICATION_INFO          WINHTTP_QUERY_AUTHENTICATION_INFO         
#define HTTP_QUERY_MAX                          WINHTTP_QUERY_MAX                         
#define HTTP_QUERY_CUSTOM                       WINHTTP_QUERY_CUSTOM                      
#define HTTP_QUERY_FLAG_REQUEST_HEADERS         WINHTTP_QUERY_FLAG_REQUEST_HEADERS        
#define HTTP_QUERY_FLAG_SYSTEMTIME              WINHTTP_QUERY_FLAG_SYSTEMTIME             
#define HTTP_QUERY_FLAG_NUMBER                  WINHTTP_QUERY_FLAG_NUMBER                 

#define ERROR_INTERNET_FORCE_RETRY              WINHTTP_ERROR_RESEND_REQUEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\iwinsock.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    iwinsock.hxx

Abstract:

    Contains prototypes for indirected sockets functions

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Moved into SOCKET_FUNC_ARRAY in order to supports Socks.

--*/

#if !defined(_IWINSOCK_)
#define _WINSOCK_

#if defined(__cplusplus)
extern "C" {
#endif

//
// includes
//

#include <winsock2.h>
#include <basetyps.h>
#include <nspapi.h>
#include <svcguid.h>

//
// prototypes
//

BOOL
IwinsockInitialize(
    VOID
    );

VOID
IwinsockTerminate(
    VOID
    );

DWORD
LoadWinsock(
    VOID
    );

VOID
UnloadWinsock(
    VOID
    );

DWORD
SafeCloseSocket(
    IN SOCKET Socket
    );

//
// sockets functions
//

extern
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

extern
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    );

extern
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    );

extern
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    );

extern
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    );

extern
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    LPSTR lpHostName
    );

extern
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    );

extern
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

extern
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    );

extern
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    );

extern
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    );

extern
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    );

extern
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    );

extern
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    );

extern
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    );

extern
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    );

extern
int 
(PASCAL FAR * _I_WSARecv)(
    SOCKET s,                                               
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesRecvd,                           
    LPDWORD lpFlags,                                        
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    );

extern
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    );

extern
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    );

extern
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    );

extern
int
(PASCAL FAR * _I_WSASend)(
    SOCKET s,                                                  
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesSent,                            
    DWORD dwFlags,                                          
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    );

extern
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    );

extern
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    );

extern
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    );

extern
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    );

//
// WSA functions
//

extern
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    );

extern
int
(PASCAL FAR * _I_WSACleanup)(
    void
    );

extern
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    );

extern
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    );

extern
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    );

class CWrapOverlapped
{
    WSAOVERLAPPED m_Overlapped;
    LONG m_dwReferenceCount;

public:

    CWrapOverlapped()
    {
        //Don't need to zero out the overlapped struct here.
        // since we zero it out in the fsm's before using (see icsocket.cxx)
        m_dwReferenceCount = 1;
    }
    
    LONG Reference()
    {
        return InterlockedIncrement(&m_dwReferenceCount);
    }

    BOOL Dereference()
    {
        BOOL bRet = FALSE;
        LONG lResult = InterlockedDecrement(&m_dwReferenceCount);

        if (lResult == 0)
        {
            delete this;
            bRet = TRUE;
        }

        return bRet;
    }

    LPWSAOVERLAPPED GetOverlapped()
    {
        return &m_Overlapped;
    }

    friend CWrapOverlapped* GetWrapOverlappedObject(LPVOID lpAddress);
};
//
// macros
//

#ifndef unix
#if defined(FD_ISSET)
#undef FD_ISSET
#endif

#define FD_ISSET(fd, set) _I___WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))
#endif /* unix */

#if INET_DEBUG

VOID
IWinsockCheckSockets(
    VOID
    );

#define CHECK_SOCKETS() IWinsockCheckSockets()

#else

#define CHECK_SOCKETS() /* NOTHING */

#endif

#if defined(__cplusplus)
}
#endif

#endif // _IWINSOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\msxmlmem.h ===
typedef INT_PTR	TAG;

#include "../../core/base/memutil.h"


#define ALLOCATE_ZERO_MEMORY(Size)  \
    _MemAlloc(Size, HEAP_ZERO_MEMORY)

#define ALLOCATE_FIXED_MEMORY(Size) \
    MemAllocNe(Size)

#define ALLOCATE_MEMORY(Flags, Size) \
    ((Flags & LMEM_ZEROINIT) != 0 ?     \
        ALLOCATE_ZERO_MEMORY(Size) : ALLOCATE_FIXED_MEMORY(Size))

#define FREE_ZERO_MEMORY(pv) \
    FREE_MEMORY((pv))

#define FREE_FIXED_MEMORY(pv) \
    FREE_MEMORY((pv))

#define FREE_MEMORY(pv) \
    (MemFree((pv)), NULL)

#define REALLOCATE_MEMORY(pv, Size, Flags) \
    _MemReAlloc((pv), (Size), HEAP_ZERO_MEMORY)


#define New     new_ne


#define INITIALIZE_DEBUG_MEMORY() \
    /* NOTHING */

#define TERMINATE_DEBUG_MEMORY(bReport) \
    /* NOTHING */

#define CHECK_MEMORY_FREED(bReport) \
    /* NOTHING */

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    /* NOTHING */


//
// Wininet no longer uses moveable memory
//

#define LOCK_MEMORY(p)          (LPSTR)(p)
#define UNLOCK_MEMORY(p)


struct TLSDATA;

inline void InitializeMsxmlTLS()
{
    extern struct TLSDATA * EnsureTlsData();

    (void) EnsureTlsData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\parsers.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.h

Abstract:

    Contains prototypes etc. for common\parsers.cxx

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD ConvertedNumber
    );

BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD ConvertedNumber
    );

BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT ConvertedNumber
    );

BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\parseurl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.h

Abstract:

    Header for parseurl.c and protocol-specific parsers

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Revision History:

    26-Apr-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define SAFE                0x00    // character is safe in all schemes
#define SCHEME_FTP          0x01    // character is unsafe in FTP scheme
#define SCHEME_GOPHER       0x02    // character is unsafe in gopher scheme
#define SCHEME_HTTP         0x04    // character is unsafe in HTTP scheme
#define UNSAFE              0x80    // character is unsafe in all schemes
#define HOSTNAME            0x08

#define SCHEME_ANY          (SCHEME_FTP | SCHEME_GOPHER | SCHEME_HTTP)

//
// types
//

typedef
DWORD
(*LPFN_URL_PARSER)(
    LPHINTERNET,
    LPSTR,
    DWORD,
    LPSTR,
    DWORD,
    DWORD,
    DWORD_PTR
    );

//
// prototypes
//

BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    );

BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    );

DWORD
ParseUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPVOID hMapped,
    IN LPCSTR Url,
    IN LPCSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* UrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    );

DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR* EncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    );

class MEMORYPACKET;

DWORD
ConvertUnicodeToMultiByte(
    IN LPCWSTR lpszObjectName, 
    IN DWORD dwCodePage, 
    OUT MEMORYPACKET* pmpObjectName, 
    IN DWORD dwFlags);
    
//
// flags for EncodeUrlPath
//

#define NO_ENCODE_PATH_SEP  0x00000001

DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR UnescapedString,
    IN OUT LPDWORD UnescapedLength
    );

DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    );

DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    );

DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    );

DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT INTERNET_PORT* lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    );

INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    );

LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    );

LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    );

//
// protocol-specific URL parsers
//


DWORD
ParseHttpUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\registry.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Prototypes, etc., for dll\registry.c

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Revision History:

    20-Mar-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

#define INTERNET_POLICY_KEY         "SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

//
// prototypes
//

DWORD
OpenInternetSettingsKey(
    VOID
    );

DWORD
CloseInternetSettingsKey(
    VOID
    );

DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    );

DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

#ifdef WININET6
DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );
#endif

DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetWriteRegistryString(
    IN LPCSTR ParameterName,
    IN LPSTR ParameterValue
    );


#if INET_DEBUG

VOID
DbgRegKey_Init(
    VOID
    );

VOID
DbgRegKey_Terminate(
    VOID
    );

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    );

LONG
DbgRegCloseKey(
    IN HKEY hKey
    );

#define INITIALIZE_DEBUG_REGKEY() \
    DbgRegKey_Init()

#define TERMINATE_DEBUG_REGKEY() \
    DbgRegKey_Terminate()

#define REGOPENKEY(a, b, c) \
    DbgRegOpenKey((a), (b), (c), __FILE__, __LINE__)

#define REGOPENKEYEX(a, b, c, d, e) \
    DbgRegOpenKeyEx((a), (b), (c), (d), (e), __FILE__, __LINE__)

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    DbgRegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i), __FILE__, __LINE__)

#define REGCLOSEKEY(a) \
    DbgRegCloseKey(a)

#else

#define INITIALIZE_DEBUG_REGKEY() \
    /* NOTHING */

#define TERMINATE_DEBUG_REGKEY() \
    /* NOTHING */

#define REGOPENKEY(a, b, c) \
    RegOpenKey((a), (b), (c))

#define REGOPENKEYEX(a, b, c, d, e) \
    RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a) \
    RegCloseKey(a)

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\proxreg.h ===
#include <inetreg.h>

#define BLOB_BUFF_GRANULARITY   1024

class CRegBlob
{
    private:
        HKEY    _hkey;
        BOOL    _fWrite;
        BOOL    _fCommit;
        DWORD   _dwOffset;
        DWORD   _dwBufferLimit;
        BYTE *  _pBuffer;
        LPCSTR  _pszValue;

    public:
        CRegBlob(BOOL fWrite);
        ~CRegBlob();
        DWORD Init(HKEY hBaseKey, LPCSTR pszSubKey, LPCSTR pszValue);
        DWORD Abandon();
        DWORD Commit();
        DWORD WriteString(LPCSTR pszString);
        DWORD ReadString(LPCSTR * ppszString);
        DWORD WriteBytes(LPCVOID pBytes, DWORD dwByteCount);
        DWORD ReadBytes(LPVOID pBytes, DWORD dwByteCount);

    private:
        DWORD Encrpyt();
        DWORD Decrypt();
};


typedef struct {

    //
    // dwStructSize - Structure size to handle growing list of new entries or priv/pub structures
    //

    DWORD dwStructSize;

    //
    // dwFlags - Proxy type flags
    //

    DWORD dwFlags;

    //
    // dwCurrentSettingsVersion - a counter incremented every time we change our settings
    //

    DWORD dwCurrentSettingsVersion;

    //
    // lpszConnectionName - name of the Connectoid for this connection
    //
    
    LPCSTR lpszConnectionName;

    //
    // lpszProxy - proxy server list
    //

    LPCSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCSTR lpszProxyBypass;

} INTERNET_PROXY_INFO_EX, * LPINTERNET_PROXY_INFO_EX;

// name of blob for saved legacy settings
#define LEGACY_SAVE_NAME            "SavedLegacySettings"

DWORD
LoadProxySettings();

DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

DWORD
SetPerConnOptions(
    HINTERNET hInternet,    
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2
    );

HKEY
FindBaseProxyKey(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\passport.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passport.h

Abstract:

    WinInet/WinHttp- Passport Auenthtication Package Interface.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef PASSPORT_H
#define PASSPORT_H

typedef void* PP_CONTEXT;
typedef void* PP_LOGON_CONTEXT;

//
// Passport related error codes
//

// generic internal error
#define PP_GENERIC_ERROR   -1   // biaow-todo: GetLastError() to return more specific error codes

// generic async error
#define PP_REQUEST_PENDING -9

//
// return codes from PP_Logon
//
#define PP_LOGON_SUCCESS    0
#define PP_LOGON_FAILED     1
#define PP_LOGON_REQUIRED   2

//
// return codes from PP_GetReturnVerbAndUrl
//
#define PP_RETURN_KEEP_VERB 1
#define PP_RETURN_USE_GET   0

#define PFN_LOGON_CALLBACK PVOID    // biaow-todo: define the async callback prototype

//
// Passport Context routines
//

PP_CONTEXT 
PP_InitContext(
    IN PCWSTR    pwszHttpStack, // "WinInet.dll" or "WinHttp5.dll"

    IN HINTERNET hSession       // An existing session (i.e. hInternet) returned by InternetOpen() 
                                // or WinHttpOpen(); hSession must compatible with pwszHttpStack. 
                                // (e.g.WinInet.Dll<->InternetOpen() or WinHttp5.Dll<->WinHttpOpen() )
    );

VOID 
PP_FreeContext(
	IN PP_CONTEXT hPP
    );

//
// Passport Logon Context routines
//

PP_LOGON_CONTEXT
PP_InitLogonContext(
	IN PP_CONTEXT  hPP,
	IN PCWSTR      pwszPartnerInfo,   // i.e. "WWW-Authenticate: Passport1.4 ..." from partner 
                                      // site's 302 re-direct
    IN DWORD       dwParentFlags
    );

DWORD
PP_Logon(
    IN PP_LOGON_CONTEXT    hPPLogon,
	IN HANDLE	           hEvent,          // biaow-todo: async
    IN PFN_LOGON_CALLBACK  pfnLogonCallback,// biaow-todo: async
    IN DWORD               dwContext        // biaow-todo: async
    );

// -- This method should be called when PP_Logon() returns PP_LOGON_REQUIRED 
// -- (i.e. 401 from a Passport DA)
BOOL
PP_GetChallengeInfo(
    IN PP_LOGON_CONTEXT hPPLogon,
    OUT HBITMAP**       ppBitmap,   // can be NULL; if not NULL, ownership of the bitmap 
                                    // is not transferred to the user
    OUT PBOOL           pfPrompt,
  	IN PWSTR    	    pwszCbText,
    IN OUT PDWORD       pdwTextLen,
    IN PWSTR            pwszRealm,
    IN DWORD            dwMaxRealmLen
    );

// -- if the credentials are NULL/NULL, the means the default creds will be used
// -- if default creds can not be retrieved, this method will return FALSE
BOOL 
PP_SetCredentials(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN PCWSTR              pwszRealm,
    IN PCWSTR              pwszTarget,  // optional if user/pass are known (not null)
    IN PCWSTR              pwszSignIn,  // can be NULL
    IN PCWSTR              pwszPassword // can be NULL
    );

BOOL
PP_GetLogonHost(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszHostName,    // user supplied buffer ...
	IN OUT PDWORD       pdwHostNameLen  // ... and length (will be updated to actual length 
    );

BOOL 
PP_GetAuthorizationInfo(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszTicket,       // e.g. "from-PP = ..."
	IN OUT PDWORD       pdwTicketLen,
	OUT PBOOL           pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
	IN PWSTR            pwszUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwUrlLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	);

// -- biaow-todo: async
VOID 
PP_AbortLogon(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN DWORD               dwFlags
    );

// -- biaow-todo: 
VOID 
PP_Logout(
    IN PP_CONTEXT hPP,
    IN DWORD      dwFlags
    );

VOID 
PP_FreeLogonContext(
    IN PP_LOGON_CONTEXT    hPPLogon
	);

BOOL
PP_ForceNexusLookup(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszRegUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
	IN PWSTR            pwszDARealm,    // user supplied buffer ...
	IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	);



#ifdef PP_DEMO

BOOL PP_ContactPartner(
	IN PP_CONTEXT   hPP,
    IN PCWSTR       pwszPartnerUrl,
    IN PCWSTR       pwszVerb,
    IN PCWSTR       pwszHeaders,
    IN PWSTR        pwszData,
    IN OUT PDWORD   pdwDataLength
    );

#endif // PP_DEMO

#endif // PASSPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\rescache.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.h

Abstract:

    Contains prototypes, structures, manifests for rescache.c

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// manifests
//

#define RESOLVER_CACHE_DISABLED         -1
#define MINIMUM_RESOLVER_CACHE_ENTRIES  1
#define MAXIMUM_RESOLVER_CACHE_ENTRIES  128 // arbitrary, just in case user decides to wack it up
#define LIVE_FOREVER                    ((DWORD)-1)
#define LIVE_DEFAULT                    ((DWORD)0)

//
// types
//

//
// HOSTENT_CACHE_ENTRY_STATE - the hostent cache entry can be in-use, unused, or
// awaiting deletion
//

typedef enum {
    ENTRY_UNUSED = 1,
    ENTRY_IN_USE,
    ENTRY_DELETE
} HOSTENT_CACHE_ENTRY_STATE;

//
// RESOLVER_CACHE_ENTRY - we maintain a doubly-linked list of these. The list is
// maintained in MRU order - we throw out the one at the far end of the list.
// The structure is variable length, dependent on the amount of data in the
// hostent. We also honour the time-to-live in the DNS answer. When we get a
// response we set the ExpirationTime field. On future cache hits, if the
// current time is >= the ExpirationTime value then we must throw out this entry
// and refresh the cache
//

typedef struct {

    //
    // ListEntry - cache entries comprise a double-linked list
    //

    LIST_ENTRY ListEntry;

    //
    // ExpirationTime - formed by adding the time-to-live value from the DNS
    // response to the result obtained from time(). If ever time() returns a
    // value >= ExpirationTime, this entry is stale and must be refreshed
    //

    DWORD ExpirationTime;

    //
    // HostName - original name resolved to Hostent
    //

    LPSTR HostName;

    //
    // State - unused, in-use, or delete
    //

    HOSTENT_CACHE_ENTRY_STATE State;

    //
    // ReferenceCount - only change State when zero
    //

    LONG ReferenceCount;

    //
    // Hostent - the fixed data portion of a HOSTENT structure. The variable
    // part overflows the end of this structure
    //

    HOSTENT Hostent;

} RESOLVER_CACHE_ENTRY, *LPRESOLVER_CACHE_ENTRY;

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
QueryHostentCache(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL,
    OUT LPHOSTENT * Hostent,
    OUT LPDWORD TimeToLive
    );

VOID
CacheHostent(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR lpszHostName,
    IN LPHOSTENT pHostent,
    IN DWORD TimeToLive,
    IN VOID** pAlloc=NULL,
    IN DWORD dwAllocSize=0
    );

VOID
FlushHostentCache(
    SERIALIZED_LIST* pResolverCache
    );

VOID
ThrowOutHostentCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPHOSTENT lpHostent
    );

VOID
ReleaseHostentCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPHOSTENT lpHostent
    );

#if defined(__cplusplus)
}
#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.h

Abstract:

    Contains name resolution cache structure definition

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
InitNameresCache(
    VOID
);

DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpAddressInfoList
);

DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
);

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
);

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfoList
);

DWORD
DeinitNameresCache(
    VOID
);

#if defined(__cplusplus)
}
#endif

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\resinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    resinfo.h

Abstract:

    Resource owner info header. Used for tracking resources in debug build

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if INET_DEBUG

//
// types
//

//typedef struct {
//    DWORD Tid;
//    DWORD CallersAddress;
//    DWORD CallersCaller;
//    DWORD SourceFileLine;
//    LPSTR SourceFileName;
//} RESOURCE_INFO, *LPRESOURCE_INFO;
typedef struct {
    DWORD Tid;
    LPSTR SourceFileName;
    DWORD SourceFileLine;
} RESOURCE_INFO, *LPRESOURCE_INFO;

//#define GET_RESOURCE_INFO(pResource) \
//    { \
//        (pResource)->Tid = GetCurrentThreadId(); \
//        (pResource)->CallersAddress = 0; \
//        (pResource)->CallersCaller = 0; \
//        (pResource)->SourceFileLine = __LINE__; \
//        (pResource)->SourceFileName = __FILE__; \
//    }
#define GET_RESOURCE_INFO(pResource) \
    { \
        (pResource)->Tid = GetCurrentThreadId(); \
        (pResource)->SourceFileName = __FILE__; \
        (pResource)->SourceFileLine = __LINE__; \
    }

//#define INITIALIZE_RESOURCE_INFO(pResource) \
//    { \
//        (pResource)->Tid = GetCurrentThreadId(); \
//        (pResource)->CallersAddress = 0; \
//        (pResource)->CallersCaller = 0; \
//        (pResource)->SourceFileLine = __LINE__; \
//        (pResource)->SourceFileName = __FILE__; \
//    }
#define INITIALIZE_RESOURCE_INFO(pResource) \
    { \
        (pResource)->Tid = GetCurrentThreadId(); \
        (pResource)->SourceFileName = __FILE__; \
        (pResource)->SourceFileLine = __LINE__; \
    }

#else

#define GET_RESOURCE_INFO(pResource)
#define INITIALIZE_RESOURCE_INFO(pResource)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\secinit.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    secinit.h

Abstract:

    Contains prototypes for indirected security functions

Author:

    Sophia Chung (sophiac) 7-Feb-1996

Revision History:

--*/

#if !defined(_SECINIT_)

#define _SECINIT_

#if defined(__cplusplus)
extern "C" {
#endif

#include <sspi.h>

#if defined(__cplusplus)
}
#endif

extern CCritSec InitializationSecLock;

extern PSecurityFunctionTable   GlobalSecFuncTable;
extern WIN_VERIFY_TRUST_FN      pWinVerifyTrust;
extern WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;

extern HCERTSTORE   g_hMyCertStore;

#define g_EnumerateSecurityPackages \
        (*(GlobalSecFuncTable->EnumerateSecurityPackagesA))
#define g_AcquireCredentialsHandle  \
        (*(GlobalSecFuncTable->AcquireCredentialsHandleA))
#define g_FreeCredentialsHandle     \
        (*(GlobalSecFuncTable->FreeCredentialHandle))
#define g_InitializeSecurityContext \
        (*(GlobalSecFuncTable->InitializeSecurityContextA))
#define g_DeleteSecurityContext     \
        (*(GlobalSecFuncTable->DeleteSecurityContext))
#define g_QueryContextAttributes    \
        (*(GlobalSecFuncTable->QueryContextAttributesA))
#define g_FreeContextBuffer         \
        (*(GlobalSecFuncTable->FreeContextBuffer))
#define g_SealMessage               \
        (*((SEAL_MESSAGE_FN)GlobalSecFuncTable->Reserved3))
#define g_UnsealMessage             \
        (*((UNSEAL_MESSAGE_FN)GlobalSecFuncTable->Reserved4))

LONG WINAPI WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD);

// Don't use WinVerifyTrust directly to verify secure channel connections.
// Use the wininet wrapper WinVerifySecureChannel instead.
#define g_WinVerifyTrust \
        pWinVerifyTrust


typedef PSecurityFunctionTable  (APIENTRY *INITSECURITYINTERFACE) (VOID);

#define CRYPT_INSTALL_DEFAULT_CONTEXT_NAME      "CryptInstallDefaultContext"

typedef BOOL
(WINAPI * CRYPT_INSTALL_DEFAULT_CONTEXT_FN)
(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
);

#define CRYPT_UNINSTALL_DEFAULT_CONTEXT_NAME    "CryptUninstallDefaultContext"
    
typedef BOOL
(WINAPI * CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN)   
(
    HCRYPTDEFAULTCONTEXT hDefaultContext,
    IN DWORD dwFlags,
    IN void *pvReserved
);

typedef PCCERT_CHAIN_CONTEXT
(WINAPI *CERT_FIND_CHAIN_IN_STORE_FN)
(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CHAIN_CONTEXT pPrevChainContext
);

#define CERT_FIND_CHAIN_IN_STORE_NAME            "CertFindChainInStore"

typedef VOID
(WINAPI *CERT_FREE_CERTIFICATE_CHAIN_FN)
(
    IN PCCERT_CHAIN_CONTEXT pChainContext
);

#define CERT_FREE_CERTIFICATE_CHAIN_NAME        "CertFreeCertificateChain"


extern CRYPT_INSTALL_DEFAULT_CONTEXT_FN g_CryptInstallDefaultContext;
extern CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN g_CryptUninstallDefaultContext;
extern CERT_FIND_CHAIN_IN_STORE_FN        g_CertFindChainInStore;
extern CERT_FREE_CERTIFICATE_CHAIN_FN     g_CertFreeCertificateChain;

extern HCRYPTPROV GlobalFortezzaCryptProv;

#define LOCK_SECURITY()   (InitializationSecLock.Lock())
#define UNLOCK_SECURITY() (InitializationSecLock.Unlock())


//
// prototypes
//

BOOL
SecurityInitialize(
    VOID
    );

VOID
SecurityTerminate(
    VOID
    );

DWORD
LoadSecurity(
    VOID
    );

VOID
UnloadSecurity(
    VOID
    );

DWORD
LoadWinTrust(
    VOID
    );


BOOL
IsFortezzaInstalled(
    VOID
    );

#endif // _SECINIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\serialst.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.h

Abstract:

    Header file for serialst.c

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

//
// types
//

typedef struct {

#if INET_DEBUG

    //
    // Signature - must have this to ensure its really a serialized list. Also
    // makes finding start of this structure relatively easy when debugging
    //

    DWORD Signature;

    //
    // ResourceInfo - basically who owns this 'object', combined with yet more
    // debugging information
    //

    RESOURCE_INFO ResourceInfo;

    //
    // LockCount - number of re-entrant locks held
    //

    LONG LockCount;

#endif // INET_DEBUG

    LIST_ENTRY List;

    //
    // ElementCount - number of items on list. Useful for consistency checking
    //

    LONG ElementCount;

    //
    // Lock - we must acquire this to update the list. Put this structure at
    // the end to make life easier when debugging
    //

    CCritSec Lock;

} SERIALIZED_LIST, *LPSERIALIZED_LIST;

//
// SERIALIZED_LIST_ENTRY - we can use this in place of LIST_ENTRY so that in
// the debug version we can check for cycles, etc.
//

typedef struct {

    LIST_ENTRY List;

#if INET_DEBUG

    DWORD Signature;
    DWORD Flags;

#endif

} SERIALIZED_LIST_ENTRY, *LPSERIALIZED_LIST_ENTRY;

//
// prototypes
//

#if INET_DEBUG

BOOL
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

#define IsLockHeld(list) \
    (((list)->ResourceInfo.Tid == GetCurrentThreadId()) \
        ? ((list)->LockCount != 0) \
        : FALSE)

#else // INET_DEBUG

BOOL
InitializeSerializedList(LPSERIALIZED_LIST pList);

#define TerminateSerializedList(list) \
    ((list)->Lock.FreeLock())

#define LockSerializedList(list) \
    ((list)->Lock.Lock())

#define UnlockSerializedList(list) \
    ((list)->Lock.Unlock())

BOOL
InsertAtHeadOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry);

BOOL
InsertAtTailOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry);

BOOL
RemoveFromSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry);

#define IsSerializedListEmpty(list) \
    IsListEmpty(&(list)->List)

#define HeadOfSerializedList(list) \
    (list)->List.Flink

#define TailOfSerializedList(list) \
    (list)->List.Blink

#define IsLockHeld(list) \
    /* NOTHING */



#endif // INET_DEBUG

//
// functions that are always functions
//

LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    );

LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

//
// functions that are always macros
//

#define NextInSerializedList(list, entry)\
        (( ((entry)->List).Flink == &((list)->List))? NULL : ((entry)->List).Flink)

#define ElementsOnSerializedList(list) \
    (list)->ElementCount

#define SlSelf(SerializedList) \
    &(SerializedList)->List.Flink
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\thrdinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.h

Abstract:

    Per-thread structure definitions/macros

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define INTERNET_THREAD_INFO_SIGNATURE  'drhT'  // "Thrd"

//
// forward references
//

class CFsm;

//
// types
//

//
// INTERNET_THREAD_INFO - per-thread information, handily referenced via a TLS
// slot
//

typedef struct _INTERNET_THREAD_INFO {

    //
    // List - doubly linked list that we delete on DLL_PROCESS_DETACH
    //

    LIST_ENTRY List;

#if INET_DEBUG

    //
    // Signature - lets us know that this structure is probably an
    // INTERNET_THREAD_INFO
    //

    DWORD Signature;

#endif

    //
    // ThreadId - used to identify this thread within a process
    //

    DWORD ThreadId;

    //
    // ErrorNumber - arbitrary error code, supplied in InternetSetLastError
    //

    DWORD ErrorNumber;

    //
    // hErrorText - we store the last error text on a per-thread basis. This
    // handle identifies a moveable buffer
    //

    HLOCAL hErrorText;

    //
    // ErrorTextLength - length of the error text in hErrorText
    //

    DWORD ErrorTextLength;

    //
    // hObject - the current Internet object handle being used in this API. We
    // need this to maintain context e.g. when we want to get timeout values
    //

    HINTERNET hObject;

    //
    // hObjectMapped - this is the address of the real object mapped to hObject
    //

    HINTERNET hObjectMapped;

    //
    // IsAsyncWorkerThread - TRUE if this thread is an async worker thread
    //

    BOOL IsAsyncWorkerThread;

    //
    // InCallback - TRUE if we have made an app callback. Used to detect
    // re-entrancy
    //

    BOOL InCallback;

    //
    // fExitThread - This is the last thread we're waiting for termination of.
    //

    BOOL fExitThread;
    
    //
    // NestedRequests - incremented when we detect that we're processing an API
    // in the async worker thread context. If this API then calls other APIs,
    // then we need to treat (mapped) handles differently in the called APIs
    //

    DWORD NestedRequests;

    //
    // dwMappedErrorCode - the real error code returned by e.g. a winsock API,
    // before it was mapped to a WinInet error
    //

    DWORD dwMappedErrorCode;

    //
    // Fsm - currently executing Finite State Machine
    //

    CFsm * Fsm;

#ifdef ENABLE_DEBUG

    //
    // IsAsyncSchedulerThread - TRUE if this INTERNET_THREAD_INFO belongs to the
    // one-and-only async scheduler thread
    //

    BOOL IsAsyncSchedulerThread;

    //
    // per-thread debug variables
    //

    //
    // Pointer to LIFO (stack) of INTERNET_DEBUG_RECORDs. Used to generate
    // indented call-tracing for diagnostics
    //

    LPINTERNET_DEBUG_RECORD Stack;

    //
    // CallDepth - nesting level for calls
    //

    int CallDepth;

    //
    // IndentIncrement - the current indent level. Number of spaces
    //

    int IndentIncrement;

    //
    // StartTime and StopTime - used for timing calls to e.g. send(), recv()
    //

    DWORD StartTime;
    DWORD StopTime;

    DWORD MajorCategoryFlags;
    DWORD MinorCategoryFlags;

#endif // #ifdef ENABLE_DEBUG

} INTERNET_THREAD_INFO, *LPINTERNET_THREAD_INFO;

//
// macros
//

//
// InternetClearLastError - frees the response text buffer for this thread
//

#define InternetClearLastError() \
    InternetSetLastError(0, NULL, 0, 0)

//
// InternetResetObjectHandle - resets the per-thread current object handle
//

#define InternetResetObjectHandle() \
    InternetSetObjectHandle(NULL)

//
// _InternetIncNestingCount - increments nesting level count
//

#define _InternetIncNestingCount() \
    lpThreadInfo->NestedRequests++;

// ** debug version
//#define _InternetIncNestingCount() \
//    if ( lpThreadInfo->NestedRequests > 0xffff ) { \
//        OutputDebugString("InternetIncNestingCount, inc over threshold, contact arthurbi, x68073 (sechs)\n"); \
//        DebugBreak(); \
//    } \
//    lpThreadInfo->NestedRequests++;

//
// _InternetDecNestingCount - decrements nesting level count
//

#define _InternetDecNestingCount(dwNestingLevel) \
    lpThreadInfo->NestedRequests -= dwNestingLevel;

// ** debug version
//#define _InternetDecNestingCount(dwNestingLevel) \
//    if ( lpThreadInfo->NestedRequests == 0 ) { \
//        OutputDebugString("InternetDecNestingCount, attempting to dec 0, contact arthurbi, x68073 (sieben)\n"); \
//        DebugBreak(); \
//    } \
//    if ( dwNestingLevel != 1 && dwNestingLevel != 0 ) { \
//        OutputDebugString("InternetDecNestingCount, invalid nesting level, contact arthurbi, x68073 (acht)\n"); \
//        DebugBreak(); \
//    } \
//    lpThreadInfo->NestedRequests -= dwNestingLevel;

//
// _InternetSetObjectHandle - set the object handle given the thread info block
//

#define _InternetSetObjectHandle(lpThreadInfo, hInternet, hMapped) \
    DEBUG_PRINT(HTTP,   \
            INFO,       \
            ("Setting new obj handle on thrd=%x, old=%x, new=%x (map: old=%x, new=%x)\n", \
            lpThreadInfo, \
            lpThreadInfo->hObject, \
            hInternet, \
            lpThreadInfo->hObjectMapped, \
            hMapped \
            )); \
    lpThreadInfo->hObject = hInternet; \
    lpThreadInfo->hObjectMapped = hMapped;

//
// _InternetClearLastError - clear the last error info given the thread info
// block
//

#define _InternetClearLastError(lpThreadInfo) \
    _InternetSetLastError(lpThreadInfo, 0, NULL, 0, 0)

//
// _InternetResetObjectHandle - clear the object handle given the thread info
// block
//

#define _InternetResetObjectHandle(lpThreadInfo) \
    _InternetSetObjectHandle(lpThreadInfo, NULL, NULL)

//
// _InternetGetObjectHandle - retrieves the object handle from the per-thread
// info block
//

#define _InternetGetObjectHandle(lpThreadInfo) \
    lpThreadInfo->hObject

//
// _InternetGetMappedObjectHandle - retrieves the mapped object handle from the
// per-thread info block
//

#define _InternetGetMappedObjectHandle(lpThreadInfo) \
    lpThreadInfo->hObjectMapped

//
// InternetDisableAsync - turns off the async worker thread indication in the
// thread info block
//

#define _InternetDisableAsync(lpThreadInfo) \
    _InternetSetAsync(FALSE)

//
// InternetEnableAsync - turns off the async worker thread indication in the
// thread info block
//

#define _InternetEnableAsync(lpThreadInfo, Val) \
    _InternetSetAsync(TRUE)

//
// _InternetGetAsync - returns the async worker thread indication from the
// thread info block
//

#define _InternetGetAsync(lpThreadInfo) \
    lpThreadInfo->IsAsyncWorkerThread

//
// _InternetSetAsync - turns on or off the async worker thread indication in the
// thread info block
//

#define _InternetSetAsync(lpThreadInfo, Val) \
    lpThreadInfo->IsAsyncWorkerThread = Val

#define _InternetGetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback

#define _InternetSetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback = TRUE

#define _InternetResetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback = FALSE

#if INET_DEBUG

#define CHECK_INTERNET_THREAD_INFO(lpThreadInfo) \
    INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE)

#else

#define CHECK_INTERNET_THREAD_INFO(lpThreadInfo) \
    /* NOTHING */

#endif

//
// prototypes
//

#define UI_ACTION_CODE_NONE_TAKEN                   0
#define UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE  1
#define UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT       2
#define UI_ACTION_CODE_USER_ACTION_COMPLETED        3


LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    );

VOID
InternetDestroyThreadInfo(
    VOID
    );

VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    );

VOID
InternetTerminateThreadInfo(
    VOID
    );

LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    );

VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    );

DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    );

DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo,
    IN BOOL  bCopyBuffer=FALSE,
    IN BOOL  bConvertToUnicode=TRUE
    );

DWORD
InternetIndicateStatus(
    IN DWORD dwInternetStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN BOOL  bCopyBuffer=FALSE,
    IN BOOL  bConvertToUnicode=FALSE
    );

DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    );

DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    );

#define SLE_APPEND          0x00000001
#define SLE_ZERO_TERMINATE  0x00000002

DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    );

LPSTR
InternetLockErrorText(
    VOID
    );

VOID
InternetUnlockErrorText(
    VOID
    );

VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    );

HINTERNET
InternetGetObjectHandle(
    VOID
    );

HINTERNET
InternetGetMappedObjectHandle(
    VOID
    );

//
// external data
//

extern SERIALIZED_LIST ThreadInfoList;

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\util.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Header for util.cxx

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#if !defined(__UTIL_H__)
#define __UTIL_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define PLATFORM_TYPE_UNKNOWN       ((DWORD)(-1))
#define PLATFORM_TYPE_WIN95         ((DWORD)(0))
#define PLATFORM_TYPE_WINNT         ((DWORD)(1))
#define PLATFORM_TYPE_UNIX          ((DWORD)(2))

#define PLATFORM_SUPPORTS_UNICODE   0x00000001

// max header allowed by wininet in the cache

#define MAX_HEADER_SUPPORTED            2048
#define MAX_USERNAME                    128
#define DEFAULT_MAX_EXTENSION_LENGTH    8

//
// types
//

//
// TRI_STATE - for places where we need to differentiate between TRUE/FALSE and
// uninitialized
//

typedef enum {
    TRI_STATE_UNKNOWN = -1,
    TRI_STATE_FALSE = 0,
    TRI_STATE_TRUE = 1
} TRI_STATE;

//
// DLL_ENTRY_POINT - maps a name to an entry point in a DLL
//

typedef struct {
    LPSTR lpszProcedureName;
    FARPROC * lplpfnProcedure;
} DLL_ENTRY_POINT, * LPDLL_ENTRY_POINT;

//
// DLL_INFO - used to dynamically load/unload libraries
//

typedef struct {
    LPSTR lpszDllName;
    HINSTANCE hModule;
    LONG LoadCount;
    DWORD dwNumberOfEntryPoints;
    LPDLL_ENTRY_POINT lpEntryPoints;
} DLL_INFO, * LPDLL_INFO;

//
// macros
//

#define IsPlatformWin95() \
    (BOOL)((GlobalPlatformType == PLATFORM_TYPE_WIN95) ? TRUE : FALSE)

#define IsPlatformWinNT() \
    (BOOL)((GlobalPlatformType == PLATFORM_TYPE_WINNT) ? TRUE : FALSE)

//#define IsUnicodeSupported() \
//    (BOOL)((PlatformSupport() & PLATFORM_SUPPORTS_UNICODE) ? TRUE : FALSE)

#define DLL_ENTRY_POINT_ELEMENT(name) \
    # name, (FARPROC *)&_I_ ## name

#define DLL_INFO_INIT(name, entryPoints) { \
    name, \
    NULL, \
    0, \
    ARRAY_ELEMENTS(entryPoints), \
    (LPDLL_ENTRY_POINT)&entryPoints \
}


#define CompareFileTime(ft1, ft2)   ( ((*(LONGLONG *)&ft1) > (*(LONGLONG *)&ft2)) ? 1 : \
                                        ( ((*(LONGLONG *)&ft1) == (*(LONGLONG *)&ft2)) ? 0 : -1 ) )


#define WRAP_REVERT_USER(fn, args, retVal) \
{ \
    HANDLE hThreadToken = NULL; \
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ), \
            FALSE, \
            &hThreadToken)) \
    { \
        INET_ASSERT(hThreadToken != 0); \
        RevertToSelf(); \
    } \
    retVal = fn args; \
    if (hThreadToken) \
    { \
        SetThreadToken(NULL, hThreadToken); \
        CloseHandle(hThreadToken); \
    } \
}

#define SAFE_WRAP_REVERT_USER(fn, args, retVal) \
{ \
    HANDLE hThreadToken = NULL; \
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ), \
            FALSE, \
            &hThreadToken)) \
    { \
        INET_ASSERT(hThreadToken != 0); \
        RevertToSelf(); \
    } \
    __try \
    { \
        retVal = fn args; \
    } \
    __except(EXCEPTION_EXECUTE_HANDLER) \
    { \
    } \
    ENDEXCEPT \
    if (hThreadToken) \
    { \
        SetThreadToken(NULL, hThreadToken); \
        CloseHandle(hThreadToken); \
    } \
}

#define WRAP_REVERT_USER_VOID(fn, args) \
{ \
    HANDLE hThreadToken = NULL; \
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ), \
            FALSE, \
            &hThreadToken)) \
    { \
        INET_ASSERT(hThreadToken != 0); \
        RevertToSelf(); \
    } \
    fn args; \
    if (hThreadToken) \
    { \
        SetThreadToken(NULL, hThreadToken); \
        CloseHandle(hThreadToken); \
    } \
}

#define SAFE_WRAP_REVERT_USER_VOID(fn, args) \
{ \
    HANDLE hThreadToken = NULL; \
    if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ), \
            FALSE, \
            &hThreadToken)) \
    { \
        INET_ASSERT(hThreadToken != 0); \
        RevertToSelf(); \
    } \
    __try \
    { \
        fn args; \
    } \
    __except(EXCEPTION_EXECUTE_HANDLER) \
    { \
    } \
    ENDEXCEPT \
    if (hThreadToken) \
    { \
        SetThreadToken(NULL, hThreadToken); \
        CloseHandle(hThreadToken); \
    } \
}

//
// prototypes
//

LPSTR
NewString(
    IN LPCSTR String,
    IN DWORD dwLen = 0
    );

LPWSTR
NewStringW(
    IN LPCWSTR String,
    IN DWORD dwLen = 0
    );


LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    );

HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    );

LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    );

LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    );

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    );

DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os = NULL
    );

DWORD
PlatformSupport(
    VOID
    );

DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    );

DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    );

DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    );

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    );

DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    );

//
// flags for LoadDllEntryPoints()
//

#define LDEP_PARTIAL_LOAD_OK    0x00000001  // ok if not all entry points can be loaded

DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    );

DWORD
MapInternetError(
    IN DWORD ErrorCode,
    IN LPDWORD lpdwStatus = NULL
    );

DWORD
CalculateHashValue(
    IN LPSTR lpszString
    );

VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    );

LPTSTR
FTtoString(
    IN FILETIME *pftTime
    );

BOOL
PrintFileTimeInInternetFormat(
    FILETIME *lpft,
    LPSTR lpszBuff,
    DWORD   dwSize
);

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    );

BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    );

//DWORD
//UnicodeToUtf8(
//    IN LPCWSTR pwszIn,
//    IN DWORD dwInLen,
//    OUT LPBYTE pszOut,
//    IN OUT LPDWORD pdwOutLen
//    );

DWORD
CountUnicodeToUtf8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInLen,
    IN BOOL bEncode
    );

DWORD
ConvertUnicodeToUtf8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInLen,
    OUT LPBYTE pszOut,
    IN DWORD dwOutLen,
    IN BOOL bEncode
    );

BOOL
StringContainsHighAnsi(
    IN LPSTR pszIn,
    IN DWORD dwInLen
    );

DWORD 
GetTickCountWrap();

#ifdef DONT_USE_IERT
char *
StrTokEx(
    IN OUT char ** pstring, 
    IN const char * control);

double 
StrToDbl(
    IN const char *str, 
    IN OUT char **strStop);
#endif //DONT_USE_IERT
#if defined(__cplusplus)
}
#endif


DWORD
WideCharToAscii(PCWSTR pszW, char ** ppszA);

DWORD
AsciiToWideChar_UsingGlobalAlloc(const char * pszA, LPWSTR * ppszW);

#endif // defined(__UTIL_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\private.h ===
// Stuff removed from public header file...

#define INTERNET_DEFAULT_SOCKS_PORT     1080        // default for SOCKS firewall servers.

// maximum field lengths (arbitrary)
// NOTE: if these are put back in the public header, rename them to WINHTTP_.
#define INTERNET_MAX_HOST_NAME_LENGTH   256
#define INTERNET_MAX_USER_NAME_LENGTH   128
#define INTERNET_MAX_PASSWORD_LENGTH    128
#define INTERNET_MAX_REALM_LENGTH       128
#define INTERNET_MAX_PORT_NUMBER_LENGTH 5           // INTERNET_PORT is unsigned short
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length

// This is a bogus limit we should get rid of.
#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_URL_LENGTH         (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

// INTERNET_DIAGNOSTIC_SOCKET_INFO - info about the socket in use
// (diagnostic purposes only, hence internal)

typedef struct {
    DWORD_PTR Socket;
    DWORD     SourcePort;
    DWORD     DestPort;
    DWORD     Flags;
} INTERNET_DIAGNOSTIC_SOCKET_INFO, * LPINTERNET_DIAGNOSTIC_SOCKET_INFO;

//
// INTERNET_DIAGNOSTIC_SOCKET_INFO.Flags definitions
//

#define IDSI_FLAG_KEEP_ALIVE    0x00000001  // set if from keep-alive pool
#define IDSI_FLAG_SECURE        0x00000002  // set if secure connection
#define IDSI_FLAG_PROXY         0x00000004  // set if using proxy
#define IDSI_FLAG_TUNNEL        0x00000008  // set if tunnelling through proxy

#ifdef __WINCRYPT_H__
#ifdef ALGIDDEF
//
// INTERNET_SECURITY_INFO - contains information about certificate
// and encryption settings for a connection.
//

#define INTERNET_SECURITY_INFO_DEFINED

typedef WINHTTP_CERTIFICATE_INFO  INTERNET_CERTIFICATE_INFO;
typedef WINHTTP_CERTIFICATE_INFO* LPINTERNET_CERTIFICATE_INFO;


typedef struct {

    //
    // dwSize - Size of INTERNET_SECURITY_INFO structure.
    //

    DWORD dwSize;


    //
    // pCertificate - Cert context pointing to leaf of certificate chain.
    //

    PCCERT_CONTEXT pCertificate;

    //
    // Start SecPkgContext_ConnectionInfo
    // The following members must match those
    // of the SecPkgContext_ConnectionInfo
    // sspi structure (schnlsp.h)
    //


    //
    // dwProtocol - Protocol that this connection was made with
    //  (PCT, SSL2, SSL3, etc)
    //

    DWORD dwProtocol;

    //
    // aiCipher - Cipher that this connection as made with
    //

    ALG_ID aiCipher;

    //
    // dwCipherStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwCipherStrength;

    //
    // aiHash - Hash that this connection as made with
    //

    ALG_ID aiHash;

    //
    // dwHashStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwHashStrength;

    //
    // aiExch - Key Exchange type that this connection as made with
    //

    ALG_ID aiExch;

    //
    // dwExchStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwExchStrength;


} INTERNET_SECURITY_INFO, * LPINTERNET_SECURITY_INFO;


typedef struct {
    //
    // dwSize - size of INTERNET_SECURITY_CONNECTION_INFO
    //
    DWORD dwSize;

    // fSecure - Is this a secure connection.
    BOOL fSecure;

    //
    // dwProtocol - Protocol that this connection was made with
    //  (PCT, SSL2, SSL3, etc)
    //

    DWORD dwProtocol;

    //
    // aiCipher - Cipher that this connection as made with
    //

    ALG_ID aiCipher;

    //
    // dwCipherStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwCipherStrength;

    //
    // aiHash - Hash that this connection as made with
    //

    ALG_ID aiHash;

    //
    // dwHashStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwHashStrength;

    //
    // aiExch - Key Exchange type that this connection as made with
    //

    ALG_ID aiExch;

    //
    // dwExchStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwExchStrength;

} INTERNET_SECURITY_CONNECTION_INFO , * LPINTERNET_SECURITY_CONNECTION_INFO;
#endif // ALGIDDEF
#endif // __WINCRYPT_H__

BOOLAPI
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwReserved
    );

#define INTERNET_SERVICE_HTTP   3

// flags for InternetReadFileEx()
#define IRF_NO_WAIT     0x00000008

BOOLAPI
InternetGetLastResponseInfo(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoW
#endif // !UNICODE

typedef struct _INTERNET_COOKIE {
    DWORD cbSize;
    LPSTR pszName;
    LPSTR pszData;
    LPSTR pszDomain;
    LPSTR pszPath;
    FILETIME *pftExpires;
    DWORD dwFlags;
    LPSTR pszUrl;
} INTERNET_COOKIE, *PINTERNET_COOKIE;

#define INTERNET_COOKIE_IS_SECURE   0x01
#define INTERNET_COOKIE_IS_SESSION  0x02

//
// internal error codes that are used to communicate specific information inside
// of Wininet but which are meaningless at the interface
//

#define INTERNET_INTERNAL_ERROR_BASE            (WINHTTP_ERROR_BASE + 900)



//
// INTERNET_PER_CONN_OPTION_LIST - set per-connection options such as proxy
// and autoconfig info
//
// Set and queried using WinHttp[Set|Query]Option with
// INTERNET_OPTION_PER_CONNECTION_OPTION
//

typedef struct
{
    DWORD   dwOption;            // option to be queried or set
    union
    {
        DWORD    dwValue;        // dword value for the option
        LPWSTR   pszValue;       // pointer to string value for the option
        FILETIME ftValue;        // file-time value for the option
    } Value;
} INTERNET_PER_CONN_OPTIONW, * LPINTERNET_PER_CONN_OPTIONW;

#ifdef UNICODE
typedef INTERNET_PER_CONN_OPTIONW INTERNET_PER_CONN_OPTION;
typedef LPINTERNET_PER_CONN_OPTIONW LPINTERNET_PER_CONN_OPTION;
#endif // UNICODE

typedef struct
{
    DWORD   dwSize;             // size of the INTERNET_PER_CONN_OPTION_LIST struct
    LPWSTR  pszConnection;      // connection name to set/query options
    DWORD   dwOptionCount;      // number of options to set/query
    DWORD   dwOptionError;      // on error, which option failed
    LPINTERNET_PER_CONN_OPTIONW  pOptions;
                                // array of options to set/query
} INTERNET_PER_CONN_OPTION_LISTW, * LPINTERNET_PER_CONN_OPTION_LISTW;

#ifdef UNICODE
typedef INTERNET_PER_CONN_OPTION_LISTW INTERNET_PER_CONN_OPTION_LIST;
typedef LPINTERNET_PER_CONN_OPTION_LISTW LPINTERNET_PER_CONN_OPTION_LIST;
#endif // UNICODE

//
// Options used in INTERNET_PER_CONN_OPTON struct
//
#define INTERNET_PER_CONN_FLAGS                         1
#define INTERNET_PER_CONN_PROXY_SERVER                  2
#define INTERNET_PER_CONN_PROXY_BYPASS                  3
#define INTERNET_PER_CONN_AUTOCONFIG_URL                4
#define INTERNET_PER_CONN_AUTODISCOVERY_FLAGS           5
#define INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL      6
#define INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS  7
#define INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME   8
#define INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL    9


//
// PER_CONN_FLAGS
//
#define PROXY_TYPE_DIRECT                               0x00000001   // direct to net
#define PROXY_TYPE_PROXY                                0x00000002   // via named proxy
#define PROXY_TYPE_AUTO_PROXY_URL                       0x00000004   // autoproxy URL
#define PROXY_TYPE_AUTO_DETECT                          0x00000008   // use autoproxy detection


#define INTERNET_OPEN_TYPE_DIRECT                       WINHTTP_ACCESS_TYPE_NO_PROXY
#define INTERNET_OPEN_TYPE_PROXY                        WINHTTP_ACCESS_TYPE_NAMED_PROXY
#define INTERNET_OPEN_TYPE_PRECONFIG                    WINHTTP_ACCESS_TYPE_DEFAULT_PROXY
#define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY  WINHTTP_ACCESS_TYPE_DEFAULT_PROXY

typedef HTTP_VERSION_INFO  INTERNET_VERSION_INFO;
typedef HTTP_VERSION_INFO* LPINTERNET_VERSION_INFO;

#define ERROR_HTTP_HEADER_NOT_FOUND             ERROR_WINHTTP_HEADER_NOT_FOUND             
#define ERROR_HTTP_INVALID_SERVER_RESPONSE      ERROR_WINHTTP_INVALID_SERVER_RESPONSE      
#define ERROR_HTTP_INVALID_QUERY_REQUEST        ERROR_WINHTTP_INVALID_QUERY_REQUEST        
#define ERROR_HTTP_HEADER_ALREADY_EXISTS        ERROR_WINHTTP_HEADER_ALREADY_EXISTS        
#define ERROR_HTTP_REDIRECT_FAILED              ERROR_WINHTTP_REDIRECT_FAILED              
#define ERROR_HTTP_NOT_REDIRECTED               ERROR_WINHTTP_NOT_REDIRECTED               

#define INTERNET_INVALID_PORT_NUMBER    INTERNET_DEFAULT_PORT // use the protocol-specific default

#define HTTP_ADDREQ_INDEX_MASK        WINHTTP_ADDREQ_INDEX_MASK
#define HTTP_ADDREQ_FLAGS_MASK        WINHTTP_ADDREQ_FLAGS_MASK
#define HTTP_ADDREQ_FLAG_ADD_IF_NEW   WINHTTP_ADDREQ_FLAG_ADD_IF_NEW
#define HTTP_ADDREQ_FLAG_ADD          WINHTTP_ADDREQ_FLAG_ADD
#define HTTP_ADDREQ_FLAG_REPLACE      WINHTTP_ADDREQ_FLAG_REPLACE
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
#define HTTP_ADDREQ_FLAG_COALESCE                  WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA


#define HTTP_QUERY_MIME_VERSION                 WINHTTP_QUERY_MIME_VERSION                
#define HTTP_QUERY_CONTENT_TYPE                 WINHTTP_QUERY_CONTENT_TYPE                
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING   
#define HTTP_QUERY_CONTENT_ID                   WINHTTP_QUERY_CONTENT_ID                  
#define HTTP_QUERY_CONTENT_DESCRIPTION          WINHTTP_QUERY_CONTENT_DESCRIPTION         
#define HTTP_QUERY_CONTENT_LENGTH               WINHTTP_QUERY_CONTENT_LENGTH              
#define HTTP_QUERY_CONTENT_LANGUAGE             WINHTTP_QUERY_CONTENT_LANGUAGE            
#define HTTP_QUERY_ALLOW                        WINHTTP_QUERY_ALLOW                       
#define HTTP_QUERY_PUBLIC                       WINHTTP_QUERY_PUBLIC                      
#define HTTP_QUERY_DATE                         WINHTTP_QUERY_DATE                        
#define HTTP_QUERY_EXPIRES                      WINHTTP_QUERY_EXPIRES                     
#define HTTP_QUERY_LAST_MODIFIED                WINHTTP_QUERY_LAST_MODIFIED               
#define HTTP_QUERY_MESSAGE_ID                   WINHTTP_QUERY_MESSAGE_ID                  
#define HTTP_QUERY_URI                          WINHTTP_QUERY_URI                         
#define HTTP_QUERY_DERIVED_FROM                 WINHTTP_QUERY_DERIVED_FROM                
#define HTTP_QUERY_COST                         WINHTTP_QUERY_COST                        
#define HTTP_QUERY_LINK                         WINHTTP_QUERY_LINK                        
#define HTTP_QUERY_PRAGMA                       WINHTTP_QUERY_PRAGMA                      
#define HTTP_QUERY_VERSION                      WINHTTP_QUERY_VERSION                     
#define HTTP_QUERY_STATUS_CODE                  WINHTTP_QUERY_STATUS_CODE                 
#define HTTP_QUERY_STATUS_TEXT                  WINHTTP_QUERY_STATUS_TEXT                 
#define HTTP_QUERY_RAW_HEADERS                  WINHTTP_QUERY_RAW_HEADERS                 
#define HTTP_QUERY_RAW_HEADERS_CRLF             WINHTTP_QUERY_RAW_HEADERS_CRLF            
#define HTTP_QUERY_CONNECTION                   WINHTTP_QUERY_CONNECTION                  
#define HTTP_QUERY_ACCEPT                       WINHTTP_QUERY_ACCEPT                      
#define HTTP_QUERY_ACCEPT_CHARSET               WINHTTP_QUERY_ACCEPT_CHARSET              
#define HTTP_QUERY_ACCEPT_ENCODING              WINHTTP_QUERY_ACCEPT_ENCODING             
#define HTTP_QUERY_ACCEPT_LANGUAGE              WINHTTP_QUERY_ACCEPT_LANGUAGE             
#define HTTP_QUERY_AUTHORIZATION                WINHTTP_QUERY_AUTHORIZATION               
#define HTTP_QUERY_CONTENT_ENCODING             WINHTTP_QUERY_CONTENT_ENCODING            
#define HTTP_QUERY_FORWARDED                    WINHTTP_QUERY_FORWARDED                   
#define HTTP_QUERY_FROM                         WINHTTP_QUERY_FROM                        
#define HTTP_QUERY_IF_MODIFIED_SINCE            WINHTTP_QUERY_IF_MODIFIED_SINCE           
#define HTTP_QUERY_LOCATION                     WINHTTP_QUERY_LOCATION                    
#define HTTP_QUERY_ORIG_URI                     WINHTTP_QUERY_ORIG_URI                    
#define HTTP_QUERY_REFERER                      WINHTTP_QUERY_REFERER                     
#define HTTP_QUERY_RETRY_AFTER                  WINHTTP_QUERY_RETRY_AFTER                 
#define HTTP_QUERY_SERVER                       WINHTTP_QUERY_SERVER                      
#define HTTP_QUERY_TITLE                        WINHTTP_QUERY_TITLE                       
#define HTTP_QUERY_USER_AGENT                   WINHTTP_QUERY_USER_AGENT                  
#define HTTP_QUERY_WWW_AUTHENTICATE             WINHTTP_QUERY_WWW_AUTHENTICATE            
#define HTTP_QUERY_PROXY_AUTHENTICATE           WINHTTP_QUERY_PROXY_AUTHENTICATE          
#define HTTP_QUERY_ACCEPT_RANGES                WINHTTP_QUERY_ACCEPT_RANGES               
#define HTTP_QUERY_SET_COOKIE                   WINHTTP_QUERY_SET_COOKIE                  
#define HTTP_QUERY_COOKIE                       WINHTTP_QUERY_COOKIE                      
#define HTTP_QUERY_REQUEST_METHOD               WINHTTP_QUERY_REQUEST_METHOD              
#define HTTP_QUERY_REFRESH                      WINHTTP_QUERY_REFRESH                     
#define HTTP_QUERY_CONTENT_DISPOSITION          WINHTTP_QUERY_CONTENT_DISPOSITION         
#define HTTP_QUERY_AGE                          WINHTTP_QUERY_AGE                         
#define HTTP_QUERY_CACHE_CONTROL                WINHTTP_QUERY_CACHE_CONTROL               
#define HTTP_QUERY_CONTENT_BASE                 WINHTTP_QUERY_CONTENT_BASE                
#define HTTP_QUERY_CONTENT_LOCATION             WINHTTP_QUERY_CONTENT_LOCATION            
#define HTTP_QUERY_CONTENT_MD5                  WINHTTP_QUERY_CONTENT_MD5                 
#define HTTP_QUERY_CONTENT_RANGE                WINHTTP_QUERY_CONTENT_RANGE               
#define HTTP_QUERY_ETAG                         WINHTTP_QUERY_ETAG                        
#define HTTP_QUERY_HOST                         WINHTTP_QUERY_HOST                        
#define HTTP_QUERY_IF_MATCH                     WINHTTP_QUERY_IF_MATCH                    
#define HTTP_QUERY_IF_NONE_MATCH                WINHTTP_QUERY_IF_NONE_MATCH               
#define HTTP_QUERY_IF_RANGE                     WINHTTP_QUERY_IF_RANGE                    
#define HTTP_QUERY_IF_UNMODIFIED_SINCE          WINHTTP_QUERY_IF_UNMODIFIED_SINCE         
#define HTTP_QUERY_MAX_FORWARDS                 WINHTTP_QUERY_MAX_FORWARDS                
#define HTTP_QUERY_PROXY_AUTHORIZATION          WINHTTP_QUERY_PROXY_AUTHORIZATION         
#define HTTP_QUERY_RANGE                        WINHTTP_QUERY_RANGE                       
#define HTTP_QUERY_TRANSFER_ENCODING            WINHTTP_QUERY_TRANSFER_ENCODING           
#define HTTP_QUERY_UPGRADE                      WINHTTP_QUERY_UPGRADE                     
#define HTTP_QUERY_VARY                         WINHTTP_QUERY_VARY                        
#define HTTP_QUERY_VIA                          WINHTTP_QUERY_VIA                         
#define HTTP_QUERY_WARNING                      WINHTTP_QUERY_WARNING                     
#define HTTP_QUERY_EXPECT                       WINHTTP_QUERY_EXPECT                      
#define HTTP_QUERY_PROXY_CONNECTION             WINHTTP_QUERY_PROXY_CONNECTION            
#define HTTP_QUERY_UNLESS_MODIFIED_SINCE        WINHTTP_QUERY_UNLESS_MODIFIED_SINCE       
#define HTTP_QUERY_ECHO_REQUEST                 WINHTTP_QUERY_ECHO_REQUEST                
#define HTTP_QUERY_ECHO_REPLY                   WINHTTP_QUERY_ECHO_REPLY                  
#define HTTP_QUERY_ECHO_HEADERS                 WINHTTP_QUERY_ECHO_HEADERS                
#define HTTP_QUERY_ECHO_HEADERS_CRLF            WINHTTP_QUERY_ECHO_HEADERS_CRLF           
#define HTTP_QUERY_PROXY_SUPPORT                WINHTTP_QUERY_PROXY_SUPPORT               
#define HTTP_QUERY_AUTHENTICATION_INFO          WINHTTP_QUERY_AUTHENTICATION_INFO         
#define HTTP_QUERY_MAX                          WINHTTP_QUERY_MAX                         
#define HTTP_QUERY_CUSTOM                       WINHTTP_QUERY_CUSTOM                      
#define HTTP_QUERY_FLAG_REQUEST_HEADERS         WINHTTP_QUERY_FLAG_REQUEST_HEADERS        
#define HTTP_QUERY_FLAG_SYSTEMTIME              WINHTTP_QUERY_FLAG_SYSTEMTIME             
#define HTTP_QUERY_FLAG_NUMBER                  WINHTTP_QUERY_FLAG_NUMBER                 

#define ERROR_WINHTTP_FORCE_RETRY               ERROR_WINHTTP_RESEND_REQUEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\xpltfrm.h ===
#ifndef __XPLTFRM_H__
#define __XPLTFRM_H__

#include <platform.h>

#ifdef unix
#define LONGLONG_ZERO 0LL
#define __int8 char
#define DIR_SEPARATOR_CHAR TEXT('/')
#define DIR_SEPARATOR_STRING TEXT("/")
#define WEBDIR_STRING "Web/"
// Follwing is workaround for MainWin Registry API bug 2053.
#else
#define LONGLONG_ZERO 0i64
#define DIR_SEPARATOR_CHAR TEXT('\\')
#define DIR_SEPARATOR_STRING TEXT("\\")
#define WEBDIR_STRING "Web\\" 
#endif /* unix */

#endif /* __XPLTFRM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\tstr.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tstr.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    16-Jan-1992 Danl
        Cut this info from \net\inc\tstring.h
    30-Jan-1992 JohnRo
        Added STRSTR().
        Use _wcsupr() instead of wcsupr() to keep PC-LINT happy.
        Added STRCMPI() and STRNCMPI().
        Fixed a few definitions which were missing MAKE_STR_FUNCTION etc.
    14-Mar-1992 JohnRo
        Avoid compiler warnings using WCSSIZE(), MEMCPY(), etc.
        Added TCHAR_TAB.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

#ifndef _TSTR_H_INCLUDED
#define _TSTR_H_INCLUDED

#include <ctype.h>              // isdigit(), iswdigit() eventually, etc.
#include <stdlib.h>             // atol(), _ultoa().
#include <string.h>             // memcpy(), strlen(), etc.
// Don't #define memmove to RtlMoveMemory for wchar.h
// because the protoypes don't match.
#pragma push_macro("memmove")
#undef memmove
#include <wchar.h>
#pragma pop_macro("memmove")


LPWSTR
ultow (
    IN DWORD Value,
    OUT LPWSTR Area,
    IN DWORD Radix
    );

LONG
wtol (
    IN LPWSTR Src
    );


#ifdef LM20_COMPATIBLE
#define MAKE_STR_FUNCTION(s)    s##f
#else
#define MAKE_STR_FUNCTION(s)    s
#endif


#if defined(UNICODE)

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(wtol)(Src)

#define ISALNUM(tchar)      iswalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      iswalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iswcntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      iswdigit(tchar)
#define ISGRAPH(tchar)      iswgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      iswlower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      iswprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      iswpunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      iswspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      iswupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     iswxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscat)((dest), (src))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(wcschr)((s1), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscpy)((dest), (src))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(wcscspn)((s), (c))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(wcslen)(s)
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncat)((dest), (src), (n))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncpy)((dest), (src), (n))
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(wcsspn)((s1), (s2))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(wcsrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(wcswcs)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(_wcsupr)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(wcscmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(wcsncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)

#define TOLOWER(tchar)      towlower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      towupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(ultow)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  WCHAR

#else   // not UNICODE

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(atol)(Src)

#define ISALNUM(tchar)      isalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      isalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iscntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      isdigit(tchar)
#define ISGRAPH(tchar)      isgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      islower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      isprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      ispunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      isspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      isupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     isxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcat)((dest), (src))
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncat)((dest), (src), (n))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(strlen)(s)
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(strspn)((s1), (s2))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(strcspn)((s), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcpy)((dest), (src))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncpy)((dest), (src), (n))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(strchr)((s1), (c))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(strrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(strstr)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(strupr)(s)
#define STRREV(s)           (LPTSTR)MAKE_STR_FUNCTION(strrev)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(lstrcmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(lstrcmpi)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(lstrcmpi)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(strncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_strnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_strnicmp)

#define TOLOWER(tchar)      tolower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      toupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(_ultoa)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  TCHAR

#endif // not UNICODE


//
// For the memory routines, the counts are always BYTE counts.
//
#define MEMCPY                  MAKE_STR_FUNCTION(memcpy)
#define MEMMOVE                 MAKE_STR_FUNCTION(memmove)

//
// These are used to determine the number of bytes (including the NUL
// terminator) in a string.  This will generally be used when
// calculating the size of a string for allocation purposes.
//

#define STRSIZE(p)      ((STRLEN(p)+1) * sizeof(TCHAR))
#define WCSSIZE(s)      ((MAKE_STR_FUNCTION(wcslen)(s)+1) * sizeof(WCHAR))


//
// character literals (both types)
//

#define TCHAR_EOS       ((_CHAR_TYPE)'\0')
#define TCHAR_STAR      ((_CHAR_TYPE)'*')
#define TCHAR_BACKSLASH ((_CHAR_TYPE)'\\')
#define TCHAR_FWDSLASH  ((_CHAR_TYPE)'/')
#define TCHAR_COLON     ((_CHAR_TYPE)':')
#define TCHAR_DOT       ((_CHAR_TYPE)'.')
#define TCHAR_SPACE     ((_CHAR_TYPE)' ')
#define TCHAR_TAB       ((_CHAR_TYPE)'\t')


//
// General purpose macro for casting character types to whatever type in vogue
// (as defined in this file)
//

#define MAKE_TCHAR(c)   ((_CHAR_TYPE)(c))

//
// IS_PATH_SEPARATOR
//
// lifted from curdir.c and changed to use TCHAR_ character literals, checks
// if a character is a path separator i.e. is a member of the set [\/]
//

#define IS_PATH_SEPARATOR(ch) ((ch == TCHAR_BACKSLASH) || (ch == TCHAR_FWDSLASH))

//
// The following 2 macros lifted from I_Net canonicalization files
//

#define IS_DRIVE(c)             ISALPHA(c)
#define IS_NON_ZERO_DIGIT(c)    (((c) >= MAKE_TCHAR('1')) && ((c) <= MAKE_TCHAR('9')))

//
// STRING_SPACE_REQD returns a number (of bytes) corresponding to the space
// required in which (n) characters can be accomodated
//

#define STRING_SPACE_REQD(n)    ((n) * sizeof(_CHAR_TYPE))

//
// DOWN_LEVEL_STRLEN returns the number of single-byte characters necessary to
// store a converted _CHAR_TYPE string. This will be WCHAR (or wchar_t) if
// UNICODE is defined or CHAR (or char) otherwise
//

#define DOWN_LEVEL_STRSIZE(n)   ((n) / sizeof(_CHAR_TYPE))

#endif  // _TSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\lib\libentry.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dllentry.cxx

Abstract:

    Entry point for WinInet Internet client DLL

    Contents:
        WinInetDllEntryPoint

Author:

    Richard L Firth (rfirth) 10-Nov-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    10-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include <process.h>
#include <perfdiag.hxx>
#include <shlwapi.h>
#include <advpub.h>

#ifndef WINHTTP_STATIC_LIBRARY
#error libentry.cxx should not be compiled into winhttpx.dll
#endif

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
WINAPI
WinHttpDllMainHook(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );


#if defined(__cplusplus)
}
#endif

//
// global data
//

GLOBAL CCritSec GeneralInitCritSec;

//
// functions
//

BOOL
WINAPI
WinHttpDllMainHook(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )

/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    if (Reason != DLL_PROCESS_ATTACH) {

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

    }

    DWORD error;

    //
    // perform global dll initialization, if any.
    //
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        GlobalDllHandle = DllHandle;
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        if (!GeneralInitCritSec.Init())
            return FALSE;

        if (!g_pAsyncCount)
        {
            g_pAsyncCount = New CAsyncCount();

            if (!g_pAsyncCount)
                return FALSE;
        }

        INITIALIZE_DEBUG_REGKEY();
        INITIALIZE_DEBUG_MEMORY();
        INET_DEBUG_START();

        if (!GlobalDllInitialize() || !InternetCreateThreadInfo(TRUE))
        {
            return FALSE;
        }

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

        DEBUG_LEAVE(TRUE);

        break;

    case DLL_PROCESS_DETACH:

        //
        // signal to all APIs (and any other function that might have an
        // interest) that the DLL is being shutdown
        //

        GlobalDynaUnload = (Reserved == NULL) ? TRUE : FALSE;
        InDllCleanup = TRUE;

        DEBUG_PRINT(DLL,
                    INFO,
                    ("DLL Terminated\n"
                    ));

        DEBUG_LEAVE(TRUE);

        if (GlobalDynaUnload) {
            if (GlobalDataInitialized) {
                GlobalDataTerminate();
            }
            GlobalDllTerminate();
            InternetTerminateThreadInfo();
        }

        PERF_DUMP();

        PERF_END();

        if (g_pAsyncCount)
        {
            delete g_pAsyncCount;
            g_pAsyncCount = 0;
        }
        //TERMINATE_DEBUG_MEMORY(FALSE);
        TERMINATE_DEBUG_MEMORY(TRUE);
        INET_DEBUG_FINISH();
        TERMINATE_DEBUG_REGKEY();

        //InternetDestroyThreadInfo();
        
        GeneralInitCritSec.FreeLock();
        break;

    case DLL_THREAD_DETACH:

        //
        // kill the INTERNET_THREAD_INFO
        //

        DEBUG_LEAVE(TRUE);

        InternetDestroyThreadInfo();
        break;

    case DLL_THREAD_ATTACH:

        //
        // we do nothing for thread attach - if we need an INTERNET_THREAD_INFO
        // then it gets created by the function which realises we need one
        //

        AllowCAP();

        DEBUG_LEAVE(TRUE);

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\lib\makefile.inc ===
!if "$(BUILD_PRODUCT)" == "IE"
MC_INC = -A
!endif

$(O)\inetmsg.rc $(O)\inetmsg.h $(O)\msg00001.bin : inetmsg.mc
    mc $(MC_INC) -v -d -r $(O) -h $(O) inetmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\wininetp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininetp.h

Abstract:

    Includes all headers for precompiled header to build Windows Internet
    client DLL

Author:

    Richard L Firth (rfirth) 26-Oct-1994

Revision History:

    26-Oct-1994 rfirth
        Created

--*/

#ifndef __WININETP_H__
#define __WININETP_H__ 1

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

// #define STRESS_BUG_DEBUG // for stress debugging

#if DBG

#define STRESS_BUG_DEBUG // for stress debugging

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG

//
// common include files
//


//
// CRT includes
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h> // Pull in the 'offsetof' macro.
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <excpt.h>
#include <limits.h>
#include <fcntl.h>
#include <io.h>
#include <time.h>

//
// OS includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>

#if defined(__cplusplus)
}
#endif

//#include <fastcrit.h>

//
// SSL/PCT Security includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#define SECURITY_WIN32
#include <sspi.h>    // standard SSPI interface
#include <issperr.h> // SSPI errors.
#include <spseal.h>  // Private SSPI Seal/UnSeal functions.
#include <schnlsp.h> // shared private schannel/wininet interfaces.
#include <wintrust.h> // various CAPI stuff for cert management
#include <wincrypt.h>
#if defined(__cplusplus)
}
#endif


#define WININET_SERVER_CORE     1

//
// WININET includes
//

#include <iwinsock.h>
#include <winhttp.h>
#include <internal.h>
#include <private.h>
#include <ansi.h>
#include <wininetd.h>
#include <resinfo.h>
#include <syncobj.hxx>
#include <serialst.h>
#include <chunkflt.hxx>
#include <inetdbg.h>
#ifdef WINHTTP_FOR_MSXML
#  include <msxmlmem.h>
#else
#  include <debugmem.h>
#endif
#include <shlwapi.h>
#define NO_SHLWAPI_MLUI
#include <shlwapip.h>
#include <malloc.h>
#include <crtsubst.h>
#include <handle.h>
#include <constant.h>
#include <macros.h>
#include <inetp.h>
#include <util.h>
#include <proxreg.h>
#include <icstring.hxx>
#include <cliauth.hxx>
#include <certcach.hxx>
#include <buffer.hxx>
#include <thrdinfo.h>
#include <defaults.h>
#include <passport.h>
#include <spluginx.hxx>
#include <splugin.hxx>
#include <secinit.h>
#include <inetsspi.h>
#include <tstr.h>
#include <registry.h>
#include <parseurl.h>
#include <globals.h>
#include <autoprox.hxx>
#include <reslock.hxx>
#include <proxysup.hxx>
#include <hinet.hxx>
#include <priolist.hxx>
#include <icasync.hxx>
#include <caddrlst.hxx>
#include <icsocket.hxx>
#include <ssocket.hxx>
#include <servinfo.hxx>
#include <connect.hxx>
#include <http.hxx>
#include <cookie.h>
#include <rescache.h>
#include <parsers.h>
#include <fsm.hxx>
#include <mpacket.hxx>
#include <inetchar.h>
#include <bgtask.hxx>

#if defined(__cplusplus)
extern "C" {
#endif


//
//  Various protocol package initializers.
//

BOOL
WINAPI
WinInetDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );

#if defined(__cplusplus)
}
#endif

//
// Need version 0x400 for ras defines for this to work on win95 gold.
//
#if defined(__cplusplus)
extern "C" {
#endif

#undef WINVER
#define WINVER 0x400

#include <ras.h>
#include <raserror.h>

#ifdef ICECAP
extern "C" void _stdcall StartCAP(void);
extern "C" void _stdcall StopCAP(void);
extern "C" void _stdcall SuspendCAP(void);
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall MarkCAP(long lMark);  // write mark to MEA
extern "C" void _stdcall AllowCAP(void);  // Allow profiling when 'profile=almostnever'
#else
#define StartCAP()
#define StopCAP()
#define SuspendCAP()
#define ResumeCAP()
#define MarkCAP(n)
#define AllowCAP()
#endif

#if defined(__cplusplus)
}
#endif


/* X-Platform stuff */
#include <xpltfrm.h>

#endif /* __WININETP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\inc\wininetd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wininetd.h

Abstract:

    Contains the interface for the WININET diagnostic capabilities.

    This interface only exists in the debug version of WININET.DLL.
    Calling the debug functions in the retail version of the DLL will
    yield ERROR_INVALID_PARAMETER

Author:

    Richard L Firth (rfirth) 14-Jun-1995

Revision History:

    14-Jun-1995 rfirth
        Created

--*/

//
// manifests
//

//
// if the environment or registry variable "WininetLog" is set to !0 then the
// following values will be used for control, category and error level resp.
// These options generate "WININET.LOG" in the current directory
//

#define INTERNET_DEBUG_CONTROL_DEFAULT      (DBG_THREAD_INFO       \
                                            | DBG_CALL_DEPTH        \
                                            | DBG_ENTRY_TIME        \
                                            | DBG_PARAMETER_LIST    \
                                            | DBG_TO_FILE           \
                                            | DBG_INDENT_DUMP       \
                                            | DBG_SEPARATE_APIS     \
                                            | DBG_AT_ERROR_LEVEL    \
                                            | DBG_NO_ASSERT_BREAK   \
                                            | DBG_DUMP_LENGTH       \
                                            | DBG_NO_LINE_NUMBER    \
                                            | DBG_ASYNC_ID          \
                                            )
#define INTERNET_DEBUG_CATEGORY_DEFAULT     DBG_ANY
#define INTERNET_DEBUG_ERROR_LEVEL_DEFAULT  DBG_INFO

//
// options. These are the option values to use with InternetQueryOption()/
// InternetSetOption() to get/set the information described herein
//

#define WINHTTP_OPTION_GET_DEBUG_INFO      1001
#define WINHTTP_OPTION_SET_DEBUG_INFO      1002
#define WINHTTP_OPTION_GET_HANDLE_COUNT    1003
#define WINHTTP_OPTION_GET_TRIGGERS        1004
#define WINHTTP_OPTION_SET_TRIGGERS        1005
#define WINHTTP_OPTION_RESET_TRIGGERS      1006

#define INTERNET_FIRST_DEBUG_OPTION         WINHTTP_OPTION_GET_DEBUG_INFO
#define INTERNET_LAST_DEBUG_OPTION          WINHTTP_OPTION_RESET_TRIGGERS

//
// debug levels
//

#define DBG_INFO            0
#define DBG_WARNING         1
#define DBG_ERROR           2
#define DBG_FATAL           3
#define DBG_ALWAYS          99

//
// debug control flags - these flags control where the debug output goes (file,
// debugger, console) and how it is formatted
//

#define DBG_THREAD_INFO     0x00000001  // dump the thread id
#define DBG_CALL_DEPTH      0x00000002  // dump the call level
#define DBG_ENTRY_TIME      0x00000004  // dump the local time when the function is called
#define DBG_PARAMETER_LIST  0x00000008  // dump the parameter list
#define DBG_TO_DEBUGGER     0x00000010  // output via OutputDebugString()
#define DBG_TO_CONSOLE      0x00000020  // output via printf()
#define DBG_TO_FILE         0x00000040  // output via fprintf()
#define DBG_FLUSH_OUTPUT    0x00000080  // fflush() after every fprintf()
#define DBG_INDENT_DUMP     0x00000100  // indent dumped data to current level
#define DBG_SEPARATE_APIS   0x00000200  // empty line after leaving each API
#define DBG_AT_ERROR_LEVEL  0x00000400  // always output diagnostics >= InternetDebugErrorLevel
#define DBG_NO_ASSERT_BREAK 0x00000800  // don't call DebugBreak() in InternetAssert()
#define DBG_DUMP_LENGTH     0x00001000  // dump length information when dumping data
#define DBG_NO_LINE_NUMBER  0x00002000  // don't dump line number info
#define DBG_APPEND_FILE     0x00004000  // append to the log file (default is truncate)
#define DBG_LEVEL_INDICATOR 0x00008000  // dump error level indicator (E for Error, etc.)
#define DBG_DUMP_API_DATA   0x00010000  // dump data at API level (InternetReadFile(), etc.)
#define DBG_DELTA_TIME      0x00020000  // dump times as millisecond delta if DBG_ENTRY_TIME
#define DBG_CUMULATIVE_TIME 0x00040000  // dump delta time from start of trace if DBG_ENTRY_TIME
#define DBG_FIBER_INFO      0x00080000  // dump the fiber address if DBG_THREAD_INFO
#define DBG_THREAD_INFO_ADR 0x00100000  // dump INTERNET_THREAD_INFO address if DBG_THREAD_INFO
#define DBG_ARB_ADDR        0x00200000  // dump ARB address if DBG_THREAD_INFO
#define DBG_ASYNC_ID        0x00400000  // dump async ID
#define DBG_REQUEST_HANDLE  0x00800000  // dump request handle
#define DBG_TRIGGER_ON      0x10000000  // function is an enabling trigger
#define DBG_TRIGGER_OFF     0x20000000  // function is a disabling trigger
#define DBG_NO_DATA_DUMP    0x40000000  // turn off all data dumping
#define DBG_NO_DEBUG        0x80000000  // turn off all debugging

//
// debug category flags - these control what category of information is output
//

#define DBG_NOTHING         0x00000000  // internal
#define DBG_INET            0x00000001  // e.g. InternetOpenUrl()
#define DBG_FTP             0x00000002  // e.g. FtpFindFirstFile()
#define DBG_GOPHER          0x00000004  // e.g. GopherFindFirstFile()
#define DBG_HTTP            0x00000008  // e.g. HttpOpenRequest()
#define DBG_API             0x00000010  // APIs
#define DBG_UTIL            0x00000020  // various utility functions
#define DBG_UNICODE         0x00000040  // wide character functions
#define DBG_WORKER          0x00000080  // worker functions
#define DBG_HANDLE          0x00000100  // handle creation/deletion functions
#define DBG_SESSION         0x00000200  // session/creation functions
#define DBG_SOCKETS         0x00000400  // sockets functions
#define DBG_VIEW            0x00000800  // gopher view functions
#define DBG_BUFFER          0x00001000  // gopher buffer functions
#define DBG_PARSE           0x00002000  // FTP/gopher parse functions
#define DBG_MEMALLOC        0x00004000  // Debug memory allocation/free functions
#define DBG_SERIALST        0x00008000  // Serialized List functions
#define DBG_THRDINFO        0x00010000  // INTERNET_THREAD_INFO functions
#define DBG_PROTOCOL        0x00020000  // protocol functions
#define DBG_DLL             0x00040000  // DLL functions
#define DBG_REFCOUNT        0x00080000  // logs all reference count functions
#define DBG_REGISTRY        0x00100000  // logs all registry functions
#define DBG_TRACE_SOCKETS   0x00200000  // monitors socket usage
#define DBG_ASYNC           0x00400000  // logs async functions
#define DBG_CACHE           0x00800000  // logs cache specific stuff
#define DBG_INVALID_HANDLES 0x01000000  // logs invalid handles (e.g. in InternetCloseHandle())
#define DBG_OBJECTS         0x02000000  // dump object info
#define DBG_PROXY           0x04000000  // dump proxy info
#define DBG_RESLOCK         0x08000000  // dump resource lock info
#define DBG_DIALUP          0x10000000  // dump dial-up info
#define DBG_GLOBAL          0x20000000  // dump global-scope functions
#define DBG_ANY             0xFFFFFFFF  // internal

//
// types
//

//
// INTERNET_DEBUG_INFO - structure that receives the current debugging variables
// via InternetQueryOption(), or which contains the new debugging variables to
// be set via InternetSetOption()
//

typedef struct {

    //
    // ErrorLevel - DBG_INFO, etc.
    //

    int ErrorLevel;

    //
    // ControlFlags - DBG_THREAD_INFO, etc.
    //

    DWORD ControlFlags;

    //
    // CategoryFlags - DBG_INET, etc.
    //

    DWORD CategoryFlags;

    //
    // BreakFlags - DBG_API, etc. where breakpoints will be taken
    //

    DWORD BreakFlags;

    //
    // IndentIncrement - increment to use for each depth increase
    //

    int IndentIncrement;

    //
    // Filename - name of output log being used/to use
    //

    char Filename[1];

} INTERNET_DEBUG_INFO, *LPINTERNET_DEBUG_INFO;

//
// INTERNET_TRIGGER_INFO - a diagnostic trigger. Triggers are enabled when the
// function named in this structure is executed. Triggers can enable or disable
// diagnostics
//

typedef struct {

    //
    // FunctionName - name of the function to act as trigger. ControlFlags has
    // DBG_TRIGGER_ON or DBG_TRIGGER_OFF set
    //

    LPCSTR FunctionName;

    //
    // ControlFlags - control flags to use when the trigger is enabled. If the
    // trigger disables diagnostics then the previous control flags will be
    // restored
    //

    DWORD ControlFlags;

    //
    // CategoryFlags - category flags to use when the trigger is enabled. See
    // ControlFlags
    //

    DWORD CategoryFlags;

} INTERNET_TRIGGER_INFO, *LPINTERNET_TRIGGER_INFO;

//
// INTERNET_DEBUG_TRIGGERS - 1 or more of these will be returned from/given to
// InternetQueryOption()/InternetSetOption()
//

typedef struct {

    //
    // Count - number of INTERNET_TRIGGER_INFO structures contained herein
    //

    DWORD Count;

    //
    // Triggers - an array of 0 or more INTERNET_TRIGGER_INFO structures
    //

    INTERNET_TRIGGER_INFO Triggers[1];

} INTERNET_DEBUG_TRIGGERS, *LPINTERNET_DEBUG_TRIGGERS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\passport\inetsess.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    InetSess.cpp

Abstract:

    Implements the Passport Session that uses WinInet as the underlying transport.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"

#ifdef HINTERNET
#undef HINTERNET
#endif

#ifdef INTERNET_PORT
#undef INTERNET_PORT
#endif

#include <WinInet.h>
#include "session.h"

// #include "inetsess.tmh"

//
// func pointer decl for WinInet
//

typedef HINTERNET
(WINAPI * PFN_INTERNET_OPEN)(
    IN LPCWSTR lpwszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpwszProxy OPTIONAL,
    IN LPCWSTR lpwszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_INTERNET_CONNECT)(
    IN HINTERNET hInternet,
    IN LPCWSTR lpwszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpwszUserName OPTIONAL,
    IN LPCWSTR lpwszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

typedef HINTERNET
(WINAPI * PFN_OPEN_REQUEST)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpwszVerb,
    IN LPCWSTR lpwszObjectName,
    IN LPCWSTR lpwszVersion,
    IN LPCWSTR lpwszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

typedef BOOL
(WINAPI * PFN_SEND_REQUEST)(
    IN HINTERNET hRequest,
    IN LPCWSTR lpwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );

typedef BOOL 
(WINAPI * PFN_QUERY_INFO)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
);

typedef BOOL 
(WINAPI* PFN_CLOSE_HANDLE)(
    IN HINTERNET hInternet
);

typedef BOOL 
(WINAPI* PFN_SET_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

typedef BOOL 
(WINAPI* PFN_QUERY_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
);

typedef HINTERNET 
(WINAPI* PFN_OPEN_URL)(
    IN HINTERNET hInternet, 
    IN LPCWSTR lpwszUrl,
    IN LPCWSTR lpwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
);

typedef BOOL 
(WINAPI* PFN_CRACK_URL)(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents
);

typedef BOOL 
(WINAPI* PFN_READ_FILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

typedef INTERNET_STATUS_CALLBACK 
(WINAPI* PFN_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
);

typedef BOOL 
(WINAPI* PFN_ADD_HEADERS)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);

class WININET_SESSION : public SESSION
{
protected:
    WININET_SESSION(void);
    virtual ~WININET_SESSION(void);

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET);
    virtual void Close(void);

protected:    
    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT
        );

    virtual HINTERNET OpenRequest(
            HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0);

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0);

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL);

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet);

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength);    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength);

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags);

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead);

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents);

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        );

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        );


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR pwszData,
                                PDWORD pdwDataLength
                                );
#endif // PP_DEMO

    BOOL InitHttpApi(PFN_INTERNET_OPEN*);

protected:
    HINTERNET m_hInternet;

    PFN_INTERNET_CONNECT    m_pfnConnect;
    PFN_OPEN_REQUEST        m_pfnOpenRequest;
    PFN_SEND_REQUEST        m_pfnSendRequest;
    PFN_QUERY_INFO          m_pfnQueryInfo;
    PFN_CLOSE_HANDLE        m_pfnCloseHandle;
    PFN_SET_OPTION          m_pfnSetOption;
    PFN_OPEN_URL            m_pfnOpenUrl;
    PFN_QUERY_OPTION        m_pfnQueryOption;
    PFN_CRACK_URL           m_pfnCrack;
    PFN_READ_FILE           m_pfnReadFile;
    PFN_STATUS_CALLBACK     m_pfnStatusCallback;
    PFN_ADD_HEADERS         m_pfnAddHeaders;

friend class SESSION;
};

//
// Implementation for SESSION
//

SESSION* CreateWinHttpSession(void);

// -----------------------------------------------------------------------------
BOOL SESSION::CreateObject(PCWSTR pwszHttpStack, HINTERNET hSession, SESSION*& pSess)
{
    PP_ASSERT(pwszHttpStack != NULL);
    
    pSess = NULL;

    if (!::_wcsicmp(pwszHttpStack, L"WinInet.dll") || 
        !::_wcsicmp(pwszHttpStack, L"WinInet"))
    {
        pSess = new WININET_SESSION();
    }
    else
    {
        pSess = ::CreateWinHttpSession();
    }

    if (pSess)
    {
        return pSess->Open(pwszHttpStack, hSession);
    }
    else
    {
        DoTraceMessage(PP_LOG_ERROR, "CreateObject() failed; not enough memory");
        return FALSE;
    }
}

// -----------------------------------------------------------------------------
SESSION::SESSION(void)
{
    m_hHttpStack = 0;
    m_hCredUI = 0;
    m_RefCount = 0;

    m_pfnReadDomainCred = NULL;
    m_pfnCredFree = NULL;

    m_hKeyLM = NULL;
    m_hKeyCU = NULL;
    m_hKeyDAMap = NULL;

    m_fLogout = FALSE;

    m_LastNexusDownloadTime = 0xFFFFFFFF;
}

// -----------------------------------------------------------------------------
SESSION::~SESSION(void)
{
}

BOOL SESSION::GetDAInfoFromPPNexus(
	IN PWSTR            pwszRegUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
	IN PWSTR            pwszRealm,    // user supplied buffer ...
	IN OUT PDWORD       pdwRealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    )
{
    BOOL fRetVal = FALSE;
    HINTERNET hRequest = NULL;
    HINTERNET hConnect = NULL;
    DWORD dwError;
    
#ifdef DBG
    WCHAR wNexusHost[512] = L"nexus.msn.pp.test.microsoft.com";
#else
    WCHAR wNexusHost[512] = L"nexus.passport.com";
#endif
    
    DWORD dwHostLen = sizeof(wNexusHost); // note: size of the buffer, not # of UNICODE characters
    
#ifdef DBG
    WCHAR wNexusObj[512] = L"sprdr/pprdr.asp";
#else
    WCHAR wNexusObj[512] = L"rdr/pprdr.asp";
#endif    
    DWORD dwObjLen = sizeof(wNexusObj);
    
    WCHAR wPassportUrls[1024];
    DWORD dwUrlsLen = ARRAYSIZE(wPassportUrls);
    DWORD dwValueType;

    WCHAR Delimiters[] = L",";
    PWSTR Token = NULL;
    // we allow only one Nexus contact per session to avoid infinite loop due to Nexus misconfiguration

    DWORD dwCurrentTime = ::GetTickCount();

    if ((dwCurrentTime >= m_LastNexusDownloadTime) && 
        (dwCurrentTime - m_LastNexusDownloadTime < 5*60*1000)) // 5 minutes
    {
        DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() failed: Nexus info already downloaded");
        goto exit;
    }

    // biaow-todo: when the Passport Team gives us THE final Nexus name, we'll then hard-code it here. And
    //             there will be no need to query registry here by then.
    
    if (m_hKeyLM)
    {
        dwError = ::RegQueryValueExW(m_hKeyLM,
                                     L"NexusHost",
                                     0,
                                     &dwValueType,
                                     reinterpret_cast<LPBYTE>(wNexusHost),
                                     &dwHostLen);

        PP_ASSERT(!(dwError == ERROR_MORE_DATA));
        // PP_ASSERT(dwValueType == REG_SZ); BVT Break!!!

        dwError = ::RegQueryValueExW(m_hKeyLM,
                                     L"NexusObj",
                                     0,
                                     &dwValueType,
                                     reinterpret_cast<LPBYTE>(wNexusObj),
                                     &dwObjLen);

        PP_ASSERT(!(dwError == ERROR_MORE_DATA));
        // PP_ASSERT(dwValueType == REG_SZ); BVT Break!!!
    }
    
    hConnect = Connect(wNexusHost,
#ifdef DISABLE_SSL
                    INTERNET_DEFAULT_HTTP_PORT
#else
                    INTERNET_DEFAULT_HTTPS_PORT
#endif
                       );
    if (hConnect == NULL)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::GetDAInfoFromPPNexus(): failed to connect to %ws; Error = %d", 
                       wNexusHost, dwErrorCode);
        goto exit;
    }

    hRequest = OpenRequest(hConnect,
                           NULL,
                           wNexusObj,
#ifdef DISABLE_SSL
                           0
#else                                                 
                           INTERNET_FLAG_SECURE
#endif
                           );

    if (hRequest == NULL)

    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; OpenRequest() to %ws failed, Error Code = %d",
                       wNexusObj, dwErrorCode);
        goto exit;
    }


    if (!SendRequest(hRequest, NULL, 0))
    {
        DWORD dwErrorCode = ::GetLastError();

#ifdef BAD_CERT_OK
        if (dwErrorCode == ERROR_INTERNET_INVALID_CA)
        {
            DWORD dwSecFlags;
            DWORD dwSecurityFlagsSize = sizeof(dwSecFlags);

            if (!QueryOption(hRequest, 
                                    INTERNET_OPTION_SECURITY_FLAGS,
                                    &dwSecFlags,
                                    &dwSecurityFlagsSize))
            {
                dwSecFlags = 0;
            }
            else
            {
                dwSecFlags |= SECURITY_SET_MASK;
            }

            if (!SetOption(hRequest, 
                                      INTERNET_OPTION_SECURITY_FLAGS, 
                                      &dwSecFlags, 
                                      dwSecurityFlagsSize))
            {
                PP_ASSERT(TRUE); // shouldn't reach here
                goto exit;
            }
            else
            {
                if (!SendRequest(hRequest, NULL, 0))
                {
                    DWORD dwErrorCode = ::GetLastError();
                    DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus(): SendRequest() failed");
                    goto exit;
                }
            }
        }
#else
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus(): failed");
        goto exit;
#endif // BAD_CERT_OK
    }

    if (QueryHeaders(hRequest,
                     HTTP_QUERY_PASSPORT_URLS,
                     wPassportUrls,
                     &dwUrlsLen) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; PassportUrls header not found");
        goto exit;
    }

    Token = ::wcstok(wPassportUrls, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no text in between commas");
            goto next_token;
        }

        // find DALocation
        if (!::_wcsnicmp(Token, L"DALogin", ::wcslen(L"DALogin")))
        {
            PWSTR pwszDAUrl = ::wcsstr(Token, L"=");
            if (pwszDAUrl == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DALocation");
                goto exit;
            }
            
            pwszDAUrl++; // skip "="

            while (*pwszDAUrl == (L" ")[0]) { ++pwszDAUrl; } // skip leading white spaces

            ::wcscpy(m_wDefaultDAUrl, L"https://");
            ::wcscat(m_wDefaultDAUrl, pwszDAUrl);

            if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                             L"LoginServerUrl",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(m_wDefaultDAUrl),
                             ::wcslen(m_wDefaultDAUrl) * sizeof(WCHAR)) != ERROR_SUCCESS)
            {
                if (m_hKeyCU)
                {
                    ::RegSetValueExW(m_hKeyCU,
                             L"LoginServerUrl",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(m_wDefaultDAUrl),
                             ::wcslen(m_wDefaultDAUrl) * sizeof(WCHAR));
                }
            }

            m_LastNexusDownloadTime = ::GetTickCount();
            fRetVal = TRUE;

            DoTraceMessage(PP_LOG_INFO, "DALocation URL %ws found", m_wDefaultDAUrl);
        }
        else if (!::_wcsnicmp(Token, L"DARealm", ::wcslen(L"DARealm")))
        {
            PWSTR pwszDARealm = ::wcsstr(Token, L"=");
            if (pwszDARealm == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DARealm");
                goto exit;
            }

            pwszDARealm++; // skip "="

            while (*pwszDARealm == (L" ")[0]) { ++pwszDARealm; } // skip leading white spaces

            if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                             L"LoginServerRealm",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(pwszDARealm),
                             ::wcslen(pwszDARealm) * sizeof(WCHAR)) != ERROR_SUCCESS)
            {
                if (m_hKeyCU)
                {
                ::RegSetValueExW(m_hKeyCU,
                             L"LoginServerRealm",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(pwszDARealm),
                             ::wcslen(pwszDARealm) * sizeof(WCHAR));
                }
            }

            if (pwszRealm)
            {
                if (*pdwRealmLen < ::wcslen(pwszDARealm) + 1)
                {
                    *pdwRealmLen = ::wcslen(pwszDARealm) + 1;
                    fRetVal = FALSE;
                    goto exit;
                }
                else
                {
                    ::wcscpy(pwszRealm, pwszDARealm);
                    *pdwRealmLen = ::wcslen(pwszDARealm) + 1;
                }
            }
            
            DoTraceMessage(PP_LOG_INFO, "DALocation URL %ws found", m_wDefaultDAUrl);
        }
        else if (!::_wcsnicmp(Token, L"DAReg", ::wcslen(L"DAReg")))
            {
                PWSTR pwszDAReg = ::wcsstr(Token, L"=");
                if (pwszDAReg == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DAReg");
                    goto exit;
                }

                pwszDAReg++; // skip "="

                while (*pwszDAReg == (L" ")[0]) { ++pwszDAReg; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"RegistrationUrl",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszDAReg),
                                 ::wcslen(pwszDAReg) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"RegistrationUrl",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszDAReg),
                                 ::wcslen(pwszDAReg) * sizeof(WCHAR));
                    }
                }

                if (pwszRegUrl)
                {
                    if (*pdwRegUrlLen < ::wcslen(pwszDAReg) + 1)
                    {
                        *pdwRegUrlLen = ::wcslen(pwszDAReg) + 1;
                        fRetVal = FALSE;
                        goto exit;
                    }
                    else
                    {
                        ::wcscpy(pwszRegUrl, pwszDAReg);
                        *pdwRegUrlLen = ::wcslen(pwszDAReg) + 1;
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "DALocation URL %ws found", m_wDefaultDAUrl);
            }

    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

exit:
    if (hRequest)
    {
        CloseHandle(hRequest);
    }
    if (hConnect)
    {
        CloseHandle(hConnect);
    }

    return fRetVal;
}

BOOL SESSION::UpdateDAInfo(
    PCWSTR pwszSignIn,
    PCWSTR pwszDAUrl
    )
{
    if (pwszSignIn)
    {
        LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
        if (pwszDomain && m_hKeyDAMap)
        {
            DWORD dwError = ::RegSetValueExW(m_hKeyDAMap,
                                             pwszDomain,
                                             0,
                                             REG_SZ,
                                             reinterpret_cast<const LPBYTE>(const_cast<PWSTR>(pwszDAUrl)),
                                             ::wcslen(pwszDAUrl) * sizeof(WCHAR));
            if (dwError == ERROR_SUCCESS)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL SESSION::GetDAInfo(PCWSTR pwszSignIn,
                        LPWSTR pwszDAHostName,
                        DWORD HostNameLen,
                        LPWSTR pwszDAHostObj,
                        DWORD HostObjLen)
{
    LPCWSTR pwszDAUrl = m_wDefaultDAUrl;

    WCHAR wDomainDAUrl[1024];
    DWORD dwDomainUrlLen = sizeof(wDomainDAUrl);

    if (pwszSignIn)
    {
        LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
        if (pwszDomain && m_hKeyDAMap)
        {
            DWORD dwValueType;
            DWORD dwError = ::RegQueryValueExW(m_hKeyDAMap, 
                                               pwszDomain,
                                               0,
                                               &dwValueType,
                                               reinterpret_cast<LPBYTE>(wDomainDAUrl),
                                               &dwDomainUrlLen);
            
            PP_ASSERT(!(dwError == ERROR_MORE_DATA));
            // PP_ASSERT(dwValueType == REG_SZ);

            if (dwError == ERROR_SUCCESS)
            {
                pwszDAUrl = wDomainDAUrl;
            }
        }
    }

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));

    UrlComps.dwStructSize = sizeof(UrlComps);

    UrlComps.lpszHostName = pwszDAHostName;
    UrlComps.dwHostNameLength = HostNameLen;

    UrlComps.lpszUrlPath = pwszDAHostObj;
    UrlComps.dwUrlPathLength = HostObjLen;

    if (CrackUrl(pwszDAUrl, 
                 0, 
                 0, 
                 &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::GetDAInfo() failed; can not crack the URL %ws",
                       pwszDAUrl);
        return FALSE;
    }

    return TRUE;
}


BOOL SESSION::Open(PCWSTR /*pwszHttpStack*/, HINTERNET)
{
    BOOL fRetVal = FALSE;
    DWORD dwError;
    DWORD dwValueType;
    DWORD dwUrlLen = sizeof(m_wDefaultDAUrl); // note: size of the buffer, not # of UNICODE characters
    BOOL fDAInfoCached = FALSE; // assume NO DA info's cached locally

    dwError = ::RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &m_hKeyLM,
                          NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);
        
        // we can't open the Passport key for read & write, let's try open it for read only
        ::RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &m_hKeyLM,
                          NULL);

        // if we still can't open it for read, we are still fine since we can download the info from the
        // Nexus server. *NOTE* m_hKeyLM could be NULL from this point on.
    }

    dwError = ::RegCreateKeyExW(HKEY_CURRENT_USER,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &m_hKeyCU,
                          NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);

        ::RegCreateKeyExW(HKEY_CURRENT_USER,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &m_hKeyCU,
                          NULL);
    }

    if (m_hKeyCU)
    {
        dwError = ::RegCreateKeyExW(m_hKeyCU,
                              L"DAMap",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &m_hKeyDAMap,
                              NULL);

        if (dwError != ERROR_SUCCESS)
        {
            DoTraceMessage(PP_LOG_ERROR, 
                           "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);
        
            ::RegCreateKeyExW(m_hKeyCU,
                              L"DAMap",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ,
                              NULL,
                              &m_hKeyDAMap,
                              NULL);        
        }
    }
    
    if (m_hKeyCU == NULL || ::RegQueryValueExW(m_hKeyCU, 
                           L"LoginServerUrl",
                           0,
                           &dwValueType,
                           reinterpret_cast<LPBYTE>(m_wDefaultDAUrl),
                           &dwUrlLen) != ERROR_SUCCESS)
    {
        if (m_hKeyLM && ::RegQueryValueExW(m_hKeyLM, 
                               L"LoginServerUrl",
                               0,
                               &dwValueType,
                               reinterpret_cast<LPBYTE>(m_wDefaultDAUrl),
                               &dwUrlLen) == ERROR_SUCCESS)
        {
            fDAInfoCached = TRUE;
        }
    }
    else
    {
        fDAInfoCached = TRUE;
    }

    PP_ASSERT(!(dwError == ERROR_MORE_DATA));
    // PP_ASSERT(dwValueType == REG_SZ); BVT break!!!

    if (!fDAInfoCached || (::wcslen(m_wDefaultDAUrl) == ::wcslen(L"")))
    {
        if (GetDAInfoFromPPNexus(NULL, 0, NULL, 0) == FALSE)
        {
            goto exit;
        }
    }
    else
    {
        /*
        URL_COMPONENTSW UrlComps;
        ::memset(&UrlComps, 0, sizeof(UrlComps));

        UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);

        UrlComps.lpszHostName = m_wDAHostName;
        UrlComps.dwHostNameLength = ARRAYSIZE(m_wDAHostName);

        UrlComps.lpszUrlPath = m_wDATargetObj;
        UrlComps.dwUrlPathLength = ARRAYSIZE(m_wDATargetObj);

        if (CrackUrl(m_wDefaultDAUrl, 
                          0, 
                          0, 
                          &UrlComps) == FALSE)
        {
            DoTraceMessage(PP_LOG_ERROR, 
                           "WININET_SESSION::Open() failed; can not crack the URL %ws",
                           m_wDefaultDAUrl);
            goto exit;
        }
        */
    }

    /*
    DWORD dwRegUrlLen = sizeof(m_wRegistrationUrl);
    dwError = ::RegQueryValueExW(m_hKeyLM, 
                       L"RegistrationUrl",
                       0,
                       &dwValueType,
                       reinterpret_cast<LPBYTE>(m_wRegistrationUrl),
                       &dwRegUrlLen);

    PP_ASSERT(!(dwError == ERROR_MORE_DATA));
    */

    m_hCredUI = ::LoadLibraryW(L"advapi32.dll");
    if (m_hCredUI)
    {
        m_pfnReadDomainCred = 
                    reinterpret_cast<PFN_READ_DOMAIN_CRED_W>(::GetProcAddress(m_hCredUI, "CredReadDomainCredentialsW"));
        if (m_pfnReadDomainCred == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "failed to bind to CredReadDomainCredentialsW()"); 
        }

        m_pfnCredFree = 
            reinterpret_cast<PFN_CRED_FREE>(::GetProcAddress(m_hCredUI, "CredFree"));
        if (m_pfnCredFree == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "failed to bind to CredFree()"); 
        }
    }

    fRetVal = TRUE;

exit:

    return fRetVal;
}

void SESSION::Logout(void)
{
    if (!m_fLogout)
    {
        m_fLogout = TRUE;
        ::GetSystemTime(&m_LogoutTimeStamp);
    }
}

BOOL SESSION::IsLoggedOut(void) const
{
    return m_fLogout;
}

void SESSION::ResetLogoutFlag(void)
{
    m_fLogout = FALSE;
}

const SYSTEMTIME* SESSION::GetLogoutTimeStamp(void) const
{
    return &m_LogoutTimeStamp;
}

void SESSION::Close(void)
{
    if (m_hCredUI)
    {
       ::FreeLibrary(m_hCredUI);
        m_hCredUI = NULL;
    }

    if (m_hKeyDAMap)
    {
        ::RegCloseKey(m_hKeyDAMap);
    }

    if (m_hKeyCU)
    {
        ::RegCloseKey(m_hKeyCU);
    }
    
    if (m_hKeyLM)
    {
        ::RegCloseKey(m_hKeyLM);
    }
}


//
// Implementation for WININET_SESSION
//

// -----------------------------------------------------------------------------
WININET_SESSION::WININET_SESSION(void)
{
    m_hInternet = NULL;

    m_pfnConnect = NULL;
    m_pfnOpenRequest = NULL;
    m_pfnSendRequest = NULL;
    m_pfnQueryInfo = NULL;
    m_pfnCloseHandle = NULL;
    m_pfnSetOption = NULL;
    m_pfnOpenUrl = NULL;
    m_pfnQueryOption = NULL;
    m_pfnCrack = NULL;
    m_pfnReadFile = NULL;
}

// -----------------------------------------------------------------------------
WININET_SESSION::~WININET_SESSION(void)
{
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::Connect(
    LPCWSTR lpwszServerName,
    INTERNET_PORT nPort)
{
    PP_ASSERT(m_pfnConnect != NULL);

    return (*m_pfnConnect)(m_hInternet, 
                    lpwszServerName, 
                    nPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::OpenRequest(
    HINTERNET hConnect,
    LPCWSTR lpwszVerb,
    LPCWSTR lpwszObjectName,
    DWORD dwFlags,
    DWORD_PTR dwContext)
{
    PP_ASSERT(m_pfnOpenRequest != NULL);

    return (*m_pfnOpenRequest)(hConnect,
                               lpwszVerb,
                               lpwszObjectName,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               dwFlags,
							   dwContext);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::SendRequest(
    HINTERNET hRequest,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD_PTR dwContext)
{                                                                 

    PP_ASSERT(m_pfnSendRequest != NULL);

    return (*m_pfnSendRequest)(hRequest,
                        lpwszHeaders,
                        dwHeadersLength,
                        NULL,
                        0);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::QueryHeaders(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex)
{
    PP_ASSERT(m_pfnQueryInfo != NULL);

    return (*m_pfnQueryInfo)(hRequest,
                             dwInfoLevel,
                             lpvBuffer,
                             lpdwBufferLength,
                             lpdwIndex);
}

// -----------------------------------------------------------------------------
BOOL  WININET_SESSION::CloseHandle(
    IN HINTERNET hInternet)
{
    PP_ASSERT(m_pfnCloseHandle != NULL);

    return (*m_pfnCloseHandle)(hInternet);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::QueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength)
{
    PP_ASSERT(m_pfnQueryOption != NULL);

    return (*m_pfnQueryOption)(hInternet,
                               dwOption,
                               lpBuffer,
                               lpdwBufferLength
                               );
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::SetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength)
{
    PP_ASSERT(m_pfnSetOption != NULL);

    return (*m_pfnSetOption)(hInternet,
                             dwOption,
                             lpBuffer,
                             dwBufferLength);
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::OpenUrl(
    LPCWSTR lpwszUrl,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags)
{
    PP_ASSERT(m_pfnOpenUrl != NULL);

    return (*m_pfnOpenUrl)(m_hInternet,
                           lpwszUrl,
                           lpwszHeaders,
                           dwHeadersLength,
                           dwFlags,
                           0);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::ReadFile(
    HINTERNET hFile,
    LPVOID lpBuffer,
    DWORD dwNumberOfBytesToRead,
    LPDWORD lpdwNumberOfBytesRead)
{
    PP_ASSERT(m_pfnReadFile != NULL);

    return (*m_pfnReadFile)(
                            hFile,
                            lpBuffer,
                            dwNumberOfBytesToRead,
                            lpdwNumberOfBytesRead);
}

BOOL WININET_SESSION::CrackUrl(
    LPCWSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents)
{
    PP_ASSERT (m_pfnCrack != NULL);

    return (*m_pfnCrack)(lpszUrl,
                         dwUrlLength,
                         dwFlags,
                         lpUrlComponents);
}


PVOID WININET_SESSION::SetStatusCallback(
    HINTERNET hInternet,
    PVOID lpfnCallback
    )
{
    PP_ASSERT (m_pfnStatusCallback != NULL);

    return (*m_pfnStatusCallback)(hInternet,
                                  (INTERNET_STATUS_CALLBACK)lpfnCallback);

}

BOOL WININET_SESSION::AddHeaders(
    HINTERNET hConnect,
    LPCWSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwModifiers
    )
{
    PP_ASSERT(m_pfnAddHeaders != NULL);

    return (*m_pfnAddHeaders)(hConnect,
                              lpszHeaders,
                              dwHeadersLength,
                              dwModifiers
                              );
}



BOOL WININET_SESSION::InitHttpApi(PFN_INTERNET_OPEN* ppfnInternetOpen)
{
    BOOL  fRet = FALSE;

    m_pfnCloseHandle =
        reinterpret_cast<PFN_CLOSE_HANDLE>(::GetProcAddress(m_hHttpStack, "InternetCloseHandle"));
    if (m_pfnCloseHandle == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetCloseHandle not found");
        goto exit;
    }

    *ppfnInternetOpen = 
        reinterpret_cast<PFN_INTERNET_OPEN>(::GetProcAddress(m_hHttpStack, "InternetOpenW"));
    if (*ppfnInternetOpen == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetOpenW not found");
        goto exit;
    }

    m_pfnConnect = 
        reinterpret_cast<PFN_INTERNET_CONNECT>(::GetProcAddress(m_hHttpStack, "InternetConnectW"));
    if (m_pfnConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetConnectW not found");
        goto exit;
    }

    m_pfnOpenRequest = 
        reinterpret_cast<PFN_OPEN_REQUEST>(::GetProcAddress(m_hHttpStack, "HttpOpenRequestW"));
    if (m_pfnOpenRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpOpenRequestW not found");
        goto exit;
    }

    m_pfnSendRequest =
        reinterpret_cast<PFN_SEND_REQUEST>(::GetProcAddress(m_hHttpStack, "HttpSendRequestW"));
    if (m_pfnSendRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpSendRequestW not found");
        goto exit;
    }

    m_pfnQueryInfo =
        reinterpret_cast<PFN_QUERY_INFO>(::GetProcAddress(m_hHttpStack, "HttpQueryInfoW"));
    if (m_pfnQueryInfo == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpQueryInfoW not found");
        goto exit;
    }
    
    m_pfnSetOption =
        reinterpret_cast<PFN_SET_OPTION>(::GetProcAddress(m_hHttpStack, "InternetSetOptionW"));
    if (m_pfnSetOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetSetOptionW not found");
        goto exit;
    }

    m_pfnOpenUrl =
        reinterpret_cast<PFN_OPEN_URL>(::GetProcAddress(m_hHttpStack, "InternetOpenUrlW"));
    if (m_pfnOpenUrl == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetOpenUrlW not found");
        goto exit;
    }

    m_pfnQueryOption =
            reinterpret_cast<PFN_QUERY_OPTION>(::GetProcAddress(m_hHttpStack, "InternetQueryOptionW"));
    if (m_pfnQueryOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetQueryOptionW not found");
        goto exit;
    }

    m_pfnCrack =
            reinterpret_cast<PFN_CRACK_URL>(::GetProcAddress(m_hHttpStack, "InternetCrackUrlW"));
        if (m_pfnCrack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetCrackUrlW not found");
        goto exit;
    }

    m_pfnReadFile =
            reinterpret_cast<PFN_READ_FILE>(::GetProcAddress(m_hHttpStack, "InternetReadFile"));
    if (m_pfnReadFile == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetReadFile not found");
        goto exit;
    }

    m_pfnStatusCallback =
        reinterpret_cast<PFN_STATUS_CALLBACK>(::GetProcAddress(m_hHttpStack, "InternetSetStatusCallbackW"));
    if (m_pfnStatusCallback == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetSetStatusCallback not found");
        goto exit;
    }

    m_pfnAddHeaders =
        reinterpret_cast<PFN_ADD_HEADERS>(::GetProcAddress(m_hHttpStack, "HttpAddRequestHeadersW"));
    if (m_pfnAddHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpAddRequestHeaders not found");
        goto exit;
    }


    fRet = TRUE;

exit:
    return fRet;
}

BOOL WININET_SESSION::Open(
    PCWSTR pwszHttpStack,
    HINTERNET hInternet
    )
{
    PP_ASSERT(pwszHttpStack != NULL);

    DWORD dwErrorCode;
    BOOL  fRet = FALSE;
    PFN_INTERNET_OPEN pfnInternetOpen = NULL;

    PP_ASSERT(m_hHttpStack == 0);
    m_hHttpStack = ::LoadLibraryW(pwszHttpStack);
    if (m_hHttpStack == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to load library %ws; error = %d", pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (InitHttpApi(&pfnInternetOpen) == FALSE)
    {
        goto exit;
    }

    if (hInternet)
    {
        m_hInternet = hInternet;
        m_fOwnedSession = FALSE;
    }
    else
    {
        m_hInternet = (*pfnInternetOpen)(
                                         L"Microsoft.NET-Passport-Authentication-Service/1.4",
                                         INTERNET_OPEN_TYPE_PRECONFIG,
                                         NULL,
                                         NULL,
                                         0 /*INTERNET_FLAG_ASYNC*/ // biaow-todo: use async
                                         );
        m_fOwnedSession = TRUE;
    }
    if (m_hInternet == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to open an HTTP session through %ws; error = %d", 
                       pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (SESSION::Open(pwszHttpStack, hInternet) == FALSE)
    {
        goto exit;
    }
    
    fRet = TRUE;

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session opened");

exit:
    if (!fRet)
    {
        if (m_hInternet && m_fOwnedSession)
        {
            (*m_pfnCloseHandle)(m_hInternet);
            m_hInternet = NULL;
        }
        if (m_hHttpStack)
        {
           ::FreeLibrary(m_hHttpStack);
            m_hHttpStack = NULL;
        }
        
        DoTraceMessage(PP_LOG_ERROR, "WinInet Http Session failed");
    }

    return fRet;
}

void WININET_SESSION::Close(void)
{
    PP_ASSERT(m_pfnCloseHandle);
    if (m_hInternet && m_fOwnedSession)
    {
        (*m_pfnCloseHandle)(m_hInternet);
        m_pfnCloseHandle = NULL;
    }

    if (m_hHttpStack)
    {
       ::FreeLibrary(m_hHttpStack);
        m_hHttpStack = NULL;
    }

    SESSION::Close();

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session closed");
}

#ifdef PP_DEMO
BOOL WININET_SESSION::ContactPartner(PCWSTR pwszPartnerUrl,
                                     PCWSTR pwszVerb,
                                     PCWSTR pwszHeaders,
                                     PWSTR  pwszData,
                                     PDWORD pdwDataLength
                                     )
{
    BOOL fRet = FALSE;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    WCHAR ServerName[128];
    WCHAR ObjectPath[1024];

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));
    
    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);
    
    UrlComps.lpszHostName = ServerName;
    UrlComps.dwHostNameLength = ARRAYSIZE(ServerName);

    UrlComps.lpszUrlPath = ObjectPath;
    UrlComps.dwUrlPathLength = ARRAYSIZE(ObjectPath);

    PP_ASSERT(m_pfnCrack != NULL);

    if ((*m_pfnCrack)(pwszPartnerUrl, 
                      0, 
                      0, 
                      &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not crack the URL %ws",
                       pwszPartnerUrl);
        goto exit;
    }

    PP_ASSERT(m_pfnConnect != NULL);

    hConnect = (*m_pfnConnect)(m_hInternet, 
                    UrlComps.lpszHostName, 
                    UrlComps.nPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);
    if (hConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not open an HTTP sesstion to %ws:%d",
                       UrlComps.lpszHostName, UrlComps.nPort);
        goto exit;
    }

    PP_ASSERT(m_pfnOpenRequest != NULL);

    hRequest = (*m_pfnOpenRequest)(hConnect,
                               pwszVerb,
                               UrlComps.lpszUrlPath,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_NO_AUTH,
                               0);
    if (hRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not open an HTTP request to %ws:(%ws)",
                       UrlComps.lpszUrlPath, pwszVerb);
        goto exit;
    }

    PP_ASSERT(m_pfnSendRequest != NULL);

    if ((*m_pfnSendRequest)(hRequest,
                        pwszHeaders,
                        0,
                        NULL,
                        0) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not send an HTTP request");

        goto exit;
    }

    if (pwszData == NULL)
    {
        fRet = TRUE;
        goto exit;
    }
    
    DWORD dwStatus, dwStatusLen;
    dwStatusLen = sizeof(dwStatus);
    if (!QueryHeaders(hRequest, 
                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                      &dwStatus,
                      &dwStatusLen))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not query status code");
        goto exit;
    }

    if (dwStatus != HTTP_STATUS_REDIRECT)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; expecting %d but get %d",
                       HTTP_STATUS_REDIRECT, dwStatus);
        goto exit;
    }

    ::wcscpy(pwszData, L"WWW-Authenticate: ");
    if(!QueryHeaders(hRequest,
                     HTTP_QUERY_WWW_AUTHENTICATE, 
                     (LPVOID)(pwszData + ::wcslen(L"WWW-Authenticate: ")),
                     pdwDataLength))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; no auth headers found");
        goto exit;
    }

    (*m_pfnCloseHandle)(hRequest);
    hRequest = NULL;
    (*m_pfnCloseHandle)(hConnect);
    hConnect = NULL;
    
    fRet = TRUE;

exit:
    if (hRequest)
    {
        (*m_pfnCloseHandle)(hRequest);
        hRequest = NULL;
    }

    if (hConnect)
    {
        (*m_pfnCloseHandle)(hConnect);
        hConnect = NULL;
    }

    return fRet;
}
#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\passport\httpsess.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    InetSess.cpp

Abstract:

    Implements the Passport Session that uses WinInet as the underlying transport.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"

/*
#ifdef HINTERNET
#undef HINTERNET
#endif

#ifdef INTERNET_PORT
#undef INTERNET_PORT
#endif

#include <WinHTTP.h>
*/

#define INTERNET_DEFAULT_HTTP_PORT      80
#define INTERNET_DEFAULT_HTTPS_PORT     443
#define WINHTTP_HEADER_NAME_BY_INDEX    NULL
#define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY  0
#define INTERNET_OPEN_TYPE_PRECONFIG  INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000
#define INTERNET_FLAG_NO_AUTH           0x00040000
#define HTTP_QUERY_FLAG_NUMBER          0x20000000
#define HTTP_QUERY_STATUS_CODE          19  // special: part of status line
#define HTTP_STATUS_REDIRECT            302 // object temporarily moved
#define HTTP_QUERY_WWW_AUTHENTICATE     40

typedef
VOID
(CALLBACK * WINHTTP_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

#include "session.h"

// #include "inetsess.tmh"

//
// func pointer decl for WinInet
//

typedef HINTERNET
(WINAPI * PFN_INTERNET_OPEN)(
    IN LPCWSTR lpwszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpwszProxy OPTIONAL,
    IN LPCWSTR lpwszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_INTERNET_CONNECT)(
    IN HINTERNET hInternet,
    IN LPCWSTR lpwszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_OPEN_REQUEST)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpwszVerb,
    IN LPCWSTR lpwszObjectName,
    IN LPCWSTR lpwszVersion,
    IN LPCWSTR lpwszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    );

typedef BOOL
(WINAPI * PFN_SEND_REQUEST)(
    IN HINTERNET hRequest,
    IN LPCWSTR lpwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    );

typedef BOOL 
(WINAPI * PFN_QUERY_INFO)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPCWSTR lpszName OPTIONAL,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
);

typedef BOOL 
(WINAPI* PFN_CLOSE_HANDLE)(
    IN HINTERNET hInternet
);

typedef BOOL 
(WINAPI* PFN_SET_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

typedef BOOL 
(WINAPI* PFN_QUERY_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
);

typedef HINTERNET 
(WINAPI* PFN_OPEN_URL)(
    IN HINTERNET hInternet, 
    IN LPCWSTR lpwszUrl,
    IN LPCWSTR lpwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
);

typedef int INTERNET_SCHEME, * LPINTERNET_SCHEME;

#define INTERNET_SCHEME_HTTP        (1)
#define INTERNET_SCHEME_HTTPS       (2)

#define INTERNET_SCHEME_PARTIAL     (-2)
#define INTERNET_SCHEME_UNKNOWN     (-1)
#define INTERNET_SCHEME_DEFAULT     (0)
#define INTERNET_SCHEME_SOCKS       (3)
#define INTERNET_SCHEME_FIRST       (INTERNET_SCHEME_HTTP)
#define INTERNET_SCHEME_LAST        (INTERNET_SCHEME_SOCKS)

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSW, * LPURL_COMPONENTSW;

typedef BOOL 
(WINAPI* PFN_CRACK_URL)(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents
);

typedef BOOL 
(WINAPI* PFN_READ_FILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

typedef WINHTTP_STATUS_CALLBACK
(WINAPI* PFN_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    );

typedef BOOL 
(WINAPI* PFN_ADD_HEADERS)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);


class WINHTTP_SESSION : public SESSION
{
protected:
    WINHTTP_SESSION(void);
    virtual ~WINHTTP_SESSION(void);

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET);
    virtual void Close(void);

protected:    
    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT);

    virtual HINTERNET OpenRequest(
            HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0);

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0);

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL);

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet);

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength);    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength);

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags);

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead);

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents);

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        );

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        );

#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR pwszData,
                                PDWORD pdwDataLength
                                );
#endif // PP_DEMO

    BOOL InitHttpApi(PFN_INTERNET_OPEN*);

protected:
    HINTERNET m_hInternet;

    PFN_INTERNET_CONNECT    m_pfnConnect;
    PFN_OPEN_REQUEST        m_pfnOpenRequest;
    PFN_SEND_REQUEST        m_pfnSendRequest;
    PFN_QUERY_INFO          m_pfnQueryInfo;
    PFN_CLOSE_HANDLE        m_pfnCloseHandle;
    PFN_SET_OPTION          m_pfnSetOption;
    PFN_OPEN_URL            m_pfnOpenUrl;
    PFN_QUERY_OPTION        m_pfnQueryOption;
    PFN_CRACK_URL           m_pfnCrack;
    PFN_READ_FILE           m_pfnReadFile;
    PFN_STATUS_CALLBACK     m_pfnStatusCallback;
    PFN_ADD_HEADERS         m_pfnAddHeaders;

friend class SESSION;
friend SESSION* CreateWinHttpSession(void);
};

SESSION* CreateWinHttpSession(void)
{
    return new WINHTTP_SESSION();
}

//
// Implementation for WINHTTP_SESSION
//

// -----------------------------------------------------------------------------
WINHTTP_SESSION::WINHTTP_SESSION(void)
{
    m_hInternet = NULL;

    m_pfnConnect = NULL;
    m_pfnOpenRequest = NULL;
    m_pfnSendRequest = NULL;
    m_pfnQueryInfo = NULL;
    m_pfnCloseHandle = NULL;
    m_pfnSetOption = NULL;
    m_pfnOpenUrl = NULL;
    m_pfnQueryOption = NULL;
    m_pfnCrack = NULL;
    m_pfnReadFile = NULL;
}

// -----------------------------------------------------------------------------
WINHTTP_SESSION::~WINHTTP_SESSION(void)
{
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::Connect(
    LPCWSTR lpwszServerName,
    INTERNET_PORT nPort)
{
    PP_ASSERT(m_pfnConnect != NULL);

    return (*m_pfnConnect)(m_hInternet, 
                    lpwszServerName, 
                    nPort,
                    0);
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::OpenRequest(
    HINTERNET hConnect,
    LPCWSTR lpwszVerb,
    LPCWSTR lpwszObjectName,
    DWORD dwFlags,
    DWORD_PTR dwContext)
{
    PP_ASSERT(m_pfnOpenRequest != NULL);

    return (*m_pfnOpenRequest)(hConnect,
                               lpwszVerb,
                               lpwszObjectName,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               dwFlags);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::SendRequest(
    HINTERNET hRequest,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD_PTR dwContext)
{                                                                 

    PP_ASSERT(m_pfnSendRequest != NULL);

    return (*m_pfnSendRequest)(hRequest,
                        lpwszHeaders,
                        dwHeadersLength,
                        NULL,
                        0,
						0, // optional total length
                        dwContext);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::QueryHeaders(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex)
{
    PP_ASSERT(m_pfnQueryInfo != NULL);

    return (*m_pfnQueryInfo)(hRequest,
                             dwInfoLevel,
                             WINHTTP_HEADER_NAME_BY_INDEX,
                             lpvBuffer,
                             lpdwBufferLength,
                             lpdwIndex);
}

// -----------------------------------------------------------------------------
BOOL  WINHTTP_SESSION::CloseHandle(
    IN HINTERNET hInternet)
{
    PP_ASSERT(m_pfnCloseHandle != NULL);

    return (*m_pfnCloseHandle)(hInternet);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::QueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength)
{
    PP_ASSERT(m_pfnQueryOption != NULL);

    return (*m_pfnQueryOption)(hInternet,
                               dwOption,
                               lpBuffer,
                               lpdwBufferLength
                               );
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::SetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength)
{
    PP_ASSERT(m_pfnSetOption != NULL);

    return (*m_pfnSetOption)(hInternet,
                             dwOption,
                             lpBuffer,
                             dwBufferLength);
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::OpenUrl(
    LPCWSTR lpwszUrl,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags)
{
    return NULL;
    /*
    PP_ASSERT(m_pfnOpenUrl != NULL);

    return (*m_pfnOpenUrl)(m_hInternet,
                           lpwszUrl,
                           lpwszHeaders,
                           dwHeadersLength,
                           dwFlags,
                           0);
    */
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::ReadFile(
    HINTERNET hFile,
    LPVOID lpBuffer,
    DWORD dwNumberOfBytesToRead,
    LPDWORD lpdwNumberOfBytesRead)
{
    PP_ASSERT(m_pfnReadFile != NULL);

    return (*m_pfnReadFile)(
                            hFile,
                            lpBuffer,
                            dwNumberOfBytesToRead,
                            lpdwNumberOfBytesRead);
}

BOOL WINHTTP_SESSION::CrackUrl(
    LPCWSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents)
{
    PP_ASSERT (m_pfnCrack != NULL);

    return (*m_pfnCrack)(lpszUrl,
                         dwUrlLength,
                         dwFlags,
                         lpUrlComponents);
}

PVOID WINHTTP_SESSION::SetStatusCallback(
    HINTERNET hInternet,
    PVOID lpfnCallback
    )
{
    return (*m_pfnStatusCallback)(hInternet,
                                  (WINHTTP_STATUS_CALLBACK)lpfnCallback,
                                  0,
                                  0);

}

BOOL WINHTTP_SESSION::AddHeaders(
    HINTERNET hConnect,
    LPCWSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwModifiers
    )
{
    PP_ASSERT(m_pfnAddHeaders != NULL);

    return (*m_pfnAddHeaders)(hConnect,
                              lpszHeaders,
                              dwHeadersLength,
                              dwModifiers
                              );
}

BOOL WINHTTP_SESSION::InitHttpApi(PFN_INTERNET_OPEN* ppfnInternetOpen)
{
    BOOL  fRet = FALSE;

    m_pfnCloseHandle =
        reinterpret_cast<PFN_CLOSE_HANDLE>(::GetProcAddress(m_hHttpStack, "WinHttpCloseHandle"));
    if (m_pfnCloseHandle == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpCloseHandle not found");
        goto exit;
    }

    *ppfnInternetOpen = 
        reinterpret_cast<PFN_INTERNET_OPEN>(::GetProcAddress(m_hHttpStack, "WinHttpOpen"));
    if (*ppfnInternetOpen == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpen not found");
        goto exit;
    }

    m_pfnConnect = 
        reinterpret_cast<PFN_INTERNET_CONNECT>(::GetProcAddress(m_hHttpStack, "WinHttpConnect"));
    if (m_pfnConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpConnect not found");
        goto exit;
    }

    m_pfnOpenRequest = 
        reinterpret_cast<PFN_OPEN_REQUEST>(::GetProcAddress(m_hHttpStack, "WinHttpOpenRequest"));
    if (m_pfnOpenRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpenRequest not found");
        goto exit;
    }

    m_pfnSendRequest =
        reinterpret_cast<PFN_SEND_REQUEST>(::GetProcAddress(m_hHttpStack, "WinHttpSendRequest"));
    if (m_pfnSendRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSendRequest not found");
        goto exit;
    }

    m_pfnQueryInfo =
        reinterpret_cast<PFN_QUERY_INFO>(::GetProcAddress(m_hHttpStack, "WinHttpQueryHeaders"));
    if (m_pfnQueryInfo == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpQueryHeaders not found");
        goto exit;
    }
    
    m_pfnSetOption =
        reinterpret_cast<PFN_SET_OPTION>(::GetProcAddress(m_hHttpStack, "WinHttpSetOption"));
    if (m_pfnSetOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSetOption not found");
        goto exit;
    }

    /*
    m_pfnOpenUrl =
        reinterpret_cast<PFN_OPEN_URL>(::GetProcAddress(m_hHttpStack, "WinHttpOpenUrl"));
    if (m_pfnOpenUrl == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpenUrl not found");
        goto exit;
    }
    */

    m_pfnQueryOption =
            reinterpret_cast<PFN_QUERY_OPTION>(::GetProcAddress(m_hHttpStack, "WinHttpQueryOption"));
    if (m_pfnQueryOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpQueryOption not found");
        goto exit;
    }

    m_pfnCrack =
            reinterpret_cast<PFN_CRACK_URL>(::GetProcAddress(m_hHttpStack, "WinHttpCrackUrl"));
        if (m_pfnCrack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpCrackUrl not found");
        goto exit;
    }

    m_pfnReadFile =
            reinterpret_cast<PFN_READ_FILE>(::GetProcAddress(m_hHttpStack, "WinHttpReadData"));
    if (m_pfnReadFile == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpReadData not found");
        goto exit;
    }

    m_pfnStatusCallback =
        reinterpret_cast<PFN_STATUS_CALLBACK>(::GetProcAddress(m_hHttpStack, "WinHttpSetStatusCallback"));
    if (m_pfnStatusCallback == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSetStatusCallback not found");
        goto exit;
    }

    m_pfnAddHeaders =
        reinterpret_cast<PFN_ADD_HEADERS>(::GetProcAddress(m_hHttpStack, "WinHttpAddRequestHeaders"));
    if (m_pfnAddHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpAddRequestHeaders not found");
        goto exit;
    }
    
    fRet = TRUE;

exit:
    return fRet;
}

BOOL WINHTTP_SESSION::Open(
    PCWSTR pwszHttpStack,
    HINTERNET hInternet
    )
{
    PP_ASSERT(pwszHttpStack != NULL);

    DWORD dwErrorCode;
    BOOL  fRet = FALSE;
    PFN_INTERNET_OPEN pfnInternetOpen = NULL;

    PP_ASSERT(m_hHttpStack == 0);
    m_hHttpStack = ::LoadLibraryW(pwszHttpStack);
    if (m_hHttpStack == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to load library %ws; error = %d", pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (InitHttpApi(&pfnInternetOpen) == FALSE)
    {
        goto exit;
    }

    if (hInternet)
    {
        m_hInternet = hInternet;
        m_fOwnedSession = FALSE;
    }
    else
    {
        m_hInternet = (*pfnInternetOpen)(
                                         L"Microsoft WinHttp Passport Authentication Service 1.4",
                                         INTERNET_OPEN_TYPE_PRECONFIG,  // ? name didn't get changed yet
                                         NULL,
                                         NULL,
                                         0 /*WINHTTP_FLAG_ASYNC*/ // biaow-todo: use async
                                         );
        m_fOwnedSession = TRUE;
    }
    if (m_hInternet == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to open an HTTP session through %ws; error = %d", 
                       pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (SESSION::Open(pwszHttpStack, hInternet) == FALSE)
    {
        goto exit;
    }
    
    fRet = TRUE;

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session opened");

exit:
    if (!fRet)
    {
        if (m_hInternet && m_fOwnedSession)
        {
            (*m_pfnCloseHandle)(m_hInternet);
            m_hInternet = NULL;
        }
        if (m_hHttpStack)
        {
           ::FreeLibrary(m_hHttpStack);
            m_hHttpStack = NULL;
        }
        
        DoTraceMessage(PP_LOG_ERROR, "WinInet Http Session failed");
    }

    return fRet;
}

void WINHTTP_SESSION::Close(void)
{
    PP_ASSERT(m_pfnCloseHandle);
    if (m_hInternet && m_fOwnedSession)
    {
        (*m_pfnCloseHandle)(m_hInternet);
        m_pfnCloseHandle = NULL;
    }

    if (m_hHttpStack)
    {
       ::FreeLibrary(m_hHttpStack);
        m_hHttpStack = NULL;
    }

    SESSION::Close();

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session closed");
}

#ifdef PP_DEMO
BOOL WINHTTP_SESSION::ContactPartner(PCWSTR pwszPartnerUrl,
                                     PCWSTR pwszVerb,
                                     PCWSTR pwszHeaders,
                                     PWSTR  pwszData,
                                     PDWORD pdwDataLength
                                     )
{
    BOOL fRet = FALSE;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    WCHAR ServerName[128];
    WCHAR ObjectPath[1024];

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));
    
    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);
    
    UrlComps.lpszHostName = ServerName;
    UrlComps.dwHostNameLength = ARRAYSIZE(ServerName);

    UrlComps.lpszUrlPath = ObjectPath;
    UrlComps.dwUrlPathLength = ARRAYSIZE(ObjectPath);

    PP_ASSERT(m_pfnCrack != NULL);

    if ((*m_pfnCrack)(pwszPartnerUrl, 
                      0, 
                      0, 
                      &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not crack the URL %ws",
                       pwszPartnerUrl);
        goto exit;
    }

    PP_ASSERT(m_pfnConnect != NULL);

    hConnect = (*m_pfnConnect)(m_hInternet, 
                    UrlComps.lpszHostName, 
                    UrlComps.nPort,
                    0);
    if (hConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not open an HTTP sesstion to %ws:%d",
                       UrlComps.lpszHostName, UrlComps.nPort);
        goto exit;
    }

    PP_ASSERT(m_pfnOpenRequest != NULL);

    hRequest = (*m_pfnOpenRequest)(hConnect,
                               pwszVerb,
                               UrlComps.lpszUrlPath,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_NO_AUTH);
    if (hRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not open an HTTP request to %ws:(%ws)",
                       UrlComps.lpszUrlPath, pwszVerb);
        goto exit;
    }

    PP_ASSERT(m_pfnSendRequest != NULL);

    if ((*m_pfnSendRequest)(hRequest,
                        pwszHeaders,
                        0,
                        NULL,
                        0,
                        0,
                        0) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not send an HTTP request");

        goto exit;
    }

    if (pwszData == NULL)
    {
        fRet = TRUE;
        goto exit;
    }
    
    DWORD dwStatus, dwStatusLen;
    dwStatusLen = sizeof(dwStatus);
    if (!QueryHeaders(hRequest, 
                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                      &dwStatus,
                      &dwStatusLen))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not query status code");
        goto exit;
    }

    if (dwStatus != HTTP_STATUS_REDIRECT)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; expecting %d but get %d",
                       HTTP_STATUS_REDIRECT, dwStatus);
        goto exit;
    }

    ::wcscpy(pwszData, L"WWW-Authenticate: ");
    if(!QueryHeaders(hRequest,
                     HTTP_QUERY_WWW_AUTHENTICATE, 
                     (LPVOID)(pwszData + ::wcslen(L"WWW-Authenticate: ")),
                     pdwDataLength))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; no auth headers found");
        goto exit;
    }

    (*m_pfnCloseHandle)(hRequest);
    hRequest = NULL;
    (*m_pfnCloseHandle)(hConnect);
    hConnect = NULL;
    
    fRet = TRUE;

exit:
    if (hRequest)
    {
        (*m_pfnCloseHandle)(hRequest);
        hRequest = NULL;
    }

    if (hConnect)
    {
        (*m_pfnCloseHandle)(hConnect);
        hConnect = NULL;
    }

    return fRet;
}
#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\passport\logon.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    logon.h

Abstract:

    This interface abstracts a Passport Logon Session.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef LOGON_H
#define LOGON_H

class SESSION;

class LOGON
{
public:
    LOGON(SESSION*, DWORD dwParentFlags);
    virtual ~LOGON(void);

    BOOL Open(PCWSTR pwszPartnerInfo);
    void Close(void);

    BOOL SetCredentials(
        PCWSTR pwszRealm,
        PCWSTR pwszTarget,
        PCWSTR pwszSignIn,
        PCWSTR pwszPassword
        );

    BOOL GetLogonHost(
    	PWSTR       pwszHostName,
    	OUT PDWORD  pdwHostNameLen
        ) const;

    DWORD Logon(void);

    BOOL GetChallengeInfo(
		HBITMAP**		 ppBitmap,
        PBOOL            pfPrompt,
    	PWSTR			 pwszCbText,
        PDWORD           pdwTextLen,
        PWSTR            pwszRealm,
        DWORD            dwMaxRealmLen
        ) const;

    BOOL GetAuthorizationInfo(
        PWSTR   pwszTicket,       // e.g. "from-PP = ..."
        PDWORD  pdwTicketLen,
        PBOOL   pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
        PWSTR   pwszUrl,    // user supplied buffer ...
        PDWORD  pdwUrlLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        ) const;

    VOID StatusCallback(
        IN HINTERNET hInternet,
        IN DWORD dwInternetStatus,
        IN LPVOID lpvStatusInformation,
        IN DWORD dwStatusInformationLength);

protected:
    void GetCachedCreds(
        PCWSTR	pwszRealm,
        PCWSTR  pwszTarget,
        PCREDENTIALW** pppCreds,
        DWORD* pdwCreds
        );

    BOOL DownLoadCoBrandBitmap(
        PWSTR pwszChallenge
        );

    DWORD Handle401FromDA(
        HINTERNET   hRequest, 
        BOOL        fTicketRequest
        );

    DWORD Handle200FromDA(
        HINTERNET hRequest
        );

protected:

    SESSION*    m_pSession;

    HINTERNET   m_hConnect;
    BOOL        m_fCredsPresent;
    PWSTR       m_pwszSignIn;
    PWSTR       m_pwszPassword;
    WCHAR       m_wNewDAUrl[1024];
    PWSTR       m_pwszTicketRequest;
    PWSTR       m_pwszAuthInfo;
    PWSTR		m_pwszReturnUrl;
    // PWSTR       m_pwszCbUrl;
	BOOL		m_fWhistler;
    HBITMAP*    m_pBitmap;
    BOOL        m_fPrompt;
    WCHAR       m_wRealm[128];
    WCHAR       m_wTimeSkew[16];
    PWSTR       m_pwszAuthHeader;
    DWORD       m_dwParentFlags;

    WCHAR       m_wDAHostName[256];

};

#endif // LOGON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\passport\loadgif.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\loadgif.cpp
//
//  Contents: gif decoder, copied from direct animation source: danim\src\appel\util\loadgif.cpp
//
//------------------------------------------------------------------------------------
//#include <wininetp.h>

//bw #include "headers.h"

// #define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ole2.h>
#include <math.h>


#include <windowsx.h>

/*lint ++flb*/

//bw DeclareTag(tagImageDecode, "Image Decode", "Image Decode Filters");

const long COLORKEY_NOT_SET = -1;

/*-- 
Structs from IE img.hxx 
--*/

void * __cdecl
_calloc(size_t num, size_t size)
{
    void * pv = malloc(num * size);
    if (NULL == pv)
    {
        return NULL;
    }
    ZeroMemory(pv, num * size);
    return pv;
}

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};

typedef struct _GCEDATA // data from GIF Graphic control extension
{
    unsigned int uiDelayTime;           // frame duration, initialy 1/100ths seconds
                                    // converted to milliseconds
    unsigned int uiDisposalMethod;      // 0 - none specified.
                                    // 1 - do not dispose - leave bits in place.
                                    // 2 - replace with background color.
                                    // 3 - restore previous bits
                                    // >3 - not yet defined
    BOOL                  fTransparent;         // TRUE is ucTransIndex describes transparent color
    unsigned char ucTransIndex;         // transparent index

} GCEDATA; 

typedef struct _GIFFRAME
{
    struct _GIFFRAME    *pgfNext;
    GCEDATA                             gced;           // animation parameters for frame.
    int                                 top;            // bounds relative to the GIF logical screen 
    int                                 left;
    int                                 width;
    int                                 height;
    unsigned char               *ppixels;       // pointer to image pixel data
    int                                 cColors;        // number of entries in pcolors
    PALETTEENTRY                *pcolors;
    PBITMAPINFO                 pbmi;
    HRGN                                hrgnVis;                // region describing currently visible portion of the frame
    int                                 iRgnKind;               // region type for hrgnVis
} GIFFRAME, *PGIFFRAME;

typedef struct {
    BOOL        fAnimating;                 // TRUE if animation is (still) running
    DWORD       dwLoopIter;                 // current iteration of looped animation, not actually used for Netscape compliance reasons
    _GIFFRAME * pgfDraw;                    // last frame we need to draw
    DWORD       dwNextTimeMS;               // Time to display pgfDraw->pgfNext, or next iteration
} GIFANIMATIONSTATE, *PGIFANIMATIONSTATE;

#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a        ((DWORD)89)  // GIF89a file format.

typedef struct _GIFANIMDATA
{
    BOOL                        fAnimated;                      // TRUE if cFrames and pgf define a GIF animation
    BOOL                        fLooped;                        // TRUE if we've seen a Netscape loop block
    BOOL                        fHasTransparency;       // TRUE if a frame is transparent, or if a frame does
                                        // not cover the entire logical screen.
    BOOL            fNoBWMapping;       // TRUE if we saw more than two colors in anywhere in the file.
    DWORD           dwGIFVer;           // GIF Version <see defines above> we need to special case 87a backgrounds
    unsigned short      cLoops;                         // A la Netscape, we will treat this as 
                                        // "loop forever" if it is zero.
    PGIFFRAME           pgf;                            // animation frame entries
    PALETTEENTRY        *pcolorsGlobal;         // GIF global colors - NULL after GIF prepared for screen
    PGIFFRAME       pgfLastProg;        // remember the last frame to be drawn during decoding
    DWORD           dwLastProgTimeMS;   // time at which pgfLastProg was displayed.

} GIFANIMDATA, *PGIFANIMDATA;

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long BitPixel;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct _GIFINFO
{
    IStream *stream;
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif();
      ~CImgGif();

      unsigned char * ReadGIFMaster();
      BOOL Read(unsigned char *buffer, long len);
      long ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE]);
      long DoExtension(long label);
      long GetDataBlock(unsigned char *buf);
      unsigned char * ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame);
      long readLWZ();
      long nextLWZ();
      long nextCode(long code_size);
      BOOL initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL growTables();
      BITMAPINFO * FinishDithering();

   // Data members
   public:
      LPCSTR              _szFileName;
      BOOL                _fInterleaved;
      BOOL                _fInvalidateAll;
      int                 _yLogRow;
      GIFINFO             _gifinfo;
      GIFANIMATIONSTATE   _gas;
      GIFANIMDATA         _gad;
      PALETTEENTRY        _ape[256];
      int                 _xWidth;
      int                 _yHeight;
      LONG                _lTrans;
      BYTE *              _pbBits;

} GIFIMAGE;


CImgGif::CImgGif() {
   _gifinfo.pstack = NULL;
   _gifinfo.table[0] = NULL;
   _gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() {
   free(_gifinfo.pstack);
   free(_gifinfo.table[0]);
   free(_gifinfo.table[1]);
   PGIFFRAME nextPgf, curPgf;
   curPgf = _gad.pgf;
   while(curPgf != NULL) {
      nextPgf = curPgf->pgfNext;
      free(curPgf->ppixels);
      free(curPgf->pcolors);
      free(curPgf->pbmi);
      free(curPgf);
      curPgf = nextPgf;
   }
}

static int GetColorMode() { return 0; };

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, long len)
{
   DWORD lenout = 0;
   /* read len characters into buffer */
   _gifinfo.stream->Read(buffer,len,&lenout);

   return ((long)lenout == len);
}

long CImgGif::ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE])
{
        long i;
        unsigned char rgb[3];

        for (i = 0; i < number; ++i)
        {
                if (!Read(rgb, sizeof(rgb)))
                {
                        //bw //bw TraceTag((tagImageDecode, "bad gif colormap."));
                        return (TRUE);
                }
                buffer[CM_RED][i] = rgb[0];
                buffer[CM_GREEN][i] = rgb[1];
                buffer[CM_BLUE][i] = rgb[2];
        }
        return FALSE;
}

long
CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
          return -1;
   }
   _gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
          return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2

BOOL CImgGif::initLWZ(long input_code_size)
{
   if(input_code_size < MINIMUM_CODE_SIZE)
     return FALSE;

   _gifinfo.set_code_size = input_code_size;
   _gifinfo.code_size = _gifinfo.set_code_size + 1;
   _gifinfo.clear_code = 1 << _gifinfo.set_code_size;
   _gifinfo.end_code = _gifinfo.clear_code + 1;
   _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
   _gifinfo.max_code = _gifinfo.clear_code + 2;

   _gifinfo.curbit = _gifinfo.lastbit = 0;
   _gifinfo.last_byte = 2;
   _gifinfo.get_done = FALSE;

   _gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        _gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        _gifinfo.stacksize = MIN_STACK_SIZE;

        if ( _gifinfo.pstack != NULL )
                free( _gifinfo.pstack );
        if ( _gifinfo.table[0] != NULL  )
                free( _gifinfo.table[0] );
        if ( _gifinfo.table[1] != NULL  )
                free( _gifinfo.table[1] );

 
    _gifinfo.table[0] = 0;
    _gifinfo.table[1] = 0;
    _gifinfo.pstack = 0;

    _gifinfo.pstack = (unsigned short *) malloc((_gifinfo.stacksize)*sizeof(unsigned short));
    if(_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    _gifinfo.sp = _gifinfo.pstack;

    // Initialize the two tables.
    _gifinfo.tablesize = (_gifinfo.max_code_size);

    _gifinfo.table[0] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    _gifinfo.table[1] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    if((_gifinfo.table[0] == 0) || (_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(_gifinfo.pstack){
        free(_gifinfo.pstack);
        _gifinfo.pstack = 0;
    }

    if(_gifinfo.table[0]){
        free(_gifinfo.table[0]);
        _gifinfo.table[0] = 0;
    }

    if(_gifinfo.table[1]){
        free(_gifinfo.table[1]);
        _gifinfo.table[1] = 0;
    }

    return FALSE;
}

long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &_gifinfo.buf[0];

   if (_gifinfo.return_clear)
   {
          _gifinfo.return_clear = FALSE;
          return _gifinfo.clear_code;
   }

   end = _gifinfo.curbit + code_size;

   if (end >= _gifinfo.lastbit)
   {
          long count;

          if (_gifinfo.get_done)
          {
                  return -1;
          }
          buf[0] = buf[_gifinfo.last_byte - 2];
          buf[1] = buf[_gifinfo.last_byte - 1];

          if ((count = GetDataBlock(&buf[2])) == 0)
                  _gifinfo.get_done = TRUE;
          if (count < 0)
          {
                  return -1;
          }
          _gifinfo.last_byte = 2 + count;
          _gifinfo.curbit = (_gifinfo.curbit - _gifinfo.lastbit) + 16;
          _gifinfo.lastbit = (2 + count) * 8;

          end = _gifinfo.curbit + code_size;

   // Okay, bug 30784 time. It's possible that we only got 1
   // measly byte in the last data block. Rare, but it does happen.
   // In that case, the additional byte may still not supply us with
   // enough bits for the next code, so, as Mars Needs Women, IE
   // Needs Data.
   if ( end >= _gifinfo.lastbit && !_gifinfo.get_done )
   {
      // protect ourselve from the ( theoretically impossible )
      // case where between the last data block, the 2 bytes from
      // the block preceding that, and the potential 0xFF bytes in
      // the next block, we overflow the buffer.
      // Since count should always be 1,
      //bw Assert ( count == 1 );
      // there should be enough room in the buffer, so long as someone
      // doesn't shrink it.
      if ( count + 0x101 >= sizeof( _gifinfo.buf ) )
      {
          //bw Assert ( FALSE ); // 
          return -1;
      }

              if ((count = GetDataBlock(&buf[2 + count])) == 0)
                      _gifinfo.get_done = TRUE;
              if (count < 0)
              {
                      return -1;
              }
              _gifinfo.last_byte += count;
              _gifinfo.lastbit = _gifinfo.last_byte * 8;

              end = _gifinfo.curbit + code_size;
   }
   }

   j = end / 8;
   i = _gifinfo.curbit / 8;

   if (i == j)
          ret = buf[i];
   else if (i + 1 == j)
          ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
          ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (_gifinfo.curbit % 8)) & maskTbl[code_size];

   _gifinfo.curbit += code_size;

        return ret;
}

// Grows the stack and returns the top of the stack.
unsigned short *
CImgGif::growStack()
{
    long index;
    unsigned short *lp;
    
        if (_gifinfo.stacksize >= MAX_STACK_SIZE) return 0;

	index = long(_gifinfo.sp - _gifinfo.pstack);
    lp = (unsigned short *)realloc(_gifinfo.pstack, (_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(lp == 0)
        return 0;
        
    _gifinfo.pstack = lp;
    _gifinfo.sp = &(_gifinfo.pstack[index]);
    _gifinfo.stacksize = (_gifinfo.stacksize)*2;
    lp = &(_gifinfo.pstack[_gifinfo.stacksize]);
    return lp;
}

BOOL
CImgGif::growTables()
{
    unsigned short *lp;

    lp = (unsigned short *) realloc(_gifinfo.table[0], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[0] = lp;
    
    lp = (unsigned short *) realloc(_gifinfo.table[1], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[1] = lp;

    return TRUE;

}

inline
long CImgGif::readLWZ()
{
   return((_gifinfo.sp > _gifinfo.pstack) ? *--(_gifinfo.sp) : nextLWZ());
}

#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
        long code, incode;
        unsigned short usi;
        unsigned short *table0 = _gifinfo.table[0];
        unsigned short *table1 = _gifinfo.table[1];
        unsigned short *pstacktop = &(_gifinfo.pstack[_gifinfo.stacksize]);

        while ((code = nextCode(_gifinfo.code_size)) >= 0)
        {
                if (code == _gifinfo.clear_code)
                {
                        /* corrupt GIFs can make this happen */
                        if (_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
                        {
                                return -2;
                        }

                
                        _gifinfo.code_size = _gifinfo.set_code_size + 1;
                        _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
                        _gifinfo.max_code = _gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                        
            table0 = _gifinfo.table[0];
            table1 = _gifinfo.table[1];

                        _gifinfo.tablesize = _gifinfo.max_code_size;


                        for (usi = 0; usi < _gifinfo.clear_code; ++usi)
                        {
                                table1[usi] = usi;
                        }
                        memset(table0,0,sizeof(unsigned short )*(_gifinfo.tablesize));
                        memset(&table1[_gifinfo.clear_code],0,sizeof(unsigned short)*((_gifinfo.tablesize)-_gifinfo.clear_code));
                        _gifinfo.sp = _gifinfo.pstack;
                        do
                        {
                                _gifinfo.firstcode = _gifinfo.oldcode = nextCode(_gifinfo.code_size);
                        }
                        while (_gifinfo.firstcode == _gifinfo.clear_code);

                        return _gifinfo.firstcode;
                }
                if (code == _gifinfo.end_code)
                {
                        long count;
                        unsigned char buf[260];

                        if (_gifinfo.ZeroDataBlock)
                        {
                                return -2;
                        }

                        while ((count = GetDataBlock(buf)) > 0)
                                ;

                        if (count != 0)
                        return -2;
                }

                incode = code;

                if (code >= _gifinfo.max_code)
                {
            if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (_gifinfo.firstcode));
                        code = _gifinfo.oldcode;
                }

#if FEATURE_FAST
                // (andyp) easy speedup here for ie3.1 (too late for ie3.0):
                //
                // 1. move growStack code out of loop (use max 12-bit/4k slop).
                // 2. do "sp = _gifinfo.sp" so it will get enreg'ed.
                // 3. un-inline growStack (and growTables).
                // 4. change short's to int's (benefits win32) (esp. table1 & table2)
                // (n.b. int not long, so we'll keep win3.1 perf)
                // 5. change long's to int's (benefits win16) (esp. code).
                //
                // together these will make the loop very tight w/ everything kept
                // enregistered and no 66 overrides.
                //
                // one caveat is that on average this loop iterates 4x so it's
                // not clear how much the speedup will really gain us until we
                // look at the outer loop as well.
#endif
                while (code >= _gifinfo.clear_code)
                {
                        if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = table1[code];
                        if (code == (long)(table0[code]))
                        {
                                return (code);
                        }
                        code = (long)(table0[code]);
                }

        if (_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }
                _gifinfo.firstcode = (long)table1[code];
        *(_gifinfo.sp)++ = table1[code];

                if ((code = _gifinfo.max_code) < (1 << MAX_LWZ_BITS))
                {
                        table0[code] = (USHORT)(_gifinfo.oldcode) & CODE_MASK;
                        table1[code] = (USHORT)(_gifinfo.firstcode) & CODE_MASK;
                        ++_gifinfo.max_code;
                        if ((_gifinfo.max_code >= _gifinfo.max_code_size) && (_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
                        {
                                _gifinfo.max_code_size *= 2;
                                ++_gifinfo.code_size;
                                if(!growTables())
                                    return -2;
       
                table0 = _gifinfo.table[0];
                table1 = _gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                memset(&(table1[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                _gifinfo.tablesize = (_gifinfo.max_code_size);


                        }
                }

                _gifinfo.oldcode = incode;

                if (_gifinfo.sp > _gifinfo.pstack)
                        return ((long)(*--(_gifinfo.sp)));
        }
        return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

unsigned char *
CImgGif::ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame)
{
    unsigned char *dp, c;
    long v;
    long xpos = 0, ypos = 0, pass = 0;
    unsigned char *image;
    long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks ( up to terminator ) into
    //ULONG ulCoversImg = IMGBITS_PARTIAL;

    /*
       **  Initialize the Compression routines
     */
    if (!Read(&c, 1))
    {
        return (NULL);
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
     */

     cbImage = padlen * height * sizeof(char);

     if (   cbImage > dwMaxGIFBits
        ||  (image = (unsigned char *) _calloc(1, cbImage)) == NULL)
    {
         //bw TraceTag((tagImageDecode, "Cannot allocate space for gif image data\n"));
         return (NULL);
    }

        if (c == 1)
        {
                // Netscape seems to field these bogus GIFs by filling treating them
                // as transparent. While not the optimal way to simulate this effect,
                // we'll fake it by pushing the initial code size up to a safe value,
                // consuming the input, and returning a buffer full of the transparent
                // color or zero, if no transparency is indicated.
                if (initLWZ(MINIMUM_CODE_SIZE))
                        while (readLWZ() >= 0);
                else {
          //bw TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
          return (NULL);
        }

                if (_gifinfo.Gif89.transparent != -1)
						FillMemory(image, cbImage, (BYTE)_gifinfo.Gif89.transparent);
                else // fall back on the background color 
                        FillMemory(image, cbImage, 0);
                
                return image;
        }
        else if (initLWZ(c) == FALSE)
        {
                free(image);
        //bw TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
        return NULL;
        }

    if (!fGIFFrame)
        _pbBits = image;

    if (fInterlace)
    {
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            _fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
//              message("readimage, logical=%d, offset=%d\n", i, padlen * ((height-1) - ypos));
            dp = &image[padlen * ((height-1) - ypos)];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
                /*if (!fGIFFrame && pass == 1)
                {
                    ulCoversImg = IMGBITS_TOTAL;
                }*/
            }
            if (!fGIFFrame)
            {
                _yLogRow = i;

                /*if ((i & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/

        if (!fGIFFrame && height <= 4)
        {
            _yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            _yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &image[padlen * ypos];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            if (!fGIFFrame)
            {
                _yLogRow++;
//                  message("readimage, logical=%d, offset=%d\n", _yLogRow, padlen * ypos);
                /*if ((_yLogRow & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/
    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0)
                                ;
    return (image);

abort:
    /*if (!fGIFFrame)
        OnProg(TRUE, ulCoversImg);*/
    return NULL;
}

long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                    if ( count >= 3 )
                    {
                        _gad.fLooped = TRUE;
                        _gad.cLoops = (buf[2] << 8) | buf[1];
                    }
                }
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                //bw TraceTag((tagImageDecode, "GIF comment: %s\n", buf));                
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                _gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                _gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                _gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0)
                    _gifinfo.Gif89.transparent = buf[3];
                else
                    _gifinfo.Gif89.transparent = -1;
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
        default:
            break;
    }

    while (GetDataBlock((unsigned char *) buf) > 0)
        ;

    return FALSE;
}

BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}


PBITMAPINFO x_8BPIBitmap(int xsize, int ysize)
{
        PBITMAPINFO pbmi;

        if (GetColorMode() == 8)
        {
                pbmi = (PBITMAPINFO) _calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(WORD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        else
        {
                pbmi = (PBITMAPINFO) _calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        return pbmi;
}

/*
    For color images.
        This routine should only be used when drawing to an 8 bit palette screen.
        It always creates a DIB in DIB_PAL_COLORS format.
*/
PBITMAPINFO BIT_Make_DIB_PAL_Header(int xsize, int ysize)
{
        int i;
        PBITMAPINFO pbmi;
        WORD *pw;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        pw = (WORD *) pbmi->bmiColors;

        for (i = 0; i < 256; i++)
        {
                pw[i] = (WORD)i;
        }

        return pbmi;
}

/*
    For color images.
        This routine is used when drawing to the nonpalette screens.  It always creates
        DIBs in DIB_RGB_COLORS format.
        If there is a transparent color, it is modified in the palette to be the
        background color for the window.
*/
PBITMAPINFO BIT_Make_DIB_RGB_Header_Screen(int xsize, int ysize,
                                           int cEntries, PALETTEENTRY * rgpe, int transparent)
{
        int i;
        PBITMAPINFO pbmi;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        for (i = 0; i < cEntries; i++)
        {
                pbmi->bmiColors[i].rgbRed = rgpe[i].peRed;
                pbmi->bmiColors[i].rgbGreen = rgpe[i].peGreen;
                pbmi->bmiColors[i].rgbBlue = rgpe[i].peBlue;
                pbmi->bmiColors[i].rgbReserved = 0;
        }

/*
        if (transparent != -1)
        {
                COLORREF color;

                color = PREF_GetBackgroundColor();
                pbmi->bmiColors[transparent].rgbRed     = GetRValue(color);
                pbmi->bmiColors[transparent].rgbGreen   = GetGValue(color);
                pbmi->bmiColors[transparent].rgbBlue    = GetBValue(color);
        }
*/
        return pbmi;
}

unsigned char *
CImgGif::ReadGIFMaster()
{
    HRESULT hr = S_OK;
    unsigned char buf[16];
    unsigned char c;
    unsigned char localColorMap[3][MAXCOLORMAPSIZE];
    long useGlobalColormap;
    long imageCount = 0;
    long imageNumber = 1;
    unsigned char *image = NULL;
    unsigned long i;
    GIFSCREEN GifScreen;
    long bitPixel;
    PGIFFRAME pgfLast = NULL;
    PGIFFRAME pgfNew;
    
    _gifinfo.ZeroDataBlock = 0;
    
    /*
    * Initialize GIF89 extensions
    */
    _gifinfo.Gif89.transparent = -1;
    _gifinfo.Gif89.delayTime = 5;
    _gifinfo.Gif89.inputFlag = -1;
    _gifinfo.Gif89.disposal = 0;
    _gifinfo.lGifLoc = 0;
    
    // initialize our animation fields
    _gad.fAnimated = FALSE;          // set to TRUE if we see more than one image
    _gad.fLooped = FALSE;                    // TRUE if we've seen a Netscape loop block
    _gad.fHasTransparency = FALSE; // until proven otherwise
    _gad.fNoBWMapping = FALSE;
    _gad.dwGIFVer = dwGIFVerUnknown;
    _gad.cLoops = 0;                
    _gad.pgf = NULL;
    _gad.pcolorsGlobal = NULL;
    
    if (!Read(buf, 6))
    {
        //bw TraceTag((tagImageDecode, "GIF: error reading magic number\n"));
        hr = E_FAIL;
        goto done;  
    }
    
    if (!IsGifHdr(buf)) {
        //bw TraceTag((tagImageDecode, "GIF: Malformed header\n"));
        hr = E_FAIL;
        goto done;
    }
    
    _gad.dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;
    
    if (!Read(buf, 7))
    {
        //bw TraceTag((tagImageDecode, "GIF: failed to read screen descriptor\n"));
        hr = E_FAIL;
        goto done;
    }
    
    GifScreen.Width = LM_to_uint(buf[0], buf[1]);
    GifScreen.Height = LM_to_uint(buf[2], buf[3]);
    GifScreen.BitPixel = 2 << (buf[4] & 0x07);
    GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
    GifScreen.Background = buf[5];
    GifScreen.AspectRatio = buf[6];
    
    if (BitSet(buf[4], LOCALCOLORMAP))
    {                                                       /* Global Colormap */
        int scale = 65536 / MAXCOLORMAPSIZE;
        
        if (ReadColorMap(GifScreen.BitPixel, GifScreen.ColorMap))
        {
            //bw TraceTag((tagImageDecode, "error reading global colormap\n"));
            hr = E_FAIL;
            goto done;
        }
        for (i = 0; i < GifScreen.BitPixel; i++)
        {
            int tmp;
            
            tmp = (BYTE) (GifScreen.ColorMap[0][i]);
            _ape[i].peRed = (BYTE) (GifScreen.ColorMap[0][i]);
            _ape[i].peGreen = (BYTE) (GifScreen.ColorMap[1][i]);
            _ape[i].peBlue = (BYTE) (GifScreen.ColorMap[2][i]);
            _ape[i].peFlags = (BYTE) 0;
        }
        for (i = GifScreen.BitPixel; i < MAXCOLORMAPSIZE; i++)
        {
            _ape[i].peRed = (BYTE) 0;
            _ape[i].peGreen = (BYTE) 0;
            _ape[i].peBlue = (BYTE) 0;
            _ape[i].peFlags = (BYTE) 0;
        }
    }
    
    if (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49)
    {
        float r;
        r = ((float) (GifScreen.AspectRatio) + (float) 15.0) / (float) 64.0;
        //bw TraceTag((tagImageDecode, "Warning: non-square pixels!\n"));
    }
    
    for (;; ) // our appetite now knows no bounds save termination or error
    {
        if (!Read(&c, 1))
        {
            //bw TraceTag((tagImageDecode, "EOF / read error on image data\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if (c == ';')
        {                                               /* GIF terminator */
            if (imageCount < imageNumber)
            {
                //bw TraceTag((tagImageDecode, "No images found in file\n"));
                hr = E_FAIL;
                goto done;
            }
            break;
        }
        
        if (c == '!')
        {                                               /* Extension */
            if (!Read(&c, 1))
            {
                //bw TraceTag((tagImageDecode, "EOF / read error on extension function code\n"));
                hr = E_FAIL;
                goto done;
            }
            DoExtension(c);
            continue;
        }
        
        if (c != ',')
        {                                               /* Not a valid start character */
            break;
        }
        
        ++imageCount;
        
        if (!Read(buf, 9))
        {
            //bw TraceTag((tagImageDecode, "couldn't read left/top/width/height\n"));
            hr = E_FAIL;
            goto done;
        }
        
        useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);
        
        bitPixel = 1 << ((buf[8] & 0x07) + 1);
        
        /*
        * We only want to set width and height for the imageNumber
        * we are requesting.
        */
        if (imageCount == imageNumber)
        {
            // Replicate some of Netscape's special cases:
            // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
            // Don't use the logical screen if the first image spills out of the logical screen.
            // These are artifacts of primitive authoring tools falling into the hands of hapless users.
            RECT    rectImage;  // rect defining bounds of GIF
            RECT    rectLS;     // rect defining bounds of GIF logical screen.
            RECT    rectSect;   // intersection of image an logical screen
            BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
            BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases
            
            rectImage.left = LM_to_uint(buf[0], buf[1]);
            rectImage.top = LM_to_uint(buf[2], buf[3]);
            rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
            rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);
            rectLS.left = rectLS.top = 0;
            rectLS.right = GifScreen.Width;
            rectLS.bottom = GifScreen.Height;
            IntersectRect( &rectSect, &rectImage, &rectLS );
            fNoSpill = EqualRect( &rectImage, &rectSect );
            fGoofy87a = FALSE;
            if (_gad.dwGIFVer == dwGIFVer87a)
            {
                // netscape ignores the logical screen if the image is flush against
                // either the upper left or lower right corner
                fGoofy87a = (rectImage.top == 0 && rectImage.left == 0) ||
                    (rectImage.bottom == rectLS.bottom &&
                    rectImage.right == rectLS.right);
            }   
            
            if (!fGoofy87a && fNoSpill)
            {
                _xWidth = GifScreen.Width;  
                _yHeight = GifScreen.Height;
            }
            else
            {
                // Something is amiss. Fall back to the image's dimensions.
                
                // If the sizes match, but the image is offset, or we're ignoring
                // the logical screen cuz it's a goofy 87a, then pull it back to 
                // to the origin
                if ((LM_to_uint(buf[4], buf[5]) == GifScreen.Width &&
                    LM_to_uint(buf[6], buf[7]) == GifScreen.Height) ||
                    fGoofy87a)
                {
                    buf[0] = buf[1] = 0; // left corner to zero
                    buf[2] = buf[3] = 0; // top to zero.
                }
                
                _xWidth = LM_to_uint(buf[4], buf[5]);
                _yHeight = LM_to_uint(buf[6], buf[7]);
            }
            
            _lTrans = _gifinfo.Gif89.transparent;
            
            // Post WHKNOWN
            //OnSize(_xWidth, _yHeight, _lTrans);
        }
        
        if (!useGlobalColormap)
        {
            if (ReadColorMap(bitPixel, localColorMap))
            {
                //bw TraceTag((tagImageDecode, "error reading local colormap\n"));
                hr = E_FAIL;
                goto done;
            }
        }
        
        // We allocate a frame record for each imag in the GIF stream, including
        // the first/primary image.
        pgfNew = (PGIFFRAME) _calloc(1, sizeof(GIFFRAME));
        
        if ( pgfNew == NULL )
        {
            //bw TraceTag((tagImageDecode, "not enough memory for GIF frame\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if ( _gifinfo.Gif89.delayTime != -1 )
        {
            // we have a fresh control extension for this block
            
            // convert to milliseconds
            pgfNew->gced.uiDelayTime = _gifinfo.Gif89.delayTime * 10;
            
            
            //REVIEW(seanf): crude hack to cope with 'degenerate animations' whose timing is set to some
            //                               small value becaue of the delays imposed by Netscape's animation process
            if ( pgfNew->gced.uiDelayTime <= 50 ) // assume these small values imply Netscape encoding delay
                pgfNew->gced.uiDelayTime = 100;   // pick a larger value s.t. the frame will be visible
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
            
        }
        else
        {   // fake one up s.t. GIFs that rely solely on Netscape's delay to time their animations will play
            // The spec says that the scope of one of these blocks is the image after the block.
            // Netscape says 'until further notice'. So we play it their way up to a point. We
            // propagate the disposal method and transparency. Since Netscape doesn't honor the timing
            // we use our default timing for these images.
            pgfNew->gced.uiDelayTime = 100;
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
        }
        
        pgfNew->top = LM_to_uint(buf[2], buf[3]);               // bounds relative to the GIF logical screen 
        pgfNew->left = LM_to_uint(buf[0], buf[1]);
        pgfNew->width = LM_to_uint(buf[4], buf[5]);
        pgfNew->height = LM_to_uint(buf[6], buf[7]);
        
        // Images that are offset, or do not cover the full logical screen are 'transparent' in the
        // sense that they require us to matte the frame onto the background.
        
        if (!_gad.fHasTransparency && (pgfNew->gced.fTransparent ||
            pgfNew->top != 0 ||
            pgfNew->left != 0 ||
            (UINT)pgfNew->width != (UINT)GifScreen.Width ||
            (UINT)pgfNew->height != (UINT)GifScreen.Height))
        {
            _gad.fHasTransparency = TRUE;
            //if (_lTrans == -1)
            //    OnTrans(0);
        }
        
        // We don't need to allocate a handle for the simple region case.
        // FrancisH says Windows is too much of a cheapskate to allow us the simplicity
        // of allocating the region once and modifying as needed. Well, okay, he didn't
        // put it that way...
        pgfNew->hrgnVis = NULL;
        pgfNew->iRgnKind = NULLREGION;
        
        if (!useGlobalColormap)
        {
            // remember that we saw a local color table and only map two-color images
            // if we have a homogenous color environment
            _gad.fNoBWMapping = _gad.fNoBWMapping || bitPixel > 2;
            
            // CALLOC will set unused colors to <0,0,0,0>
            pgfNew->pcolors = (PALETTEENTRY *) _calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
            if ( pgfNew->pcolors == NULL )
            {
                DeleteRgn( pgfNew->hrgnVis );
                free( pgfNew );
                
                //bw TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                hr = E_FAIL;
                goto done;
            }
            else
            {
                for (i = 0; i < (ULONG)bitPixel; ++i)
                {
                    pgfNew->pcolors[i].peRed = localColorMap[CM_RED][i];
                    pgfNew->pcolors[i].peGreen = localColorMap[CM_GREEN][i];
                    pgfNew->pcolors[i].peBlue = localColorMap[CM_BLUE][i];
                }
                pgfNew->cColors = bitPixel;
            }
        }
        else
        {
            if ( _gad.pcolorsGlobal == NULL )
            { // Whoa! Somebody's interested in the global color table
                // CALLOC will set unused colors to <0,0,0,0>
                _gad.pcolorsGlobal = (PALETTEENTRY *) _calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
                _gad.fNoBWMapping = _gad.fNoBWMapping || GifScreen.BitPixel > 2;
                if ( _gad.pcolorsGlobal != NULL )
                {
                    CopyMemory(_gad.pcolorsGlobal, _ape,
                        GifScreen.BitPixel * sizeof(PALETTEENTRY) );
                }
                else
                {
                    DeleteRgn( pgfNew->hrgnVis );
                    free( pgfNew );
                    //bw TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                    hr = E_FAIL;
                    goto done;  
                }
            }
            pgfNew->cColors = GifScreen.BitPixel;
            pgfNew->pcolors = _gad.pcolorsGlobal;
        }
        
        // Get this in here so that GifStrectchDIBits can use it during progressive
        // rendering.
        if ( _gad.pgf == NULL )
            _gad.pgf = pgfNew;
        
        pgfNew->ppixels = ReadImage(LM_to_uint(buf[4], buf[5]), // width
            LM_to_uint(buf[6], buf[7]), // height
            BitSet(buf[8], INTERLACE),
            imageCount != imageNumber);
        
        if ( pgfNew->ppixels != NULL )
        {
            // Oh JOY of JOYS! We got the pixels!
            if (pgfLast != NULL)
            {
                int transparent = (pgfNew->gced.fTransparent) ? (int) pgfNew->gced.ucTransIndex : -1;
                
                _gad.fAnimated = TRUE; // say multi-image == animated
                
                if (GetColorMode() == 8) // palettized, use DIB_PAL_COLORS
                {   // This will also dither the bits to the screen palette
                    
                    pgfNew->pbmi = BIT_Make_DIB_PAL_Header(pgfNew->width, pgfNew->height);
                    //if (x_Dither(pgfNew->ppixels, pgfNew->pcolors, pgfNew->width, pgfNew->height, transparent))
                    //    goto exitPoint;
                }
                else // give it an RGB header
                {
                    pgfNew->pbmi = BIT_Make_DIB_RGB_Header_Screen(
                        pgfNew->width,
                        pgfNew->height,
                        pgfNew->cColors, pgfNew->pcolors,
                        transparent);
                }
                
                // Okay, so we've done any mapping on the GIFFRAME, so there's
                // no need to keep the pcolors around.  Let's go can clear out
                // the pcolors.
                // REVIEW(seanf): This assumes a common palette is used by all
                // clients of the image
                if ( pgfNew->pcolors != NULL && pgfNew->pcolors != _gad.pcolorsGlobal )
                    free( pgfNew->pcolors );
                pgfNew->pcolors = NULL;
                
                pgfLast->pgfNext = pgfNew;
                
                // Do something to here to get the new frame on the screen.
                
                _fInvalidateAll = TRUE;
                //super::OnProg(FALSE, IMGBITS_TOTAL);
            }
            else
            { // first frame
                _gad.pgf = pgfNew;
                
                _gad.pgfLastProg = pgfNew;
                _gad.dwLastProgTimeMS = 0;
                // set up a temporary animation state for use in progressive draw
                _gas.fAnimating = TRUE; 
                _gas.dwLoopIter = 0;
                _gas.pgfDraw = pgfNew;
                
                if ( imageCount == imageNumber )
                    image = pgfNew->ppixels;
            }
            pgfLast = pgfNew;
        }
        
        // make the _gifinfo.Gif89.delayTime stale, so we know if we got a new
        // GCE for the next image
        _gifinfo.Gif89.delayTime = -1;
        
        }
        
        if ( imageCount > imageNumber )
            _gad.fAnimated = TRUE; // say multi-image == animated
        
#ifdef FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        // RAID #23709 - If an animation is sufficiently long, we treat it as indefinite...
        // Indefinite stays indefinite.
        // 5/29/96 - JCordell sez we shouldn't introduce this gratuitous NS incompatibility.
        //           We'll keep it around inside this ifdef in case we decide we want it.
        if ( _gad.fLooped &&
            (_gad.dwLoopDurMS * _gad.cLoops) / 1000 > dwIndefiniteGIFThreshold ) // if longer than five minutes
            _gad.cLoops = 0; // set to indefinite looping.
#endif // FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        
done:
        return image;
}

BITMAPINFO *
CImgGif::FinishDithering()
{
    BITMAPINFO * pbmi;
    
    if (GetColorMode() == 8)
    {
        pbmi = BIT_Make_DIB_PAL_Header(_gad.pgf->width, _gad.pgf->height);
    }
    else
    {
        pbmi = BIT_Make_DIB_RGB_Header_Screen(_gad.pgf->width, _gad.pgf->height,
            _gad.pgf->cColors, _gad.pgf->pcolors, _lTrans);
    }
    
    return pbmi;
}

//#include <vector>
//#define vector std::vector

//+-----------------------------------------------------------------------
//
//  Member:    LoadGifImage
//
//  Overview:  Given an IStream, decode an image into an array of bitmaps
//
//  Arguments: pStream      data source
//             colorKeys    pointer to where to store colorKey data
//             numBitmaps   where to store number of bitmaps
//             delays       where to store delay array
//             loop         where to store number of times to loop
//             ppBitMaps    where to store bitmaps
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
LoadGifImage(IStream *stream,                       
             COLORREF **colorKeys,
             int *numBitmaps,
             int **delays,
             double *loop,
             HBITMAP **ppBitMaps)
{
    HRESULT hr = S_OK;
   /* 
      The odd approach here lets us keep the original IE GIF code unchanged while removing
      DA specific inserts (except error reporting). The progressive rendering and palette 
      dithering found in the IE code is also not supported yet.
   */
   CImgGif gifimage;
   gifimage._szFileName = NULL;
   gifimage._gifinfo.stream = stream;
   BYTE *pbBits = gifimage.ReadGIFMaster();

   if (pbBits) {
      gifimage._pbBits = pbBits;
      gifimage._gad.pgf->pbmi = gifimage.FinishDithering(); 
   }

   /*
      Extract information from GIF decoder, and format it into an array of bitmaps.
   */
   *delays = NULL;
   /*vector<>*/HBITMAP vhbmp;
   /*vector<>*/COLORREF vcolorKey;
   /*vector<>*/int vdelay;
   LPVOID  image = NULL;
   LPVOID  lastBits = pbBits;
   LPVOID  bitsBeforeLastBits = NULL;
   HBITMAP *hImage = NULL;
   PBITMAPINFO pbmi = NULL;
   HBITMAP hbm;
   PGIFFRAME pgf = gifimage._gad.pgf;
   PGIFFRAME pgfOld = NULL;
   bool fUseOffset = false; 
   bool fFirstFrame = true;
   long pgfWidth,pgfHeight,     // animation frame dims
        fullWidth,fullHeight,   // main frame dims
        fullPad, pgfPad,        // row padding vals
        fullSize, pgfSize;
   unsigned int disp = 0;
    int i = 0;

   // TODO: Dither global palette to display palette

   fullWidth = gifimage._xWidth;
   fullHeight = gifimage._yHeight;
   fullPad = (((fullWidth + 3) / 4) * 4) - fullWidth;  
   fullSize = (fullPad+fullWidth)*fullHeight; 
    
   if (NULL == pgf)
   {
       hr = E_FAIL;
       goto done;
   }

   while(1) 
   {     
//      Assert(pgf);      
      pbmi = pgf->pbmi;
      if (pbmi == NULL)
      {
          hr = E_FAIL;
          goto done;
      }

      // TODO: It would be nice to pass local palettes up so they could
      // be mapped to system palettes.       

      // Check to see if frame is offset from logical frame      
      if(pgf->top != 0 ||
         pgf->left != 0 || 
         pgf->width != fullWidth ||
         pgf->height != fullHeight) 
      {
         fUseOffset = true;    
         pgfWidth = pbmi->bmiHeader.biWidth;    
         pgfHeight = pbmi->bmiHeader.biHeight;  
         pbmi->bmiHeader.biWidth = fullWidth;      
         pbmi->bmiHeader.biHeight = fullHeight; 
         pgfPad = (((pgfWidth + 3) / 4) * 4) - pgfWidth; 
         pgfSize = (pgfPad+pgfWidth)*pgfHeight;
      }

      hbm = CreateDIBSection(NULL, pbmi, DIB_RGB_COLORS, (LPVOID *) &image, NULL, 0);        
      if(!hbm) 
      {
          hr = E_OUTOFMEMORY;
          goto done;
      }

      // Correctly composite bitmaps based on disposal method specified        
      disp = pgf->gced.uiDisposalMethod;
      // If the frame is offset, fill it with          
      if( (disp == gifRestorePrev) && (bitsBeforeLastBits != NULL) )
         memcpy(image, bitsBeforeLastBits, fullSize);
      else if( (disp == gifRestoreBkgnd) || (disp == gifRestorePrev) || fFirstFrame ) // fill with bgColor      
         memset(image, pgf->gced.ucTransIndex, fullSize);           
      else // fill with last frames data                                              
         memcpy(image, lastBits, fullSize);      
         
      
      // For offset gifs allocate an image the size of the first frame 
      // and then fill in the bits at the offset location.        
      if(fUseOffset) {         
         for(i=0; i<pgfHeight; i++) {               
            BYTE *dst, *src;                     
            // the destination is the address of the image data plus the frame and row offset. 
            int topOffset = fullHeight - pgfHeight - pgf->top;
            dst = (BYTE*)image +                                  
                  ( ((topOffset + i) *(fullPad+fullWidth)) + pgf->left );
            // copy from the frame's nth row
            src = pgf->ppixels + i*(pgfPad+pgfWidth);                
            for(int j=0; j<pgfWidth; j++) {     
                // copy the frame row data, excluding transparent bytes    
                if(src[j] != pgf->gced.ucTransIndex)
                    dst[j] = src[j];
            }
         }
      }     
      else {
         // Overwritten accumulated bits with current bits. If the 
         // new image contains transparency we need to take it into 
         // account. Since this is slower, special case it.
         if(pgf->gced.fTransparent) {            
            for(i=0; i<((fullPad+fullWidth)*fullHeight); i++) {        
                if(pgf->ppixels[i] != pgf->gced.ucTransIndex)
                    ((BYTE*)image)[i] = ((BYTE*)pgf->ppixels)[i];
            }
         }
         else // Otherwise, just copy over the offset window's bytes
            memcpy(image, pgf->ppixels, (fullPad+fullWidth)*fullHeight);  
      }

      /* 
          If we got a transparent color extension, convert it to a COLORREF
      */
      COLORREF colorKey = COLORKEY_NOT_SET;
      if (pgf->gced.fTransparent) {      
          int transparent = pgf->gced.ucTransIndex;
          colorKey = RGB(pgf->pbmi->bmiColors[transparent].rgbRed,
                         pgf->pbmi->bmiColors[transparent].rgbGreen,
                         pgf->pbmi->bmiColors[transparent].rgbBlue);
      }

      // vcolorKey.push_back(colorKey);
      vcolorKey = colorKey;

      // biao change : vhbmp.push_back(hbm);
      vhbmp = hbm;
      
      /* 
         The delay times are frame specific and can be different, these
         should be propagated as an array to the sampling code.  
      */      
      // vdelay.push_back(pgf->gced.uiDelayTime);      
      vdelay = pgf->gced.uiDelayTime;

      bitsBeforeLastBits = lastBits;        
      lastBits = image;
      fUseOffset = false;
      if(pgf->pgfNext == NULL) 
          break;
      pgfOld = pgf;
      pgf = pgf->pgfNext;
      fFirstFrame = FALSE;      
   } 
 
   
   // The number of times to loop are also propagated.  Note we add one because 
   // all other GIF decoders appear to treat the loop as the number of times to 
   // loop AFTER the first run through the frames.
   if (gifimage._gad.cLoops == 0 && gifimage._gad.fLooped != 0)
   {
		*loop = 0; // HUGE_VAL;
   }
   else
   {
        *loop = gifimage._gad.cLoops;
   }
   
   *numBitmaps = 1;

   // Since the vector will go out of scope, move contents over to heap
   hImage  = (HBITMAP *)malloc(1 * sizeof(HBITMAP)); 
   if (NULL == hImage)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *delays = (int*)malloc(1 * sizeof(int)); 
   if (NULL == *delays)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *colorKeys = (COLORREF*)malloc( sizeof(COLORREF) * 1 ); 
   if (NULL == *colorKeys)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   for(i=0; i < 1; i++) {
      hImage[i] = vhbmp; // biao fix [i];
      (*colorKeys)[i] = vcolorKey; // [i];
      (*delays)[i] = vdelay; //[i];
   }

   *ppBitMaps = hImage;

   hr = S_OK;
done:
   if (FAILED(hr))
   {
       free(hImage);
       free(*delays);
       free(*colorKeys);
   }
   return hr;
}

/*lint --flb*/

BOOL Gif2Bmp(LPSTREAM pStream, HBITMAP** ppBmp)
{
    HRESULT hr;
	HBITMAP * phBMPs = NULL;
    int numGifs = 0;
    double loop = 0;
    int * pDelays = NULL;
    COLORREF * pColorKeys = NULL;

    hr = LoadGifImage(pStream,
                      &pColorKeys,
                      &numGifs,
                      &pDelays,
                      &loop,
                      &phBMPs);

    if (FAILED(hr))
    {
        return FALSE;
    }

    *ppBmp = phBMPs;
	
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\passport\ppdefs.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ppdefs.h

Abstract:

    Basic Passport definitions.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef PP_DEFS_H
#define PP_DEFS_H

#include <Windows.h>

#define HINTERNET PVOID
#define INTERNET_PORT WORD

#define PP_LOG_INFO	 /*Noise*/ 0x00000001
#define PP_LOG_WARNING	/*Unusual*/ 0x00000002
#define PP_LOG_ERROR	 /*Error*/ 0x00000004

#ifdef DBG
#define PP_ASSERT(fVal) if (!fVal) DebugBreak();
#else
#define PP_ASSERT(fVal)
#endif

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

 #define WPP_CONTROL_GUIDS \
     WPP_DEFINE_CONTROL_GUID(Regular,(81b20fea,73a8,4b62,95bc,354477c97a6f), \
         WPP_DEFINE_BIT(Error)      \
         WPP_DEFINE_BIT(Unusual)    \
         WPP_DEFINE_BIT(Noise)      \
    ) 
    
//
// func pointer decl for CredUI
//

//#include <credui.h>
#include <wincred.h>

typedef BOOL
(WINAPI * PFN_READ_DOMAIN_CRED_W) (
	IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
	IN DWORD Flags,
	OUT DWORD *Count,
	OUT PCREDENTIALW **Credential
	);

typedef VOID
(WINAPI * PFN_CRED_FREE)(
    IN PVOID Buffer
    );


#define DoTraceMessage

#endif // PP_DEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\passport\logon.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Logon.cpp

Abstract:


Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"
#include "passport.h"
#include "session.h"
#include "logon.h"
#include "ole2.h"
#include "wincrypt.h"

// #include "logon.tmh"

#define HTTP_STATUS_DENIED              401 // access denied
#define HTTP_STATUS_OK                  200 // request completed

#define HTTP_QUERY_FLAG_NUMBER          0x20000000
#define HTTP_QUERY_STATUS_CODE          19  // special: part of status line
#define HTTP_QUERY_AUTHENTICATION_INFO  76
#define HTTP_QUERY_WWW_AUTHENTICATE     40


// NOTE*** below we assume(!) the WinInet & WinHttp shared the same error VALUE

#define ERROR_HTTP_HEADER_NOT_FOUND     12150L
#define ERROR_INTERNET_INVALID_CA       12045L
#define INTERNET_OPTION_SECURITY_FLAGS  31

#define SECURITY_FLAG_IGNORE_REVOCATION         0x00000080
#define SECURITY_FLAG_IGNORE_UNKNOWN_CA         0x00000100
#define SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200

#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.
#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.

#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    INTERNET_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  INTERNET_FLAG_IGNORE_CERT_DATE_INVALID

#define SECURITY_SET_MASK       (SECURITY_FLAG_IGNORE_REVOCATION |\
                                 SECURITY_FLAG_IGNORE_UNKNOWN_CA |\
                                 SECURITY_FLAG_IGNORE_CERT_CN_INVALID |\
                                 SECURITY_FLAG_IGNORE_CERT_DATE_INVALID |\
                                 SECURITY_FLAG_IGNORE_WRONG_USAGE)

#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define INTERNET_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://
#define INTERNET_STATUS_REDIRECT                110

#define HTTP_ADDREQ_FLAG_ADD        0x20000000
#define HTTP_ADDREQ_FLAG_REPLACE    0x80000000

#define INTERNET_FLAG_SECURE            0x00800000  // use PCT/SSL if applicable (HTTP)


LOGON::LOGON(SESSION* pSession, DWORD dwParentFlags)
    : m_pSession(pSession)
{
    m_pSession->AddRef();

    m_hConnect = NULL;
    
    m_fCredsPresent = FALSE;
    m_pwszSignIn = NULL;
    m_pwszPassword = NULL;

    m_pwszTicketRequest = NULL;
    m_pwszAuthInfo = NULL;
    m_pwszReturnUrl = NULL;

    m_pBitmap = NULL;
    m_fPrompt = FALSE;

    m_wTimeSkew[0] = L'\0';
    m_wNewDAUrl[0] = 0;
    m_dwParentFlags = dwParentFlags;

}

LOGON::~LOGON(void)
{
    if (m_pwszAuthInfo)
    {
        delete [] m_pwszAuthInfo;
    }
    if (m_pwszSignIn)
    {
        delete [] m_pwszSignIn;
    }
    if (m_pwszPassword)
    {
        delete [] m_pwszPassword;
    }
    if (m_pwszTicketRequest)
    {
        delete [] m_pwszTicketRequest;
    }
    if (m_pwszAuthHeader)
    {
        delete [] m_pwszAuthHeader;
    }
    m_pSession->RemoveRef();
}

// -----------------------------------------------------------------------------
BOOL LOGON::Open(
    PCWSTR	pwszPartnerInfo // in the form of "WWW-Authenticate: Passport1.4 ..."
    )
{
    PP_ASSERT(pwszPartnerInfo != NULL);

    // locate the auth scheme name, i.e. Passport1.4
    
    PCWSTR pwszTicketRequest = ::wcsstr(pwszPartnerInfo, L"Passport1.4");
    if (pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; Passport1.4 scheme not found");
        return FALSE;
    }
    
    pwszTicketRequest += ::wcslen(L"Passport1.4");
    
    // skip white spaces between the scheme name and the Ticket Request (TR)

    while (*pwszTicketRequest == (L" ")[0]) { ++pwszTicketRequest; }
    
    if (pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; Ticket Request missing");
        return FALSE;
    }
    
    // save the TR
    
    DWORD dwTrLen = ::wcslen(pwszTicketRequest);
    m_pwszTicketRequest = new WCHAR[dwTrLen + 1];
    if (m_pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; not enough memory");
        return FALSE;
    }
    ::wcscpy(m_pwszTicketRequest, pwszTicketRequest);

    m_pwszAuthHeader = new WCHAR[dwTrLen + 2048/*Prepared for long creds*/ + 1]; 
    if (m_pwszAuthHeader == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; not enough memory");
        return FALSE;
    }

    DoTraceMessage(PP_LOG_INFO, "LOGON::Open() succeed");

    return TRUE;
}

void LOGON::Close(void)
{
    PP_ASSERT(m_hConnect != NULL);
    PP_ASSERT(m_pSession != NULL);

    m_pSession->CloseHandle(m_hConnect);
    m_hConnect = NULL;
}



// pClearPassword is assumed to be at least 256 chars

void DecryptPassword ( WCHAR* pClearPassword, PVOID pPassword, DWORD cbSize )
{
    BOOL bOrigEncrypted = FALSE;

    DATA_BLOB InBlob;
    DATA_BLOB OutBlob;
    LPWSTR pszDesc;

    if ( pClearPassword == NULL )
        return;

    if ( cbSize == 0 )
    {
        // CryptUnprotectData doesn't like to be sent a zero-length buffer
        pClearPassword[0] = L'\0';
        return;		
    }

    InBlob.pbData = (BYTE*)pPassword;
    InBlob.cbData = cbSize;

    if ( CryptUnprotectData ( &InBlob,
                            &pszDesc,
                            NULL,
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN,
                            &OutBlob ) )
    {

        if ( wcscmp (L"SSOCred", pszDesc) == 0 )
        {
            DWORD dwOutChars = OutBlob.cbData/sizeof(WCHAR);
            if ( dwOutChars < 256 )
            {
                wcsncpy ( pClearPassword, (WCHAR*)OutBlob.pbData, dwOutChars );
                pClearPassword[dwOutChars] = L'\0';
            }
            bOrigEncrypted = TRUE;
        }
        LocalFree ( pszDesc );
        LocalFree ( OutBlob.pbData );
    }

    if ( !bOrigEncrypted )
    {
        // copy the plain text
        wcsncpy ( pClearPassword, (WCHAR*)pPassword, 256 );
    }

    return;
}



void LOGON::GetCachedCreds(
	PCWSTR	pwszRealm,
    PCWSTR  pwszTarget,
    PCREDENTIALW** pppCreds,
    DWORD* pdwCreds
    )
{
    *pppCreds = NULL;
    *pdwCreds = 0;

    if (m_pSession->m_pfnReadDomainCred == NULL)
    {
        return;
    }

    ULONG CredTypes = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
    DWORD dwFlags = CRED_CACHE_TARGET_INFORMATION;
    CREDENTIAL_TARGET_INFORMATIONW TargetInfo;


    memset ( (void*)&TargetInfo, 0, sizeof(CREDENTIAL_TARGET_INFORMATIONW));

	TargetInfo.TargetName = const_cast<PWSTR>(pwszTarget);
    TargetInfo.DnsDomainName = const_cast<PWSTR>(pwszRealm);
	TargetInfo.PackageName = L"Passport1.4";

    TargetInfo.Flags = 0;
    TargetInfo.CredTypeCount = 1;
    TargetInfo.CredTypes = &CredTypes;

    if ((*m_pSession->m_pfnReadDomainCred)(&TargetInfo, 
                                           dwFlags,
                                           pdwCreds,
                                           pppCreds ) != TRUE)
    {
        *pppCreds = NULL;
        *pdwCreds = 0;

    }
    else
    {
        if (m_pSession->IsLoggedOut())
        {
            FILETIME LogoutTimestamp;
            ::SystemTimeToFileTime(m_pSession->GetLogoutTimeStamp(), &LogoutTimestamp);
            if (CompareFileTime(&((**pppCreds)->LastWritten), &LogoutTimestamp) == -1)
            {
                // the cred is entered/created earlier (less) than the Logout request. It is no good.

                m_pSession->m_pfnCredFree(*pppCreds);
                *pppCreds = NULL;
                *pdwCreds = 0;
            }
            else
            {
            m_pSession->ResetLogoutFlag();
            }
        }
    }


    return;
}

// -----------------------------------------------------------------------------
BOOL LOGON::SetCredentials(
	PCWSTR pwszRealm,
	PCWSTR pwszTarget,
    PCWSTR pwszSignIn,
    PCWSTR pwszPassword
    )
{
    WCHAR wPass[256];
    PCREDENTIALW* ppCred = NULL;
    DWORD dwCreds = 0;
    PCREDENTIALW pCredToUse = NULL;

    if ((!pwszSignIn) && (!pwszPassword))
    {
		GetCachedCreds(pwszRealm, pwszTarget, &ppCred, &dwCreds);

        if (dwCreds > 0 && ppCred[0] != NULL )
        {
            for ( DWORD idx = 0; idx < dwCreds; idx++ )
            {
                if ( ppCred[idx]->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )
                {
                    // check to see if prompt bit is set.   If set, keep looking, only use if
                    // the prompt bit isn't set.
                    if ( !(ppCred[idx]->Flags & CRED_FLAGS_PROMPT_NOW) )
                    {
                        pCredToUse = ppCred[idx];
                        break;
                    }
                }
            }
        }



        if (pCredToUse == NULL)
        {
            return FALSE;
        }

        DecryptPassword(wPass, 
                  PVOID(pCredToUse->CredentialBlob), 
                  pCredToUse->CredentialBlobSize);

        pwszSignIn = pCredToUse->UserName;
        pwszPassword = wPass;

    }

    if (m_pwszSignIn)
    {
        delete [] m_pwszSignIn;
    }

    DWORD dwSignInLen = ::wcslen(pwszSignIn);
    m_pwszSignIn = new WCHAR[dwSignInLen + 1];
    if (m_pwszSignIn == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; not enough memory");
        return FALSE;
    }

    ::wcscpy(m_pwszSignIn, pwszSignIn);

    if (m_pwszPassword)
    {
        delete [] m_pwszPassword;
    }

    DWORD dwPasswordLen = ::wcslen(pwszPassword);
    m_pwszPassword = new WCHAR[dwPasswordLen + 1];
    if (m_pwszPassword == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; not enough memory");
        delete [] m_pwszSignIn;
        m_pwszSignIn = NULL;
        return FALSE;
    }

    ::wcscpy(m_pwszPassword, pwszPassword);
    
    m_fCredsPresent = TRUE;

    if (ppCred)
    {
        if (m_pSession->m_pfnCredFree)
        {
            m_pSession->m_pfnCredFree(ppCred);
        }
    }

    return TRUE;
}

BOOL Gif2Bmp(LPSTREAM pStream, HBITMAP** ppBmp);
// -----------------------------------------------------------------------------
BOOL LOGON::DownLoadCoBrandBitmap(
    PWSTR pwszChallenge
    )
{
    PP_ASSERT(pwszChallenge != NULL);

    PWSTR pwszCbUrl = NULL;
    BOOL fRet = FALSE;

    WCHAR Delimiters[] = L",";
    PWSTR Token = ::wcstok(pwszChallenge, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no text in between commas");
            goto next_token;
        }

        // find cburl
        if (!::_wcsnicmp(Token, L"cburl", ::wcslen(L"cburl")))
        {
            PWSTR CbUrl = ::wcsstr(Token, L"=");
            if (CbUrl == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cburl");
                goto next_token;
            }
            
            CbUrl++; // skip "="

            while (*CbUrl == (L" ")[0]) { ++CbUrl; } // skip leading white spaces

            pwszCbUrl = new WCHAR[::wcslen(CbUrl)+1];
            if (pwszCbUrl == NULL)
            {
                DoTraceMessage(PP_LOG_ERROR, "LOGON::DownLoadCoBrandBitmap() failed; not enough memory");
                goto exit;
            }
            ::wcscpy(pwszCbUrl, CbUrl);

            DoTraceMessage(PP_LOG_INFO, "CoBrand URL %ws found", pwszCbUrl);
        }
        else if (!::_wcsnicmp(Token, L"ts", ::wcslen(L"ts")))
        {
            ::wcscpy(m_wTimeSkew, Token);
        }
        else if (!::_wcsnicmp(Token, L"srealm", ::wcslen(L"srealm")))
        {
            PWSTR pwszRealm = ::wcsstr(Token, L"=");
            if (pwszRealm == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cburl");
                goto next_token;
            }
            
            pwszRealm++; // skip "="

            while (*pwszRealm == (L" ")[0]) { ++pwszRealm; } // skip leading white spaces

            ::wcscpy(m_wRealm, pwszRealm);

            DoTraceMessage(PP_LOG_INFO, "sRealm URL %ws found", pwszCbUrl);
        }

    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

    if (pwszCbUrl)
    {
        HINTERNET hCbUrl = m_pSession->OpenUrl(pwszCbUrl, NULL, 0, 0);
        if (hCbUrl == NULL)
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "LOGON::DownLoadCoBrandBitmap() failed; can not open URL %ws",
                           pwszCbUrl);
            goto exit;
        }

        {
            BYTE bBuf[1024];
            DWORD cbBuf = sizeof(bBuf);
            DWORD cbRead = 0;
            LPSTREAM pStream;

            if (CreateStreamOnHGlobal(NULL, TRUE, &pStream) != S_OK)
            {
                DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed");
                m_pSession->CloseHandle(hCbUrl);

                goto exit;
            }

            while (m_pSession->ReadFile(hCbUrl, bBuf, cbBuf, &cbRead) && cbRead)
                pStream->Write(bBuf, cbRead, NULL);

            LARGE_INTEGER Zero = {0};
            pStream->Seek(Zero, STREAM_SEEK_SET, NULL); // seek to the beginning of the stream

            DoTraceMessage(PP_LOG_INFO, "CoBrand Graphic %ws downloaded", pwszCbUrl);
            
            if (Gif2Bmp(pStream, &m_pBitmap) == FALSE)
            {
                DoTraceMessage(PP_LOG_ERROR, "Gif2Bmp() failed");
                m_pSession->CloseHandle(hCbUrl);

                goto exit;
            }

            pStream->Release();
            m_pSession->CloseHandle(hCbUrl);

            fRet = TRUE;

            DoTraceMessage(PP_LOG_INFO, "CoBrand Bitmap created");
        }
    }

exit:
    if (pwszCbUrl)
    {
        delete [] pwszCbUrl;
    }

    return fRet;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Handle401FromDA(
    HINTERNET   hRequest, 
    BOOL        fTicketRequest
    )
{
    PP_ASSERT(hRequest != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    DWORD dwIndex = 0;
    BOOL  fFound = FALSE;
    WCHAR Challenge[2048];


    while (dwIndex != ERROR_HTTP_HEADER_NOT_FOUND)
    {
        DWORD ChallengeLength = sizeof(Challenge) / sizeof(WCHAR);

        if(m_pSession->QueryHeaders(hRequest,
                                    HTTP_QUERY_WWW_AUTHENTICATE, 
                                    Challenge,
                                    &ChallengeLength,
                                    &dwIndex))
        {
            if (::wcsstr(::_wcslwr(Challenge), L"passport1.4"))
            {
                fFound = TRUE;
                break;
            }
        }
        else
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; QueryHeaders() failed; Error Code = %d",
                           dwErrorCode);
            break;
        }
    }

    if (!fFound)
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; Passport1.4 auth header not found");
        goto exit;
    }

    if (::wcsstr(::_wcslwr(Challenge), L"retry"))
    {
        // biaow-todo: not yet implemented
        PP_ASSERT(TRUE); // shouldn't reach here
        dwRetVal = PP_LOGON_REQUIRED;
    }
    else if (::wcsstr(::_wcslwr(Challenge), L"failed"))
    {
        if (fTicketRequest)
        {
            dwRetVal = PP_LOGON_REQUIRED;
            DoTraceMessage(PP_LOG_INFO, "Handle401FromDA() : Logon required by DA");
        }
        else
        {
            dwRetVal = PP_LOGON_FAILED; // Login Request Failed; bad news!
            DoTraceMessage(PP_LOG_WARNING, "Handle401FromDA() : Logon failed");
        }
    }
    else
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; no valid DA status");
        goto exit;
    }

    if (dwRetVal == PP_LOGON_REQUIRED)
    {
        if (::wcsstr(::_wcslwr(Challenge), L"prompt"))
        {
            m_fPrompt = TRUE;
        }
        else
        {
            m_fPrompt = FALSE;
        }

        DownLoadCoBrandBitmap(Challenge);
    }

exit:
    
    return dwRetVal;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Handle200FromDA(
    HINTERNET hRequest
    )
{
    PP_ASSERT(hRequest != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    
    PWSTR pwszBuffer = NULL;
    DWORD dwBuffer = 0;
    if((!m_pSession->QueryHeaders(hRequest,
                                  HTTP_QUERY_AUTHENTICATION_INFO, 
                                  pwszBuffer,
                                  &dwBuffer))
       && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        pwszBuffer = new WCHAR[dwBuffer];
        if (pwszBuffer == NULL)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
            goto exit;
        }

        if (!m_pSession->QueryHeaders(hRequest,
                                      HTTP_QUERY_AUTHENTICATION_INFO, 
                                      pwszBuffer,
                                      &dwBuffer))
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; no Authenticate-Info header found");
            goto exit;
        }

        WCHAR Delimiters[] = L",";
        PWSTR Token = ::wcstok(pwszBuffer, Delimiters);
        while (Token != NULL)
        {
            while (*Token == (L" ")[0]) { ++Token; }
            if (Token == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::Handle200FromDA() : no text in between commas");
                goto next_token;
            }

            if (!::_wcsnicmp(Token, L"ru", ::wcslen(L"ru")))
            {
                PWSTR ReturnUrl = ::wcsstr(Token, L"=");
                if (ReturnUrl == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() : no = after cburl");
                    goto exit;
                }
                ReturnUrl++; // skip =
                
                while (*ReturnUrl == (L" ")[0]) { ++ReturnUrl; }  // skip leading white spaces
                
                m_pwszReturnUrl = new WCHAR[::wcslen(ReturnUrl)+1];
                if (m_pwszReturnUrl == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
                    goto exit;
                }

                ::wcscpy(m_pwszReturnUrl, ReturnUrl);
            }
            else if (!::_wcsnicmp(Token, L"from-pp", ::wcslen(L"from-pp")))
            {
                m_pwszAuthInfo = new WCHAR[::wcslen(Token)+1];
                if (m_pwszAuthInfo == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
                    goto exit;
                }

                ::wcscpy(m_pwszAuthInfo, Token);
            }

        next_token:

            Token = ::wcstok(NULL, Delimiters);
        }

        dwRetVal = PP_LOGON_SUCCESS;
    }
    else
    {
        PP_ASSERT(TRUE); // shouldn't reach here
        goto exit;
    }

exit:

    if (pwszBuffer)
    {
        delete [] pwszBuffer;
    }

    return dwRetVal;
}

VOID PrvLogonStatusCallback(    
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength
)
{
    LOGON* pLogon = reinterpret_cast<LOGON*>(dwContext);

    pLogon->StatusCallback(hInternet,
                           dwInternetStatus,
                           lpvStatusInformation,
                           dwStatusInformationLength);


}

VOID LOGON::StatusCallback(
    IN HINTERNET hInternet,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength)
{
    if (dwInternetStatus == INTERNET_STATUS_REDIRECT)
    {
        ::wcscpy(m_wNewDAUrl, (LPCWSTR)lpvStatusInformation);
        BOOL fRet = m_pSession->AddHeaders(hInternet, 
                               m_pwszAuthHeader, 
                               ::wcslen(m_pwszAuthHeader),
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE
                               );

        PP_ASSERT(fRet == TRUE);
    }
}

BOOL LOGON::GetLogonHost(
    PWSTR       pwszHostName,
    OUT PDWORD  pdwHostNameLen
    ) const
{
    if (*pdwHostNameLen < DWORD(::wcslen(m_wDAHostName) + 1))
    {
        *pdwHostNameLen = ::wcslen(m_wDAHostName) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszHostName != NULL);

    ::wcscpy(pwszHostName, m_wDAHostName);

    *pdwHostNameLen = ::wcslen(m_wDAHostName) + 1;

    return TRUE;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Logon(
    void
    )
{
    PP_ASSERT(m_pSession != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    BOOL fTicketRequest;
    HINTERNET hRequest = 0;
    DWORD dwFlags = 0;

    ::wcscpy(m_pwszAuthHeader, L"Authorization: Passport1.4 ");

    if (m_fCredsPresent)
    {
        ::wcscat(m_pwszAuthHeader, L"sign-in=");
        ::wcscat(m_pwszAuthHeader, m_pwszSignIn);
        ::wcscat(m_pwszAuthHeader, L",");
        
        ::wcscat(m_pwszAuthHeader, L"pwd=");
        ::wcscat(m_pwszAuthHeader, m_pwszPassword);
        ::wcscat(m_pwszAuthHeader, L",");

        if (m_wTimeSkew[0])
        {
            ::wcscat(m_pwszAuthHeader, m_wTimeSkew);
            ::wcscat(m_pwszAuthHeader, L",");
        }

        fTicketRequest = FALSE; // this is a login request, since we've gather credentials
    }
    else
    {
        ::wcscat(m_pwszAuthHeader, L"tname = , ");
        
        fTicketRequest = TRUE;
    }
    
    ::wcscat(m_pwszAuthHeader, m_pwszTicketRequest);

retry:

    // attempt connecting to the Passport DA

    if (m_hConnect)
    {
        m_pSession->CloseHandle(m_hConnect);
    }

    WCHAR       wDATargetObj[256];
    
    DWORD fStstus = m_pSession->GetDAInfo(m_pwszSignIn,
                                          m_wDAHostName, 256,
                                          wDATargetObj, 256);

    PP_ASSERT(fStstus == TRUE);
    
    m_hConnect = m_pSession->Connect(m_wDAHostName/*m_pSession->GetLoginHost()*/,
#ifdef DISABLE_SSL
                    INTERNET_DEFAULT_HTTP_PORT
#else
                    INTERNET_DEFAULT_HTTPS_PORT
#endif
                                     );
    if (m_hConnect == NULL)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; can not connect to %ws, Error = %d",
                       m_wDAHostName, dwErrorCode);
        goto exit;
    }
    if (hRequest)
    {
        m_pSession->CloseHandle(hRequest);
    }

    dwFlags = m_dwParentFlags;

    hRequest = m_pSession->OpenRequest(m_hConnect,
                                       NULL, // "GET"
                                       wDATargetObj/*m_pSession->GetLoginTarget()*/,
#ifdef DISABLE_SSL
                                       dwFlags | INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS,
#else                                                 
                                                 dwFlags | INTERNET_FLAG_SECURE,
#endif
                                       (DWORD_PTR)this
                                       );
    if (hRequest == NULL)

    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; OpenRequest() to %ws failed, Error Code = %d",
                       wDATargetObj, dwErrorCode);
        goto exit;
    }
    
    m_wNewDAUrl[0] = 0;
    m_pSession->SetStatusCallback(hRequest, PrvLogonStatusCallback);
    
    if (!m_pSession->SendRequest(hRequest, 
                                 m_pwszAuthHeader, 
                                 ::wcslen(m_pwszAuthHeader),
                                 (DWORD_PTR)this))
    {
        DWORD dwErrorCode = ::GetLastError();

#ifdef BAD_CERT_OK
        if (dwErrorCode == ERROR_INTERNET_INVALID_CA)
        {
            DWORD dwSecFlags;
            DWORD dwSecurityFlagsSize = sizeof(dwSecFlags);

            if (!m_pSession->QueryOption(hRequest, 
                                    INTERNET_OPTION_SECURITY_FLAGS,
                                    &dwSecFlags,
                                    &dwSecurityFlagsSize))
            {
                dwSecFlags = 0;
            }
            else
            {
                dwSecFlags |= SECURITY_SET_MASK;
            }

            if (!m_pSession->SetOption(hRequest, 
                                      INTERNET_OPTION_SECURITY_FLAGS, 
                                      &dwSecFlags, 
                                      dwSecurityFlagsSize))
            {
                PP_ASSERT(TRUE); // shouldn't reach here
                goto exit;
            }
            else
            {
                if (!m_pSession->SendRequest(hRequest, NULL, 0))
                {
                    dwErrorCode = ::GetLastError();
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; SendRequest() failed, Error Code = %d",
                                   dwErrorCode);
                    goto exit;
                }
                else
                {
                    dwErrorCode = ERROR_SUCCESS;
                }
            }
        }
#endif // BAD_CERT_OK
        
        if (dwErrorCode != ERROR_SUCCESS)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; SendRequest() failed, Error Code = %d",
                           dwErrorCode);

            if (m_pSession->GetDAInfoFromPPNexus(NULL, 0, NULL, 0) == TRUE)
            {
                goto retry;
            }

            goto exit;
        }
    }

    {
        DWORD dwStatus, dwStatusLen;
        dwStatusLen = sizeof(dwStatus);
        if (!m_pSession->QueryHeaders(hRequest,
                                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                                      &dwStatus,
                                      &dwStatusLen))
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; can not retrieve Status Code, Error Code = %d",
                           dwErrorCode);
            goto exit;
        }
    
        if (dwStatus == HTTP_STATUS_DENIED)
        {
            dwRetVal = Handle401FromDA(hRequest, fTicketRequest);
        }
        else if (dwStatus == HTTP_STATUS_OK)
        {
            dwRetVal = Handle200FromDA(hRequest);
        }
        else
        {
            //PP_ASSERT(TRUE); // shouldn't reach here
            //goto exit;
        }

        if (dwRetVal == PP_GENERIC_ERROR)
        {
            if (m_pSession->GetDAInfoFromPPNexus(NULL, 0, NULL, 0) == TRUE)
            {
                goto retry;
            }
        }
        else
        {
            if (m_wNewDAUrl[0])
            {
                m_pSession->UpdateDAInfo(m_pwszSignIn,
                                         m_wNewDAUrl);
                m_wNewDAUrl[0] = 0;
            }
        }
    }

exit:

    if (hRequest)
    {
        m_pSession->CloseHandle(hRequest);
    }
    
    return dwRetVal;
}

// -----------------------------------------------------------------------------
BOOL LOGON::GetChallengeInfo(
	HBITMAP**		 ppBitmap,
	PBOOL			 pfPrompt,
	PWSTR			 pwszCbText,
    PDWORD           pdwTextLen,
    PWSTR            pwszRealm,
    DWORD            dwMaxRealmLen
    ) const
{
    if (ppBitmap)
    {
        *ppBitmap = m_pBitmap;
    }
    if (pfPrompt)
    {
        *pfPrompt = m_fPrompt;
    }

	// *pdwTextLen = 0; // biaow-todo:
    
    if (pwszRealm)
    {
        ::wcsncpy(pwszRealm, m_wRealm, dwMaxRealmLen-1);
    }
    
    return TRUE;
}

// -----------------------------------------------------------------------------
BOOL LOGON::GetAuthorizationInfo(
    PWSTR   pwszTicket,
    PDWORD  pdwTicketLen,
    PBOOL   pfKeepVerb,
    PWSTR   pwszUrl,
    PDWORD  pdwUrlLen 
    ) const
{
    if (m_pwszReturnUrl == NULL)
    {
        *pfKeepVerb = TRUE;
        *pdwUrlLen = 0;
        return TRUE;
    }

    if (*pdwUrlLen < DWORD(::wcslen(m_pwszReturnUrl) + 1))
    {
        *pdwUrlLen = ::wcslen(m_pwszReturnUrl) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszUrl != NULL);

    ::wcscpy(pwszUrl, m_pwszReturnUrl);

    *pfKeepVerb = FALSE;
    *pdwUrlLen = ::wcslen(m_pwszReturnUrl) + 1;

    if (*pdwTicketLen < DWORD(::wcslen(m_pwszAuthInfo) + 1))
    {
        *pdwTicketLen = ::wcslen(m_pwszAuthInfo) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszTicket != NULL);

    ::wcscpy(pwszTicket, m_pwszAuthInfo);
    *pdwTicketLen = ::wcslen(m_pwszAuthInfo) + 1;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\passport\passport.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passport.cpp

Abstract:

    WinInet/WinHttp- Passport Auenthtication Package Interface implementation.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "ppdefs.h"
#include "Session.h"
#include "logon.h"
#include "passport.h"

// #include "passport.tmh"

// -----------------------------------------------------------------------------
PP_CONTEXT 
PP_InitContext(
    PCWSTR	pwszHttpStack,
    HINTERNET hSession
    )
{
//	WPP_INIT_TRACING(L"Microsoft\\Passport1.4");
    
    if (pwszHttpStack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitConect() : pwszHttpStack is null");
        return 0;
    }

    SESSION* pSession;
    if (SESSION::CreateObject(pwszHttpStack, hSession, pSession) == FALSE)
    {
        return 0;
    }


    DoTraceMessage(PP_LOG_INFO, "Passport Context Initialized");
    
    return reinterpret_cast<PP_CONTEXT>(pSession);
}

// -----------------------------------------------------------------------------
VOID 
PP_FreeContext(
	PP_CONTEXT hPP
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeContext() : hPP is null");
        return;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);
    
    if (pSession->RefCount() > 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "Passport Context ref count not zero before freed");
    }

    delete pSession;

    DoTraceMessage(PP_LOG_INFO, "Passport Context Freed");

//	WPP_CLEANUP();
}

// -----------------------------------------------------------------------------
PP_LOGON_CONTEXT
PP_InitLogonContext(
	PP_CONTEXT hPP,
    PCWSTR	pwszPartnerInfo,
    DWORD dwParentFlags
    )
{
    if (hPP == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitLogonContext() : hPP is null");
        return 0;
    }

    LOGON* pLogon = new LOGON(reinterpret_cast<SESSION*>(hPP), dwParentFlags);
    if (pLogon == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitLogonContext() failed; not enough memory");
        return 0;
    }

    if (pLogon->Open(pwszPartnerInfo) == FALSE)
    {
        delete pLogon;
        return 0;
    }

    DoTraceMessage(PP_LOG_INFO, "Passport Logon Context Initialized");
    
    return reinterpret_cast<PP_LOGON_CONTEXT>(pLogon);
}

// -----------------------------------------------------------------------------
VOID 
PP_FreeLogonContext(
    PP_LOGON_CONTEXT    hPPLogon
	)
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeLogonContext() : hPPLogon is null");
        return;
    }

    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);
    
    delete  pLogon;

    DoTraceMessage(PP_LOG_INFO, "Passport Logon Context Freed");
}

// -----------------------------------------------------------------------------
DWORD
PP_Logon(
    PP_LOGON_CONTEXT    hPPLogon,
	HANDLE	            hEvent,
    PFN_LOGON_CALLBACK  pfnLogonCallback,
    DWORD               dwContext	
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_Logon() : hPPLogon is null");
        return 0;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->Logon();
}

// -----------------------------------------------------------------------------
BOOL
PP_GetChallengeInfo(
    PP_LOGON_CONTEXT hPPLogon,
	HBITMAP**		 ppBitmap,
    PBOOL            pfPrompt,
  	PWSTR			 pwszCbText,
    PDWORD           pdwTextLen,
    PWSTR            pwszRealm,
    DWORD            dwMaxRealmLen
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetInfoFromChallenge() : hPPLogon is null");
        return FALSE;
    }

	//PP_ASSERT(ppBitmap != NULL);
	//PP_ASSERT(pfPrompt != NULL);
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

	return pLogon->GetChallengeInfo(ppBitmap,
									pfPrompt,
                                    pwszCbText,
                                    pdwTextLen,
                                    pwszRealm,
                                    dwMaxRealmLen);
}

// -----------------------------------------------------------------------------
BOOL 
PP_SetCredentials(
    PP_LOGON_CONTEXT    hPPLogon,
    PCWSTR              pwszRealm,
    PCWSTR              pwszTarget,
    PCWSTR              pwszSignIn,
    PCWSTR              pwszPassword
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_SetCredentials() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->SetCredentials(pwszRealm, pwszTarget, pwszSignIn, pwszPassword);
}

BOOL
PP_GetLogonHost(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszHostName,    // user supplied buffer ...
	IN OUT PDWORD       pdwHostNameLen  // ... and length (will be updated to actual length 
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetLogonHost() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);
    
    return pLogon->GetLogonHost(pwszHostName, pdwHostNameLen);
}


// -----------------------------------------------------------------------------
BOOL 
PP_GetAuthorizationInfo(
    PP_LOGON_CONTEXT hPPLogon,
	PWSTR            pwszTicket,       // e.g. "from-PP = ..."
	OUT PDWORD       pdwTicketLen,
	PBOOL            pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
	PWSTR            pwszUrl,    // user supplied buffer ...
	OUT PDWORD       pdwUrlLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	)
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetReturnVerbAndUrl() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->GetAuthorizationInfo(pwszTicket, 
                                        pdwTicketLen, 
                                        pfKeepVerb, 
                                        pwszUrl, 
                                        pdwUrlLen);
}


// -----------------------------------------------------------------------------
VOID 
PP_Logout(
    IN PP_CONTEXT hPP,
    IN DWORD      dwFlags
    )
{
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);
    pSession->Logout();
}

BOOL
PP_ForceNexusLookup(
    PP_LOGON_CONTEXT    hPP,
	IN PWSTR            pwszRegUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
	IN PWSTR            pwszDARealm,    // user supplied buffer ...
	IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	)
{

    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    return pSession->GetDAInfoFromPPNexus(pwszRegUrl,
                                          pdwRegUrlLen,
                                          pwszDARealm,
                                          pdwDARealmLen);
}


#ifdef PP_DEMO

// -----------------------------------------------------------------------------
BOOL PP_ContactPartner(
	PP_CONTEXT hPP,
    PCWSTR pwszPartnerUrl,
    PCWSTR pwszVerb,
    PCWSTR pwszHeaders,
    PWSTR pwszData,
    PDWORD pdwDataLength
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_ContactPartner() : hPPLogon is null");
        return FALSE;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    return pSession->ContactPartner(pwszPartnerUrl,
                                    pwszVerb,
                                    pwszHeaders,
                                    pwszData,
                                    pdwDataLength
                                    );
}

#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\bucket.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Bucket.hpp"
#include "Cache.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here relate the compuation of the       */
    /*   current active page address range.                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 HighestAddress			  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new allocation bucket and prepare it for use.         */
    /*   We need to be sure to carefully check everything we have       */
    /*   been supplied as it has come indirectly from the user.         */
    /*                                                                  */
    /********************************************************************/

BUCKET::BUCKET
		( 
		SBIT32						  NewAllocationSize,
		SBIT32						  NewChunkSize,
		SBIT32						  NewPageSize 
		)
    {
	//
	//   We want to make sure that the bucket configuration
	//   appears to make basic sense.  If not we have no 
	//   alternative than to throw an expection.
	//
	if
			(
			(NewAllocationSize > 0)
				&&
			(NewChunkSize >= NewAllocationSize)
				&&
			(NewChunkSize <= NewPageSize)
				&&
			PowerOfTwo( NewPageSize )
			)
		{
		//
		//   Create the bucket and prepare it for use.
		//   Pre-compute any information we can here to
		//   save work later.
		//
		AllocationSize = NewAllocationSize;
		ChunkSize = NewChunkSize;
		PageSize = NewPageSize;

		ActivePages = 0;
		AllocationShift = 0;
		ChunkShift = 0;

		//
		//   Compute the optimization level from the available
		//   bucket information.  The highest level means
		//   everything is a power of two (just shifts - yipee !!).
		//   The next means no chunks (i.e. simple scaling), The
		//   next means simple chunks (i.e. complex scaling).
		//   The final alternative is to horrid to discuss. 
		//   
		if ( ConvertDivideToShift( AllocationSize,& AllocationShift ) )
			{
			//
			//   If we are not using chunking we can skip the
			//   extra compuation that is needed.  We can tell
			//   this is the case if the chunk size and the page
			//   size match or if the chunk size is a multiple
			//   of the allocation size.
			//
			if 
					( 
					(ChunkSize == PageSize)
						||
					((ChunkSize % AllocationSize) == 0)
					)
				{
				//
				//   The best case is when we can use shifts
				//   instead of multiply and divide.
				//
				ComputeAddressFunction = ComputeAddressBestCase;
				ComputeOffsetFunction = ComputeOffsetBestCase;
				}
			else
				{
				//
				//   When we have chunks we have to do more 
				//   work invloving additional multiples and
				//   divides.  Nonetheless, we try to minimize
				//   these as far as possible.
				// 
				if ( ConvertDivideToShift( ChunkSize,& ChunkShift ) )
					{
					//
					//   We have managed to replace some of the
					//   multiplies and divides with shifts.
					//
					ComputeAddressFunction = ComputeAddressPoorCase;
					ComputeOffsetFunction = ComputeOffsetPoorCase;
					}
				else
					{
					//
					//   We are unable to optimize this case.
					//   These calls will really hurt.
					//
					ComputeAddressFunction = ComputeAddressWorstCase;
					ComputeOffsetFunction = ComputeOffsetWorstCase;
					}
				}
			}
		else
			{
			//
			//   If we are not using chunking we can skip the
			//   extra compuation that is needed.  We can tell
			//   this is the case if the chunk size and the page
			//   size match or if the chunk size is a multiple
			//   of the allocation size.
			//
			if 
					( 
					(ChunkSize == PageSize)
						||
					((ChunkSize % AllocationSize) == 0)
					)
				{ 
				//
				//   A good case is when we can use a few
				//   simple multiplies and divides to do simple
				//   scaling.
				//
				ComputeAddressFunction = ComputeAddressGoodCase;
				ComputeOffsetFunction = ComputeOffsetGoodCase;
				}
			else
				{ 
				//
				//   When we have chunks we have to do more 
				//   work invloving additional multiples and
				//   divides.  Nonetheless, we try to minimize
				//   these as far as possible.
				// 
				if ( ConvertDivideToShift( ChunkSize,& ChunkShift ) )
					{
					//
					//   We have managed to replace some of the
					//   multiplies and divides with shifts.
					//
					ComputeAddressFunction = ComputeAddressPoorCase;
					ComputeOffsetFunction = ComputeOffsetPoorCase;
					}
				else
					{
					//
					//   We are unable to optimize this case.
					//   These calls will really hurt.
					//
					ComputeAddressFunction = ComputeAddressWorstCase;
					ComputeOffsetFunction = ComputeOffsetWorstCase;
					}
				}
			}

		//
		//   Compute all the information that will be
		//   needed later to describe the allocation
		//   pages.
		//
		NumberOfElements = 
			((SBIT16) ((PageSize / ChunkSize) * (ChunkSize / AllocationSize)));
		SizeOfChunks = (SBIT16)
			((SBIT16) (ChunkSize / AllocationSize));
		SizeOfElements = (SBIT16)
			((SBIT16) (((NumberOfElements-1) / OverheadBitsPerWord) + 1));
		SizeKey = NoSizeKey;
		}
	else
		{ Failure( "Configuration in constructor for BUCKET" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressBestCase( CHAR *Address,SBIT32 Offset )
	{ return ((VOID*) (Address + (Offset << AllocationShift))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressGoodCase( CHAR *Address,SBIT32 Offset )
	{ return ((VOID*) (Address + (Offset * AllocationSize))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressPoorCase( CHAR *Address,SBIT32 Offset )
	{
	REGISTER SBIT32 ChunkNumber = (Offset / SizeOfChunks);
	REGISTER SBIT32 ChunkOffset = (ChunkNumber * SizeOfChunks);
	REGISTER SBIT32 AllocationNumber = (Offset - ChunkOffset);

	return
		((VOID*)
			(
			Address 
				+
			(ChunkNumber << ChunkShift)
				+
			(AllocationNumber * AllocationSize)
			)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressWorstCase( CHAR *Address,SBIT32 Offset )
	{
	REGISTER SBIT32 ChunkNumber = (Offset / SizeOfChunks);
	REGISTER SBIT32 ChunkOffset = (ChunkNumber * SizeOfChunks);
	REGISTER SBIT32 AllocationNumber = (Offset - ChunkOffset);

	return
		((VOID*)
			(
			Address 
				+
			(ChunkNumber * ChunkSize)
				+
			(AllocationNumber * AllocationSize)
			)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetBestCase( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset = (Displacement >> AllocationShift);

	(*Found) = (Displacement == (ArrayOffset << AllocationShift));
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetBestCase" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetGoodCase( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset = (Displacement / AllocationSize);

	(*Found) = (Displacement == (ArrayOffset * AllocationSize));
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetGoodCase" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetPoorCase( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;
	REGISTER SBIT32 ChunkNumber = (Displacement >> ChunkShift);
	REGISTER SBIT32 ChunkAddress = (ChunkNumber << ChunkShift);
	REGISTER SBIT32 ChunkOffset = (Displacement - ChunkAddress);
	REGISTER SBIT32 AllocationNumber = (ChunkOffset / AllocationSize);

	ArrayOffset = ((ChunkNumber * SizeOfChunks) + AllocationNumber);

	(*Found) = 
		(
		(Displacement) 
			== 
		(ChunkAddress + (AllocationNumber * AllocationSize))
		);
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetPoorCase" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetWorstCase( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;
	REGISTER SBIT32 ChunkNumber = (Displacement / ChunkSize);
	REGISTER SBIT32 ChunkAddress = (ChunkNumber * ChunkSize);
	REGISTER SBIT32 ChunkOffset = (Displacement - ChunkAddress);
	REGISTER SBIT32 AllocationNumber = (ChunkOffset / AllocationSize);

	ArrayOffset = ((ChunkNumber * SizeOfChunks) + AllocationNumber);

	(*Found) = 
		(
		(Displacement) 
			== 
		(ChunkAddress + (AllocationNumber * AllocationSize))
		);
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetWorstCase" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a memory allocation.                                    */
    /*                                                                  */
    /*   We need to delete a single memory allocation from a bucket.    */
    /*   We do this by passing the request on to the page.              */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::Delete( VOID *Address,PAGE *Page,SBIT32 Version )
	{
	AUTO SEARCH_PAGE Details;

	//
	//   When we delete an allocation we need to ensure 
	//   the page has not radically changed since we found
	//   it.  Hence, we compare the current page version  
	//   number with the one we found earlier.  If all is 
	//   well we get the details relating to the allocation
	//   and then delete it.
	//
	return
		(
		((Page -> GetVersion()) == Version)
			&&
		(Page -> FindPage( Address,& Details,False ) != NULL)
			&&
		(Page -> Delete( & Details ))
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a page from the bucket list.                            */
    /*                                                                  */
    /*   When a page becomes full it is removed from the bucket list    */
    /*   so it will be no longer inspected when looking for free space. */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::DeleteFromBucketList( PAGE *Page )
	{
	//
	//   We keep track of the number of active pages on the 
	//   bucket list.  This helps us when we need to scan the
	//   bucket list for some reason later.
	//
	if ( (-- ActivePages) >= 0 )
		{
		//
		//   Delete the page from the bucket list as it is 
		//   no longer needed.  There are two cases when this 
		//   happens.  When the page is full and when the page 
		//   is about to be deleted.
		//
		Page -> DeleteFromBucketList( & BucketList );

		//
		//   Compute the highest address on the first page.  We 
		//   use this information to figure out whether to 
		//   recycle an allocation or pass it along for deletion
		//   in the cache.
		//
		Page = (PAGE::FirstInBucketList( & BucketList ));
		
		if ( ! Page -> EndOfBucketList() )
			{
			CurrentPage =
				(
				((VOID*) (((LONG) Page -> GetAddress()) + (PageSize - 1)))
				);
			}
		else
			{ CurrentPage = ((VOID*) HighestAddress); }
		}
	else
		{ Failure( "Active page count in DeleteFromBucketList" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a page into the bucket list.                            */
    /*                                                                  */
    /*   When a page is created or when it changes from being full      */
    /*   to having at least one free slot it is added to the bucket     */
    /*   list so that it can be used to allocate space.                 */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::InsertInBucketList( PAGE *Page )
	{
	//
	//   We keep track of the number of active pages on the 
	//   bucket list.  This helps us when we need to scan the
	//   bucket list for some reason later.
	//
	ActivePages ++;

	//
	//   We insert pages into the list in ascending address
	//   order.  This ensures that we always allocate the 
	//   lowest addresses first.  This is done to try to keep 
	//   the working set small and compact.
	//
	if ( ! BucketList.EndOfList() )
		{
		REGISTER VOID *Address = (Page -> GetAddress());
		REGISTER PAGE *Last = (Page -> LastInBucketList( & BucketList ));

		//
		//   We are about to walk the entire page list
		//   trying to find where to insert this page.
		//   Lets see if the page needs to be inserted
		//   at the end of the list.  If so have saved
		//   ourseleves a lot of work and we can exit 
		//   early.
		//   
		if ( Address < (Last -> GetAddress()) )
			{
			REGISTER PAGE *Current;

			//
			//   Well it looks like we need to walk along 
			//   the entire page list to find the correct 
			//   place to insert this element.
			//
			for 
					( 
					Current = (Page -> FirstInBucketList( & BucketList ));
					! Current -> EndOfBucketList();
					Current = Current -> NextInBucketList() 
					)
				{
				//
				//   While the current address is lower 
				//   than ours we need to keep on walking.
				//
				if ( Address < (Current -> GetAddress()) )
					{
					//
					//   We have found the spot so insert 
					//   the bucket just before the current 
					//   bucket.
					//
					Current -> InsertBeforeInBucketList( & BucketList,Page );

					break;
					}
				}
			}
		else
			{
			//
			//   The page has the highest address so insert
			//   it at the end of the list.
			//
			Last -> InsertAfterInBucketList( & BucketList,Page );
			}
		}
	else
		{ Page -> InsertInBucketList( & BucketList ); }

	//
	//   Compute the highest address on the first page.  We can
	//   use this information to figure out whether to recycle an
	//   allocation or pass it along for deletion in the cache.
	//
	Page = (PAGE::FirstInBucketList( & BucketList ));
	
	CurrentPage =
		(
		((VOID*) (((LONG) Page -> GetAddress()) + (PageSize - 1)))
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   When the delete cache becomes full we complete any pending     */
    /*   delete requests.  We also flush the delete cache when if       */
    /*   we need to allocate additional memory unless recycling is      */
    /*   enabled in which case we just steal it directly from the       */
    /*   delete cache.                                                  */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::MultipleDelete
		( 
		ADDRESS_AND_PAGE			  *Array,
		SBIT32						  *Deleted,
		SBIT32						  Size 
		)
	{
	AUTO SEARCH_PAGE Details;
	REGISTER SBIT32 Count;

	//
	//   Zero the count of deleted items.
	//
	(*Deleted) = 0;

	//
	//   Delete each element one at a time.  We would love to
	//   delete them all at once but we haven't got a clue where
	//   they have come from so we have to do it one at a time. 
	//   
	for ( Count=0;Count < Size;Count ++ )
		{
		REGISTER ADDRESS_AND_PAGE *Current = & Array[ Count ];
		REGISTER PAGE *Page = Current -> Page;

		//
		//   It may see like a waste of time to batch up all
		//   the deletions.  Why not do them as they arrive.
		//   There are a number of reasons.  The deletes can
		//   be recycled, batchs of deletes is faster than
		//   single deletes (due to cache effects) and so on.
		//
		if
				(
				(Current -> Version == Page -> GetVersion())
					&&
				(Page -> FindPage( Current -> Address,& Details,False ) != NULL)
					&&
				(Page -> Delete( & Details ))
				)
			{ (*Deleted) ++; }
		}

	return ((*Deleted) == Size);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We need to make a multiple memory allocation from this			*/
    /*   bucket so walk the bucket list allocating any available        */
    /*   space and return it to the caller.                             */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::MultipleNew
		( 
		SBIT32						  *Actual,
		VOID						  *Array[],
		SBIT32						  Requested 
		)
    {
	//
	//   Zero the count of allocated elements.
	//
	(*Actual) = 0;

	//
	//   We walk the sorted list of pages with available
	//   allocations searching for elements to allocate.
	//
	do
		{
		REGISTER PAGE *Page;
		REGISTER PAGE *NextPage;

		//
		//   Walk the bucket list looking for any available
		//   free space.
		//
		for 
				( 
				Page = (PAGE::FirstInBucketList( & BucketList ));
				! Page -> EndOfBucketList();
				Page = NextPage
				)
			{
			REGISTER SBIT32 ActualSize = (Page -> GetPageSize());

			//
			//   Lets find the next page now as the current 
			//   bucket may be removed from the bucket list
			//   by the following allocation call.
			//
			NextPage = Page -> NextInBucketList();

			//
			//   We allow the page size to be dynamically
			//   modified to support a variety of wierd
			//   data layouts for BBT.   If the current page
			//   is not the standard size then skip it.
			//
			if ( (ActualSize == NoSize) || (ActualSize == PageSize) )
				{
				//
				//   We try allocate all the space we need 
				//   from each page in the bucket list.  If 
				//   the page has enough space we can exit 
				//   early if not we go round the loop and
				//   try the next page.
				//
				if ( Page -> MultipleNew( Actual,Array,Requested ) )
					{ return True; }
				}
			}
		}
	while 
		( 
		NewPage -> CreatePage( (CACHE*) this )
			!= 
		((PAGE*) AllocationFailure) 
		);

	//
	//   We see if we managed to allocate all the elements
	//   we wanted.  If so we are happy and we can get out 
	//   of here.
	//
	if ( (*Actual) < Requested )
		{
		//
		//   We see if we managed to allocate any elements 
		//   at all.  If not we fail the request.
		//
		if ( (*Actual) > 0 )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 Delta = ((Requested) - (*Actual));

			//
			//   We are very naughty when we allocate multiple
			//   elements in that we put them in the array in
			//   reverse order.  The logic is that this is just
			//   what we want when we allocate out of the cache.
			//   However, if we are unable to allocate all the
			//   elements we needed then we have to move the 
			//   pointers down to the base of the array.
			//
			for ( Count=0;Count < (*Actual);Count ++ )
				{ Array[ Count ] = Array[ (Count + Delta) ]; }
			}
		else
			{ return False; }
		}

	return True;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We need to make a new memory allocation from this bucket       */
    /*   so search the page list of available space and return a        */
    /*   free element.                                                  */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::New( BOOLEAN SubDivided,SBIT32 NewSize )
    {
	do
		{
		REGISTER PAGE *Page;

		//
		//   Walk the bucket list looking for any available
		//   free space.
		//
		for 
				( 
				Page = (PAGE::FirstInBucketList( & BucketList ));
				! Page -> EndOfBucketList();
				Page = Page -> NextInBucketList()
				)
			{
			REGISTER SBIT32 ActualSize = (Page -> GetPageSize());

			//
			//   We allow the page size to be dynamically
			//   modified to support a variety of wierd
			//   data layouts for BBT.   If the current page
			//   is not the correct size then skip it.
			//
			if 
					( 
					(ActualSize == NoSize) 
						|| 
					(ActualSize == ((NewSize == NoSize) ? PageSize : NewSize))
					)
				{
				//
				//   We know that any page that appears in 
				//   the bucket list will have at least one 
				//   free element available.  So if we find
				//   that the bucket list a suitable page 
				//   then we know that we can allocate something.
				//
				return (Page -> New( SubDivided ));
				}
			}
		}
	while 
		( 
		NewPage -> CreatePage( ((CACHE*) this),NewSize ) 
			!= 
		((PAGE*) AllocationFailure) 
		);

	//
	//   We were unable to find anything we could allocate
	//   so fail the request.
	//
	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release free space.                                            */
    /*                                                                  */
    /*   We sometimes do not release free space from a bucket as        */
    /*   returning it to the operating system and getting it again      */
    /*   later is very expensive.  Here we flush any free space we      */
    /*   have aquired over the user supplied limit.                     */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::ReleaseSpace( SBIT32 MaxActivePages )
    {
	REGISTER SBIT32 Current = ActivePages;

	//
	//   We only bother to try to trim the number of
	//   active pages if we are over the limit.
	//
	if ( Current > MaxActivePages )
		{
		REGISTER PAGE *NextPage;
		REGISTER PAGE *Page;

		//
		//   Walk the backwards along the bucket list 
		//   and delete the highest addressed free pages
		//   if we are over the limit.
		//
		for 
				( 
				Page = (PAGE::LastInBucketList( & BucketList ));
				(Current > MaxActivePages) 
					&& 
				(! Page -> EndOfBucketList());
				Page = NextPage
				)
			{
			//
			//   We are walking backwards down the bucket
			//   list looking for empty pages to delete.
			//   However, if we find a page we can remove
			//   it will be automatically removed from the
			//   list so we need to get the next pointer
			//   before this happens.
			//
			NextPage = Page -> PreviousInBucketList();

			//
			//   We can only release a page if it is empty
			//   if not we must skip it.
			//
			if ( Page -> Empty() )
				{
				Current --;

				DeletePage( Page ); 
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the bucket information.                                 */
    /*                                                                  */
    /*   When we create the bucket there is some information that       */
    /*   is not available.  Here we update the bucket to make sure      */
    /*   it has all the data we need.                                   */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::UpdateBucket
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	REGISTER SBIT16 NewSizeKey = (NewPages -> FindSizeKey( NumberOfElements ));

	//
	//   We compute and verify the size key to make sure
	//   it is suitable for all the pages that we will
	//   create after the heap constructor is completed.
	//
	if ( NewSizeKey != NoSizeKey )
		{
		//
		//   Update the size key and the connections.
		//
		SizeKey = NewSizeKey;

		UpdateConnections
			( 
			NewFind,
			NewHeap,
			NewPages,
			NewParentCache 
			);
		}
	else
		{ Failure( "Bucket can't get a size key in UpdateBucket" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the allocation bucket.                                 */
    /*                                                                  */
    /********************************************************************/

BUCKET::~BUCKET( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\bucket.hpp ===
#ifndef _BUCKET_HPP_
#define _BUCKET_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Connections.hpp"
#include "Page.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   A collection of pages.                                         */
    /*                                                                  */
    /*   A bucket is a collection of pages capable of allocating        */
    /*   fixed sized memory elements.  The pages are allocated from     */
    /*   from larger buckets and are stored in a linked list in         */
    /*   order of ascending of page addresses.                          */
    /*                                                                  */
    /********************************************************************/

class BUCKET : public CONNECTIONS
    {
		//
		//   Private type definitions.
		//
		//   All allocations are registered in bit vectors.
		//   Here we have some prototypes for seriously  
		//   optimized functions to do address to bit 
		//   vector computations.
		//
		typedef VOID *(BUCKET::*COMPUTE_ADDRESS)
			( 
			CHAR					  *Address,
			SBIT32					  Offset 
			);

		typedef SBIT32 (BUCKET::*COMPUTE_OFFSET)
			( 
			SBIT32					  Displacement,
			BOOLEAN					  *Found 
			);

		//
		//   Private data.
		//
		//   A bucket owns all the memory of a given size
		//   and manages it.  Above it is a cache to 
		//   protect it from huge number of calls and
		//   below it are the connections to various 
		//   other classes.  The 'AllocationSize' is the
		//   buckets allocation size.  The 'ChunkSize' is
		//   chunking size which is typically half way
		//   between the 'AllocationSize' and the 'PageSize'.
		//   The 'PageSize' is the size of the bucket
		//   where this bucket gets its space.
		//   
		//
		SBIT32                        AllocationSize;
		SBIT32						  ChunkSize;
		SBIT32						  PageSize;

		//
		//   It is the job of the bucket to keep track of
		//   all the information relating to allocations
		//   of a given 'AllocationSize'.  The 'ActivePages'
		//   keeps track of the number of available pages
		//   in the 'BucketList'.  The 'BucketList' is a
		//   linked list of pages that have available space.
		//   The 'CurrentPage' contains the highest address
		//   of the first page in the 'BucketList'.
		//
		SBIT32						  ActivePages;
		LIST						  BucketList;
		VOID						  *CurrentPage;

		//
		//   A bucket needs to be able to quickly convert
		//   bit vector offsets to addresses (and vice versa).
		//   The 'AllocationShift' is set when the 
		//   'AllocationSize' is a power of two to avoid 
		//   any divides.  The 'ChunkShift' is set when the
		//   'ChunckSize' is a power of two to avoid some
		//   divides.  The 'ComputeAddressFunction' and
		//   'ComputeOffsetFunction' point to optimized
		//   functions to do conversions that are selected
		//   by the constructor.
		//
		SBIT32						  AllocationShift;
		SBIT32						  ChunkShift;
		COMPUTE_ADDRESS				  ComputeAddressFunction;
		COMPUTE_OFFSET				  ComputeOffsetFunction;

		//
		//   A bucket typically contains a collection of
		//   pages.  As all pages are the same data that
		//   should really be stored in page descriptions
		//   is instead stored in the bucket to save space.
		//   The 'NumberOfElements' contains the number of
		//   elements in each pages bit vector.  The 
		//   'SizeOfChunks' contains the pre-computed chunk
		//   size.  The 'SizeOfElements' contains the number
		//   of words in the pages bit vector.  The 'SizeKey'
		//   contains an index which selects the size of the
		//   bit vector when a new page is created.
		//
		SBIT16						  NumberOfElements;
		SBIT16						  SizeOfChunks;
		SBIT16						  SizeOfElements;
		SBIT16						  SizeKey;

   public:
		//
		//   Public functions.
		//
		//   The functionality provided by this class pretty
		//   much matches the external API.  Nonetheless, these
		//   APIs are protected from excessive calls by a fast
		//   cache that is derived from this class.
		//
        BUCKET
			( 
			SBIT32					  NewAllocationSize,
			SBIT32					  NewChunkSize,
			SBIT32					  NewPageSize 
			);

		BOOLEAN Delete( VOID *Address,PAGE *Page,SBIT32 Version );

		VOID DeleteFromBucketList( PAGE *Page );

		VOID InsertInBucketList( PAGE *Page );

		BOOLEAN MultipleDelete
			( 
			ADDRESS_AND_PAGE		  *Array,
			SBIT32					  *Deleted,
			SBIT32					  Size 
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested 
			);

		VOID *New( BOOLEAN SubDivided,SBIT32 NewSize = NoSize );

		VOID ReleaseSpace( SBIT32 MaxActivePages );

		VOID UpdateBucket
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~BUCKET( VOID );

		//
		//   Public inline functions.
		//
		//   It saves a significant amount of space by putting
		//   common information in the bucket instead of a 
		//   separate copy in each page description.  Nonetheless,
		//   it means that both classes are very much dependent
		//   upon each other.
		//
		INLINE VOID *ComputeAddress( CHAR *Address,SBIT32 Offset )
			{ return (this ->* ComputeAddressFunction)( Address,Offset ); }

		INLINE SBIT32 ComputeOffset( SBIT32 Displacement,BOOLEAN *Found )
			{ return (this ->* ComputeOffsetFunction)( Displacement,Found ); }

		INLINE SBIT32 GetAllocationSize( VOID )
			{ return AllocationSize; }

		INLINE SBIT32 GetChunkSize( VOID )
			{ return ChunkSize; }

		VOID *GetCurrentPage( VOID )
			{ return CurrentPage; }

		INLINE SBIT16 GetNumberOfElements( VOID )
			{ return NumberOfElements; }

		INLINE SBIT32 GetPageSize( VOID )
			{ return PageSize; }

		INLINE SBIT16 GetSizeOfChunks( VOID )
			{ return SizeOfChunks; }

		INLINE SBIT16 GetSizeOfElements( VOID )
			{ return SizeOfElements; }

		INLINE SBIT16 GetSizeKey( VOID )
			{ return SizeKey; }

	private:
		//
		//   Private functions.
		//
		//   When we need to convert an address to a bit 
		//   offset (or vice versa) we use one of the following 
		//   functions.
		//
		VOID *ComputeAddressBestCase( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressGoodCase( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressPoorCase( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressWorstCase( CHAR *Address,SBIT32 Offset );

		SBIT32 ComputeOffsetBestCase( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetGoodCase( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetPoorCase( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetWorstCase( SBIT32 Displacement,BOOLEAN *Found );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BUCKET( CONST BUCKET & Copy );

        VOID operator=( CONST BUCKET & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\bucketlist.hpp ===
#ifndef _BUCKET_LIST_HPP_
#define _BUCKET_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   The bucket list.                                               */
    /*                                                                  */
    /*   All allocation buckets have a linked list of pages with        */
    /*   available space in ascending order of address.                 */
    /*                                                                  */
    /********************************************************************/

class BUCKET_LIST
    {
		//
		//   Private data.
		//
 		LIST						  BucketList;

   public:
        //
        //   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
        //
        BUCKET_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromBucketList( LIST *HeadOfList )
			{ BucketList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfBucketList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInBucketList( LIST *HeadOfList )
			{ return ((PAGE*) HeadOfList -> First()); }

		INLINE VOID InsertInBucketList( LIST *HeadOfList )
			{ BucketList.Insert( HeadOfList ); }

		INLINE VOID InsertAfterInBucketList( LIST *HeadOfList,PAGE *Page )
			{ BucketList.InsertAfter( HeadOfList,(LIST*) Page ); }

		INLINE VOID InsertBeforeInBucketList( LIST *HeadOfList,PAGE *Page )
			{ BucketList.InsertBefore( HeadOfList,(LIST*) Page ); }

		STATIC INLINE PAGE *LastInBucketList( LIST *HeadOfList )
			{ return ((PAGE*) HeadOfList -> Last()); }

		INLINE PAGE *NextInBucketList( VOID )
			{ return ((PAGE*) BucketList.Next()); }

		INLINE PAGE *PreviousInBucketList( VOID )
			{ return ((PAGE*) BucketList.Previous()); }

        ~BUCKET_LIST( VOID )
			{ /* void */ };

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        BUCKET_LIST( CONST BUCKET_LIST & Copy );

        VOID operator=( CONST BUCKET_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\cache.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the maximum size of        */
    /*   the cache.                                                     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxCacheSize			  = ((2 << 16)-1);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new allocation cache and prepare it for use.  A       */
    /*   is inactive until the first request is received at which       */
    /*   time it springs into life.                                     */
    /*                                                                  */
    /********************************************************************/

CACHE::CACHE
		( 
		SBIT32						  NewAllocationSize,
		SBIT32						  NewCacheSize,
		SBIT32						  NewChunkSize,
		SBIT32						  NewPageSize,
		BOOLEAN						  NewStealing,
		BOOLEAN						  NewThreadSafe
		) :
		//
		//   Call the constructors for the contained classes.
		//
		BUCKET( NewAllocationSize,NewChunkSize,NewPageSize )
    {
	//
	//   We need to be very careful with the configuration
	//   information as it has come indirectly from the
	//   user and my be bogus.
	//
	if ( (NewCacheSize >= 0) && (NewCacheSize < MaxCacheSize) )
		{
		//
		//   Setup the cache and mark it as inactive.
		//
		Active = False;
		Stealing = NewStealing;
		ThreadSafe = NewThreadSafe;
#ifdef ENABLE_HEAP_STATISTICS

		CacheFills = 0;
		CacheFlushes = 0;
		HighTide = 0;
		HighWater = 0;
		InUse = 0;
#endif

		CacheSize = ((SBIT16) NewCacheSize);
		FillSize = 1;
		NumberOfChildren = 0;

		//
		//   The stacks that may later contain allocations
		//   are set to zero just to be neat.
		//
		DeleteStack = NULL;
		NewStack = NULL;

		TopOfDeleteStack = 0;
		TopOfNewStack = 0;
		}
	else
		{ Failure( "Cache size in constructor for CACHE" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Create the cache stacks.                                       */
    /*                                                                  */
    /*   A cache is created on demand.  We do this when we get the      */
    /*   first allocation or deallocation request.                      */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::CreateCacheStacks( VOID )
	{
	//
	//   We allocate the cache stacks from the internal
	//   new page allocator if we have not done it already.
	//
	if ( DeleteStack == NULL )
		{
		REGISTER SBIT32 Size = (CacheSize * sizeof(ADDRESS_AND_PAGE));

		DeleteStack = 
			((ADDRESS_AND_PAGE*) (NewPage -> NewCacheStack( Size )));
		}

	if ( NewStack == NULL )
		{
		REGISTER SBIT32 Size = (CacheSize * sizeof(VOID*));

		NewStack = 
			((VOID**) (NewPage -> NewCacheStack( Size )));
		}

	//
	//   We can now activate the cache as long as we 
	//   were able to allocate both stacks.
	//
	if ( (NewStack != NULL ) && (DeleteStack != NULL ) )
		{
		//
		//   We have completed creating the cache so set
		//   various flags and zero various counters.
		//
		Active = True;

		//
		//   Setup the fill size.
		//
		FillSize = 1;

		//
		//   Zero the stack tops.
		//
		TopOfDeleteStack = 0;
		TopOfNewStack = 0;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new data page.                                        */
    /*                                                                  */
    /*   When we create a new page we also need to allocate some        */
    /*   memory to hold the associated data.                            */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::CreateDataPage( VOID )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Create a data page.
	//
	NewMemory = ((BUCKET*) this) -> New( True );

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return NewMemory;
	}
#ifdef ENABLE_HEAP_STATISTICS

    /********************************************************************/
    /*                                                                  */
    /*   Compute high water.                                            */
    /*                                                                  */
    /*   Compute the high water mark for the current cache.             */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::ComputeHighWater( SBIT32 Size )
	{
	//
	//   Update the usage statistics.
	//
	if ( (InUse += Size) > HighTide )
		{ 
		HighTide = InUse;
		
		if ( HighTide > HighWater )
			{ HighWater = HighTide; }
		}
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   A memory deallocation cache.                                   */
    /*                                                                  */
    /*   We cache memory deallocation requests to improve performance.  */
    /*   We do this by stacking requests until we have a batch.         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::Delete( VOID *Address,PAGE *Page,SBIT32 Version )
	{
	REGISTER BOOLEAN Result;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   If recycling is allowed and the address is
		//   on the current page or a previous page and
		//   there is space on the new stack then put the
		//   element in the new stack for immediate reuse.
		//
		if 
				(
				(Stealing)
					&&
				(Address < GetCurrentPage())
					&&
				(TopOfNewStack < CacheSize)
				)
			{
			//
			//   The address is suitable for immediate
			//   reuse.  So put it on the stack of new
			//   elements.
			//
			NewStack[ (TopOfNewStack ++) ] = Address;

			Result = True;
			}
		else
			{
			REGISTER ADDRESS_AND_PAGE *Current = 
				(& DeleteStack[ TopOfDeleteStack ++ ]);

			//
			//   The address would best be deleted before
			//   being reused.
			//
			Current -> Address = Address;
			Current -> Page = Page;
			Current -> Version = Version;

			//
			//   When the delete stack is full we flush it.
			//
			if ( TopOfDeleteStack >= CacheSize )
				{
				AUTO SBIT32 Deleted;

				//
				//   Flush the delete stack.
				//
				Result = 
					(
					((BUCKET*) this) -> MultipleDelete
						(
						DeleteStack,
						& Deleted,
						TopOfDeleteStack 
						)
					);
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the usage statistics.  There
				//   is a nasty case here where we cache
				//   a delete only to find out later that
				//   it was bogus.   When this occurs we
				//   have to increase the 'InUse' count 
				//   to allow for this situation.
				//
				CacheFlushes ++;
				
				InUse += (TopOfDeleteStack - Deleted);
#endif

				//
				//   Zero the top of the stack.
				//
				TopOfDeleteStack = 0;
				}
			else
				{ Result = True; }
			}
		}
	else
		{
		//
		//   Delete the element.
		//
		Result = 
			(((BUCKET*) this) -> Delete( Address,Page,Version )); 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	if ( Result )
		{ InUse --; }
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   The entire heap is about to be deleted under our feet.  We     */
    /*   need to prepare for this by disabling the cache as its         */
    /*   contents will disappear as well.                               */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::DeleteAll( VOID )
	{
	//
	//   Disable the cache if needed.
	//
	Active = False;
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Zero the statistics.
	//
	HighTide = 0;
	InUse = 0;
#endif

	//
	//   Setup the fill size.
	//
	FillSize = 1;

	//
	//   Zero the top of stacks.
	//
	TopOfDeleteStack = 0;
	TopOfNewStack = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a data page.                                            */
    /*                                                                  */
    /*   Delete a data page that was associated with a smaller cache    */
    /*   so its space can be reused.                                    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::DeleteDataPage( VOID *Address )
	{
	AUTO SEARCH_PAGE Details;
	REGISTER BOOLEAN Result;
	REGISTER PAGE *Page;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Find the description of the data page we need to 
	//   delete and make sure it is valid.
	//
	Find -> ClaimFindShareLock();

	Page = FindParentPage( Address );

	if ( Page != NULL )
		{ Page = (Page -> FindPage( Address,& Details,False )); }

	Find -> ReleaseFindShareLock();

	//
	//   Delete the data page.
	//
	if ( Page != NULL )
		{ Result = (Page -> Delete( & Details )); }
	else
		{ Failure( "No data page in DeleteDataPage" ); }

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   The allocation cache contains preallocated memory from the     */
    /*   associated allocation bucket.  The cache will supply these     */
    /*   preallocated elements with the minimum fuss to any caller.     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
	{
	REGISTER BOOLEAN Result;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   We have been asked to allocalte multiple
		//   new elements.  If it appears that we don't  
		//   have enough elements available but stealing 
		//   is allowed we can try raiding the deleted 
		//   stack.
		//
		if ( (Requested > TopOfNewStack) && (Stealing) )
			{
			while ( (TopOfDeleteStack > 0) && (TopOfNewStack < CacheSize) )
				{
				NewStack[ (TopOfNewStack ++) ] = 
					(DeleteStack[ (-- TopOfDeleteStack) ].Address);
				}
			}

		//
		//   We will allocate from the cache if requested 
		//   size is smaller than the number of available 
		//   elements.
		//
		if ( Requested <= TopOfNewStack )
			{
			REGISTER SBIT32 Count;

			//
			//   We need to copy the elements out of the
			//   cache into the callers array.
			//
			for ( Count=0;Count < Requested;Count ++ )
				{ Array[ Count ] = NewStack[ (-- TopOfNewStack) ]; }

			(*Actual) = Requested;

			Result = True;
			}
		else
			{
			REGISTER BUCKET *Bucket = ((BUCKET*) this);

			//
			//   We don't have enough elements in the cache 
			//   so we allocate directly from the bucket.
			//
			Result =
				(
				Bucket -> MultipleNew
					( 
					Actual,
					Array,
					Requested
					)
				);

			//
			//   We fill up the cache so we have a good 
			//   chance of dealing with any following 
			//   requests if it is less than half full.
			//
			if ( TopOfNewStack <= (CacheSize / 2) )
				{
				AUTO SBIT32 NewSize;
				REGISTER SBIT32 MaxSize = (CacheSize - TopOfNewStack);

				//
				//   We slowly increse the fill size
				//   of the cache to make sure we don't
				//   waste too much space.
				//
				if ( FillSize < CacheSize )
					{
					if ( (FillSize *= 2) > CacheSize )
						{ FillSize = CacheSize; }
					}

				//
				//   Bulk load the cache with new
				//   elements.
				//
				Bucket -> MultipleNew
					( 
					& NewSize, 
					& NewStack[ TopOfNewStack ],
					((FillSize < MaxSize) ? FillSize : MaxSize)
					);
#ifdef ENABLE_HEAP_STATISTICS

				CacheFills ++;
#endif
				TopOfNewStack += NewSize;
				}
			}
		}
	else
		{
		//
		//   We may want to enable the cache for next
		//   time so see if this needs to be done.
		//
		if ( CacheSize > 1 )
			{ CreateCacheStacks(); }

		//
		//   The cache is disabled so go directly to the
		//   bucket.
		//
		Result = ((BUCKET*) this) -> MultipleNew
			( 
			Actual,
			Array,
			Requested
			);
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (*Actual) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   The allocation cache contains preallocated memory from the     */
    /*   associated allocation bucket.  The cache will supply these     */
    /*   preallocated elements with the minimum fuss to any caller.     */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::New( VOID )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   We first try the stack for new allocations
		//   to see if there are any available elements.
		//
		if ( TopOfNewStack > 0 )
			{ NewMemory = (NewStack[ (-- TopOfNewStack) ]); }
		else
			{
			//
			//   When stealing is allowed we will recycle
			//   elements from the top of the deleted stack.
			//
			if ( (TopOfDeleteStack > 0) && (Stealing) )
				{ NewMemory = (DeleteStack[ (-- TopOfDeleteStack) ].Address); }
			else
				{
				//
				//   We slowly increse the fill size
				//   of the cache to make sure we don't
				//   waste too much space.
				//
				if ( FillSize < CacheSize )
					{
					if ( (FillSize *= 2) > CacheSize )
						{ FillSize = CacheSize; }
					}

				//
				//   We need to bulk load some new  
				//   memory from the heap.
				//
				if 
						( 
						((BUCKET*) this) -> MultipleNew
							( 
							& TopOfNewStack,
							NewStack,
							FillSize
							) 
						)
					{
					//
					//   Update the statistics and return
					//   the top element on the stack.
					//
#ifdef ENABLE_HEAP_STATISTICS
					CacheFills ++;
#endif
					NewMemory = NewStack[ (-- TopOfNewStack) ]; 
					}
				else
					{
					//
					//   Update the statistics and fail
					//   the request for memeory.
					//
					NewMemory = ((VOID*) AllocationFailure);
					}
				}
			}
		}
	else
		{ 
		//
		//   We may want to enable the cache for next
		//   time so see if this needs to be done.
		//
		if ( CacheSize > 1 )
			{ CreateCacheStacks(); }

		//
		//   The cache is disabled so go directly to the
		//   bucket.
		//
		NewMemory = ((BUCKET*) this) -> New( False ); 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (NewMemory != ((VOID*) AllocationFailure)) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	//
	//   Prefetch the first cache line if we are running
	//   a Pentium III or better.
	//
	Prefetch.L1( ((CHAR*) NewMemory),1 );

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation for non-standard sizes.                      */
    /*                                                                  */
    /*   A non standard sized allocation simply by-passes the cache     */
    /*   but it still needs to hold the lock to prevent failure on      */
    /*   SMP systems.                                                   */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::New( BOOLEAN SubDivided,SBIT32 NewSize )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Allocate a non-standard sized block.
	//
	NewMemory = ((BUCKET*) this) -> New( SubDivided,NewSize );
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (NewMemory != ((VOID*) AllocationFailure)) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release free space.                                            */
    /*                                                                  */
    /*   We sometimes do not release free space from a bucket as        */
    /*   returning it to the operating system and getting it again      */
    /*   later is very expensive.  Here we flush any free space we      */
    /*   have aquired over the user supplied limit.                     */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::ReleaseSpace( SBIT32 MaxActivePages )
	{
	//
	//   When there is a potential for multiple threads 
	//   we claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Release the free space from the backet.
	//
	((BUCKET*) this) -> ReleaseSpace( MaxActivePages );

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search the cacahe for an allocation.                           */
    /*                                                                  */
    /*   We sometimes need to search the cache to see if an             */
    /*   allocation is currently in the cacahe awaiting allocation      */
    /*   or release.                                                    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::SearchCache( VOID *Address )
	{
	REGISTER BOOLEAN Result = False;

	//
	//   We check to see if the cache is active.
	//
	if ( Active )
		{
		//
		//   When there is a potential for multiple 
		//   threads we claim the cache lock.
		//
		ClaimCacheLock();

		//
		//   We check to see if the cache is still 
		//   active.
		//
		if ( Active )
			{
			REGISTER SBIT32 Count;

			//
			//   Search the allocated cache.
			//
			for ( Count=(TopOfNewStack-1);Count >= 0;Count -- )
				{ 
				if ( Address == NewStack[ Count ] )
					{
					Result = True;
					break;
					}
				}

			//
			//   If it has not been found yet then try
			//   the deleted cache.
			//
			if ( ! Result )
				{
				//
				//   Search the deleted cache.
				//
				for ( Count=(TopOfDeleteStack-1);Count >= 0;Count -- )
					{ 
					if ( Address == DeleteStack[ Count ].Address )
						{
						Result = True;
						break;
						}
					}
				}
			}

		//
		//   Release any lock we may have claimed earlier.
		//
		ReleaseCacheLock();
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   Flush the cache to release the maximum amount of space back    */
    /*   to the operating system.  This is slow but may be very         */
    /*   valuable in some situations.                                   */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::Truncate( VOID )
	{
	REGISTER BOOLEAN Result = True;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Disable the cache if needed.
	//
	Active = False;

	//
	//   Setup the fill size.
	//
	FillSize = 1;

	//
	//   Flush any elements in the delete cache.
	//   We do this now because we need to use 
	//   the delete cache below.
	//
	if ( TopOfDeleteStack > 0 )
		{
		AUTO SBIT32 Deleted;

		//
		//   Flush the delete stack.
		//
		Result = 
			(
			((BUCKET*) this) -> MultipleDelete
				(
				DeleteStack,
				& Deleted,
				TopOfDeleteStack 
				)
				&&
			(Result)
			);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Update the usage statistics.  There
		//   is a nasty case here where we cache
		//   a delete only to find out later that
		//   it was bogus.   When this occurs we
		//   have to increase the 'InUse' count 
		//   to allow for this situation.
		//
		CacheFlushes ++;
		
		InUse += (TopOfDeleteStack - Deleted);
#endif
		
		//
		//   Zero the top of the stack.
		//
		TopOfDeleteStack = 0;
		}
	
	//
	//   Flush any elements in the new cache by
	//   copying them over to the delete cache
	//   and adding the additional information
	//   required.
	//
	if ( TopOfNewStack > 0 )
		{
		//
		//   We need to find the data page for each  
		//   allocation we have in the new cache.
		//   Claim the lock here to make things a
		//   little more efficient.
		//
		Find -> ClaimFindShareLock();

		//
		//   We copy each allocation across and 
		//   add the associated page information.
		//
		for ( TopOfNewStack --;TopOfNewStack >= 0;TopOfNewStack -- )
			{
			REGISTER VOID *Address = (NewStack[ TopOfNewStack ]);
			REGISTER PAGE *Page = (ParentCache -> FindChildPage( Address ));

			//
			//   You would think that any memory in the
			//   new cache had to be valid.   Well it
			//   does except in the case when we have
			//   'Recycle' set and somebody does a double
			//   delete on a valid heap address.
			//
			if ( Page != NULL )
				{
				REGISTER ADDRESS_AND_PAGE *Current = 
					(& DeleteStack[ TopOfDeleteStack ++ ]);

				//
				//   We need to find the allocation page
				//   where the memory was allocated from
				//   so we can delete it.
				//
				Current -> Address = Address;
				Current -> Page = Page;
				Current -> Version = Page -> GetVersion();
				}
			else
				{ 
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the usage statistics.  There
				//   is a nasty case here where we cache
				//   a delete only to find out later that
				//   it was bogus.   When this occurs we
				//   have to increase the 'InUse' count 
				//   to allow for this situation.
				//
				InUse ++;

#endif
				Result = False; 
				}
			}

		//
		//   Release the lock.
		//
		Find -> ReleaseFindShareLock();
		}

	//
	//   Flush the delete cache again to delete
	//   any new elements that we added to it
	//   above.
	//
	if ( TopOfDeleteStack > 0 )
		{
		AUTO SBIT32 Deleted;

		//
		//   Flush the delete stack.
		//
		Result = 
			(
			((BUCKET*) this) -> MultipleDelete
				(
				DeleteStack,
				& Deleted,
				TopOfDeleteStack 
				)
				&&
			(Result)
			);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Update the usage statistics.  There
		//   is a nasty case here where we cache
		//   a delete only to find out later that
		//   it was bogus.   When this occurs we
		//   have to increase the 'InUse' count 
		//   to allow for this situation.
		//
		CacheFlushes ++;
		
		InUse += (TopOfDeleteStack - Deleted);
#endif
		
		//
		//   Zero the top of the stack.
		//
		TopOfDeleteStack = 0;
		}

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the bucket information.                                 */
    /*                                                                  */
    /*   When we create the bucket there is some information that       */
    /*   is not available.  Here we update the bucket to make sure      */
    /*   it has all the data it needs.                                  */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::UpdateCache
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	//
	//   Notify the parent cache that it has a new
	//   child.
	//
	if ( NewParentCache != ((CACHE*) GlobalRoot) )
		{ NewParentCache -> NumberOfChildren ++; }

	//
	//   Update the allocation bucket.
	//
	UpdateBucket
		( 
		NewFind,
		NewHeap,
		NewPages,
		NewParentCache 
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the cache and ensure it is disabled.                   */
    /*                                                                  */
    /********************************************************************/

CACHE::~CACHE( VOID )
	{
	if ( Active )
		{ Failure( "Cache active in destructor for CACHE" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\cache.hpp ===
#ifndef _CACHE_HPP_
#define _CACHE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Bucket.hpp"
#include "Find.hpp"
#include "NewPage.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The allocation cache.                                          */
    /*                                                                  */
    /*   The memory allocation cache consists of two stacks.  The       */
    /*   first stack contains preallocated elements which are           */
    /*   available for use.  The second stack contains elements         */
    /*   which have been deallocated and are about to be recycled.      */
    /*                                                                  */
    /********************************************************************/

class CACHE : public BUCKET
    {
		//
		//   Private data.
		//
		//   A cache sits on top of a bucket and shields 
		//   it from being swamped by calls.  The 'Active'
		//   flag is set when the cache is active.  The
		//   'Stealing' flag indicates that deallocated
		//   memory can be stolen and reallocated.  The
		//   'ThreadSafe' flag indicates that locking is
		//   required.
		//
		BOOLEAN						  Active;
		BOOLEAN						  Stealing;
		BOOLEAN						  ThreadSafe;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   When we are collecting statistics we enable 
		//   the following variables.  The 'CacheFills' 
		//   count keeps track of the number of times
		//   the cache was filled from the bucket.  The
		//   'CacheFlushes' count keeps track of the 
		//   number of times the cache flushed deleted
		//   elements to the bucket.  The 'HighTide' count  
		//   keeps track the the highest number of outstanding
		//   allocations since the last "DeleteAll()'.  The 
		//   'HighWater' count keeps track of the maximum 
		//   number of allocations at any point.  The
		//   'InUse' counts the the current number of outstanding 
		//   allocations.
		//
		SBIT32						  CacheFills;
		SBIT32						  CacheFlushes;
		SBIT32						  HighTide;
		SBIT32						  HighWater;
		SBIT32						  InUse;
#endif

		//
		//   A cache can be controlled by the user.  The
		//   'CacheSize' controls the number of allocations
		//   that can be preallocated or queued for 
		//   deletion.  The 'NumberOfChildren' is a count
		//   of the number of caches that allocate space
		//   from this cache.
		//
		SBIT16						  CacheSize;
		SBIT16						  FillSize;
		SBIT16						  NumberOfChildren;

		//
		//   The cache consists of two stacks.  The
		//   'DeleteStack' contains elements that are 
		//   waiting to be deleted.  The 'NewStack' 
		//   contains elements waiting to be allocated.
		//
		ADDRESS_AND_PAGE			  *DeleteStack;
		VOID						  **NewStack;

		//
		//   The top of the deleted stack is kept in
		//   'TopOfDeleteStack' and the top of the new
		//   stack is kept in 'TopOfNewStack'.
		//
		SBIT32						  TopOfDeleteStack;
		SBIT32						  TopOfNewStack;

		//
		//   The 'Spinlock' is a fast lock employed to
		//   make the cache multi-threaded if 'ThreadSafe'
		//   is true.
		//   
		SPINLOCK					  Spinlock;

   public:
		//
		//   Public functions.
		//
		//   The cacahe is a subset of the full haep interface
		//   a certain calls simply bypass it.  However, there
		//   are a few additional functions for cases where the
		//   cache needs to be notified of significant heap
		//   events.
		//
        CACHE
			( 
			SBIT32					  NewAllocationSize,
			SBIT32					  NewCacheSize,
			SBIT32					  NewChunkSize,
			SBIT32					  NewPageSize,
			BOOLEAN					  NewStealing,
			BOOLEAN					  NewThreadSafe
			);

		VOID *CreateDataPage( VOID );

		BOOLEAN Delete( VOID *Address,PAGE *Page,SBIT32 Version );

		VOID DeleteAll( VOID );

		BOOLEAN DeleteDataPage( VOID *Address );

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested 
			);

		VOID *New( VOID );

		VOID *New( BOOLEAN SubDivided,SBIT32 NewSize = NoSize );

		VOID ReleaseSpace( SBIT32 MaxActivePages );

		BOOLEAN SearchCache( VOID *Address );

		BOOLEAN Truncate( VOID );

		VOID UpdateCache
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~CACHE( VOID );

		//
		//   Public inline functions.
		//
		//   A cache just like its parent bucket is closely
		//   coupled to various other classes and provides
		//   then is vital information.
		//
		INLINE VOID ClaimCacheLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ClaimLock(); } 
			}

		INLINE PAGE *FindChildPage( VOID *Address )
			{
			return Find -> FindPage
				( 
				((VOID*) (((BIT32) Address) & ~(GetAllocationSize()-1))),
				(CACHE*) this
				); 
			}

		INLINE PAGE *FindParentPage( VOID *Address )
			{
			return Find -> FindPage
				( 
				((VOID*) (((BIT32) Address) & ~(GetPageSize()-1))),
				ParentCache
				); 
			}

		INLINE SBIT16 GetCacheSize( VOID )
			{ return CacheSize; }

		INLINE SBIT32 GetNumberOfChildren( VOID )
			{ return NumberOfChildren; }

		INLINE VOID ReleaseCacheLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ReleaseLock(); } 
			}

		INLINE BOOLEAN Walk( SEARCH_PAGE *Details )
			{ return NewPage -> Walk( Details ); }
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Cache statistics.
		//
		//   A cache has a collection statistics which it
		//   uses to measure how it is doing.  It is possible
		//   to get access to this data for the purpose of
		//   outputing various reports.
		//
		INLINE SBIT32 GetCacheFills( VOID )
			{ return CacheFills; }

		INLINE SBIT32 GetCacheFlushes( VOID )
			{ return CacheFlushes; }

		INLINE SBIT32 GetHighWater( VOID )
			{ return HighWater; }
#endif

	private:
		//
		//   Private functions.
		//
		//   A cache is initially inactive.  If at least one
		//   allocation request is made it will spring into
		//   life, allocate any space needed and prepare itself
		//   for use.
		//
		VOID CreateCacheStacks( VOID );
#ifdef ENABLE_HEAP_STATISTICS

		VOID ComputeHighWater( SBIT32 Size );
#endif

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        CACHE( CONST CACHE & Copy );

        VOID operator=( CONST CACHE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\passport\session.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    session.h

Abstract:

    This interface abstracts a Passport Session.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef SESSION_H
#define SESSION_H

class SESSION
{
public:
    static
    BOOL CreateObject(PCWSTR pwszHttpStack,  HINTERNET hSession, SESSION*& pSess);

public:
    SESSION(void);
    virtual ~SESSION(void);

    UINT GetSessionId(void) const { return m_SessionId; }
    BOOL Match(UINT SessionId) const { return SessionId == m_SessionId; }

    void AddRef(void) { ++m_RefCount; }
    
    void RemoveRef(void) 
    {
        if (m_RefCount > 0)
        {
            --m_RefCount;
        }
    }

    UINT RefCount(void) const { return m_RefCount; }

    // methods to retrieve the registry-configured value

    // PCWSTR GetLoginHost(void) const { return m_wDAHostName; }
    // PCWSTR GetLoginTarget(void) const { return m_wDATargetObj; }
    PCWSTR GetRegistrationUrl(void) const { return m_wRegistrationUrl; }
    
    BOOL GetDAInfoFromPPNexus(
        IN PWSTR            pwszRegUrl,    // user supplied buffer ...
        IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                        // on successful return)
        IN PWSTR            pwszDARealm,    // user supplied buffer ...
        IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        );

    BOOL GetDAInfo(PCWSTR pwszSignIn,
                   LPWSTR pwszDAHostName,
                   DWORD HostNameLen,
                   LPWSTR pwszDAHostObj,
                   DWORD HostObjLen);

    BOOL UpdateDAInfo(
        PCWSTR pwszSignIn,
        PCWSTR pwszDAUrl
        );

    void Logout(void);

    BOOL IsLoggedOut(void) const;

    const SYSTEMTIME* GetLogoutTimeStamp(void) const;

    void ResetLogoutFlag(void);
    
    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET) = 0;
    virtual void Close(void) = 0;

    // methods below abstracts a subset of WinInet/WinHttp functionalities.

    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT) = 0;

    virtual HINTERNET OpenRequest(
        HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0) = 0;

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0) = 0;

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL) = 0;

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet) = 0;

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength) = 0;    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength) = 0;

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags) = 0;

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead) = 0;

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents) = 0;

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        ) = 0;

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        ) = 0;


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR  pwszData,
                                PDWORD pdwDataLength
                                ) = 0;
#endif // PP_DEMO

protected:
    static UINT m_SessionIdSeed;

    HMODULE     m_hHttpStack;
    HMODULE     m_hCredUI;
    UINT        m_SessionId;
    BOOL        m_fOwnedSession;
    UINT        m_RefCount;

    // WCHAR       m_wDAHostName[256];
    // WCHAR       m_wDATargetObj[64];
    WCHAR       m_wRegistrationUrl[256];

    PFN_READ_DOMAIN_CRED_W
                m_pfnReadDomainCred;
    PFN_CRED_FREE m_pfnCredFree;

    HKEY m_hKeyLM;
    HKEY m_hKeyCU;
    HKEY m_hKeyDAMap;
    WCHAR m_wDefaultDAUrl[1024];

    DWORD m_LastNexusDownloadTime;

    BOOL        m_fLogout;
    SYSTEMTIME  m_LogoutTimeStamp;

    friend class LOGON;
};

#endif // SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\connections.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Connections.hpp"
#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   There are a variety of connections that need to be made        */
    /*   after all the classes are ready for use.  However, we          */
    /*   initially zero all these connection pointers until we are      */
    /*   ready to link everything.                                      */
    /*                                                                  */
    /********************************************************************/

CONNECTIONS::CONNECTIONS( VOID )
    {
	Active = False;

	Find = NULL;
	Heap = NULL;
	NewPage = NULL;
	ParentCache = NULL;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the connections.                                        */
    /*                                                                  */
    /*   When we create an allocator there is some information that     */
    /*   is not available.  Here we update the connection information   */
    /*   so we can locate the correct instances of various other        */
    /*   classes.                                                       */
    /*                                                                  */
    /********************************************************************/

VOID CONNECTIONS::UpdateConnections
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	//
	//   We typically only need to update the connections once
	//   but in some situations multiple updates can occur.  If
	//   this is the case we carefully check the update is 
	//   consistent with the previous update.
	//
	if ( ! Active )
		{
		//
		//   We now have the information we need to update the 
		//   connections.
		//
		Active = True;
		Find = NewFind;
		Heap = NewHeap;
		NewPage = NewPages;
		ParentCache = NewParentCache;
		}
	else
		{
		//
		//   Nasty, we have already updated the connections once.  
		//   Since we have been called again we know this node 
		//   must be shared between two heaps.  We can deal with  
		//   this as long as selected pointers are the same.
		//
		if 
				(
				(Find != NewFind)
					||
				(NewPage != NewPages)
					||
				(ParentCache != NewParentCache)
				)
			{ Failure( "Sharing violation in UpdateConnections" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the connections.                                       */
    /*                                                                  */
    /********************************************************************/

CONNECTIONS::~CONNECTIONS( VOID )
    {
	Active = False;

	Find = NULL;
	Heap = NULL;
	NewPage = NULL;
	ParentCache = NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\connections.hpp ===
#ifndef _CONNECTIONS_HPP_
#define _CONNECTIONS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "NewPage.hpp"
#include "Prefetch.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   At the top level the parent of all caches is a constant        */
    /*   called 'GlobalRoot'.                                           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 GlobalRoot				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;
class PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   We communicate between a page and the associated cache         */
    /*   using an address pointer, page pointer and version triple.     */
    /*                                                                  */
    /********************************************************************/

typedef struct
	{
	VOID							  *Address;
	PAGE							  *Page;
	SBIT32							  Version;
	}
ADDRESS_AND_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Connections to other classes.                                  */
    /*                                                                  */
    /*   The connections between the various classes in the memory      */
    /*   allocator is a twisted mess.  The root cause is that at a      */
    /*   fundamental level.  Every part depends on every other part.    */
    /*   Nonetheless, a significant effort has been made to seperate    */
    /*   the parts as best as possible.  The various classes are        */
    /*   linked here so every part can find the correct instance of     */
    /*   every other part.                                              */
    /*                                                                  */
    /********************************************************************/

class CONNECTIONS : public ENVIRONMENT, public COMMON
    {
		//
		//   Private data.
		//
		BOOLEAN						  Active;

   public:
		//
		//   Public data.
		//
		//   All the classes that inherit this class get
		//   pointers to related classes they need to call
		//   from time to time. 
		//
		FIND                          *Find;
		HEAP                          *Heap;
		NEW_PAGE					  *NewPage;
		CACHE						  *ParentCache;

		//
		//   The 'Prefetch' is a class that will trigger
		//   a cache fetch if the CPU supports it.
		//   
		PREFETCH					  Prefetch;

        //
        //   Public functions.
		//
		//   The sole job of this class is to provide 
		//   pointers to related classes.  These pointers
		//   are unknown until after the heap has been
		//   created and this need to be dynamically
		//   linked during the execution of the top 
		//   level heap constructor.
        //
        CONNECTIONS( VOID );

		VOID UpdateConnections
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~CONNECTIONS( VOID );

		//
		//   Public inline functions.
		//
		//   The complex linkages in the heap sometimes 
		//   lead to the case where a class has a pointer
		//   to it's cache but not to the class it needs
		//   to call.  Thus, to avoid replicating large
		//   numbers of pointers we export call interfaces
		//   from here to allow the required calls to be
		//   made indirectly.
		//
		INLINE VOID DeleteFromFindList( PAGE *Page )
			{ Find -> DeleteFromFindList( Page ); }

		INLINE VOID DeletePage( PAGE *Page )
			{ NewPage -> DeletePage( Page ); }

		INLINE HEAP *GetHeap( VOID )
			{ return Heap; }

		INLINE CACHE *GetParentCache( VOID )
			{ return ParentCache; }

		INLINE VOID InsertInFindList( PAGE *Page )
			{ Find -> InsertInFindList( Page ); }

		INLINE BOOLEAN TopCache( VOID )
			{ return (ParentCache == ((CACHE*) GlobalRoot)); }

	private:
        //
        //   Disabled operations.
        //
        CONNECTIONS( CONST CONNECTIONS & Copy );

        VOID operator=( CONST CONNECTIONS & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\findlist.hpp ===
#ifndef _FIND_LIST_HPP_
#define _FIND_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "BucketList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The find list.                                                 */
    /*                                                                  */
    /*   The find list links all the pages in the same hash bucket      */
    /*   together so that the correct page can be found.                */
    /*                                                                  */
    /********************************************************************/

class FIND_LIST : public BUCKET_LIST
    {
		//
		//   Private data.
		//
 		LIST						  FindList;

   public:
		//
		//   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
		//
        FIND_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromFindList( LIST *HeadOfList )
			{ FindList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfFindList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInFindList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> First()) ); }

		INLINE VOID InsertInFindList( LIST *HeadOfList )
			{ FindList.Insert( HeadOfList ); }

		INLINE PAGE *NextInFindList( VOID )
			{ return ComputePageAddress( ((CHAR*) FindList.Next()) ); }

        ~FIND_LIST( VOID )
			{ /* void */ };

	private:
		//
		//   Private functions.
		//
		//   Compute the actual start address of the page
		//   and return it to allow the linked list to
		//   be correctly walked.
		//
		STATIC INLINE PAGE *ComputePageAddress( CHAR *Address )
			{
			if ( Address != NULL )
				{ return ((PAGE*) (Address - sizeof(BUCKET_LIST))); }
			else
				{ return ((PAGE*) NULL); }
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FIND_LIST( CONST FIND_LIST & Copy );

        VOID operator=( CONST FIND_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\find.hpp ===
#ifndef _FIND_HPP_
#define _FIND_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "List.hpp"
#include "Page.hpp"
#include "Prefetch.hpp"
#include "Rockall.hpp"
#include "Sharelock.hpp"
#include "Spinlock.hpp"
#include "Tls.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Find a memory allocation.                                      */
    /*                                                                  */
    /*   When a memory allocation is released all we are given is .     */
    /*   the allocation address.  This is not very helpful as the       */
    /*   allocation information is not stored relative to this          */
    /*   address.  Instead we use a hash table to map the allocation    */
    /*   address to the allocation information.                         */
    /*                                                                  */
    /********************************************************************/

class FIND : public ENVIRONMENT, public COMMON
    {
		//
		//   Private type specifications.
		//
		//   We need to do a recursive search in the find 
		//   table in order to locate the associated page
		//   from an address.  As this is expensive there
		//   is also a cache that slaves common translations
		//   to improve performance.
		//
		typedef struct
			{
			VOID					  *Address;
			PAGE					  *Page;
#ifdef DEBUGGING
			SBIT32					  Version;
#endif
			}
		LOOK_ASIDE;

		//
		//   Private data.
		//
		//   All the page descriptions are stored in the 
		//   hash table so they can be quickly found.  The
		//   key is the address of the first byte on the
		//   page.  The 'MaxHash' is the number of elements
		//   in the hash table and is always a power of two.
		//   The 'HashMask' is a bit mask to remove any 
		//   unwanted part of the hash key.  The 'HashShift'
		//   is the number of bits required to shift and is
		//   as a substitute for divide.  The 'Resize' flag
		//   indicates whether the hash table is permitted 
		//   to grow.
		//
		SBIT32						  MaxHash;

		SBIT32						  HashMask;
		SBIT32						  HashShift;
		BOOLEAN						  Resize;

		//
		//   The hash table allows addresses to be mapped to
		//   page descriptions quickly.  Nonetheless, it is 
		//   not fast enough.  To enhance performance a look
		//   aside cache slaves the hottest translations.  The
		//   'MaxLookAside' is the number of elements in the
		//   cache.  The 'MaxAddressMask' is a mask that removes 
		//   low order bits of an address and represents the
		//   span of each cache entry.  The 'LookAsideActions'
		//   is a simple count of requests to the cache.  The
		//   'LookAsideMask' and 'LookAsideShift' parallel the
		//   fields above in the hash table.  The 'LookAsideThreshold'
		//   determines at what point the cache will become 
		//   active.  The 'ThreadSafe' flag indicates whether
		//   locking is required.
		//
		SBIT32						  MaxLookAside;

		BIT32						  MaxAddressMask;
		BIT32						  MinAddressMask;

		SBIT32						  LookAsideActions;
		SBIT32						  LookAsideMask;
		SBIT32						  LookAsideShift;
		SBIT32						  LookAsideThreshold;
		BOOLEAN						  ThreadSafe;

		//
		//   When a request is made to translate an address to
		//   a page description the cache is the first port of
		//   call.  If the translation is not found then the
		//   hash table is tried.  The 'Hash' points to the hash
		//   table.  The 'LookAside' points to the lookaside
		//   hash table.  The 'Rockall' points to the external API
		//   to give access to the low level external allocation
		//   functions.  
		//
		LIST						  *Hash;
		LOOK_ASIDE					  *LookAside;
		ROCKALL						  *Rockall;

		//
		//   The translation of addresses to page descriptions
		//   is very common.  So care has been taken to ensure
		//   it is not a bottleneck when locking is enabled.  The
		//   'Sharelock' is a fast reader/writer lock and is used
		//   almost all the time.  The 'Spinlock' is an exclusive
		//   lock and is only used when the 'Hash' and 'LookAside'
		//   tables are resized.
		//
		PREFETCH					  Prefetch;
		SHARELOCK					  Sharelock;
		SPINLOCK					  Spinlock;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Statistics data.
		//
		//   There is a concern with any hash table about
		//   poor hashing keys and poor performance.  The
		//   statistics monitor various data so as to allow
		//   the performance metrics to be monitored.  The
		//   'Fills' counter keeps track of the number of
		//   cache fills.  The 'Hits' counter monitors the
		//   number of cache hits.  The 'MaxPages' counter
		//   is the high water mark of hash table entries.
		//   The 'MaxTests' is the max number of compares 
		//   done while searching an entry.  The 'Misses' 
		//   counter keeps track of the number of cache misses.
		//   The 'Scans' counter monitors the number of hash
		//   table searches.  The 'Tests' counter is the 
		//   total number of tests performed while searching
		//   for entries.
		//
		SBIT32						  Fills;
		SBIT32						  Hits;
		SBIT32						  MaxPages;
		SBIT32						  MaxTests;
		SBIT32						  Misses;
		SBIT32						  Scans;
		SBIT32						  Tests;
#endif
		SBIT32						  Used;
#ifndef ENABLE_RECURSIVE_LOCKS

		//
		//   Static private data.
		//
		//   It is not uncommon for developers to have some
		//   form of bias.  I dislike recursive locks so here
		//   I introduce a TLS value to indicate whether the
		//   current thread has a global lock.  If so all
		//   locking in the other classes is disabled.
		//
		STATIC THREAD_LOCAL_STORE	  LockCount;
#endif

   public:
		//
		//   Public functions.
		//
		//   The translation functionality supplied by this
		//   class is only applicable after an allocation
		//   has been made.  Hence, all of the APIs supported
		//   relate to the need to translate an allocation
		//   address to the host page description.
		//
        FIND
			( 
			SBIT32					  NewMaxHash,
			SBIT32					  NewMaxLookAside,
			SBIT32					  NewFindThreshold,
			ROCKALL					  *NewRockall,
			BOOLEAN					  NewResize,
			BOOLEAN					  NewThreadSafe 
			);

		BOOLEAN Delete( VOID *Address,CACHE *ParentCache );

		VOID DeleteFromFindList( PAGE *Page );

		BOOLEAN Details
			( 
			VOID					  *Address,
			SEARCH_PAGE				  *Details,
			CACHE					  *ParentCache,
			SBIT32					  *Size 
			);

		PAGE *FindPage( VOID *Address,CACHE *ParentCache );

		VOID InsertInFindList( PAGE *Page );

		BOOLEAN KnownArea( VOID *Address,CACHE *ParentCache );

		VOID ReleaseFindShareLockAndUpdate
			( 
			VOID					  *Address,
			PAGE					  *Page,
			SBIT32					  Version 
			);

		BOOLEAN Walk
			( 
			BOOLEAN					  *Active,
			VOID					  **Address,
			CACHE					  *ParentCache,
			SBIT32					  *Size 
			);

		VOID UpdateFind
			( 
			BIT32					  NewMaxAddressMask,
			BIT32					  NewMinAddressMask
			);

        ~FIND( VOID );

		//
		//   Public inline functions.
		//
		//   Although this class is perhaps the most self
		//   contained.  Nonetheless, there is still lots
		//   of situations when other classes need to 
		//   interact and get information about the current
		//   situation.
		//
		INLINE VOID ClaimFindExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ClaimExclusiveLock(); } 
			}

		INLINE VOID ClaimFindShareLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ClaimShareLock(); } 
			}

		INLINE VOID DeleteAll( VOID )
			{ LookAsideActions = 0; }

		INLINE VOID ReleaseFindExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ReleaseExclusiveLock(); } 
			}

		INLINE VOID ReleaseFindShareLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ReleaseShareLock(); } 
			}

		//
		//   Static public inline functions.
		//
		//   There is a strong case for removing the lock
		//   count functionality from this class.  However,
		//   as it consists of a single declaration and the
		//   following inline functions I have not been
		//   driven to fix this yet.  Maybe some day. 
		//
#ifndef ENABLE_RECURSIVE_LOCKS
		STATIC INLINE VOID DecrementLockCount( VOID )
			{ 
			LockCount.SetPointer
				( 
				((VOID*) (((SBIT32) LockCount.GetPointer()) - 1))
				);
			}

		STATIC INLINE SBIT32 GetLockCount( VOID )
			{ return ((SBIT32) LockCount.GetPointer()); }

		STATIC INLINE VOID IncrementLockCount( VOID )
			{ 
			LockCount.SetPointer
				( 
				((VOID*) (((SBIT32) LockCount.GetPointer()) + 1))
				);
			}
#else
		STATIC INLINE VOID DecrementLockCount( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 GetLockCount( VOID )
			{ return 0; }

		STATIC INLINE VOID IncrementLockCount( VOID )
			{ /* void */ }
#endif

#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Public inline statistic functions.
		//
		//   The statistics are typically provided in 
		//   debug builds to provide good information  
		//   about allocation patterns.  
		//
		INLINE SBIT32 AverageHashLength( VOID )
			{ return (Tests / ((Scans > 0) ? Scans : 1)); }

		INLINE SBIT32 CacheFills( VOID )
			{ return Fills; }

		INLINE SBIT32 CacheHits( VOID )
			{ return Hits; }

		INLINE SBIT32 CacheMisses( VOID )
			{ return Misses; }

		INLINE SBIT32 MaxHashLength( VOID )
			{ return MaxTests; }

		INLINE SBIT32 MaxHashSize( VOID )
			{ return MaxHash; }

		INLINE SBIT32 MaxLookAsideSize( VOID )
			{ return MaxLookAside; }

		INLINE SBIT32 MaxUsage( VOID )
			{ return ((MaxPages * 100) / MaxHash); }

		INLINE SBIT32 TotalScans( VOID )
			{ return Scans; }
#endif

	private:
		//
		//   Private functions.
		//
		//   Although the hashed lookup functionality is 
		//   externally visable the look aside cache is 
		//   hidden from view along with the ability to
		//   resize the hash table.
		//
		BOOLEAN FindLookAside( VOID *Address,PAGE **Page );

		VOID ResizeHashTable( VOID );

		//
		//   Private inline functions.
		//
		//   Although I am not keen on code in the headers
		//   certain functions are so small or so hot that
		//   I have to submit to the desire to do it. 
		//
		INLINE VOID ChangeToExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ChangeSharedLockToExclusiveLock(); } 
			}

		INLINE LIST *FindHashHead( VOID *Address )
			{
			REGISTER BIT32 Value = (((BIT32) Address) * 2964557531);

			return (& Hash[ ((Value >> HashShift) & HashMask) ]); 
			}

		INLINE LOOK_ASIDE *FindLookAsideHead( VOID *Address )
			{
			REGISTER BIT32 Value = (((BIT32) Address) * 2964557531);

			return (& LookAside[ ((Value >> LookAsideShift) & LookAsideMask) ]); 
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FIND( CONST FIND & Copy );

        VOID operator=( CONST FIND & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\find.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the size of the hash       */
    /*   table and other related features.                              */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinHash				  = 1024;
CONST SBIT32 MinHashSpace			  = (100/25);
CONST SBIT32 MinLookAside			  = 128;

CONST BIT32 NoAddressMask			  = ((BIT32) -1);
CONST SBIT32 NoCacheEntry			  = -1;

#ifndef ENABLE_RECURSIVE_LOCKS
    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

THREAD_LOCAL_STORE FIND::LockCount;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create the hash table and initialize it ready for use. The     */
    /*   configuration information supplied from the parameters needs   */
    /*   to be carefully checked as it has come indirectly from the     */
    /*   user and may be bogus.                                         */
    /*                                                                  */
    /********************************************************************/

FIND::FIND
		( 
		SBIT32						  NewMaxHash,
		SBIT32						  NewMaxLookAside,
		SBIT32						  NewFindThreshold,
		ROCKALL						  *NewRockall,
		BOOLEAN						  NewResize, 
		BOOLEAN						  NewThreadSafe 
		)
    {
	REGISTER SBIT32 AlignMask = (NewRockall -> NaturalSize()-1);

	//
	//   We need to make sure that the size of the hash table
	//   makes sense.  The hash table size needs to be a reasonable
	//   size (say 1k or larger) and a power of 2 (so we don't need
	//   to do any divides).
	//   
	if 
			(
			PowerOfTwo( (AlignMask+1) )
				&&
			(NewFindThreshold >= 0 )
				&&
			(NewMaxHash >= MinHash) 
				&&
			(ConvertDivideToShift( NewMaxHash,& HashMask ))
				&& 
			(NewMaxLookAside >= MinLookAside) 
				&& 
			(ConvertDivideToShift( NewMaxLookAside,& LookAsideMask ))
			)
		{
		REGISTER SBIT32 HashSize = (NewMaxHash * sizeof(LIST));
		REGISTER SBIT32 LookAsideSize = (NewMaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

		//
		//   Set up the hash table.
		//
		MaxHash = NewMaxHash;

		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);
		Resize = NewResize;

		//
		//   Set up the lookaside table.
		//
		MaxLookAside = NewMaxLookAside;

		MaxAddressMask = NoAddressMask;
		MinAddressMask = NoAddressMask;

		LookAsideActions = 0;
		LookAsideShift = (32-LookAsideMask);
		LookAsideMask = ((1 << LookAsideMask)-1);
		LookAsideThreshold = NewFindThreshold;

		ThreadSafe = NewThreadSafe;

		//
		//   Create some space for the find table and the 
		//   look aside table.
		//
		Hash = ((LIST*) NewRockall -> NewArea( AlignMask,TotalSize,False ));
		LookAside = ((LOOK_ASIDE*) & Hash[ MaxHash ]);
		Rockall = NewRockall;

		//
		//   If the memory allocation request for the hash
		//   table fails we are doomed.  If it works we need
		//   to call the constructor for each linked list
		//   head node.
		//
		if ( Hash != ((LIST*) AllocationFailure) )
			{
			REGISTER SBIT32 Count;

			//
			//   Call the constructor for each hash table
			//   linked list header.
			//
			for ( Count=0;Count < NewMaxHash;Count ++ )
				{ PLACEMENT_NEW( & Hash[ Count ],LIST ); }

			//
			//   Zero the look aside structures.  We need
			//   to do this to ensure they do not match a
			//   valid allocation address later.
			//
			for ( Count=0;Count < MaxLookAside;Count ++ )
				{
				REGISTER LOOK_ASIDE *Current = & LookAside[ Count ];

				Current -> Address = ((VOID*) NoCacheEntry);
				Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
				Current -> Version = ((SBIT32) NoCacheEntry);
#endif
				}
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Zero the statistics information.
			//
			Fills = 0;
			Hits = 0;
			MaxPages = 0;
			MaxTests = 0;
			Misses = 0;
			Scans = 0;
			Tests = 0;
#endif
			Used = 0;
			}
		else
			{ Failure( "Create hash fails in constructor for FIND" ); }
		}
	else
		{ Failure( "Hash table size in constructor for FIND" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a memory allocation.                                    */
    /*                                                                  */
    /*   We need to delete a particular memory allocation.  All         */
    /*   we have is an address.  We use this to find the largest        */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation we need to delete.                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Delete( VOID *Address,CACHE *ParentCache )
    {
	REGISTER PAGE *Page;
	REGISTER BOOLEAN Update;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Lets try the lookaside table.  There is a pretty
	//   good chance that we will have the details we need 
	//   already in the cache.  If not we need to find it
	//   the hard way.  During the process we add the mapping
	//   into the lookaside for next time.
	//
	if
			( 
			Update = 
				(
				! FindLookAside
					( 
					((VOID*) (((LONG) Address) & ~MinAddressMask)),
					& Page 
					)
				)
			)
		{
		//
		//   Find the allocation page and get the details of entry.
		//   We do this by finding the parent of the top cache.
		//   We  know that this is the global root and will find
		//   the correct page even if it is on another heap (as
		//   long as the find table is globally shared).
		//
		Page = (ParentCache -> FindParentPage( Address ));

		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Address,NULL,True )); }
		}

	//
	//   We may have failed to find the address.  If so
	//   we simply fail the call.  If not we put the deleted 
	//   element back in the associated cache.
	//
	if ( Page != ((PAGE*) NULL) )
 		{
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Original = (Page -> GetVersion());

		//
		//   Prefetch the class data if we are running a
		//   Pentium III or better with locks.  We do this
		//   because prefetching hot SMP data structures
		//   really helps.  However, if the structures are
		//   not shared (i.e. no locks) then it is worthless
		//   overhead.
		//
		if ( ThreadSafe )
			{ Prefetch.Nta( ((CHAR*) Cache),sizeof(CACHE) ); }

		//
		//   Release the lock if we claimed it earlier and
		//   update the lookaside if needed.
		//
		if ( Update )
			{ ReleaseFindShareLockAndUpdate( Address,Page,Original ); }
		else
			{ ReleaseFindShareLock(); }

		//
		//   We have found the associated page description
		//   so pass the delete request along to the cache
		//   and get out of here.
		//
		return (Cache -> Delete( Address,Page,Original ));
		}
	else
		{ 
		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindShareLock();

		return False; 
		}
  }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an item from the find table.                            */
    /*                                                                  */
    /*   We need to delete page from the find list.  We expect          */
    /*   this to take quite a while as multiple threads can be          */
    /*   using this class at the same time.                             */
    /*                                                                  */
    /********************************************************************/

VOID FIND::DeleteFromFindList( PAGE *Page )
	{
	REGISTER VOID *Address = (Page -> GetAddress());

	//
	//   Claim an exclusive lock so we can update the 
	//   hash and lookaside as needed.
	//
	ClaimFindExclusiveLock();

	//
	//   Delete the page from the hash table.
	//
	Page -> DeleteFromFindList( FindHashHead( Address ) );

	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER SBIT32 Count;
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Stride = (Cache -> GetAllocationSize());

		//
		//   We are about look up various look aside entries
		//   and delete any that are stale.  We need to do
		//   this for every lookaside slot that relates to
		//   the page.  If the allocation size is smaller
		//   than the lookaside slot size we can save some
		//   iterations by increasing the stride size.
		//
		if ( Stride <= ((SBIT32) MinAddressMask) )
			{ Stride = ((SBIT32) (MinAddressMask+1)); }

		//
		//   Whenever we delete an entry from the hash table
		//   the lookaside is potentially corrupt.  So we 
		//   need to delete any look aside entries relating
		//   to this page.
		//
		for ( Count=0;Count < Cache -> GetPageSize();Count += Stride )
			{
			REGISTER VOID *Segment = 
				((VOID*) ((((LONG) Address) + Count) & ~MinAddressMask));
			REGISTER LOOK_ASIDE *Current = 
				(FindLookAsideHead( Segment ));

			//
			//   Delete the look aside entry if it is stale.
			//
			if ( Segment == Current -> Address )
				{
				Current -> Address = ((VOID*) NoCacheEntry);
				Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
				Current -> Version = ((SBIT32) NoCacheEntry);
#endif
				}
			}
		}

	//
	//   Update the statistics.
	//
	Used --;

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Details of a memory allocation.                                */
    /*                                                                  */
    /*   We need to the details of a particular memory allocation.      */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.                                           */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Details
		( 
		VOID						  *Address,
		SEARCH_PAGE					  *Details,
		CACHE						  *ParentCache,
		SBIT32						  *Size 
		)
    {
	REGISTER PAGE *Page;
	REGISTER BOOLEAN Result;
	REGISTER BOOLEAN Update;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Lets try the lookaside table.  There is a pretty
	//   good chance that we will have the deatils we need 
	//   already in the cache.  If not we need to find it
	//   the hard way.  During the process we add the mapping
	//   into the lookaside for next time.
	//
	if
			( 
			Update = 
				(
				! FindLookAside
					( 
					((VOID*) (((LONG) Address) & ~MinAddressMask)),
					& Page 
					)
				)
			)
		{
		//
		//   Find the allocation page and get the details of entry.
		//   We do this by finding the parent of the top cache.
		//   We  know that this is the global root and will find
		//   the correct page even if it is on another heap (as
		//   long as the find table is globally shared).
		//
		Page = (ParentCache -> FindParentPage( Address ));

		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Address,Details,True )); }
		}
	else
		{
		//
		//   We may need to provide the all the details of the
		//   allocation for some reason.
		//
		if ( Details != NULL )
			{ Page = (Page -> FindPage( Address,Details,True )); }
		}

	//
	//   We may have failed to find the address.  If so
	//   we simply fail the call.  If not we extract the 
	//   information we want.
	//
	if ( Result = (Page != ((PAGE*) NULL)) )
 		{
		//
		//   Compute the size.  We would normally expect
		//   this to be the cache size.  However, there
		//   are some weird pages that sometimes have
		//   other sizes.
		//
		(*Size) = (Page -> ActualSize());
		}

	//
	//   Release the lock if we claimed it earlier and 
	//   update the lookaside if needed.
	//
	if ( (Update) && (Result) )
		{ ReleaseFindShareLockAndUpdate( Address,Page,Page -> GetVersion() ); }
	else
		{ ReleaseFindShareLock(); }

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find in the look aside.                                        */
    /*                                                                  */
    /*   We need to find a particular page in the look aside.  So we    */
    /*   try a simple look up (no lists or chains).                     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::FindLookAside( VOID *Address,PAGE **Page )
    {
	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER LOOK_ASIDE *Current = FindLookAsideHead( Address );

		//
		//   We have hashed to a lookaside slot.  Maybe
		//   it contains what we want or maybe not.
		//
		if ( Address == Current -> Address )
			{
#ifdef DEBUGGING
			if ( Current -> Version == (Current -> Page -> GetVersion()) )
				{
#endif
				//
				//   We hit the lookaside and the 
				//   contents are valid.
				//
				(*Page) = (Current -> Page);
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the statistics.
				//
				Hits ++;
#endif

				return True;
#ifdef DEBUGGING
				}
			else
				{ Failure( "Deleted page in FindLookAside" ); }
#endif
			}
		}
	else
		{
		//
		//   We update number of times we tried to
		//   use the lookaside and it was disabled.  
		//   After a while this will lead to the 
		//   lookaside being enabled.
		//
		LookAsideActions ++; 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   We missed the lookaside so update the 
	//   statistics to reflect our misfortune.
	//
	Misses ++;
#endif

	return False; 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find a page.                                                   */
    /*                                                                  */
    /*   We need to find a particular page in the hash table.  So we    */
    /*   scan along the associated linked list looking for a match.     */
    /*                                                                  */
    /********************************************************************/

PAGE *FIND::FindPage( VOID *Address,CACHE *ParentCache )
    {
#ifdef ENABLE_HEAP_STATISTICS
	REGISTER SBIT32 Cycles = 0;
	REGISTER PAGE *Result = NULL;
#endif
	REGISTER PAGE *Page;

	//
	//   Find the associated hash bucket and then walk
	//   along the linked list for this looking for
	//   the correct page description.
	//
	for 
			( 
			Page = PAGE::FirstInFindList( FindHashHead( Address ) );
			! Page -> EndOfFindList();
			Page = Page -> NextInFindList()
			)
		{
#ifdef ENABLE_HEAP_STATISTICS
		//
		//   Count the number of iterations in when we
		//   are recording statistics so we can calculate
		//   the average chain length.
		//
		Cycles ++;

#endif
		//
		//   We can identify the the target page by two key
		//   characteristics.  These are the start address and
		//   the parent page.   Although we may have sub-divided
		//   a page into various chunks each chunk will have
		//   a different parent (although its start address
		//   may sometimes be the same).
		//
		if 
				( 
				(Address == (Page -> GetAddress())) 
					&& 
				(ParentCache == (Page -> GetParentPage()))
				)
			{
#ifdef ENABLE_HEAP_STATISTICS
			//
			//   We have found the target page.  So return it
			//   to the caller.
			//
			if ( Page -> ValidPage() )
				{
				Result = Page;
				break;
				}
			else
				{ Failure( "Deleted page in FindPage" ); }
#else
			return Page;
#endif
			}
		}

#ifdef ENABLE_HEAP_STATISTICS
	//
	//   When we are in statistics mode we need to update the
	//   information so we can output it at the end of the
	//   run.
	//
	if ( MaxTests < Cycles )
		{ MaxTests = Cycles; }

	Tests += Cycles;

	Scans ++;

	return Result;
#else
	return NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Insert an item into the find table.                            */
    /*                                                                  */
    /*   We need to insert a new page into the find table.  We expect   */
    /*   this to take quite a while as multiple threads can be using    */
    /*   this class at the same time.                                   */
    /*                                                                  */
    /********************************************************************/

VOID FIND::InsertInFindList( PAGE *Page )
	{
	REGISTER VOID *Address = (Page -> GetAddress());

	//
	//   Claim an exclusive lock so we can update the 
	//   find table and lookaside as needed.
	//
	ClaimFindExclusiveLock();

	//
	//   Insert a new page into the find table.
	//
	Page -> InsertInFindList( FindHashHead( Address ) );

	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER SBIT32 Count;
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Stride = (Cache -> GetAllocationSize());

		//
		//   We are about look up various lookaside entries
		//   and update any that are stale.  We need to do
		//   this for every lookaside slot that relates to
		//   the page.  If the allocation size is smaller
		//   than the lookaside slot size we can save some
		//   iterations by increasing the stride size.
		//
		if ( Stride <= ((SBIT32) MinAddressMask) )
			{ Stride = ((SBIT32) (MinAddressMask+1)); }

		//
		//   Whenever we add an entry from the find table
		//   the lookaside is potentially corrupt.  So we 
		//   need to update any lookaside entries relating
		//   to the page.
		//
		for ( Count=0;Count < Cache -> GetPageSize();Count += Stride )
			{
			REGISTER VOID *Segment = 
				((VOID*) ((((LONG) Address) + Count) & ~MinAddressMask));
			REGISTER LOOK_ASIDE *Current = 
				(FindLookAsideHead( Segment ));

			//
			//   Add the new page to the lookaside as we
			//   expect it to get hit pretty soon one way
			//   or another.
			//
			Current -> Address = Segment;
			Current -> Page = Page;
#ifdef DEBUGGING
			Current -> Version = Page -> GetVersion();
#endif
			}
		}

	//
	//   Update the statistics and resize the find
	//   table if it is over 75% full.
	//
	if ( ((++ Used) + (MaxHash / MinHashSpace)) > MaxHash )
		{ ResizeHashTable(); }
#ifdef ENABLE_HEAP_STATISTICS

	if ( Used > MaxPages )
		{ MaxPages = Used; }
#endif

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out if it is known to the current heap.             */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::KnownArea( VOID *Address,CACHE *ParentCache )
    {
	REGISTER PAGE *Page;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Find out if the address belongs to this heap
	//   or any other heap of which we are aware (i.e.
	//   when single image is active).
	//
	Page = (ParentCache -> FindParentPage( Address ));

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindShareLock();

	return (Page != ((PAGE*) NULL));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock and update.                              */
    /*                                                                  */
    /*   We have been asked to insert a page into the lookaside.        */
    /*   We assume the caller already has a share lock which we         */
    /*   release when we are finished.                                  */
    /*                                                                  */
    /********************************************************************/

VOID FIND::ReleaseFindShareLockAndUpdate
		( 
		VOID						  *Address,
		PAGE						  *Page,
		SBIT32						  Version
		)
    {
	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		//
		//   Claim an exclusive lock so we can update the 
		//   lookaside as needed.
		//
		ChangeToExclusiveLock();

#ifdef DEBUGGING
		if ( Page -> ValidPage() )
			{
#endif
			if ( Version == (Page -> GetVersion()) )
				{
				REGISTER LONG Base = (((LONG) Address) & ~MinAddressMask);
				REGISTER VOID *Segment = ((VOID*) Base);
				REGISTER LOOK_ASIDE *Current = FindLookAsideHead( Segment );

				//
				//   Overwrite any existing information.
				//
				Current -> Address = Segment;
				Current -> Page = Page;
#ifdef DEBUGGING
				Current -> Version = Page -> GetVersion();
#endif
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the statistics.
				//
				Fills ++;
#endif
				}
#ifdef DEBUGGING
			}
		else
			{ Failure( "Deleted page in ReleaseFindShareLockAndUpdate" ); }
#endif

		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindExclusiveLock();
		}
	else
		{ 
		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindShareLock(); 
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize the find table.                                         */
    /*                                                                  */
    /*   We need to grow the hash table as it appears to be a little    */
    /*   small given the number of pages that have been created.        */
    /*                                                                  */
    /********************************************************************/

VOID FIND::ResizeHashTable( VOID )
    {
	AUTO SBIT32 NewHashMask;
	AUTO SBIT32 NewLookAsideMask;

	//
	//   When we need to resize the hash table it is a
	//   straight race.  The first thread to claim the
	//   lock gets to do the work.  Everyone else just
	//   exits.
	//
	if ( (Resize) && (Spinlock.ClaimLock(0)) )
		{
		REGISTER SBIT32 AlignMask = (Rockall -> NaturalSize()-1);
		REGISTER SBIT32 NewMaxHash = (MaxHash * ExpandStore);
		REGISTER SBIT32 NewMaxLookAside = (MaxLookAside * ExpandStore);
		REGISTER SBIT32 NewHashSize = (NewMaxHash * sizeof(LIST));
		REGISTER SBIT32 NewLookAsideSize = (NewMaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 NewTotalSize = (NewHashSize + NewLookAsideSize);
		REGISTER SBIT32 HashSize = (MaxHash * sizeof(LIST));
		REGISTER SBIT32 LookAsideSize = (MaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

		//
		//   It is actually possible for a thread to get
		//   delayed for so long that it thinks the hash 
		//   table still needs to be resized long after the 
		//   work has been completed.  Additionally, we want
		//   to make sure that all the new values are sane.
		//
		if 
				(
				PowerOfTwo( (AlignMask+1) )
					&&
				(NewMaxHash > 0)
					&&
				(ConvertDivideToShift( NewMaxHash,& NewHashMask ))
					&&
				(NewMaxLookAside > 0)
					&& 
				(ConvertDivideToShift( NewMaxLookAside,& NewLookAsideMask ))
					&&
				((Used + (MaxHash / MinHashSpace)) > MaxHash)
				)
			{
			REGISTER LIST *NewHash;
			REGISTER LOOK_ASIDE *NewLookAside;

			//
			//   We have been picked as the victim who
			//   needs to resize the hash table.  We are
			//   going to call the external allocator 
			//   to get more memory.  As we know this is 
			//   likely to to nail us we drop the lock to 
			//   allow other threads to continue.
			//
			ReleaseFindExclusiveLock();

			//
			//   We know that allocating a new table and 
			//   initializing it is going to take ages.
			//   Well at least everyone else gets to carry
			//   on in the mean time.
			//
			NewHash = 
				((LIST*) Rockall -> NewArea( AlignMask,NewTotalSize,False ));

			NewLookAside = 
				((LOOK_ASIDE*) & NewHash[ NewMaxHash ]);

			//
			//   If the memory allocation request for the hash
			//   table fails we exit and try again later. 
			//
			if ( NewHash != ((LIST*) AllocationFailure) )
				{
				REGISTER SBIT32 Count;

				//
				//   Call the constructor for each hash table
				//   linked list header.
				//
				for ( Count=0;Count < NewMaxHash;Count ++ )
					{ PLACEMENT_NEW( & NewHash[ Count ],LIST ); }

				//
				//   Zero the look aside structure.
				//
				for ( Count=0;Count < NewMaxLookAside;Count ++ )
					{
					REGISTER LOOK_ASIDE *Current = & NewLookAside[ Count ];

					Current -> Address = ((VOID*) NoCacheEntry);
					Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
					Current -> Version = ((SBIT32) NoCacheEntry);
#endif
					}
				}

			//
			//   Claim an exclusive lock so we can resize  
			//   the hash table.
			//
			ClaimFindExclusiveLock();

			//
			//   If we have allocated the new find table
			//   we can now rehash the existing entries.
			//   If not we are out of here.
			//
			if ( NewHash != ((LIST*) AllocationFailure) )
				{
				REGISTER SBIT32 Count;
				REGISTER SBIT32 MaxOldHash = MaxHash;
				REGISTER LIST *OldHash = Hash;

				//
				//   Update the control information 
				//   for the new hash table.
				//
				MaxHash = NewMaxHash;
				HashShift = (32-NewHashMask);
				HashMask = ((1 << NewHashMask)-1);

				MaxLookAside = NewMaxLookAside;
				LookAsideShift = (32-NewLookAsideMask);
				LookAsideMask = ((1 << NewLookAsideMask)-1);

				Hash = NewHash;
				LookAside = NewLookAside;

				//
				//   Delete all the existing records
				//   from the old hash table and insert
				//   them into the new hash table.
				//
				for ( Count=0;Count < MaxOldHash;Count ++ )
					{
					REGISTER LIST *Current = & OldHash[ Count ];

					//
					//   Walk along each hash bucket 
					//   deleting the records and inserting
					//   them into the new hash table.
					//
					while ( ! Current -> EndOfList() )
						{
						REGISTER PAGE *Page = PAGE::FirstInFindList( Current );
						REGISTER VOID *Address = (Page -> GetAddress());

						Page -> DeleteFromFindList( Current );

						Page -> InsertInFindList( FindHashHead( Address ) );
						}
					}

				//
				//   Time to do more operating system work
				//   so lets drop the lock again.
				//
				ReleaseFindExclusiveLock();

				//
				//   Delete all the list heads and return the
				//   original allocation to the operating system.
				//
				for ( Count=0;Count < MaxOldHash;Count ++ )
					{ PLACEMENT_DELETE( & OldHash[ Count ],LIST ); }

				//
				//   Deallocate the old extent.
				//
				Rockall -> DeleteArea( ((VOID*) OldHash),TotalSize,False );

				//
				//   We are finished so reclaim the lock
				//   so we can exit.
				//
				ClaimFindExclusiveLock();
				}
			else
				{ Resize = False; }
			}

		Spinlock.ReleaseLock();
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the find table.                                         */
    /*                                                                  */
    /*   We need to update the find table with certain information      */
    /*   to ensure it is used correctly and consistently.               */
    /*                                                                  */
    /********************************************************************/

VOID FIND::UpdateFind( BIT32 NewMaxAddressMask,BIT32 NewMinAddressMask )
    {
	//
	//   When we have a single heap image all the 'TopCache' sizes
	//   must be the same.
	//
	if 
			( 
			(MaxAddressMask == NoAddressMask) 
				|| 
			(MaxAddressMask == NewMaxAddressMask) 
			)
		{
		//
		//   If we need to be thread safe then claim a sharable lock
		//   on the hash table to stop it being changed under our feet.
		//
		ClaimFindExclusiveLock();

		//
		//   Update the max address mask if it is not the current
		//   value but yet consistent.
		//
		MaxAddressMask = NewMaxAddressMask;

		//
		//   Update the address mask is the new heap has a smaller
		//   parent than all of the other heaps.
		//
		if ( MinAddressMask > NewMinAddressMask )
			{ MinAddressMask = NewMinAddressMask; }

		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindExclusiveLock();
		}
	else
		{ Failure( "Different 'TopCache' sizes with 'SingleImage'" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   whay anybody might want to do this given the rest of the       */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Walk
		( 
		BOOLEAN						  *Active,
		VOID						  **Address,
		CACHE						  *ParentCache,
		SBIT32						  *Size 
		)
    {
	REGISTER VOID *Memory = (*Address);
	REGISTER BOOLEAN Result;
	REGISTER BOOLEAN Update;
	REGISTER PAGE *Page;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   When the address is null we need to set up the heap
	//   walk.  In all other cases we just extract the next
	//   allocation in the list.
	//
	if ( Memory != NULL )
		{
		AUTO SEARCH_PAGE Details;

		//
		//   Lets try the lookaside table.  There is a pretty
		//   good chance that we will have the details we need 
		//   already in the cache.  If not we need to find it
		//   the hard way.  During the process we add the mapping
		//   into the lookaside for next time.
		//
		if
				(
				Update =
					( 
					! FindLookAside
						( 
						((VOID*) (((LONG) Memory) & ~MinAddressMask)),
						& Page 
						) 
					)
				)
			{
			//
			//   Find the allocation page and get the details of entry.
			//   We do this by finding the parent of the top cache.
			//   We  know that this is the global root and will find
			//   the correct page even if it is on another heap (as
			//   long as the find table is globally shared).
			//
			Page = (ParentCache -> FindParentPage( Memory ));
			}

		//
		//   We now compute all the details relating to the address
		//   so we can find any subsequent allocation.
		//
		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Memory,& Details,True )); }

		//
		//   We may have failed to find the address  .If so
		//   we simply fail the call.  If not we find the next
		//   allocation in the heap.
		//
		if ( Result = ((Page != ((PAGE*) NULL)) && (Details.Found)) )
 			{
			//
			//   We need to walk the heap to get te details
			//   of the next allocation.
			//
			if ( Result = (Page -> Walk( & Details )) )
				{
				REGISTER BIT32 AllocationBit =
					((*Details.VectorWord) & Details.AllocationMask);

				(*Active) = (AllocationBit != 0);
				(*Address) = Details.Address;
				(*Size) = (Details.Page -> ActualSize());

				//
				//   If we are considering putting something
				//   in the lookaside lets make sure that
				//   we will get to hit the cache entry at
				//   least once.  If not lets forget putting
				//   it in the cache.
				//
				if ( Update )
					{
					Update =
						(
						(((LONG) Memory) & ~MinAddressMask)
							==
						(((LONG) Details.Address) & ~MinAddressMask)
						);
					}
				}
			}
		}
	else
		{
		AUTO SEARCH_PAGE Details;

		//
		//   We start a heap walk by setting the initial 
		//   address to the value null.
		//
		Details.Address = NULL;
		Details.Cache = ParentCache;
		Details.Page = NULL;

		Page = NULL;
		Update = False;

		//
		//   We walk the heap to get te details of the
		//   first heap allocation.
		//
		if ( Result = (Page -> Walk( & Details )) )
			{
			REGISTER BIT32 AllocationBit =
				((*Details.VectorWord) & Details.AllocationMask);

			(*Active) = (AllocationBit != 0);
			(*Address) = Details.Address;
			(*Size) = (Details.Page -> ActualSize());
			}
		}

	//
	//   Release the lock if we claimed it earlier and
	//   update the lookaside if needed.
	//
	if ( (Update) && (Result) )
		{ ReleaseFindShareLockAndUpdate( Memory,Page,Page -> GetVersion() ); }
	else
		{ ReleaseFindShareLock(); }

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Delete the hash table and release all the associated memory.   */
    /*                                                                  */
    /********************************************************************/

FIND::~FIND( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 HashSize = (MaxHash * sizeof(LIST));
	REGISTER SBIT32 LookAsideSize = (MaxLookAside * sizeof(LOOK_ASIDE));
	REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

	//
	//   Call the destructor for each hash table
	//   linked list header.
	//
	for ( Count=0;Count < MaxHash;Count ++ )
		{ PLACEMENT_DELETE( & Hash[ Count ],LIST ); }

	//
	//   Deallocate the area.
	//
	Rockall -> DeleteArea( ((VOID*) Hash),TotalSize,False );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\heap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control minimum size of an         */
    /*   allocation bucket.                                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinParentSize			  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a heap and prepare it for use.  Additionally, make      */
    /*   sure that the heap configuration makes sense.  This is         */
    /*   tricky as the whole structure of the heap can be changed       */
    /*   by the external configuration information.                     */
    /*                                                                  */
    /********************************************************************/

HEAP::HEAP
		(
		CACHE						  *Caches1[],
		CACHE						  *Caches2[],
		SBIT32						  MaxFreeSpace,
		FIND						  *NewFind,
		NEW_PAGE					  *NewPages,
		ROCKALL						  *NewRockall,
		SBIT32						  Size1,
		SBIT32						  Size2,
		SBIT32						  Stride1,
		SBIT32						  Stride2,
		BOOLEAN						  NewThreadSafe
		)
    {
	//
	//   The top three buckets are special and a user can not 
	//   allocate memory from two of them.  Thus, unless we have  
	//   at least four buckets the memory allocator is not going 
	//   to be very useful. 
	//
	if ( (Size1 >= 1) && (Size2 >= 3) )
		{
		REGISTER CACHE *FirstCache = Caches1[0];
		REGISTER CACHE *MiddleCache = Caches2[0];
		REGISTER CACHE *LastCache = Caches2[ (Size2-3) ];

		//
		//   Calculate the minimum and maximum allocation sizes.
		//   All allocations outside of this range will be passed
		//   directly to the external allocator.
		//
		CachesSize = (Size1 + Size2);
		MinCacheSize = FirstCache -> GetAllocationSize();
		MidCacheSize = MiddleCache -> GetAllocationSize();
		MaxCacheSize = LastCache -> GetAllocationSize();

		//
		//   Calculate and save various useful pointers needed
		//   during the course of execution.
		//
		Caches = Caches1;
		ExternalCache = (Caches2[ (Size2-1) ]);
		Find = NewFind;
		NewPage = NewPages;
		Rockall = NewRockall;
		TopCache = (Caches2[ (Size2-2) ]);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Zero the heap statistics.
		//
		CopyMisses = 0;
		MaxCopySize = 0;
		MaxNewSize = 0;
		NewMisses = 0;
		Reallocations = 0;
		TotalCopySize = 0;
		TotalNewSize = 0;
#endif

		//
		//   The external allocation size must be reasonable.
		//   All allocation sizes must be a multiple of the
		//   minimum allocation size.  The minimum allocation
		//   size and the middle allocation size must be a 
		//   power of two.
		//   
		if 
				( 
				(ExternalCache -> GetPageSize() == TopCache -> GetPageSize())
					&& 
				(PowerOfTwo( Rockall -> NaturalSize() ))
					&&
				(Rockall -> NaturalSize() >= PageSize())
					&&
				(TopCache -> GetPageSize() >= PageSize())
					&&
				(PowerOfTwo( TopCache -> GetPageSize() ))
					&&
				((Stride1 > 0) && (PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (PowerOfTwo( Stride2 )))
					&&
				(ConvertDivideToShift( Stride1,& ShiftSize1 ))
					&&
				(ConvertDivideToShift( Stride2,& ShiftSize2 ))
				)
			{
			REGISTER SBIT32 Count1;
			REGISTER SBIT32 TopCacheSize = (TopCache -> GetPageSize());
			REGISTER SBIT32 MaxSize1 = (MidCacheSize / Stride1);
			REGISTER SBIT32 MaxSize2 = (TopCacheSize / Stride2);

			//
			//   Calculate the maximum number of free pages 
			//   that can be kept.  Also set the smallest parent
			//   mask to the maximum value.
			//
			MaxFreePages = (MaxFreeSpace / (TopCache -> GetAllocationSize()));
			SmallestParentMask = ((TopCache -> GetAllocationSize())-1);
			ThreadSafe = NewThreadSafe;

			//
			//   Calculate the sizes of the arrays that map 
			//   sizes to caches.
			//
			MaxTable1 = (MaxSize1 * sizeof(CACHE*));
			MaxTable2 = (MaxSize2 * sizeof(CACHE*));

			//
			//   The heap pages must be specified in asceding
			//   order of size and be an exact multiple of the
			//   minimum allocation size.
			//
			for ( Count1=0;Count1 < Size1;Count1 ++ )
				{
				REGISTER CACHE *Current = Caches1[ Count1 ];
				REGISTER CACHE *Next = Caches1[ (Count1+1) ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();
				REGISTER SBIT32 ChunkSize = Current -> GetChunkSize();
				REGISTER SBIT32 PageSize = Current -> GetPageSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride1) != 0 )
					{ Failure( "Cache size not multiple of stride" ); }

				if ( AllocationSize >= Next -> GetAllocationSize() )
					{ Failure( "Cache sizes not in ascending order" ); }

				if ( (AllocationSize > ChunkSize) || (ChunkSize > PageSize) )
					{ Failure( "Chunk size not suitable for cache" ); }

				if ( AllocationSize >= PageSize )
					{ Failure( "Cache size larger than parent size" ); }

				if ( PageSize > TopCacheSize )
					{ Failure( "Parent size exceeds 'TopCache' size" ); }
				}

			//
			//   The heap pages must be specified in asceding
			//   order of size and be an exact multiple of the
			//   minimum allocation size.
			//
			for ( Count1=0;Count1 < (Size2-2);Count1 ++ )
				{
				REGISTER CACHE *Current = Caches2[ Count1 ];
				REGISTER CACHE *Next = Caches2[ (Count1+1) ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();
				REGISTER SBIT32 ChunkSize = Current -> GetChunkSize();
				REGISTER SBIT32 PageSize = Current -> GetPageSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride2) != 0 )
					{ Failure( "Cache size not multiple of stride" ); }

				if ( AllocationSize >= Next -> GetAllocationSize() )
					{ Failure( "Cache sizes not in ascending order" ); }

				if ( (AllocationSize > ChunkSize) || (ChunkSize > PageSize) )
					{ Failure( "Chunk size not suitable for cache" ); }

				if ( AllocationSize >= PageSize )
					{ Failure( "Cache size larger than parent size" ); }

				if ( PageSize > TopCacheSize )
					{ Failure( "Parent size exceeds 'TopCache' size" ); }
				}

			//
			//   The external and top caches have special rules
			//   which must be checked to ensure these caches
			//   are valid.
			//
			for ( Count1=(Size2-2);Count1 < Size2;Count1 ++ )
				{
				REGISTER CACHE *Current = Caches2[ Count1 ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride2) != 0 )
					{ Failure( "Top cache size not multiple of minimum" ); }

				if ( AllocationSize != Current -> GetChunkSize() )
					{ Failure( "Chunk size not suitable for top cache" ); }

				if ( AllocationSize != Current -> GetPageSize() )
					{ Failure( "Page size not suitable for top cache" ); }

				if ( Current -> GetCacheSize() != 0 )
					{ Failure( "Cache size not zero for top cache" ); }
				}

			//
			//   We need to allocate two arrays to enable requested
			//   sizes to be quickly mapped to allocation caches.
			//   Here we allocate the tables and later fill in all
			//   the necessary mapping information.
			//
			SizeToCache1 = (CACHE**) 
				(
				Rockall -> NewArea
					(
					(Rockall -> NaturalSize() - 1),
					(MaxTable1 + MaxTable2),
					False
					)
				);
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   When we are compiled for statistics we keep
			//   information on all the allocations we see.
			//
			Statistics = (SBIT32*)
				(
				Rockall -> NewArea
					(
					(Rockall -> NaturalSize() - 1),
					(MaxCacheSize * sizeof(SBIT32)),
					False
					)
				);
#endif

			//
			//   We make sure that the allocations we made 
			//   did not fail.  If not we have to fail the 
			//   creation of the whole heap.
			//
			if 
					( 
					(SizeToCache1 != ((CACHE**) AllocationFailure))
#ifdef ENABLE_HEAP_STATISTICS
						&&
					(Statistics != ((SBIT32*) AllocationFailure))
#endif
					) 
				{
				REGISTER SBIT32 Count2;

				//
				//   Cycle through the first segment of the 
				//   mapping table creating approriate 
				//   translations.
				//
				for ( Count1=0,Count2=0;Count1 < MaxSize1;Count1 ++ )
					{
					//
					//   We make sure that the current allocation
					//   page is large enough to hold an element
					//   of some given size.  If not we move on to
					//   the next allocation page.
					//
					if 
							( 
							((Count1 + 1) * Stride1)
								> 
							(Caches1[ Count2 ] -> GetAllocationSize()) 
							)
						{ Count2 ++; }

					//
					//   Store a pointer so that a request for
					//   this size of allocation goes directly
					//   to the correct page.
					//
					SizeToCache1[ Count1 ] = Caches1[ Count2 ];
					}

				//
				//   Compute the start address for the second
				//   segment of the table.
				//
				SizeToCache2 = 
					((CACHE**) & ((CHAR*) SizeToCache1)[ MaxTable1 ]);

				//
				//   Cycle through the second segment of the 
				//   mapping table creating approriate 
				//   translations.
				//
				for ( Count1=0,Count2=0;Count1 < MaxSize2;Count1 ++ )
					{
					//
					//   We make sure that the current allocation
					//   page is large enough to hold an element
					//   of some given size.  If not we move on to
					//   the next allocation page.
					//
					if 
							( 
							((Count1 + 1) * Stride2)
								> 
							(Caches2[ Count2 ] -> GetAllocationSize()) 
							)
						{ Count2 ++; }

					//
					//   Store a pointer so that a request for
					//   this size of allocation goes directly
					//   to the correct page.
					//
					SizeToCache2[ Count1 ] = Caches2[ Count2 ];
					}

				//
				//   Now that we have created the size to cache 
				//   mappings lets use them to link each cache to  
				//   the cache it uses to allocate additional 
				//   memory.
				//
				for ( Count1=0;Count1 < (CachesSize-1);Count1 ++ )
					{
					REGISTER CACHE *CurrentCache = Caches[ Count1 ];
					REGISTER SBIT32 PageSize = CurrentCache -> GetPageSize();
					REGISTER CACHE *ParentCache = FindCache( PageSize );
					REGISTER BOOLEAN Top = (CurrentCache == ParentCache);

					//
					//   Ensure that the parent cache is suitable
					//   and in line with what we were expecting. 
					//
					if 
							(
							(PowerOfTwo( PageSize ))
								&&
							(PageSize >= MinParentSize)
								&&
							(PageSize == (ParentCache -> GetAllocationSize()))
							)
						{
						//
						//   We keep track of the smallest
						//   cache that is a parent.  We can
						//   use this to improve the performance
						//   of the find hash table.
						//
						if ( ((BIT32) PageSize) < SmallestParentMask )
							{ SmallestParentMask = (PageSize-1); }

						//
						//   Update the current cache with  
						//   information about it's parent 
						//   cache.
						//
						CurrentCache -> UpdateCache
							(
							NewFind,
							this,
							NewPages,
							((Top) ? ((CACHE*) GlobalRoot) : ParentCache)
							); 
						} 
					else
						{ Failure( "Parent bucket is invalid" ); }
					}

				//
				//   The external cache is an exact duplicate
				//   of the top cache and is used to hold all
				//   memory allocations that are too large for
				//   any bucket.  Nonetheless, its parent is
				//   still the top cache.
				//
				ExternalCache -> UpdateCache
					(
					NewFind,
					this,
					NewPages,
					TopCache
					);

				//
				//   Update the hash table with the minimum
				//   parent size for this heap.
				//
				Find -> UpdateFind
					(
					(TopCache -> GetAllocationSize()-1),
					SmallestParentMask 
					);

				//
				//   Update the new page structure with the 
				//   details of the top cache.
				//
				NewPage -> UpdateNewPage( TopCache );

				//
				//   Activate the heap.
				//
				Active = True;
				}
			else
				{ Failure( "Mapping table in constructor for HEAP" ); }
			}
		else
			{ Failure( "The allocation sizes in constructor for HEAP" ); }
		}
	else
		{ Failure( "A heap size in constructor for HEAP" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We need to release some memory.  First we try to slave the     */
    /*   request in the free cache so we can do a batch of releases     */
    /*   later.  If not we are forced to do it at once.                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Delete( VOID *Address,SBIT32 Size )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   When the caller gives us the size of the 
		//   allocation we can short cut the deallocation 
		//   process by skipping directly to the correct 
		//   cache.  However, if the user supplies us
		//   with bogus data we will retry using the
		//   the full deallocation process.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));

			if ( Find -> Delete( Address,Cache ) )
				{ return True; }
			}

		//
		//   It looks like all we have is the address so 
		//   deallocate using the long path.
		//
		return (Find -> Delete( Address,TopCache ));
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We delete the entire heap and free all existing allocations.   */
    /*   If 'Recycle' is requested we slave the allocated memory as     */
    /*   we expect some new allocations.  If not we return all the      */
    /*   memory to the external allocator.                              */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::DeleteAll( BOOLEAN Recycle )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   We claim all of the heap locks to freeze
		//   all new allocations or deletions.
		//
		LockAll();

		//
		//   Now reset all the caches and the find
		//   hash table statistics.
		//
		Find -> DeleteAll();

		for ( Count=0;Count < CachesSize;Count ++ )
			{ Caches[ Count ] -> DeleteAll(); }

		//
		//   Delete the heap.
		//
		NewPage -> DeleteAll( Recycle );

		//
		//   Now release all the heap locks we claimed
		//   earlier and unfreeze the heap.
		//
		UnlockAll();

		//
		//   Trim the free space if needed.
		//
		if ( Recycle )
			{ TopCache -> ReleaseSpace( MaxFreePages ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Details of a memory allocation.                                */
    /*                                                                  */
    /*   We need to the details of a particular memory allocation.      */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.                                           */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Details( VOID *Address,SBIT32 *Size )
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Dummy;

		//
		//   We allow the caller to omit the 'Size' parameter.
		//   I can see little reason for this but it is supported
		//   anyway.
		//
		if ( Size == NULL )
			{ Size = & Dummy; }

		//
		//   Find the details relating to this allocation
		//   and return them.
		//
		return (Find -> Details( Address,NULL,TopCache,Size ));
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a cache.                                                  */
    /*                                                                  */
    /*   Find the allocation cache for the size supplied and return     */
    /*   a pointer to it.                                               */
    /*                                                                  */
    /********************************************************************/

CACHE *HEAP::FindCache( SBIT32 Size )
	{
	REGISTER CACHE *Cache;

	//
	//   Compute the cache address.
	//
	if ( Size < MidCacheSize )
		{ return (SizeToCache1[ ((Size-1) >> ShiftSize1) ]); }
	else
		{ return (SizeToCache2[ ((Size-1) >> ShiftSize2) ]); }

	//
	//   Prefetch the class data if we are running a
	//   Pentium III or better with locks.  We do this
	//   because prefetching hot SMP data structures
	//   really helps.  However, if the structures are
	//   not shared (i.e. no locks) then it is worthless
	//   overhead.
	//
	if ( ThreadSafe )
		{ Prefetch.Nta( ((CHAR*) Cache),sizeof(CACHE) ); }

	return Cache;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim a lock on the entire heap.                               */
    /*                                                                  */
    /*   We claim a lock on the heap to improve performance             */
    /*   or prevent others from performing heap operations.             */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::LockAll( VOID )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We claim the locks if we have not already
		//   claimed them earlier.
		//
		if ( Find -> GetLockCount() == 0 )
			{
			REGISTER SBIT32 Count;

			//
			//   We claim all of the heap locks to freeze
			//   all new allocations or deletions.
			//
			for ( Count=0;Count < CachesSize;Count ++ )
				{ Caches[ Count ] -> ClaimCacheLock(); }

			//
			//  Although the heap is frozen at this point
			//  we claim the last few locks just to be
			//  tidy.
			//
			Find -> ClaimFindExclusiveLock();

			NewPage -> ClaimNewPageLock();
			}

		//
		//   Increment the per thread lock count.
		//
		Find -> IncrementLockCount();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete multiple allocations.                                   */
    /*                                                                  */
    /*   We need to release multiple memory allocations.  First we try  */
    /*   to slave the requets in the free cache so we can do a batch    */
    /*   of releases later.  If not we are forced to do it immediately. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::MultipleDelete
		( 
		SBIT32						  Actual,
		VOID						  *Array[],
		SBIT32						  Size 
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;
		REGISTER BOOLEAN Result = True;
		REGISTER CACHE *ParentCache = ((CACHE*) GlobalRoot);

		//
		//   When the caller gives us the size of the allocation
		//   we can short cut the deallocation process by skipping
		//   directly to the correct cache.  However, if the user
		//   supplies us with bogus data we will retry using the
		//   the long path.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));

			ParentCache = (Cache -> GetParentCache());
			}

		//
		//   Delete each memory allocation one at a time.
		//   We would like to delete them all at once but
		//   we can't be sure they are all vaild or related.
		//
		for ( Count=0;Count < Actual;Count ++ )
			{
			REGISTER VOID *Address = Array[ Count ];

			//
			//   First try to optimize the delete and if that
			//   fails then try the long path.
			//
			if 
					(
					(ParentCache == ((CACHE*) GlobalRoot)) 
						|| 
					(! Find -> Delete( Address,ParentCache )) 
					)
				{
				Result =
					(
					Find -> Delete( Address,TopCache )
						&&
					Result
					);
				}
			}

		return Result;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We have been asked to allocate muliple memory blocks.   We     */
    /*   we do this by using the cache and then claiming and addition   */
    /*   space from the heap as needed.                                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::MultipleNew
		( 
		SBIT32						  *Actual,
		VOID						  *Array[],
		SBIT32						  Requested,
		SBIT32						  Size,
		SBIT32						  *Space,
		BOOLEAN						  Zero
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Dummy;

		//
		//   We allow the caller to omit the 'Actual' parameter.
		//   I can see little reason for this but it is supported
		//   anyway.  Regardless we zero it.
		//
		if ( Actual == NULL )
			{ Actual = & Dummy; }

		(*Actual) = 0;

		//
		//   We need to be sure that the size requested is in the 
		//   range supported by the memory allocator.  If not we
		//   do a series of single allocations from the default
		//   allocator.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));
			REGISTER SBIT32 NewSize = (Cache -> GetAllocationSize());

			//
			//   Allocate memory from the appropriate 
			//   allocation bucket.
			//
			(VOID) Cache -> MultipleNew( Actual,Array,Requested );

			//
			//   If needed return the actual amount  
			//   of space allocated for each element.
			//
			if ( Space != NULL )
				{ (*Space) = NewSize; }
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Update the allocation statistics.
			//
			Statistics[ (Size-1) ] += Requested;
#endif

			//
			//   If needed zero each element that is  
			//   allocated.
			//
			if ( Zero )
				{
				REGISTER SBIT32 Count;

				for ( Count=((*Actual)-1);Count >= 0;Count -- )
					{ ZeroMemory( Array[ Count ],NewSize ); }
				}

			return ((*Actual) == Requested);
			}
		else
			{
			//
			//   If the allocation size is greater than
			//   zero we create the allocations.  If not
			//   we fail the request.
			//
			if ( Size > 0 )
				{
				//
				//   We have got a request for an element size
				//   larger than the largest bucket size.  So 
				//   we call the single allocation interface 
				//   as this supports large sizes.
				//
				for 
					( 
					/* void */;
					((*Actual) < Requested)
						&&
					((Array[ (*Actual) ] = New( Size )) != AllocationFailure);
					(*Actual) ++ 
					);

				//
				//   If needed return the actual amount of space 
				//   allocated for each element.
				//
				if ( Space != NULL )
					{ (*Space) = Size; }

				return ((*Actual) == Requested);
				}
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We have been asked to allocate some memory.  Hopefully,        */
    /*   we will be able to do this out of the cache.  If not we        */
    /*   will need to pass it along to the appropriate allocation       */
    /*   bucket.                                                        */
    /*                                                                  */
    /********************************************************************/

VOID *HEAP::New( SBIT32 Size,SBIT32 *Space,BOOLEAN Zero )
	{
	REGISTER VOID *NewMemory = ((VOID*) AllocationFailure);

	//
	//   Although normally a class is never called before
	//   its constructor. The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We ensure the allocation size is in
		//   the range supported by the heap.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Update the allocation statistics.
			//
			Statistics[ (Size-1) ] ++;
#endif

			//
			//   Allocate memory from the appropriate
			//   cache in the heap.
			//
			NewMemory = (Cache -> New()); 
			Size = (Cache -> GetAllocationSize());
			}
		else
			{ 
			//
			//   If the allocation size is greater than
			//   zero we create the allocation.  If not
			//   we fail the request.
			//
			if ( Size > 0 )
				{
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the allocation statistics.
				//
				if ( Size > MaxNewSize )
					{ MaxNewSize = Size; }

				NewMisses ++;
				TotalNewSize += Size;

#endif
				//
				//   Allocate memory from a special
				//   cache bucket which gets space
				//   externally.
				//
				NewMemory = (ExternalCache -> New( False,Size ));
				}
			else
				{ NewMemory = ((VOID*) AllocationFailure); }
			}

		//
		//   We need to be sure that the allocation 
		//   request did not fail.
		//
		if ( NewMemory != ((VOID*) AllocationFailure) )
			{
			//
			//   If needed return the actual amount of space 
			//   allocated for this request.
			//
			if ( Space != NULL )
				{ (*Space) = Size; }

			//
			//   Zero the memory if the needed.
			//
			if ( Zero )
				{ ZeroMemory( NewMemory,Size ); }
			}
		}

	return NewMemory;
	}
#ifdef ENABLE_HEAP_STATISTICS

    /********************************************************************/
    /*                                                                  */
    /*   Print statistics.                                              */
    /*                                                                  */
    /*   We output the allocation statistics to the debug console.      */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::PrintDebugStatistics( VOID )
	{
	REGISTER HANDLE Semaphore;
	
	//
	//   As we may have multiple heaps executing there 
	//   destructors at the same time we create a semaphore
	//   to prevent multiple threads producing output at
	//   the same time.
	//
	if ( (Semaphore = CreateSemaphore( NULL,1,MaxCpus,"Print" )) != NULL)
        {
		//
		//   Wait for the global semaphore.
		//
		if 
				( 
				WaitForSingleObject( Semaphore,INFINITE ) 
					== 
				WAIT_OBJECT_0 
				)
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 CurrentSize = 0;
			REGISTER SBIT32 GrandTotal = 0;
			REGISTER SBIT32 HighWater = 0;
			REGISTER SBIT32 Total = 0;

			//
			//   Output the titles to the debug console.
			//
			DebugPrint
				( 
				"\n"
				"  Original    New      Bucket    High   "
				"   Cache    Cache     Partial    Grand\n" 
				"    Size    Allocs      Size     Water  "
				"   Fills   Flushes     Total     Total\n"
				);

			//
			//   Output details for every sample size.
			//
			for ( Count=0;Count < MaxCacheSize;Count ++ )
				{
				REGISTER SBIT32 Hits = Statistics[ Count ]; 

				//
				//   Skip the sample if there are no hits.
				//
				if ( Hits > 0 )
					{
					REGISTER CACHE *Cache = FindCache( (Count+1) );
					REGISTER SBIT32 CacheSize = Cache -> GetAllocationSize();

					//
					//   Zero the running totals at the end
					//   of each bucket.
					//
					if ( CurrentSize != CacheSize )
						{
						CurrentSize = CacheSize;
						Total = 0;

						DebugPrint
							( 
							"----------------------------------------"
							"--------------------------------------\n" 
							);
						}

					//
					//   Compute and output the totals.
					//
					if ( Total == 0)
						{ HighWater += (Cache -> GetHighWater() * CacheSize); }

					Total += Hits;
					GrandTotal += Hits;

					DebugPrint
						(
						"%8d  %8d  %8d  %8d  %8d  %8d  %8d  %8d\n",
						(Count + 1),
						Hits,
						CacheSize,
						Cache -> GetHighWater(),
						Cache -> GetCacheFills(),
						Cache -> GetCacheFlushes(),
						Total,
						GrandTotal
						); 
					}
				}

			//
			//   Print the hash table statistics.
			//
			DebugPrint( "\nHash Table Statistics" );
			DebugPrint( "\n---------------------\n" );

			DebugPrint
				(
				"\t*** Cache ***\n"
				"\tFills\t\t: %d\n\tHits\t\t: %d\n\tMisses\t\t: %d\n"
				"\t*** Table ***\n"
				"\tAverage\t\t: %d\n\tMax\t\t: %d\n\tScans\t\t: %d\n"
				"\tMax Hash\t: %d\n\tMax LookAside\t: %d\n\tUsage\t\t: %d%%\n",
				Find -> CacheFills(),
				Find -> CacheHits(),
				Find -> CacheMisses(),
				Find -> AverageHashLength(),
				Find -> MaxHashLength(),
				Find -> TotalScans(),
				Find -> MaxHashSize(),
				Find -> MaxLookAsideSize(),
				Find -> MaxUsage()
				);

			//
			//   Print the reallocation statistics.
			//
			DebugPrint( "\nOversize Statistics" );
			DebugPrint( "\n-------------------\n" );

			DebugPrint
				(
				"\tAverage Size\t: %d\n\tMax Size\t: %d\n\tMisses\t\t: %d\n",
				(TotalNewSize / ((NewMisses > 0) ? NewMisses : 1)),
				MaxNewSize,
				NewMisses
				);

			//
			//   Print the reallocation statistics.
			//
			DebugPrint( "\nRealloc Statistics" );
			DebugPrint( "\n------------------\n" );

			DebugPrint
				(
				"\tAverage Copy\t: %d\n\tCalls\t\t: %d\n\tMax Copy\t: %d\n"
				"\tTotal Copies\t: %d\n",
				(TotalCopySize / ((CopyMisses > 0) ? CopyMisses : 1)),
				Reallocations,
				MaxCopySize,
				CopyMisses
				);

			//
			//   Print the general statistics.
			//
			DebugPrint( "\nSummary Statistics" );
			DebugPrint( "\n------------------\n" );

			DebugPrint
				(
				"\tHigh Water\t: %d\n",
				HighWater
				);
			}
		else
			{ Failure( "Sleep failed in PrintDebugStatistics" ); }

		//
		//   Release the global semaphore.
		//
		ReleaseSemaphore( Semaphore,1,NULL );

		CloseHandle( Semaphore );
		}
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We have been asked to reallocate some memory.  Hopefully,      */
    /*   we will be able to do this out of the cache.  If not we        */
    /*   will need to pass it along to the appropriate allocation       */
    /*   bucket, do a copy and free the orginal allocation.             */
    /*                                                                  */
    /********************************************************************/

VOID *HEAP::Resize
		( 
		VOID						  *Address,
		SBIT32						  NewSize,
		SBIT32						  Move,
		SBIT32						  *Space,
		BOOLEAN						  NoDelete,
		BOOLEAN						  Zero
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Size;
		AUTO SBIT32 NewSpace;

		//
		//   Find the details of the existing allocation.
		//   If there is no existing allocation then exit.
		//
		if ( Details( Address,& Size ) )
			{
			REGISTER VOID *NewMemory;
			REGISTER SBIT32 Smallest = ((Size < NewSize) ? Size : NewSize);

			//
			//   Make sure the sizes appear to make sense.
			//
			if ( Smallest > 0 )
				{
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the statistics.
				//
				Reallocations ++;

#endif
				//
				//   When the new allocation allocation is 
				//   standard heap allocation size we check 
				//   for various optimizations.
				//
				if ( NewSize <= MaxCacheSize )
					{
					REGISTER CACHE *Cache = (FindCache( NewSize ));
					REGISTER SBIT32 CacheSize = (Cache -> GetAllocationSize());
					REGISTER SBIT32 Delta = (CacheSize - Size);
					
					//
					//   We only need to reallocate if the new
					//   size is larger than the current bucket
					//   or the new size is smaller and we have 
					//   been given permission to move the 
					//   allocation.
					//
					if ( ResizeTest( Delta,Move ) )
						{
						//
						//   We need to allocate some more
						//   memory and copy the old data.
						//   into the new area.
						//
						NewMemory = (Cache -> New());
						NewSpace = CacheSize;
#ifdef ENABLE_HEAP_STATISTICS

						//
						//   Update the statistics.
						//
						Statistics[ (NewSize-1) ] ++;
#endif
						}
					else
						{
						//
						//   If the new size is unchanged or smaller
						//   then just return the current allocation.
						//   If the new size is larger then we must
						//   fail the call.
						//
						if ( Delta <= 0 )
							{
							//
							//   The amount of memory allocated for  
							//   this request is unchanged so return  
							//   the current size.
							//
							if ( Space != NULL )
								{ (*Space) = Size; }

							return Address; 
							}
						else
							{ return ((VOID*) AllocationFailure); }
						}
					}
				else
					{
					REGISTER SBIT32 Delta = (NewSize - Size);

					//
					//   We only need to reallocate if the new
					//   size is larger than the current bucket
					//   or the new size is smaller and we have 
					//   been given permission to move the 
					//   allocation.
					//
					if ( ResizeTest( Delta,Move ) )
						{
						//
						//   One of the sizes is not within the
						//   allocation range of the heap.  So
						//   I have to punt and reallocate.
						//   
						NewMemory = 
							(
							ExternalCache -> New
								( 
								False,
								(NewSpace = NewSize)
								)
							);
#ifdef ENABLE_HEAP_STATISTICS

						//
						//   Update the allocation statistics.
						//
						if ( NewSize > MaxNewSize )
							{ MaxNewSize = NewSize; }

						NewMisses ++;
						TotalNewSize += NewSize;
#endif
						}
					else
						{
						//
						//   If the new size is unchanged or smaller
						//   then just return the current allocation.
						//   If the new size is larger then we must
						//   fail the call.
						//
						if ( Delta <= 0 )
							{
							//
							//   The amount of memory allocated for  
							//   this request is unchanged so return  
							//   the current size.
							//
							if ( Space != NULL )
								{ (*Space) = Size; }

							return Address; 
							}
						else
							{ return ((VOID*) AllocationFailure); }
						}
					}
				
				//
				//   We need to make sure we were able to allocate
				//   the new memory otherwise the copy will fail.
				//
				if ( NewMemory != ((VOID*) AllocationFailure) )
					{
					//
					//   Copy the contents of the old allocation 
					//   to the new allocation.
					//
					memcpy
						( 
						((void*) NewMemory),
						((void*) Address),
						((int) Smallest) 
						);

					//
					//   If needed return the actual amount of  
					//   space allocated for this request.
					//
					if ( Space != NULL )
						{ (*Space) = NewSpace; }

					//
					//   Delete the old allocation unless we
					//   need to keep it around.
					//
					if ( ! NoDelete )
						{
						//
						//   Delete the old allocation.
						//
						if ( ! Delete( Address,Size ) )
							{ Failure( "Deleting allocation in Resize" ); }
						}

					//
					//   Zero the memory if the needed.
					//
					if ( Zero )
						{
						REGISTER SBIT32 Difference = (NewSpace - Smallest);

						//
						//   If the new size is larger than 
						//   old size then zero the end of the
						//   new allocation.
						//
						if ( Difference > 0 )
							{ 
							REGISTER CHAR *Array = ((CHAR*) NewMemory);

							ZeroMemory( & Array[ Smallest ],Difference ); 
							} 
						}	
#ifdef ENABLE_HEAP_STATISTICS

					//
					//   Update the allocation statistics.
					//
					if ( Smallest > MaxCopySize )
						{ MaxCopySize = Smallest; }

					CopyMisses ++;
					TotalCopySize += Smallest;
#endif
					}

				return NewMemory;
				}
			}
		}

	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This pretty much a do nothing   */
    /*   as we do this automatically anyway.  The only thing we can     */
    /*   do is free any space the user suggested keeping earlier.       */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Truncate( SBIT32 MaxFreeSpace )
	{
	REGISTER BOOLEAN Result = True;

	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   Flush all the caches and to free up
		//   as much space as possible.
		//
		for ( Count=0;Count < CachesSize;Count ++ )
			{
			Result =
				(
				(Caches[ Count ] -> Truncate())
					&&
				(Result)
				); 
			}

		//
		//   We slave all available free space in the top
		//   bucket so force it to be released.
		//
		TopCache -> ReleaseSpace
			(
			(MaxFreeSpace / (TopCache -> GetAllocationSize()))
			);
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   We release the locks so others can use the heap.               */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::UnlockAll( BOOLEAN Partial )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   Decrement the per thread lock count.
		//
		Find -> DecrementLockCount();

		//
		//   We release the locks only if we have claimed 
		//   them earlier.
		//
		if ( (Find -> GetLockCount()) == 0 )
			{
			//
			//   Now release all the heap locks we claimed
			//   earlier and unfreeze the heap.
			//
			NewPage -> ReleaseNewPageLock();

			Find -> ReleaseFindExclusiveLock();

			//
			//   When we destroy the heap we hold on
			//   to the cache locks to prevent errors.
			//
			if ( ! Partial )
				{
				REGISTER SBIT32 Count;

				//
				//   Now release all the cache locks we claimed
				//   earlier and unfreeze the cache.
				//
				for ( Count=0;Count < CachesSize;Count ++ )
					{ Caches[ Count ] -> ReleaseCacheLock(); }
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify of a memory allocation.                                 */
    /*                                                                  */
    /*   We need to verify the details of a memory allocation.          */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.  Finally, we check that the element       */
    /*   is not in the cache waiting to be allocated or freed.          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Verify( VOID *Address,SBIT32 *Size )
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SEARCH_PAGE Details;
		AUTO SBIT32 NewSize;

		//
		//   We extract the size of the allocation and  
		//   any associated allocation information.
		//   to see if it is present.
		//
		if ( Find -> Details( Address,& Details,TopCache,& NewSize ) )
			{
			//
			//   We need to be careful to make sure this 
			//   element is actually allocated.
			//
			if ( Details.Found )
				{
				//
				//   We know that the element appears to be 
				//   allocated but it may be in the cache
				//   somewhere so ensure this is not the case.
				//
				if ( (NewSize > 0) && (NewSize <= MaxCacheSize) )
					{
					if ( Details.Cache -> SearchCache( Address ) )
						{ return False; }
					}

				//
				//   We have shown that the element is active
				//   so return the size if requested.
				//
				if ( Size != NULL )
					{ (*Size) = NewSize; }

				return True;
				}
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   whay anybody might want to do this given the rest of the       */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Walk
		( 
		BOOLEAN						  *Active,
		VOID						  **Address,
		SBIT32						  *Size 
		)
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We walk the heap and find the next allocation
		//   along with some basic information.
		//
		if ( Find -> Walk( Active,Address,TopCache,Size ) )
			{
			//
			//   We know that the element appears to be 
			//   allocated but it may be in the cache
			//   somewhere so ensure this is not the case.
			//
			if ( ((*Size) > 0) && ((*Size) <= MaxCacheSize) )
				{
				if ( FindCache( (*Size) ) -> SearchCache( (*Address) ) )
					{ (*Active) = False; }
				}

			return True;
			}
		}

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   We would like to destroy the heap at the end of the run        */
    /*   just to be tidy.  However, to do this we need to know that     */
    /*   all of the other destructors have been called and that the     */
    /*   application will not request more memory or use any existing   */
    /*   allocations.  We can't know this without help from the         */
    /*   compiler and OS.                                               */
    /*                                                                  */
    /********************************************************************/

HEAP::~HEAP( VOID )
	{
	REGISTER SBIT32 Count;

	//
	//   We mark the heap as inactive.
	//
	Active = False;

	//
	//   We claim all of the heap locks to freeze
	//   all new allocations or deletions.
	//
	LockAll();

	//
	//   Now reset all the caches.
	//
	for ( Count=0;Count < CachesSize;Count ++ )
		{ Caches[ Count ] -> DeleteAll(); }

	//
	//   Delete the heap.
	//
	NewPage -> DeleteAll( False );

	//
	//   We release any of the shared locks we 
	//   cliamed earlier.
	//
	UnlockAll( True );
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Deal with heap statistics.
	//
	if ( Statistics != NULL ) 
		{
		//
		//   Print all the statistics.
		//
		PrintDebugStatistics();

		//
		//   Deallocate the area.
		//
		Rockall -> DeleteArea
			( 
			((VOID*) Statistics),
			(MaxCacheSize * sizeof(SBIT32)),
			False
			); 
		}
#endif

	//
	//   Delete the heap mapping tables.
	//
	if ( SizeToCache1 != NULL ) 
		{ 	
		//
		//   Deallocate the area.
		//
		Rockall -> DeleteArea
			( 
			((VOID*) SizeToCache1),
			(MaxTable1 + MaxTable2),
			False
			); 
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\heappch.hpp ===
#ifndef _HEAP_PCH_HPP_
#define _HEAP_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Bucket.hpp"
#include "BucketList.hpp"
#include "Cache.hpp"
#include "Connections.hpp"
#include "Find.hpp"
#include "FindList.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"
#include "NewPageList.hpp"
#include "Page.hpp"
#include "Rockall.hpp"

#include "LibraryPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\heap.hpp ===
#ifndef _HEAP_HPP_
#define _HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "NewPage.hpp"
#include "Prefetch.hpp"
#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class BUCKET;
class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   The heap interface.                                            */
    /*                                                                  */
    /*   The traditional memory allocation interface only supports      */
    /*   a single allocation heap.  This memory allocator supports      */
    /*   multiple allocation heaps.  However, the interface nicely      */
    /*   hides this so at this point we are back to the traditional     */
    /*   single heap interface.                                         */
    /*                                                                  */
    /********************************************************************/

class HEAP : public ENVIRONMENT, public COMMON
    {
		//
		//   Private data.
		//
		//   The heap is the top level container of all the
		//   functionality in the other classes.  The 'Active'
		//   flag indicates if the heap has been initialized.
		//   The 'MaxFreePages' controls the amount of free
		//   space the heap will slave before it starts to
		//   return it the the external allocator.  The
		//   'SmallestParentMask' is mask that shows which 
		//   parts of an address can be safely masked off
		//   and still ensure a hit in the find lookaside
		//   cache.  The 'ThreadSafe' flag indicates whether
		//   locking being used.
		//
		BOOLEAN						  Active;
		SBIT32						  MaxFreePages;
		BIT32						  SmallestParentMask;
		BOOLEAN						  ThreadSafe;

		//
		//   A heap is merely a collection of fixed sized
		//   allocation buckets (each with an optional cache).
		//   The 'CachesSize' is the total number of buckets.
		//   The 'MinCacheSize' is the allocation size of the
		//   smallest bucket.  The 'MidCacheSize' is the size
		//   of the bucket where the stride changes.  The
		//   'MaxCacheSize' is the allocation size of the 
		//   largest bucket externally visable.
		//
		SBIT32						  CachesSize;
		SBIT32						  MinCacheSize;
		SBIT32						  MidCacheSize;
		SBIT32						  MaxCacheSize;

		//
		//   A key function of the heap is to convert the
		//   requested allocation size into a pointer to
		//   the appropriate bucket (and cache).  This has
		//   to be very fast and is achieved using a direct
		//   lookup (i.e. an array).  The lookup array 
		//   consists of two sections (i.e. for small sizes
		//   and large sizes) to minimize space.  The 
		//   'MaxTable1' and 'MaxTable2' variables contain 
		//   the size of each section of the array.  The 
		//   'ShiftSize1' and 'ShiftSize2' variables contain
		//   the shift that should be applied to the size to
		//   obtain the appropriate index.  The 'SizeToCache1'
		//   and 'SizeToCache2' pointers refer to the direct
		//   lookup tables.
		//   
		SBIT32						  MaxTable1;
		SBIT32						  MaxTable2;
		SBIT32						  ShiftSize1;
		SBIT32						  ShiftSize2;
		CACHE                         **SizeToCache1;
		CACHE                         **SizeToCache2;

		//
		//   The heap needs to have access to most of the 
		//   other classes.  The 'Caches' class sits on
		//   top of an allocation bucket which owns all
		//   the allocated memory for a given size.  The
		//   'ExternalCache' is a special bucket that 
		//   contains weird sized pages.  The 'Find' class
		//   translates allocation addresses to page 
		//   descriptions.  The 'Rockall' class is needed
		//   to gain access to the external allocation APIs.
		//   The 'NewPage' class owns all page descriptions
		//   and plays a significant role in whole heap
		//   operations.  The 'TopCache' is the largest 
		//   bucket size and owns almost all the externally
		//   allocated memory.
		//
		CACHE						  **Caches;
		CACHE						  *ExternalCache;
		FIND						  *Find;
		NEW_PAGE					  *NewPage;
		PREFETCH					  Prefetch;
		ROCKALL						  *Rockall;
		CACHE						  *TopCache;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Statistics data.
		//
		//   A key feature of this heap is its ability to be
		//   significantly reconfigured at run time.  A great
		//   deal of complexity could have been removed if 
		//   certain static choices had been made.  Although
		//   this flexibility is nice the support of statistics
		//   here allows precise information to be collected so
		//   to enable the value of this to be maximized.
		//   
		//
		SBIT32						  CopyMisses;
		SBIT32						  MaxCopySize;
		SBIT32						  MaxNewSize;
		SBIT32						  NewMisses;
		SBIT32						  Reallocations;
		SBIT32						  *Statistics;
		SBIT32						  TotalCopySize;
		SBIT32						  TotalNewSize;
#endif

   public:
		//
		//   Public functions.
		//
		//   The heap exports the high level interface
		//   out to the world.  Any request a developer
		//   can make must come through one of these
		//   functions.
		//
        HEAP
			(
			CACHE					  *Caches1[],
			CACHE					  *Caches2[],
			SBIT32					  MaxFreeSpace,
			FIND					  *NewFind,
			NEW_PAGE				  *NewPages,
			ROCKALL					  *NewRockall,
			SBIT32					  Size1,
			SBIT32					  Size2,
			SBIT32					  Stride1,
			SBIT32					  Stride2,
			BOOLEAN					  NewThredSafe
			);

		BOOLEAN Delete( VOID *Address,SBIT32 Size = NoSize );

		VOID DeleteAll( BOOLEAN Recycle = True );

		BOOLEAN Details( VOID *Address,SBIT32 *Size = NULL );

		VOID LockAll( VOID );

		BOOLEAN MultipleDelete
			( 
			SBIT32					  Actual,
			VOID					  *Array[],
			SBIT32					  Size = NoSize
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested,
			SBIT32					  Size,
			SBIT32					  *Space = NULL,
			BOOLEAN					  Zero = False
			);

		VOID *New
			( 
			SBIT32					  Size,
			SBIT32					  *Space = NULL,
			BOOLEAN					  Zero = False
			);

		VOID *Resize
			( 
			VOID					  *Address,
			SBIT32					  NewSize,
			SBIT32					  Move = 1,
			SBIT32					  *Space = NULL,
			BOOLEAN					  NoDelete = False,
			BOOLEAN					  Zero = False
			);

		BOOLEAN Truncate( SBIT32 MaxFreeSpace = 0 );

		VOID UnlockAll( BOOLEAN Partial = False );

		BOOLEAN Verify( VOID *Address,SBIT32 *Size = NULL );

		BOOLEAN Walk
			( 
			BOOLEAN					  *Active,
			VOID					  **Address,
			SBIT32					  *Size 
			);

        ~HEAP( VOID );

		//
		//   Public inline functions.
		//
		//   Although these functions are public they mostly
		//   intended for internal consumption and are not
		//   to be called externally.
		//
		INLINE SBIT32 GetMaxFreePages( VOID )
			{ return MaxFreePages; }

		INLINE BOOLEAN KnownArea( VOID *Address )
			{ return (Find -> KnownArea( Address,TopCache )); }

		INLINE VOID *SpecialNew( SBIT32 Size )
			{ return NewPage -> NewCacheStack( Size ); }

	private:
		//
		//   Private functions.
		//
		//   All of the statistical information is 
		//   generated and output when the heaps
		//   destructor executes.
		//
		CACHE *FindCache( SBIT32 Size );
#ifdef ENABLE_HEAP_STATISTICS

		VOID PrintDebugStatistics( VOID );
#endif
		//
		//   Private inline functions.
		//
		//   The notion that resizing an allocation is 
		//   cheap has worked its way into the minds of 
		//   a large number of developers.  As a result
		//   parameter has been added to the function to
		//   allow the actual behavior to be controlled.
		//
		INLINE BOOLEAN ResizeTest( SBIT32 Delta,SBIT32 Move )
			{
			return
				(
				((Move > 0) && ((((Delta >= 0) ? Delta : -Delta) >= Move)))
					||
				((Move < 0) && ((Delta > 0) || (Delta <= Move)))
				);
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        HEAP( CONST HEAP & Copy );

        VOID operator=( CONST HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\heappch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\newpage.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants set overall limits on the number and size of     */
    /*   page descriptions for pages within the memory allocator.       */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinNewPages			  = 1;
CONST SBIT32 VectorRange			  = ((2 << 15) - 1);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   A 'PAGE' structure has various fixed fields and a variable     */
    /*   sized allocation bit vector.  When this class is initialized   */
    /*   the user is required to supply us with an array that details   */
    /*   the sizes of allocation bit vectors supported.                 */
    /*                                                                  */
    /********************************************************************/

NEW_PAGE::NEW_PAGE
		(
		FIND						  *NewFind,
		SBIT32						  NewPageSizes[],
		ROCKALL						  *NewRockall,
		SBIT32						  Size,
		BOOLEAN						  NewThreadSafe 
		)
    {
	REGISTER SBIT32 DefaultRootSize = (NewRockall -> NaturalSize());
	REGISTER SBIT32 ReservedBytes = (Size * sizeof(NEW_PAGES));
	REGISTER SBIT32 SpareBytes = (DefaultRootSize - ReservedBytes);
	REGISTER SBIT32 StackSize = (SpareBytes / sizeof(VOID*));

	//
	//   We need to make sure that we appear to have a valid
	//   array of 'NewPageSizes' and that the bit vector sizes
	//   do not exceed the memory addressing range.
	//
	if 
			(
			PowerOfTwo( DefaultRootSize )
				&&
			(DefaultRootSize >= PageSize())
				&&
			(Size >= MinNewPages) 
				&&
			((NewPageSizes[ (Size-1) ] * OverheadBitsPerWord) <= VectorRange)
			)
		{
		REGISTER VOID *NewMemory = 
			(
			NewRockall -> NewArea
				( 
				(DefaultRootSize-1),
				DefaultRootSize,
				False
				)
			);

		//
		//   We are in big trouble if we can not allocate space
		//   to store this initial control information.  If the
		//   allocation fails we are forced to exit and the whole  
		//   memory allocator becomes unavailable.
		//
		if ( NewMemory != AllocationFailure )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 LastSize = 0;

			//
			//   We are now ready to setup the configuration
			//   information.
			//
			MaxCacheStack = 0;
			MaxNewPages = Size;
			MaxStack = StackSize;

			NaturalSize = DefaultRootSize;
			RootCoreSize = DefaultRootSize;
			RootStackSize = 0;
			ThreadSafe = NewThreadSafe;
			TopOfStack = 0;
			Version = 0;

			CacheStack = NULL;
			NewPages = ((NEW_PAGES*) NewMemory);
			Stack = ((VOID**) & NewPages[ Size ]);

			Find = NewFind;
			Rockall = NewRockall;
			TopCache = NULL;

			//
			//   Create a lists for the various page 
			//   sizes and prepare them for use.
			//
			for ( Count=0;Count < Size;Count ++ )
				{
				REGISTER SBIT32 CurrentSize = NewPageSizes[ Count ];

				if ( CurrentSize > LastSize )
					{
					REGISTER NEW_PAGES *NewPage = & NewPages[ Count ];

					//
					//   Create a list for the current
					//   size and fill in all the related
					//   details.
					//
					NewPage -> Elements = (CurrentSize * OverheadBitsPerWord);
					PLACEMENT_NEW( & NewPage -> ExternalList,LIST );
					PLACEMENT_NEW( & NewPage -> FullList,LIST );
					PLACEMENT_NEW( & NewPage -> FreeList,LIST );
					NewPage -> Size = (CurrentSize * sizeof(BIT32));

					LastSize = CurrentSize;
					}
				else
					{ Failure( "Sizes in constructor for NEW_PAGES" ); }
				}
			}
		else
			{ Failure( "No memory in constructor for NEW_PAGES" ); }
		}
	else
		{ Failure( "Setup of pages in constructor for NEW_PAGES" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Create a new page.                                             */
    /*                                                                  */
    /*   Create a new 'PAGE' structure and prepare it for use.  If      */
    /*   we don't already have any pages of the required size then      */
    /*   allocate memory, create new 'PAGE' structures and link them    */
    /*   into the appropriate free chain.                               */
    /*                                                                  */
    /********************************************************************/

PAGE *NEW_PAGE::CreatePage( CACHE *Cache,SBIT32 NewSize )
    {
	REGISTER PAGE *NewPage = ((PAGE*) AllocationFailure);
	REGISTER SBIT16 SizeKey = (Cache -> GetSizeKey());

	//
	//   All allocations are made from fixed sized
	//   pages.  These pages have a bit vector to
	//   keep track of which elements are allocated
	//   and available.  The 'SizeKey' is an index
	//   into 'NewPages[]' that will supply a page
	//   that has a big enough the bit vector.
	//
#ifdef DEBUGGING
	if ( (SizeKey >= 0) && (SizeKey < MaxNewPages) )
		{
#endif
		REGISTER NEW_PAGES *Current;

		//
		//   When there is a potential for multiple threads 
		//   we claim the lock.
		//
		ClaimNewPageLock();

		//
		//   We allocate 'PAGE' structures as we need them
		//   and link them together in the free list.
		//   If we don't have any structures available we 
		//   allocate some more and add tem to the list.
		//
		if ( (Current = & NewPages[ SizeKey ]) -> FreeList.EndOfList() )
			{
			REGISTER SBIT32 ArrayElements = (Current -> Size - MinVectorSize);
			REGISTER SBIT32 ArraySize = (ArrayElements * sizeof(BIT32));
			REGISTER SBIT32 TotalSize = (sizeof(PAGE) + ArraySize);
			REGISTER SBIT32 FinalSize = CacheAlignSize( TotalSize );
			REGISTER SBIT32 TotalPages = (NaturalSize / FinalSize);

			//
			//   Nasty, we have run out of stack space.  If
			//   we can not grow this table then the heap
			//   will not be able to expand any further.
			//
			if ( TopOfStack >= MaxStack )
				{
				//
				//   Try to grow the stack size.
				//
				ResizeStack();

				//
				//   Update the pointer as the table may
				//   have moved.
				//
				Current = & NewPages[ SizeKey ];
				}

			//
			//   We may find ourseleves in a situation where
			//   the size of the new 'PAGE' structure is larger
			//   than the natural allocation size or the stack
			//   is full so we can't create new pages.  If so we
			//   refuse to create any new pages so any allocation
			//   requests for this size will fail.
			//
			if ( (TotalPages > 0) && (TopOfStack < MaxStack) )
				{
				REGISTER CHAR *NewMemory = 
					((CHAR*) VerifyNewArea( (NaturalSize-1),NaturalSize ));

				//
				//   We may also find ourselves unable to 
				//   anymore memory.  If so we will fail the
				//   request to create a page.
				//
				if ( NewMemory != AllocationFailure )
					{
					REGISTER SBIT32 Count;

					//
					//   Add the new allocation to stack of
					//   outstanding external allocations.
					//
					Stack[ (TopOfStack ++) ] = ((VOID*) NewMemory);

					//
					//   Add the new elements to the free list
					//   for the current allocation size.
					//
					for 
							( 
							Count=0;
							Count < TotalPages;
							Count ++, (NewMemory += FinalSize)
							)
						{
						REGISTER PAGE *Page = ((PAGE*) NewMemory);

						//
						//   The page has been allocated but not 
						//   initialized so call the constructor
						//   and the destructor to get it into
						//   a sane state.
						//
						PLACEMENT_NEW( NewPage,PAGE ) 
							(
							NULL,
							NULL,
							0,
							NULL,
							0
							);

						PLACEMENT_DELETE( Page,PAGE );

						//
						//   Finally add the page to the free list
						//   so it can be used.
						//
						Page -> InsertInNewPageList( & Current -> FreeList ); 
						}
					}
				}
			}

		//
		//   We are now ready to create a new allocation
		//   page.  We start by requesting a page from
		//   the parent bucket.  If this works we know that 
		//   we have almost everthing we need to create the 
		//   new page.
		//
		if ( ! Current -> FreeList.EndOfList() )
			{
			REGISTER VOID *NewMemory;
			REGISTER CACHE *ParentPage = (Cache -> GetParentCache());

			NewPage = (PAGE::FirstInNewPageList( & Current -> FreeList ));

			//
			//   We have found a suitable page structure
			//   so remove it from the free list.
			//
			NewPage -> DeleteFromNewPageList( & Current -> FreeList );

			//
			//   Release any lock we might have as another
			//   thread may be waiting to delete a page and
			//   be holding the lock we need in order to
			//   create a page.
			//
			ReleaseNewPageLock();

			//
			//   We need to allocate memory to store the users 
			//   data.  After all we are the memory allocator
			//   and that is our job in life.  Typically, we do
			//   this by making a recursive internal request
			//   from a larger bucket.  Nonetheless, at some point
			//   we will reach the 'TopCache' and will be forced
			//   to request memory from an external source.
			//
			if ( (Cache -> TopCache()) || (NewSize != NoSize) )
				{
				REGISTER AlignMask = (TopCache -> GetPageSize()-1);

				//
				//   We allocate memory externally in large blocks 
				//   and sub-divide these allocations into smaller
				//   blocks.  The only exception is if the caller 
				//   caller is requesting some weird size in which
				//   case we request memory directly from the
				//   external allocator (usually the OS).
				//
				if ( NewSize == NoSize )
					{ NewSize = (Cache -> GetPageSize()); }

				//
				//   All externally allocated memory belongs
				//   to the global root.  Thus, it will be 
				//   found in the first lookup in the find
				//   table.
				//
				ParentPage = ((CACHE*) GlobalRoot);

				//
				//   Allocate from the external allocator.
				//
				NewMemory = (VerifyNewArea( AlignMask,NewSize ));
				}
			else
				{
				//
				//   Allocate memory from a larger cache and then
				//   sub-divide it as needed.
				//
				NewMemory = 
					(Cache -> GetParentCache() -> CreateDataPage()); 
				}

			//
			//   Reclaim any lock we have had earlier so 
			//   we can update the the new page structure.
			//
			ClaimNewPageLock();

			//
			//   Lets make sure we sucessfully allocated the
			//   memory for the data page.
			//
			if ( NewMemory != AllocationFailure )
				{
				//
				//   We now have everything we need so lets
				//   create a new page.
				//
				PLACEMENT_NEW( NewPage,PAGE ) 
					(
					NewMemory,
					Cache,
					NewSize,
					ParentPage,
					(Version += 2)
					);

				//
				//   Finally lets add the new page to the various
				//   lists so we can quickly find it again later.
				//
				Cache -> InsertInBucketList( NewPage );

				Cache -> InsertInFindList( NewPage );

				NewPage -> InsertInNewPageList
					(
					(Cache -> TopCache())
						? & Current -> ExternalList 
						: & Current -> FullList 
					); 
				}
			else
				{
				//
				//   We were unable to allocate any data space
				//   for this new page so lets free the page 
				//   description and exit.
				//
				NewPage -> InsertInNewPageList( & Current -> FreeList );

				NewPage = ((PAGE*) AllocationFailure);
				}
			}

		//
		//   We have finished so release the lock now. 
		//
		ReleaseNewPageLock();
#ifdef DEBUGGING
		}
	else
		{ Failure( "The page size key is out of range" ); }
#endif

	return NewPage;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   Delete an entire heap and return all the memory to the         */
    /*   top level pool or the external allocator (usually the OS).     */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::DeleteAll( BOOLEAN Recycle )
    {
	REGISTER SBIT32 Count;

	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We assume at this point that we have blocked
	//   all memory allocation and dealloction requests.
	//   We are now going to walk through the various lists
	//   and just blow away things.  We are going to
	//   do this in a tidy way just in case the caller
	//   wants to use the heap again later.
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];
		REGISTER PAGE *Page;
		REGISTER PAGE *NextPage;

		//
		//   All allocations that appear in the full list
		//   have been sub-allocated from larger pages in
		//   almost all cases.
		//
		for
				(
				Page = (PAGE::FirstInNewPageList( & Current -> FullList ));
				! Page -> EndOfNewPageList();
				Page = NextPage
				)
			{
			REGISTER VOID *Address = (Page -> GetAddress());
			REGISTER CACHE *Cache = (Page -> GetCache());
			REGISTER SBIT32 PageSize = (Page -> GetPageSize());

			//
			//   We decide here how we will deal with the page.
			//   If it is empty, non-standard or we are not
			//   recycling we will blow it away.  If not we
			//   simply reset it for later use.
			//
			if ( (Page -> Empty()) || (PageSize != NoSize) || (! Recycle) )
				{
				//
				//   We need to release any associated data page.
				//   If this is the top level then release the
				//   memory back to the external allocator.  If 
				//   not we release it back to the parent bucket.
				//
				if ( PageSize == NoSize )
					{
					//
					//   If we are just recycling then we cleanly
					//   delete the page.  If not then we know it
					//   will be blown away later so why bother.
					//
					if ( Recycle )
						{
						REGISTER CACHE *ParentCache = 
							(Cache -> GetParentCache());

						if ( ! (ParentCache -> DeleteDataPage( Address )) )
							{ Failure( "Reset data page in DeleteAll" ); }
						}
					}
				else
					{ Rockall -> DeleteArea( Address,PageSize,True ); }

				//
				//   We may have been blowing away pages  
				//   randomly and now we are about to destroy 
				//   the current page.  So lets figure out 
				//   what page comes next before we continue.
				//
				NextPage = (Page -> NextInNewPageList());

				//
				//   If the page is not full it will in a 
				//   bucket list somewhere.  We need to remove
				//   it as we are about to delete the page.
				//
				if ( ! Page -> Full() )
					{ Cache -> DeleteFromBucketList( Page ); }

				//
				//   Delete the page from the find list and the
				//   new page list.
				//
				Cache -> DeleteFromFindList( Page );

				Page -> DeleteFromNewPageList( & Current -> FullList );

				//
				//   Delete the page structure.
				//
				PLACEMENT_DELETE( Page,PAGE );

				//
				//   Finally add the page to the free list
				//   so it can be recycled.
				//
				Page -> InsertInNewPageList( & Current -> FreeList );
				}
			else
				{
				//
				//   We know that the current page has at 
				//   least one allocation on it so instead
				//   of deleting it we will mark it as free
				//   (except for any sub-allocations) and
				//   leave it around for next time.  If it
				//   is never used the next top level 
				//   'DeleteAll' will delete it.
				//
				Page -> DeleteAll();

				//
				//   We have now reset the current page so  
				//   lets figure out what page comes next.
				//
				NextPage = (Page -> NextInNewPageList());
				}
			}

		//
		//   We have a choice to make.  If we intend to
		//   use this heap again we keep all top level
		//   allocated memory in a list ready for reuse.
		//   If not we return it to the external allocator
		//   (usually the OS).
		//   
		if ( ! Recycle )
			{
			//
			//   The external allocations list contains an
			//   entry for every externally allocated page
			//   except those allocated for special internal 
			//   use within this class or for weird sized
			//   pages that appeared above in the 'FullList'.
			//
			for
					(
					Page = (PAGE::FirstInNewPageList( & Current -> ExternalList ));
					! Page -> EndOfNewPageList();
					Page = (PAGE::FirstInNewPageList( & Current -> ExternalList ))
					)
				{
				REGISTER VOID *Address = (Page -> GetAddress());
				REGISTER CACHE *Cache = (Page -> GetCache());
				REGISTER SBIT32 PageSize = (Page -> GetPageSize());

				//
				//   We no longer need this top level allocation
				//   so return it to the external allocator.
				//
				Rockall -> DeleteArea( Address,PageSize,True );

				//
				//   If the page is not full it will in a 
				//   bucket list somewhere.  We need to remove
				//   it as we are about to delete the page.
				//
				if ( ! Page -> Full() )
					{ Cache -> DeleteFromBucketList( Page ); }

				//
				//   Delete the page from the find list and the
				//   new page list.
				//
				Cache -> DeleteFromFindList( Page );

				Page -> DeleteFromNewPageList( & Current -> ExternalList );

				//
				//   Delete the page structure.
				//
				PLACEMENT_DELETE( Page,PAGE );

				//
				//   Finally add the page to the free list
				//   so it can be recycled.
				//
				Page -> InsertInNewPageList( & Current -> FreeList );
				}
			}
		}

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a page.                                                 */
    /*                                                                  */
    /*   Delete a page structure, free the associated memory and        */
    /*   unlink it from the various allocation lists.                   */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::DeletePage( PAGE *Page )
    {
	REGISTER CACHE *Cache = Page -> GetCache();
	REGISTER SBIT16 SizeKey = Cache -> GetSizeKey();

	//
	//   All allocations are made from fixed sized
	//   pages.  These pages have a bit vector to
	//   keep track of which elements are allocated
	//   and available.  The 'SizeKey' is an index
	//   into 'NewPages[]' that will supply a page
	//   that has a big enough the bit vector.
	//
#ifdef DEBUGGING
	if ( (SizeKey >= 0) && (SizeKey < MaxNewPages) )
		{
#endif
		REGISTER VOID *Address = (Page -> GetAddress());
		REGISTER NEW_PAGES *Current = & NewPages[ SizeKey ];
		REGISTER SBIT32 Size = (Page -> GetPageSize());

		//
		//   We need to release any associated data page.
		//   If this is the top level then release the
		//   memory back to the external allocator.  If 
		//   not we release it back to the parent bucket.
		//
		if ( Size == NoSize )
			{ 
			REGISTER CACHE *ParentCache = (Cache -> GetParentCache());

			if ( ! (ParentCache -> DeleteDataPage( Address )) )
				{ Failure( "Deleting data page in DeletePage" ); }
			}
		else
			{ Rockall -> DeleteArea( Address,Size,True ); }

		//
		//   Claim the global lock so that the various  
		//   lists can be updated.
		//
		ClaimNewPageLock();

		//
		//   Remove the page from the lists and delete it.
		//
		Cache -> DeleteFromBucketList( Page );

		Cache -> DeleteFromFindList( Page );

		Page -> DeleteFromNewPageList
			(
			(Cache -> TopCache())
				? & Current -> ExternalList 
				: & Current -> FullList 
			); 

		PLACEMENT_DELETE( Page,PAGE );

		//
		//   Finally add the page to the free list
		//   so it can be recycled.
		//
		Page -> InsertInNewPageList( & Current -> FreeList );

		//
		//   We have finsihed so release the lock.
		//
		ReleaseNewPageLock();
#ifdef DEBUGGING
		}
	else
		{ Failure( "The page size key out of range in DeletePage" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find the correct index in new page.                            */
    /*                                                                  */
    /*   When we come to create a new page we need to make sure the     */
    /*   bit vector is large enough for the page.  We calculate this    */
	/*   here just once to save time later.                             */
    /*                                                                  */
    /********************************************************************/

SBIT16 NEW_PAGE::FindSizeKey( SBIT16 NumberOfElements )
    {
	REGISTER SBIT32 Count;

	//
	//   Search the table of page structures looking for 
	//   elements of a suitable size.  As the table is
	//   known to be in order of increasing size we can
	//   terminate the search as soon as we find something 
	//   large enough.
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];

		if ( NumberOfElements <= Current -> Elements )
			{ return ((SBIT16) Count); }
		}

	//
	//   Nasty, we don't seem to have anything large enough
	//   to store the bit vector.
	//
	return NoSizeKey;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new cache stack.                                      */
    /*                                                                  */
    /*   A cache stack is an array that contains memory allocations     */
    /*   that are waiting to be allocated or released.                  */
    /*                                                                  */
    /********************************************************************/

VOID *NEW_PAGE::NewCacheStack( SBIT32 Size )
    {
	REGISTER VOID *NewStack;

	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We ensure that there is enough space to make the
	//   allocation.  If not we request additional space
	//   and prepare it for use.
	//
	if ( (CacheStack == NULL) || ((MaxCacheStack + Size) > NaturalSize) )
		{
		//
		//   Nasty, we have run out of stack space.  If
		//   we can not grow this table then the heap
		//   will not be able to expand any further.
		//
		if ( TopOfStack >= MaxStack )
			{
			//
			//   Try to grow the stack size.
			//
			ResizeStack();
			}

		//
		//   We may find ourseleves in a situation where
		//   the size of the new stack structure is larger
		//   than the natural allocation size or the stack
		//   is full so we can't create new pages.  If so we
		//   refuse to create any new stacks.
		//
		if ( (Size < NaturalSize) && (TopOfStack < MaxStack) )
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) VerifyNewArea( (NaturalSize-1),NaturalSize ));

			//
			//   We may also find ourselves unable to 
			//   anymore memory.  If so we will fail the
			//   request to create a new cache stack.
			//
			if ( NewMemory != AllocationFailure )
				{
				//
				//   Add the new allocation to stack of
				//   outstanding external allocations.
				//
				Stack[ (TopOfStack ++) ] = ((VOID*) NewMemory);

				//
				//   Prepare the new memory block for use.
				//   
				CacheStack = NewMemory;
				MaxCacheStack = 0;
				}
			else
				{ return NULL; }
			}
		else
			{ return NULL; }
		}

	//
	//   We allocate some space for the new cache 
	//   stack and update and align the high water
	//   mark of the space used.
	//
	NewStack = ((VOID*) & CacheStack[ MaxCacheStack ]);

	MaxCacheStack += (Size + CacheLineMask);
	MaxCacheStack &= ~CacheLineMask;

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();

	return NewStack;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Resize the new page stack.                                     */
    /*                                                                  */
    /*   The new page stack holds pointers to all the pages owned       */
    /*   by the heap.  If this stack become full we must expand it      */
	/*   otherwise we can no longer grow the heap.                      */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::ResizeStack( VOID )
    {
	REGISTER SBIT32 NewSize = 
		(((RootStackSize <= 0) ? NaturalSize : RootStackSize) * 2);

	//
	//   Lets just check that we have really run out
	//   of stack space as expanding it really hurts.
	//
	if ( TopOfStack >= MaxStack )
		{
		REGISTER VOID *NewMemory = 
			(
			Rockall -> NewArea
				( 
				(NaturalSize-1),
				NewSize,
				False
				)
			);

		//
		//   We need to verify that we were able to allocate
		//   fresh memory for the stack.
		//
		if ( NewMemory != NULL )
			{
			REGISTER BOOLEAN DeleteStack = (RootStackSize > 0);
			REGISTER VOID *OriginalMemory = ((VOID*) Stack);
			REGISTER SBIT32 OriginalSize = (MaxStack * sizeof(VOID*));

			//
			//   All is well as we were able to allocate 
			//   additional space for the stack.  All we 
			//   need to do now is to update the control 
			//   information.
			//
			MaxStack = (NewSize / sizeof(VOID*));

			RootStackSize = NewSize;

			Stack = ((VOID**) NewMemory);

			//
			//   Now lets copy across the existing data. 
			//
			memcpy( NewMemory,OriginalMemory,OriginalSize );

			//
			//   When the heap is created we put the
			//   stack on the root core page.  Later
			//   we may move it if we expand it.  If
			//   this is the case we have to delete  
			//   the previous expansion here.
			//
			if ( DeleteStack )
				{
				//
				//   Deallocate the existing stack if it
				//   is not on the root core page.
				//
				Rockall -> DeleteArea( OriginalMemory,OriginalSize,False );
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify an external allocation.                                 */
    /*                                                                  */
    /*   All memory requests are allocated from the external allocator  */
	/*   at the highest level.  Here we have a wrapper for this         */
    /*   function so we can test the result and make sure it is sane.   */
    /*                                                                  */
    /********************************************************************/

VOID *NEW_PAGE::VerifyNewArea( SBIT32 AlignMask,SBIT32 Size )
	{
#ifdef DEBUGGING
	//
	//   We need to ensure that the alignment of the new
	//   external allocation is a power of two.
	//
	if ( PowerOfTwo( (AlignMask + 1) ) )
		{
#endif
		REGISTER VOID *NewMemory = 
			(Rockall -> NewArea( AlignMask,Size,True ));

		//
		//   We need to ensure that the external allocation
		//   request is sucessful.  If not it makes no sense
		//   to try and check it.
		//
		if ( NewMemory != ((VOID*) AllocationFailure) )
			{
			//
			//   We require the external memory allocator to always
			//   allocate memory on the requested boundary.  If not 
			//   we are forced to reject the supplied memory.
			//
			if ( (((SBIT32) NewMemory) & AlignMask) == 0 )
				{ return NewMemory; }
			else
				{ 
				Rockall -> DeleteArea( NewMemory,Size,True );
				
				Failure( "Alignment of allocation in VerifyNewArea" );
				}
			}
#ifdef DEBUGGING
		}
	else
		{ Failure( "Alignment is not a power of two in VerifyNewArea" ); }
#endif

	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN NEW_PAGE::Walk( SEARCH_PAGE *Details )
    {
	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We examine the current address to see if it
	//   is null.  If so then this is the start of a
	//   heap walk so we need to set it up.
	//
	if ( Details -> Address == NULL )
		{
		REGISTER SBIT32 Count;

		//
		//   Walk through the list of different sized
		//   page descriptions.
		//
		for ( Count=0;Count < MaxNewPages;Count ++ )
			{
			REGISTER NEW_PAGES *Current = & NewPages[ Count ];

			//
			//   Compute a pointer to the first element
			//   of the current size.
			//
			Details -> Page = 
				(PAGE::FirstInNewPageList( & Current -> FullList ));

			//
			//   Examine the current list of full (or 
			//   partially full) pages.  If there is at  
			//   least one page then this is the starting 
			//   point for the heap walk.
			//
			if ( ! Details -> Page -> EndOfNewPageList() )
				{
				//
				//   Compute the starting address of the 
				//   heap walk.
				//
				Details -> Address = 
					(Details -> Page -> GetAddress());

				break;
				}
			}
		}
	else
		{
		REGISTER PAGE *LastPage = Details -> Page;

		//
		//   We have exhusted the current page so walk
		//   the list and find the next page.
		//
		Details -> Page = 
			(Details -> Page -> NextInNewPageList());

		//
		//   We need to ensure that we have not reached
		//   the end of the current list.
		//
		if ( Details -> Page -> EndOfNewPageList() )
			{
			REGISTER SBIT32 Count;
			REGISTER BOOLEAN Found = False;

			//
			//   We need to find a new page description
			//   list to walk so reset the current 
			//   address just in case we don't find 
			//   anything.
			//
			Details -> Address = NULL;

			//
			//   We have reached the end of the current
			//   list and we need to continue with the
			//   start of the next list.  However, we
			//   don't know which list we were using
			//   previously.  So first we identify the
			//   previous list and then select the next
			//   avaibale list.
			//
			for ( Count=0;Count < MaxNewPages;Count ++ )
				{
				REGISTER NEW_PAGES *Current = & NewPages[ Count ];

				//
				//   We search for the original list
				//   we were walking.
				//
				if ( ! Found )
					{
					//
					//   When we find the original list
					//   then we set a flag showing that
					//   the next available list is the
					//   target.
					//
					if 
							( 
							LastPage 
								== 
							(PAGE::LastInNewPageList( & Current -> FullList )) 
							)
						{ Found = True; }
					}
				else
					{
					//
					//   We have found the previous list
					//   so the first element of the next
					//   list seems a good place to continue.
					//
					Details -> Page = 
						(PAGE::FirstInNewPageList( & Current -> FullList ));

					//
					//   We check to make sure that the list
					//   has at least one active page.  If not
					//   it is worthless and we continue looking
					//   for a suitable list.
					//
					if ( ! Details -> Page -> EndOfNewPageList() )
						{
						//
						//   Compute the starting address for 
						//   the next page in the heap walk.
						//
						Details -> Address = 
							(Details -> Page -> GetAddress());

						break;
						}
					}
				}
			}
		else
			{ 
			//
			//   Compute the starting address for 
			//   the next page in the heap walk.
			//
			Details -> Address = 
				(Details -> Page -> GetAddress());
			}
		}

	//
	//   If we find a new heap page to walk we update
	//   the details.  We mark some entry's as exhusted
    //   so as to provoke other code to set them up.
	//
	if ( Details -> Address != NULL )
		{
		//
		//   Compute the new allocation details.
		//
		Details -> Page -> FindPage
			( 
			Details -> Address,
			Details,
			False 
			);
		}

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();

	return (Details -> Address != NULL);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory all the page structures and release any allocated      */
    /*   memory.                                                        */
    /*                                                                  */
    /********************************************************************/

NEW_PAGE::~NEW_PAGE( VOID )
    {
	REGISTER SBIT32 Count;

	//
	//   Delete all active allocations.
	//
	DeleteAll( False );

	//
	//   We are about to delete all of the memory 
	//   allocated by this class so destroy any
	//   internal pointers.
	//
	MaxCacheStack = 0;
	CacheStack = NULL;

	//
	//   We have now deleted all the memory allocated by
	//   this heap except for the memory  allocated directly 
	//   by this class.  Here we finish off the job by 
	//   deleting these allocations and reseting the internal 
	//   data structures.
	//
	for ( Count=0;Count < TopOfStack;Count ++ )
		{
		REGISTER VOID *Current = Stack[ Count ];

		Rockall -> DeleteArea( Current,NaturalSize,False );
		}

	TopOfStack = 0;

	//
	//   If we were forced to expand the root stack then
	//   release this additional memory now.
	//
	if ( RootStackSize > 0 )
		{
		//
		//   Deallocate root stack which previously 
		//   contained pointers to all the memory
		//   allocated by this class.
		//
		Rockall -> DeleteArea( ((VOID*) Stack),RootStackSize,False );
		}

	//
	//   Delete all the new page list headings just
	//   to be neat
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];

		PLACEMENT_DELETE( & Current -> ExternalList,LIST );
		PLACEMENT_DELETE( & Current -> FullList,LIST );
		PLACEMENT_DELETE( & Current -> FreeList,LIST );
		}

	//
	//   Deallocate root core page which previously 
	//   contained all the new page lists.
	//
	Rockall -> DeleteArea( ((VOID*) NewPages),RootCoreSize,False );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\newpagelist.hpp ===
#ifndef _NEW_PAGE_LIST_HPP_
#define _NEW_PAGE_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "FindList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The new page list.                                             */
    /*                                                                  */
    /*   The new page list links all the memory allocated by the low    */
    /*   level external allocator, or sub-divided pages or free pages   */
    /*   so they can be quickly found.                                  */
    /*                                                                  */
    /************************************************************